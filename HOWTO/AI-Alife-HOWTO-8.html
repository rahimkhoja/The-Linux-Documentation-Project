<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.21">
 <TITLE>GNU/Linux AI &amp; Alife HOWTO: Missing &amp; Dead</TITLE>
 <LINK HREF="AI-Alife-HOWTO-7.html" REL=previous>
 <LINK HREF="AI-Alife-HOWTO.html#toc8" REL=contents>
</HEAD>
<BODY>
Next
<A HREF="AI-Alife-HOWTO-7.html">Previous</A>
<A HREF="AI-Alife-HOWTO.html#toc8">Contents</A>
<HR>
<H2><A NAME="Missing &amp; Dead"></A> <A NAME="s8">8.</A> <A HREF="AI-Alife-HOWTO.html#toc8">Missing &amp; Dead</A>    </H2>


<P>This is my area for old or bad entries. The MIA section is for entires for
which I no longer have a valid home page. If you have any information
regarding where I can find these now please let me know. The Dead section
is for projects that seem dead. Moving them here allows me to keep my
the main sections clean while allowing for interested parties to
correct me in which case I can just move it back.</P>

<H2><A NAME="ss8.1">8.1</A> <A HREF="AI-Alife-HOWTO.html#toc8.1">MIA - Projects missing linkage.</A>
    </H2>

<P>
<DL>
<P>
<A NAME="AntWars"></A> </P>
<DT><B>AntWars</B><DD><P>
<UL>
<LI>Web site: http://ant-wars.net/</LI>
</UL>
</P>
<P>Ant Wars is a competition which pits clever programs against each
other to do battle and compete for food in virtual worlds. Each
contestant is a species of ant, which can visualize only the world
immediately around him and pheromones left by fellow and enemy ants.
Using this information, the ant brain (a simple state machine) must
guide the ant towards collecting food at his home ant hill, while
fending off or attacking enemies.</P>
<P>Clever use of pheromones and subtle behaviors can create large scale
tactics such as raiding, defense, harvesting, and scouting when many
ants cooperate.</P>

<P>
<A NAME="CASE"></A> </P>
<DT><B>CASE</B><DD><P>
<UL>
<LI>Web site: http://www.iu.hio.no/~cell/</LI>
<LI>FTP site: ftp://ftp.iu.hio.no/pub/</LI>
</UL>
</P>
<P>CASE (Cellular Automaton Simulation Environment) is a C++
toolkit for visualizing discrete models in two dimensions:
so-called cellular automata. The aim of this project is to
create an integrated framework for creating generalized cellular
automata using the best, standardized technology of the day.</P>

<P>
<A NAME="CLEARS"></A> </P>
<DT><B>CLEARS</B><DD><P>
<UL>
<LI>Web site: ????</LI>
</UL>
</P>
<P>The CLEARS system is an interactive graphical environment for
computational semantics. The tool allows exploration and
comparison of different semantic formalisms, and their
interaction with syntax. This enables the user to get an idea of
the range of possibilities of semantic construction, and also
where there is real convergence between theories.</P>

<P>
<A NAME="CLIG"></A> </P>
<DT><B>CLIG</B><DD><P>
<UL>
<LI>Web site: http://www.ags.uni-sb.de/~konrad/clig.html</LI>
</UL>
</P>
<P>CLIG is an interactive, extendible grapher for visualizing linguistic
data structures like trees, feature structures, Discourse
Representation Structures (DRS), logical formulas etc. All of these can
be freely mixed and embedded into each other. The grapher has been
designed both to be stand-alone and to be used as an add-on for
linguistic applications which display their output in a graphical
manner.</P>

<P>
<A NAME="Corewar VM"></A> </P>
<DT><B>Corewar VM</B><DD><P>
<UL>
<LI>Web site: http://www.jedi.claranet.fr/</LI>
</UL>
</P>
<P>This is a virtual machine written in Java (so it is a virtual machine
for another virtual machine !) for a Corewar game.</P>

<P>
<A NAME="DAI"></A> </P>
<DT><B>DAI</B><DD><P>
<UL>
<LI>Web site: http://starship.python.net/crew/gandalf/DNET/AI/</LI>
</UL>
</P>
<P>A library for the Python programming language that provides an
object oriented interface to the CLIPS expert system tool. It
includes an interface to COOL (CLIPS Object Oriented Language)
that allows:
<UL>
<LI>Investigate COOL classes</LI>
<LI>Create and manipulate with COOL instances</LI>
<LI>Manipulate with COOL message-handler's</LI>
<LI>Manipulate with Modules</LI>
</UL>
</P>

<P>
<A NAME="DHARMI"></A> </P>
<DT><B>DHARMI</B><DD><P>
<UL>
<LI>Web site: http://megazone.bigpanda.com/~wolf/DHARMI/</LI>
</UL>
</P>
<P>DHARMI is a high level spatial, tinker-toy like language who's
components are transparently administered by a background
process called the Habitat. As the name suggests, the language
was designed to make modelling prototypes and handle living
data. Programs can be modified while running. This is accomplished
by blurring the distinction between source code, program,
and data.</P>

<P>
<A NAME="Dunce"></A> </P>
<DT><B>Dunce</B><DD><P>
<UL>
<LI>Web site: http://www.boswa.com/boswabits/</LI>
</UL>
</P>
<P>Dunce is a simple chatterbot (conversational AI) and a language for
programming such chatterbots. It uses a basic regex pattern matching
and a semi-neural rule/response firing mechanism (with excitement/decay
cycles).</P>
<P>Dunce is listed about halfway down the page.</P>

<P>
<A NAME="EcoSim"></A> </P>
<DT><B>EcoSim</B><DD><P>
<UL>
<LI>Web site: http://www.offis.de/projekte/projekt.php?id=140</LI>
</UL>
</P>
<P>NOTE: the above web site has info on EcoSim but no code to download.</P>
<P>In EcoSim an ecosystem is described by all static and dynamic
properties of the individuals involved in the system as well as time
varying properties of the environment. Individuals change their state
over time or due to internal and external events. The environment is
also defined via dynamic objects which can change. Supports on the fly
analysis and animation of generated data. It is a C++ class library
designed to support individual-oriented modelling and simulation
of ecological systems.</P>

<P>
<A NAME="Evo"></A> </P>
<DT><B>Evo</B><DD><P>
<UL>
<LI>Web site: http://omicrongroup.org/evo/</LI>
</UL>
</P>
<P>Evo is a software development framework that allows developers to build
complex alife simulations. Using Evo, researchers can easily build
systems of independent agents interacting with one another and with
their environment. Evo implements biological operators such as genetic
recombination and mutation to evolve the behavior of agents so that
they are more adapted to their environment.</P>

<P>
<A NAME="Grany-3"></A> </P>
<DT><B>Grany-3</B><DD><P>
<UL>
<LI>Web site: http://zarb.org/&nbsp;gc/html/grany.html</LI>
</UL>
</P>
<P>Grany-3 is a full-featured cellular automaton simulator, made in C++
with Gtk--, flex++/bison++, doxygen and gettext, useful to granular
media physicists.</P>

<P>
<A NAME="IBAL"></A> </P>
<DT><B>IBAL</B><DD><P>
<UL>
<LI>Web site: http://www.eecs.harvard.edu/~avi/IBAL/</LI>
</UL>
</P>
<P>IBAL (pronounced "eyeball") is a general-purpose language for
probabilistic modeling, parameter estimation and decision making. It
generalizes Bayesian networks, hidden Markov models, stochastic context
free grammars, Markov decision processes, and allows many new
possibilities. It also provides a convenient programming-language
framework with libraries, automatic type checking and so on.</P>

<P>
<A NAME="IDEAL"></A> </P>
<DT><B>IDEAL</B><DD><P>
<UL>
<LI>Web site: http://yoda.cis.temple.edu:8080/ideal/</LI>
</UL>
</P>
<P>IDEAL is a test bed for work in influence diagrams and
Bayesian networks. It contains various inference algorithms
for belief networks and evaluation algorithms for influence
diagrams. It contains facilities for creating and editing
influence diagrams and belief networks.</P>
<P>IDEAL is written in pure Common Lisp and so it will run in
Common Lisp on any platform. The emphasis in writing IDEAL has
been on code clarity and providing high level programming
abstractions. It thus is very suitable for experimental
implementations which need or extend belief network
technology.</P>
<P>At the highest level, IDEAL can be used as a subroutine
library which provides belief network inference and influence
diagram evaluation as a package. The code is documented in a
detailed manual and so it is also possible to work at a lower
level on extensions of belief network methods.</P>
<P>IDEAL comes with an optional graphic interface written in
CLIM. If your Common Lisp also has CLIM, you can run the
graphic interface.</P>

<P>
<A NAME="Illuminator"></A> </P>
<DT><B>Illuminator</B><DD><P>
<UL>
<LI>Web site: http://documents.cfar.umd.edu/resources/source/illuminator.html</LI>
</UL>
</P>
<P>Illuminator is a toolset for developing OCR and Image
Understanding applications.  Illuminator has two major parts: a
library for representing, storing and retrieving OCR
information, heretofore called dafslib, and an X-Windows "DAFS"
file viewer, called illum. Illuminator and DAFS lib were
designed to supplant existing OCR formats and become a standard
in the industry. They particularly are extensible to handle more
than just English.</P>
<P>The features of this release:
<UL>
<LI>5 magnification levels for images</LI>
<LI>flagged characters and words</LI>
<LI>unicode support -- American, British, French, German,
Greek, Italian, MICR, Norwegian, Russian, Spanish, Swedish, 
keyboards </LI>
<LI>reads DAFS, TIFF's, PDA's (image only)</LI>
<LI>save to DAFS, ASCII/UTF or Unicode</LI>
<LI>Entity Viewer - shows properties, character choices,
bounding boxes image fragment for a selected entity, change 
type, change content, hierarchy mode</LI>
</UL>
</P>

<P>
<A NAME="Jet's Neural Architecture"></A> </P>
<DT><B>Jet's Neural Architecture</B><DD><P>
<UL>
<LI>Web site: http://www.voltar-confed.org/jneural/</LI>
</UL>
</P>
<P>Jet's Neural Architecture is a C++ framework for doing neural net
projects. The goals of this project were to make a fast, flexible
neural architecture that isn't stuck to one kind of net and to make
sure that end users could easily write useful applications. All the
documentation is also easily readable.</P>

<P>
<A NAME="Neural Networks at your Fingertips"></A> </P>
<DT><B>Neural Networks at your Fingertips</B><DD><P>
<UL>
<LI>Web site: http://www.neural-networks-at-your-fingertips.com/</LI>
</UL>
</P>
<P>A set of ANSI C packages that illustrate Adaline networks,
back-propagation, the Hopfield model, BAM, Boltzman, CPN, SOM, and
ART1. Coded in portable, self-contained ANSI C. With complete example
applications from a variety of well-known application domains.</P>

<P>
<A NAME="Neureka ANS"></A> </P>
<DT><B>Neureka ANS (nn/xnn)</B><DD><P>
<UL>
<LI>FTP site: ftp://ftp.ii.uib.no/pub/neureka/</LI>
</UL>
</P>
<P>nn is a high-level neural network specification language. The
current version is best suited for feed-forward nets, but
recurrent models can and have been implemented, e.g. Hopfield
nets, Jordan/Elman nets, etc.  In nn, it is easy to change
network dynamics. The nn compiler can generate C code or
executable programs (so there must be a C compiler available),
with a powerful command line interface (but everything may also
be controlled via the graphical interface, xnn). It is possible
for the user to write C routines that can be called from inside
the nn specification, and to use the nn specification as a
function that is called from a C program. Please note that no
programming is necessary in order to use the network models that
come with the system (`netpack').</P>
<P>xnn is a graphical front end to networks generated by the nn
compiler, and to the compiler itself. The xnn graphical
interface is intuitive and easy to use for beginners, yet
powerful, with many possibilities for visualizing network data.</P>
<P>NOTE: You have to run the install program that comes with this
to get the license key installed. It gets put (by default) in
/usr/lib. If you (like myself) want to install the package
somewhere other than in the /usr directory structure (the
install program gives you this option) you will have to set up
some environmental variables (NNLIBDIR &amp; NNINCLUDEDIR are
required). You can read about these (and a few other optional
variables) in appendix A of the documentation (pg 113).</P>

<P>
<A NAME="NEURObjects"></A> </P>
<DT><B>NEURObjects</B><DD><P>
<UL>
<LI>Web site: http://www.disi.unige.it/person/ValentiniG/NEURObjects/</LI>
</UL>
</P>
<P>NEURObjects is  a set   of C++ library   classes for neural networks
development.  The main goal of  the library consists in supporting
researchers and practitioners in developing new neural network methods
and applications, exploiting the potentialities  of object-oriented
design and  programming.  NEURObjects provides also general purpose
applications for classification problems and can be used for fast
prototyping  of inductive  machine learning applications.</P>

<P>
<A NAME="OSCAR"></A> </P>
<DT><B>OSCAR</B><DD><P>
<UL>
<LI>Web site: http://oscarhome.soc-sci.arizona.edu/ftp/OSCAR-web-page/oscar.html</LI>
</UL>
</P>
<P>The goal of the OSCAR project is the formulation of a general theory of
rationality and its implementation in an artificial rational agent. The
function of artificial agents is to draw conclusions and make decisions
on the basis of information supplied to them. OSCAR is a fully
implemented architecture for rational agents, based upon a general
purpose defeasible reasoner.  OSCAR is written in Common Lisp and is
free for educational and research purposes.</P>

<P>
<A NAME="PAI"></A> </P>
<DT><B>PAI</B><DD><P>
<UL>
<LI>Web site: http://utenti.quipo.it/claudioscordino/pai.html</LI>
</UL>
</P>
<P>AI (Programmable Artificial Intelligence) is a program capable of
having a conversation in its mother tongue, English. Written in
C++.</P>

<P>
<A NAME="pygene"></A> </P>
<DT><B>pygene</B><DD><P>
<UL>
<LI>Web site: http://www.freenet.org.nz/python/pygene/</LI>
</UL>
</P>
<P>pygene is a simple and easily understandable library for genetic
algorithms and genetic programming in python. Includes examples
such as the travelling salesman problem.</P>

<P>
<A NAME="PyIE"></A> </P>
<DT><B>PyIE</B><DD><P>
<UL>
<LI>repo: https://www.dfwpython.org/repo/Projects/PyIE/</LI>
</UL>
</P>
<P>PyIE is a hypothesis based, agenda driven, object oriented inference
engine written in Python. Inferencing modes include back chaining,
opportunistic forward chaining and explicit forward chaining. The
first-class object base supports metaclasses, classes, objects and
multiple, dynamic inheritance.  All objects are first class objects and
all attributes are slot values, i.e. data members attached to some
object.</P>
<P>PyIE uses a TMS (truth maintenance system) for first level (condition
change) non-monotonic reasoning. User defined metaclasses are being
explored to support second level (belief change) non-monotonic
reasoning.</P>

<P>
<A NAME="Python ANN"></A> </P>
<DT><B>Simple Neural Net (in Python)</B><DD><P>
<UL>
<LI>Web site: http://www.amk.ca/python/unmaintained/</LI>
</UL>
</P>
<P>Simple neural network code, which implements a class for 3-level
networks (input, hidden, and output layers). The only learning
rule implemented is simple backpropagation. No documentation (or
even comments) at all, because this is simply code that I use to
experiment with. Includes modules containing sample datasets
from Carl G. Looney's NN book. Requires the Numeric
extensions.</P>

<P>
<A NAME="Python Fuzzy Logic Module"></A> </P>
<DT><B>Python Fuzzy Logic Module</B><DD><P>
<UL>
<LI>FTP site: ftp://ftp.csh.rit.edu/pub/members/retrev/</LI>
</UL>
</P>
<P>A simple python module for fuzzy logic. The file is 'fuz.tar.gz' in
this directory. The author plans to also write a simple genetic
algorithm and a neural net library as well. Check the 00_index file in
this directory for release info.</P>

<P>
<A NAME="QUANT1"></A> </P>
<DT><B>QUANT1</B><DD><P>
<UL>
<LI>Web site: http://linux.irk.ru/projects/QUANT/</LI>
</UL>
</P>
<P>This project seems to have gone proprietary. The only trace I can find
via google is at
http://www.zurich.co.uk/strategicrisk/softwaresupport/Quant1.htm.</P>
<P>QUANT/1 stands for type QUANTifier. It aims to be an alternative to
Prolog-like (Resulutional-like) systems. Main features include a lack
of necessity for eliminating Quantifiers, scolemisation, ease of
comprehension, large scale formulae operation, acceptance of nonHorn
formulaes, and Iterative deeping. The actual library implemented in
this project is called ATPPCF (Automatic Theorem Prover in calculus of
Positively Constructed Formulae).</P>
<P>ATPPCF will be a library (inference engine) and an extension of the
Predicate Calculus Language as a new logical language. The library will
be incorporable in another software such as TCL, Python, Perl. The
engine's primary inference method will be the "search of inference in
language of Positively Constructed Formulas (PCFs)" (a subset of
Predicate Calculus well translated in both directions). The language
will be used as scripting language to the engine. But there will be
possibility to replace it with extensions languages of main software.</P>

<P>
<A NAME="SCNN"></A> </P>
<DT><B>SCNN</B><DD><P>
<UL>
<LI>Web site: http://www.uni-frankfurt.de/fb13/iap/e_ag_rt/SCNN/</LI>
</UL>
</P>
<P>SCNN is an universal simulating system for Cellular Neural
Networks (CNN).  CNN are analog processing neural networks
with regular and local interconnections, governed by a set of
nonlinear ordinary differential equations. Due to their local
connectivity, CNN are realized as VLSI chips, which operates
at very high speed.</P>

<P>
<A NAME="SPI"></A> </P>
<DT><B>Symbolic Probabilistic Inference (SPI)</B><DD><P>
<UL>
<LI>FTP site: ftp://ftp.engr.orst.edu/pub/dambrosi/spi/</LI>
<LI>Paper (ijar-94.ps): ftp://ftp.engr.orst.edu/pub/dambrosi/</LI>
</UL>
</P>
<P>Contains Common Lisp function libraries to implement SPI type baysean
nets. Documentation is very limited.
Features:
<UL>
<LI>Probabilities, Local Expression Language Utilities, Explanation,
Dynamic Models, and a TCL/TK based GUI.</LI>
</UL>
</P>

<P>
<A NAME="SPRLIB-ANNLIB"></A> </P>
<DT><B>SPRLIB/ANNLIB</B><DD><P>
<UL>
<LI>Web site: http://www.ph.tn.tudelft.nl/~sprlib/</LI>
</UL>
</P>
<P>SPRLIB (Statistical Pattern Recognition Library) was developed
to support the easy construction and simulation of pattern
classifiers. It consist of a library of functions (written in C)
that can be called from your own program. Most of the well-known
classifiers are present (k-nn, Fisher, Parzen, ....), as well as
error estimation and dataset generation routines.</P>
<P>ANNLIB (Artificial Neural Networks Library) is a neural network
simulation library based on the data architecture laid down by
SPRLIB. The library contains numerous functions for creating,
training and testing feed-forward networks.  Training algorithms
include back-propagation, pseudo-Newton, Levenberg-Marquardt,
conjugate gradient descent, BFGS.... Furthermore, it is possible
- due to the datastructures' general applicability - to build
Kohonen maps and other more exotic network architectures using
the same data types.</P>

<P>
<A NAME="Sugal"></A> </P>
<DT><B>Sugal</B><DD><P>
<UL>
<LI>Web site: http://www.trajan-software.demon.co.uk/sugal.htm</LI>
</UL>
</P>
<P>Sugal [soo-gall] is the SUnderland Genetic ALgorithm system.
The aim of Sugal is to support research and implementation in Genetic
Algorithms on a common software platform. As such, Sugal supports a
large number of variants of Genetic Algorithms, and has extensive
features to support customization and extension.</P>

<P>
<A NAME="ThoughtTreasure"></A> </P>
<DT><B>ThoughtTreasure</B><DD><P>
<UL>
<LI>Web site: http://www.signiform.com/tt/htm/tt.htm</LI>
</UL>
</P>
<P>ThoughtTreasure is a project to create a database of commonsense rules
for use in any application. It consists of a database of a little over
100K rules and a C API to integrate it with your applications. Python,
Perl, Java and TCL wrappers are already available.</P>

<P>
<A NAME="TIN"></A> </P>
<DT><B>TIN</B><DD><P>
<UL>
<LI>Web site: http://www.jetlag.demon.nl/</LI>
</UL>
</P>
<P>This program simulates primitive life-forms, equipped with some
basic instincts and abilities, in a 2D environment consisting of
cells.  By mutation new generations can prove their success, and thus
passing on "good family values".</P>
<P>The brain of a TIN can be seen as a collection of processes, each
representing drives or impulses to behave a certain way, depending on the
state/perception of the environment ( e.g. presence of food, walls,
neighbors, scent traces) These behavior process currently are : eating,
moving, mating, relaxing, tracing others, gathering food and killing. The
process with the highest impulse value takes control, or in other words:
the tin will act according to its most urgent need.</P>

<P>
<A NAME="Ummon"></A> </P>
<DT><B>Ummon</B><DD><P>
<UL>
<LI>Web site: http://www.spacetide.com/projects/ummon/</LI>
</UL>
</P>
<P>Ummon is an advanced Open Source chatterbot. The main principle of the
bot is that it has no initial knowledge of either words or grammar; it
learns everything "on the fly." Numerous AI techniques will be explored
in the development of Ummon to achieve realistic "human" communication
with support for different, customizable personalities.</P>

<P>
<A NAME="ViSe"></A> </P>
<DT><B>Virtual Secretary Project (ViSe)</B><DD><P>(Tcl/Tk)
<UL>
<LI>Web site: http://www.vise.cs.uit.no/vise/</LI>
</UL>
</P>
<P>The motivation of the Virtual Secretary project is to construct
user-model-based intelligent software agents, which could in
most cases replace human for secretarial tasks, based on modern
mobile computing and computer network. The project includes two
different phases: the first phase (ViSe1) focuses on information
filtering and process migration, its goal is to create a secure
environment for software agents using the concept of user
models; the second phase (ViSe2) concentrates on agents'
intelligent and efficient cooperation in a distributed
environment, its goal is to construct cooperative agents for
achieving high intelligence. (Implemented in Tcl/TclX/Tix/Tk)</P>

<P>
<A NAME="Zeus"></A> </P>
<DT><B>Zeus</B><DD><P>
<UL>
<LI>Web site: http://more.btexact.com/projects/agents/zeus/</LI>
</UL>
</P>
<P>The construction of multi-agent systems involves long development
times and requires solutions to some considerable technical
difficulties. This has motivated the development of the ZEUS
toolkit, which provides a library of software components and tools
that facilitate the rapid design, development and deployment of
agent system</P>


</DL>
</P>


<H2><A NAME="ss8.2">8.2</A> <A HREF="AI-Alife-HOWTO.html#toc8.2">Dead projects.</A>
    </H2>

<P>
<DL>

<P>
<A NAME="FIPA-OS"></A> </P>
<DT><B>FIPA-OS</B><DD><P>
<UL>
<LI>Web site: http://fipa-os.sourceforge.net/index.htm</LI>
</UL>
</P>
<P>FIPA-OS is an open source implementation of the mandatory elements
contained within the FIPA specification for agent interoperability. In
addition to supporting the FIPA interoperability concepts, FIPA-OS also
provides a component based architecture to enable the development of
domain specific agents which can utilise the services of the FIPA
Platform agents. It is implemented in Java.</P>

<P>
<A NAME="PDKB"></A> </P>
<DT><B>PDKB</B><DD><P>
<UL>
<LI>Web site: http://lynx.eaze.net/~pdkb/web/</LI>
<LI>SourceForge site: http://sourceforge.net/projects/pdkb/</LI>
</UL>
</P>
<P>Public Domain Knowledge Bank (PDKB) is an Artificial Intelligence
Knowledge Bank of common sense rules and facts. It is based on the Cyc
Upper Ontology and the MELD language.</P>

<P>
<A NAME="RobocodeNG"></A> </P>
<DT><B>RobocodeNG</B><DD><P>
<UL>
<LI>Web site: http://robocodeng.sourceforge.net/</LI>
</UL>
</P>
<P>Merged together with original 
<A HREF="AI-Alife-HOWTO-6.html#Robocode">Robocode</A>
 as of version 1.1.</P>
<P>Extension of Robocode, the battling bot AI programming game. Like its
parent, it is written in Java and meant as a learning environment.</P>

<P>
<A NAME="Sulawesi"></A> </P>
<DT><B>Sulawesi</B><DD><P>
<UL>
<LI>Web site: http://wearables.essex.ac.uk/sulawesi/</LI>
</UL>
</P>
<P>A framework called Sulawesi has been designed and implemented to
tackle what has been considered to be important challenges in a
wearable user interface. The ability to accept input from any
number of modalities, and perform if necessary a translation to any
number of modal outputs. It does this primarily through a set
of proactive agents to act on the input.</P>

<P>
<A NAME="TresBel"></A> </P>
<DT><B>TresBel</B><DD><P>
<UL>
<LI>Abstract: http://iridia.ulb.ac.be/Projects/imple.html</LI>
<LI>Direct Download: ftp://iridia.ulb.ac.be/pub/hongxu/software/TresBel.tar.Z</LI>
</UL>
</P>
<P>This project seems to have been superseded by 
<A HREF="AI-Alife-HOWTO-3.html#Pulcinella">Pulcinella</A>
.</P>
<P>Libraries containing (Allegro) Common Lisp code for Belief Functions
(aka. Dempster-Shafer evidential reasoning) as a representation
of uncertainty. Very little documentation. Has a limited GUI.</P>


</DL>
</P>

<HR>
Next
<A HREF="AI-Alife-HOWTO-7.html">Previous</A>
<A HREF="AI-Alife-HOWTO.html#toc8">Contents</A>
</BODY>
</HTML>
