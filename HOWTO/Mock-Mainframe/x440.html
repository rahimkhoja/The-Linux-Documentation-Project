<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
><HEAD
><TITLE
>Going Hardcore: Non-GUI Systems</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REL="HOME"
TITLE="The Mock Mainframe Mini-HOWTO"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Life With Multiple Users"
HREF="x407.html"><LINK
REL="NEXT"
TITLE="Odds and Ends"
HREF="x536.html"></HEAD
><BODY
CLASS="section"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>The Mock Mainframe Mini-HOWTO</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x407.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x536.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN440"
></A
>8. Going Hardcore: Non-GUI Systems</H1
><P
>&#13;As nice as KDE and Gnome are, they use system resources like popcorn. If
you are only starting an application, try a desktop that is more
lightweight such as <TT
CLASS="literal"
>Blackbox</TT
>.  Though your distribution should set up the
basics for you, you will probably have to edit the configuration files (in
this case, the <TT
CLASS="literal"
>Blackbox</TT
> menu file that is specified in <TT
CLASS="literal"
>~/.blackbox</TT
>) for
each user. Also, make sure your users know how to work the environment. At
the very least, teach them that <TT
CLASS="literal"
>CTRL-ALT-BACKSPACE</TT
> kills the X server.
</P
><P
>&#13;But real men and women don't need a graphical user interface (GUI) at all:
They use a command shell such as <TT
CLASS="literal"
>bash</TT
>.  Before X Windows gave us
graphics, the Free Software Foundation (FSF) had created the GNU tools that
are as rock steady as any piece of software on the planet. They are the
heart of every distribution, and without them, there would be no "Linux"
system (which is why "GNU/Linux" is the more percise term).  If you have no
choice but to get by with really weak hardware &#8212; we're talking anything
down to a 386SX here &#8212; you can dump X Windows altogether and get along
just fine. Even if you stick to GUIs, some basic knowledge of the shell
can help you get far more out of your system.
</P
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN449"
></A
>8.1. Why the Command Line Is Cool</H2
><P
>&#13;Think of Linux on the command line as the Willow Rosenberg approach to
computers: Whereas GUIs are as spectacular as a punch on the nose by
vampire slayer Buffy Summers, even a little knowledge of the shell will let
you work nuanced magic of nearly unlimited power with little effort. True
fans of the TV series will realize that there is a warning implied here:
The power of the shell can become habit forming, if not downright
addictive, and you can destroy your whole system with no chance of recovery
if you mess things up. Using <TT
CLASS="literal"
>bash</TT
> takes you as close to
the raw energies of your machine as you can get without using a C compiler,
and the danger rises accordingly.
</P
><P
>&#13;It took Willow six years to become a witch powerful enough to end the
world, but it should take you a few weeks at most to become familiar with
the command line. Here are four paragraphs to help you decide if you want
to make the effort:
</P
><P
>&#13;The power of the command line environment is rooted in its design
philosophy: Each tool is designed to do one job and one job only, but to do
that job superbly. Also, almost every tool can be connected to every other
tool to create processing chains with just a few commands. Since these
tools are (almost) all general purpose, you can solve just about any
problem with the right combination. With these same commands, you can write
little programs (<EM
>shell scripts</EM
>) for everyday tasks. If you look closely
at the programs your distributor includes, you will see that a lot of the
are in <TT
CLASS="literal"
>bash</TT
>. Other script languages such as Python or Perl might be more
powerful, but the command line is always included and has far less
overhead.
</P
><P
>&#13;It is learning the individual tools of the CLI that is somewhat daunting.
A lot of commands have strange names that don't even pretend to be mnemonic
(the pattern scanning tool <TT
CLASS="literal"
>awk</TT
> is named for its creators Aho, Kernighan,
and Weinberger), only make sense in a historical context (the <EM
>tape
archiving utility</EM
> <TT
CLASS="literal"
>tar</TT
> is now used to distribute compressed files), or
look like they are typos (<TT
CLASS="literal"
>umount</TT
> instead of "unmount", <TT
CLASS="literal"
>passwd</TT
> instead
of "password"). There can be dozens of options for each command, and they
can be just as cryptic. Because the system was written by hackers in the
true sense of the word who wanted the computer to get the job done and not
talk about it, the shell normally will not ask you for confirmation, even
if you tell it to delete every single file on your hard disk. This is where
the end of the world scenario from <EM
>Buffy</EM
> comes in.
</P
><P
>&#13;Once you <EM
>have</EM
> mastered the basics of the shell, however, you will get
stuff done a lot faster, you will understand jokes such as <TT
CLASS="literal"
>rm -rf
/bin/laden</TT
>, and you will develop a spring in your step and a glint in
your eye. This is why even people who are young enough to have been born
after the invention of the mouse develop a  tendency to use X Windows
merely as a comfortable way to open a lot of terminal windows (either
<TT
CLASS="literal"
>xterm</TT
> or the less resource-hungry <TT
CLASS="literal"
>rxvt</TT
>).
</P
><P
>&#13;The CLI has just about every tool you'll need: <TT
CLASS="literal"
>mutt</TT
> or <TT
CLASS="literal"
>pine</TT
>
for email (real hard-core basket cases use <TT
CLASS="literal"
>mail</TT
>) <TT
CLASS="literal"
>w3m</TT
> or <TT
CLASS="literal"
>lynx</TT
> for
surfing, and of course the legendary editors <TT
CLASS="literal"
>vi</TT
> (more commonly <TT
CLASS="literal"
>vim</TT
>
these days) or <TT
CLASS="literal"
>emacs</TT
>. The obvious exception to this rule are programs
that let you view pictures. But then you probably aren't interested in that
sort of thing anyway, are you.
</P
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN478"
></A
>8.2. Setting Up Text Terminals</H2
><P
>&#13;Basically, you have the same options for text terminals as you do with X
terminals. Everything is just a bit easier.
</P
><P
>&#13;For example, you don't have to reboot if you are forced to use a different
operation system: Any program that lets you log in via <TT
CLASS="literal"
>telnet</TT
> (on secure,
closed networks) or <TT
CLASS="literal"
>ssh</TT
> (everywhere else) will do. Microsoft Windows
includes a <TT
CLASS="literal"
>telnet</TT
> client that is best described as rudimentary; for
serious work, try a free Win32 implementation such as Simon Tathamt's
<A
HREF="http://www.chiark.greenend.org.uk/<subscript>sgtatham/putty/"
TARGET="_top"
>PuTTY http://www.chiark.greenend.org.uk/sgtatham/putty/</A
>. Apple users with Mac
OS X should have no problems with their clients.
</P
><P
>&#13;The Linux Terminal Server Project also has a package for text terminals.
The hardware can be as basic as it gets: Go find yourself a 386DX (for
those of you who don't remember the Soviet Union or the first <TT
CLASS="literal"
>Star Trek</TT
>
series: This is the original Pentium's grandaddy). The mainboard will
probably not have a PCI slot, so you'll need an ISA graphics card and an
ISA network card. These are so low down the hardware chain you might have
problems finding them, because they are being junked, not sold second hand.
</P
><P
>&#13;There is no reason, though, why your computer has to be advanced enought to
understand the TCP/IP protocol and be part of your local network at all.
You can connect just about any computer to the serial port(s) of the mock
mainframe: For example, there is a Linux HOWTO for older Macs by Robert
Kiesling (<EM
>The MacTerminal MINI-HOWTO</EM
>); in an article in
<A
HREF="http://www.linuxgazette.com/issue70/arndt.html"
TARGET="_top"
>The Linux Gazette http://www.linuxgazette.com/issue70/arndt.html</A
>, Matthias Arndt shows how
to convert an Atari ST into a terminal; Nicholas Petreley explains in
<A
HREF="http://www.itworld.com/Comp/2384/LWD010511penguin2/"
TARGET="_top"
>IT World.com http://www.itworld.com/Comp/2384/LWD010511penguin2/</A
> how to use your Palm
Pilot. If you can get it connected to the serial port, chances are you can
get it running on Linux. There are special cards with multiple serial ports
for larger setups. Of course, there is a HOWTO for that as well: <EM
>The
Serial HOWTO</EM
> by David S.Lawyer.
</P
><P
>&#13;You can also get special text terminals as individual machines.  David S.
Lawyer has written an extensive Linux HOWTO on the subject
(<EM
>Text-Terminal-HOWTO</EM
>) that explains how they work, how you set them up,
and why you would want one.
</P
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN495"
></A
>8.3. Useful Shell Commands</H2
><P
>&#13;To get you started on the shell, here are a few commands that are
especially useful if you are sharing a system. These very basic examples
were chosen to be useful to normal users.
</P
><P
>&#13;<STRONG
>Play nice</STRONG
>. The <TT
CLASS="literal"
>nice</TT
> command is one of those things that would make the
world a better place if everybody used it more often, but nobody does. It
allows you to lower the <EM
>scheduling priority</EM
> of a process so that less
important programs don't get in the way of the important ones.
</P
><P
>&#13;For example, assume you have a WAV recording of your own voice as you sing
a song under the shower, and you want to convert it to the Ogg Vorbis
format to distribute to your fans on the Internet, all three of them. A
simple command to do this is
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;         oggenc -o showersong.ogg showersong.wav
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;Encoding music formats is a CPU intensive process, so performance will
drop. Now, if a few minutes more or less don't matter, just start the line
off with <TT
CLASS="literal"
>nice</TT
>:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;         nice oggenc -o shower.ogg shower.wav
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;Now the encoding will be run with a lower priority, but you will still have
to wait for it to finish before you can use the shell again. To have the
computer execute a command in the background, add an ampersand ("&#38;") to the
end of the line:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;         nice oggenc -o shower.ogg shower.wav &#38;
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;The shell will respond by giving you a <EM
>job number</EM
> and a <EM
>process id</EM
>
(PID), and then will ask you for the next command.
</P
><P
>&#13;The <TT
CLASS="literal"
>nice</TT
> command is a good example of the power that was lost when
graphical interfaces became the default: There is no simple way to adjust
the priority of a process with a mouse-driven interface.
</P
><P
>&#13;<STRONG
>Do it later.</STRONG
> Another way to spread the load is to have an intensive
process start at a time when the system is not being used much. Depending
on who is on the system with you, this could be three  o'clock in the
morning or any time until two o'clock in the afternoon.
</P
><P
>&#13;The <TT
CLASS="literal"
>at</TT
> command lets you set a time to start a program or any other
process that can be run from the command line. To have our shower song
encoded at eight in the evening when you are out watching meaningful French
love films, you enter the command "at" followed by the time you want
execution to start, and then hit the <TT
CLASS="literal"
>ENTER</TT
>. Then you type in the command
itself, followed by another <TT
CLASS="literal"
>ENTER</TT
>, and finally a <TT
CLASS="literal"
>CTRL-d</TT
> to finish the
sequence:
</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;         me@mycomputer:&#62; at 20:00
         warning: commands will be executed using /bin/sh
         &#62; nice oggenc -o shower.ogg shower.wav
         &#62; &#60;CTRL-d&#62;
         job 1 at 2003-09-28 20:00
</PRE
></FONT
></TD
></TR
></TABLE
><P
>&#13;The <TT
CLASS="literal"
>at</TT
> command accepts just about any time format: Americans get to use
their quaint "08:00pm" notation instead of "20:00", and there are a whole
set of shortcuts like <TT
CLASS="literal"
>midnight</TT
>, <TT
CLASS="literal"
>noon</TT
> or even <TT
CLASS="literal"
>teatime</TT
>.  <TT
CLASS="literal"
>at</TT
>
sends the output of the command to your mailbox.
</P
><P
>&#13;<STRONG
>Do it when you are bored.</STRONG
> A close relative of <TT
CLASS="literal"
>at</TT
> uses system load, not
time of day to determine when a command should be run: <TT
CLASS="literal"
>batch</TT
> saves the
execution for a time when the system load has fallen below a certain value
(to see what your system load currently is, run <TT
CLASS="literal"
>uptime</TT
> from a shell or
<TT
CLASS="literal"
>xload</TT
> under X Windows). The documentation gives this value as 0.8. The
syntax for <TT
CLASS="literal"
>batch</TT
> is basically the same as for <TT
CLASS="literal"
>at</TT
>, except that the time
field is optional.
</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x407.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x536.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Life With Multiple Users</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Odds and Ends</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>