<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
><HEAD
><TITLE
>Install Linux and LILO on DiskOnChip</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REL="HOME"
TITLE="Booting Linux from DiskOnChip HOWTO"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Using M-Systems DiskOnChip 2000 TSOP as an additional storage drive in Linux"
HREF="steps.html"><LINK
REL="NEXT"
TITLE="Install Development ToolChain on DiskOnChip"
HREF="devtools.html"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Booting Linux from DiskOnChip HOWTO</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="steps.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="devtools.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="install"
></A
>5. Install Linux and LILO on DiskOnChip</H1
><P
>In this section we will learn how to install Linux operating system on an unformatted DOC and boot from it using LILO as the boot loader.</P
><P
>In order to get to this state, a procedure will be discussed.  Some steps in this procedure resemble the steps discussed previously in this document.  Even so, this should be considered a separate procedure, rather than a continuation of the steps in <A
HREF="steps.html"
>Section 4</A
>.</P
><P
>In general, to make a device to boot into Linux, it should have the following components:</P
><P
></P
><UL
><LI
><P
>Kernel Image</P
></LI
><LI
><P
>Root Filesystem</P
></LI
><LI
><P
>Boot loader to load the kernel Image into memory</P
></LI
></UL
><P
>This section will basically try to fulfill the above three requirements.</P
><P
>The following steps should be followed for achieving the goal of this section.</P
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="copy_firmware"
></A
>5.1. Step 1: Copying the DOC firmware onto DiskOnChip</H2
><P
>We will use the <B
CLASS="command"
>dformat</B
> utility from <TT
CLASS="filename"
>linux_binary.5_1_4/dformat_5_1_4_37</TT
>.</P
><P
>M-Systems does not provide the firmware for using the DOC on Linux platforms. We address this problem by making a copy of the firmware shipped with the M-Systems dos utilities into this directory (<SPAN
CLASS="QUOTE"
>"dos utilities"</SPAN
> is the term used by the M-Systems people so we have also used this name).  On our system we copied it by mounting the windows partition and extracting it from there:</P
><P
><B
CLASS="command"
>mount <TT
CLASS="option"
>-t</TT
> <TT
CLASS="parameter"
><I
>auto</I
></TT
><TT
CLASS="filename"
>/dev/hda5 /mnt/d</TT
></B
> </P
><P
><B
CLASS="command"
>cp <TT
CLASS="filename"
>/mnt/d/dos\ utilities/doc514.exb linux_binary.5_1_4/dformat_5_1_4_37/</TT
></B
> </P
><P
>Now format the drive, using the <B
CLASS="command"
>dtformat</B
> from <TT
CLASS="filename"
>linux_binary.5_1_4/dformat_5_1_4_37/</TT
>:</P
><P
><B
CLASS="command"
>cd <TT
CLASS="filename"
>linux_binary.5_1_4/dformat_5_1_4_37/</TT
></B
> </P
><P
><B
CLASS="command"
>./dformat <TT
CLASS="option"
>-WIN:D000 -S:doc514.exb</TT
></B
> </P
><P
><TT
CLASS="parameter"
><I
>D000</I
></TT
> specifies the address of the DiskOnChip in the BIOS.</P
><P
>The following is the BIOS (RTD Enhanced Phoenix - AwardBIOS CMOS Setup Utility (v6.00.04.1601)) setting on our system.</P
><P
>The Integrated peripherals of the BIOS menu should have:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;SSD Socket #1 to Bios Extension
Bios Ext. Window size 8k
Bios Ext. window [D000:0000]
Fail safe Boot ROM [Disabled]
</PRE
></FONT
></TD
></TR
></TABLE
><P
>The Bios Ext. Window denotes the address for your DiskOnChip.</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>BIOSes</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The setting may be different depending upon your BIOS version.</P
></TD
></TR
></TABLE
></DIV
><P
>Now shutdown the system and boot into Windows XP.</P
><P
>From now on you will notice the TrueFFS message and some time delay before the Grub Menu appears.</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="format"
></A
>5.2. Step 2: Format DiskOnChip using Dos Utilities</H2
><P
>Boot into Windows XP. We will use the M-Systems Dos Utilities for formatting the DiskOnChip. The Dos utility <B
CLASS="command"
>dformat</B
> will copy the firmware to the DOC, and then format it as a <EM
>fat16</EM
> device.</P
><P
>Using the command prompt, run the following command from the DOS utilities folder (assuming that you have already downloaded the DOS utilities):</P
><P
><B
CLASS="command"
>dformat <TT
CLASS="option"
>/WIN:D000 /S:doc514.exb</TT
></B
> </P
><P
>Check the DOC partition using another utility called <B
CLASS="command"
>dinfo</B
>. A sample <B
CLASS="command"
>dinfo</B
> output is given in the appendix.</P
><P
>Again shutdown the system and now boot into Linux.</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Always shutdown</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>After formatting you should always do a full shutdown (power off) and not just a reboot.</P
></TD
></TR
></TABLE
></DIV
><P
>Even though Step 1 and Step 2 seem to be the same, the only difference being that Step 1 is done from Linux and Step 2 from Windows XP, they both have to be done.</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="patch+compile"
></A
>5.3. Step 3: Patch and Compile the kernel 2.4.18</H2
><P
>This has to be performed in exactly the same manner as described in <A
HREF="steps.html#step1"
>Section 4.1</A
> and <A
HREF="steps.html#step2"
>Section 4.2</A
>.</P
><P
>Also add an entry for the new kernel in <TT
CLASS="filename"
>/boot/grub/menu.lst</TT
> as described in <A
HREF="steps.html#step4"
>Section 4.4</A
>.</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="nodes"
></A
>5.4. Step 4: Create nodes</H2
><P
>This is done using the ame procedure as described in <A
HREF="steps.html#step3"
>Section 4.3</A
>.</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="modconf"
></A
>5.5. Step 5: Modify the /etc/module.conf file</H2
><P
>The file <TT
CLASS="filename"
>/etc/modules.conf</TT
> has to be modified, adding this line at the end of the file:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;options doc major=62
</PRE
></FONT
></TD
></TR
></TABLE
><P
>This is required since our nodes use a major number of 62, while the doc driver module uses a major number of 100. When creating the <TT
CLASS="filename"
>initrd</TT
> image, the driver will be loaded with major number value of 100 (instead of 62) if you do not edit the module configuration file.  This will make it impossible for the nodes to use the driver. The reason for using the initrd image will be explained in the next step.</P
><P
>The <B
CLASS="command"
>mkinitrd_doc</B
> script from <TT
CLASS="filename"
>linux_binary.5_1_4/doc-linux-5_1_4_20/driver</TT
> reads the <TT
CLASS="filename"
>/etc/modules.conf</TT
> file and looks for anything that has been mentioned for the DOC driver regarding the major number. By default, <B
CLASS="command"
>mkinitrd_doc</B
> will create an <TT
CLASS="filename"
>initrd</TT
> image that loads the DOC module with a major number of 100. However, with the modifications we have made to the <TT
CLASS="filename"
>/etc/modules.conf</TT
> file, the <TT
CLASS="filename"
>initrd</TT
> image will load the module with a major number of 62.</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="initrd"
></A
>5.6. Step 6: Create the initrd image</H2
><P
>Run the <B
CLASS="command"
>mkinitrd_doc</B
> script from <TT
CLASS="filename"
>linux_binary.5_1_4/doc-linux-5_1_4_20/driver/</TT
>:</P
><P
><B
CLASS="command"
>./mkinitrd_doc</B
> </P
><P
>This may give warning messages similar to the following, which can be safely ignored:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;  cp: cannot stat ./sbin/insmod.static.: No such file or directory
  cp: cannot stat ./dev/systty.: No such file or directory
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Check for the newly created <TT
CLASS="filename"
>initrd</TT
> image, <TT
CLASS="filename"
>initrd-2.4.18.img</TT
>, in the <TT
CLASS="filename"
>/boot</TT
> directory. </P
><P
>Running the <B
CLASS="command"
>mkinitrd_doc</B
> script produces this image. The reason for making an <TT
CLASS="filename"
>initrd</TT
> image is that the provided M-Systems driver cannot be added as a built-in support in the kernel, which leaves no other option than adding it as a loadable module. If we want to boot from DOC, the kernel should know how to access the DOC at the time of booting to search for <B
CLASS="command"
>/sbin/init</B
> in the root filesystem on the DOC (the root filesystem is necessary to get the Linux system up).</P
><P
>In the booting sequence of the Linux, <B
CLASS="command"
>/sbin/init</B
> is the file (a command actually) that the kernel looks for in order to start various services and, finally, give the login shell to the user.  The figure below illustrates the problem:</P
><DIV
CLASS="figure"
><A
NAME="AEN479"
></A
><P
><B
>Figure 1. Why we need an initrd image</B
></P
><DIV
CLASS="mediaobject"
><P
><IMG
SRC="initrd.png"></P
></DIV
></DIV
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="insert_driver"
></A
>5.7. Step 7: Insert the DOC driver into the new kernel</H2
><P
>Reboot the system and boot into the newly created kernel.</P
><P
>Now insert the doc module:</P
><P
><B
CLASS="command"
>modprobe <TT
CLASS="parameter"
><I
>doc</I
></TT
></B
> </P
><P
>This will give the following messages:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;fl : Flash disk driver for DiskOnChip
fl: DOC devices(s) found: 1
fl: _init:registed device at major 62
.
.
.
.
</PRE
></FONT
></TD
></TR
></TABLE
><P
>To access the DOC, ensure that the major number assigned to the nodes is 62.</P
><P
>In case of a major number of 100 is assigned, check if the <TT
CLASS="filename"
>/etc/modules.conf</TT
> was successfully modified. If it was not, then repeat <A
HREF="install.html#modconf"
>Section 5.5</A
>. You must then also repeat <A
HREF="install.html#initrd"
>Section 5.6</A
> because the <TT
CLASS="filename"
>initrd</TT
> image depends on <TT
CLASS="filename"
>/etc/modules.conf</TT
>.   If the DOC entry were incorrect in this file, the <TT
CLASS="filename"
>initrd</TT
> image will be useless.</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="createfs"
></A
>5.8. Step 8:  Create a filesystem on the DiskOnChip</H2
><P
>Perform <A
HREF="steps.html#step6"
>Section 4.6</A
>.  This is required to create partitions on the DOC.</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="rootfs"
></A
>5.9. Step 9:  Build Root Filesystem on the DiskOnChip</H2
><P
>Before starting with this step make sure that you have not mounted <TT
CLASS="filename"
>/dev/msys/fla1</TT
> on any of the mount points, as this step will involve reformatting the DiskOnChip.</P
><P
>Also, in order to understand the details of Root File system refer to <A
HREF="http://www.tldp.org/HOWTO/Bootdisk-HOWTO/index.html"
TARGET="_top"
>The Linux Bootdisk How To</A
> available at <A
HREF="http://www.tldp.org"
TARGET="_top"
>http://www.tldp.org</A
>.</P
><P
>We will use the <B
CLASS="command"
>mkdocimg</B
> script located in <TT
CLASS="filename"
>linux_binary.5_1_4/doc-linux-5_1_4_20/build</TT
>.</P
><P
>We will also use the <TT
CLASS="filename"
>redhat-7.1.files</TT
> directory, located in the same directory (i.e. <TT
CLASS="filename"
>build</TT
>), which contains the list of the files that will be copied in the root filesystem that will be created on the DOC.</P
><P
><B
CLASS="command"
>./mkdocimg <TT
CLASS="filename"
>redhat-7.1.files</TT
></B
> </P
><P
>This step will take a few minutes to complete.</P
><P
>Now mount the <TT
CLASS="filename"
>/dev/msys/fla1</TT
> partition on the mount point <TT
CLASS="filename"
>/mnt/doc</TT
> and check the files that have been created:</P
><P
><B
CLASS="command"
>mount <TT
CLASS="option"
>-t</TT
> <TT
CLASS="parameter"
><I
>auto</I
></TT
> <TT
CLASS="filename"
>/dev/msys/fla1 /mnt/doc</TT
></B
> </P
><P
><B
CLASS="command"
>cd <TT
CLASS="filename"
>/mnt/doc</TT
></B
> </P
><P
>The following directories are created on the DOC as a result of running the script:</P
><P
><TT
CLASS="filename"
>bin dev sbin etc lib usr home mnt tmp var boot</TT
></P
><P
>The most important is the boot directory. This contains the <TT
CLASS="filename"
>vmlinuz-2.4.18</TT
> and <TT
CLASS="filename"
>initrd-2.4.18.img</TT
> which gets copied from the <TT
CLASS="filename"
>/boot</TT
> directory. This directory is required when booting from DiskOnChip.</P
><P
>Apart from these files there are some other files which must be deleted:</P
><P
></P
><UL
><LI
><P
><TT
CLASS="filename"
>System.map-2.4.18</TT
></P
></LI
><LI
><P
><TT
CLASS="filename"
>boot.3E00</TT
></P
></LI
></UL
><P
>These two files are created later by LILO.</P
><P
>The <TT
CLASS="filename"
>redhat-7.1.files</TT
> directory contains a list of files and directories that will be created when we use the <B
CLASS="command"
>mkdocimg</B
> script.</P
><P
>This script does not create all the files that are necessary for creating the root filesystem on the DOC. So replace the directories created by the <B
CLASS="command"
>mkdocimg</B
> script, with the directories of the <TT
CLASS="filename"
>/</TT
> filesystem (root filesystem that is currently running).</P
><P
>The directories under <TT
CLASS="filename"
>/</TT
>, such as <TT
CLASS="filename"
>etc</TT
>, <TT
CLASS="filename"
>sbin</TT
>, <TT
CLASS="filename"
>bin</TT
> and so on contain lot of files that are not useful and ideally should not be copied while building the root filesystem for DOC. But since we have not discussed the files that are essential and the files that can be removed, we therefore suggest that one should copy the entire contents of the directories. We know that it is a clumsy way of building the root filesystem and will unnecessarily take lot of memory; bear with us as in the next section we will explain how to put the development tools on the DOC.  We will then remove the useless files from the root filesystem of DOC.</P
><P
>If you are aware of how to build the root filesystem we would encourage you to copy only the essential files.</P
><P
>The following is the set of commands we used to modify the root filesystem:</P
><P
><B
CLASS="command"
>rm <TT
CLASS="option"
>-rf</TT
> <TT
CLASS="filename"
>/mnt/doc/sbin</TT
></B
> </P
><P
><B
CLASS="command"
>rm <TT
CLASS="option"
>-rf</TT
> <TT
CLASS="filename"
>/mnt/doc/etc</TT
></B
> </P
><P
><B
CLASS="command"
>rm <TT
CLASS="option"
>-rf</TT
> <TT
CLASS="filename"
>/mnt/doc/lib</TT
></B
> </P
><P
><B
CLASS="command"
>rm <TT
CLASS="option"
>-rf</TT
> <TT
CLASS="filename"
>/mnt/doc/dev</TT
></B
> </P
><P
><B
CLASS="command"
>cp <TT
CLASS="option"
>-rf</TT
> <TT
CLASS="filename"
>/sbin /mnt/doc</TT
></B
> </P
><P
><B
CLASS="command"
>cp <TT
CLASS="option"
>-rf</TT
> <TT
CLASS="filename"
>/etc /mnt/doc</TT
></B
> </P
><P
><B
CLASS="command"
>cp <TT
CLASS="option"
>-rf</TT
> <TT
CLASS="filename"
>/dev /mnt/doc</TT
></B
> </P
><P
><B
CLASS="command"
>cp <TT
CLASS="option"
>-rf</TT
> <TT
CLASS="filename"
>/lib /mnt/doc</TT
></B
> </P
><P
><B
CLASS="command"
>rm <TT
CLASS="option"
>-rf</TT
> <TT
CLASS="filename"
>/mnt/doc/lib/modules</TT
></B
> </P
><P
>Now our filesystem is ready.</P
><P
>The total size occupied by this filesystem will be about 35Mb.</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="rdev"
></A
>5.10. Step 10: Use rdev to specify the DOC root filesystem location to kernel image</H2
><P
>This step is required to specify the location of the DOC root filesystem to the kernel we compiled in the step 3. The step can be avoided by giving the details of the root filesystem location in the Boot Loader configuration file, but we had some problems in making the kernel locate the root filesystem at the time of booting so we recommend executing this command:</P
><P
><B
CLASS="command"
>rdev <TT
CLASS="filename"
>/boot/vmlinuz-2.4.18 /dev/msys/fla1</TT
></B
> </P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="lilo"
></A
>5.11. Step 11: Compile lilo-22.3.2</H2
><P
>We are going to use LILO as the boot loader since this is the only BootLoader that can read an INFTL device without many changes to be done to the BootLoader source code.</P
><P
>For more information on how LILO and other boot loaders operate, refer to .</P
><P
>We need to compile the lilo-22-3.2 source code to get the executable file for LILO.</P
><P
>We will use the source code from <TT
CLASS="filename"
>linux_binary.5_1_4/doc-linux-5_1_4_20/lilo/lilo-22.3.2</TT
>.</P
><P
>Before starting the build we need to do the following:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Create a <EM
>soft link</EM
> for the kernel-2.4.18 source code with the name <TT
CLASS="filename"
>linux</TT
>.</P
><P
>When you untar the file <TT
CLASS="filename"
>linux-2.4.18.tar.gz</TT
> it will create a directory <TT
CLASS="filename"
>linux</TT
>. So we need to rename the directory <TT
CLASS="filename"
>linux</TT
> to <TT
CLASS="filename"
>linux-2.4.18</TT
> before creating a soft link with the same name:</P
><P
><B
CLASS="command"
>mv <TT
CLASS="filename"
>linux linux-2.4.18</TT
></B
> </P
><P
><B
CLASS="command"
>ln <TT
CLASS="option"
>-s</TT
> <TT
CLASS="filename"
>linux-2.4.18 linux</TT
></B
> </P
><P
>If the above steps are not done the build might fail.</P
></LI
><LI
><P
>Patch file: <TT
CLASS="filename"
>linux_binary.5_1_4/doc-linux-5_1_4_20/lilo/lilo-22.3.2/common.h</TT
>:</P
><P
>The lilo-22.3.2 source code that comes with the M-Systems <TT
CLASS="filename"
>linux_binary.5_1_4.tgz</TT
> is buggy as one of the variables <TT
CLASS="varname"
>PAGE_SIZE</TT
> is not defined. We need to patch the LILO source code as follows:</P
><P
>Add the following lines in the <TT
CLASS="filename"
>common.h</TT
> after the line <SPAN
CLASS="QUOTE"
>"#include .lilo.h."</SPAN
>:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;+ #ifndef PAGE_SIZE
+ #define PAGE_SIZE 4096U
+ #endif
#define 0_NACCESS 3
</PRE
></FONT
></TD
></TR
></TABLE
><P
>Where <SPAN
CLASS="QUOTE"
>"+"</SPAN
> indicates the lines to be added.</P
></LI
><LI
><P
>Make sure that the <B
CLASS="command"
>gcc</B
> version is 2.95.3 by using <B
CLASS="command"
>gcc <TT
CLASS="option"
>--version</TT
></B
>.</P
></LI
></OL
><P
>Now we can start the build process. Run</P
><P
><B
CLASS="command"
>make <TT
CLASS="parameter"
><I
>clean</I
></TT
> &#38;&#38; make</B
> </P
><P
>This will create a new LILO executable, <TT
CLASS="filename"
>linux_binary.5_1_4/doc-linux-5_1_4_20/lilo/lilo-22.3.2/lilo</TT
>.  Copy this LILO executable into <TT
CLASS="filename"
>/sbin/lilo</TT
> and <TT
CLASS="filename"
>/mnt/doc/sbin/lilo</TT
>:</P
><P
><B
CLASS="command"
>cp <TT
CLASS="filename"
>linux_binary.5_1_4/doc-linux-5_1_4_20/lilo/lilo-22.3.2/lilo /sbin/lilo</TT
></B
> </P
><P
><B
CLASS="command"
>cp <TT
CLASS="filename"
>linux_binary.5_1_4/doc-linux-5_1_4_20/lilo/lilo-22.3.2/lilo /mnt/doc/sbin/lilo</TT
></B
> </P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="boot.b"
></A
>5.12. Step 12: Copy the boot.b file into boot directory of DOC</H2
><P
>We need to copy the file <TT
CLASS="filename"
>boot.b</TT
> from <TT
CLASS="filename"
>linux_binary.5_1_4/doc-linux-5_1_4_20/lilo/</TT
> to <TT
CLASS="filename"
>/mnt/doc/boot</TT
>.</P
><P
>The file contains the essential <EM
>stage1</EM
> and <EM
>stage2</EM
> of the LILO boot loader.</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="liloconf"
></A
>5.13. Step 13:  Modify the /etc/lilo.conf file</H2
><P
>First, remove the existing <TT
CLASS="filename"
>/etc/lilo.conf</TT
>:</P
><P
><B
CLASS="command"
>rm <TT
CLASS="option"
>-rf</TT
> <TT
CLASS="filename"
>/etc/lilo.conf</TT
></B
> </P
><P
>Now create a new <TT
CLASS="filename"
>/etc/lilo.conf</TT
>, using a text editor, and add the following lines to it:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;boot=/dev/msys/fla
compact
install=/boot/boot.b
map=/boot/System.map
disk=/dev/msys/fla
bios=0x80
prompt
delay=50
timeout=50
image=/boot/vmlinuz
label=linux
root=/dev/msys/fla1
initrd=/boot/initrd.img
read-only
</PRE
></FONT
></TD
></TR
></TABLE
><P
>According to the above lines added to <TT
CLASS="filename"
>/etc/lilo.conf</TT
>, one needs to create soft links for <TT
CLASS="filename"
>vmlinuz-2.4.18</TT
> and <TT
CLASS="filename"
>initrd-2.4.18.img</TT
> in <TT
CLASS="filename"
>/mnt/doc/boot</TT
>:</P
><P
><B
CLASS="command"
>cd <TT
CLASS="filename"
>/mnt/doc/boot</TT
></B
> </P
><P
><B
CLASS="command"
>ln <TT
CLASS="option"
>-s</TT
> <TT
CLASS="filename"
>vmlinuz-2.4.18 vmlinuz</TT
></B
> </P
><P
><B
CLASS="command"
>ln <TT
CLASS="option"
>-s</TT
> <TT
CLASS="filename"
> initrd-2.4.18.img initrd.img</TT
></B
> </P
><P
>Copy the newly created <TT
CLASS="filename"
>/etc/lilo.conf</TT
> to <TT
CLASS="filename"
>mnt/doc/etc/lilo.conf</TT
>.</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="bootable"
></A
>5.14. Step 14: Store the new LILO configuration on the DiskOnChip</H2
><P
>This step will configure LILO in the MBR of the DiskOnChip and hence make the DiskOnChip bootable.</P
><P
>Ensure that <TT
CLASS="filename"
>/dev/msys/fla1</TT
> (root filesystem partition for the DOC) is mounted on the mount point <TT
CLASS="filename"
>/mnt/doc</TT
>.</P
><P
>Execute the following command to store the LILO configuration on the DOC:</P
><P
><B
CLASS="command"
>lilo<TT
CLASS="option"
>-v -C</TT
> <TT
CLASS="filename"
>/etc/lilo.conf</TT
> <TT
CLASS="option"
>-r</TT
> <TT
CLASS="filename"
>/mnt/doc</TT
></B
> </P
><P
><TT
CLASS="filename"
>/mnt/doc</TT
> denotes the location where the BootLoader will be installed, so it is installed on the DiskOnChip, as <TT
CLASS="filename"
>/mnt/doc</TT
> is the mount point for the primary partition of DOC where LILO was configured.</P
><P
>It will create the following two files in the boot directory of DOC (i.e. <TT
CLASS="filename"
>/mnt/doc/boot</TT
>):</P
><P
></P
><OL
TYPE="1"
><LI
><P
><TT
CLASS="filename"
>System.map-2.4.18</TT
></P
></LI
><LI
><P
><TT
CLASS="filename"
>boot.3E00</TT
></P
></LI
></OL
><P
>Now you should make a backup of the entire DiskOnChip to allow for easy restore of the files damaged by possible fatal errors:</P
><P
><B
CLASS="command"
>cd <TT
CLASS="filename"
>/home</TT
></B
> </P
><P
><B
CLASS="command"
>tar <TT
CLASS="option"
>-cvzf</TT
> <TT
CLASS="filename"
>docimg.tgz /mnt/doc</TT
></B
> </P
><P
>This will create a compressed copy of all the contents of DiskOnChip with the name <TT
CLASS="filename"
>docimg.tgz</TT
> in <TT
CLASS="filename"
>/home</TT
>.</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="fstab"
></A
>5.15. Step 15: Modify etc/fstab of DiskOnChip root file system</H2
><P
>Open the <TT
CLASS="filename"
>/mnt/doc/etc/fstab</TT
> file and edit the line where the mount point is <TT
CLASS="filename"
>/</TT
>.  Change that line to:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;/dev/msys/fla1  /  ext2  rw.noauto 0 1
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="firmware"
></A
>5.16. Step16:  Update Firmware</H2
><P
>This step is required to update the firmware of the DiskOnChip. We will use the <B
CLASS="command"
>dformat</B
> utility from <TT
CLASS="filename"
>linux_binary.5_1_4/dformat_5_1_4_37</TT
>:</P
><P
><B
CLASS="command"
>./dformat <TT
CLASS="option"
>-W:D000 -S:doc514.exb -Y -NOFORMAT</TT
></B
> </P
><DIV
CLASS="warning"
><P
></P
><TABLE
CLASS="warning"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/warning.gif"
HSPACE="5"
ALT="Warning"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Don't format!</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <TT
CLASS="option"
>NOFORMAT</TT
> flag is important otherwise it will reformat the DiskOnChip device, and the contents will be lost.</P
></TD
></TR
></TABLE
></DIV
><P
>The above command will cause the DiskOnChip to boot in the absence of any other bootable device. So we need to remove the Hard Disk in order to allow the DOC to boot.</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="boot"
></A
>5.17. Step17: BOOT from DiskOnChip</H2
><P
>Check your BIOS manual for enabling booting from a BIOS extension device i.e. DiskOnChip. On our system we had to disable the Hard Disk and CDROM and set the first bootable device as HDD-0.</P
><P
>Reboot the system after making the necessary changes in the BIOS.</P
><P
>You will get the LILO menu and on pressing enter Linux gets booted from DiskOnChip.</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="steps.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="devtools.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Using M-Systems DiskOnChip 2000 TSOP as an additional storage drive in Linux</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Install Development ToolChain on DiskOnChip</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>