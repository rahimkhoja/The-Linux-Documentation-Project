<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>BASH Programming - Introduction HOW-TO: Pipes</TITLE>
 <LINK HREF="Bash-Prog-Intro-HOWTO-5.html" REL=next>
 <LINK HREF="Bash-Prog-Intro-HOWTO-3.html" REL=previous>
 <LINK HREF="Bash-Prog-Intro-HOWTO.html#toc4" REL=contents>
</HEAD>
<BODY>
<A HREF="Bash-Prog-Intro-HOWTO-5.html">Next</A>
<A HREF="Bash-Prog-Intro-HOWTO-3.html">Previous</A>
<A HREF="Bash-Prog-Intro-HOWTO.html#toc4">Contents</A>
<HR>
<H2><A NAME="s4">4. Pipes</A>        </H2>

<P> This section explains in a very simple and practical way how to use pipes, 
nd why you may want it.
<P>
<H2><A NAME="ss4.1">4.1 What they are and why you'll want to use them</A>
                </H2>

<P> Pipes let you use (very simple, I insist) the output of a program as the 
input of another one    
<H2><A NAME="ss4.2">4.2 Sample: simple pipe with sed   </A>
</H2>

<P> This is very simple way to use pipes.
<BLOCKQUOTE><CODE>
<PRE>
        ls -l | sed -e "s/[aeio]/u/g"   
        
</PRE>
</CODE></BLOCKQUOTE>

Here, the following happens: first the command ls -l is executed, and it's output, 
instead of being printed, is sent (piped) to the sed program, which in turn, prints
what it has to. 
<H2><A NAME="ss4.3">4.3 Sample: an alternative to ls -l *.txt  </A>
</H2>

<P> Probably, this is a more difficult way to do ls -l *.txt, but it is here for illustrating pipes,
not for solving such listing dilema. 
<BLOCKQUOTE><CODE>
<PRE>
        ls -l | grep "\.txt$"
        
</PRE>
</CODE></BLOCKQUOTE>

Here, the output of the program ls -l is sent to the grep program, which, in turn, will print 
lines which match the regex "\.txt$".
<HR>
<A HREF="Bash-Prog-Intro-HOWTO-5.html">Next</A>
<A HREF="Bash-Prog-Intro-HOWTO-3.html">Previous</A>
<A HREF="Bash-Prog-Intro-HOWTO.html#toc4">Contents</A>
</BODY>
</HTML>
