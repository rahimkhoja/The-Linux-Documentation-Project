<HTML
><HEAD
><TITLE
>Installation In Detail</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"><LINK
REL="HOME"
TITLE="The Linux Installation HOWTO"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="Installation Overview"
HREF="overview.html"><LINK
REL="NEXT"
TITLE="Booting Your New System"
HREF="firstboot.html"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>The Linux Installation HOWTO</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="overview.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="firstboot.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="DETAILS">6. Installation In Detail</H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="PREPARING">6.1. Getting prepared for installation</H2
><P
>Linux makes more effective use of PC hardware than MS-DOS, Windows
or NT, and is accordingly less tolerant of misconfigured hardware.
There are a few things you can do before you start that will lessen
your chances of being stopped by this kind of problem.</P
><P
>First, collect any manuals you have on your hardware -- motherboard,
video card, monitor, modem, etc. -- and put them within easy reach.</P
><P
>Second, gather detailed information on your hardware configuration.
One easy way to do this, if you're running MS-DOS 5.0, or up, is to
print a report from the Microsoft diagnostic utility msd.exe (you
can leave out the TSR, driver, memory-map, environment-strings and
OS-version parts).  Among other things, this will guarantee you
full and correct information on your video card and mouse type,
which will be helpful in configuring X later on.</P
><P
>Third, check your machine for configuration problems with
supported hardware that could cause an un-recoverable lockup
during Linux installation.</P
><P
></P
><UL
><LI
><P
>It is possible for a DOS/Windows system using IDE hard
drive(s) and CD ROM to be functional even with the master/slave
jumpers on the drives incorrectly set.  Linux won't fly this way.
If in doubt, check your master-slave jumpers!</P
></LI
><LI
><P
>Is any of your peripheral hardware designed with neither
configuration jumpers nor non-volatile configuration memory?  If
so, it may require boot-time initialization via an MS-DOS utility
to start up, and may not be easily accessible from Linux.  CD-ROMs,
sound cards, Ethernet cards and low-end tape drives can have this
problem.  If so, you may be able to work around this with an
argument to the boot prompt; see the<A
HREF="http://www.linuxdoc.org/HOWTO/BootPrompt-HOWTO.html"
TARGET="_top"
>Linux Boot Prompt HOWTO</A
> for
details).</P
></LI
><LI
><P
>Some other operating systems will allow a bus mouse to share an
IRQ with other devices.  Linux doesn't support this; in fact, trying it may
lock up your machine.  If you are using a bus mouse, see the <A
HREF="http://www.linuxdoc.org/HOWTO/Busmouse-HOWTO.html"
TARGET="_top"
>Linux Bus Mouse HOWTO</A
>, for
details.</P
></LI
></UL
><P
>If possible, get the telephone number of an experienced Linux user
you can call in case of emergency.  Nine times out of ten you won't
need it, but it's comforting to have.</P
><P
>Budget time for installation.  That will be about one hour on
a bare system or one being converted to all-Linux operation.  Or
up to three hours for a dual-boot system (they have a much higher
incidence of false starts and hangups).</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BOOTROOT">6.2. Creating the boot and root floppies</H2
><P
>(This step is only needed if you can't boot from a CD-ROM.)</P
><P
>Your Linux CD-ROM may come with installation aids that will take
you through the process of building boot, root, and rescue disks
with interactive prompts.  These may be an MS-DOS installation
program (such as the Red Hat <B
CLASS="COMMAND"
>redhat.exe</B
> program) or a Unix
script, or both.</P
><P
>If you have such a program and can use it, you should read the rest
of this subsection for information only.  Run the program to do
actual installation -- its authors certainly knew more about the
specific distribution than I, and you'll avoid many error-prone
hand-entry steps.</P
><P
>More detailed information on making bootdisks, see the
<A
HREF="http://www.linuxdoc.org/HOWTO/Bootdisk-HOWTO.html"
TARGET="_top"
>Linux Bootdisk HOWTO</A
>.</P
><P
>Your first step will be to select a boot-disk image to fit your
hardware.  If you must do this by hand, you'll generally find that either
(a) the bootdisk images on your CD-ROM are named in a way that will help
you pick a correct one, or (b) there's an index file nearby describing each
image.</P
><P
>Next, you must create floppies from the bootdisk image you selected,
and optionally from the rescue disk images.  This is where the MS-DOS
program RAWRITE.EXE comes into play.</P
><P
>Next, you must have two or three <EM
>high-density</EM
>
MS-DOS formatted floppies.  (They must be of the same type; that is, if
your boot floppy drive is a 3.5" drive, both floppies must be
high-density 3.5" disks.) You will use RAWRITE.EXE to write the
bootdisk images to the floppies.</P
><P
>Invoke it with no arguments, like this:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>C:\&#62; RAWRITE</PRE
></FONT
></TD
></TR
></TABLE
><P
>Answer the prompts for the name of the file to write and the floppy
to write it to (such as A:). RAWRITE will copy the file, block-by-block,
directly to the floppy. Also use RAWRITE for the root disk image (such as
COLOR144). When you're done, you'll have two floppies: one containing the
boot disk, the other containing the root disk. Note that these two floppies
will no longer be readable by MS-DOS (they are ``Linux format'' floppies,
in some sense).</P
><P
>You can use the dd(1) commands on a UNIX system to do the same job.
(For this, you will need a UNIX workstation with a floppy drive, of
course.)  For example, on a Sun workstation with the floppy drive on device
<TT
CLASS="FILENAME"
>/dev/rfd0</TT
>, you can use the command:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>$ dd if=bare of=/dev/rfd0 obs=18k</PRE
></FONT
></TD
></TR
></TABLE
><P
>You must provide the appropriate output block size argument (the `obs'
argument) on some workstations (e.g., Suns) or this will fail. If
you have problems the man page for dd(1) may be be instructive.</P
><P
>Be sure that you're using brand-new, error-free floppies. The
floppies must have no bad blocks on them.</P
><P
>Note that you do not need to be running Linux or MS-DOS in order to
install Linux.  However, running Linux or MS-DOS makes it easier to
create the boot and root floppies from your CD-ROM. If you don't
have an operating system on your machine, you can use someone
else's Linux or MS-DOS just to create the floppies, and install
from there.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="REPARTITIONING">6.3. Repartitioning your DOS/Windows drives</H2
><P
>On most used systems, the hard drive is already dedicated to
partitions for MS-DOS, OS/2, and so on.  You'll need to resize
these partitions in order to make space for Linux.  If you're going
to run a dual-boot system, it's strongly recommended that you read
one or more of the following mini-HOWTOS, which describe different
dual-boot configurations.</P
><P
></P
><UL
><LI
><P
><A
HREF="http://www.linuxdoc.org/HOWTO/mini/Linux+DOS+Win95+OS2.html"
TARGET="_top"
>The
DOS-Win95-OS2-Linux mini-HOWTO</A
>.</P
></LI
><LI
><P
><A
HREF="http://www.linuxdoc.org/HOWTO/mini/Linux+Win95.html"
TARGET="_top"
>The Linux+Win95
mini-HOWTO</A
>.</P
></LI
><LI
><P
><A
HREF="http://www.linuxdoc.org/HOWTO/mini/Linux+NT-Loader.html"
TARGET="_top"
>The
Linux+NT-Loader mini-HOWTO</A
></P
></LI
></UL
><P
>Even if they are not directly applicable to your system, they will
help you understand the issues involved.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Some Linuxes will install to a directory on your MS-DOS
partition. (This is different than installing <EM
>from</EM
> an
MS-DOS partition.) Instead, you use the ``UMSDOS filesystem'', which allows
you to treat a directory of your MS-DOS partition as a Linux filesystem. In
this way, you don't have to repartition your drive.</P
></TD
></TR
></TABLE
></DIV
><P
>I only suggest using this method if your drive already has four
partitions (the maximum supported by DOS) and repartitioning would
be more trouble than it's worth (it slows down your Linux due to
filename translation overhead).  Or, if you want to try out Linux
before repartitioning, this is a good way to do so. But in most
cases you should re-partition, as described here. If you do plan to
use UMSDOS, you are on your own -- it is not documented in detail
here. From now on, we assume that you are NOT using UMSDOS, and
that you will be repartitioning.</P
><P
>A <I
CLASS="FIRSTTERM"
>partition</I
> is just a section of the hard drive
set aside for a particular operating system to use. If you only have MS-DOS
installed, your hard drive probably has just one partition, entirely for
MS-DOS. To use Linux, however, you'll need to repartition the drive, so
that you have one partition for MS-DOS, and one (or more) for Linux.</P
><P
>Partitions come in three flavors: <I
CLASS="FIRSTTERM"
>primary</I
>,
<I
CLASS="FIRSTTERM"
>extended</I
>, and <I
CLASS="FIRSTTERM"
>logical</I
>.  Briefly,
primary partitions are one of the four main partitions on your
drive. However, if you wish to have more than four partitions per drive,
you need to replace the last primary partition with an extended partition,
which can contain many logical partitions.  You don't store data directly
on an extended partition---it is used only as a container for logical
partitions. Data is stored only on either primary or logical
partitions.</P
><P
>To put this another way, most people use only primary partitions.
However, if you need more than four partitions on a drive, you
create an extended partition. Logical partitions are then created
on top of the extended partition, and there you have it---more than
four partitions per drive.</P
><P
>Note that you can easily install Linux on the second drive on your
system (known as D: to MS-DOS). You simply specify the
appropriate device name when creating Linux partitions. This is
described in detail below.</P
><P
>Back to repartitioning your drive. It used to be that there was no way to
resize partitions without destroying the data on them.  Nowadays there are
partitioning utilities that can resize non-destructively; they know about
the structure of file systems, can find the free space on a file system,
and can move file data around on the partition to move free space where it
needs to be in order for a resize to work properly.  It's still suggested
that you make a full backup before using one of these, in case of program
or human error.</P
><P
>Under Linux <A
HREF="http://www.gnu.org/software/parted"
TARGET="_top"
>GNU
parted</A
> allows you to create, destroy, resize and copy partitions.  It
supports ext2, FAT16, and FAT32 filesystems, Linux swap devices; it also
knows about MS-DOS disk labels. Parted is useful for creating space for new
operating systems, reorganising disk usage, copying data between hard
disks, and disk imaging.  It is relatively new code, but is reported to
work well and not trash data.</P
><P
>There is a non-destructive disk repartitioner available for MS-DOS,
called <A
HREF="http://metalab.unc.edu/pub/Linux/system/install"
TARGET="_top"
>FIPS</A
>. With
FIPS, a disk optimizer (such as Norton Speed Disk), and a little bit of
luck, you should be able to resize MS-DOS partitions without destroying the
data on them.</P
><P
>The older method of resizing a partition, if you don't have one of these
resizing partition editors available, is to delete the partition(s), and
re-create them with smaller sizes.  If you use this method, you absolutely
must make a backup in order to save any of your data.</P
><P
>The classic way to modify partitions is with the program
<B
CLASS="COMMAND"
>FDISK</B
>. For example, let's say that you have an 80 meg
hard drive, dedicated to MS-DOS. You'd like to split it in half---40 megs
for MS-DOS and 40 megs for Linux. In order to do this, you run
<B
CLASS="COMMAND"
>FDISK</B
> under MS-DOS, delete the 80 meg MS-DOS partition,
and re-create a 40 meg MS-DOS partition in its place. You can then format
the new partition and reinstall your MS-DOS software from backups. 40
megabytes of the drive is left empty. Later, you create Linux partitions on
the unused portion of the drive.</P
><P
>In short, you should do the following to resize MS-DOS partitions
with <B
CLASS="COMMAND"
>FDISK</B
>:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Make a full backup of your system.</P
></LI
><LI
><P
>Create an MS-DOS bootable floppy, using a command such as

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>FORMAT /S A:</PRE
></FONT
></TD
></TR
></TABLE
>

Copy the files <B
CLASS="COMMAND"
>FDISK.EXE</B
> and
<B
CLASS="COMMAND"
>FORMAT.COM</B
> to this floppy, as well as any other
utilities that you need. (For example, utilities to recover your system
from backup.)</P
></LI
><LI
><P
>Boot the MS-DOS system floppy.</P
></LI
><LI
><P
>Run <B
CLASS="COMMAND"
>FDISK</B
>, possibly specifying the drive to modify (such as
C: or D:).</P
></LI
><LI
><P
>Use the FDISK menu options to delete the partitions which
you wish to resize. <EM
>This will destroy all data on the affected
partitions.</EM
></P
></LI
><LI
><P
>Use the FDISK menu options to re-create those partitions,
with smaller sizes.</P
></LI
><LI
><P
>Exit FDISK and re-format the new partitions with the
<B
CLASS="COMMAND"
>FORMAT</B
> command.</P
></LI
><LI
><P
>Restore the original files from backup.</P
></LI
></OL
><P
>Note that MS-DOS FDISK will give you an option to create
a ``logical DOS drive''. A logical DOS drive is just a logical
partition on your hard drive. You can install Linux on a logical
partition, but you don't want to create that logical partition
with MS-DOS fdisk. So, if you're currently using a logical
DOS drive, and want to install Linux in its place, you should
delete the logical drive with MS-DOS FDISK, and (later)
create a logical partition for Linux in its place.</P
><P
>The mechanism used to repartition for OS/2 and other operating 
systems is similar. See the documentation for those operating
systems for details.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN365">6.4. Creating partitions for Linux</H2
><P
>After repartitioning your drive, you need to create partitions for
Linux. Before describing how to do that, we'll talk about
partitions and filesystems under Linux.</P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="PARTBASICS">6.4.1. Partition basics</H3
><P
>Linux requires at least one partition, for the <I
CLASS="FIRSTTERM"
>root
filesystem</I
>, which will hold the Linux kernel itself.</P
><P
>You can think of a <I
CLASS="FIRSTTERM"
>filesystem</I
> as a partition
formatted for Linux. Filesystems are used to hold files. Every system must
have a root filesystem, at least. However, many users prefer to use
multiple filesystems---one for each major part of the directory tree. For
example, you may wish to create a separate filesystem to hold all files
under the <TT
CLASS="FILENAME"
>/usr</TT
> directory.  (Note that on UNIX systems,
forward slashes are used to delimit directories, not backslashes as with
MS-DOS.) In this case you have both a root filesystem, and a
<TT
CLASS="FILENAME"
>/usr</TT
> filesystem.</P
><P
>Each filesystem requires its own partition. Therefore, if you're
using both root and <TT
CLASS="FILENAME"
>/usr</TT
> filesystems, you'll need to
create two Linux partitions. </P
><P
>In addition, most users create a <I
CLASS="FIRSTTERM"
>swap partition</I
>,
which is used for virtual RAM. If you have, say, 4 megabytes of memory on
your machine, and a 10-megabyte swap partition, as far as Linux is
concerned you have 14 megabytes of virtual memory.</P
><P
>When using swap space, Linux moves unused pages of memory out to
disk, allowing you to run more applications at once on your system.
However, because swapping is often slow, it's no replacement for
real physical RAM. But applications that require a great deal of
memory (such as the X window system) often rely on swap space if
you don't have enough physical RAM.</P
><P
>Nearly all Linux users employ a swap partition.  If you have 4
megabytes of RAM or less, a swap partition is required to install
the software. It is strongly recommended that you have a swap
partition anyway, unless you have a great amount of physical RAM.</P
><P
>The size of your swap partition depends on how much virtual memory
you need. It's often suggested that you have at least 16 megabytes
of virtual memory total. Therefore, if you have 8 megs of physical
RAM, you might want to create an 8-megabyte swap partition.  Note that
there are platform-dependent limits on the size of swap partitions;
see the Partition-HOWTO if you want to create a swap partition larger
than 1GB.</P
><P
>You can find more on the theory of swap space layout and disk
partitioning in the Linux Partition mini-HOWTO (<A
HREF="http://www.linuxdoc.org/HOWTO/mini/Partition.html"
TARGET="_top"
>http://www.linuxdoc.org/HOWTO/mini/Partition.html</A
>).</P
><P
>Note: it is possible, though a bit tricky, to share swap partitions
between Linux and Windows 95 in a dual-boot system.  For details, see the
<A
HREF="ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/unmaintained/mini/Swap-Space"
TARGET="_top"
>Linux
Swap Space Mini-HOWTO</A
>.</P
><P
>Gotcha #1: If you have an EIDE drive with a partition that goes
above 504MB, your BIOS may not allow you to boot to a Linux installed
there.  So keep your root partition below 504MB. This shouldn't be a
problem for SCSI drive controllers, which normally have their own drive
BIOS firmware.  For technical details, see the <A
HREF="http://www.linuxdoc.org/HOWTO/mini/Large-Disk.html"
TARGET="_top"
>Large Disk Mini-HOWTO</A
>.</P
><P
>Gotcha #2: Are you mixing IDE and SCSI drives?  Then watch out.
Your BIOS may not allow you to boot directly to a SCSI drive.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="PARTSIZING">6.4.2. Sizing partitions</H3
><P
>Besides your root and swap partitions, you'll want to set up
one or more partitions to hold your software and home directories.</P
><P
>While, in theory, you could run everything off a single huge root
partition, almost nobody does this.  Having multiple partitions
has several advantages:</P
><P
></P
><UL
><LI
><P
>It often cuts down the time required for boot-time file-system
checks.</P
></LI
><LI
><P
>Files can't grow across partition boundaries.  Therefore
you can use partition boundaries as firebreaks against programs
(like Usenet news) that want to eat huge amounts of disk, to
prevent them from crowding out file space needed by your kernel
and the rest of your applications.</P
></LI
><LI
><P
>If you ever develop a bad spot on your disk, formatting
and restoring a single partition is less painful than having to
redo everything from scratch.</P
></LI
></UL
><P
>On today's large disks, a good basic setup is to have a small root
partition (less than 80 meg), a medium-sized /usr partition (up to
300 meg or so) to hold system software, and a /home partition
occupying the rest of your available space for home directories.</P
><P
>You can get more elaborate.  If you know you're going to run
Usenet news, for example, you may want to give it a partition
of its own to control its maximum possible disk usage.  Or create
a /var partition for mail, news, and temporary files all together.  
But in today's regime of very cheap, very large hard disks these
complications seem less and less necessary for your first Linux
installation.  For your first time, especially, keep it simple.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="BOOTING">6.5. Booting the installation disk</H2
><P
>The first step is to boot the bootdisk you generated.  Normally
you'll be able to boot hands-off; the boot kernel prompt will fill
itself in after 10 seconds.  This is how you'll normally boot from
an IDE disk.</P
><P
>What's actually happening here is this: the boot disk provides a
miniature operating system which (because the hard drive isn't
prepared) uses a portion of your RAM as a virtual disk (called,
logically enough, a `ramdisk').</P
><P
>The boot disk loads onto the ramdisk a small set of files and
installation tools which you'll use to prepare your hard drive and
install a production Linux on it from your CD-ROM.</P
><P
>(In times past this was a two-stage-process, involving a second disk
called a `root disk'; this changed when kernel modules were introduced.)</P
><P
>By giving arguments after the kernel name, you can specify various
hardware parameters, such as your SCSI controller IRQ and address,
or drive geometry, before booting the Linux kernel.  This may be
necessary if Linux does not detect your SCSI controller or hard
drive geometry, for example.</P
><P
>In particular, many BIOS-less SCSI controllers require you to
specify the port address and IRQ at boot time. Likewise, IBM PS/1,
ThinkPad, and ValuePoint machines do not store drive geometry in
the CMOS, and you must specify it at boot time.  (Later on,
you'll be able to configure your production system to supply
such parameters itself.)</P
><P
>Watch the messages as the system boots. They will list and describe
the hardware your installation Linux detects.  In particular, if you
have a SCSI controller, you should see a listing of the SCSI hosts
detected.  If you see the message</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>SCSI: 0 hosts</PRE
></FONT
></TD
></TR
></TABLE
><P
>Then your SCSI controller was not detected, and you will have to
figure out how to tell the kernel where it is.</P
><P
>Also, the system will display information on the drive partitions
and devices detected. If any of this information is incorrect or
missing, you will have to force hardware detection.</P
><P
>On the other hand, if all goes well and your hardware seems to be
detected, you can skip to the following section, ``Loading the
root disk.''</P
><P
>To force hardware detection, you must enter the appropriate
parameters at the boot prompt, using the following syntax:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>linux &#60;parameters...&#62;</PRE
></FONT
></TD
></TR
></TABLE
><P
>There are a number of such parameters available; we list some of
the most common below.  Modern Linux boot disks will often give
you the option to look at help screen describing kernel parameters
before you boot.</P
><P
></P
><UL
><LI
><P
><EM
>hd=cylinders,heads,sectors</EM
> Specify the drive geometry.
Required for systems such as the IBM PS/1, ValuePoint, and ThinkPad.
For example, if your drive has 683 cylinders, 16 heads, and 32 sectors
per track, enter

<TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>linux hd=683,16,32</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
><EM
>tmc8xx=memaddr,irq</EM
> Specify address and
IRQ for BIOS-less Future Domain TMC-8xx SCSI controller. For
example,</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>linux tmc8xx=0xca000,5</PRE
></FONT
></TD
></TR
></TABLE
><P
>Note that the <EM
>0x</EM
> prefix must be used for all
values given in hex. This is true for all of the following
options.</P
></LI
><LI
><P
><EM
>st0x=memaddr,irq</EM
> Specify address and
IRQ for BIOS-less Seagate ST02 controller.</P
></LI
><LI
><P
><EM
>t128=memaddr,irq</EM
> Specify address and
IRQ for BIOS-less Trantor T128B controller.</P
></LI
><LI
><P
><EM
>ncr5380=port,irq,dma</EM
> Specify port,
IRQ, and DMA channel for generic NCR5380 controller.</P
></LI
><LI
><P
><EM
>aha152x=port,irq,scsi_id,1</EM
> Specify
port, IRQ, and SCSI ID for BIOS-less AIC-6260 controllers. This includes
Adaptec 1510, 152x, and Soundblaster-SCSI controllers.</P
></LI
></UL
><P
>If you have questions about these boot-time options, please read the
Linux <I
CLASS="CITETITLE"
>SCSI HOWTO</I
>, which should be available on any
Linux FTP archive site (or from wherever you obtained this document).  The
<I
CLASS="CITETITLE"
>SCSI HOWTO</I
> explains Linux SCSI compatibility in much
more detail.</P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="EGAORX">6.5.1. Choosing Console or X installation</H3
><P
>After boot, all current Linuxes run a screen-oriented installation
program which tries to interactively walk you through these steps, giving
lots of help.</P
><P
>You will probably get the option to try to configure X right away
so the installation program can go graphical.  If you choose this
route, the installation program will quiz you about your mouse and
monitor type before getting to the installation proper.  Once you
get your production Linux installed, these settings will be saved
for you.  You will be able to tune your monitor's performance
later, so at this stage it makes sense to settle for a basic
640x480 SVGA mode.</P
><P
>X isn't necessary for installation, but (assuming you can get
past the mouse and monitor configuration) many people find the
graphical interface easier to use.  And you're going to want to
bring up X anyway, so trying it early makes some sense.</P
><P
>Just follow the prompts in the program.  It will take you through
the steps necessary to prepare your disk, create initial user
accounts, and install software packages off the CD-ROM.</P
><P
>In the following subsections we'll describe some of the tricky
areas in the installation sequence as if you were doing them
by hand.  This should help you understand what the installation
program is doing, and why.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="FDISK">6.5.2. Using <B
CLASS="COMMAND"
>fdisk</B
> and <B
CLASS="COMMAND"
>cfdisk</B
></H3
><P
>Your first installation step once the root-disk Linux is booted
will be to create or edit the partition tables on your disks.
Even if you used FDISK to set up partitions earlier, you'll
need to go back to the partition table now and insert some
Linux-specific information now.</P
><P
>To create or edit Linux partitions, we'll use the Linux version of
the <B
CLASS="COMMAND"
>fdisk</B
> program, or its screen-oriented sibling
<B
CLASS="COMMAND"
>cfdisk</B
>.  Note that the argument to the
<B
CLASS="COMMAND"
>fdisk</B
> needs to be the device corresponding to an entire
disk (e.g. <TT
CLASS="FILENAME"
>/dev/sda</TT
>) rather than any of its partitions
(such as <TT
CLASS="FILENAME"
>/dev/sda1</TT
>).</P
><P
>Generally the installation program will look for a preexisting
partition table and offer to run <B
CLASS="COMMAND"
>fdisk</B
> or
<B
CLASS="COMMAND"
>cfdisk</B
> on it for you.  Of the two,
<B
CLASS="COMMAND"
>cfdisk</B
> is definitely easier to use, but current versions
of it are also less tolerant of a nonexistent or garbled partition
table.</P
><P
>Therefore you may find (especially if you're installing on virgin
hardware) that you need to start with <B
CLASS="COMMAND"
>fdisk</B
> to get to a
state that <B
CLASS="COMMAND"
>cfdisk</B
> can deal with.  Try running
<B
CLASS="COMMAND"
>cfdisk</B
>; if it complains, run <B
CLASS="COMMAND"
>fdisk</B
>.
(A good way to proceed if you're building an all-Linux system and
<B
CLASS="COMMAND"
>cfdisk</B
> complains is to use <B
CLASS="COMMAND"
>fdisk</B
> to
delete all the existing partions and then fire up <B
CLASS="COMMAND"
>cfdisk</B
>
to edit the empty table.)</P
><P
>A few notes apply to both <B
CLASS="COMMAND"
>fdisk</B
> and
<B
CLASS="COMMAND"
>cfdisk</B
>.  Both take an argument which is the name of the
drive that you wish to create Linux partitions on. Hard drive device names
are:</P
><P
></P
><UL
><LI
><P
><TT
CLASS="FILENAME"
>/dev/hda</TT
> First IDE drive</P
></LI
><LI
><P
><TT
CLASS="FILENAME"
>/dev/hdb</TT
> Second IDE drive</P
></LI
><LI
><P
><TT
CLASS="FILENAME"
>/dev/sda</TT
> First SCSI drive</P
></LI
><LI
><P
><TT
CLASS="FILENAME"
>/dev/sdb</TT
> Second SCSI drive</P
></LI
></UL
><P
>For example, to create Linux partitions on the first SCSI drive in
your system, you will use (or your installation program might
generate from a menu choice) the command:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>cfdisk /dev/sda</PRE
></FONT
></TD
></TR
></TABLE
><P
>If you use <B
CLASS="COMMAND"
>fdisk</B
> or <B
CLASS="COMMAND"
>cfdisk</B
>
without an argument, it will assume <TT
CLASS="FILENAME"
>/dev/hda</TT
>.</P
><P
>To create Linux partitions on the second drive on your system,
simply specify either <TT
CLASS="FILENAME"
>/dev/hdb</TT
> (for IDE drives)
or <TT
CLASS="FILENAME"
>/dev/sdb</TT
> (for SCSI drives)
when running <B
CLASS="COMMAND"
>fdisk</B
>.</P
><P
>Your Linux partitions don't all have to be on the same drive.  You
might want to create your root filesystem partition on
<TT
CLASS="FILENAME"
>/dev/hda</TT
> and your swap partition on
<TT
CLASS="FILENAME"
>/dev/hdb</TT
>, for example. In order to do so just run
<B
CLASS="COMMAND"
>fdisk</B
> or <B
CLASS="COMMAND"
>cfdisk</B
> once for each
drive.</P
><P
>In Linux, partitions are given a name based on the drive which they
belong to. For example, the first partition on the drive
<TT
CLASS="FILENAME"
>/dev/hda</TT
> is <TT
CLASS="FILENAME"
>/dev/hda1</TT
>, the second
is <TT
CLASS="FILENAME"
>/dev/hda2</TT
>, and so on. If you have any logical
partitions, they are numbered starting with <TT
CLASS="FILENAME"
>/dev/hda5</TT
>,
<TT
CLASS="FILENAME"
>/dev/hda6</TT
> and so on up.</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>You should not create or delete partitions for operating
systems other than Linux with Linux <B
CLASS="COMMAND"
>fdisk</B
> or
<B
CLASS="COMMAND"
>cfdisk</B
>. That is, don't create or delete MS-DOS
partitions with this version of <B
CLASS="COMMAND"
>fdisk</B
>; use MS-DOS's
version of <B
CLASS="COMMAND"
>FDISK</B
> instead. If you try to create MS-DOS
partitions with Linux <B
CLASS="COMMAND"
>fdisk</B
>, chances are MS-DOS will not
recognize the partition and not boot correctly.</P
></TD
></TR
></TABLE
></DIV
><P
>Here's an example of using <B
CLASS="COMMAND"
>fdisk</B
>. Here, we have a
single MS-DOS partition using 61693 blocks on the drive, and the rest of
the drive is free for Linux. (Under Linux, one block is 1024
bytes. Therefore, 61693 blocks is about 61 megabytes.)  We will create just
two partitions in this tutorial example, swap and root.  You should
probably extend this to four Linux partitions in line with the
recommendations above: one for swap, one for the root filesystem, one for
system software, and a home directory area.</P
><P
>First, we use the ``<B
CLASS="COMMAND"
>p</B
>'' command to display the
current partition table.  As you can see, <TT
CLASS="FILENAME"
>/dev/hda1</TT
>
(the first partition on <TT
CLASS="FILENAME"
>/dev/hda</TT
>) is a DOS partition
of 61693 blocks.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Command (m for help):   p
Disk /dev/hda: 16 heads, 38 sectors, 683 cylinders 
Units = cylinders of 608 * 512 bytes

     Device Boot  Begin   Start     End  Blocks   Id  System
  /dev/hda1   *       1       1     203   61693    6  DOS 16-bit &#62;=32M

Command (m for help):</PRE
></FONT
></TD
></TR
></TABLE
><P
>Next, we use the ``<B
CLASS="COMMAND"
>n</B
>'' command to create a new
partition. The Linux root partition will be 80 megs in size.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Command (m for help):  n 
Command action 
    e   extended 
    p   primary partition (1-4)
p</PRE
></FONT
></TD
></TR
></TABLE
><P
>Here we're being asked if we want to create an extended or
primary partition. In most cases you want to use primary
partitions, unless you need more than four partitions on a
drive. See the section ``Repartitioning'', above, for more
information.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Partition number (1-4): 2
First cylinder (204-683):  204
Last cylinder or +size or +sizeM or +sizeK (204-683): +80M</PRE
></FONT
></TD
></TR
></TABLE
><P
>The first cylinder should be the cylinder AFTER where the last
partition left off. In this case, <TT
CLASS="FILENAME"
>/dev/hda1</TT
> ended on
cylinder 203, so we start the new partition at cylinder 204.</P
><P
>As you can see, if we use the notation ``+80M'', it specifies a
partition of 80 megs in size. Likewise, the notation ``+80K'' 
would specify an 80 kilobyte partition, and ``+80'' would 
specify just an 80 byte partition.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Warning: Linux cannot currently use 33090 sectors of this partition</PRE
></FONT
></TD
></TR
></TABLE
><P
>If you see this warning, you can ignore it. It is left over from an
old restriction that Linux filesystems could only be 64 megs in
size. However, with newer filesystem types, that is no longer the
case... partitions can now be up to 4 terabytes in size.</P
><P
>Next, we create our 10 megabyte swap partition,
<TT
CLASS="FILENAME"
>/dev/hda3</TT
>.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Command (m for help): n
Command action 
    e   extended 
    p   primary partition (1-4) 
p

Partition number (1-4): 3
First cylinder (474-683):  474
Last cylinder or +size or +sizeM or +sizeK (474-683):  +10M</PRE
></FONT
></TD
></TR
></TABLE
><P
>Again, we display the contents of the partition table. Be
sure to write down the information here, especially the size of 
each partition in blocks. You need this information later.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Command (m for help): p
Disk /dev/hda: 16 heads, 38 sectors, 683 cylinders 
Units = cylinders of 608 * 512 bytes

     Device Boot  Begin   Start     End  Blocks   Id  System
  /dev/hda1   *       1       1     203   61693    6  DOS 16-bit &#62;=32M
  /dev/hda2         204     204     473   82080   83  Linux native
  /dev/hda3         474     474     507   10336   83  Linux native</PRE
></FONT
></TD
></TR
></TABLE
><P
>Note that the Linux swap partition (here,
<TT
CLASS="FILENAME"
>/dev/hda3</TT
>) has type ``Linux native''. We need to
change the type of the swap partition to ``Linux swap'' so that the
installation program will recognize it as such. In order to do this, use
the <B
CLASS="COMMAND"
>fdisk</B
> ``t'' command:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Command (m for help): t
Partition number (1-4): 3
Hex code (type L to list codes): 82</PRE
></FONT
></TD
></TR
></TABLE
><P
>If you use ``<B
CLASS="COMMAND"
>L</B
>'' to list the type codes, you'll
find that 82 is the type corresponding to Linux swap.</P
><P
>To quit <B
CLASS="COMMAND"
>fdisk</B
> and save the changes to the
partition table, use the ``w'' command. To quit
<B
CLASS="COMMAND"
>fdisk</B
> WITHOUT saving changes, use the
``q'' command.</P
><P
>After quitting <B
CLASS="COMMAND"
>fdisk</B
>, the system may tell you to
reboot to make sure that the changes took effect. In general there is no
reason to reboot after using <B
CLASS="COMMAND"
>fdisk</B
>---modern versions of
<B
CLASS="COMMAND"
>fdisk</B
> and <B
CLASS="COMMAND"
>cfdisk</B
> are smart enough to
update the partitions without rebooting.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="POSTPARTITION">6.5.3. Post-partition steps</H3
><P
>After you've edited the partition tables, your installation program
should look at them and offer to enable your swap partition for
you.  Tell it yes.</P
><P
>(This is made a question, rather than done automatically, on the off
chance that you're running a dual-boot system and one of your
non-Linux partitions might happen to look like a swap volume.)</P
><P
>Next the program will ask you to associate Linux filesystem names
(such as /, /usr, /var, /tmp, /home, /home2, etc.) with each of the
non-swap partitions you're going to use.</P
><P
>There is only one hard and fast rule for this.  There must be a
root filesystem, named /, and it must be bootable.  You can name
your other Linux partitions anything you like.  But there are some
conventions about how to name them which will probably simplify
your life later on.</P
><P
>Earlier on I recommended a basic three-partition setup including a
small root, a medium-sized system-software partition, and a large
home-directory partition.  Traditionally, these would be called /,
/usr, and /home.  The counterintuitive `/usr' name is a historical
carryover from the days when (much smaller) Unix systems carried
system software and user home directories on a single non-root
partition.  Some software depends on it.</P
><P
>If you have more than one home-directory area, it's conventional
to name them /home, /home2, /home3, etc.  This may come up if you
have two physical disks.  On my personal system, for example, the
layout currently looks like this:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>Filesystem         1024-blocks  Used Available Capacity Mounted on
/dev/sda1              30719   22337     6796     77%   /
/dev/sda3             595663  327608   237284     58%   /usr
/dev/sda4            1371370    1174  1299336      0%   /home
/dev/sdb1            1000949  643108   306130     68%   /home2</PRE
></FONT
></TD
></TR
></TABLE
><P
>The second disk (sdb1) isn't really all /home2; the swap
partitions on sda and sdb aren't shown in this display.
But you can see that /home is the large free area on sda
and /home2 is the user area of sdb.</P
><P
>If you want to create an partition for scratch, spool, temporary,
mail, and news files, call it /var.  Otherwise you'll probably
want to create a /usr/var and create a symbolic link named
/var that points back to it (the installation program may
offer to do this for you).</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="INSTALLING">6.6. Installing software packages</H2
><P
>Once you've gotten past preparing your partitions, the remainder of
the installation should be almost automatic.  Your installation
program (whether EGA or X-based) will guide you through a series of
menus which allow you to specify the CD-ROM to install from, the
partitions to use, and so forth.</P
><P
>Here we're not going to document many of the specifics of this
stage of installation.  It's one of the parts that varies most
between Linux distributions (vendors traditionally compete to add
value here), but also the simplest part.  And the installation
programs are pretty much self-explanatory, with good on-screen
help.</P
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AFTERWARDS">6.7. After package installations</H2
><P
>After installation is complete, and if all goes well, the
installation program will walk you through a few options 
for configuring your system before its first boot from hard drive.</P
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="LILO">6.7.1. LILO, the LInux LOader</H3
><P
>LILO (which stands for LInux LOader) is a program that will allow
you to boot Linux (as well as other operating systems, such as
MS-DOS) from your hard drive.</P
><P
>You may be given the option of installing LILO on your hard drive.
Unless you're running OS/2, answer `yes'.  OS/2 has special
requirements; see <A
HREF="afterboot.html#CUSTOM-LILO"
>Custom LILO
Configuration</A
> below.</P
><P
>Installing LILO as your primary loader makes a separate boot
diskette unnecessary; instead, you can tell LILO at each boot time
which OS to boot.</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="BOOTDISK">6.7.2. Making a production boot disk (optional)</H3
><P
>You may also be given the chance to create a ``standard boot
disk'', which you can use to boot your newly-installed Linux
system.  (This is an older and slightly less convenient method
which assumes that you will normally boot DOS, but use the boot
disk to start Linux.)</P
><P
>For this you will need a blank, high-density MS-DOS formatted
diskette of the type that you boot with on your system. Simply
insert the disk when prompted and a boot diskette will be created.
(This is not the same as an installation bootdisk, and you can't
substitute one for the other!)</P
></DIV
><DIV
CLASS="SECT3"
><H3
CLASS="SECT3"
><A
NAME="MISC">6.7.3. Miscellaneous system configuration</H3
><P
>The post-installation procedure may also take you through several
menu items allowing you to configure your system. This includes
specifying your modem and mouse device, as well as your time
zone.  Follow the menu options.</P
><P
>It may also prompt you to create user accounts or put a password
on the root (administration) account.  This is not complicated
and you can usually just walk through the screen instructions.</P
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="overview.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="firstboot.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Installation Overview</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Booting Your New System</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>