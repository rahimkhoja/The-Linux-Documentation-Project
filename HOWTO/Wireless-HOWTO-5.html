<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Wireless Howto: Overview on Wireless network setup.</TITLE>
 <LINK HREF="Wireless-HOWTO-6.html" REL=next>
 <LINK HREF="Wireless-HOWTO-4.html" REL=previous>
 <LINK HREF="Wireless-HOWTO.html#toc5" REL=contents>
</HEAD>
<BODY>
<A HREF="Wireless-HOWTO-6.html">Next</A>
<A HREF="Wireless-HOWTO-4.html">Previous</A>
<A HREF="Wireless-HOWTO.html#toc5">Contents</A>
<HR>
<H2><A NAME="s5">5. Overview on Wireless network setup.</A></H2>

<H2><A NAME="ss5.1">5.1 Fundamental steps </A>
</H2>

<P>Once you have got the needed material and you have compiled all the needed
you should do the fundamental step in a Wireless configuration: 
<P>
<OL>
<LI>Low level kernel config Let the Linux Kernel see your Wireless card (at
low level, such as ioport, interrupts, dma...): you must see some kind of kernel
message that advertise you that Wireless card has been right found and configured.
 </LI>
<LI>Data-link level setting For each particular Wireless card there is an utility
that can set typical Wireless data-link level value. For example in Proxim
Symphony the utility is called &quot;rl2cfg&quot; while in pcmcia cards settings
are in pcmcia config files. You have to set all your Wireless cards with coherence
to make them talk together. </LI>
<LI>Ip setting Now you should be able to use ifconfig and route capabilities
to change IP settings.</LI>
<LI>Tricks for better performance and to a avoiding conflicts. Now your Wireless
Network is basically working: in addition you have to adjust some particular
setting like proxy-arp, icmp echo redirect, bridging, channel change and so
on to optimize your network and avoiding strange and bandwidth killing conflicts
 </LI>
</OL>
<P>N.B.: step 1, 2 and 3 correspond to level 1, 2 and 3 of standard ISO/OSI,
while step 4 is an addendum to solve situation generated by netmask 255.255.255.255.
In fact 32 bit netmask violates standard ISO/OSI cause the network force to
use the same address for broadcast and ip machine and the network address doesn't
exist. 
<P>Someone could criticize this point of view, but if you use the standard
ISO/OSI to configure Wireless network with you'll loss many ones configuring
subnets; for each subnet usually you discard 2 IP number (Network and broadcast)
and you cannot achieve the flexibility on IP assigning (geographically kind).
You can find more on Appendix A about this. 
<P>You could notice that step 2 is not present in Wired cards cause there's
no particular settings to do there.
<H2><A NAME="ss5.2">5.2 Low Level Kernel Config </A>
</H2>

<P>Always it's a problem for Pc administration: to let kernel (or in general)
see your hardware. 
<P>Wireless cards are more complex because many of them usually have a Pcmcia
plug, so first of all you have to let your kernel see Pcmcia adapter card,
then you can try to install specific hardware driver for your Wireless card.
<P>
<P>
<PRE>
So, in Pcmcia config you have to: 
</PRE>
<P>
<OL>
<LI>install linux kernel source, from 
<A HREF="http://www.kernel.org">http://www.kernel.org</A> to /usr/src/linux (see tar and gzip
utilities) </LI>
<LI>install linux pcmcia source, from 
<A HREF="ftp://projects.sourceforge.net/pub/pcmcia-cs">ftp://projects.sourceforge.net/pub/pcmcia-cs</A> to install to /usr/src/pcmcia (see tar
and gzip utilities)</LI>
<LI>config and recompile your kernel: read file README in your linux directory
(/usr/src/linux)</LI>
<LI>config and recompile your pcmcia source: under /usr/src/pcmcia use configure
and make. Be sure your driver is here, else your have to install it following
driver instructions (usually a tar zxvf driver.tgz under pcmcia dir is sufficient).
After type &quot;make all&quot; to compile. At the end type &quot;make install&quot;.
 </LI>
<LI>After typed install you'll find some useful config files under /etc/pcmcia
.</LI>
</OL>
<P>
<PRE>
In non pcmcia case: 
</PRE>
<P>
<OL>
<LI>If your driver is present (99% not) under linux sources, you have
to install it in a directory, then to compile it. </LI>
</OL>
<P>Once you know module name you have to load it: in pcmcia config you only
need to start pcmcia daemon (/etc/rc.d/init.d/pcmcia start for RedHat), for
other &quot;modprobe module_name options&quot;. With options you'll give ioport,
irq and data-link settings (see Par 5.3) to Wireless driver. Anyway your useful
tools to know if hardware has correctly been seen by driver are: 
<P>
<OL>
<LI>&quot;tail /var/log/messages&quot; that explains info about syslog </LI>
<LI>&quot;dmesg&quot; for more info. </LI>
<LI>/proc dir: ioports, devices, irq files and driver specific sub-directories.</LI>
</OL>
<H2><A NAME="ss5.3">5.3 Data-link level setting </A>
</H2>

<P>
<PRE>
What is that? 
</PRE>
<P>Wired networks need only to connect each other and then you'll be able
to set TCP/IP parameters. 
<P>In opposite Wireless networks need data-link settings, such as: 
<P>
<OL>
<LI>What kind of Wireless network I belong to? (Adhoc or Infrastructure) </LI>
<LI>What channel I have to use? </LI>
<LI>What subnet (BSSID) I belong to, what is my ESS ID? </LI>
<LI>Is my communication protected by such a encryption algorithm? Length key?
 </LI>
</OL>
<P>As you see there are many settings you have to adjust, the reason come
from the architecture of Wireless network: there could be someone, in near
distance, that could see your packets, use your services only pointing his
antenna on the right direction and setting up right TCP/IP parameters. 
<P>In addition there could be many Wireless subnets that could generate interference
each other. 
<P>So here are: 
<P>
<OL>
<LI>Options at load-time module: &quot;modprobe ray_cs essid='LINUX'&quot;
for example or</LI>
<LI>Utilities at run-time driver: &quot;rl2cfg eth1 master&quot;. </LI>
</OL>
<H2><A NAME="ss5.4">5.4 Ip setting </A>
</H2>

<P>This is the third problem you have to face. Here situation become problematic
only when your network begin to evolve in a bigger one. 
<P>
<PRE>
Remember Wireless IP Networking doesn't stress you if you don't stress it! 
</PRE>
<H3>A simple configuration </H3>

<P>
<PRE>
                       All the hosts view each other
 
                               A - - - - - C
                                 \       /
                               |   \   /   |
                                     /\
                               |   /    \  |
                                 /       \
                               B - - - - - D
</PRE>
<P>A configuration like this is very simple and don't require nothing special
(at Ip level): you only need to assign an IP address for each host and to assign
a coherent global netmask.  
<H3>A more complex configuration </H3>

<P>
<PRE>

                       A doesn't see B directly
 
                                A &lt;- - - -
                              NO\        |
                            TALK\        C
                                \        |
                                B &lt;- - - -
 
</PRE>
<P>Here A and B can communicate only passing through C. 
<P>If the network is in Infrastructure mode and C is the Access Point all
is ok. In Adhoc mode you also can design a host to &quot;master&quot; capability
(I know the term is not so formal!), a host that creates a BSS and to which
any other host can join that BSS. 
<P>Full connectivity now is reached at IP level: A and B talk to C using the
same C interface, so if you try to ping from A to B you'll receive many ICMP
REDIRECT packets from C, cause C is telling A that the destination is already
in the network from which come the request. 
<P>Solution: type a &quot;echo 0 &gt; /proc/sys/net/ipv4/conf/ethx/send_redirects&quot;
(where ethx is the interface on C towards A and C) to null all that. 
<P>Another problem: what netmask I assign to A and C? If you assign a netmask
to A that include A and C nothing works because A don't use the gateway (C)
but make the ARP request with unknown destination MAC address. 
<P>You could think to use proxy arp, but without effect cause proxy arp reply
to source only when the destination is in a different interface from the source:
this is not the case!! 
<P>So you have to set a very little netmask (Win9x let it be 255.255.255.254,
WinNT at least 255.255.255.248), and you have to assure that hosts A and C
don't have the same net address. 
<P>
<PRE>
Examples: 
</PRE>
<P>
<OL>
<LI>IP(A) = x.y.z.2/31, IP(B) = x.y.z.3/31. This doesn't work cause A asks
for B in its network (ARP request) and C doesn't answer cause, for it, A and
B belong to the same interface (so, no proxy arp). </LI>
<LI>IP(A) = x.y.z.1/31, IP(B)= x.y.z.2/31. This works cause A ask to C (send
requests to B with C MAC address) for B. </LI>
</OL>
<P>In general with a netmask 255.255.255.254 system works with 2 IP changing
only for the final bit. 
<P>All that is a TCP/IP forcing but is the only method to obtain an high level
of flexibility. 
<P>Note: If you use an Access Point (network in Infrastructure mode) you haven't
redirect problem, cause all is solved at data-link level (almost every Access
Point acts as a bridge...). But Access Point are expansive (about 1000 USD
or more) and it is more economic to use a P133 32MB Ram to forward, even with
2 or more cards.
<H3>Internet Access </H3>

<P>
<PRE>
                               A - - - - - C - - Internet
                                 \       /
                               |   \   /   |
                                     /\
                               |   /    \  |
                                 /       \
                               B - - - - - D
 
</PRE>
<P>There is a number of situation:
<P>
<OL>
<LI>C is the only Public IP address. You only have to set private IP address
(192.168.x.y for example) for the Wireless network enabling, on C, forwarding
and masquering. A, B and D will have C as default GW. </LI>
<LI>You have a public netmask visible from Internet and C is your default GW
to Internet for the network. You only need to enable forwarding on C, setting
up default GW on A, B and D to point to C. </LI>
<LI>You have a public netmask visible from Internet and C is not the default
GW to Internet. You have 2 possible solutions: Modify your default GW to let
it point to C for your network. Symmetrically you have to let C point to default
GW to go to Internet. You could, instead, enable proxy arp feature to C (echo
1 &gt; /proc/sys/net/ipv4/conf/ethx/proxy_arp where ethx is the interface towards
the default GW) and set your default GW on C to point to the default GW. Proxy
arp is a TCP/IP forcing but works well.</LI>
</OL>
<H3>Mixed network: Wired and Wireless </H3>

<P>
<PRE>
                                Internet         
                                       \      
                                        \        E
                                         \     /
                                          \  /       Wireless
                               A - - - - - C - - F
                                 \       /   \
                               |   \   /   |   \
                        Wired        /\          G
                               |   /    \  |
                                 /       \
                               B - - - - - D
 
</PRE>
<P>Now C joins 2 networks: on the right Wireless and Wired on the left. 
<P>More you have Internet Access, so in total you have 3 network cards in
C. 
<P>What IP Address I assign to hosts? You have 2 possible solutions: 
<P>
<OL>
<LI>Split up network in 2 subnets: for example 192.168.1.0/24 and 192.168.2.0/24.
This solution is quickly but is not scalable if you are using Internet IP addresses
cause you have to drop too many IPs. </LI>
<LI>Enable Proxy Arp feature to C for all 2 interfaces. Network parameters
(net address and netmask) are the same for Wireless and Wired, but with proxy-arp
enabled I can choose which IPs are on Wired and which on Wireless. </LI>
</OL>
<P>
<PRE>
Now we examine solution 2
</PRE>
<P>For example: Consider you have Internet public subnet x.y.z.0/24.
<P>
<PRE>
Interfaces are:
</PRE>
<P>
<OL>
<LI>ifconfig eth0 x.y.z.C netmask 255.255.255.255 (Wired) </LI>
<LI>ifconfig eth1 x.y.z.C netmask 255.255.255.255 (Wireless) </LI>
<LI>ifconfig eth2 x.y.z.C netmask 255.255.255.255 (to Internet) </LI>
</OL>
<P>
<PRE>
Static routes on eth2:
</PRE>
<P>
<OL>
<LI>route add IPGW dev eth2 </LI>
<LI>route add default gw IPGW </LI>
</OL>
<P>This route stands for addressing all Internet requests to your Default
GW: as you notice, first you have to tell Linux where is the router, then let
default requesting through it.
<P>
<PRE>
Static routes on eth0:
</PRE>
<P>
<OL>
<LI>route add x.y.z.A dev eth0 </LI>
<LI>route add x.y.z.B dev eth0 </LI>
<LI>route add x.y.z.D dev eth0 </LI>
</OL>
<P>Hosts A,B and D on the Wired Network
<P>
<PRE>
Static routes on eth1:
</PRE>
<P>
<OL>
<LI>route add x.y.z.E dev eth1 </LI>
<LI>route add x.y.z.F dev eth1 </LI>
<LI>route add x.y.z.G dev eth1 </LI>
</OL>
<P>Hosts E,F and G on the Wireless Network
<P>Note that flexibility is very high, but you have to manual set each host.
<P>
<HR>
<A HREF="Wireless-HOWTO-6.html">Next</A>
<A HREF="Wireless-HOWTO-4.html">Previous</A>
<A HREF="Wireless-HOWTO.html#toc5">Contents</A>
</BODY>
</HTML>
