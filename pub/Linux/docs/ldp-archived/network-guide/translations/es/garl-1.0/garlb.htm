<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<TITLE>garlb</TITLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" VLINK="#800080" BGCOLOR="#ffffff">

<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=4 WIDTH=737>
<TR><TD WIDTH="46%" VALIGN="TOP">
      <P><a href="garla.htm"><IMG SRC="left.gif" WIDTH=36 HEIGHT=34 border="0"></a>
    </TD>
<TD WIDTH="11%" VALIGN="TOP">
      <P ALIGN="CENTER"><a href="garl.htm"><IMG SRC="up.gif" WIDTH=34 HEIGHT=36 border="0"></a>
    </TD>
<TD WIDTH="43%" VALIGN="TOP">
      <P ALIGN="RIGHT"><a href="garlc.htm"><IMG SRC="right.gif" WIDTH=36 HEIGHT=34 border="0"></a>
    </TD>
</TR>
</TABLE>

<FONT FACE="Verdana" SIZE=2><P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=4 COLOR="#000080"><P ALIGN="CENTER">Ap&eacute;ndice B</P>
</font></B><P ALIGN="CENTER"><HR><p></P>
<B><U><FONT FACE="Verdana" SIZE=2><P>Ejemplos de Archivos de Configuraci&oacute;n para smail</P>
</font></u></B><FONT FACE="Verdana" SIZE=2><P>Este ap&eacute;ndice muestra ejemplos de archivos de configuraci&oacute;n para un sistema UUCP terminal en una red de &aacute;rea local. Est&aacute;n basados en los archivos de ejemplo que se incluyen en la distribuci&oacute;n de las fuentes de smail-3.1.28. Aun cuando se intenta explicar someramente como trabajan dichos archivos, le aconsejo que lea la p&aacute;gina de manual de smail(8), que trata acerca de estos archivos con gran detalle. Una vez que Ud. comprendi&oacute; la idea b&aacute;sica de la configuraci&oacute;n de smail, merece la pena leerla. ¡Es f&aacute;cil!</P>
<P>El primer archivo que se muestra es el routers, mediante el cual se establecen los encaminadores de smail. Cuando smail tiene que enviar un mensaje a una direcci&oacute;n dada, prueba con las direcciones de todos los encaminadores, uno por vez, hasta que concuerda con la de uno de ellos. La concordancia significa que el encaminador encuentra el nodo de destino en su base de datos, sea en el archivo paths, en el /etc/hosts, o en cual sea el mecanismo de encaminamiento que se utilice.</P>
<P>Las entradas en los archivos de configuraci&oacute;n de smail siempre comienzan con un nombre &uacute;nico que identifica el encaminador, transporte, o programa de entrega local. Luego le sigue una lista de atributos que definen su comportamiento. Esta lista consta de un conjunto de atributos globales, tales como el controlador utilizado, y atributos privados que solo tienen sentido para ese controlador particular. Los atributos est&aacute;n separados mediante comas. El conjunto de atributos globales se separa de los privados mediante un punto y coma.</P>
<P>Intentemos clasificar estas distinciones. Supongamos que Ud. quiere mantener dos archivos de alias de caminos distintos; uno que contiene la informaci&oacute;n de encaminamiento para su dominio, y otro que almacena la informaci&oacute;n de encaminamiento global, generada probablemente por los mapas de UUCP. Con smail, puede especificar dos encaminadores en el archivo routers, y ambos utilizar&aacute;n el controlador pathalias. Este controlador busca los nombres de nodo en la base de datos pathalias.</P><DIR>
<DIR>

<P>#<BR>
# base de datos de alias de caminos para el encaminamiento dentro del dominio<BR>
domain_paths:<BR>
driver=pathalias, # busca el nodo en el archivo de caminos<BR>
transport=uux; # si lo encuentra lo env&iacute;a a trav&eacute;s de UUCP<BR>
<BR>
file=paths/domain, # el archivo es /usr/lib/smail/paths/domain<BR>
proto=lsearch, # el archivo no esta ordenado (b&uacute;squeda lineal)<BR>
optional, # si el archivo no existe, no importa<BR>
required=vbrew.com, # buscar solo los nodos tipo *.vbrew.com<BR>
<BR>
#<BR>
# base de datos de pathalias para encaminamientos fuera de nuestro dominio<BR>
world_paths:<BR>
driver=pathalias, # busca el nodo en el archivo de caminos<BR>
transport=uux; # si lo encuentra, lo env&iacute;a a trav&eacute;s de UUCP<BR>
&nbsp;<BR>
file=paths/world, # el archivo es /usr/lib/smail/paths/world<BR>
proto=bsearch, # el archivo fue clasificado con sort(1)<BR>
optional, # si el archivo no existe, no importa<BR>
-required, # no es obligatorio tener dominio<BR>
domain=uucp, # quitar el ".uucp" final antes de la b&uacute;squeda</P>
<P>&nbsp;</P></DIR>
</DIR>

<P>El segundo atributo global que se ha mostrado en cada una de las dos entradas de routers define el transporte que se deber&aacute; utilizar cuando el encaminador haga concordar las direcciones. En nuestro caso, el mensaje se enviara utilizando el transporte uux. Los transportes se definen en el archivo transports, que se explica mas adelante.</P>
<P>Se puede hacer un ajuste m&aacute;s fino con respecto a que transporte se utilizar&aacute; para enviar un mensaje si especifica un archivo de m&eacute;todo en lugar del atributo transport. Los archivos de m&eacute;todo son una forma de traducir los nombres de nodo a los transportes necesarios. No los trataremos aqu&iacute;.</P>
<P>El siguiente archivo routers define los encaminadores para una red de &aacute;rea local que utiliza la biblioteca de resoluci&oacute;n. Sin embargo, en un nodo Internet Ud. querr&aacute; utilizar un encaminador que maneje registros MX. Por lo tanto, deber&aacute; quitar los caracteres de comentario del encaminador alternativo inet_bind que usa el controlador BIND incorporado en smail.</P>
<P>En un contexto en el cual se utilizan UUCP y TCP/IP a la vez, puede Ud. encontrarse con el problema de que haya ciertos nodos que figuran en su archivo /etc/hosts con los cuales se contacta solo ocasionalmente mediante SLIP o PPP. En general, el correo hacia estos sistemas se debe enviar mediante UUCP. Para evitar que el controlador inet_hosts concuerde con dichas m&aacute;quinas, deber&aacute; agregarlos al archivo paths/force. Este archivo es otra base de datos del estilo de alias de caminos, y se consulta antes de que smail consulte al sistema de resoluci&oacute;n.</P><DIR>
<DIR>

<P># Ejemplo de archivo /usr/lib/smail/routers<BR>
#<BR>
# force - obliga a enviar mediante UUCP a ciertos nodos, aun en el caso<BR>
# en que est&eacute;n en nuestro /etc/hosts<BR>
force:<BR>
driver=pathalias, # busca el nodo en el archivo de caminos<BR>
transport=uux; # si lo encuentra, env&iacute;o a trav&eacute;s de UUCP<BR>
<BR>
file=paths/force, # el archivo es /usr/lib/smail/paths/force<BR>
optional, # si el archivo no existe, no importa<BR>
proto=lsearch, # el archivo no esta ordenado<BR>
# (busqueda lineal)<BR>
-required, # no es obligatorio tener dominio<BR>
domain=uucp, # quitar el ".uucp" final antes de la b&uacute;squeda<BR>
<BR>
# inet_addrs - encuentra literales de dominio que contienen literales<BR>
# de direcciones de IP, como por ejemplo janet@[191.72.2.1]<BR>
inet_addrs:<BR>
driver=gethostbyaddr, # controlador para encontrar literales<BR>
# de dominios IP<BR>
transport=smtp; # enviar utilizando SMTP sobre TCP/IP<BR>
<BR>
fail_if_error, # fallar si la direcci&oacute;n esta mal formada<BR>
check_for_local, # enviar directamente si nosotros somos<BR>
# el nodo<BR>
<BR>
# inet_hosts - encuentra nombres de nodo con gethostbyname(3N)<BR>
# Qu&iacute;telo de los comentarios si desea usar en su lugar la versi&oacute;n BIND<BR>
inet_hosts:<BR>
driver=gethostbyname, # busca nodos con la funcion de biblioteca<BR>
transport=smtp; # usar SMTP de forma predeterminada<BR>
<BR>
-required, # no es obligatorio tener dominio<BR>
-domain, # no hay sufijos de dominio definidos<BR>
-only_local_domain, # no se restrinja a los dominios definidos<BR>
<BR>
# inet_hosts - versi&oacute;n alternativa usando BIND para acceder al DNS<BR>
#inet_hosts:<BR>
# driver=bind, # utilizar el controlador BIND incorporado<BR>
# transport=smtp; # usar TCP/IP SMTP para el env&iacute;o<BR>
#<BR>
# defnames, # usar b&uacute;squeda de dominio est&aacute;ndar<BR>
# defer_no_connect, # intentar de nuevo si el servidor de<BR>
# nombres no est&aacute; activo<BR>
# -local_mx_okay, #<BR>
<BR>
#<BR>
# base de datos tipo pathalias para el encaminamiento dentro del dominio<BR>
domain_paths:<BR>
driver=pathalias, # busca el nodo en el archivo de caminos<BR>
transport=uux; # si lo encuentra, env&iacute;o a trav&eacute;s de UUCP<BR>
file=paths/domain, # el archivo es /usr/lib/smail/paths/domain<BR>
proto=lsearch, # el archivo no esta ordenado<BR>
# (b&uacute;squeda lineal)<BR>
optional, # si el archivo no existe, no importa<BR>
required=vbrew.com, # buscar solo los nodos tipo *.vbrew.com<BR>
<BR>
#<BR>
# base de datos tipo pathalias p/encaminar hacia nodos fuera de nuestro dominio<BR>
world_paths:<BR>
driver=pathalias, # busca el nodo en el archivo de caminos<BR>
transport=uux; # si lo encuentra, env&iacute;o a trav&eacute;s de UUCP<BR>
<BR>
file=paths/world, # el archivo es /usr/lib/smail/paths/world<BR>
proto=bsearch, # el archivo fue clasificado con sort(1)<BR>
optional, # si el archivo no existe, no importa<BR>
-required, # no es obligatorio tener dominios<BR>
domain=uucp, # quitar el ".uucp" final antes de la b&uacute;squeda<BR>
# smart_host - redireccionador de nodo inteligente parcialmente especificado<BR>
# Si el atributo smart_path no se define en<BR>
# /usr/lib/smail/config, se ignorar&aacute; este encaminador.<BR>
# La variable global smart_transport tiene precedencia sobre<BR>
# el atributo transport<BR>
smart_host:<BR>
driver=smarthost, # controlador para el caso especial<BR>
transport=uux; # si no hay otra especificaci&oacute;n,<BR>
# env&iacute;o a trav&eacute;s de UUCP<BR>
<BR>
-path, # usar la variable del archivo<BR>
# de configuraci&oacute;n smart_path</P>
<P>&nbsp;</P></DIR>
</DIR>

<P>El manejo del correo para las direcciones locales se configura en el archivo directors. Este se construye de la misma manera que el archivo routers, y consta de una lista de entradas que definen los redirectores respectivos. Los redirectores no env&iacute;an los mensajes, sino que solamente realizan todas las redirecciones que sean posibles, por ejemplo a trav&eacute;s de alias, reenv&iacute;o de correo y cosas por el estilo.</P>
<P>Cuando se env&iacute;a correo a una direcci&oacute;n local, como janet, smail pasa el nombre del usuario a todos los redirectores del modulo de entrega local, uno por vez. Si un redirector concuerda, entonces o bien especifica el transporte a trav&eacute;s del cual el mensaje debe enviarse (por ejemplo, el nombre de archivo del buz&oacute;n del usuario) o, si no, genera una nueva direcci&oacute;n (por ejemplo al evaluar un alias).</P>
<P>Por las cuestiones de seguridad involucradas, los redirectores generalmente realizan varios controles para ver si los archivos que se usan son archivos sensibles del sistema. Las direcciones que se obtienen a partir de medios dudosos (por ejemplo desde un archivo aliases con permisos de escritura para todo el mundo) se indican como inseguras. Algunos controladores de transporte se negar&aacute;n a utilizar dichas direcciones, por ejemplo el transporte que env&iacute;a mensajes a un archivo.</P>
<P>Adem&aacute;s, smail tambi&eacute;n asocia un usuario con cada direcci&oacute;n. Cualquier operaci&oacute;n de lectura o escritura se realizan operando con los permisos y privilegios del usuario correspondiente. Para enviar un mensaje a, por ejemplo el buz&oacute;n de janet, la direcci&oacute;n esta asociada por supuesto a janet. Las otras direcciones, tales como las que se obtienen del archivo aliases, tienen otros usuarios asociados a ellas, por ejemplo, el usuario nobody.</P>
<P>Para mas detalles de estas caracter&iacute;sticas, refi&eacute;rase por favor a la p&aacute;gina de manual de smail(8).</P><DIR>
<DIR>

<P># Ejemplo de archivo /usr/lib/smail/directors<BR>
<BR>
# aliasinclude - expande las direcciones ":include:filename"<BR>
# producidas por los archivos de alias<BR>
aliasinclude:<BR>
driver=aliasinclude, # use este controlador para caso especial<BR>
nobody; # si es inseguro, acceder al archivo como<BR>
# usuario nobody<BR>
<BR>
copysecure, # obtener los permisos desde el<BR>
# redireccionador de alias<BR>
copyowners, # obtener los propietarios a partir del<BR>
# redireccionador de alias<BR>
<BR>
# forwardinclude - expande las direcciones ":include:filename"<BR>
# producidas por los archivos de reenv&iacute;o (forward)<BR>
forwardinclude:<BR>
driver=forwardinclude, # use este controlador de caso especial<BR>
nobody; # si es inseguro, acceder al archivo como<BR>
# usuario nobody<BR>
<BR>
checkpath, # controlar la accesibilidad del camino<BR>
copysecure, # obtener los permisos desde el<BR>
<BR>
# redireccionador de reenv&iacute;os<BR>
copyowners, # obtener los propietarios desde el<BR>
# redireccionador de reenv&iacute;os<BR>
<BR>
# aliases - buscar las expansiones de alias almacenadas en la base de datos<BR>
aliases:<BR>
driver=aliasfile, # redireccionador de alias de prop&oacute;sito general<BR>
-nobody, # de manera predeterminada, todas las direcciones<BR>
# est&aacute;n siempre asociadas a nobody<BR>
sender_okay, # no quitar el remitente de las expansiones<BR>
owner=owner-$user; # los problemas se mandan a la direcci&oacute;n<BR>
# del propietario<BR>
<BR>
file=/usr/lib/aliases, # predeterminado: compatible con sendmail<BR>
modemask=002, # no debe ser de escritura para todo el mundo<BR>
optional, # si el archivo no existe, no importa<BR>
proto=lsearch, # archivo ASCII sin ordenar<BR>
<BR>
# dotforward - expande los archivos .forward de los directorios 'home'<BR>
# de los usuarios<BR>
dotforward:<BR>
driver=forwardfile, # redireccionador de reenv&iacute;os de<BR>
# prop&oacute;sito general<BR>
owner=real-$user, # los problemas se env&iacute;an al buz&oacute;n del usuario<BR>
nobody, # usar usuario nobody, si es inseguro<BR>
sender_okay; # nunca se quita el remitente en la expansi&oacute;n<BR>
<BR>
file=~/.forward, # archivo .forward en los directorios 'home'<BR>
checkowner, # el usuario puede ser el propietario<BR>
# de este archivo<BR>
owners=root, # o el root puede serlo<BR>
modemask=002, # no debe ser de escritura para todo el mundo<BR>
caution=0-10:uucp:daemon, # no correr como root o daemon<BR>
# hay que ser extremadamente cuidadoso con los directorios 'home'<BR>
# que se acceden remotamente<BR>
unsecure="~ftp:~uucp:~nuucp:/tmp:/usr/tmp",<BR>
<BR>
# forwardto - expande la linea "Forward to " al frente<BR>
# del archivo buz&oacute;n del usuario<BR>
forwardto:<BR>
driver=forwardfile,<BR>
owner=Postmaster, # errores al Postmaster<BR>
nobody, # usar usuario nobody, si es inseguro<BR>
sender_okay; # no quitar remitente en la expansion<BR>
<BR>
file=/var/spool/mail/${lc:user}, # posicion del buz&oacute;n del usuario<BR>
forwardto, # habilitar el control "Forward to "<BR>
checkowner, # el usuario puede ser propietario<BR>
# de este archivo<BR>
owners=root, # o el root puede serlo<BR>
modemask=0002, # bajo System V, el grupo mail puede escribirlo<BR>
caution=0-10:uucp:daemon, # no corra como root o daemon<BR>
<BR>
# user - encuentra usuarios en el nodo local con envio a sus respectivos buzones<BR>
user: driver=user; # controlador para encontrar nombres de usuario<BR>
<BR>
transport=local, # el transporte local es hacia los buzones<BR>
# real_user - encuentra nombres de usuario cuando estan prefijados<BR>
# con la cadena "real-"<BR>
real_user:<BR>
driver=user; # controlador para encontrar nombres de usuario<BR>
<BR>
transport=local, # el transporte local es hacia los buzones<BR>
prefix="real-", # por ejemplo, encontrar real-root<BR>
<BR>
# lists - expande listas de correo almacenadas debajo de /usr/lib/smail/lists<BR>
lists: driver=forwardfile,<BR>
caution, # marcar todas las direcciones con prudencia<BR>
nobody, # y luego asociarlas al usuario nobody<BR>
sender_okay, # NO quitar el remitente<BR>
owner=owner-$user; # el propietario de la lista<BR>
<BR>
# pasar a min&uacute;sculas el nombre de la lista de correo<BR>
file=lists/${lc:user},</P>
<P>&nbsp;</P></DIR>
</DIR>

<P>Despu&eacute;s de encaminar o redireccionar un mensaje, smail lleva el mensaje al transporte especificado por el encaminador o redireccionador que concord&oacute; con la direcci&oacute;n. Estos transportes est&aacute;n definidos en el archivo transports. Nuevamente, se define un transporte mediante un conjunto de opciones globales y privadas.</P>
<P>La opci&oacute;n m&aacute;s importante que se define para cada entrada se refiere al controlador que realiza el transporte, por ejemplo el controlador pipe, que invoca el comando especificado en el atributo cmd. Adem&aacute;s de este, existen una cierta cantidad de atributos globales que puede utilizar un transporte, que realizan varias transformaciones en la cabecera del mensaje, y posiblemente en su cuerpo. El atributo return_path, por ejemplo, hace que el transporte inserte un campo return_path en la cabecera del mensaje. El atributo unix_from_hack hace que se preceda toda ocurrencia de la palabra From al principio de una l&iacute;nea con el signo &gt;.</P><DIR>
<DIR>

<P># Ejemplo de archivo /usr/lib/smail/transports<BR>
<BR>
# local - env&iacute;a correo a los usuarios locales<BR>
local: driver=appendfile, # agrega el mensaje al archivo<BR>
return_path, # incluir un campo Return-Path:<BR>
from, # proveer una l&iacute;nea de sobre con From_<BR>
unix_from_hack, # insertar &gt; antes de From en el cuerpo<BR>
local; # usar formatos locales para el env&iacute;o<BR>
<BR>
file=/var/spool/mail/${lc:user}, # posici&oacute;n del archivo buz&oacute;n<BR>
group=mail, # el grupo propietario del archivo<BR>
# para System V<BR>
mode=0660, # el grupo mail puede acceder<BR>
suffix="\n", # agregar un cambio de l&iacute;nea extra<BR>
<BR>
# pipe - enviar el correo a trav&eacute;s de comandos de shell<BR>
pipe: driver=pipe, # encauzar el mensaje hacia otro programa<BR>
return_path, # incluir un campo Return-Path:<BR>
from, # proveer una linea de sobre con From_<BR>
unix_from_hack, # insertar &gt; antes de From en el cuerpo<BR>
local; # usar formatos locales para el env&iacute;o<BR>
<BR>
cmd="/bin/sh -c $user", # enviar las direcciones al shell Bourne<BR>
parent_env, # info de entorno a partir de la direcci&oacute;n<BR>
# del padre<BR>
pipe_as_user, # usar user-id asociado con la direcci&oacute;n<BR>
ignore_status, # ignore un status de salida distinto de cero<BR>
ignore_write_errors, # ignore errores de escritura,<BR>
# por ejemplo: tuber&iacute;a cortada<BR>
umask=0022, # umask para el proceso hijo<BR>
-log_output, # no registrar stdout/stderr en el<BR>
# archivo de registro<BR>
<BR>
# file - enviar el correo a archivos<BR>
file: driver=appendfile,<BR>
return_path, # incluir un campo Return-Path:<BR>
from, # proveer una l&iacute;nea de cabecera con From_<BR>
unix_from_hack, # insertar &gt; antes de From en el cuerpo<BR>
local; # usar formatos locales para el env&iacute;o<BR>
<BR>
file=$user, # el nombre del archivo se toma de<BR>
# la direcci&oacute;n<BR>
append_as_user, # usar el user-id asociado con la direcci&oacute;n<BR>
expand_user, # expandir ~ y $ dentro de la direcci&oacute;n<BR>
suffix="\n", # agregar un cambio de l&iacute;nea extra<BR>
mode=0600, # poner los permisos en 600<BR>
<BR>
# uux - env&iacute;os al programa rmail de una instalaci&oacute;n UUCP remota<BR>
uux: driver=pipe,<BR>
uucp, # usar formatos de direcciones estilo UUCP<BR>
from, # proveer una l&iacute;nea de sobre con Form_<BR>
max_addrs=5, # m&aacute;ximo 5 direcciones por invocaci&oacute;n<BR>
max_chars=200; # m&aacute;ximo 200 caracteres en direcci&oacute;n<BR>
<BR>
cmd="/usr/bin/uux - -r -a$sender -g$grade $host!rmail $(($user)$)",<BR>
pipe_as_sender, # que los registros uucp registren al llamador<BR>
log_output, # guardar las salidas de error para<BR>
# los mensajes rebotados<BR>
# defer_child_errors, # reintentar si uux retorna un error<BR>
<BR>
# demand - env&iacute;os al programa rmail remoto, el sondeo es inmediato<BR>
demand: driver=pipe,<BR>
uucp, # usar formatos de direcciones estilo UUCP<BR>
from, # proveer una l&iacute;nea de sobre con Form_<BR>
max_addrs=5, # m&aacute;ximo 5 direcciones por invocaci&oacute;n<BR>
max_chars=200; # m&aacute;ximo 200 caracteres en direcci&oacute;n<BR>
<BR>
cmd="/usr/bin/uux - -a$sender -g$grade $host!rmail $(($user)$)",<BR>
pipe_as_sender, # que los registros uucp registren al llamador<BR>
log_output, # guardar las salidas de error para<BR>
# los mensajes rebotados<BR>
# defer_child_errors, # reintentar si uux retorna un error<BR>
<BR>
# hbsmtp - half-baked BSMTP. Los archivos de salida deben procesarse<BR>
# regularmente y enviarse via UUCP.<BR>
hbsmtp: driver=appendfile,<BR>
inet, # usar direccionamiento RFC 822<BR>
hbsmtp, # SMTP por lotes sin HELO ni QUIT<BR>
-max_addrs, -max_chars; # no hay limite en el n&uacute;mero de direcciones<BR>
<BR>
file="/var/spool/smail/hbsmtp/$host",<BR>
user=root, # el archivo es propiedad de root<BR>
mode=0600, # solo legible-escribible por root.<BR>
<BR>
# smtp - envios utilizando SMTP sobre TCP/IP<BR>
smtp: driver=tcpsmtp,<BR>
inet,<BR>
-max_addrs, -max_chars; # no hay l&iacute;mite en el n&uacute;mero de direcciones<BR>
<BR>
short_timeout=5m, # timeout para operaciones breves<BR>
long_timeout=2h, # timeout para operaciones SMTP<BR>
# de mayor duraci&oacute;n<BR>
service=smtp, # conectar a este puerto de servicio<BR>
# Para uso en internet: descomente las siguientes 4 l&iacute;neas<BR>
# use_bind, # resolver MX y registros A m&uacute;ltiples<BR>
# defnames, # usar b&uacute;squeda de dominio est&aacute;ndar<BR>
# defer_no_connect, # reintentar si el servidor de nombres<BR>
# # no est&aacute; activo<BR>
# -local_mx_okay, # no usar MX con el sistema local</P></DIR>
</DIR>
</FONT></BODY>
</HTML>
