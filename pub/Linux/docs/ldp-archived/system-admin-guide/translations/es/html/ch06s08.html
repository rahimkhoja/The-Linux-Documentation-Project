<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Sistemas de archivos</title><meta name="generator" content="DocBook XSL Stylesheets V1.68.1"><link rel="start" href="index.html" title="Guía Para Administradores de Sistemas GNU/Linux"><link rel="up" href="ch06.html" title="Capítulo 6. Utilizando Discos y Otros Medios de Almacenamiento"><link rel="prev" href="ch06s07.html" title="Particiones"><link rel="next" href="ch06s09.html" title=" Discos sin sistemas de archivo"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Sistemas de archivos</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch06s07.html">Anterior</a> </td><th width="60%" align="center">Capítulo 6. Utilizando Discos y Otros Medios de Almacenamiento</th><td width="20%" align="right"> <a accesskey="n" href="ch06s09.html">Siguiente</a></td></tr></table><hr></div><div class="sect1" lang="es"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2541606"></a>Sistemas de archivos</h2></div></div></div><div class="sect2" lang="es"><div class="titlepage"><div><div><h3 class="title"><a name="id2541612"></a>¿Qué son
los sistemas de archivos?</h3></div></div></div><p>Un <em class="glossterm">sistema de archivos</em> son los métodos y
estructuras de datos que un sistema operativo utiliza para seguir la pista de
los archivos de un disco o partición; es decir, es la manera en la que se
organizan los archivos en el disco. El término también es utilizado para
referirse a una partición o disco que se está utilizando para almacenamiento, o
el tipo del sistema de archivos que utiliza. Así uno puede decir &#8220;<span class="quote">tengo
dos sistemas de archivo</span>&#8221; refiriéndose a que tiene dos particiones en las
que almacenar archivos, o que uno utiliza el sistema de &#8220;<span class="quote">archivos
extendido</span>&#8221;, refiriéndose al tipo del sistema de archivos.</p><p>La diferencia entre un disco o partición y el sistema de archivos que
contiene es importante. Unos pocos programas (incluyendo, razonablemente,
aquellos que crean sistemas de archivos) trabajan directamente en los sectores
crudos del disco o partición; si hay un archivo de sistema existente allí será
destruido o corrompido severamente. La mayoría de programas trabajan sobre un
sistema de archivos, y por lo tanto no utilizarán una partición que no contenga
uno (o que contenga uno del tipo equivocado).</p><p>Antes de que una partición o disco sea utilizada como un sistema de
archivos, necesita ser iniciada, y las estructura de datos necesitan escribirse
al disco. Este proceso se denomina <em class="glossterm">construir un sistema de
archivos</em>.</p><p>La mayoría de los sistema de archivos UNIX tienen una estructura general
parecida, aunque los detalles exactos pueden variar un poco. Los conceptos
centrales son <em class="glossterm">superbloque</em>, <em class="glossterm">nodo-i</em>,
<em class="glossterm">bloque de datos</em>, <em class="glossterm">bloque de
directorio</em>, y <em class="glossterm">bloque de indirección</em>. El
superbloque tiene información del sistema de archivos en conjunto, como su
tamaño (la información precisa aquí depende del sistema de archivos). Un nodo-i
tiene toda la información de un archivo, salvo su nombre. El nombre se almacena
en el directorio, junto con el número de nodo-i. Una entrada de directorio
consiste en un nombre de archivo y el número de nodo-i que representa al
archivo. El nodo-i contiene los números de varios bloques de datos, que se
utilizan para almacenar los datos en el archivo. Sólo hay espacio para unos
pocos números de bloques de datos en el nodo-i; en cualquier caso, si se
necesitan más, más espacio para punteros a los bloques de datos son colocados de
forma dinámica. Estos bloques colocados dinámicamente son bloques indirectos; el
nombre indica que para encontrar el bloque de datos, primero hay que encontrar
su número en un bloque indirecto.</p><p>Los sistemas de archivos UNIX generalmente nos permiten crear un
<em class="glossterm">agujero</em> en un archivo (esto se realiza con la llamada al
sistema <code class="function">lseek()</code>; compruebe su página de manual), lo que
significa que el sistema de archivos simplemente intenta que en un lugar
determinado en el archivo haya justamente cero bytes, pero no existan sectores
del disco reservados para ese lugar en el archivo (esto significa que el archivo
utilizará un poco menos de espacio en disco). Esto ocurre frecuentemente en
especial para pequeños binarios, librerías compartidas de Linux, algunas bases
de datos, y algunos pocos casos especiales. (los agujeros se implementan
almacenando un valor especial en la dirección del bloque de datos en el bloque
indirecto o en el nodo-i. Esta dirección especial indica que ningún bloque de
datos está localizado para esa parte del archivo, y por lo tanto, existe un
agujero en el archivo).</p></div><div class="sect2" lang="es"><div class="titlepage"><div><div><h3 class="title"><a name="id2541778"></a>Sistemas de archivos soportados por Linux</h3></div></div></div><p>Linux soporta una gran cantidad de tipos diferentes de sistemas de
archivos.  Para nuestros propósitos los más importantes son:

</p><div class="glosslist"><dl><dt>minix</dt><dd><p>El más antiguo y supuestamente el más fiable, pero muy limitado
en características (algunas marcas de tiempo se pierden, 30 caracteres de
longitud máxima para los nombres de los archivos) y restringido en capacidad
(como mucho 64 MB de tamaño por sistema de
archivos).</p></dd><dt>xia</dt><dd><p>Una versión modificada del sistema de archivos minix que eleva
los límites de nombres de archivos y tamaño del sistema de archivos, pero por
otro lado no introduce características nuevas. No es muy popular, pero se ha
verificado que funciona muy bien.</p></dd><dt>ext3</dt><dd><p>El sistema de
	archivos ext3 posee todas las propiedades del sistema de archivos ext2.
	La diferencia es que se ha añadido una bitácora (journaling). Esto
	mejora el rendimiento y el tiempo de recuperación en el caso de una
	caída del sistema. Se ha vuelto más popular que el
	ext2.</p></dd><dt>ext2</dt><dd><p>El más sistema
	de archivos nativo Linux que posee la mayor cantidad de características.
	Está diseñado para ser compatible con diseños futuros, así que las
	nuevas versiones del código del sistema de archivos no necesitará
	rehacer los sistemas de archivos
	existentes.</p></dd><dt>ext</dt><dd><p>Una versión
	antigua de ext2 que no es compatible en el futuro. Casi nunca se utiliza
	en instalaciones nuevas, y la mayoría de la gente que lo utilizaba han
	migrado sus sistemas de archivos al tipo
	ext2.</p></dd><dt>reiserfs</dt><dd><p>Un sistema
	de archivos más robusto. Se utiliza una bitácora que provoca que la
	pérdida de datos sea menos frecuente. La bitácora es un mecanismo que
	lleva un registro por cada transacción que se va a realizar, o que ha
	sido realizada. Esto permite al sistema de archivos reconstruirse por sí
	sólo fácilmente tras un daño ocasionado, por ejemplo, por cierres del
	sistema inadecuados.</p></dd></dl></div><p> </p><p>Adicionalmente, existe soporte para sistemas de archivos adicionales
ajenos, para facilitar el intercambio de archivos con otros sistemas operativos.
Estos sistemas de archivos ajenos funcionan exactamente como los propios,
excepto que pueden carecer de características usuales UNIX , o tienen curiosas
limitaciones, u otros inconvenientes.

	</p><div class="glosslist"><dl><dt>msdos</dt><dd><p>Compatibilidad
	con el sistema de archivos FAT de MS-DOS (y OS/2 y Windows
	NT).</p></dd><dt>umsdos</dt><dd><p>Extiende el
dispositivo de sistema de archivos msdos en Linux para obtener nombres de
archivo largos, propietarios, permisos, enlaces, y archivos de dispositivo. Esto
permite que un sistema de archivos msdos normal pueda utilizarse como si fuera
de Linux, eliminando por tanto la necesidad de una partición independiente para
Linux.</p></dd><dt>vfat</dt><dd><p>Esta es una extensión
del sistema de archivos FAT conocida como FAT32. Soporta tamaños de discos
mayores que FAT. La mayoría de discos con MS Windows son
vfat.</p></dd><dt>iso9660</dt><dd><p>El sistema de
archivos estándar del CD-ROM; la extensión popular Rock Ridge del estándar del
CD-ROM que permite nombres de archivo más largos se soporta de forma
automática.</p></dd><dt>nfs</dt><dd><p>Un sistema de archivos
de red que permite compartir un sistema de archivos entre varios ordenadores
para permitir fácil acceso a los archivos de todos
ellos.</p></dd><dt>smbfs</dt><dd><p>Un sistema de archivos
que permite compartir un sistema de archivos con un ordenador MS Windows. Es
compatible con los protocolos para compartir archivos de
Windows.</p></dd><dt>hpfs</dt><dd><p>El sistema de archivos
de OS/2.</p></dd><dt>sysv</dt><dd><p>EL sistema de archivos
de Xenix, Coherent y SystemV/386..</p></dd></dl></div><p> </p><p>La elección del sistema de archivos a utilizar depende de la situación. Si
la compatibilidad o alguna otra razón hace necesario uno de los sistemas de
archivos no nativos, entonces hay que utilizar ése. Si se puede elegir
libremente, entonces lo más inteligente sería utilizar ext3, puesto que tiene
todas las características de ext2, y es un sistema de archivos con
bitácora.</p><p>Existe también el sistema de archivos proc, generalmente accesible desde
el directorio <code class="filename">/proc</code>, que en realidad no es un sistema de
archivos, aún cuando lo parece. El sistema de archivos proc facilita acceder a
ciertas estructura de datos del núcleo, como la lista de procesos (de ahí el
nombre). Hace que estas estructuras de datos parezcan un sistema de archivos, y
que el sistema de archivos pueda ser manipulado con las herramientas de archivos
habituales. Por ejemplo, para obtener una lista de todos los procesos se puede
utilizar el comando

</p><pre class="screen">
<code class="prompt">$</code> <strong class="userinput"><code>ls -l /proc</code></strong>
<code class="computeroutput">total 0
dr-xr-xr-x   4 root     root            0 Jan 31 20:37 1
dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 63
dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 94
dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 95
dr-xr-xr-x   4 root     users           0 Jan 31 20:37 98
dr-xr-xr-x   4 liw      users           0 Jan 31 20:37 99
-r--r--r--   1 root     root            0 Jan 31 20:37 devices
-r--r--r--   1 root     root            0 Jan 31 20:37 dma
-r--r--r--   1 root     root            0 Jan 31 20:37 filesystems
-r--r--r--   1 root     root            0 Jan 31 20:37 interrupts
-r--------   1 root     root      8654848 Jan 31 20:37 kcore
-r--r--r--   1 root     root            0 Jan 31 11:50 kmsg
-r--r--r--   1 root     root            0 Jan 31 20:37 ksyms
-r--r--r--   1 root     root            0 Jan 31 11:51 loadavg
-r--r--r--   1 root     root            0 Jan 31 20:37 meminfo
-r--r--r--   1 root     root            0 Jan 31 20:37 modules
dr-xr-xr-x   2 root     root            0 Jan 31 20:37 net
dr-xr-xr-x   4 root     root            0 Jan 31 20:37 self
-r--r--r--   1 root     root            0 Jan 31 20:37 stat
-r--r--r--   1 root     root            0 Jan 31 20:37 uptime
-r--r--r--   1 root     root            0 Jan 31 20:37 
version</code>
<code class="prompt">$</code>
</pre><p>

(Puede haber no obstante algunos archivos adicionales que no correspondan con
ningún proceso. El ejemplo anterior se ha recortado.)</p><p>Tenga en cuenta que aunque se llame sistema de archivos, ninguna parte del
sistema de archivos proc toca el disco. Existe tan sólo en la imaginación del
núcleo. Cuando alguien intenta echar un vistazo a alguna parte del sistema de
archivos proc, el núcleo hace que parezca como si esa parte existiera en alguna
parte, aunque no lo haga. Así, aunque exista un archivo
<code class="filename">/proc/kcore</code> de muchos megabytes, no quita espacio del
disco.</p></div><div class="sect2" lang="es"><div class="titlepage"><div><div><h3 class="title"><a name="id2542155"></a>¿Qué sistemas de archivos deben utilizarse?</h3></div></div></div><p>Existe generalmente poca ventaja en utilizar muchos sistemas de archivos
distintos. Actualmente, el más popular sistema de archivos es ext3, debido a que
es un sistema de archivos con bitácora. Hoy en día es la opción más inteligente.
Reiserfs es otra elección popular porque también posee bitácora. Dependiendo de
la sobrecarga del listado de estructuras, velocidad, fiabilidad (percibible),
compatibilidad, y otras varias razones, puede ser aconsejable utilizar otro
sistema de archivos. Estas necesidades deben decidirse en base a cada
caso.</p><p>Un sistema de archivos que utiliza bitácora se denomina sistema de
archivos con bitácora. Un sistema de archivos con bitácora mantiene un diario,
la bitácora, de lo que ha ocurrido en el sistema de archivos. Cuando sobreviene
una caída del sistema, o su hijo de dos años pulsa el botón de apagado como el
mío adora hacer, un sistema de archivos con bitácora se diseña para utilizar los
diarios del sistema de archivos para recuperar datos perdidos o no guardados.
Esto reduce la pérdida de datos y se convertirá en una característica estándar
en los sistemas de archivos de Linux. De cualquier modo, no extraiga una falsa
sensación de seguridad de esto. Como todo en esta vida, puede haber errores.
Procure siempre guardar sus datos para prevenir emergencias.</p></div><div class="sect2" lang="es"><div class="titlepage"><div><div><h3 class="title"><a name="id2542210"></a>Crear un sistema de archivos</h3></div></div></div><p>Un sistema de archivos se crea, esto es, se inicia, con el comando
<span><strong class="command">mkfs</strong></span>. Existen en realidad programas separados para cada tipo
de sistemas de archivos. <span><strong class="command">mkfs</strong></span> es únicamente una careta que
ejecuta el programa apropiado dependiendo del tipo de sistemas de archivos
deseado. El tipo se selecciona con la opción <code class="option">-t fstype</code>.</p><p>Los programas a los que <code class="option">-t fstype</code> llama tienen líneas de
comando ligeramente diferentes. Las opciones más comunes e importantes se
resumen más abajo; vea las páginas de manual para más información.

</p><div class="glosslist"><dl><dt><code class="option">-t fstype</code></dt><dd><p>
	
Selecciona el tipo de sistema de archivos.  </p></dd><dt><code class="option">-c</code></dt><dd><p> Busca
bloques defectuosos e inicia la lista de bloques defectuosos en
consonancia.</p></dd><dt>-l filename</dt><dd><p>
	
Lee la lista inicial de bloques defectuosos del archivo
dado.</p></dd></dl></div><p> </p><p>Para crear un sistema de archivos ext2 en un disquete, se pueden
introducir los siguiente comandos:

</p><pre class="screen">
<code class="prompt">$</code> <strong class="userinput"><code>fdformat -n /dev/fd0H1440</code></strong>
<code class="computeroutput">Double-sided, 80 tracks, 18 sec/track. Total capacity 
1440 kB.
Formatting ... done</code>
<code class="prompt">$</code> <strong class="userinput"><code>badblocks /dev/fd0H1440 1440 $&gt;$ 
bad-blocks</code></strong>
<code class="prompt">$</code> <strong class="userinput"><code>mkfs -t ext2 -l bad-blocks 
/dev/fd0H1440</code></strong>
<code class="computeroutput">mke2fs 0.5a, 5-Apr-94 for EXT2 FS 0.5, 94/03/10
360 inodes, 1440 blocks
72 blocks (5.00%) reserved for the super user
First data block=1
Block size=1024 (log=0)
Fragment size=1024 (log=0)
1 block group
8192 blocks per group, 8192 fragments per group
360 inodes per group

Writing inode tables: done
Writing superblocks and filesystem accounting information: 
done</code>
<code class="prompt">$</code>
</pre><p>


Primero el disquete es formateado (la opción -n impide la validación, esto es,
la comprobación de bloques defectuosos).  A continuación se buscan los bloques
defectuosos mediante <span><strong class="command">badblocks</strong></span>, con la salida redirigida a un
archivo, <code class="filename">bad-blocks</code>. Finalmente, se crea el sistema de
archivos con la lista de bloques defectuosos iniciada con lo que hubiera
encontrado <span><strong class="command">badblocks</strong></span>.</p><p>La opción <code class="option">-c</code> podría haberse utilizado con
<span><strong class="command">mkfs</strong></span> en lugar de <span><strong class="command">badblocks</strong></span> y un archivo a
parte. El ejemplo siguiente hace esto.

</p><pre class="screen">
<code class="prompt">$</code> <strong class="userinput"><code>mkfs -t ext2 -c 
/dev/fd0H1440</code></strong>
<code class="computeroutput">mke2fs 0.5a, 5-Apr-94 for EXT2 FS 0.5, 94/03/10
360 inodes, 1440 blocks
72 blocks (5.00%) reserved for the super user
First data block=1
Block size=1024 (log=0)
Fragment size=1024 (log=0)
1 block group
8192 blocks per group, 8192 fragments per group
360 inodes per group

Checking for bad blocks (read-only test): done
Writing inode tables: done
Writing superblocks and filesystem accounting information: 
done</code>
<code class="prompt">$</code>
</pre><p>


La opción <code class="option">-c</code> es más conveniente que la utilización a parte de
<span><strong class="command">badblocks</strong></span>, pero <span><strong class="command">badblocks</strong></span> se necesita para
comprobar el sistema de archivos una vez creado.</p><p>El proceso para preparar sistemas de archivos en discos duros o
particiones es le mismo que para los disquetes, excepto que no es necesario el
formateo.</p></div><div class="sect2" lang="es"><div class="titlepage"><div><div><h3 class="title"><a name="mount-and-umount"></a>Montar y desmontar</h3></div></div></div><p>Antes de que se pueda utilizar un sistema de archivos, debe ser
<em class="glossterm">montado</em>. El sistema operativo realiza entonces
operaciones de mantenimiento para asegurarse que todo funciona. Como todos los
archivos en UNIX están en un mismo árbol de directorios, la operación de montaje
provocará que el contenido del nuevo sistema de archivos aparezca como el
contenido de un subdirectorio existente en algún sistema de archivos ya
montado.</p><p>Por ejemplo, la <a href="ch06s08.html#hd-mount-root" title="Figura 6.4. Tres sistemas de
archivos independientes.">Figura 6.4, &#8220;Tres sistemas de
archivos independientes.&#8221;</a>  muestra tres
sistemas de archivos independientes, cada uno de ellos con su propio directorio
raíz. Cuando se montan los dos últimos sistemas de archivos bajo
<code class="filename">/home</code> y <code class="filename">/usr</code> respectivamente, en el
primer sistema de archivos, obtenemos un único árbol de directorios, como se
observa en la <a href="ch06s08.html#hd-mount-all" title="Figura 6.5. /home y /usr montados.">Figura 6.5, &#8220;<code class="filename">/home</code> y <code class="filename">/usr</code> montados.&#8221;</a>.</p><div class="figure-float"><div class="figure"><a name="hd-mount-root"></a><p class="title"><b>Figura 6.4. Tres sistemas de
archivos independientes.</b></p><div><img src="figuras/hd-mount-separate.png" alt="Tres sistemas de archivos independientes."></div></div></div><div class="figure-float"><div class="figure"><a name="hd-mount-all"></a><p class="title"><b>Figura 6.5. <code class="filename">/home</code> y <code class="filename">/usr</code> montados.</b></p><div><img src="figuras/hd-mount-mounted.png" alt="/home y /usr montados."></div></div></div><p>El montaje puede realizarse como en el siguiente ejemplo:


</p><pre class="screen">
<code class="prompt">$</code> <strong class="userinput"><code>mount /dev/hda2 /home</code></strong>
<code class="prompt">$</code> <strong class="userinput"><code>mount /dev/hda3 /usr</code></strong>
<code class="prompt">$</code>
</pre><p>

El comando <span><strong class="command">mount</strong></span> tiene dos argumentos. El primero es el
archivo de dispositivo correspondiente al disco o partición que contiene el
sistema de archivos. El segundo es el directorio bajo el cual va a ser montado.
Tras estos dos comandos el contenido de los dos sistemas de archivos aparecen
como los contenidos de los directorios <code class="filename">/home</code> y
<code class="filename">/usr</code>, respectivamente. Se dice que
&#8220;<span class="quote"><code class="filename">/dev/hda2</code> <em class="glossterm"> está montado en</em>
<code class="filename">/home</code></span>&#8221;, e igualmente para <code class="filename">/usr</code>.
Para ver cualquiera de los sistemas de archivos, se puede mirar el contenido del
directorio en el que fue montado, como si fuera cualquier otro directorio.
Observe la diferencia entre el archivos de dispositivo,
<code class="filename">/dev/hda2</code>, y el directorio de montaje,
<code class="filename">/home</code>. El archivo de dispositivo proporciona acceso al
contenido crudo del disco, el directorio de montaje proporciona acceso a los
archivos del disco. El directorio de montaje se denomina <em class="glossterm">punto de
montaje</em>.</p>

Linux soporta multitud de sistemas de archivos. <span><strong class="command">mount</strong></span> intenta
adivinar el tipo de sistema de archivos. Se puede utilizar la <code class="option">-t
fstype</code> para especificar el tipo directamente; esto es necesario en
determinados casos, puesto que la heurística que utiliza
<span><strong class="command">mount</strong></span> no siempre funciona. Por ejemplo, para montar un
disquete MS-DOS, se puede utilizar el comando siguiente:

<pre class="screen">
<code class="prompt">$</code> <strong class="userinput"><code>mount -t msdos /dev/fd0 /floppy</code></strong>
<code class="prompt">$</code>
</pre><p>El directorio de montaje necesita estar vacío, aunque debe existir.
Cualquier archivo en él, en cualquier caso, será inaccesible por su nombre
mientras el sistema de archivos esté montado. (Cualquier archivo que estuviera
abierto seguirá estando accesible. Archivos que tengan enlaces duros desde otros
directorios podrán accederse utilizando esos nombres.) No hay daño alguno
haciendo esto, y puede incluso ser útil. Por ejemplo, a alguna gente le gusta
tener a <code class="filename">/tmp</code> y <code class="filename">/var/tmp</code> como
sinónimos, y poner <code class="filename">/tmp</code> como enlace simbólico a
<code class="filename">/var/tmp</code>. Cuando el sistema arranca, antes de montar el
sistema de archivos <code class="filename">/var</code>, se utiliza un directorio
<code class="filename">/var/tmp</code> residente en el sistema de archivos raíz en su
lugar. Cuando <code class="filename">/var</code> se monta, convertirá al directorio
<code class="filename">/var/tmp</code> del sistema de archivos raíz inaccesible. Si
<code class="filename">/var/tmp</code> no existe en el el sistema de archivos raíz, será
imposible utilizar los archivos temporales antes de montar
<code class="filename">/var</code>.</p><p>Si no tiene intención de escribir nada en el sistema de archivos, utilice
el modificador <code class="option">-r</code> de <span><strong class="command">mount</strong></span> para realizar un
montaje de <em class="glossterm">sólo-lectura</em>. Esto provocará que el núcleo
detenga cualquier intento de escribir en el sistema de archivos, y también
impedirá que el núcleo actualice el tiempo de acceso a los nodos-i. Montaje de
sólo-lectura son necesarios para medios no grabables, como los CD-ROM.</p><p>El lector atento habrá notado un ligero problema lógico.  ¿Cómo se monta
el primer sistema de archivos (denominado <em class="glossterm">sistema de archivos
raíz</em>, ya que contiene al directorio raíz), si obviamente no puede
montarse sobre otro sistema de archivos? Bueno, la respuesta es que se realiza
un truco de magia. <sup>[<a name="id2542875" href="#ftn.id2542875">14</a>]</sup> El sistema de archivos
raíz se monta mágicamente a la hora del arranque, y se puede confiar en que
siempre será montado.  Si el sistema de archivos no puede montarse, el sistema
no arrancará. El nombre del sistema de archivos que mágicamente se monta como
root está compilado dentro del núcleo, o se especifica utilizando LILO o
<span><strong class="command">rdev</strong></span>.</p><p>El sistema de archivos raíz se monta generalmente para sólo-lectura. Los
guiones (scripts) de inicio ejecutarán entonces <span><strong class="command">fsck</strong></span> para
comprobar su validez, y si no hay problemas, <em class="glossterm">volverá a
montarlo</em> para permitir la escritura. <span><strong class="command">fsck</strong></span>  no
debe ejecutarse en sistemas de archivos montados, puesto que cualquier cambio en
el sistema de archivos mientras se ejecuta <span><strong class="command">fsck</strong></span>
<span class="emphasis"><em>puede causar problemas</em></span>. Como el sistema de archivos raíz se
monta como sólo-lectura mientras se comprueba, <span><strong class="command">fsck</strong></span> puede
corregir cualquier problema sin preocuparse, porque la operación de remontaje
vaciará cualquier metadato que el sistema de archivos mantuviera en
memoria.</p><p>En muchos sistemas existen otros sistemas de archivos que también deben
montarse de forma automática durante en el arranque. Estos se especifican en el
archivo <code class="filename">/etc/fstab</code> ; vea la página de manual de fstab para
los detalles en el formato. Los detalles sobre cuándo se montan exactamente los
sistemas de archivos adicionales dependen de muchos factores, y pueden ser
configurados por cada administrador si lo necesita; vea el <a href="ch08.html" title="Capítulo 8. Encendido y apagado">Capítulo 8, <i>Encendido y apagado</i></a>.</p><p>Cuando un sistema de archivos no se necesita seguir montado, puede
desmontarse con <span><strong class="command">umount</strong></span>. <sup>[<a name="id2542989" href="#ftn.id2542989">15</a>]</sup>
		
<span><strong class="command">umount</strong></span>  toma un argumento: o bien el archivo de dispositivo o
el punto de montaje. Por ejemplo, para desmontar los directorios del ejemplo
anterior, se pueden utilizar los comandos


</p><pre class="screen">
<code class="prompt">$</code> <strong class="userinput"><code>umount /dev/hda2</code></strong>
<code class="prompt">$</code> <strong class="userinput"><code>umount /usr</code></strong>
<code class="prompt">$</code>
</pre><p>

</p><p>Lea la página de manual para más información sobre cómo utilizar el
comando. Es obligatorio que siempre se desmonte un disquete montado.
<span class="emphasis"><em>¡No saque únicamente el disquete de la disquetera!</em></span> Debido
al cacheado de disco, los datos no se escriben necesariamente hasta que se
desmonta el disquete, así que sacar el disquete de la disquetera demasiado
pronto puede provocar que el contenido se vuelva erróneo. Si únicamente lee del
disquete, esto no es muy usual, pero si escribe, incluso accidentalmente, el
resultado puede ser catastrófico.</p><p>Montar y desmontar requieren privilegios de superusuario, esto es, sólo
root puede hacerlo. La razón para esto es que si un usuario puede montar un
disquete en cualquier directorio, entonces es relativamente fácil crear un
disquete con, digamos, un caballo de Troya disfrazado de
<code class="filename">/bin/sh</code>, o cualquier otro programa frecuentemente
utilizado. De cualquier modo, se necesita generalmente permitir a los usuarios
utilizar los disquetes, y hay varias maneras de hacerlo:

</p><div class="itemizedlist"><ul type="disc"><li><p>Dar al usuario la contraseña de root. Esto es obviamente
inseguro, pero es la solución más sencilla. Funciona muy bien si no hay otras
necesidades de seguridad, que es el caso de muchos sistemas personales sin
red.</p></li><li><p>Utilizar un programa como sudo para permitir a los
	usuarios que monten. Esto también es inseguro, pero no proporciona
	privilegios de superusuario directamente a todo el mundo. 
	<sup>[<a name="id2543118" href="#ftn.id2543118">16</a>]</sup>
	
	</p></li><li><p>Hacer que el usuario utilice <span><strong class="command">mtools</strong></span>, un
paquete para manipular sistemas de archivos MS-DOS, sin tener que montarlos.
Esto funciona bien si todo lo que se necesitan son disquetes MS-DOS, pero es
bastante lioso en otros casos.</p></li><li><p>Listar los dispositivos flexibles y su punto de montaje
	permitido junto a las opciones oportunas en
	<code class="filename">/etc/fstab</code>.</p></li></ul></div><p>

La última alternativa puede implementarse añadiendo una línea como la siguiente
en el archivo <code class="filename">/etc/fstab</code>:

</p><pre class="screen">
/dev/fd0            /floppy      msdos   user,noauto      0     0
</pre><p>




Las columnas corresponden a: archivo de dispositivo a montar, directorio de
montaje, tipo de sistema de archivos, opciones, frecuencia de copia de seguridad
(utilizado por <span><strong class="command">dump</strong></span>), y el número de paso para
<span><strong class="command">fsck</strong></span> (especifica el orden en el que los sistemas de archivos
son comprobados en el arranque; 0 significa que no se comprueba).</p><p>La opción <code class="option">noauto</code> impide que se monte automáticamente al
iniciar el sistema (es decir, previene que <span><strong class="command">mount -a</strong></span> la
monte). La opción <code class="option">user</code> permite a cualquier usuario montar el
sistema de archivos, y, debido a cuestiones de seguridad, deniega la ejecución
de programas (normales o con setuid) y la interpretación de sistemas de archivos
desde el sistema de archivos montado. Después de eso, cualquier usuario puede
montar un disquete con un sistemas de archivos msdos con el comando siguiente:


</p><pre class="screen">
<code class="prompt">$</code> <strong class="userinput"><code>mount /floppy</code></strong>
<code class="prompt">$</code>
</pre><p>


El disquete puede (y necesita de ello, por supuesto) desmontarse con la orden
<span><strong class="command">umount</strong></span> correspondiente.</p><p>Si desea otorgar acceso para varios tipos de disquetes, necesita
proporcionar distintos puntos de montaje. Las opciones pueden ser diferentes
para cada punto de montaje. Por ejemplo, para permitir accesos a disquetes
MS-DOS o ext2, se pueden tener las siguientes líneas en
<code class="filename">/etc/fstab</code>:


</p><pre class="screen">
/dev/fd0    /dosfloppy    msdos   user,noauto  0  0
/dev/fd0    /ext2floppy   ext2    user,noauto  0  0
</pre><p>

Para sistemas de archivos MS-DOS (no sólo disquetes), probablemente quiera
restringir el acceso utilizando las opciones del sistema de archivos
<code class="option">uid</code>, <code class="option">gid</code>y <code class="option">umask</code>, descritas en
detalle en la página de manual de <span><strong class="command">mount</strong></span>. Si no es cuidadoso,
montar un sistema de archivos MS-DOS proporciona al menos acceso de lectura a
los archivos que hay en él, lo que no es una buena idea.</p></div><div class="sect2" lang="es"><div class="titlepage"><div><div><h3 class="title"><a name="id2543317"></a>Comprobar la integridad de un sistema de archivos con
<span><strong class="command">fsck</strong></span></h3></div></div></div><p>Los sistemas de archivos son criaturas complejas, y como tales, tienden a
ser propensos a los errores. La corrección y validación de un sistema de
archivos puede ser comprobada utilizando el comando <span><strong class="command">fsck</strong></span>.
Puede ser instruido para reparar cualquier problema menor que encuentre, y
alertar al usuario si hay errores irreparables. Afortunadamente, el código
implementado en los sistemas de archivos puede estudiarse de forma muy efectiva,
así que escasamente hay problemas, y normalmente son causados por fallos de
alimentación, hardware defectuoso, o errores de operación; por ejemplo, no
apagar el sistema adecuadamente.</p><p>La mayoría de los sistemas se configuran para ejecutar
<span><strong class="command">fsck</strong></span> automáticamente durante el arranque, así que cualquier
error se detecta (y esperemos que corregido) antes que el sistema se utilice.
Utilizar un sistema de archivos corrupto tiende a empeorar las cosas: si las
estructuras de datos se mezclan, utilizar el sistema de archivos probablemente
las mezclará aún más, resultando en una mayor pérdida de datos. En cualquier
caso, <span><strong class="command">fsck</strong></span> puede tardar un tiempo en ejecutarse en sistemas
de archivos grandes, y puesto que los errores casi nunca suceden si el sistema
se ha apagado adecuadamente, pueden utilizarse un par de trucos para evitar
realizar comprobaciones en esos casos.  El primero es que si existe el archivo
<code class="filename">/etc/fastboot</code>, no se realizan comprobaciones. El segundo es
que el sistema de archivos ext2 tiene una marca especial en su superbloque que
indica si el sistema de archivos se desmontó adecuadamente después del montaje
previo. Esto permite a <span><strong class="command">e2fsck</strong></span> (la versión de
<span><strong class="command">fsck</strong></span> para el sistema de archivos ext2) evitar la comprobación
del sistema de archivos si la bandera indica que se realizó el desmontaje (la
suposición es que un desmontaje adecuado indica que no hay problemas). Que el
truco de <code class="filename">/etc/fastboot</code> funcione en su sistema depende de
sus guiones (scripts) de inicio, pero el truco de ext2 funciona cada vez que
utilice <span><strong class="command">e2fsck</strong></span>. Debe ser sobrepasado explícitamente con una
opción de <span><strong class="command">e2fsck</strong></span> para ser evitado. (Vea la página de manual
de e2fsck para los detalles sobre cómo.).</p><p>La comprobación automática sólo funciona para los sistemas de archivos que
se montan automáticamente en el arranque. Utilice <span><strong class="command">fsck</strong></span> de
forma manual para comprobar otros sistemas de archivos, por ejemplo,
disquetes.</p><p>Si <span><strong class="command">fsck</strong></span> encuentra problemas irreparables, necesita
conocimientos profundos de cómo funciona en general un sistema de archivos, y en
particular el tipo del sistema de archivos corrupto, o buenas copias de
seguridad. Lo último es fácil (aunque algunas veces tedioso) de arreglar, el
precedente puede solucionarse a través de un amigo, los grupos de noticias y
listas de correo de Linux, o alguna otra fuente de soporte, si no sabe cómo
hacerlo usted mismo. Me gustaría contarle más sobre el tema, pero mi falta de
formación y experiencia en este asunto me lo impiden. El programa de Theodore
Ts'o <span><strong class="command">debugfs</strong></span> puede ser de ayuda.</p><p><span><strong class="command">fsck</strong></span>  debe ser utilizado únicamente en sistemas de
archivos desmontados, nunca en sistemas de archivos montados (a excepción del
raíz en sólo-lectura en el arranque). Esto es así porque accede al disco
directamente, y puede por lo tanto modificar el sistema de archivos sin que el
sistema operativo se percate de ello. <span class="emphasis"><em>Habrá problemas</em></span>, si
el sistema operativo se confunde.</p></div><div class="sect2" lang="es"><div class="titlepage"><div><div><h3 class="title"><a name="id2543514"></a>Comprobar errores en el disco mediante
<span><strong class="command">badblocks</strong></span></h3></div></div></div><p>Puede ser buena idea comprobar los bloques defectuosos periódicamente.
Esto se realiza con el comando <span><strong class="command">badblocks</strong></span>. Saca una lista de
los números de todos los bloques malos que puede encontrar. Esta lista puede
introducirse en <span><strong class="command">fsck</strong></span> para grabar en el sistema de archivos
las estructuras de datos para que el sistema operativo no intente utilizar los
bloques malos para almacenar datos. El ejemplo siguiente muestra cómo puede
hacerse esto.


</p><pre class="screen">
<code class="prompt">$</code> <strong class="userinput"><code>badblocks /dev/fd0H1440 1440 &gt; 
bad-blocks</code></strong>
<code class="prompt">$</code> <strong class="userinput"><code>fsck -t ext2 -l bad-blocks 
/dev/fd0H1440</code></strong>
<code class="computeroutput">Parallelizing fsck version 0.5a (5-Apr-94)
e2fsck 0.5a, 5-Apr-94 for EXT2 FS 0.5, 94/03/10
Pass 1: Checking inodes, blocks, and sizes
Pass 2: Checking directory structure
Pass 3: Checking directory connectivity
Pass 4: Check reference counts.
Pass 5: Checking group summary information.

/dev/fd0H1440: ***** FILE SYSTEM WAS MODIFIED *****
/dev/fd0H1440: 11/360 files, 63/1440 blocks</code>
<code class="prompt">$</code>
</pre><p>


Si badblocks informa de que un bloque se está utilizando,
<span><strong class="command">e2fsck</strong></span> intentará mover el bloque a otro lugar.  Si el bloque
estaba realmente defectuoso, no tan sólo marginado, el contenido del archivo
puede estar corrupto.</p></div><div class="sect2" lang="es"><div class="titlepage"><div><div><h3 class="title"><a name="id2543615"></a>Luchar contra la fragmentación</h3></div></div></div><p>Cuando un archivo se escribe en el disco, no puede escribirse siempre en
bloques consecutivos. Un archivos que no está almacenado en bloques consecutivos
está <em class="glossterm">fragmentado</em>. Leer un archivo fragmentado requiere
mayor tiempo, puesto que la cabeza de lectura-escritura del disco debe moverse
más. Es deseable evitar la fragmentación, aunque es un problema menor en un
sistema con un buen caché buffer con lectura progresiva.</p><p>El sistema de archivos ext2 intenta mantener la fragmentación al mínimo,
manteniendo todos los bloques de un archivo juntos, incluso cuando no pueden
almacenarse en sectores consecutivos.  Ext2 efectivamente localiza el bloque
libre más cercano a los otros bloques del archivo. Por lo tanto para ext2 hay
poca necesidad de preocuparse por la fragmentación.  Existe un programa para
desfragmentar un sistema de archivos ext2, llamado extrañamente defrag
[24].<span><strong class="command">defrag</strong></span>
		
		<sup>[<a name="id2543662" href="#ftn.id2543662">17</a>]</sup> .</p><p>Existen muchos programas de desfragmentación MS-DOS que mueven los bloques
por todo el sistema de archivos para eliminar la fragmentación. Para otros
sistemas de archivos, la desfragmentación debe hacerse guardando el sistema de
archivos, volverlo a crear, y restaurando los archivos de la copia guardada.
Guardar un sistema de archivos antes de desfragmentarlo es una buena idea para
cualquier sistema de archivos, puesto que muchas cosas pueden ir mal durante la
desfragmentación.</p></div><div class="sect2" lang="es"><div class="titlepage"><div><div><h3 class="title"><a name="id2543690"></a>Otras herramientas para todos los sistemas de
archivos</h3></div></div></div><p>Algunas herramientas adicionales pueden resultar útiles para manejar
sistemas de archivos. <span><strong class="command">df</strong></span> muestra el espacio libre en disco de
uno o más sistemas de archivos. <span><strong class="command">du</strong></span> muestra cuánto espacio en
disco ocupa un directorio y los archivos que contiene. Estos pueden utilizarse
para encontrar desperdiciadores de espacio en disco. Ambos tienen páginas de
manual que detallan las (muchas) opciones que pueden utilizarse.</p><p><span><strong class="command">sync</strong></span> fuerza que todos los bloques en el buffer caché 
no escritos
(vea la Sección 7.6<a href="ch07s06.html" title="

El Buffer Cache">&#8220;

El Buffer Cache&#8221;</a>) se escriban al
disco. Es raro hacer esto esto a mano; el demonio update hace esto
automáticamente. Puede ser útil en caso de catástrofe, por ejemplo si
<span><strong class="command">update</strong></span> o su proceso ayudante <span><strong class="command">bdflush</strong></span>
muere, o si debe apagar el ordenador <span class="emphasis"><em>ahora</em></span> y no puede
esperar que se ejecute <span><strong class="command">update</strong></span>. De nuevo, están las páginas de
manual.  El comando <span><strong class="command">man</strong></span> es su mejor amigo en linux.  Su
sobrino <span><strong class="command">apropos</strong></span> es también muy útil cuando no sabe cuál es el
nombre del comando que quiere.</p></div><div class="sect2" lang="es"><div class="titlepage"><div><div><h3 class="title"><a name="id2543789"></a>Otras herramientas para el sistema de archivos
ext2/ext3</h3></div></div></div><p>Además del creador (<span><strong class="command">mke2fs</strong></span>) y del comprobador
(<span><strong class="command">e2fsck</strong></span>) de sistemas de archivos accesibles directamente o a
través de las caretas independientes del tipo del sistema de archivos, ext2
posee herramientas adicionales que pueden resultar útiles.</p><p><span><strong class="command">tune2fs</strong></span> ajusta parámetros del sistema de archivos.
Algunos de los parámetros más interesantes son:


	</p><div class="itemizedlist"><ul type="disc"><li><p> Un contador máximo de montados.
	<span><strong class="command">e2fsck</strong></span> fuerza una comprobación cuando el sistema de
	archivos se ha montado demasiadas veces, incluso si la bandera de
	limpiado está activa.  Para un sistema que se utiliza para desarrollo o
	pruebas de sistema, puede ser una buena idea reducir este límite.
	</p></li><li><p>Un tiempo máximo entre comprobaciones.
	<span><strong class="command">e2fsck</strong></span> puede también forzar un tiempo máximo entre
	dos comprobaciones, incluso si la bandera de limpiado está activa, y el
	sistema de archivos no se monta frecuentemente. De cualquier forma, esto
	puede desactivarse.

	</p></li><li><p> Número de bloques reservados para root. Ext2 reserva
	algunos bloques para root de manera que si el sistema de archivos se
	llena, todavía será posible realizar tareas de administración sin tener
	que borrar nada. La cantidad reservada es por defecto el 5%, lo que en
	la mayoría de discos no supone un desperdicio. De cualquier manera, para
	los disquetes no existe justificación en reservar ningún bloque.
	</p></li></ul></div><p>
	

Vea la página de manual de <span><strong class="command">tune2fs</strong></span> para más
información.</p><p><span><strong class="command">dumpe2fs</strong></span> muestra información acerca de un sistema de
archivos ext2, la mayoría referente al superbloque. La <a href="ch06s08.html#dumpe2fs-output" title="Figura 6.6.  Salida de ejemplo de
dumpe2fs ">Figura 6.6, &#8220; Salida de ejemplo de
<span>dumpe2fs</span> &#8221;</a> muestra una salida de ejemplo. Alguna información en
la salida es técnica y requiere comprensión acerca de cómo trabaja el sistema de
archivos (vea el apéndice XXX ext2fspaper), pero la mayoría es comprensible
incluso para aprendices.</p>


Figura 6-5.<div class="figure-float"><div class="figure"><a name="dumpe2fs-output"></a><p class="title"><b>Figura 6.6.  Salida de ejemplo de
<span>dumpe2fs</span> </b></p><div class="literallayout"><p><br>
dumpe2fs 0.5b, 11-Mar-95 for EXT2 FS 0.5a, 94/10/23<br>
Filesystem magic number:  0xEF53<br>
Filesystem state:         clean<br>
Errors behavior:          Continue<br>
Inode count:              360<br>
Block count:              1440<br>
Reserved block count:     72<br>
Free blocks:              1133<br>
Free inodes:              326<br>
First block:              1<br>
Block size:               1024<br>
Fragment size:            1024<br>
Blocks per group:         8192<br>
Fragments per group:      8192<br>
Inodes per group:         360<br>
Last mount time:          Tue Aug  8 01:52:52 1995<br>
Last write time:          Tue Aug  8 01:53:28 1995<br>
Mount count:              3<br>
Maximum mount count:      20<br>
Last checked:             Tue Aug  8 01:06:31 1995<br>
Check interval:           0<br>
Reserved blocks uid:      0 (user root)<br>
Reserved blocks gid:      0 (group root)<br>
<br>
Group 0:<br>
  Block bitmap at 3, Inode bitmap at 4, Inode table at 5<br>
  1133 free blocks, 326 free inodes, 2 directories<br>
  Free blocks: 307-1439<br>
  Free inodes: 35-360<br>
</p></div></div></div><p><span><strong class="command">debugfs</strong></span> es un debugger para un sistema de archivos.
Permite acceso directo al sistema de archivos y a las estructuras de datos
almacenadas en el disco y puede utilizarse por tanto para reparar un disco tan
estropeado que <span><strong class="command">fsck</strong></span> no puede repararlo automáticamente.
También es conocido por recuperar archivos eliminados. De cualquier modo,
<span><strong class="command">debugfs</strong></span> requiere mucho que comprenda lo que está haciendo: un
fallo puede destruir todos sus datos.</p><p><span><strong class="command">dump</strong></span> y <span><strong class="command">restore</strong></span> pueden utilizarse
para guardar un sistema de archivos ext2. Hay versiones específicas para ext2 de
las herramientas tradicionales de copias de seguridad UNIX. Vea el Capítulo 12
<a href="ch12.html" title="Capítulo 12. Copias de seguridad (Backups)">Capítulo 12, <i>Copias de seguridad (Backups)</i></a> para más información sobre copias de seguridad.</p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id2542875" href="#id2542875">14</a>] </sup>Para conocer mas detalles lea los archivos fuentes
del kernel, o el libro Kernel Hackers' Guide.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2542989" href="#id2542989">15</a>] </sup>Este nombre debería ser por supuesto
<span><strong class="command">unmount</strong></span>, pero la n misteriosamente desapareció en los años 70s,
y no se ha visto desde entonces. Por favor, devuelva esta letra a los laboratorios Bell, NJ, si llegase a 
encontrarla.</p></div><div class="footnote"><p><sup>[<a name="ftn.id2543118" href="#id2543118">16</a>] </sup>Se requieren varios segundos de duro pensamiento..
	It requires several seconds of hard thinking on the
	users' behalf.  Furthermore <span><strong class="command">sudo</strong></span> can be configured to
	only allow users to execute certain commands.  See the sudo(8),
	sudoers(5), and visudo(8) manual pages.  </p></div><div class="footnote"><p><sup>[<a name="ftn.id2543662" href="#id2543662">17</a>] </sup> <a href="http://www.go.dlr.de/linux/src/defrag-0.73.tar.gz" target="_top">
		http://www.go.dlr.de/linux/src/defrag-0.73.tar.gz</a>
		</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch06s07.html">Anterior</a> </td><td width="20%" align="center"><a accesskey="u" href="ch06.html">Subir</a></td><td width="40%" align="right"> <a accesskey="n" href="ch06s09.html">Siguiente</a></td></tr><tr><td width="40%" align="left" valign="top">Particiones </td><td width="20%" align="center"><a accesskey="h" href="index.html">Inicio</a></td><td width="40%" align="right" valign="top">  Discos sin sistemas de archivo</td></tr></table></div></body></html>
