<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>

El Buffer Cache</title><meta name="generator" content="DocBook XSL Stylesheets V1.68.1"><link rel="start" href="index.html" title="Guía Para Administradores de Sistemas GNU/Linux"><link rel="up" href="ch07.html" title="Capítulo 7. Administración de
Memoria"><link rel="prev" href="ch07s05.html" title="

Alocando espacio de swap."><link rel="next" href="ch08.html" title="Capítulo 8. Encendido y apagado"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">

El Buffer Cache</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch07s05.html">Anterior</a> </td><th width="60%" align="center">Capítulo 7. Administración de
Memoria</th><td width="20%" align="right"> <a accesskey="n" href="ch08.html">Siguiente</a></td></tr></table><hr></div><div class="sect1" lang="es"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="buffer-cache"></a>

El Buffer Cache</h2></div></div></div><p>

La lectura desde el disco <sup>[<a name="id2549839" href="#ftn.id2549839">22</a>]</sup> es mas lenta en comparación con el acceso a memoria
(real). Además, es común leer la misma parte del disco varias veces durante
periodos relativamente cortos de tiempo. Por ejemplo, uno podría leer primero un
mensaje del correo electrónico, después leer la misma carta con un editor de
texto cuando uno la esta respondiendo, y finalmente hacer que el programa la lea
de nuevo cuando le indicamos copiarla a una carpeta. O, considere cuan seguido
el comando <span><strong class="command">ls</strong></span> es ejecutado en un sistema con muchos usuarios.
Leyendo la información del disco una sola vez y luego manteniéndola en la
memoria hasta que no sea necesaria, puede acelerar todas las lecturas
posteriores con respecto a la primera. Esto es llamado <em class="glossterm">"buffering" de
disco (disk buffering)</em>, y la memoria usada para ese propósito es
llamada <em class="glossterm">buffer cache</em>.</p><p>Debido a que la memoria es, desafortunadamente finita, y por lo tanto, un
recurso escaso, el "buffer cache" usualmente no puede ser demasiado grande (no
puede mantener todos los datos que uno siempre quiere usar).  Cuando la "cache"
se completa, los datos que no han sido usados por un periodo de tiempo
prolongado son descartados y así la memoria es liberada para ser utilizada con
nuevos datos.</p><p>

El buffering de disco trabaja cuando existen escrituras también. Por un lado,
los datos que son escritos son leídos nuevamente con mucha frecuencia (por ej.
el código fuente de un programa es guardado a un archivo, y después es leído por
el compilador), entonces, colocar los datos que son escritos en la caché es una
buena idea. Por otro lado, colocar los datos en la caché, sin escribirlos a
disco inmediatamente, acelera al programa que los guarda. Las escrituras pueden
ser realizadas en segundo plano, sin disminuir la velocidad de ejecución de los
otros programas.</p><p>

La mayoría de los sistemas operativos tienen "buffer caché" (aunque algunas
veces son llamados de manera diferente), pero no todos funcionan de acuerdo a
los mismos principios. Algunos son de <em class="glossterm">escritura directa
(write-through)</em>: los datos son escritos a disco inmediatamente (y
obviamente, son mantenidos en la caché).  Otros son de <em class="glossterm">escritura
posterior (write-back)</em>, ya que las escrituras son realizadas
momentos después. Escritura posterior es más eficiente que escritura directa,
pero es más susceptible a errores: si la máquina cae, el suministro eléctrico es
interrumpido en un mal momento, o un medio extraíble es removido sin ser
desmontado, entonces usualmente los cambios realizados en la caché se pierden.
Esta situación puede significar que el sistema de archivos (si existiese uno) no
trabaje completamente bien, tal vez debido a que los datos que no pudieron ser
escritos sean cambios importantes para el mantenimiento del sistema.</p><p>

Debido a esto, nunca debería apagar el equipo sin emplear los procedimientos
adecuados (ver <a href="ch08.html" title="Capítulo 8. Encendido y apagado">Capítulo 8, <i>Encendido y apagado</i></a> Capitulo 8), como tampoco
quitar un disco flexible de la unidad hasta que haya sido desmontado (si fue
montado), o antes de que cualquier programa que esta haciendo uso del
dispositivo no indique que ha terminado y, el "led" de la unidad de disquete ya
no esta encendida. El comando <span><strong class="command">sync</strong></span> <em class="glossterm">descarga el
buffer (flushes)</em>, por ejemplo, fuerza que los datos aun no grabados
sean escritos al disco, y puede ser usado cuando uno quiere asegurarse que todas
las escrituras se hayan realizado.En los sistemas UNIX tradicionales, hay un
programa llamado <span><strong class="command">update</strong></span> que esta ejecutándose en segundo
plano, el cual se encarga de ejecutar el comando <span><strong class="command">sync</strong></span> cada 30
segundos, por esto usualmente no es necesario usar <span><strong class="command">sync</strong></span>.
Linux tiene un demonio adicional, <span><strong class="command">bdflush</strong></span>, el cual efectúa un
<span><strong class="command">sync</strong></span> mas imperfecto, pero con mas frecuentemente para evitar
el repentino congelamiento debido a la sobrecarga de I/O que algunas veces
"sync" produce.</p><p>

Bajo Linux, <span><strong class="command">bdflush</strong></span> is iniciado por
<span><strong class="command">update</strong></span>. No existen usualmente razones para preocuparse por
<span><strong class="command">bdflush</strong></span>, pero si <span><strong class="command">bdflush</strong></span> termina su
ejecución por alguna causa, el kernel alertará sobre esto, por lo que debe
iniciarlo a mano (<span><strong class="command">/sbin/update</strong></span>).</p><p>La caché no realiza realmente buffer de archivos, pero sí ** de
	bloques, los cuales son las unidades mas pequeñas de E/S a disco (en
	Linux usualmente son de 1 kB). De esta manera, también los directorios,
	super bloques, otros datos relacionados con ** en el sistema de
	archivos, y discos sin sistema de archivos son mantenidos en
	caché.</p><p>

La eficacia de una caché es decidida principalmente por su tamaño. Una caché
pequeña es casi inservible: tiene muy pocos datos, por lo que todos los datos en
la caché serán descartados antes de que sean reutilizados. El tamaño crítico
depende de la cantidad de datos escritos y leídos, y de cuan frecuente los
mismos datos son accedidos. La única manera de saber el tamaño útil de una caché
es experimentando.</p><p>

Si la "cache" es de tamaño fijo no es muy bueno que sea demasiado grande porque
eso podría hacer que la memoria libre sea demasiado pequeña y ocasionar
"swapping" (lo cual es también muy lento). Para hacer que el uso de la memoria
real sea mas eficiente, Linux usa automáticamente toda la memoria RAM como
"buffer cache", pero también, automáticamente, disminuye el tamaño de la "cache"
a medida que los programas van necesitando mas memoria.</p><p>
 
Bajo Linux, usted no necesita configurar nada para hacer utilizar "cache", esto
sucede de forma completamente automática. A excepción de los adecuados
procedimientos a seguir para "cerrar?apagar?desconectar?bajar?deshabilitar" o
quitar ¿diskettes? usted no tiene necesidad de preocuparse por nada.  </p><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id2549839" href="#id2549839">22</a>] </sup>Excepto un disco RAM, por obvias
razones.</p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch07s05.html">Anterior</a> </td><td width="20%" align="center"><a accesskey="u" href="ch07.html">Subir</a></td><td width="40%" align="right"> <a accesskey="n" href="ch08.html">Siguiente</a></td></tr><tr><td width="40%" align="left" valign="top">

Alocando espacio de swap. </td><td width="20%" align="center"><a accesskey="h" href="index.html">Inicio</a></td><td width="40%" align="right" valign="top"> Capítulo 8. Encendido y apagado</td></tr></table></div></body></html>
