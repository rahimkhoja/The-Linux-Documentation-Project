<HTML
><HEAD
>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-2">
<TITLE
>Linux-rendszermag HOGYAN</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"/></HEAD
><BODY
CLASS="article"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="title"
><A
NAME="AEN2"/>Linux-rendszermag HOGYAN</H1
><H3
CLASS="author"
><A
NAME="AEN4"
>&#13;        Al Dev (Alavoor Vasudevan) 
      </A
></H3
><DIV
CLASS="affiliation"
><DIV
CLASS="address"
><P
CLASS="address"
><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            alavoor[AT]yahoo.com 
          <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
></DIV
><P
CLASS="pubdate"
>&#13;      v7.3, 2003. október 27 
    <BR/></P
><DIV
><DIV
CLASS="abstract"
><A
NAME="AEN13"/><P
></P
><P
>&#13;        Jelen útmutató a rendszermag beállításának, fordításának, frissítésének és 
	hibaelhárításnak részletes leírása ix86-alapú rendszereken. Emellett 
	hasznos lehet más architektúrákhoz is. A dokumentum rövid és egyszerû maradt, 
	így még a nem technikai beállítottságú "otthoni felhasználók" is képesek 
	lehetnek Linux-rendszermag készítésére és futtatására. (Idõközben a 
	<A
HREF="http://tldp.org/"
TARGET="_top"
>The Linux Documentation Project</A
>
	átnézésre bevonta ezt a dokumentumot. Hamarosan átszerkesztett és frissített 
	formában jelenik meg - a lektor)
      </P
><P
></P
></DIV
></DIV
><HR/></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Tartalomjegyzék</B
></DT
><DT
>1. <A
HREF="#introduction"
>Bevezetés</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#warnings"
>FIGYELMEZTETÉS</A
></DT
><DT
>1.2. <A
HREF="#hun_trans"
>Magyar fordítás</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#quick_steps"
>Gyors lépések - a rendszermag fordítása</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#precautions"
>Elõkészületek</A
></DT
><DT
>2.2. <A
HREF="#upgrading"
>A rendszermag kisebb fejlesztése</A
></DT
><DT
>2.3. <A
HREF="#Documentation"
>Az új kiadás változásai: dokumentáció</A
></DT
><DT
>2.4. <A
HREF="#impatient"
>A türelmetleneknek</A
></DT
><DT
>2.5. <A
HREF="#steps"
>Új rendszermag készítése - a lépések értelmezése</A
></DT
><DT
>2.6. <A
HREF="#AEN242"
>Hibaelhárítás</A
></DT
><DT
>2.7. <A
HREF="#postkernel"
>A rendszermaghoz kapcsolódó utólagos fordítások</A
></DT
><DT
>2.8. <A
HREF="#reportbugs"
>Hová küldjem a hibajelentést?</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#loadable_modules"
>Betölthetõ modulok</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#AEN266"
>A modulok segédprogramjainak telepítése</A
></DT
><DT
>3.2. <A
HREF="#AEN281"
>A rendszermaggal szállított modulok</A
></DT
><DT
>3.3. <A
HREF="#AEN297"
>Hogyan telepítsek csak egyetlen modult?</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#cloning"
>A rendszermag "klónozása"</A
></DT
><DT
>5. <A
HREF="#important_questions"
>Fontos kérdések és válaszok</A
></DT
><DD
><DL
><DT
>5.1. <A
HREF="#AEN338"
>Egyébként mit is csinál a rendszermag?</A
></DT
><DT
>5.2. <A
HREF="#AEN342"
>Miért kéne frissítenem a rendszermagomat?</A
></DT
><DT
>5.3. <A
HREF="#AEN345"
>Milyen hardvert támogatnak az új verziójú rendszermagok?</A
></DT
><DT
>5.4. <A
HREF="#AEN351"
>Milyen verziójú gcc és libc kell?</A
></DT
><DT
>5.5. <A
HREF="#AEN355"
>Mi az a betölthetõ modul?</A
></DT
><DT
>5.6. <A
HREF="#AEN359"
>Mennyi lemezterületre van szükségem?</A
></DT
><DT
>5.7. <A
HREF="#AEN362"
>Mennyi idõt vesz igénybe?</A
></DT
></DL
></DD
><DT
>6. <A
HREF="#patching_the_kernel"
>A rendszermag foltozása (patching)</A
></DT
><DD
><DL
><DT
>6.1. <A
HREF="#AEN368"
>Egy folt alkalmazása</A
></DT
><DT
>6.2. <A
HREF="#AEN400"
>Ha valami nem sikerül</A
></DT
><DT
>6.3. <A
HREF="#AEN423"
>A .orig fájloktól történõ megszabadulás</A
></DT
><DT
>6.4. <A
HREF="#AEN433"
>Egyéb foltok</A
></DT
></DL
></DD
><DT
>7. <A
HREF="#tips_and_tricks"
>Tippek és trükkök</A
></DT
><DD
><DL
><DT
>7.1. <A
HREF="#AEN439"
>A make vagy a patch parancs kimenetének átirányítása</A
></DT
><DT
>7.2. <A
HREF="#AEN451"
>Feltételes rendszermag-telepítés</A
></DT
><DT
>7.3. <A
HREF="#AEN464"
>Rendszermag frissítések</A
></DT
></DL
></DD
><DT
>8. <A
HREF="#ftpfs"
>RPM csomagok felcsatolása (mount) az FTPFS segítségével</A
></DT
><DD
><DL
><DT
>8.1. <A
HREF="#AEN479"
>Az ftpfs használata</A
></DT
><DT
>8.2. <A
HREF="#AEN484"
>Az ftpfs parancsai</A
></DT
></DL
></DD
><DT
>9. <A
HREF="#kernel_textbooks"
>A rendszermagról szóló könyvek és dokumentumok</A
></DT
><DT
>10. <A
HREF="#kernel_files_info"
>Információk a rendszermag fájljairól</A
></DT
><DD
><DL
><DT
>10.1. <A
HREF="#vmlinuz"
>vmlinuz és vmlinux</A
></DT
><DT
>10.2. <A
HREF="#bootload"
>Rendszerbetöltõ (bootloader) fájlok</A
></DT
><DT
>10.3. <A
HREF="#AEN607"
>Üzenetfájl (message file)</A
></DT
><DT
>10.4. <A
HREF="#initrdimg"
>initrd.img</A
></DT
><DT
>10.5. <A
HREF="#bzimagelbl"
>bzImage</A
></DT
><DT
>10.6. <A
HREF="#moduleinfo"
>module-info</A
></DT
><DT
>10.7. <A
HREF="#configfiles"
>config</A
></DT
><DT
>10.8. <A
HREF="#grubdir"
>grub</A
></DT
><DT
>10.9. <A
HREF="#systemmap"
>System.map</A
></DT
></DL
></DD
><DT
>11. <A
HREF="#linux_admin_tools"
>Linux rendszer-adminisztrációs eszközök</A
></DT
><DT
>12. <A
HREF="#apt-get"
>Telepítés, frissítés fénysebességgel, az apt-get segítségével 
      (Redhat, Debian, Suse, Mandrake, egyéb)</A
></DT
><DD
><DL
><DT
>12.1. <A
HREF="#sourcecode_apt-get"
>Az "apt-get" forráskódja</A
></DT
><DT
>12.2. <A
HREF="#rpmfind_tool"
>Az "rpmfind" segédprogram</A
></DT
></DL
></DD
><DT
>13. <A
HREF="#linux_boot_process"
>Haladóknak szóló témák - A Linux rendszerindítási folyamata</A
></DT
><DD
><DL
><DT
>13.1. <A
HREF="#bootprocess_urls"
>Hivatkozások a betöltési folyamat témájában</A
></DT
></DL
></DD
><DT
>14. <A
HREF="#other_formats"
>Eme dokumentum más formátumai</A
></DT
><DD
><DL
><DT
>14.1. <A
HREF="#acrobatpdf"
>Acrobat PDF formátum</A
></DT
><DT
>14.2. <A
HREF="#linuxdoc2docbook"
>Konvertálás Linuxdoc-ról Docbook formátumra</A
></DT
><DT
>14.3. <A
HREF="#mswinhelp"
>Konvertálás MS WinHelp formátumra</A
></DT
><DT
>14.4. <A
HREF="#readformats"
>A különbözõ formátumok olvasása</A
></DT
></DL
></DD
><DT
>15. <A
HREF="#create_initrd"
>"A" függelék - initrd.img fájl készítése</A
></DT
><DD
><DL
><DT
>15.1. <A
HREF="#AEN1083"
>Az mkinitrd használata</A
></DT
><DT
>15.2. <A
HREF="#AEN1090"
>Rendszermag-dokumentációk</A
></DT
><DT
>15.3. <A
HREF="#AEN1094"
>Linuxman Book</A
></DT
></DL
></DD
><DT
>16. <A
HREF="#liloconf"
>"B" függelék - lilo.conf mintafájl</A
></DT
><DD
><DL
><DT
>16.1. <A
HREF="#AEN1128"
>LILO forrásanyagok</A
></DT
><DT
>16.2. <A
HREF="#AEN1144"
>LILO hibaelhárítás</A
></DT
><DT
>16.3. <A
HREF="#AEN1199"
>Egy LILO beállítófájl minta</A
></DT
></DL
></DD
><DT
>17. <A
HREF="#grubconf"
>"C" függelék - GRUB részletesen, grub.conf mintafájl</A
></DT
><DD
><DL
><DT
>17.1. <A
HREF="#AEN1207"
>GRUB forrásanyagok</A
></DT
><DT
>17.2. <A
HREF="#AEN1228"
>GRUB tippek</A
></DT
><DT
>17.3. <A
HREF="#AEN1235"
>Egy GRUB beállítófájl minta</A
></DT
></DL
></DD
><DT
>18. <A
HREF="#post_kernel_building"
>"D" függelék - utólagos rendszermag fordítás</A
></DT
><DT
>19. <A
HREF="#troubleshoot"
>"E" függelék - a gyakori hibák elhárítása</A
></DT
><DD
><DL
><DT
>19.1. <A
HREF="#AEN1296"
>A rendszermag rendben elkészül, de a "make modules" nem sikerül</A
></DT
><DT
>19.2. <A
HREF="#AEN1310"
>A programfordítás rendben megtörténik, de a rendszermag nem indul</A
></DT
><DT
>19.3. <A
HREF="#AEN1316"
>A rendszer mûködése felfüggesztõdik a LILO-nál</A
></DT
><DT
>19.4. <A
HREF="#AEN1324"
>No init found (nem található init)</A
></DT
><DT
>19.5. <A
HREF="#AEN1335"
>Csomó fordítási hiba (compile error)</A
></DT
><DT
>19.6. <A
HREF="#AEN1340"
>A "depmod" parancs "Unresolved symbol error messages" hibaüzenetet ír ki</A
></DT
><DT
>19.7. <A
HREF="#AEN1351"
>A rendszermag nem tölti be a modult, "Unresolved symbols" hibaüzenetet ír ki</A
></DT
><DT
>19.8. <A
HREF="#AEN1356"
>A rendszermag nem tud betölteni egy modult</A
></DT
><DT
>19.9. <A
HREF="#AEN1361"
>Betölthetõ modulok</A
></DT
><DT
>19.10. <A
HREF="#AEN1370"
>Olvasd el a dokumentációt</A
></DT
><DT
>19.11. <A
HREF="#AEN1374"
>make clean</A
></DT
><DT
>19.12. <A
HREF="#AEN1379"
>Óriási vagy lassú rendszermag</A
></DT
><DT
>19.13. <A
HREF="#AEN1385"
>A párhuzamos port/nyomtató nem mûködik</A
></DT
><DT
>19.14. <A
HREF="#AEN1393"
>A rendszermag nem fordul le</A
></DT
><DT
>19.15. <A
HREF="#AEN1400"
>A rendszermag új verziója nem töltõdik be</A
></DT
><DT
>19.16. <A
HREF="#AEN1405"
>Elfelejtetted futtatni a LILO-t, vagy a rendszered egyáltalán nem indul el</A
></DT
><DT
>19.17. <A
HREF="#AEN1446"
>Azt írja ki: "warning: bdflush not running"</A
></DT
><DT
>19.18. <A
HREF="#AEN1452"
>Nem tudom mûködésre bírni az IDE/ATAPI CD-ROM-ot</A
></DT
><DT
>19.19. <A
HREF="#AEN1460"
>Furcsa dolgokat jelez elavult útválasztási kérésekrõl (routing requests)</A
></DT
><DT
>19.20. <A
HREF="#AEN1466"
>"Not a compressed kernel Image file" (nem tömörített rendszermag)</A
></DT
><DT
>19.21. <A
HREF="#AEN1472"
>Problémák a konzolos terminállal, miután 1.3.x-re frissítettünk</A
></DT
><DT
>19.22. <A
HREF="#AEN1478"
>Úgy néz ki, hogy nem fordíthatók le dolgok a rendszermag frissítése után</A
></DT
><DT
>19.23. <A
HREF="#AEN1495"
>Korlátok kitolása</A
></DT
><DT
>19.24. <A
HREF="#AEN1500"
>Hová küldjem a hibajelentést?</A
></DT
></DL
></DD
></DL
></DIV
><DIV
CLASS="sect1"
><H2
CLASS="sect1"
><A
NAME="introduction"/>1. Bevezetés</H2
><P
>&#13;      A következõ okokból fordíthatsz rendszermagot:
      <P
></P
><UL
><LI
><P
>&#13;            Rendszermag-fejlesztést végzel 
          </P
></LI
><LI
><P
>&#13;            Új hardvert raksz a számítógépbe 
          </P
></LI
><LI
><P
>&#13;            Testre akarod szabni a rendszermagot, és nem akarod a disztribúcióval 
	    szállított, alapértelmezett verziót használni.
          </P
></LI
><LI
><P
>&#13;            
            <EM
>&#13;              Védelmi szervezetek 
            </EM
>
            vagy
            <EM
>&#13;              katonai alkalmazások 
            </EM
> 
	    esetében el kell olvasni a rendszermag forrását és saját kezûleg fordítani. 
	    Nincs kivétel! (Az Egyesült Államok Védelmi Hivatala lefordítja a rendszermagot, 
	    mielõtt szétosztja a számítógépeket).
          </P
></LI
><LI
><P
>&#13;            A világon minden ország és minden kormány helyben fordítja a rendszermagot a 
	    biztonság és sértetlenség biztosítása érdekében. Minden kormányzat illetve szervezet 
	    auditálja és ellenõrzi a rendszermag-forrás minden egyes sorát, mielõtt használná 
	    a számítógépet.
          </P
></LI
><LI
><P
>&#13;            A katonai elhárító ügynökségek világszerte tanulmányozzák és 
	    lefordítják a Linux-rendszermag forráskódját. Õk minden egyes soráról 
	    tudják, mit csinál!
          </P
></LI
><LI
><P
>&#13;            Ha saját kezûleg fordítod a rendszermagot, akkor az
            <EM
>&#13;              felér a kód elolvasásával és ellenõrzésével! 
            </EM
>
          </P
></LI
><LI
><P
>&#13;            Minden egyes egyetemnek, iskolának és kollégiumnak a gépek használata elõtt 
	    le kellene fordítania az operációs rendszermagot!
          </P
></LI
><LI
><P
>&#13;            A fejlõdésed és tudásod növelése céljából, és persze 
	    csak szórakozásképpen!
          </P
></LI
><LI
><P
>&#13;            A nagyon speciális tudományos alkalmazásokhoz - valószínûleg - 
	    rendszermagot kell fordítanod
          </P
></LI
><LI
><P
>&#13;            Ez egy nemzetközi törvény: "Nem használhatod a számítógépet a rendszermag 
	    saját kezû lefordítása NÉLKÜL". Ha nem engedelmeskedsz ennek a törvénynek, 
	    sokféle géphiba lehet a "büntetésed"! Önmagadnak kell lefordítani, így 
	    nem függsz másoktól, akik megcsinálnák neked.
          </P
></LI
><LI
><P
>&#13;            Illegális, törvénytelen, bûncselekmény és csalás a számítógép 
	    használata a rendszermag SAJÁT KEZÛ fordítása nélkül! 
	    1-3 havi börtön és 100-2000 USD büntetés róható ki 
	    mindazokra, akik a számítógépet a rendszermag forráskódból 
	    történõ újrafordítása nélkül használják. Néhány állam/ország/kormány 
	    szigorú törvénnyel akadályozza meg a rendszermag újrafordítása 
	    nélküli számítógép-használatot. 
          </P
></LI
><LI
><P
>&#13;            Az USA-ban az összes vállalat elõírja a rendszermag fordítását, 
	    mielõtt használnánk a gépet, ezért van Linux, Linux 
	    és Linux mindenhol az Egyesült Államokban!
          </P
></LI
><LI
><P
>&#13;            ...és még ezer más okból - túl sok lenne mind felsorolni! 
          </P
></LI
></UL
>
    </P
><P
>&#13;      Megjegyzés: a dokumentum rövid és egyszerû maradt, így még 
      a nem technikai beállítottságú "otthoni felhasználók" is 
      képesek lehetnek a Linux-rendszermag fordítására és futtatására. 
    </P
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="warnings"/>1.1. FIGYELMEZTETÉS</H3
><P
>&#13;          A megszokott ipari gyakorlatban van egy nyomkövetõ/hibakeresõ PC, 
	  egy teszt PC és a munkára használt PC. Senki sem dolgozik egybõl 
	  a munkára használt PC-n, elõször mindig a hibakeresõ, majd a teszt 
	  PC-n kísérletezünk. Erre a különbözõ egyéni képzettség, illetve a 
	  betanulási idõ miatt van szükség. A számítógép hardvere nagyon 
	  modern technológia, akárcsak az ûrsikló, a kockázatok nagyon összetettek, 
	  képes váratlanul meghibásodni. Annak ellenére, hogy törekszünk eme dokumentum 
	  frissen tartására valamint az összes parancsot ellenõrizzük, nagyon ajánlott 
	  a szakértelmedet elõször egy gyakorló PC-n kipróbálni, mielõtt egy "ÉLES" 
	  gépen alkalmaznád azt. Pontosítsd szakértelmed és élesítsd tudásod elõször 
	  egy tesztgépen futtatott Linuxon. Amikor minden mûködik, akkor válts át 
	  a "munkagépre", fokozott óvatossággal. Ha elrontod a tesztgépet veszélyes 
	  parancsok használatával, ezekbõl a hibákból is tanulni fogsz. Elõször nagyon 
	  beképzelten fogsz dolgozni a tesztgépen. A legtöbb vállalat régi PC-ket szerez, 
	  amiket tesztgépnek használnak. Kérünk értsd meg, nincs garancia erre 
	  a dokumentumra, viszont megteremtheted a saját garanciád azzal, hogy ellenõrzöd 
	  ezt a dokumentumot a tesztgépeden vagy az otthoni PC-n (alacsonyabb 
	  kockázati tényezõk mellett). (Készítsd el a saját garanciájú dokumentumodat, 
	  és akaszd ki a falra a számítógéped közelében!!) 
       </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="hun_trans"/>1.2. Magyar fordítás</H3
><P
>&#13;         Az eredeti fordítást (v0.9) <A
HREF="mailto: jzp1218@stud.u-szeged.hu_NO_SPAM"
TARGET="_top"
>Vámosi Zoltán</A
> készítette (1997).
         Újrafordította (v6.3) <A
HREF="mailto: laca@janus.gimsz.sulinet.hu_NO_SPAM"
TARGET="_top"
>Szíjjártó László</A
> (2003.07.28).
         Frissítette (v7.3) és a lektorálta <A
HREF="mailto:dacas@freemail.hu_NO_SPAM"
TARGET="_top"
>Daczi László</A
> (2003.11.21).
       </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR/><H2
CLASS="sect1"
><A
NAME="quick_steps"/>2. Gyors lépések - a rendszermag fordítása</H2
><P
>&#13;      Ennek a résznek a szerzõje 
      <A
HREF="mailto:alavoor[AT]yahoo.com"
TARGET="_top"
>&#13;        Al Dev (alavoor[AT]yahoo.com) 
      </A
>
      (A 
      <EM
>&#13;        legfrissebb verzió 
      </EM
>
      megtalálható a 
      <A
HREF="http://milkyway.has.it"
TARGET="_top"
>&#13;        "http://milkyway.has.it" 
      </A
>
      és 
      <A
HREF="http://www.milkywaygalaxy.freeservers.com"
TARGET="_top"
>&#13;        "http://www.milkywaygalaxy.freeservers.com" 
      </A
>
      webhelyeken. Ezeken a helyeken ellenõrizheted a változásokat). A tükrözéseket megtalálod a 
      <A
HREF="http://milkyway.bounceme.net"
TARGET="_top"
>&#13;        http://milkyway.bounceme.net 
      </A
> 
      webhelyen. Ezek a webhelyeken sok linuxos nyalánkságot és tippet is találsz. 
    </P
><P
>&#13;      A rendszermag újrafordítására szükség lehet, ha kisebbé akarod tenni, 
      ez GYORSABB mûködésû operációs rendszert eredményez. 
      Az új eszközök támogatásához is elengedhetetlen.
    </P
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="precautions"/>2.1. Elõkészületek</H3
><P
>&#13;        Mielõtt lefordítanád a rendszermagot, jó ötlet a rendszer biztonsági mentése. 
	Ha még eddig nem mentetted volna el, akkor most tedd meg. 
	Kereskedelmi forgalmazású mentõprogramokat is használhatsz, mint a 
        <A
HREF="http://24.221.230.253"
TARGET="_top"
>&#13;          BRS Backup-Recovery-Software 
        </A
>
        (ugyanezen az oldalon nyílt forrású/szabad felhasználású mentõprogramokat is 
	találsz, a "Backup and Restore Utility" menüpont alatt felsorolva). 
	A biztonsági mentés csak egy ajánlat, nem elõírás 
	annak elkészítése a Linux-rendszermag fordítása elõtt. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="upgrading"/>2.2. A rendszermag kisebb fejlesztése</H3
><P
>&#13;        Ha már fordítottál rendszermagot, és fel akarod fejleszteni a következõ 
	fejlesztési szintre (patch level), akkor egyszerûen másold be a 
	meglévõ beállítófájlt és használd fel újra. (Például: ha a 2.4.19-es 
	rendszermagot már fordítottad, és a 2.4.20-ra akarsz fejleszteni.)
      </P
><P
>&#13;        <EM
>&#13;          A kisebb fejlesztésekhez: 
        </EM
>
        Ez a lépés idõt spórolhat, ha fel akarod használni a régi beállításokat. 
	Amikor telepíted a rendszermagot, a konfigurációs fájlt általában a 
	/boot könyvtárba rakod. A .config fájlt ne .config.save néven mentsd el, 
	mivel a "make mrproper" ki fog törölni minden .config* fájlt! 
	Tehát használhatod a meglévõ beállítófájlt:
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# mkdir /usr/src/kernelconfigs 
	bash# cp /usr/src/linux/.config  /usr/src/kernelconfigs/.config.save
	bash# cp /usr/src/linux/.config  /usr/src/linux/configs/.config.save  # Különösen biztonságos
	bash# cp /boot/config*  /usr/src/linux/configs/  # Különösen biztonságos
	bash# cp /boot/config-2.4.18-19.8.0  /usr/src/linux/.config
        </PRE
></FONT
></TD
></TR
></TABLE
>
        Esetleg egy másik módszer - átmásolható a .config fájl a régi 
	rendszermag-forrásfából az újba. 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# ls -l /usr/src/lin*  # You can see that /usr/src/linux is a soft link
	bash# cd /usr/src/linux 
	bash# cp ../linux-old-tree/.config .  # Például cp ../linux-2.4.19/.config .
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
><P
>&#13;        vagy még egy módszer - használható a "make oldconfig" parancs is, 
	ami alapértelmezésként felhasználja a meglévõ ./.config fájlt a 
	beállítás kérdéseihez. 
      </P
><P
>&#13;        FIGYELEM: ha nincs elég szabad hely az /usr/src alatt, akkor bármely 
	partícióra kicsomagolható a rendszermag forrása, ahol van elég tárhely 
	(például a /home-ra). Ez azért van, mert a rendszermag fordítása sok szabad 
	helyet igényel az objektum-fájlok, mint a *.o, számára. Ezért 
	az /usr/src/linux könyvtárnak egy szimbolikus hivatkozásnak (soft link) 
	KELL lennie, ami arra a könyvtárra mutat, ahol a forrás van.
      </P
><P
>&#13;        Ezek után lásd a következõ részt, a programfordításról és a telepítésrõl. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="Documentation"/>2.3. Az új kiadás változásai: dokumentáció</H3
><P
>&#13;        Ha letöltötted az új rendszermag forrását, olvasd el a következõ 
	fájlokat az /usr/src/linux/Documentation könyvtárban 
        <P
></P
><UL
><LI
><P
>&#13;              Changes: ebben olvashatók a minimális követelmények valamint néhány megjegyzés 
            </P
></LI
><LI
><P
>&#13;              kernel.txt: ebben van a "Linux-rendszermag magyarázata" 
            </P
></LI
><LI
><P
>&#13;              Olvasd el az összes *.txt fájlt az /usr/src/linux/Documentation könyvtárban, 
	      de legfontosabbak a kernel*.txt fájlok. 
            </P
></LI
></UL
>
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="impatient"/>2.4. A türelmetleneknek</H3
><P
>&#13;        <P
></P
><OL
TYPE="1"
><LI
><P
>&#13;              Csomagold ki a forrást 
            </P
></LI
><LI
><P
>&#13;              cd /usr/src/linux; mkdir /usr/src/kernelconfigs ; cp 
              /usr/src/linux/.config /usr/src/kernelconfigs/.config.save; make 
              clean; make mrproper; make clean; cp 
              /usr/src/kernelconfigs/.config.save .config # Akkor, ha újra 
	      akarod használni a beállítófájlt ??
            </P
></LI
><LI
><P
>&#13;              Opcionális - másold át a konfigurációs fájlt: átmásolhatod a 
	      beállítófájlt a régi rendszermag-forrásfából az újba 
	      (idõt spórolhat, ha a régi beállításokat akarod használni). 
            </P
></LI
><LI
><P
>&#13;              make xconfig # Szebb, de korlátai vannak; csak "X" alatt fut 
            </P
></LI
><LI
><P
>&#13;              make dep 
            </P
></LI
><LI
><P
>&#13;              Adj egy egyedi nevet az új rendszermagnak - szerkeszd az 
              /usr/src/linux/Makefile fájlt és az EXTRAVERSION bejegyzést 
            </P
></LI
><LI
><P
>&#13;              nohup make bzImage 
            </P
></LI
><LI
><P
>&#13;              "make modules" és "make modules_install" 
            </P
></LI
><LI
><P
>&#13;              ...és elmehetsz vacsorázni vagy le is fekhetsz (szép Linuxos álmokat!), 
	      majd amikor visszajössz a rendszer kész! Nézd meg a naplófájlt a 
	      "less nohup.out" paranccsal.
            </P
></LI
><LI
><P
>&#13;              make install # Ez "NEM ajánlott" - használd a "cp 
              /usr/src/linux/arch/i386/boot/bzImage /boot/bzImage.myker" parancsot 
            </P
><P
>&#13;              Másold át a System.map fájlt a /boot könyvtárba: # cp System*.map* /boot/ 
            </P
><P
>&#13;              Másold át a rendszermag konfigurációs fájlt (az általad kiválasztott 
	      opciókat). Nem elengedhetetlen, de késõbb hasznos lehet. cp .config 
              /boot/config.KERNEL_VERSION.Name 
            </P
></LI
><LI
><P
>&#13;              Állítsd be a GRUB vagy a LILO rendszerbetöltõt. 
            </P
></LI
><LI
><P
>&#13;              Indítsd újra a gépet, és ellenõrizd az új rendszermag betöltõdését 
            </P
></LI
><LI
><P
>&#13;              Készíts biztonsági mentõlemezt a "bzdisk" vagy "mkbootdisk" paranccsal 
            </P
></LI
><LI
><P
>&#13;              Opcionális - make rpm # RPM csomag készítéséhez 
            </P
></LI
><LI
><P
>&#13;              Opcionális - make clean (ha tárhelyet akarsz felszabadítani) 
            </P
></LI
></OL
>
      </P
><P
>&#13;        Lásd a fenti lépések részleteit a következõ fejezetekben... 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="steps"/>2.5. Új rendszermag készítése - a lépések értelmezése</H3
><P
>&#13;        <EM
>&#13;          Az elõzõ részben említett lépések részletei: 
        </EM
>
      </P
><P
>&#13;        <EM
>&#13;          Figyelem: 
        </EM
>
        Az alábbiakban a "bash#" jelzi a bash készenléti jelét (prompt), 
	azokat a parancsokat kell begépelni, amiket a "bash#" jelzés után 
	következnek. A következõ parancsokat RedHat Linux alatt, a 2.4.7-10 verziójú 
	rendszermaggal teszteltük, de más terjesztéseknél is (esetleg kisebb 
	eltérésekkel mûködnie kell. Ugyanúgy mûködnie kéne a régi, 2.2, 2.0 
	és 1.3 verziójú rendszermagokkal is. Szintúgy a jövõbeli vagy új 
	verziójúakkal (kis eltérésekkel - értesítsetek róla).
      </P
><P
>&#13;        <P
></P
><UL
><LI
><P
>&#13;              <EM
>&#13;                Figyelem: 
              </EM
>
              Sok rendszermagot (kernel image) tárolhatsz a rendszereden. 
	      A következõ lépéseket követve nem írod felül vagy teszed tönkre a 
	      meglévõ rendszermagodat. Ezek a lépések 
	      
              <EM
>&#13;                nagyon biztonságosak 
              </EM
>
              és a jelenlegi rendszermagot nem érintik, azt nem módosítják. 
            </P
></LI
></UL
>
      </P
><P
>&#13;        <P
></P
><OL
TYPE="1"
><LI
><P
>&#13;              <EM
>&#13;                Csomagold ki a forrást: 
              </EM
>
	      A következõ lépések végrehajtása során "root" 
	      felhasználóként legyél bejelentkezve. 
	      Csatold fel a RedHat Linux CD-ROM-ot (a RedHat 9-ben Disc 2) és 
	      telepítsd a rendszermag forrás-RPM csomagját:
              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash$ su - root
	bash# cd /mnt/cdrom/RedHat/RPMS 
	bash# rpm -i kernel-headers*.rpm 
	bash# rpm -i kernel-source*.rpm 
	bash# rpm -i dev86*.rpm   
	bash# rpm -i bin86*.rpm   
              </PRE
></FONT
></TD
></TR
></TABLE
>
              A bin86*.rpm és az "as86" csak a 
              <EM
>&#13;                RÉGEBBI Linux 
              </EM
>
              verziókhoz kell, mint a Redhat 5.x. Szerezd be az "as86" Intel assembler csomagot a 
              dev86*.rpm-bõl a CD-ROM-ról vagy a 
              <A
HREF="http://rpmfind.net/linux/RPM/mandrake/7.1/Mandrake/RPMS/bin86-0.4-12mdk.i586.html"
TARGET="_top"
>&#13;                bin86-mandrake 
              </A
> honlapról
              , 
              <A
HREF="http://rpmfind.net/linux/RPM/kondara/jirai/i586/bin86-0.4-8k.i586.html"
TARGET="_top"
>&#13;                bin86-kondara 
              </A
>
              ). A legújabb, 9-es RedHat kernel-source.rpm csomagja tartalmazza a 
	      rendszermag fejlécfájlokat. Általában a forrás a RedHat lemezeken 
	      vagy a SRPM lemezeken található, egyébként beszerezheted a
              <A
HREF="http://rpmfind.net/linux/rpm2html/search.php?query=kernel-source&submit=Search+...&system=&arch="
TARGET="_top"
>&#13;                rpmfind.net kernel-source 
              </A
>
              (keresd a RawHide-ot a legújabb RedHat-hez) és 
              <A
HREF="http://rpmfind.net/linux/rpm2html/search.php?query=kernel-headers&submit=Search+...&system=&arch="
TARGET="_top"
>&#13;                rpmfind.net kernel-headers 
              </A
>
              honlapról. Bizonyosodj meg arról is, hogy az /usr/src/linux egy szimbolikus hivatkozás, 
	      ami a megfelelõ kicsomagolt forrásra mutat.
              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# cd /usr/src
	bash# ls -l    # Láthatod, hogy az /usr/src/linux egy szimbolikus hivatkozás, ami a forrásra mutat
	lrwxrwxrwx    1 root     root           19 Jan 26 11:01 linux -&gt; linux-2.4.18-19.8.0
	drwxr-xr-x   17 root     root         4096 Jan 25 21:08 linux-2.4.18-14
	drwxr-xr-x   17 root     root         4096 Mar 26 12:50 linux-2.4.18-19.8.0
	drwxr-xr-x    7 root     root         4096 Jan 14 16:32 redhat
              </PRE
></FONT
></TD
></TR
></TABLE
>
              Ha nem szimbolikus hivatkozás, akkor nevezd át az /usr/src/linux könyvtárat 
	      /usr/src/linux-2.4.yy könyvtárra és készíts egy szimbolikus hivatkozást. 
            </P
><P
>&#13;              FIGYELEM: ha nincs elég szabad hely az /usr/src alatt, akkor 
	      bármelyik partícióra kicsomagolhatod a forrást, ahol van 
	      elegendõ (mint a /home). Ez azért van, mert a rendszermag fordítása 
	      sok szabad helyet igényel az objektum-fájlok, mint a *.o, 
	      számára. Ezért az /usr/src/linux könyvtárnak egy szimbolikus 
	      hivatkozásnak KELL lennie, ami arra a könyvtárra mutat, ahol a 
	      forrás van.
            </P
></LI
><LI
><P
>&#13;              <EM
>&#13;                Takarítás: 
              </EM
>
              Mielõtt az "mrproper" parancsot kiadnánk, elmentheted a .config fájlt. 
              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# cd /usr/src/linux 
        bash# mkdir /usr/src/kernelconfigs ;
        bash# cp /usr/src/linux/.config  /usr/src/kernelconfigs/.config.save;
	bash# cp /usr/src/linux/.config  /usr/src/linux/configs/.config.save  # Különösen biztonságos
	bash# cp /boot/config*  /usr/src/linux/configs/  # Különösen biztonságos
	bash# make clean
	bash# make mrproper  # "EL KELL VÉGEZNED ezt az mrproper-t", különben rengeteg problémával szembesülsz !!
	bash# make clean
	bash# cp /usr/src/kernelconfigs/.config.save .config  # ha újra akarod használni a beállítófájlt ??
              </PRE
></FONT
></TD
></TR
></TABLE
>
            </P
></LI
><LI
><P
>&#13;              <EM
>&#13;                Opcionális - másold át a beállítófájlt: 
              </EM
>
              Ez a lépés idõt spórolhat meg, ha fel akarod használni a régi 
	      beállításokat. Amikor telepíted a rendszermagot, akkor a beállítófájlt 
	      általában a /boot alá rakod. Van néhány alapszintû beállítófájl, 
	      az /usr/src/linux/configs/kernel-*.config, amiket felhasználhatsz. 
	      Tehát használhatod a meglévõ konfigurációs fájlt:
              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;        bash# mkdir /usr/src/kernelconfigs ;
        bash# cp /usr/src/linux/.config  /usr/src/kernelconfigs/.config.save;
	bash# cp /usr/src/linux/.config  /usr/src/linux/configs/.config.save  # Különösen biztonságos
	bash# cp /boot/config*  /usr/src/linux/configs/  # Különösen biztonságos
	bash# cp /boot/config-2.4.18-19.8.0  /usr/src/linux/.config
	Vagy másold át az alapértelmezett beállítófájlt az /usr/src/linux/configs könyvtárból:
	bash# cp /usr/src/linux/configs/kernel-2.4.18-i686.config  /usr/src/linux/.config
	Vagy Athlon processzorok esetében 
	bash# cp /usr/src/linux/configs/kernel-2.4.18-athlon.config  /usr/src/linux/.config
              </PRE
></FONT
></TD
></TR
></TABLE
>
              Esetleg egy másik módszer - átmásolhatod a .config fájlt a régi 
	      rendszermag-forrásfából az újba. 
              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# ls -l /usr/src/lin*  # Látható, hogy az /usr/src/linux egy szimbolikus hivatkozás
	bash# cd /usr/src/linux 
	bash# cp ../linux-old-tree/.config .  # Például cp ../linux-2.4.19/.config .
              </PRE
></FONT
></TD
></TR
></TABLE
>
              Sõt egy másik módszer - használhatod a "make oldconfig" parancsot, 
	      ami alapértelmezésként felhasználja a meglévõ ./.config fájlt 
	      a beállítás kérdéseihez.
            </P
></LI
><LI
><P
>&#13;              <EM
>&#13;                Beállítás: 
              </EM
>
              <P
></P
><UL
><LI
><P
>&#13;                    Indítsd el az X-Window rendszert a "startx" paranccsal. 
		    Ha nem tudod elindítani, lásd alább a következõ lépést.
                    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# man startx
	bash# startx
	bash# cd /usr/src/linux 
	bash# make xconfig  # Szebb, bár korlátozott; csak "X" alatt fut
                    </PRE
></FONT
></TD
></TR
></TABLE
>
                    Ha hibaüzenetet kapsz, miszerint a "wish" nem található, 
		    telepítsd a tk-8.3.rpm csomagot.
                  </P
></LI
><LI
><P
>&#13;                    Ha nem tudod elindítani az "X"-et, akkor próbáld meg a következõt: 
                    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;		bash# export TERM=xterm
		bash# make menuconfig  # újabb, az ncurses/curses csomagot használja, nem mûködik, ha nincs telepítve
	Ha összezavarodott képernyõt kapsz, használj más terminál-emulációt, 
	mint a vt100, vt102, vt220 vagy ansi. A képernyõ zavaros lesz és 
	összevissza karaktereket látsz, ha telnet-tel lépsz be egy távoli Linux
	rendszerbe. Ebben az esetben a vt100, vt220 terminál-emulátorokat használd. 
	Például:
		bash# export TERM=vt220
		bash# export TERM=ansi
	A VT alacsonyabb szintjein használd: 
		bash# export TERM=vt100
		bash# make menuconfig  # újabb, az ncurses/curses csomagot használja, nem mûködik, ha nincs telepítve
	Ha a "menuconfig" parancs nem mûködik, akkor próbáld meg:
		bash# make config   # régi, felhasználóbarát módszer !!
                    </PRE
></FONT
></TD
></TR
></TABLE
>
                  </P
></LI
></UL
>
              A 
              <EM
>&#13;                "make xconfig" vagy "make menuconfig" 
              </EM
>
              egy felhasználóbarát GUI felületet indít el. A 
              <EM
>&#13;                "make config" 
              </EM
>
              egy parancssoros, konzolos felületet. Betöltheted a beállítófájlt az 
              <EM
>&#13;                /usr/src/linux/.config 
              </EM
>
              fájlból ("pont config" fájl. Figyelj a pontra a "config" elõtt). 
	      Kattints a "Load configuration from file" (Beállítások betöltése fájlból) 
	      gombra. A "make xconfig"-on belül (a problémák kivédése érdekében) a 
	      következõket kell tenned:
              <P
></P
><UL
><LI
><P
>&#13;                    <EM
>&#13;                      NAGYON FONTOS !!! : 
                    </EM
>
                    Válaszd a megfelelõ CPU típust - Pentium 3, AMD K6, Cyrix, Pentium 4, 
		    Intel 386, DEC Alpha, PowerPC, egyébként a rendszermag fordítása nem 
		    sikerül, vagy ha igen, akkor nem fog elindulni!!
                  </P
></LI
><LI
><P
>&#13;                    Válaszd az SMP támogatást - akár egy, akár több processzorod van 
                  </P
></LI
><LI
><P
>&#13;                    Fájlrendszerek - válaszd a Windows95 VFAT, MSDOS, NTFS 
		    fájlrendszereket mint a rendszermag részeit, és ne mint betölthetõ 
		    modulokat. (Nekem személy szerint elõnyös, de szabadon 
		    válaszd a saját rendszerednek megfelelõen).
                  </P
></LI
><LI
><P
>&#13;                    Engedélyezd a "Loadable kernel modules" (betölthetõ rendszermag 
		    modulok) támogatást! Ezzel az opcióval, a futó Linux rendszeren 
		    tudod az eszközmeghajtókat dinamikusan ki/be tölteni. Részletesen a 
		    <A
HREF="#loadable_modules"
TARGET="_top"
>Betölthetõ modulok</A
> fejezetben 
		    olvashatsz errõl. 
                  </P
></LI
></UL
>
              Ments és lépj ki a "make xconfig"-ból. Minden kiválasztott beállítási 
	      opció elmentõdött az 
              <EM
>&#13;                /usr/src/linux/.config 
              </EM
>
              (pont config) fájlba. 
            </P
></LI
><LI
><P
>&#13;              <EM
>&#13;                Függõségek:
              </EM
>
              Most add ki a következõ parancsot: 
              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# make dep
              </PRE
></FONT
></TD
></TR
></TABLE
>
            </P
></LI
><LI
><P
>&#13;              <EM
>&#13;                Adj egyedi nevet az új rendszermagodnak: 
              </EM
>
              Nevet is adhatsz a rendszermagnak, így az egyedi lesz és 
	      nem akad össze a többivel.
              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# cd /usr/src/linux
	bash# vi Makefile
              </PRE
></FONT
></TD
></TR
></TABLE
>
              Itt keresd meg az EXTRAVERSION = -19.8.0_blabla részt és változtasd meg 
	      például így: EXTRAVERSION = -19.8.0MyKernel.26Jan2003
            </P
></LI
><LI
><P
>&#13;              <EM
>&#13;                Add ki a "make" parancsot: 
              </EM
>
              Olvasd el a következõ fájlt (hogy információt gyûjts a rendszermag 
	      fordításáról/építésérõl. Tipp: használd a színes
              <A
HREF="http://www.tldp.org/HOWTO/Vim-HOWTO.html"
TARGET="_top"
>&#13;                gvim 
              </A
>
              szövegszerkesztõt a jobb olvashatóság érdekében. 
              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# gvim -R   /usr/src/linux/arch/i386/config.in 
	bash# man less 
	bash# less   /usr/src/linux/arch/i386/config.in 
	Nyomd le a "h" billentyût a súgóért és navigálj a szövegben az i, j, k, l, h 
	vagy a nyíl-, ill. a page up/down billentyûkkel.
              </PRE
></FONT
></TD
></TR
></TABLE
>
              Most add ki a "make" parancsot: 
              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;		bash# cd /usr/src/linux
		bash# man nohup
		bash# nohup make bzImage &amp;  
		bash# man tail
		bash# tail -f nohup.out     (.... a folyamat figyeléséhez) 
	Ez a rendszermagot az /usr/src/linux/arch/i386/boot/bzImage fájlba helyezi el.
                </PRE
></FONT
></TD
></TR
></TABLE
>
            </P
></LI
><LI
><P
>&#13;              <EM
>&#13;                BETÖLTHETÕ MODULOK: 
              </EM
>
              Most amíg a "make" végigzörög az elõzõ rész szerint, elindíthatsz egy másik 
	      xterm-es parancsértelmezõt és kövesd a lépéseket: ez a lépés
              <EM
>&#13;                CSAK AKKOR 
              </EM
>
              szükséges, ha engedélyezted a "loadable module support"-ot a fenti 
	      "Beállítás" lépésnél. A betölthetõ modulok a /lib/modules alatt 
	      találhatók. EL KELL végezned ezt a lépést, ha engedélyeztél vagy 
	      letiltottál bármely modult, egyébként "unresolved symbols" hibaüzeneteket 
	      fogsz kapni a rendszermag betöltõdése közben vagy azután.
              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	# indíts egy új xterm ablakot és ...
	bash# cd /usr/src/linux
	# írányítsd át a kimenetet, hogy ne írd felül a nohup.out-ot, amíg az fut...
	bash# nohup make modules 1&gt; modules.out 2&gt; modules.err  &amp;
	bash# make modules_install   # csak akkor add ki, ha a fenti "make" parancs sikeresen lefutott
              </PRE
></FONT
></TD
></TR
></TABLE
>
              Ez bemásolja a modulokat a /lib/modules könyvtárba. 
	      Részletesen a <A
HREF="#loadable_modules"
TARGET="_top"
>Betölthetõ modulok</A
> 
	      fejezetben olvashatsz errõl.
            </P
></LI
><LI
><P
>&#13;              <EM
>&#13;                Most menj vacsorázni vagy feküdj le: 
              </EM
>
              Amíg mindkét "make"-ablak elzörög magában, addig elmehetsz vacsorázni 
	      (pihenj picit) vagy bújj ágyba (szép linuxos álmokat), mire felébredsz 
	      és visszajössz, a rendszer kész lesz! Ellenõrizheted a kimenet naplóját 
	      a "less nohup.out" paranccsal.
              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# cd /usr/src/linux
	bash# less nohup.out
	bash# less modules.err
	bash# less modules.out
	Ha nem volt hiba:
	bash# make modules_install  
              </PRE
></FONT
></TD
></TR
></TABLE
>
            </P
></LI
><LI
><P
>&#13;              <EM
>&#13;                bzImage: 
              </EM
>
              Miután a bzImage sikerült, másold át a rendszermagot (kernel image) 
	      a /boot könyvtárba. Át kell másolnod az új fájlt, különben az új 
	      rendszermag 
              <EM
>&#13;                LEHET, HOGY NEM FOG 
              </EM
>
              betöltõdni. Ezen kívül a beállítófájlt is át kell másolnod a /boot 
	      területre, hogy tükrözze a rendszermag beállításait dokumentációs szempontból.
              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# cp /usr/src/linux/arch/i386/boot/bzImage     /boot/bzImage.myker.26mar2001
	# Át KELL másolnod a beállítófájlt, hogy tükrözze a megfelelõ rendszermagot
	# dokumentációs célból
	bash# cp /usr/src/linux/.config /boot/config-&lt;your_kernelversion_date&gt;
	# Példa: cp /usr/src/linux/.config /boot/config-2.4.18-19.8.0-26mar2001
              </PRE
></FONT
></TD
></TR
></TABLE
>
              <EM
>&#13;                FIGYELEM: 
              </EM
>
              Ha az initrd használatát tervezed a LILO vagy a GRUB rendszerbetöltõben, 
	      akkor lefordíthatod és elhelyezheted azt a /boot/initrd*.img fájlban. 
	      Részletesen az 
	      <A
HREF="#create_initrd"
TARGET="_top"
>"A" függelék - initrd.img fájl készítése</A
> 
	      fejezetben olvashatsz errõl.
            </P
></LI
><LI
><P
>&#13;              <EM
>&#13;                A LILO vagy a GRUB beállítása: 
              </EM
>
              Két lehetõség van a betöltésre RedHat Linux alatt - 
	      a GRUB és a LILO. 
              <EM
>&#13;                A GRUB beállítása: 
              </EM
>
              A GRUB újabb és sokkal jobb eszköz mint a LILO, elsõdlegesen 
	      ennek a használatát ajánlom. A LILO régebbi technológia. A GRUB 
	      különbözik a többi betöltõtõl (mint például a LILO) abban, hogy ez 
              <EM
>&#13;                "képes azt hazudni a MS Windowsnak (és elhitetni vele), 
		hogy az elsõ partícióra telepítették, akkor is ha nem így van!"
              </EM
>
              . Így megtarthatod a jelenlegi Linux rendszeredet ott, ahol van, 
	      és telepíthetsz Windowst mellé. Részletesen a
              <A
HREF="#grubconf"
TARGET="_top"
>"C" függelék - GRUB részletesen, grub.conf mintafájl</A
>
	       fejezetben olvashatsz errõl.
              <EM
>&#13;                A LILO beállítása: 
              </EM
>
              A LILO régebbi eszköz, részletesen a 
	      <A
HREF="#liloconf"
TARGET="_top"
>"B" függelék - lilo.conf mintafájl</A
>
              fejezetben olvashatsz róla. 
            </P
></LI
><LI
><P
>&#13;              Indítsd újra a gépet, és a lilo futásakor nyomd meg a TAB billentyût, 
	      majd gépeld be: "myker". Ha elindul, jó munkát végeztél! Egyébként a 
	      lilo menüjében válaszd a régi rendszermagot, indítsd el és próbálj 
	      meg mindent elölrõl kezdeni. A régi rendszermagod még
              <EM
>&#13;                mindig ÉRINTETLEN és BIZTONSÁGOS 
              </EM
>
              , például a 
              <EM
>&#13;                /boot/vmlinuz-2.0.34-0.6 
              </EM
>
            </P
></LI
><LI
><P
>&#13;              Ha az új rendszermagod betöltõdik, és jól is mûködik, 
	      elkészítheted a indítólemezed. Tégy egy üres 
	      hajlékonylemezt a meghajtóba, majd: 
              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# cd /usr/src/linux
	bash# make bzdisk
	Használható még az mkbootdisk parancs -
	bash# rpm -i mkbootdisk*.rpm
	bash# man mkbootdisk
              </PRE
></FONT
></TD
></TR
></TABLE
>
            </P
></LI
><LI
><P
>&#13;              Opcionálisan, készíts RPM csomagot: ha több gépre is telepíteni 
	      akarod az új rendszermagot, RPM csomagot is készíthetsz belõle.
              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	make rpm   # RPM csomag építéséhez
                </PRE
></FONT
></TD
></TR
></TABLE
>
            </P
></LI
><LI
><P
>&#13;              <EM
>&#13;                Takarítás: 
              </EM
>
              Opcionális: make clean (ha tárhelyet akarsz felszabadítani) 
            </P
></LI
></OL
>
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN242"/>2.6. Hibaelhárítás</H3
><P
>&#13;        Problémád van? Olvasd el az 
	<A
HREF="#troubleshoot"
TARGET="_top"
>"E" függelék - a gyakori hibák elhárítása</A
>
	fejezetet.
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="postkernel"/>2.7. A rendszermaghoz kapcsolódó utólagos fordítások</H3
><P
>&#13;        Olvasd el az 
	<A
HREF="#post_kernel_building"
TARGET="_top"
>"D" függelék - utólagos rendszermag fordítás</A
>
	fejezetet. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="reportbugs"/>2.8. Hová küldjem a hibajelentést?</H3
><P
>&#13;        Ha a fenti lehetõségek mindegyikét kipróbáltad és úgy gondolod, hogy a 
	rendszermag hibás. (Ez a fejezet eredetileg az 
	<A
HREF=""
TARGET="_top"
>"E" függelék - a gyakori hibák elhárítása</A
> fejezet végén volt, 
	tehát elõször az ott leírt lehetõségeket próbáljátok végig - a lektor) 
	Ebben az esetben jelentheted a hibát, így (talán)
	javítva lesz. Olvasd el az /usr/src/linux/REPORTING-BUGS fájlt, 
	majd látogass el a 
        <A
HREF="http://www.kernel.org/pub/linux/docs/lkml/reporting-bugs.html"
TARGET="_top"
>&#13;          Reporting Bugs for the Linux Kernel 
        </A
>
        (A Linux-rendszermag hibáinak bejelentése) honlapra. 
      </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR/><H2
CLASS="sect1"
><A
NAME="loadable_modules"/>3. Betölthetõ modulok</H2
><P
>&#13;      Mindenki, aki használta a "betölthetõ modulokat", igazán "megszerette" õket! 
      Szeretem a modulokat, mivel agyafúrt dolgok, és a nagyobb feladatokat kicsi, 
      kezelhetõ részekre szedik szét. Ha elkezded használni, fogadok, 
      hogy megszereted õket! A modulok csak a Linuxra jellemzõek. Ez 
      volt a világ elsõ olyan operációs rendszere, ami bemutatta a betölthetõ 
      modulok fogalmát. Egyetlen más operációs rendszer sem rendelkezik ezzel 
      a fogalommal, de a közeljövõben más rendszerek is megvalósíthatják.
    </P
><P
>&#13;      A betölthetõ modulok memóriát spórolhatnak, és megkönnyítik a beállítást. 
      A modulok hatóköre magában foglalja a fájlrendszereket, ethernet kártyák, 
      szalagos meghajtók, nyomtatók és mások eszközmeghajtóit.
    </P
><P
>&#13;      A modulok a rendszermag kódjának darabjai, amelyeket nem csatoltak 
      (foglaltak bele) közvetlenül a bele. Az ember lefordíthatja õket 
      elkülönítve is, és beillesztheti vagy eltávolíthatja a futó rendszermagból 
      majdnem bármikor. Rugalmasságából kifolyólag nem ajánlott bizonyos 
      rendszermag-jellemzõket beléjük kódolni. Sok népszerû eszközmeghajtó, 
      mint például a PCMCIA és a QIC-80/40 szalagos eszközmeghajtók, betölthetõ modulok.
    </P
><P
>&#13;      Olvasd el a Module-HOWTO (Modul HOGYAN) doksit: 
      <A
HREF="http://www.tldp.org/HOWTO/Module-HOWTO"
TARGET="_top"
>&#13;        "http://www.tldp.org/HOWTO/Module-HOWTO" 
      </A
>
      . 
    </P
><P
>&#13;      Olvasd el ezeket a kézikönyv-oldalakat is: 
      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# rpm -i /mnt/cdrom/Redhat/RPMS/modutils*.rpm
	bash# man lsmod
	bash# man insmod
	bash# man rmmod
	bash# man depmod
	bash# man modprobe
      </PRE
></FONT
></TD
></TR
></TABLE
>
      Például, ha be akarod tölteni a 
      <TT
CLASS="literal"
>&#13;        /lib/modules/2.4.2-2/kernel/drivers/block/loop.o 
      </TT
>
      modult, tedd ezt: 
      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# man insmod
	bash# modprobe loop
	bash# insmod loop
	bash# lsmod 
      </PRE
></FONT
></TD
></TR
></TABLE
>
      Az insmod keresési útvonalát (PATH) az /etc/modules.conf fájlban állíthatod be. 
    </P
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN266"/>3.1. A modulok segédprogramjainak telepítése</H3
><P
>&#13;        A modulok segédeszközeinek RPM csomagját így telepítheted: 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# rpm -i /mnt/cdrom/Redhat/RPMS/modutils*.rpm
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
><P
>&#13;      Az 
        <TT
CLASS="literal"
>&#13;          insmod 
        </TT
>
        beilleszti a modult a futó rendszermagba. A modulok általában a 
        <TT
CLASS="literal"
>&#13;          .o 
        </TT
>
        kiterjesztéssel rendelkeznek; a példaként említett neve 
        <TT
CLASS="literal"
>&#13;          drv_hello.o 
        </TT
>
        , így ennek beillesztéséhez kiadjuk az: "
        <TT
CLASS="literal"
>&#13;          insmod drv_hello.o 
        </TT
>
        " parancsot. A rendszermag által jelenleg használt modulok listájához használd az 
        <TT
CLASS="literal"
>&#13;          lsmod 
        </TT
>
        parancsot. A kimenet valami ilyesmi: blah# lsmod Module: #pages: Used by: 
        drv_hello 1 " 
        <TT
CLASS="literal"
>&#13;          drv_hello 
        </TT
>
        " a modul neve, egy lapnyi (4k) memóriát használ, 
	és jelenleg nincs más modul, ami tõle függ. 
	Eltávolításához használd az "
        <TT
CLASS="literal"
>&#13;          rmmod drv_hello 
        </TT
>
        " parancsot. Figyeld meg, hogy az 
        <TT
CLASS="literal"
>&#13;          rmmod 
        </TT
>
        egy 
        <EM
>&#13;          modulnevet, 
        </EM
>
        nem pedig egy fájlnevet igényel; ezt kinyerheted az 
        <TT
CLASS="literal"
>&#13;          lsmod 
        </TT
>
        listájából. A többi modul-segédeszköz céljait a 
	kézikönyv-oldalaik írják le.
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN281"/>3.2. A rendszermaggal szállított modulok</H3
><P
>&#13;        A 2.0.30-as verziótól kezdve, majdnem minden elérhetõ betölthetõ modul 
	formájában. A használatukhoz elõször bizonyosodj meg, hogy nem állítod 
	be õket a rendes rendszermagban; tehát nem válaszolsz 
        <TT
CLASS="literal"
>&#13;          y 
        </TT
>
        -el ezekre a "
        <TT
CLASS="literal"
>&#13;          make config 
        </TT
>
        " alatt. Fordíts egy új rendszermagot és indítsd el. Aztán: 
        <TT
CLASS="literal"
>&#13;          cd 
        </TT
>
        az 
        <TT
CLASS="literal"
>&#13;          /usr/src/linux 
        </TT
>
        könyvtárba ismét, és: "
        <TT
CLASS="literal"
>&#13;          make modules 
        </TT
>
        ". Ez lefordítja az összes modult, amit nem adtál meg a rendszermag konfigurációjában, 
	és hivatkozást (link) készít hozzájuk az 
        <TT
CLASS="literal"
>&#13;          /usr/src/linux/modules 
        </TT
>
         könyvtárba. Használhatod õket egyenesen abból a könyvtárból vagy hajtsd végre a " 
        <TT
CLASS="literal"
>&#13;          make modules_install 
        </TT
>
        " parancsot, ami telepíti õket a 
        <TT
CLASS="literal"
>&#13;          /lib/modules/x.y.z 
        </TT
>
        könyvtárba, ahol 
        <TT
CLASS="literal"
>&#13;          x.y.z 
        </TT
>
        a rendszermag verziója. 
      </P
><P
>&#13;        Ez fõleg a fájlrendszereknél lehet kényelmes. Valószínûleg nem használod 
	gyakran a minix vagy a msdos fájlrendszert. Például, ha belebotlok egy 
	msdos (iszonyat!) hajlékonylemezbe, csak beírom:
        <TT
CLASS="literal"
>&#13;          insmod /usr/src/linux/modules/msdos.o 
        </TT
>
        , és aztán 
        <TT
CLASS="literal"
>&#13;          rmmod msdos 
        </TT
>
        , amikor végeztem. Ez az eljárás körülbelül 50k RAM-ot spórol a 
	rendszermagban a normál mûködés során. Egy kis megjegyzés kívánkozik 
	ide a minix fájlrendszer kapcsán:
        <EM
>&#13;          mindig 
        </EM
>
        közvetlenül a rendszermagba állítsd be, ha "mentõlemezen" akarod használni.
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN297"/>3.3. Hogyan telepítsek csak egyetlen modult?</H3
><P
>&#13;        Tegyük fel, hogy már megcsináltad a "make modules" és "make modules_install" 
	lépéseket. Késõbb pedig még a "make clean"-t is a helyfelszabadítás érdekében. 
	Most pedig változtatni akarsz valamelyik modul egyetlen C fájlján, és újra 
	akarod építeni azt az egy modult, és a modulfájlt bemásolni a /lib/modules 
	alá. Hogyan csinálod? Hiszen nem akarsz egy "make modules" parancsot kiadni, 
	az mindent újraépít és 2-3 óráig tart!
      </P
><P
>&#13;        Le tudsz fordítani egyetlen modulfájlt (mondjuk a foo.o-t) és telepítheted 
	is. Ehhez egyszerûen szerkeszd meg a Makefile-t, és változtasd meg a SUBDIRS 
	bejegyzést csakis azokra a könyvtárakra, amik érdekelnek.
      </P
><P
>&#13;        Egy jó példa: azt vettem észre, hogy a rendszermagom nem támogatja az 
	NTFS fájlrendszert (persze kiadtam a "make clean"-t a "make modules" után. 
	A francba!). Így elhatároztam, hogy lefordítom az NTFS betölthetõ modulját. 
	Nem akartam az egész készletet (mivel ez nálam 2 óráig tartana), ezért az 
	alábbi módszert követtem, és csak a fs/ntfs modult fordítottam, majd kiadtam 
	az "insmod ntfs" parancsot. Az egész 5 percig tartott!
      </P
><P
>&#13;        Másik példa: ha csak az fs/autofs modul érdekel, akkor a következõket 
	teszem:
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	cd /usr/src/linux
	mv Makefile Makefile.original
	cp Makefile.original Makefile.my
	ln -s Makefile.my Makefile   # mivel néhány fájlnak még szüksége lehet a "Makefile"-ra
	vi Makefile.my
	# Megjegyzésekkel láttam el a "SUBDIRS" sorokat, és hozzáadtam azokat a könyvtárakat, amik érdekeltek
	# például a fs/autofs-hez:
		#SUBDIRS	=kernel drivers mm fs net ipc lib abi crypto
		SUBDIRS		=fs/autofs
	# Elmentettem a Makefile.my fájlt és kiadtam a következõ parancsot:
	make -f Makefile.my modules
	# Ez megcsinálja az autofs.o modult
	# Most bemásoltam a modul objektumfájlt a célkönyvtárba: /lib/modules
	# VESZÉLYES: NE CSINÁLD EZT: "make -f Makefile.my modules_install" , mivel kitakaríthatja
	# a többi jót is a /lib/modules könyvtárból !! Csak másold be, így:
	cp autofs.o /lib/modules/2.4.18-19.8.0/kernel/fs/autofs
	  
	# Most állítsunk vissza mindent a normál helyzetbe
	rm Makefile  # This is a link to Makefile.my
	ln -s Makefile.original Makefile
	  
	# Rögzítsd a változtatásokat a beállítófájlban a késõbbi használat érdekében
	# Szerkeszd az /usr/src/linux/.config fájlt és állítsd be modulként a szolgáltatást
	cd /usr/src/linux
        mkdir /usr/src/kernelconfigs ;
        cp /usr/src/linux/.config  /usr/src/kernelconfigs/.config.save;
	cp /usr/src/linux/.config  /usr/src/linux/configs/.config.save  # Különösen biztonságos
	cp /boot/config*  /usr/src/linux/configs/  # Különösen biztonságos
	vi /usr/src/linux/.config 
	# és változtasd meg a beállító paramétert. Például az én esetemben
	# az ntfs modulnál CONFIG_NTFS_FS=m jelzi, hogy ez modul.
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
><P
>&#13;        Többet is megtudhatsz a Makefile-ról és a make-rõl, ha elolvasod a GNU 
	make kézikönyv oldat: 
        <P
></P
><UL
><LI
><P
>&#13;              <A
HREF="http://www.gnu.org/manual/make"
TARGET="_top"
>&#13;                "http://www.gnu.org/manual/make" 
              </A
>
              . 
            </P
></LI
><LI
><P
>&#13;              University of Utah Makefile 
              <A
HREF="http://www.math.utah.edu/docs/info/make-stds_toc.html"
TARGET="_top"
>&#13;                "http://www.math.utah.edu/docs/info/make-stds_toc.html" 
              </A
>
            </P
></LI
><LI
><P
>&#13;              University of Hawaii Makefile 
              <A
HREF="http://www.eng.hawaii.edu/Tutor/Make"
TARGET="_top"
>&#13;                "http://www.eng.hawaii.edu/Tutor/Make" 
              </A
>
            </P
></LI
><LI
><P
>&#13;              A Linuxban - man make 
            </P
></LI
><LI
><P
>&#13;              A Linuxban - info make 
            </P
></LI
></UL
>
      </P
><P
>&#13;        Ismerkedj meg a modulokat elkészítõ Makefile-al. 
	A fájlnak van egy "module" sora, mint:
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	modules: $(patsubst %, _mod_%, $(SUBDIRS))
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
><P
>&#13;        A patsubst függvény szintaktikája  $(patsubst minta,helyettesítés,szöveg). 
	A százalékjelet ([percnt]) ugyanúgy használja, mint a mintaillesztõ szabályok - 
	mint egy sztringet, ami illeszkedik a mintában és a helyettesítõ szövegben 
	is. Végigkeresi a "szöveg"-et elválasztójellel tagolt szavakért, 
	amik illeszkednek a "mintá"-ra és kicseréli az elõfordulásaikat a 
	"helyettesítés"-re.
      </P
><P
>&#13;        Ez a Makefile ugyanúgy tartalmaz szabványos shell-függvényeket, 
	mint szabványos make függvényeket. A shell-függvények szintaktikája 
	$(shell parancs). Ez a függvény kimenetét adja vissza (az új sorok kihúzásával). 
      </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR/><H2
CLASS="sect1"
><A
NAME="cloning"/>4. A rendszermag "klónozása"</H2
><P
>&#13;      Lehet, hogy készíteni akarsz egy rendszermagot egy adott rendszeren, 
      majd ezt sok hasonló PC-re is akarod nagyüzemben telepíteni. 
      Az újonnan készített rendszermagnak a gépeik százaira való 
      egyszerûbb telepítése érdekében RPM (RedHat) vagy DEB (Debian) 
      csomag formájában akarod azt elkészíteni, vagy egyszerûen csak 
      tar.gz fájl formájában.
    </P
><P
>&#13;      <P
></P
><OL
TYPE="1"
><LI
><P
>&#13;            RPM csomagot készíthetsz a rendszermagból az rpmbuild -ba kernel*.spec paranccsal
          </P
></LI
><LI
><P
>&#13;            Ellenõrizd, hogy az elkészült kernel*.rpm minden, a 
	    /lib/modules/2.x.x-y könyvtárban lévõ fájlt tartalmaz. 
	    Egyébiránt össze kell csomagolnod a tar és gzip segítségével 
	    ezt a könyvtárat, és átvinni a célgépekre.
          </P
></LI
><LI
><P
>&#13;            Ellenõrizd, hogy a rendszermag-csomag tartalmazza a 
	    /boot/initrd-2.x.x-y.img fájlt, különben össze kell 
	    csomagolnod a tar és gzip segítségével, és átvinni a célgépekre.
          </P
></LI
><LI
><P
>&#13;            Ezen felül a /boot könyvtár más fájljait is, amik nincsenek a kernel*.rpm csomagban.
          </P
></LI
></OL
>
    </P
></DIV
><DIV
CLASS="sect1"
><HR/><H2
CLASS="sect1"
><A
NAME="important_questions"/>5. Fontos kérdések és válaszok</H2
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
NAME="AEN338"/>5.1. Egyébként mit is csinál a rendszermag?</H3
><P
>&#13;        A Unix rendszermagja közvetítõként viselkedik a programok és a 
	hardver között. Elõször is, elvégzi (vagy elrendezi) a memóriakezelést 
	az összes futó program (folyamat) számára, és biztosítja, hogy mindegyik 
	igazságosan (vagy éppen nem annyira igazságosan, ha engeded) osztozzon a 
	processzor ciklusain. Ezen felül egy szép, meglehetõsen hordozható felületet 
	biztosít a programok felé, hogy "beszélgethessenek" a hardverrel.
      </P
><P
>&#13;        Biztosan van még több minden is, amit el lehet mondani a mûködésérõl, 
	de ezek az alapvetõ funkciók a legfontosabbak amikrõl tudni kell.
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN342"/>5.2. Miért kéne frissítenem a rendszermagomat?</H3
><P
>&#13;        Az újabb rendszermagok általában több fajta hardver kezelését teszik 
	lehetõvé (vagyis több eszközvezérlõjük van), jobb folyamatvezérlésük 
	lehet, gyorsabbak és stabilabbak lehetnek, mint a régi verziók és 
	azok buta kis hibáit kijavíthatják. A legtöbben azért frissítenek, 
	mert új eszközvezérlõket és hibajavításokat akarnak.
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN345"/>5.3. Milyen hardvert támogatnak az új verziójú rendszermagok?</H3
><P
>&#13;        Olvasd el a 
        <A
HREF="http://www.tldp.org/HOWTO/Hardware-HOWTO"
TARGET="_top"
>&#13;          Hardware-HOWTO 
        </A
>
        (Hardver HOGYAN) dokumentumban. Ezen kívül megnézheted a " 
        <TT
CLASS="literal"
>&#13;          config.in 
        </TT
>
        " fájlt a Linux forráskódjában, vagy egyszerûen keresd ki a "
        <TT
CLASS="literal"
>&#13;          make config 
        </TT
>
        " kiadásával. Ez megmutatja az összes, standard rendszermag által 
	támogatott hardvert, de nem az összeset, amit a Linux támogat; 
	sok elterjedt eszközvezérlõt (mint a PCMCIA vezérlõk és néhány 
	szalagos meghajtó) betölthetõ modulként tartanak karban és külön 
	terjesztenek.
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN351"/>5.4. Milyen verziójú gcc és libc kell?</H3
><P
>&#13;        Linus ajánl egy adott verziójú gcc-t a
        <TT
CLASS="literal"
>&#13;          README 
        </TT
>
        fájlban, ami a Linux forráskód része. Ha nincs meg ez a verzió, 
	az ajánlott verziójú gcc dokumentációja jelzi, ha frissíteni 
	kell a libc programkönyvtárat. Ez nem bonyolult eljárás, 
	de fontos az útmutatások követése. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN355"/>5.5. Mi az a betölthetõ modul?</H3
><P
>&#13;        Részletesen a <A
HREF="#loadable_modules"
TARGET="_top"
>Betölthetõ modulok</A
> 
	fejezetben olvashatsz errõl.
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN359"/>5.6. Mennyi lemezterületre van szükségem?</H3
><P
>&#13;        Ez függ az egyéni rendszer-beállításaidtól. Elõször is, a tömörített 
	Linux forrás közel 14 MB méretû, legalábbis a 2.2.9 verzió. Sok helyen 
	megtartják ezt is, miután kicsomagolták. Kicsomagolva és egy nem túl 
	bonyolult beállítással, még további 67 MB-ot foglal.
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN362"/>5.7. Mennyi idõt vesz igénybe?</H3
><P
>&#13;        Az újabb gépekkel a fordítás drámaian kevesebb idõt igényel, 
	mint a régieken; egy AMD K6-2/300 egy gyors merevlemezzel a 
	2.2.x rendszermagot elkészíti körülbelül 4 perc alatt. Viszont 
	az öreg Pentiumokkal, 486-osokkal és 386-osokkal, ha úgy tervezed, 
	hogy nekiállsz fordítani, várhatsz akár órákat, napokat...
      </P
><P
>&#13;        Ha ez zavar téged, és éppen van egy gyorsabb gép a közelben, amin 
	fordíthatsz, akkor lefordíthatod azon (feltéve, hogy jó adatokat 
	adsz meg, a segédprogramjaid naprakészek stb.), majd átviheted 
	a rendszermagot a lassabb gépre.
      </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR/><H2
CLASS="sect1"
><A
NAME="patching_the_kernel"/>6. A rendszermag foltozása (patching)</H2
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
NAME="AEN368"/>6.1. Egy folt alkalmazása</H3
><P
>&#13;        A rendszermag lépésenkénti fejlesztésének eszköze a foltozás. 
	Például, ha v1.1.45-ös Linuxod van, és észreveszed, hogy létezik egy "
        <TT
CLASS="literal"
>&#13;          patch46.gz 
        </TT
>
        " fájl ehhez, ez azt jelenti, hogy frissítheted az 1.1.46 verzióra a 
	folt alkalmazásával. Elõször biztonsági másolatot ajánlott készíteni a 
	forrásfáról ("
        <TT
CLASS="literal"
>&#13;          make clean 
        </TT
>
        
	" majd ezután " 
        <TT
CLASS="literal"
>&#13;          cd /usr/src; tar zcvf old-tree.tar.gz linux 
        </TT
>
        ", ami egy tömörített tar archívumot készít).
      </P
><P
>&#13;        Tehát folytatva a fenti példát, tegyük fel, hogy van egy "
        <TT
CLASS="literal"
>&#13;          patch46.gz 
        </TT
>
        " fájl az 
        <TT
CLASS="literal"
>&#13;          /usr/src 
        </TT
>
        könyvtárban. Lépj be 
        <TT
CLASS="literal"
>&#13;          cd 
        </TT
>
        az 
        <TT
CLASS="literal"
>&#13;          /usr/src 
        </TT
>
        könyvtárba és add ki a " 
        <TT
CLASS="literal"
>&#13;          zcat patch46.gz [verbar] patch -p0 
        </TT
>
        " (vagy " 
        <TT
CLASS="literal"
>&#13;          patch -p0 [lt ] patch46 
        </TT
>
        " parancsot , ha a folt nincs tömörítve). Látni fogod, ahogy a feliratok 
	elzúgnak (vagy elcsattognak, ha lassabb géped van), jelezve, hogy 
	megpróbálják a kóddarabokat beilleszteni, és hogy ez sikerült-e vagy sem. 
	Általában ez a folyamat túl gyors ahhoz, hogy elolvashasd és nem lehetsz 
	biztos benne, hogy mûködött-e, ezért használd a 
        <TT
CLASS="literal"
>&#13;          -s 
        </TT
>
        kapcsolót a 
        <TT
CLASS="literal"
>&#13;          patch 
        </TT
>
        programhoz, ami azt jelzi a 
        <TT
CLASS="literal"
>&#13;          patch 
        </TT
>
        programnak, hogy csak a hibaüzeneteket írja ki (nem fogsz sokat kapni a "hé, 
	a komputerem éppen valami változtatást csinál!" érzésbõl, de lehet, hogy épp 
	ezt értékeled...) Azon dolgok megtekintéséért, amik nem mentek simán, 
	lépj be az 
        <TT
CLASS="literal"
>&#13;          /usr/src/linux 
        </TT
>
        könyvtárba és keress 
        <TT
CLASS="literal"
>&#13;          .rej 
        </TT
>
        kiterjesztésû fájlokat. A 
        <TT
CLASS="literal"
>&#13;          patch 
        </TT
>
        régebbi verziói (azok a verziók, amiket alsóbbrendû fájlrendszeren fordítottak) 
	a visszadobott dolgokat 
        <TT
CLASS="literal"
>&#13;          # 
        </TT
>
        kiterjesztéssel látják el. Használhatod a "
        <TT
CLASS="literal"
>&#13;          find 
        </TT
>
        " parancsot, hogy keressen helyetted; a "find . -name '*.rej' -print" 
	kiírja a standard kimenetre az összes  
        <TT
CLASS="literal"
>&#13;          .rej 
        </TT
>
         kiterjesztésû fájlt, ami az aktuális könyvtárban és alkönyvtáraiban van.
      </P
><P
>&#13;        Ha minden rendben zajlott, adj ki egy "
        <TT
CLASS="literal"
>&#13;          make clean 
        </TT
>
        ", " 
        <TT
CLASS="literal"
>&#13;          config 
        </TT
>
        ", and " 
        <TT
CLASS="literal"
>&#13;          dep 
        </TT
>
        " parancssorozatot, a 3. és 4. részben leírtak szerint. 
      </P
><P
>&#13;        Elég kevés kapcsolója van a 
        <TT
CLASS="literal"
>&#13;          patch 
        </TT
>
        parancsnak. Ahogy fentebb említettem, a
        <TT
CLASS="literal"
>&#13;          patch -s 
        </TT
>
        minden üzenetet elnyom, kivéve a hibaüzeneteket. Ha valahol másutt tartod a 
	rendszermag forrását, nem az 
        <TT
CLASS="literal"
>&#13;          /usr/src/linux 
        </TT
>
        könyvtárban, a 
        <TT
CLASS="literal"
>&#13;          patch -p1 
        </TT
>
        (abban a könyvtárban) rendben megfoltozza a dolgokat. Egyéb 
        <TT
CLASS="literal"
>&#13;          patch 
        </TT
>
        kapcsolókat a jól dokumentált kézikönyv oldalakban keress.
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN400"/>6.2. Ha valami nem sikerül</H3
><P
>&#13;        (Figyelem: ez a rész leginkább a meglehetõsen régi rendszermagokra vonatkozik)
      </P
><P
>&#13;        A leggyakrabban elõforduló probléma az volt, amikor egy folt módosította a "
        <TT
CLASS="literal"
>&#13;          config.in 
        </TT
>
        " fájlt és az nem jól nézett ki, mivel megváltoztattad a beállításokat, 
	hogy megfeleljenek a gépednek. Ezt már javították, de még 
	belefuthatsz, ha régi rendszermagot fordítasz. A kijavításához nézd meg a 
        <TT
CLASS="literal"
>&#13;          config.in.rej 
        </TT
>
        fájlt, hogy mi maradt az eredeti foltból. 
	A változásokat általában "
        <TT
CLASS="literal"
>&#13;          + 
        </TT
>
        " és " 
        <TT
CLASS="literal"
>&#13;          - 
        </TT
>
        " karakterek jelzik a sorok elején. Nézd meg a szomszédos sorokat, 
	és jegyezd meg, hogy "
        <TT
CLASS="literal"
>&#13;          y 
        </TT
>
        "-al vagy " 
        <TT
CLASS="literal"
>&#13;          n 
        </TT
>
        " betûvel vannak jelölve. Most szerkeszd a 
        <TT
CLASS="literal"
>&#13;          config.in 
        </TT
>
        fájlt, és változtasd meg az " 
        <TT
CLASS="literal"
>&#13;          y 
        </TT
>
        "-t " 
        <TT
CLASS="literal"
>&#13;          n 
        </TT
>
        "-re és az " 
        <TT
CLASS="literal"
>&#13;          n 
        </TT
>
        "-et " 
        <TT
CLASS="literal"
>&#13;          y 
        </TT
>
        "-ra, amikor szükséges. Adj ki egy "patch -p0 &lt; config.in.rej" 
	parancsot és ha azt jelzi, hogy sikerült, akkor folytathatod a 
	beállítást és fordítást. A 
        <TT
CLASS="literal"
>&#13;          config.in.rej 
        </TT
>
        fájl ottmarad, de törölhetõ.
      </P
><P
>&#13;        Ha további problémákba ütközöl, akkor használaton kívüli foltot telepítettél. 
	Ha azt mondja, hogy "
        <TT
CLASS="literal"
>&#13;          previously applied patch detected: Assume -R? 
        </TT
>
        " (elõzõleg már alkalmazott foltot észleltem), akkor valószínûleg olyan 
	foltot próbáltál alkalmazni, ami a jelenlegi verziószám alatti; ha "
        <TT
CLASS="literal"
>&#13;          y 
        </TT
>
        "-t válaszolsz, megpróbálja visszaállítani a forrásodat, és nagy 
	valószínûséggel ez nem sikerül; ezért egy teljesen új forrásfára 
	van szükséged (ami nem is olyan rossz ötlet elsõ nekifutásra).
      </P
><P
>&#13;        A folt visszavonásához használd a "
        <TT
CLASS="literal"
>&#13;          patch -R 
        </TT
>
        " parancsot az eredeti folton.
      </P
><P
>&#13;        A legjobb dolog, ha a foltozás tényleg rossz irányba megy, 
	hogy újrakezdesz mindent egy tiszta, még nem használt forrásfával 
	(például az egyik
        <TT
CLASS="literal"
>&#13;          linux-x.y.z.tar.gz 
        </TT
>
        fájllal). 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN423"/>6.3. A .orig fájloktól történõ megszabadulás</H3
><P
>&#13;        Már néhány foltozás után a 
        <TT
CLASS="literal"
>&#13;          .orig 
        </TT
>
        fájlok elkezdenek szaporodni. Például, egy 1.1.51-es fámat valamikor 
	még az 1.1.48 tájékán takarítottam ki. A .orig fájlok törlésével majdnem 
	fél MB hely szabadult fel. A "find . -name '*.orig' -exec rm -f {} ';' " 
	parancs gondoskodik errõl. A 
        <TT
CLASS="literal"
>&#13;          patch 
        </TT
>
        azon verziói, amik a 
        <TT
CLASS="literal"
>&#13;          # 
        </TT
>
        karaktert használják a visszautasítások fájlneveiben, a tilde (~) 
	karakterrel jelzik a 
        <TT
CLASS="literal"
>&#13;          .orig 
        </TT
>
        fájlokat. 
      </P
><P
>&#13;        Vannak jobb módszerek is a 
        <TT
CLASS="literal"
>&#13;          .orig 
        </TT
>
        fájloktól történõ megszabadulásra, amik függnek a GNU
        <TT
CLASS="literal"
>&#13;          xargs 
        </TT
>
	parancstól: "find . -name '*.orig' | xargs rm"  vagy az 
	"elég biztonságos de kicsit bõbeszédûbb" módszer: 
         find . -name '*.orig' -print0 | xargs --null rm --
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN433"/>6.4. Egyéb foltok</H3
><P
>&#13;        A Linus által terjesztett foltokon kívül léteznek mások is (én "nem 
	szabványos" foltoknak hívom õket). Ha ezeket használod, a Linus-félék 
	lehet, hogy nem mûködnek megfelelõen. Elképzelhetõ, hogy vissza kell õket 
	vonnod, kijavítani a forrást vagy a foltot magát, telepíteni egy 
	új forrásfát vagy ezek kombinációját kell tenned. Ez nagyon bosszantó lehet, ezért 
	ha nem akarod módosítani a forrást (egy nagyon rossz végeredmény lehetõségét 
	vállalva), forgasd vissza a nem szabványos foltokat, mielõtt a Linus-féléket 
	alkalmazod, vagy telepíts egy új forrásfát. Ezután láthatod, hogy a nem 
	szabványos foltok mûködnek-e még. Ha nem, akkor vagy maradsz a régi 
	rendszermagnál, játszhatsz a folttal vagy a forrással, hogy mûködjön, 
	vagy vársz (esetleg rimánkodsz érte) a folt új verziójáig.
      </P
><P
>&#13;        Milyen gyakoriak azok a foltok, amik nincsenek a szabvány rendszermagban? 
	Valószínûleg hallottál róluk. Valamikor használtam a "noblink" foltot 
	a virtuális konzoljaimhoz, mert utálom a villogó kurzort. (Ezt a foltot 
	(legalábbis régen) gyakran frissítették az új verziókhoz). Azonban mióta 
	a legtöbb új eszközmeghajtót modulként fejlesztik, a "nem szabványos" 
	foltok kibocsátási üteme jelentõsen csökken.
      </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR/><H2
CLASS="sect1"
><A
NAME="tips_and_tricks"/>7. Tippek és trükkök</H2
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
NAME="AEN439"/>7.1. A make vagy a patch parancs kimenetének átirányítása</H3
><P
>&#13;        Ha látni szeretnéd a naplókat, amiket a " 
        <TT
CLASS="literal"
>&#13;          make 
        </TT
>
        " vagy a " 
        <TT
CLASS="literal"
>&#13;          patch 
        </TT
>
        " parancsok csinálnak, akkor átirányíthatod a kimenetüket egy fájlba. 
	Elõször nézd meg, milyen shellt használsz: " 
        <TT
CLASS="literal"
>&#13;          grep root /etc/passwd 
        </TT
>
        " és keress valami ehhez hasonlót: " 
        <TT
CLASS="literal"
>&#13;          /bin/csh 
        </TT
>
        ". 
      </P
><P
>&#13;        Ha sh-t vagy bash-t használsz, a (parancs) 2&gt;&amp;1 | tee (kimeneti fájl) 
	utasítássor készít egy másolatot a 
        <TT
CLASS="literal"
>&#13;          (parancs) 
        </TT
>
        kimenetérõl a " 
        <TT
CLASS="literal"
>&#13;          (kimeneti fájl) 
        </TT
>
        "-ba. 
      </P
><P
>&#13;        A csh vagy tcsh esetén használd a (parancs) |&amp; tee (kimenti fájl) formát. 
      </P
><P
>&#13;        Az rc esetén (megjegyzés: valószínûleg nem ezt használod) : (parancs) &gt;[2=1] | 
        tee (kimeneti fájl) 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN451"/>7.2. Feltételes rendszermag-telepítés</H3
><P
>&#13;        A hajlékonylemezre történõ telepítésen kívül még egyéb módszerek is léteznek 
	az új rendszermag kipróbálására anélkül, hogy a régit bántatnánk. Sok egyéb 
	Unix változatól eltérõen, a LILO képes a rendszermagot a lemez bármely részérõl 
	betölteni (ha nagy méretû (500 MB vagy nagyobb) lemezed van, kérlek olvasd el a 
	LILO dokumentációját, hogy ez mennyiben okozhat problémát). Ezért, ha az 
	"image = /usr/src/linux/arch/i386/boot/bzImage label = new_kernel" sorokat 
	berakod a LILO beállítófájljának végére, akkor választhatod az újonnan 
	fordított rendszermagot is anélkül, hogy a régi 
        <TT
CLASS="literal"
>&#13;          /vmlinuz 
        </TT
>
        -hoz hozzányúlnál (természetesen miután futtatod a 
        <TT
CLASS="literal"
>&#13;          lilo 
        </TT
>
        parancsot). A legkönnyebben a betöltés közben a SHIFT lenyomásával 
	lehet jelezni a LILO-nak, hogy az új rendszermagot töltse be (amikor azt látod 
	a képernyõn, hogy 
        <TT
CLASS="literal"
>&#13;          LILO 
        </TT
>
        , és semmi mást), ami ad egy készenléti jelet. Ennél a pontnál beírhatod: " 
        <TT
CLASS="literal"
>&#13;          new_kernel 
        </TT
>
        " az új rendszermag indításához. 
      </P
><P
>&#13;        Ha több különbözõ rendszermag-forrásfát akarsz tárolni egyszerre a gépen 
	(ez azonban 
        <EM
>&#13;          rengeteg 
        </EM
>
        lemezterületet fogyaszthat; légy óvatos), a legtöbbször az 
        <TT
CLASS="literal"
>&#13;          /usr/src/linux-x.y.z 
        </TT
>
        könyvtárba kerülnek, ahol az 
        <TT
CLASS="literal"
>&#13;          x.y.z 
        </TT
>
        a rendszermag verziója. Ezután "kiválaszthatsz" egy forrásfát egy szimbolikus 
	hivatkozás segítségével; például "
        <TT
CLASS="literal"
>&#13;          ln -sf linux-1.2.2 /usr/src/linux 
        </TT
>
        ", ez az 1.2.2-t teszi aktuálissá. Mielõtt egy hasonló szimbolikus hivatkozást 
	készítenél, bizonyosodj meg arról, hogy az 
        <TT
CLASS="literal"
>&#13;          ln 
        </TT
>
        utolsó paramétere nem egy létezõ könyvtár (régebbi szimbolikus hivatkozás 
	elfogadható); különben az eredmény nem az lesz, amit várnál. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN464"/>7.3. Rendszermag frissítések</H3
><P
>&#13;        Russell Nelson ( 
        <TT
CLASS="literal"
>&#13;          nelson@crynwr.com 
        </TT
>
        ) foglalja össze az új rendszermag kiadásoknál a változásokat. 
	Ezek rövidek, és fejlesztés elõtt átnézheted õket. Hozzáférhetõk 
	anonymous FTP-vel az 
        <A
HREF="ftp://ftp.emlist.com"
TARGET="_top"
>&#13;          "ftp://ftp.emlist.com" 
        </A
>
        webhelyen, a 
        <TT
CLASS="literal"
>&#13;          pub/kchanges 
        </TT
>
        könyvtárban, vagy a 
        <A
HREF="http://www.crynwr.com/kchanges"
TARGET="_top"
>&#13;          "http://www.crynwr.com/kchanges" 
        </A
>
      webhelyen. 
      </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR/><H2
CLASS="sect1"
><A
NAME="ftpfs"/>8. RPM csomagok felcsatolása (mount) az FTPFS segítségével</H2
><P
>&#13;      Mostanra lefordítódott az új rendszermagod és jól fut. Szükséged lehet arra 
      a számtalan RPM csomagra, amiket lehet, hogy a közeljövõben telepítened kell 
      majd. Ennek egyik útja, hogy fizikailag felcsatolod a LINUX CD-ROM-jait, 
      de több mint 3 CD-rõl van szó, kényelmetlen leválasztani és cserélgetni 
      õket. Itt jön a képbe az FTPFS. 
    </P
><P
>&#13;      Ha automatizálni szeretnéd az RMP csomagok telepítését, fontold meg 
      az "apt-get" parancs használatát. Az apt-get automatikusan feloldja a 
      függõségeket, letölti és telepíti vagy frissíti a csomagokat. Részletesebben a 
      <A
HREF="#apt-get"
TARGET="_top"
>Telepítés, frissítés fénysebességgel</A
> fejezetben 
      olvashatsz errõl.
    </P
><P
>&#13;      Az FTP fájlrendszer (FTPFS) egy Linux-rendszermag-modul, ami kibõvíti a 
      VFS hatókörét arra, hogy FTP köteteket is fel tudjon csatolni. Tehát fel 
      tudsz csatolni FTP-n megosztott könyvtárakat a saját fájlrendszeredbe, 
      és a helyi fájlok kezelésének elõnyeit élvezheted. Megtalálható a 
      <A
HREF="http://lufs.sourceforge.net/lufs"
TARGET="_top"
>&#13;        "http://lufs.sourceforge.net/lufs" 
      </A
>
      és a 
      <A
HREF="http://ftpfs.sourceforge.net"
TARGET="_top"
>&#13;        "http://ftpfs.sourceforge.net" 
      </A
>
      webhelyen. 
    </P
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN479"/>8.1. Az ftpfs használata</H3
><P
>&#13;        Töltsd le az ftpfs-t, és telepítsd a rendszeredre. Az ftpfs 
	modulként települ: /lib/modules/2.4.18-19.8.0/kernel/fs/ftpfs/ftpfs.o. 
	Ezen kívül az ftpmount parancs az /usr/bin/ftpmount könyvtárba. 
	Ezután megteheted a következõt:
      </P
><P
>&#13;        Jelentkezz be root felhasználóként (su - root) és futtasd ezt a szkriptet:
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	#!/bin/sh -x
	# Hasznald ezt a szkriptet a redhat cdroms rpm-konyvtar (disk1,2,3) felcsatolasahoz
	# Built rpm by name ftpfs.
	# http://lufs.sourceforge.net/main/projects.html
	# ftpmount --help
	# Probald ezt: ftpmount [user[:pass]@]host_name[:port][/root_dir] mount_point [-o]
	# [-uid=id] [gid=id] [fmask=mask] [dmask=mask]
	#ftpmount anonymous:pass@ftp.kernel.org /mnt/ftpfs
	#mkdir -p /mnt/ftpfs /mnt/ftpfs/updates /mnt/ftpfs/rpms /mnt/ftpfs/contrib
	# Redhat ftp mirror sites - http://www.redhat.com/download/mirror.html
	FTPSITE="csociety-ftp.ecn.purdue.edu"
	USER="anonymous:pass"
	ftpmount $USER@$FTPSITE/pub/redhat/redhat  /mnt/ftpfs/site
	ftpmount $USER@$FTPSITE/pub/redhat/redhat/linux/updates/8.0/en/os  /mnt/ftpfs/updates
	ftpmount $USER@$FTPSITE/pub/redhat/redhat/linux/8.0/en/os/i386/RedHat /mnt/ftpfs/rpms
	ftpmount $USER@$FTPSITE/pub/redhat-contrib /mnt/ftpfs/contrib
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN484"/>8.2. Az ftpfs parancsai</H3
><P
>&#13;        Mielõtt egyáltalán elkezdenél az FTP kötetek felcsatolásának gondolatával 
	játszani, gyõzõdj meg, hogy elegendõ sávszélességed van-e, különben nem 
	lesz nagy élvezet.
      </P
><DIV
CLASS="sect3"
><HR/><H4
CLASS="sect3"
><A
NAME="AEN487"/>8.2.1. Az autofs-féle módszer - ki kell próbálnod!</H4
><P
>&#13;          Ha elég bölcs voltál, és telepítetted az autofs/automount szolgáltatást 
	  (nézd meg a telepítési feljegyzéseket), akkor nagyon fincsi módon 
	  használhatod az ftpfs-t: csak próbálj meg hozzáférni a kívánt szerveren 
	  bármelyik fájlhoz/könyvtárhoz az /mnt/ftpfs alatt. 
          <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	cd /mnt/ftpfs/[user:pass@]ftp_server[:port]
          </PRE
></FONT
></TD
></TR
></TABLE
>
        </P
><P
>&#13;          Valami ilyesmit csinálj: cd /mnt/ftpfs/ftp.kernel.org. 
	  És mi történik? Már ott is vagy!
        </P
><P
>&#13;          Normál esetben ezt csak anonymous FTP-vel használd, mivel nem akarhatod, 
	  hogy a felhasználói név/jelszó információid megjelenjenek az /mnt/ftpfs 
	  könyvtárfában. 
        </P
></DIV
><DIV
CLASS="sect3"
><HR/><H4
CLASS="sect3"
><A
NAME="AEN493"/>8.2.2. Az ftpmount-féle megoldás</H4
><P
>&#13;          <EM
>&#13;            ftpmount [lsqb ]user[lsqb ]:password]@]hostname[lsqb ]:port ][lsqb 
            ]/root_dir] mount_point [lsqb ]-own] [lsqb ]-uid=id] [lsqb 
            ]-gid=id] [lsqb ]-fmask=mask] [lsqb ]-dmask=mask] [lsqb ]-active] 
          </EM
>
        </P
><P
>&#13;          <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	A paraméterek: [alapértékek]
	    * user: A felhasználói név, amivel belépsz az FTP szerverre. [anonymous]
	    * password: A felhasználói jelszó. [user@ftpfs.sourceforge.net]
	    * hostname: Az FTP szerver.
	    * port: A port, amin a szerver figyel. [21]
	    * root_dir: Az FTP szerver felcsatolandó könyvtára. Megadható a bevezetõ / jel nélkül is (vagyis "home/duru", nem "/home/duru/"). [/]
	    * mount_point: A helyi könyvtár, amibe az FTP könyvtárat fel akarod csatolni.
	    * own: Jelzõbit minden távoli fájl tulajdonosi viszonyának jelzésére. Olyan FTP-knél hasznos, amik nem felhasználói neveket, hanem azonosítókat (UID) listáznak ki.
	    * uid: Annak a helyi felhasználónak az UID-je, akié lesz a felcsatolt könyvtár
	    * gid: A helyi csoport azonosítója, aki birtokolja a felcsatolt könyvtárat.
	    * fmask: A numerikus fájlmaszk, ami az összes felcsatolt fájléval VAGY kapcsolatban lesz.
	    * dmask: A numerikus könyvtármaszk, ami az összes felcsatolt könyvtáréval VAGY kapcsolatban lesz.
	    * active: Jelzõbit az aktív módú FTP forgalom jelzésére. Hasznos, ha valamilyen tûzfal mögött vagy, és nem tudsz véletlenszerûen kiválasztott portokhoz kapcsolódni.
          </PRE
></FONT
></TD
></TR
></TABLE
>
        </P
><P
>&#13;          Például: ftpmount mali@ftp.linuxnet.wox.org /mnt/ftpfs -uid=500 -gid=500 
          -dmask=555 
        </P
><P
>&#13;          Általában jó ötlet, ha nem adod meg paraméterként a jelszavadat, 
	  mivel az ftpmount úgyis kérdezni fogja.
        </P
></DIV
><DIV
CLASS="sect3"
><HR/><H4
CLASS="sect3"
><A
NAME="AEN501"/>8.2.3. A mount-féle módszer</H4
><P
>&#13;          Ha valamilyen okból nem az ftpmount-ot választod (valószínûleg 
	  valamilyen rendszermag-foltot telepítettél és lusta vagy az 
	  ftpmount-ot is telepíteni), itt egy módszer a jó öreg mount
	  paranccsal:
        </P
><P
>&#13;          <EM
>&#13;            mount -n -t ftpfs none mount_point -o ip=server_ip [lsqb 
            ],user=user_name] [lsqb ],pass=password] [lsqb ],port=server_port] 
            [lsqb ],root= root_dir] [lsqb ],own] [lsqb ],uid=id] [lsqb 
            ],gid=id] [lsqb ],fmode=mask] [lsqb ],dmode=mask] [lsqb ],active] 
          </EM
>
        </P
><P
>&#13;          Figyeld meg, hogy a szerver IP címét kell megadnod és az egyetlen 
	  lehetõség a jelszó megadására, ha egyszerûen beírod a parancssorba. 
	  Például, mialatt teszteltem, a következõ parancsot használtam: 
        </P
><P
>&#13;          mount -n -t ftpfs none /mnt/ftpfs -o 
          ip=127.0.0.1,user=mali,pass=my_pass 
        </P
></DIV
><DIV
CLASS="sect3"
><HR/><H4
CLASS="sect3"
><A
NAME="AEN508"/>8.2.4. Néhány megjegyzés</H4
><P
>&#13;          A kötet leválasztására használható az 
          <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	umount mount_point
          </PRE
></FONT
></TD
></TR
></TABLE
> 
        parancs.
	</P
><P
>&#13;          Az own opció (-o az ftpmount-nál) ráerõlteti az összes felcsatolt fájlra 
	  a felcsatolását végzõ felhasználó tulajdonosi jogát. Ez hasznos, ha ki 
	  akarjuk igazítani néhány szerver különös felhasználó/jogosultság beállítását 
	  (SERVU és hasonlók).
        </P
><P
>&#13;          Néhány bölcs szó: 
          <P
></P
><UL
><LI
><P
>&#13;                Használd a -n felcsatolási kapcsolót! Gondolom, nem akarod a felhasználó/jelszó 
		információidat az mtab-ban viszontlátni.
              </P
></LI
><LI
><P
>&#13;                Ne "tépd ki a falból"! (Kitépni a falból = egy tucat folyamat még olvassa a 
		felcsatolási pont alatti dolgokat)
              </P
></LI
><LI
><P
>&#13;                Egyetlen folyamattal mûködik a legjobban! Amíg a konkurens hozzáférés 
		(normál körülmények közt) nem okoz semmilyen problémát, a kimenetet egy 
		olvasási folyamatra optimalizálták (a TCP kapcsolat életben marad). 
		Tehát ha mozit akarsz nézni, nem akarhatod, hogy másik folyamat is 
		hozzáférjen a felcsatolási ponthoz és agyonvágja a teljesítményt 
		(bízz bennem!).
              </P
></LI
><LI
><P
>&#13;                Az IP címformátum nem kóser - használd az ftpmount-ot.
              </P
></LI
></UL
>
        </P
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR/><H2
CLASS="sect1"
><A
NAME="kernel_textbooks"/>9. A rendszermagról szóló könyvek és dokumentumok</H2
><P
>&#13;      A Linux-rendszermagról szóló könyveket találsz a következõ helyeken: 
      <P
></P
><UL
><LI
><P
>&#13;            A Linux-rendszermag mûködésének megértéséhez ajánlott elolvasni az 
	    /usr/src/linux/Documentation könyvtárban lévõ kernel-docs.txt fájlt, 
	    amely az interneten megtalálható a 
            <A
HREF="http://www.dit.upm.es/~jmseyas/linux/kernel/hackers-docs.html"
TARGET="_top"
>&#13;              "http://www.dit.upm.es/~jmseyas/linux/kernel/hackers-docs.html" 
            </A
>
	    honlapon is. Ez számos fontos hivatkozást tartalmaz Linux-rendszermag tankönyvekre 
	    és dokumentációkra. El kell látogatni erre a webhelyre.
          </P
></LI
><LI
><P
>&#13;            Kernel book (Rendszermag könyv) a
            <A
HREF="http://kernelbook.sourceforge.net"
TARGET="_top"
>&#13;              "http://kernelbook.sourceforge.net" 
            </A
>
            és a 
            <A
HREF="http://sourceforge.net/projects/kernelbook"
TARGET="_top"
>&#13;              "http://sourceforge.net/projects/kernelbook" 
            </A
>
	    honlapon.
          </P
></LI
><LI
><P
>&#13;            A rendszermagról szóló könyvek, mint a "The Linux Kernel Module Programming 
            Guide", "Linux Kernel 2.4 Internals", "The Linux System 
            Administrators Guide", 'The Linux Network Administrator's Guide" 
            és mások megtalálhatók a 
            <A
HREF="http://www.tldp.org/guides.html"
TARGET="_top"
>&#13;              "http://www.tldp.org/guides.html" 
            </A
>
          honlapon.
	  </P
></LI
><LI
><P
>&#13;            FreeTech könyvek: 
            <A
HREF="http://www.tcfb.com/freetechbooks/booklinuxdev.html"
TARGET="_top"
>&#13;              "http://www.tcfb.com/freetechbooks/booklinuxdev.html" 
            </A
>
          </P
></LI
><LI
><P
>&#13;            Rusty-féle doksik: 
            <A
HREF="http://www.netfilter.org/unreliable-guides"
TARGET="_top"
>&#13;              "http://www.netfilter.org/unreliable-guides" 
            </A
>
          </P
></LI
><LI
><P
>&#13;            Linux-rendszermag hivatkozások: 
            <A
HREF="http://www.topology.org/soft/lkernel.html"
TARGET="_top"
>&#13;              "http://www.topology.org/soft/lkernel.html" 
            </A
>
          </P
></LI
><LI
><P
>&#13;            Linux Kernel Internals: 
            <A
HREF="http://www.moses.uklinux.net/patches/lki.html"
TARGET="_top"
>&#13;              "http://www.moses.uklinux.net/patches/lki.html" 
            </A
>
          </P
></LI
><LI
><P
>&#13;            Könyvekre mutató hivatkozások: 
            <A
HREF="http://linux-mm.org/kernel-links.shtml"
TARGET="_top"
>&#13;              "http://linux-mm.org/kernel-links.shtml" 
            </A
>
          </P
></LI
></UL
>
    </P
><P
>&#13;      A rendszermag készítésének bemutatása:
      Presentation of Kernel building process 
      <A
HREF="http://mike.passwall.com/nblug/kernel-talk"
TARGET="_top"
>&#13;        NBLUG Linux Seminars - Kernel Building Presentation Talks 
      </A
>
    </P
><P
>&#13;      Hivatkozások egyéb, a témába vágó HOGYANokra:
      <P
></P
><UL
><LI
><P
>&#13;            <A
HREF="http://www.tldp.org/HOWTO/Bootdisk-HOWTO/index.html"
TARGET="_top"
>&#13;              Bootdisk-HOWTO 
            </A
>
          (Linux indítólemez HOGYAN)
	  </P
></LI
><LI
><P
>&#13;            <A
HREF="http://www.tldp.org/HOWTO/Sound-HOWTO/index.html"
TARGET="_top"
>&#13;              Sound-HOWTO : 
            </A
>
            hangkártyák és segédprogramjaik 
          </P
></LI
><LI
><P
>&#13;            <A
HREF="http://www.tldp.org/HOWTO/SCSI-Generic-HOWTO/index.html"
TARGET="_top"
>&#13;              SCSI-HOWTO: 
            </A
>
            minden, amit tudni kell az SCSI vezérlõkrõl és eszközökrõl. Olvasd a 
            <A
HREF="http://www.tldp.org/HOWTO/SCSI-2.4-HOWTO/index.html"
TARGET="_top"
>&#13;              SCSI-2.4-HOWTO 
            </A
>
          doksiban.
	  </P
></LI
><LI
><P
>&#13;            <A
HREF="http://www.tldp.org/HOWTO/Net-HOWTO/index.html"
TARGET="_top"
>&#13;              NET-2-HOWTO: 
            </A
>
            hálózatkezelés 
          </P
></LI
><LI
><P
>&#13;            <A
HREF="http://www.tldp.org/HOWTO/PPP-HOWTO/index.html"
TARGET="_top"
>&#13;              PPP-HOWTO: 
            </A
>
            PPP hálózatkezelés általában 
          </P
></LI
><LI
><P
>&#13;            <A
HREF="http://www.tldp.org/HOWTO/PCMCIA-HOWTO.html"
TARGET="_top"
>&#13;              PCMCIA-HOWTO: 
            </A
>
            a notebook géped meghajtóiról 
          </P
></LI
><LI
><P
>&#13;            <A
HREF="http://www.doclib.org/Linux/docs/HOWTO/other-formats/html/ELF-HOWTO-html/ELF-HOWTO.html"
TARGET="_top"
>&#13;              ELF-HOWTO: 
            </A
>
            ELF: mi is ez, konvertálás... Tüköroldalak: 
            <A
HREF="http://cs.mipt.ru/docs/comp/eng/os/linux/howto/howto_english/elf/elf-howto.html"
TARGET="_top"
>&#13;              ELF-HOWTO-mirror 
            </A
>
            . Lásd még: 
            <A
HREF="http://www.tldp.org/HOWTO/GCC-HOWTO"
TARGET="_top"
>&#13;              GCC-HOWTO 
            </A
>
          </P
></LI
><LI
><P
>&#13;            <A
HREF="http://www.tldp.org/HOWTO/Hardware-HOWTO/index.html"
TARGET="_top"
>&#13;              Hardware-HOWTO: 
            </A
>
            a támogatott hardverek áttekintése 
          </P
></LI
><LI
><P
>&#13;            <A
HREF="http://tldp.org/HOWTO/mini/Modules/index.html"
TARGET="_top"
>&#13;              Module mini-HOWTO: 
            </A
>
            még több információ a rendszermag-modulokról 
          </P
></LI
><LI
><P
>&#13;            <A
HREF="http://tldp.org/HOWTO/mini/Kerneld/index.html"
TARGET="_top"
>&#13;              Kerneld mini-HOWTO: 
            </A
>
            a kerneld démonról 
          </P
></LI
><LI
><P
>&#13;            <A
HREF="http://tldp.org/HOWTO/mini/BogoMips.html"
TARGET="_top"
>&#13;              BogoMips mini-HOWTO: 
            </A
>
	    (
	    <A
HREF="http://tldp.fsf.hu/HOWTO/mini/BogoMips-hu.html"
TARGET="_top"
>&#13;              BogoMips mini-HOGYAN: 
            </A
>
	    )
            ha csak kíváncsi vagy.
          </P
></LI
></UL
>
    </P
></DIV
><DIV
CLASS="sect1"
><HR/><H2
CLASS="sect1"
><A
NAME="kernel_files_info"/>10. Információk a rendszermag fájljairól</H2
><P
>&#13;      Ez a rész "rövid áttekintést" és "bemutatást" tartalmaz a Linux-rendszermag 
      egyes részeirõl. Ha van idõd, olvasd el.
    </P
><P
>&#13;      Figyelmeztetés: nagyon elõvigyázatosnak kell lenned ezekkel a fájlokkal, 
      és nem szabad szerkeszteni vagy mozgatni/törölni/átnevezni õket.
    </P
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="vmlinuz"/>10.1. vmlinuz és vmlinux</H3
><P
>&#13;        A "vm" azt jelenti "Virtuális Memória" ("Virtual Memory"). A Linux
	támogatja a virtuális memória használatát, szemben az olyan 
	régi rendszerekkel mint a DOS. Annál a 640 kByte egy komoly 
	korlát volt. A Linux képes virtuális memóriaként használni a 
	merevlemezt, ezért "vm" a neve.	A vmlinuz a rendszermag végrehajtható 
	fájlja. Helye a /boot/vmlinuz könyvtár. Ez lehet egy szimbolikus 
	hivatkozás valamire, például /boot/vmlinuz-2.4.18-19.8.0.
	A "make zImage" parancs készíti el a vmlinuz fájlt, és 
	a "cp /usr/src/linux/arch/i386/linux/boot/zImage 
        /boot/vmlinuz" paranccsal rakhatod a helyére. A vmlinuz a 
	vmlinux tömörített változata. A zImage ezért visszamenõleg 
	kompatibilis (a kisebb rendszermagok esetében). Megjegyzendõ, hogy a 
	közeljövõben megszûnhet a zImage, és elõnyben részesül a 
	"make bzImage" (big zImage; nagy zImage). A zImage (vmlinuz) 
	nem csak egy tömörített fájl, de van benne egy beépített 
	gzip-kicsomagoló is (a fájl elejében). Tehát nem lehet 
	használni a gzip -dc és gunzip parancsokat a vmlinuz 
	kicsomagolására.
      </P
><P
>&#13;        A zImage és a bzImage egyaránt tömörített a gzip programmal. A 
	rendszermagban van egy mini-gunzip, ami a rendszermag kicsomagolására 
	és indítására szolgál. A különbség az, hogy a régi zImage az 
	alsó memóriába (az elsõ 640 kByte-ra), míg a bzImage a rendszermagot 
	a felsõ memóriába csomagolja ki (1 MByte fölé).
      </P
><P
>&#13;        A vmlinux a tömörítetlen rendszermag-fájl, a vmlinuz a tömörített, 
	amit betölthetõvé tettek. (Figyeld meg, hogy mindkét név hasonlóan 
	néz ki, kivéve az utolsó z betût). Általában nem kell törõdnöd a 
	vmlinux fájllal, ez csak egy közbensõ lépés.
      </P
><P
>&#13;        A rendszermag általában egy bzImage fájlt készít, eltárolja az 
	arch/i386/boot könyvtárban, és a felhasználónak kell átmásolni azt a 
	/boot könyvtárba, majd beállítani a GRUB vagy a LILO rendszerbetöltõt. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="bootload"/>10.2. Rendszerbetöltõ (bootloader) fájlok</H3
><P
>&#13;        A .b fájlok a rendszerbetöltõ fájlok. Ezek szükségesek a 
	rendszermag memóriába való betöltéséhez. Lehetõleg 
	NE bántsd õket.
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	ls -l /boot/*.b
	-rw-r--r--    1 root     root         5824 Sep  5  2002 /boot/boot.b
	-rw-r--r--    1 root     root          612 Sep  5  2002 /boot/chain.b
	-rw-r--r--    1 root     root          640 Sep  5  2002 /boot/os2_d.b
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN607"/>10.3. Üzenetfájl (message file)</H3
><P
>&#13;        A "message" fájl tartalmazza a bootloader által megjeleníthetõ üzenetet, 
	ami az operációs rendszer kiválasztására szólít fel. Ezért NE nyúlj hozzá.
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	ls -l /boot/message*
	-rw-r--r--    1 root     root        23108 Sep  6  2002 /boot/message
	-rw-r--r--    1 root     root        21282 Sep  6  2002 /boot/message.ja
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="initrdimg"/>10.4. initrd.img</H3
><P
>&#13;        Részletesen az 
	<A
HREF="#create_initrd"
TARGET="_top"
>"A" függelék - initrd.img fájl készítése</A
> 
	fejezetben olvashatsz errõl. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="bzimagelbl"/>10.5. bzImage</H3
><P
>&#13;        A bzImage a "make bzImage" parancs által készített tömörített rendszermag-fájl, 
	ami a fordítás során jött létre. Fontos megjegyezni, hogy a bzImage 
	nincs tömörítve a 
        <EM
>&#13;          bzip2 
        </EM
>
        programmal!! A bz a bzImage nevében félrevezetõ!! A valódi jelentése 
	"Big Zimage". A "b" jelentése a bzImage szóban "big". A zImage és 
	a bzImage egyaránt a gzip metódusával van tömörítve. A rendszermagban 
	van egy mini-gunzip, ami a rendszermag kicsomagolására 
	és indítására szolgál. A különbség az, hogy a régi zImage az alsó 
	memóriába (az elsõ 640 kByte-ra), míg a bzImage a rendszermagot 
	a felsõ memóriába csomagolja ki (1 MByte fölé). Az egyetlen ismert 
	probléma az lehet, hogy néhány gépen nem mûködik a bzImage 
	(mert a gép bugyuta). A bzImage jelenleg gyorsabban elindul mint a 
	zImage, de nincs különbség a rendszer *futásának* sebességében. A szabály az, 
	ha az összes meghajtóprogram (driver) nem fér bele a zImage fájlba, 
	akkor moduláris rendszermagra van szükség.
      </P
><P
>&#13;        Ha a rendszermag kicsi a zImage és bzImage is használható, 
	az elindított rendszer ugyanúgy fut. A nagy rendszermag mint 
	bzImage fog futni, nem mint egy zImage. Mindkét rendszerfájl 
	a gzip metódussal tömörített (a bzImage nem a bzip metódussal 
	van tömörítve, mint azt a neve sugallja), de különbözõ módon 
	töltõdnek be a memóriába. A rendszermag a felsõ memóriaterületre 
	is betölthetõ, így nem korlátozza a memóriaméret a gyagya intel 
	architektúrán. Miért létezik két módszer? Néhány régebbi lilo és 
	loadlin rendszerbetöltõ nem kezeli a bzImage formátumot. 
	Megjegyzendõ, hogy a *betöltés* különbözõ, de a *futás* azonos. 
	Sok tévinformáció származott abból, hogy mi is a bzImage fájl 
	(a legtöbb szerint bzip2 metódussal tömörített fájl).
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="moduleinfo"/>10.6. module-info</H3
><P
>&#13;        A "module-info" fájl egy szimbolikus hivatkozás: 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	$ uname -r
	2.4.18-19.8.0custom
	  
	# ls -l /boot/module-info*
	lrwxrwxrwx    1 root     root           25 Jan 26 10:44 /boot/module-info -&gt; module-info-2.4.18-19.8.0
	-rw-r--r--    1 root     root        15436 Sep  4  2002 /boot/module-info-2.4.18-14
	-rw-r--r--    1 root     root        15436 Jan 26 01:29 /boot/module-info-2.4.18-19.8.0
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
><P
>&#13;        A fentiekhez hozzátéve megjegyzendõ, hogy nem kötelezõ module-info 
	szimbolikus hivatkozást készíteni egy rendszermaghoz kapcsolódó 
	fájlhoz, mint amilyen a System-map és vmlinuz fájlokhoz szükséges. 
	Ez csak egy szöveges fájl, amely akkora, mint az aktuális module-info 
	lista. Mielõtt eltávolítanád az összes RH rendszermaghoz szükséges 
	"alapanyagot" a rendszeredrõl, készítened kellene egy mentést errõl 
	a fájlról: 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;# cp /boot/module-info-2.4.20-19.9 /boot/module-info-2.4.20-19.9.backup 
        </PRE
></FONT
></TD
></TR
></TABLE
>
        Ezt biztonságosabb a module-info fájlal megtenni, ritkán változnak 
	ugyanazon RH rendszermagok változatán belül.
      </P
><P
>&#13;        Ez a "module-info" fájl az anaconda/utils/modlist (speciális RedHat Linux 
	Anaconda telepítõhöz) programmal készült. Egyéb Linux összeállításokban 
	létezhet ennek megfelelõ parancs. Tájékozódj a Linux disztribútorod 
	kézikönyv oldalaiból.
      </P
><P
>&#13;        Nézd meg a szkriptet és keress rá a "module-info" szóra
	<A
HREF="http://www.mit.edu/afs/sipb/system/rhlinux/redhat-6.2/misc/src/trees/updmodules"
TARGET="_top"
>&#13;          updmodules 
        </A
>
        . 
      </P
><P
>&#13;        Következik egy részlet a szkriptbõl:
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	#!/bin/bash
	# updmodules.sh
		MODLIST=$PWD/../anaconda/utils/modlist
		MODINFO=$KERNELROOT/boot/module-info-$version
	-- kivágás
	bla-bla-bla 
	-- kivágás
	    # module-info fajl elkeszitese
	    $MODLIST --modinfo-file $MODINFO --ignore-missing --modinfo \
			$(ls *.o | sed 's/\.o$//') &gt; ../modinfo
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
><P
>&#13;        Az anaconda/utils/modlist program az anaconda-runtime*.rpm csomagban van a 
	RedHat CD-ROM-on:
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	cd /mnt/cdrom/RedHat/RPMS
	rpm -i anaconda-8.0-4.i386.rpm
	rpm -i anaconda-runtime-8.0-4.i386.rpm
	ls -l /usr/lib/anaconda-runtime/modlist
        </PRE
></FONT
></TD
></TR
></TABLE
>
        Beszerezheted a forráskódját (anaconda/utils/modlist.c) az 
        anaconda*.src.rpm-bõl a 
        <A
HREF="http://www.rpmfind.net/linux/rpm2html/search.php?query=anaconda"
TARGET="_top"
>&#13;          "http://www.rpmfind.net/linux/rpm2html/search.php?query=anaconda" 
        </A
>
        webhelyrõl. Egybõl olvashatod is:
        <A
HREF="http://www.trustix.net/pub/Trustix/trustix-1.5/i586/misc/src/anaconda/utils/modlist.c"
TARGET="_top"
>&#13;          modlist.c 
        </A
>
        . 
      </P
><P
>&#13;        A "module-info" a fordítás során készül el. Ez egy információs fájl, amit 
	legalábbis akkor használnak, mialatt kitöltésre kerülnek a rendszermag 
	megfelelõ Oops jelentései. Ez egy lista a modulok belépési pontjairól. 
	Ezen kívül a depmod is használja azon táblák felépítésénél, amiket az 
	insmod és rokonsága használ. Függõségi információkat tartalmaz azokról a 
	modulokról, amiket egy adott modul elõtt be kell tölteni stb. 
      </P
><P
>&#13;        A lényeg az, hogy "Ne távolítsd el a module-info fájlt."
      </P
><P
>&#13;        Néhány információ a module-info fájlról:
        <P
></P
><UL
><LI
><P
>&#13;              A rendszermag rpm fájlok tartalmazzák (az anaconda-runtime*.rpm építi fel)
            </P
></LI
><LI
><P
>&#13;              Egy hivatkozás a module-info-{kernel-version} fájlhoz
            </P
></LI
><LI
><P
>&#13;              Az összes hozzáférhetõ modulról tartalmaz információt (legalábbis azokról, 
	      amik benne vannak az alapértelmezett rendszermag beállításban).
            </P
></LI
><LI
><P
>&#13;              Fontos az anaconda számára - az anaconda/utils/modlist parancsban.
            </P
></LI
><LI
><P
>&#13;              A kudzu is használhatja, hogy felderítse a modulok alapértelmezett 
	      paramétereit, amikor elkészíti a bejegyzéseket az /etc/modules.conf
	      fájlban. Ha használaton kívül helyezed a module-info fájlt, 
	      leállítod a gépet, beraksz egy új hálózati kártyát és újraindítasz, 
	      a kudzu hangosan reklamálni fog. Nézd meg a kudzu forráskódját.
            </P
></LI
></UL
>
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="configfiles"/>10.7. config</H3
><P
>&#13;        Minden alkalommal, ha új rendszermagot fordítasz és telepíted a 
	rendszermag-fájlt a /boot könyvtárba, a megfelelõ beállítófájlt 
	szintén át kell másolnod a /boot könyvtárba, dokumentációs célból 
	és késõbbi hivatkozás miatt. Ezeket a fájlokat NE változtasd vagy 
	szerkeszd!
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	ls -l /boot/config-*
	-rw-r--r--    1 root     root        42111 Sep  4  2002 /boot/config-2.4.18-14
	-rw-r--r--    1 root     root        42328 Jan 26 01:29 /boot/config-2.4.18-19.8.0
	-rw-r--r--    1 root     root        51426 Jan 25 22:21 /boot/config-2.4.18-19.8.0BOOT
	-rw-r--r--    1 root     root        52328 Jan 28 03:22 /boot/config-2.4.18-19.8.0-26mar2003
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="grubdir"/>10.8. grub</H3
><P
>&#13;        Ha a GRUB rendszerbetöltõt használod, akkor lesz ott egy "grub" könyvtár is.
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	ls /boot/grub
	device.map     ffs_stage1_5  menu.lst        reiserfs_stage1_5  stage2
	e2fs_stage1_5  grub.conf     minix_stage1_5  splash.xpm.gz      vstafs_stage1_5
	fat_stage1_5   jfs_stage1_5  stage1          xfs_stage1_5
        </PRE
></FONT
></TD
></TR
></TABLE
>
        Részletesen a
        <A
HREF="#grubconf"
TARGET="_top"
>"C" függelék - GRUB részletesen, grub.conf mintafájl</A
>
	fejezetben olvashatsz errõl. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="systemmap"/>10.9. System.map</H3
><P
>&#13;        A System.map egy "telefonkönyv-szerû" függvénylistája egy bizonyos lefordított
	rendszermagnak. Tipikusan egy szimbolikus hivatkozás az éppen futó rendszermag 
	System.map fájljára. Ha rossz (vagy semmilyen) System.map fájlt használsz, 
	az összeomlások nyomon követése nehezebb, de más hatása nincs. A System.map 
	nélkül kisebb zavaró üzenetekkel kell szembesülnöd.
      </P
><P
>&#13;        NE bántsd a System.map fájlokat.
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	ls -ld /boot/System.map*
	lrwxrwxrwx    1 root     root           30 Jan 26 19:26 /boot/System.map -&gt; System.map-2.4.18-19.8.0custom
	-rw-r--r--    1 root     root       501166 Sep  4  2002 /boot/System.map-2.4.18-14
	-rw-r--r--    1 root     root       510786 Jan 26 01:29 /boot/System.map-2.4.18-19.8.0
	-rw-r--r--    1 root     root       331213 Jan 25 22:21 /boot/System.map-2.4.18-19.8.0BOOT
	-rw-r--r--    1 root     root       503246 Jan 26 19:26 /boot/System.map-2.4.18-19.8.0custom
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
><P
>&#13;        <EM
>&#13;          Hogyan készül a rendszermag szimbólumtáblája (Kernel Symbol Table)?
        </EM
>
        A System.map fájlt az "nm vmlinux" készíti el, és a nem fontos vagy 
	érdeklõdésre számot nem tartó szimbólumokat kiszedi a grep. Amikor 
	lefordítod a rendszermagot, a System.map fájl az /usr/src/linux/System.map
	fájlba kerül. Valahogy így:
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	nm /boot/vmlinux-2.4.18-19.8.0 &gt; System.map
	# Ez egy sor az /usr/src/linux/Makefile fájlból 
	nm vmlinux | grep -v '\(compiled\)\|\(\.o$$\)\|\( [aUw] \)\|\(\.\.ng$$\)\|\(LASH[RL]DI\)' | sort &gt; System.map
	cp /usr/src/linux/System.map /boot/System.map-2.4.18-14   # For v2.4.18
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
><P
>&#13;        Forrás: 
        <A
HREF="http://www.dirac.org/linux/systemmap.html"
TARGET="_top"
>&#13;          "http://www.dirac.org/linux/systemmap.html" 
        </A
>
      </P
><DIV
CLASS="sect3"
><HR/><H4
CLASS="sect3"
><A
NAME="AEN668"/>10.9.1. System.map</H4
><P
>&#13;          Úgy néz ki, hogy információhiány van a System.map fájlról. Tényleg semmi 
	  rendkívüli nincs benne, és a dolgok állása szerint tényleg nem olyan fontos. 
	  De az információ hiánya homályossá teszi. Olyan, mint a fülcimpa: mindenkinek 
	  van, de senki sem tudja igazán, miért. Ez egy kis weboldal, amit a "miért" 
	  leírására hoztam össze.
        </P
><P
>&#13;          Megjegyzem, nem vagyok 100%-ig korrekt. Példának okáért lehetséges, 
	  hogy egy rendszerben nincs /proc fájlrendszer támogatás, de a legtöbben 
	  van. Feltételezem, hogy "úszol az árral" és egy meglehetõsen tipikus 
	  rendszered van.
        </P
><P
>&#13;          A dolgok egy része az Oops-okról az Alessandro Rubini-féle "Linux 
          Device Drivers" (Linux meghajtóprogramok) leírásból származik, 
	  amibõl a legtöbbet tanultam a rendszermag programozásáról.
        </P
></DIV
><DIV
CLASS="sect3"
><HR/><H4
CLASS="sect3"
><A
NAME="AEN673"/>10.9.2. Mik a szimbólumok?</H4
><P
>&#13;          Programozási környezetben a szimbólum a program építõeleme: változónév vagy 
	  függvénynév. Nem meglepetés, hogy a rendszermagnak is vannak szimbólumai, 
	  ugyanúgy, mint az általad írt programoknak. A különbség persze ott van, 
	  hogy a rendszermag nagyon bonyolult darab kódolási szempontból, és sok-sok 
	  globális szimbóluma van.
        </P
></DIV
><DIV
CLASS="sect3"
><HR/><H4
CLASS="sect3"
><A
NAME="AEN676"/>10.9.3. Mi a rendszermag szimbólumtáblája (Kernel Symbol Table)?</H4
><P
>&#13;          A rendszermag nem használ szimbólumneveket. Sokkal jobban szereti tudni a 
	  változó vagy függvény nevét azok címei által. Ahelyett, hogy a size_t 
	  BytesRead formát használná, elõnyben részesíti azt, ha erre a változóra 
	  (példának okáért) c0343f20 formában hivatkozhat.
        </P
><P
>&#13;          Másrészrõl, az emberek nem szeretik a c0343f20 kinézetû neveket. 
	  Jobban kedveljük azt, hogy size_t BytesRead. Normál esetben ez nem 
	  jelent problémát. A rendszermagot fõleg C nyelven írták, ezért a 
	  fordító/szerkesztõ megengedi, hogy szimbólumneveket használjunk 
	  kódolás közben, a rendszermagnak pedig engedi, hogy címeket használjon 
	  futás közben. Mindenki boldog lehet.
        </P
><P
>&#13;          Azonban vannak olyan szituációk, amikor tudnunk kell egy szimbólum címét 
	  (vagy egy címhez tartozó szimbólumot). Ez a szimbólumtábla által valósul 
	  meg, és nagyon hasonló ahhoz, ahogy a gdb (GNU debugger - a ford.) 
	  visszaadja a függvényneveket egy címrõl (vagy egy címet a függvénynévbõl). 
	  A szimbólumtábla egy lista az összes szimbólumról, a címeikkel együtt. 
	  Íme egy példa:
        </P
><P
>&#13;          <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	   c03441a0 B dmi_broken
	   c03441a4 B is_sony_vaio_laptop
	   c03441c0 b dmi_ident
	   c0344200 b pci_bios_present
	   c0344204 b pirq_table
	   c0344208 b pirq_router
	   c034420c b pirq_router_dev
	   c0344220 b ascii_buffer
	   c0344224 b ascii_buf_bytes
          </PRE
></FONT
></TD
></TR
></TABLE
>
        </P
><P
>&#13;          Látható, hogy a dmi_broken nevû változó a c03441a0 
	  rendszermag-címen van.
        </P
></DIV
><DIV
CLASS="sect3"
><HR/><H4
CLASS="sect3"
><A
NAME="AEN684"/>10.9.4. Mi is a System.map fájl?</H4
><P
>&#13;          Két fájl használatos szimbólumtáblaként:
          <P
></P
><OL
TYPE="1"
><LI
><P
>&#13;                /proc/ksyms 
              </P
></LI
><LI
><P
>&#13;                System.map 
              </P
></LI
></OL
>
        </P
><P
>&#13;          Na mármost. Már tudod, mi is a System.map fájl.
        </P
><P
>&#13;          Minden alkalommal, ha új rendszermagot fordítasz, a különbözõ szimbólumnevek 
	  címei megváltoznak.
        </P
><P
>&#13;          A /proc/ksyms egy "folyamatfájl" és a rendszermag indulásakor 
	  menet közben készül el. Valójában ez nem fájl: egyszerûen a 
	  rendszermag adatainak megjelenítése, ami azt az illúziót adja, 
	  mintha lemezn lévõ fájl lenne. Ha nem hiszel nekem, próbáld megállapítani 
	  a /proc/ksyms fájl méretét. Ezért mindig az aktuálisan futó 
	  rendszermaghoz képest lesz korrekt.
        </P
><P
>&#13;          A System.map azonban egy létezõ fájl a fájlrendszeredben. Amikor 
	  új rendszermagot fordítasz, ennek régi verziója rossz szimbólum-információkat 
	  tartalmaz. Egy új verzió készül minden egyes új fordításkor, 
	  és ki kell cserélned a régit az újjal.
        </P
></DIV
><DIV
CLASS="sect3"
><HR/><H4
CLASS="sect3"
><A
NAME="AEN696"/>10.9.5. Mi az Oops?</H4
><P
>&#13;          Mi a leggyakoribb hiba a házilag készült programjaiddal? 
	  A szegmentációs hiba (segfault). A jó öreg signal 11.
        </P
><P
>&#13;          Mi a Linux-rendszermag leggyakoribb hibája? A segfault. Itt azonban a 
	  segfault fogalma sokkal összetettebb, és ahogy az várható 
	  sokkal komolyabb. Amikor a rendszermag egy hibás mutatóra hivatkozik, 
	  azt nem segfault-nak hívjuk - ezt hívják "oops"-nak. Egy ilyen 
	  oops rendszermag-hibát jelez, mindig jelenteni és javítani kell.
        </P
><P
>&#13;          Figyeld meg, hogy az oops nem ugyanaz a dolog, mint a segfault. 
	  A programod nem tud kijönni egy segfault-ból. A rendszermag viszont 
	  nem szükségszerûen kerül instabil állapotba, ha egy oops fordul elõ. 
	  A rendszermag nagyon robusztus; az oops csak az aktuális folyamatot 
	  öli meg, a rendszermag többi részét megfelelõen jó állapotban hagyhatja.
        </P
><P
>&#13;          Az oops nem egyenlõ a rendszermag pánikkal (kernel panic). Pánik alkalmával 
	  a rendszermag nem tud tovább futni; a rendszer halt állapotba zuhan és 
	  újra kell indítani. Egy oops akkor okozhat pánikot, ha a rendszer egy 
	  életfontosságú része semmisül meg. Egy oops valamely eszközvezérlõben 
	  például majdnem sosem okoz pánikot.
        </P
><P
>&#13;          Amikor egy oops elõfordul, a rendszer a hibakereséshez elengedhetetlen 
	  információt nyomtat ki, mint például a CPU összes regiszterének tartalmát 
	  és az oldalleíró táblák (page descriptor tables) helyét. Fõleg az EIP 
	  (utasítás mutató) tartalma íródik ki. Mint ez itt:
          <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	   EIP: 0010:[&lt;00000000&gt;]
	   Call Trace: [&lt;c010b860&gt;]
          </PRE
></FONT
></TD
></TR
></TABLE
>
        </P
></DIV
><DIV
CLASS="sect3"
><HR/><H4
CLASS="sect3"
><A
NAME="AEN704"/>10.9.6. Mit köze egy oops-nak a System.map fájlhoz?</H4
><P
>&#13;          Egyetérthetsz azzal, hogy az EIP-ben adott információ és a nyomkövetési 
	  adatok nem valami információgazdagok. Ennél is fontosabb, hogy még a 
	  rendszermag fejlesztõinek sem azok. Mivel a szimbólumnak nincs fix címe, 
	  a c010b860 mutathat bárhova.
        </P
><P
>&#13;          Ahhoz, hogy használhassuk ezeket a titkosított oops-kimeneteket, 
	  a Linux egy klogd nevû démont használ, a rendszermag naplózó démont. 
	  A klogd elfogja a rendszermag oops-ait és a syslog segítségével 
	  naplózza, kicserélve néhány haszontalan információt, mint a c010b860 
	  olyanra, amit ember is tud használni. Más szóval, a klogd egy rendszermag-üzenet 
	  naplózó, ami név-cím feloldást tud végezni. Amint átalakítja a rendszermag 
	  üzeneteit, egy olyan naplózót használ, ami a rendszerszintû üzeneteket tudja 
	  naplózni, általában a syslogd démont.
        </P
><P
>&#13;          A név-cím feloldáshoz a klogd a System.map fájlt használja. 
	  Most már tudod, mi az oops és mi köze a System.map fájlhoz.
        </P
><P
>&#13;          <EM
>&#13;            Megjegyzések: 
          </EM
>
          Jelenleg kétféle címfeloldást végez a klogd.
        </P
><P
>&#13;          <P
></P
><UL
><LI
><P
>&#13;                Statikus fordítást, ami használja a System.map fájlt.
              </P
></LI
><LI
><P
>&#13;                A dinamikus fordítást, amit a betölthetõ modulokkal használnak, 
		nem használja 
              </P
></LI
></UL
>
        </P
><P
>&#13;          a System.map fájlt, ezért nem fontos ennek tárgyalásánál, 
	  de azért röviden ismertetem.
        </P
><P
>&#13;          <EM
>&#13;            A klogd dinamikus fordítása 
          </EM
>
        </P
><P
>&#13;          Tegyük fel, hogy betöltöttél egy rendszermag-modult, ami oops-ot 
	  idézett elõ. Egy oops üzenet készült és a klogd elfogta. Azt találta, 
	  hogy az oops a d00cf810-nál fordult elõ. Mivel ez a cím egy dinamikusan 
	  betöltött modulhoz tartozik, nincs bejegyzés hozzá a System.map fájlban. 
	  A klogd keresi, de nem talál semmit így arra következtet, hogy egy 
	  betölthetõ modul  generálta az üzenetet. A klogd ezután lekérdezi a 
	  rendszermagot olyan szimbólumokért, amiket a betölthetõ modulok 
	  exportáltak. Még ha a modul szerzõje nem exportálta is a szimbólumokat, 
	  legalább a klogd tudni fogja, melyik modul idézte elõ az oops-ot, ami 
	  jobb, mint semmit sem tudni az oops-ról.
        </P
><P
>&#13;          Más programok is használják a System.map fájlt és rövidesen ezzel is 
	  foglalkozom.
        </P
></DIV
><DIV
CLASS="sect3"
><HR/><H4
CLASS="sect3"
><A
NAME="AEN722"/>10.9.7. Hol kellene lennie a System.map fájlnak?</H4
><P
>&#13;          A System.map bárhol lehet, ahol az õt használó szoftverek keresik. 
	  Most beszéljünk arról, hogy a klogd hol keresi. 
	  Az induláskor, ha a klogd nem kapta meg argumentumként a System.map 
	  helyét, akkor három helyen keresi a következõ sorrendben:
          <P
></P
><OL
TYPE="1"
><LI
><P
>&#13;                /boot/System.map 
              </P
></LI
><LI
><P
>&#13;                /System.map 
              </P
></LI
><LI
><P
>&#13;                /usr/src/linux/System.map 
              </P
></LI
></OL
>
        </P
><P
>&#13;          A System.map ezenkívül verzió-információkat is tartalmaz, és a 
	  klogd intelligens módon a megfelelõ map (térkép)fájlt keresi meg. 
	  Például, ha a 2.4.18-as rendszermagot futtatod és a 
	  hozzá társított fájl a /boot/System.map. Most fordítasz egy új 
	  2.5.1-es rendszermagot az /usr/src/linux fán belül. A fordítási 
	  folyamat közben elkészül az /usr/src/linux/System.map fájl. Amikor 
	  elindítod az új rendszermagot, a klogd elõször megnézi a /boot/System.map-et, 
	  megállapítja, hogy ez nem a futó rendszermagnak megfelelõ térképfájl, 
	  ezután megnézi az /usr/src/linux/System.map-et, megállapítja, hogy 
	  ez a megfelelõ, és elkezdi olvasni a szimbólumokat.
        </P
><P
>&#13;          Néhány megjegyzés: 
        </P
><P
>&#13;          <P
></P
><UL
><LI
><P
>&#13;                Valahol a 2.5.x szérián belül, a Linux-rendszermag elkezdett 
		Linux-verziószám formában kicsomagolódni a tar archívumból, 
		a sima linux helyett (kezeket fel: hányan vártuk már, hogy 
		ez megtörténjen?) Nem tudom, hogy a klogd démont módosították-e 
		már úgy, hogy az /usr/src/linux-verzió/System.map fájlt keresse. 
		TENNIVALÓ: nézd meg a klogd forrását. ?? FIXME ?? Ha valaki megver is ezért, 
		kérlek küldj e-mailt, és tudasd, hogy módosították-e a klogd-t 
		úgy, hogy a forráskód új nevû könyvtárában keressen. ??FIXME??
              </P
></LI
><LI
><P
>&#13;                A kézikönyv oldal nem ír le mindent. Nézd meg ezt:
              </P
></LI
></UL
>
        </P
><P
>&#13;          <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	   # strace -f /sbin/klogd | grep 'System.map'
	   31208 open("/boot/System.map-2.4.18", O_RDONLY|O_LARGEFILE) = 2
          </PRE
></FONT
></TD
></TR
></TABLE
>
        </P
><P
>&#13;          Kétségtelen, hogy a klogd nemcsak a 3 keresési könyvtárban nézi meg 
	  a térképfájl megfelelõ verzióját, de tudja azt is, hogy a "System.map" 
	  nevet követõ "-kernelverzó"-t nézze, mint a System.map-2.4.18. Ez a 
	  klogd egy nem dokumentált képessége.
        </P
><P
>&#13;          Néhány meghajtónak szüksége van a System.map-re a szombólumok feloldásához 
	  (mivel a rendszermag fejlécfájljaihoz lettek linkelve, és nem mondjuk a 
	  glibc-éihez). Ezek nem fognak jól mûködni a futó rendszermaghoz készült 
	  megfelelõ System.map fájl nélkül. Ez NEM ugyanaz a dolog, mint hogy egy 
	  modul nem töltõdik be a rendszermag verziószámának eltérése miatt. Ezt a 
	  rendszermag-verzió jelzésével kell megoldani, nem a szimbólumtáblával, 
	  ami változik az ugyanolyan verziójú rendszermagokon belül is!
        </P
></DIV
><DIV
CLASS="sect3"
><HR/><H4
CLASS="sect3"
><A
NAME="AEN744"/>10.9.8. Mi használja még a System.map fájlt?</H4
><P
>&#13;          Ne gondold, hogy a System.map csak a rendszermag oops-ok számára 
	  hasznos. Bár a rendszermag maga nem igazán használja, más programok, 
	  mint a klogd, az lsof,
        </P
><P
>&#13;          <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	   satan# strace lsof 2&gt;&amp;1 1&gt; /dev/null | grep System
	   readlink("/proc/22711/fd/4", "/boot/System.map-2.4.18", 4095) = 23
          </PRE
></FONT
></TD
></TR
></TABLE
>
        </P
><P
>&#13;          és a ps : 
        </P
><P
>&#13;          <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	   satan# strace ps 2&gt;&amp;1 1&gt; /dev/null | grep System
	   open("/boot/System.map-2.4.18", O_RDONLY|O_NONBLOCK|O_NOCTTY) = 6
          </PRE
></FONT
></TD
></TR
></TABLE
>
        </P
><P
>&#13;          valamint számos egyéb szoftver is, mint a dosemu igényli a megfelelõ 
	  System.map-et.
        </P
></DIV
><DIV
CLASS="sect3"
><HR/><H4
CLASS="sect3"
><A
NAME="AEN753"/>10.9.9. Mi történik, ha nem megfelelõ System.map fájlom van?</H4
><P
>&#13;          Tegyük fel, hogy több rendszermagod van ugyanazon a gépen. Minden 
	  egyes rendszermaghoz más-más System.map-re van szükség! Ha olyan 
	  rendszermagot indítasz, amihez nem tartozik System.map, rendszeresen 
	  látsz majd olyan üzeneteket, hogy: System.map does not match actual 
	  kernel (A System.map nem felel meg az aktuális rendszermagnak). Nem 
	  végzetes hiba, de bosszantó lehet mindig ezt látni, ha kiadsz egy 
	  "ps ax" parancsot. Néhány program, mint a dosemu, lehet, hogy nem mûködik 
	  megfelelõen (bár nem tudok semmi biztosat errõl). Végül, a klogd vagy 
	  a ksymoops kimenete nem lesz megbízható egy rendszermag oops esetén. 
	  Olvasd el a kézikönyv oldalakat, a "man ksymoops" és "man klogd" 
	  parancsok kiadása után.
        </P
></DIV
><DIV
CLASS="sect3"
><HR/><H4
CLASS="sect3"
><A
NAME="AEN756"/>10.9.10. Hogyan orvosoljam a fenti szituációt?</H4
><P
>&#13;          A megoldás, hogy az összes System.map fájlt a /boot-ban tárolod 
	  és átnevezed a rendszermag verziószámára. Tegyük fel hogy több 
	  rendszermagod van, mint:
        </P
><P
>&#13;          <P
></P
><UL
><LI
><P
>&#13;                /boot/vmlinuz-2.2.14 
              </P
></LI
><LI
><P
>&#13;                /boot/vmlinuz-2.2.13 
              </P
></LI
></UL
>
        </P
><P
>&#13;          Ezután csak nevezd át a térképfájlokat a rendszermag verziójának 
	  megfelelõen és rakd õket a /boot könyvtárba:
          <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	   /boot/System.map-2.2.14
	   /boot/System.map-2.2.13
          </PRE
></FONT
></TD
></TR
></TABLE
>
        </P
><P
>&#13;          Mi van, ha két másolatod van ugyanabból a rendszermagból? Mint itt:
          <P
></P
><UL
><LI
><P
>&#13;                /boot/vmlinuz-2.2.14 
              </P
></LI
><LI
><P
>&#13;                /boot/vmlinuz-2.2.14.nosound 
              </P
></LI
></UL
>
        </P
><P
>&#13;          A legjobb válasz az lehet, ha az összes szoftver a következõ fájlokat 
	  nézi meg:
          <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	   /boot/System.map-2.2.14
	   /boot/System.map-2.2.14.nosound
          </PRE
></FONT
></TD
></TR
></TABLE
>
        </P
><P
>&#13;          Használhatsz szimbolikus hivatkozásokat is:
          <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	   System.map-2.2.14
	   System.map-2.2.14.sound
	   ln -s System.map-2.2.14.sound System.map     # Itt System.map -&gt; System.map-2.2.14.sound
          </PRE
></FONT
></TD
></TR
></TABLE
>
        </P
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR/><H2
CLASS="sect1"
><A
NAME="linux_admin_tools"/>11. Linux rendszer-adminisztrációs eszközök</H2
><P
>&#13;      Két igazán jó adminisztrációs eszköz létezik Linuxra, ezek a Linuxconf és a Webmin.
    </P
><P
>&#13;      Linux rendszer-adminisztrációs eszközök: 
      <P
></P
><UL
><LI
><P
>&#13;            A Linuxconf megtalálható a 
            <A
HREF="http://www.solucorp.qc.ca/linuxconf"
TARGET="_top"
>&#13;              http://www.solucorp.qc.ca/linuxconf 
            </A
> 
	    webhelyen. A Linuxconf egy különösen nagy projekt. A program félelmetesen jól 
	    használható, sok beállítási lehetõség van benne. A Linuxconf a 
	    LEGISMERTEBB rendszer-adminisztrációs eszköz Linuxra. Ez az összes 
	    disztribúcióban megtalálható, mint a Redhat, Debian, Suse stb. 
	    A Linuxconf egyenértékû a HPUX SAM, valamint az AIX SMITTY programjával. 
	    Egyaránt fut konzolon és az X-Window GUI felületén. Debian Linux 
	    esetén a letöltéshez és telepítéshez elég az "apt-get linuxconf". 
          </P
></LI
><LI
><P
>&#13;            A Webmin a legjobban használható és nagyon népszerû rendszer-adminisztrációs 
	    eszköz a Linuxhoz. Elég elterjedt és díjazott, mint legjobb rendszer-adminisztriciós 
	    eszköz Solaris BSD, Linux, HPUX, AIX, SCO és más rendszerekhez. A Webmin 
	    évrõl-évre szervezetek, konferenciák és szerkesztõk által odaítélt díjakat 
	    nyert az elmúlt 5 évben. A Webmin más rendszerek alatt is használható 
	    mint például AIX, Solaris, HPUX, IRIX, BSD, SCO Unix, OSF, Darwin, 
	    Apple Macintosh Mac OS X és Cygwin. Jelenleg a leginkább támogatott 
	    rendszerek a Solaris, Linux (különösen a Redhat) és FreeBSD. Perl nyelven 
	    írták, ez hordozható akárcsak a "C", de ellentétben azzal szkript-nyelv. 
	    A Perl "unokatestvére" a "C" nyelvnek. A legfõbb hátránya, hogy szüksége van 
	    az X-Window rendszerre, az Apache webszerver és a Perl telepítése 
	    és futtatása után használható a Webmin. Ezt a hézagot tömi be a Linuxconf, 
	    nincs szükség az X-Window vagy más program telepítésére a használatához. 
	    A Linuxconf akár egy buta karakteres terminálon is futhat az ncurses-al. 
	    A Webmin megtalálható a
            <A
HREF="               http://www.webmin.com "
TARGET="_top"
> http://www.webmin.com 
            </A
>
            webhelyen. Itt letölthetõ a Webmin csomag. 
          </P
></LI
><LI
><P
>&#13;            Google könyvtár 
            <A
HREF="               http://directory.google.com/Top/Computers/Software/Operating_Systems/Unix/Administration/                "
TARGET="_top"
> 
              http://directory.google.com/Top/Computers/Software/Operating_Systems/Unix/Administration/ 
            </A
>
          </P
></LI
><LI
><P
>&#13;            Íme a RedHat adminisztrációs eszközök listája: 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	# ls /usr/sbin/redhat-con*
	/usr/sbin/redhat-config-bind           /usr/sbin/redhat-config-packages
	/usr/sbin/redhat-config-bind-gui       /usr/sbin/redhat-config-printer
	/usr/sbin/redhat-config-kickstart      /usr/sbin/redhat-config-printer-gui
	/usr/sbin/redhat-config-network        /usr/sbin/redhat-config-printer-tui
	/usr/sbin/redhat-config-network-cmd    /usr/sbin/redhat-config-proc
	/usr/sbin/redhat-config-network-druid  /usr/sbin/redhat-config-services
	
	A program indításához -
	# /usr/sbin/redhat-config-bind &amp;
	# /usr/sbin/redhat-config-network &amp;
	  
	Majd próbálkozz más parancsokkal.
		</PRE
></FONT
></TD
></TR
></TABLE
>
          </P
></LI
><LI
><P
>&#13;            Vizuális valamint Samba segédprogramok és egyebek megtalálhatók a 
            <A
HREF="               http://www.ibiblio.org/pub/Linux/system/admin/frontends/!INDEX.html                "
TARGET="_top"
> 
              http://www.ibiblio.org/pub/Linux/system/admin/frontends/!INDEX.html 
            </A
>
            és 
            <A
HREF="               http://www.ibiblio.org/pub/Linux/system/admin/!INDEX.html "
TARGET="_top"
> 
              http://www.ibiblio.org/pub/Linux/system/admin/!INDEX.html 
            </A
>
	    honlapokon.
          </P
></LI
><LI
><P
>&#13;            Rendszer, hálózati és adminisztrációs segédprogramok találhatók a 
            <A
HREF="               http://gd.tuwien.ac.at/opsys/linux/applications/text1.html#sysad                "
TARGET="_top"
> 
              http://gd.tuwien.ac.at/opsys/linux/applications/text1.html#sysad 
            </A
>
	    honlapon.
          </P
></LI
><LI
><P
>&#13;            Képernyõ-alapú adminisztrációs segédprogramok a Linux Refresher webhelyrõl: 
            <A
HREF="               http://linuxrefresher.com/maintenance/admgui/guiconf.htm "
TARGET="_top"
> 
              http://linuxrefresher.com/maintenance/admgui/guiconf.htm 
            </A
>
          </P
></LI
><LI
><P
>&#13;            SuSE YAST adminisztrációs segédprogram, Redhat /usr/sbin/redhat-conf* és egyéb 
	    segédprogramok:
            <A
HREF="               http://freshmeat.net/browse/253/?topic_id=253 "
TARGET="_top"
> 
              http://freshmeat.net/browse/253/?topic_id=253 
            </A
>
            <A
HREF="               http://freshmeat.net/browse/201/?topic_id=201 "
TARGET="_top"
> 
              http://freshmeat.net/browse/201/?topic_id=201 
            </A
>
          </P
></LI
></UL
>
    </P
><P
>&#13;      Linux rendszer-adminisztrációval kapcsolatos felhasználói kézikönyvek:
      <P
></P
><UL
><LI
><P
>&#13;            <A
HREF="               http://tldp.org/guides.html "
TARGET="_top"
> http://tldp.org/guides.html 
            </A
>
          </P
></LI
><LI
><P
>&#13;            <A
HREF="               http://tldp.org/LDP/lame/LAME/linux-admin-made-easy/index.html                "
TARGET="_top"
> 
              http://tldp.org/LDP/lame/LAME/linux-admin-made-easy/index.html 
            </A
>
          </P
></LI
><LI
><P
>&#13;            <A
HREF="                http://tldp.org/LDP/nag2/index.html "
TARGET="_top"
> 
              http://tldp.org/LDP/nag2/index.html 
            </A
>
          </P
></LI
><LI
><P
>&#13;            Linux rendszer-adminisztrációval kapcsolatos gyakorlatok: 
            <A
HREF="               http://www.yolinux.com/TUTORIALS/LinuxTutorialSysAdmin.html "
TARGET="_top"
> 
              http://www.yolinux.com/TUTORIALS/LinuxTutorialSysAdmin.html 
            </A
>
          </P
></LI
><LI
><P
>&#13;            <A
HREF="               http://www-106.ibm.com/developerworks/views/linux/tutorials.jsp                "
TARGET="_top"
> IBM Linux gyakorlatok 
            </A
>
          </P
></LI
><LI
><P
>&#13;            <A
HREF="               http://tariqnazir.tripod.com/unix.html "
TARGET="_top"
> 
              http://tariqnazir.tripod.com/unix.html 
            </A
>
          </P
></LI
><LI
><P
>&#13;            <A
HREF="               http://www.unixtools.com "
TARGET="_top"
> http://www.unixtools.com 
            </A
>
          </P
></LI
></UL
>
    </P
><P
>&#13;      Rendszer-adminisztrációs 
      System Administration magazin: 
      <P
></P
><UL
><LI
><P
>&#13;            <A
HREF="               http://www.samag.com/ "
TARGET="_top"
> http://www.samag.com/ 
            </A
>
          </P
></LI
></UL
>
    </P
><P
>&#13;      Linux rendszer-adminisztrációs tanfolyamok: 
      <P
></P
><UL
><LI
><P
>&#13;            Online India, Pune: 
            <A
HREF="               http://www.nixcraft.com/services/education/redhat/ "
TARGET="_top"
> 
              http://www.nixcraft.com/services/education/redhat/ 
            </A
>
          </P
></LI
><LI
><P
>&#13;            Online UK : 
            <A
HREF="               http://www.firstalt.co.uk/courses/la2.html "
TARGET="_top"
> 
              http://www.firstalt.co.uk/courses/la2.html 
            </A
>
          </P
></LI
><LI
><P
>&#13;            Online UK : 
            <A
HREF="               http://training.gbdirect.co.uk/courses/linux/running_linux_in_the_enterprise.html                "
TARGET="_top"
> 
              http://training.gbdirect.co.uk/courses/linux/running_linux_in_the_enterprise.html 
            </A
>
          </P
></LI
><LI
><P
>&#13;            Online USA : 
            <A
HREF="               http://www.sgi.com/support/custeducation/courses/linux/sys_admin.html                "
TARGET="_top"
> 
              http://www.sgi.com/support/custeducation/courses/linux/sys_admin.html 
            </A
>
          </P
></LI
><LI
><P
>&#13;            Online USA : 
            <A
HREF="               http://www.traininghott.com/Courses/Linux-System-Admin-Hands-On-Training-Course-Class-Seminar-NIS-DNS-DHCP-LILO.htm?source=findwhat_keyword=linux-admin-group                "
TARGET="_top"
> HOTT Training 
            </A
>
          </P
></LI
><LI
><P
>&#13;            Google directory: 
            <A
HREF="               http://www.google.com/search?q=courses+Linux+system+admin+&hl=en&lr=&ie=UTF-8&oe=UTF-8                "
TARGET="_top"
> Google Linux System Admin education 
            </A
>
          </P
></LI
></UL
>
    </P
></DIV
><DIV
CLASS="sect1"
><HR/><H2
CLASS="sect1"
><A
NAME="apt-get"/>12. Telepítés, frissítés fénysebességgel, az apt-get segítségével 
      (Redhat, Debian, Suse, Mandrake, egyéb)</H2
><P
>&#13;      Automatizálható a Linux rendszer karbantartása egy olyan használható 
      segédprogrammal, mint az apt-get. Az apt-get roppant hatékony, világszerte 
      milliónyi linuxos gépen használják. Az apt-get RedHat és Debian Linux 
      alapokon mûködik. Az RPM és Deb csomagokat támogató disztribúciókon használható. 
      A disztribúciók legtöbbjén használható; ha mégsem, nagyon könnyen 
      átszabhatod a forráskódját. A Mandrake-ben használt eszköznek urpmi a neve.
      <P
></P
><UL
><LI
><P
>&#13;            Ha RedHat Linuxot használsz, töltsd le az apt-get csomagot az
	    <A
HREF="http://apt.freshrpms.net"
TARGET="_top"
>&#13;              Apt for Redhat Linux 
            </A
>
	    (Apt a RedHat Linuxhoz) honlapról.
          </P
></LI
><LI
><P
>&#13;            A további részletekrõl az  
            <A
HREF="http://freshrpms.net/apt"
TARGET="_top"
>&#13;              Apt for Redhat Linux 
            </A
>
	    (Apt a RedHat Linuxhoz) honlapon olvashatsz.
          </P
></LI
><LI
><P
>&#13;            Alaposan olvasd át a dokumentációt mielõtt használnád. 
	    Olvasd el a 
            <A
HREF="http://www.debian.org/doc/ddp"
TARGET="_top"
>&#13;              Debian Docs 
            </A
>
            és 
            <A
HREF="http://www.debian.org/doc/user-manuals"
TARGET="_top"
>&#13;              User's Manuals 
            </A
>
            (Felhasználói kézikönyvek) továbbá 
            <A
HREF="http://www.debian.org/doc/user-manuals#apt-howto"
TARGET="_top"
>&#13;              APT HOWTO 
            </A
>
            honlapokat és válaszd ki a megfelelõ nyelvet, például 
            <A
HREF="http://www.debian.org/doc/manuals/apt-howto/index.en.html"
TARGET="_top"
>&#13;              English: HTML 
            </A
>
          </P
></LI
><LI
><P
>&#13;            <A
HREF="http://bazar.conectiva.com.br/~godoy/apt-howto"
TARGET="_top"
>&#13;              Apt+RPM howto 
            </A
>
          </P
></LI
><LI
><P
>&#13;            <A
HREF="http://apt4rpm.sourceforge.net"
TARGET="_top"
>&#13;              APT for RPM Based Linux Distributions 
            </A
>
	    (APT az RPM-alapú Linux terjesztésekhez)
          </P
></LI
><LI
><P
>&#13;            <A
HREF="http://www.debian.org/doc/manuals/apt-howto/ch-distros.en.html"
TARGET="_top"
>&#13;              List of Distributions which support APT 
            </A
>
	    (Az APT programot támogató terjsztések listája)
          </P
></LI
><LI
><P
>&#13;            Nézd meg a YUM segédprogramot a 
            <A
HREF="http://www.linux.duke.edu/projects/yum"
TARGET="_top"
>&#13;              YUM - Yellowdog Updater, Modified 
            </A
>
            honlapon. 
          </P
></LI
></UL
>
    </P
><P
>&#13;      Többet szeretnél tudni az apt-get parancsról? Csak nézd meg a súgóját 
      a következõ bash shell-ben kiadott paranccsal: 
      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;		$ apt-get -h  | more
			  
		apt 0.5.5cnc6 for linux i386 compiled on Jul 19 2003 21:23:24
		Usage: apt-get [options] command
			   apt-get [options] install|remove pkg1 [pkg2 ...]
			   apt-get [options] source pkg1 [pkg2 ...]
			  
		apt-get is a simple command line interface for downloading and
		installing packages. The most frequently used commands are update
		and install.
			  
		Commands:
		   update - Retrieve new lists of packages
		   upgrade - Perform an upgrade
		   install - Install new packages (pkg is libc6 not libc6.rpm)
		   remove - Remove packages
		   source - Download source archives
		   build-dep - Configure build-dependencies for source packages
		   dist-upgrade - Distribution upgrade, see apt-get(8)
		   clean - Erase downloaded archive files
		   autoclean - Erase old downloaded archive files
		   check - Verify that there are no broken dependencies
			  
		Options:
		  -h  This help text.
		  -q  Loggable output - no progress indicator
		  -qq No output except for errors
		  -d  Download only - do NOT install or unpack archives
		  -s  No-act. Perform ordering simulation
		  -y  Assume Yes to all queries and do not prompt
		  -f  Attempt to continue if the integrity check fails
		  -m  Attempt to continue if archives are unlocatable
		  -u  Show a list of upgraded packages as well
		  -b  Build the source package after fetching it
		  -D  When removing packages, remove dependencies as possible
		  -c=? Read this configuration file
		  -o=? Set an arbitary configuration option, eg -o dir::cache=/tmp
		See the apt-get(8), sources.list(5) and apt.conf(5) manual
		pages for more information and options.
							   This APT has Super Cow Powers.
	  </PRE
></FONT
></TD
></TR
></TABLE
>
    </P
><P
>&#13;      A kézikönyv oldal a következõ módon tekinthetõ meg: 
      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;			man apt-get
	  In the bottom of manual page, look at "See Also" section
			man apt.conf
			man apt-cache
			man apt-cdrom
	  </PRE
></FONT
></TD
></TR
></TABLE
>
    </P
><P
>&#13;      Egy példa az apt-get használatára: 
      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;			apt-get -f  upgrade postgresql-contrib
			apt-get  upgrade postgresql-contrib
			apt-get  install postgresql-contrib
			apt-get  install gaim
			apt-get dist-upgrade
		</PRE
></FONT
></TD
></TR
></TABLE
>
    </P
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="sourcecode_apt-get"/>12.1. Az "apt-get" forráskódja</H3
><P
>&#13;        Letöltheted és újrafordíthatod az apt-get forráskódját a 
	saját terjesztésedhez. Az apt-get forráskódja letölthetõ a
        <A
HREF="http://ftp.freshrpms.net/pub/freshrpms/redhat/9/apt"
TARGET="_top"
>&#13;          http://ftp.freshrpms.net/pub/freshrpms/redhat/9/apt 
        </A
>
        honlapról. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="rpmfind_tool"/>12.2. Az "rpmfind" segédprogram</H3
><P
>&#13;        Az apt-get programtól függetlenül az rpmfind is használható a RedHat-ban. 
	Az rpmfind néhány dologban hasonlít az apt-get segédprogramra. Látogass el 
	az rpmfind honlapjára:
        <A
HREF="http://rpmfind.net/linux/rpmfind"
TARGET="_top"
>&#13;          http://rpmfind.net/linux/rpmfind 
        </A
>
        . Az rpmfind egy olyan segédprogram, amely megkeresi, telepíti és 
	önmûködõen frissíti a helyi gépeden lévõ RPM fájlokat. Az rpmfind 
	webhelyét megtalálod a 
        <A
HREF="http://rpmfind.net"
TARGET="_top"
>&#13;          http://rpmfind.net 
        </A
>
        címen. 
      </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR/><H2
CLASS="sect1"
><A
NAME="linux_boot_process"/>13. Haladóknak szóló témák - A Linux rendszerindítási folyamata</H2
><P
>&#13;      Ez a rész nem igazán érdekes az átlagos "Józsi, otthoni PC-felhasználó" számára, 
      inkább irányul azok felé, akik számítógép-tudományos háttérrel rendelkeznek.
    </P
><P
>&#13;      A betöltési folyamat a következõ: CPU-&gt; VGA-&gt; Power-On-Self-Test-&gt; SCSI-&gt; 
      Boot Manager-&gt; Lilo boot loader-&gt; kernel-&gt; init-&gt; bash. A firmware és szoftver 
      programok különbözõ üzeneteket adnak, amikor a számítógép és a Linux életre kel.
    </P
><P
>&#13;      A Linux betöltési folyamatának részletes bemutatása:
      <P
></P
><OL
TYPE="1"
><LI
><P
>&#13;            Az alaplapon lévõ BIOS elõidézi a videokártya BIOS 
	    inicializálását
          </P
></LI
><LI
><P
>&#13;            Az alaplapon lévõ BIOS inicializálja önmagát
          </P
></LI
><LI
><P
>&#13;            Az SCSI vezérlõn lévõ BIOS inicializálja önmagát
          </P
></LI
><LI
><P
>&#13;            Hardveres összegzés: az alaplapi BIOS ezután kiírja a következõ 
	    összegzést a hardver tartalmáról. Majd futtatja a vírusellenõrzõ kódját, 
	    ami megváltozott indítószektorokat (boot sector) keres (ha engedélyezve van - a lektor).
          </P
></LI
><LI
><P
>&#13;            BootManager menü : a Master Boot Record (MBR) kiolvasásra kerül az elsõ 
	    merevlemezen, a DOS hagyományaihoz híven, a 0x00007c00 címre, és a 
	    processzor elkezdi végrehajtani az ott leírt utasításokat. Ez az MBR 
	    betöltõkód beolvassa az aktív DOS partíció elsõ szektorában lévõ kódot.
          </P
></LI
><LI
><P
>&#13;            A Lilo elindul: ha a Linuxot választottad és ha azt a LILO-val telepítetted, 
	    akkor betöltõdik a 0x00007c00 címre. A Lilo kiírja a LILO üzenetet az 
	    elõrehaladásáról, egyenként írva ki a betûket. Az elsõ "L" betût akkor írja 
	    ki, miután a Lilo átmozgatta magát egy jobb helyre, mint például a 0x0009A000 
	    címre. Az "I" jelenik meg, mielõtt elkezdené a másodszintû betöltõkódját. 
	    A másodszintû betöltõ írja ki a következõ "L"-t, betölti a rendszermag 
	    részeire mutató leírókat, és végül kiírja a végsõ "O" betût. A leírók a 
	    0x0009d200 címen helyezõdnek el. A rendszerindítási üzenet és a parancssor, 
	    ha úgy adták meg, kiíródik. A "tab" megnyomása a promptnál teszi lehetõvé, 
	    hogy a felhasználó rendszert válasszon, és parancssori opciókat adjon át a 
	    rendszermagnak, a meghajtóinak és az "init" programnak. Ezen kívül környezeti 
	    változók is megadhatók ennél a pontnál. 
            <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;A következõ sor a /boot/message fájlból származik:
&gt;
&gt;
&gt;
 Press  to list available boot image labels. 
 (Nyomj Tab-ot a kiválasztható rendszerindító fájlok (boot image) címkéinek megtekintéséhez)
A következõ sor az /sbin/lilo promptjából származik:
boot:
Figyelem: ha a Lilo-t nem használjuk, akkor a rendszermag elejébe, 
a linux/arch/i386/boot/bootsect.S-be épített kód kiírja a "Loading" 
üzenetet és folytatja.
A Lilo kiírja a következõt, amint tölti be a rendszermag kódját. 
A "Linux-2.2.12" szöveget a "label=..." megadásából veszi a lilo.conf-ból.
Loading linux-2.2.12..........
		</PRE
></FONT
></TD
></TR
></TABLE
>
          </P
></LI
><LI
><P
>&#13;            A /linux/arch/i386/boot/setup.S fájlban található rendszermag-kód 
	    végzi el az átkapcsolást a processzor valós (DOS) módjából a védett 
	    (teljes 32 bites) üzemmódba. A Trampoline.S és Trampoline32.S nevû 
	    kódrészek segítik az átkapcsolást. A kisebb rendszermag fájlok (zImage) 
	    kitömörítõdnek, és betöltõdnek a 0x00010000 címre. A nagyobb fájlok 
	    (bzImage) ehelyett a 0x00100000 címre töltõdnek. Ez a kód állítja 
	    be a regisztereket, kicsomagolja a tömörített rendszermagot 
	    (aminek az elején a linux/arch/i386/head.S található), kiírja a 
	    következõ két sort a linux/arch/i386/boot/compressed/misc.c 
	    fájlból:
	    <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;Uncompressing Linux... Ok. 
Booting the kernel. 
	    </PRE
></FONT
></TD
></TR
></TABLE
>
	    Az i386-specifikus setup.S most már bevégezte dolgát, és elugrik a 
	    0x00010000 (vagy 0x00100000) címre, hogy elindítsa az általános 
	    Linux kódot.
            <P
></P
><UL
><LI
><P
>&#13;                  Processzor, konzol és memória inicializálása: ez futtatja a 
		  linux/arch/i386/head.S-et, ami azonnal elugrik a 
		  linux/init/main.c fájlban lévõ start_kernel(void)
		  függvényhez, ahol a megszakításokat újradefiniálják. 
		  A linux/kernel/module.c ezután betölti a konzol és a 
		  PCI busz meghajtóit. Ettõl a ponttól kezdve a rendszermag 
		  üzenetei a memóriában is tárolódnak, és hozzáférhetõk a 
		  /bin/dmesg használatával. Általában késõbb átkerülnek a 
		  /var/log/message fájlba is, végsõ tárolásra.
                </P
></LI
><LI
><P
>&#13;                  A PCI busz inicializálása: a linux/init/main.c fájlban lévõ 
		  mpci_init() függvény váltja ki a következõ, 
		  a linux/arch/i386/kernel/bios32.c fájlban lévõ sorok kiírását:
                </P
></LI
><LI
><P
>&#13;                  Hálózat inicializálása: a linux/init/main.c fájlban lévõ 
		  socket_init() függvény végzi el a hálózat inicializálását:
                  <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;linux/net/socket.c prints:
Linux NET4.0 for Linux 2.2
Based upon Swansea University Computer Society NET3.039
linux/net/unix/af_unix.c prints:
NET4: Unix domain sockets 1.0 for Linux NET4.0.
linux/net/ipv4/af_inet.c prints:
NET4: Linux TCP/IP 1.0 for NET4.0
IP Protocols: ICMP, UDP, TCP
linux/net/ipv4/ip_gre.c prints:
GRE over IPv4 tunneling driver
linux/net/core/dev.c prints:
early initialization of device gre0 is deferred
linux/net/core/rtnetlink.c prints:
Initializing RT netlink socket
					</PRE
></FONT
></TD
></TR
></TABLE
>
                </P
></LI
><LI
><P
>&#13;                  A Kernel Idle Thread (üresjárati szál, a 0. folyamat) elindulása: 
		  ennél a pontnál egy rendszermag-folyamat indul el, ami az init() 
		  függvényt futtatja, ami a linux/init/main.c fájlban definiált 
		  rutinok egyike. Ez az init() nem összetévesztendõ az /sbin/init 
		  programmal, ami a rendszermag elindulása után kezd el futni. 
		  A linux/init/main.c fájlban lévõ mkswapd_setup() függvény váltja 
		  ki a következõ, a linux/mm/vmscan.c fájlból származó sorok kiírását: 
		  Starting kswapd v1.5 
                </P
></LI
><LI
><P
>&#13;                  Eszközmeghajtók inicializálása: a linux/arch/i386/kernel/setup.c 
		  rendszermag-rutin ezek után inicializálja az eszközöket és a 
		  fájlrendszereket (beépítve a rendszermagba??). A következõ sorokat 
		  állítja elõ, majd elágazik (fork) az /sbin/init-re: 
                  <P
></P
><UL
><LI
><P
>&#13;                        Általános párhuzamos port inicializálás: 
			a linux/drivers/misc/parport_pc.c párhuzamos port 
			inicializáló rutin írja ki a következõket:
                      </P
></LI
><LI
><P
>&#13;                        Karakteres eszközök inicializálása: a következõ 3 sor a 
			linux/drivers/char/serial.c fájlból származik: 
                      </P
></LI
><LI
><P
>&#13;                        Block Device Initializations : 
                        linux/drivers/block/rd.c prints: RAM disk driver 
                        initialized: 16 RAM disks of 8192K size 
                        linux/drivers/block/loop.c prints: loop: registered 
                        device at major 7 linux/drivers/block/floppy.c prints: 
                        Floppy drive(s): fd0 is 1.44M, fd1 is 1.44M FDC 0 is a 
                        post-1991 82077 
                      </P
></LI
><LI
><P
>&#13;                        SCSI busz inicializálása: a következõ sorok a 
			linux/drivers/scsi alkönyvtárban lévõ aic7xxx.c, 
			scsi.c, sg.c, sd.c vagy sr.c fájlokból származnak:
                      </P
></LI
></UL
>
                </P
></LI
><LI
><P
>&#13;                  A rendszermag Point-To-Point protokoll támogatásának 
		  inicializálása: a következõ inicializálást a 
		  linux/drivers/net/ppp.c végzi.
                </P
></LI
><LI
><P
>&#13;                  A merevlemez-elrendezés vizsgálata: a következõ sorok a 
		  linux/drivers/block/genhd.c fájlból származnak: 
                </P
></LI
></UL
>
          </P
></LI
><LI
><P
>&#13;            Init Program (Process 1) Startup : The program /sbin/init is 
            started by the "idle" process (Process 0) code in 
            linux/init/main.c and becomes process 1. /sbin/init then completes 
            the initialization by running scripts and forking additional 
            processes as specified in /etc/inittab. It starts by printing: 
            INIT: version 2.76 booting and reads /etc/inittab. 
          </P
></LI
><LI
><P
>&#13;            A Bash parancsértelmezõ indulása: a bash shell, a /bin/bash 
	    indul el ezek után. A feléledése az /etc/profile szkript 
	    végrehajtásával kezdõdik, ami beállítja a rendszerszintû 
	    környezeti változókat: 
          </P
></LI
></OL
>
    </P
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="bootprocess_urls"/>13.1. Hivatkozások a betöltési folyamat témájában</H3
><P
>&#13;        Nézd meg a következõ forrásokat: 
        <P
></P
><UL
><LI
><P
>&#13;              <A
HREF="http://www.tldp.org/HOWTO/Bootdisk-HOWTO/x1440.html"
TARGET="_top"
>&#13;                The Linux Boot Process 
              </A
>
	      (A Linux betöltési folyamata)
            </P
></LI
><LI
><P
>&#13;              <A
HREF="http://www.tldp.org/HOWTO/Bootdisk-HOWTO/x88.html"
TARGET="_top"
>&#13;                Bootdisks and Boot Process 
              </A
>
	      (Indítólemezek és a betöltési folyamat)
            </P
></LI
><LI
><P
>&#13;              <A
HREF="http://ourworld.compuserve.com/homepages/KanjiFlash/SGVLUG.htm"
TARGET="_top"
>&#13;                Linux Boot Process - by San Gabreil LUG 
              </A
>
	      (Linux betöltési folyamat - írta San Gabreil LUG)
            </P
></LI
><LI
><P
>&#13;              <A
HREF="http://www.linuxnetmag.com/en/issue4/m4boot1.html"
TARGET="_top"
>&#13;                Boot Process (Netmag) 
              </A
>
	      (Betöltési folyamat (Netmag))
            </P
></LI
><LI
><P
>&#13;              <A
HREF="http://oldfield.wattle.id.au/luv/boot.html"
TARGET="_top"
>&#13;                Boot Process (LUG Victoria) 
              </A
>
	      (Betöltési folyamat (LUG Victoria))
            </P
></LI
></UL
>
      </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR/><H2
CLASS="sect1"
><A
NAME="other_formats"/>14. Eme dokumentum más formátumai</H2
><P
>&#13;      Ezt a fejezetet 
      <A
HREF="mailto:alavoor[AT]yahoo.com"
TARGET="_top"
>&#13;        Al Dev 
      </A
>
      írta, (a 
      <A
HREF="http://milkyway.has.it"
TARGET="_top"
>&#13;        "http://milkyway.has.it" 
      </A
>
      és a 
      <A
HREF="http://www.milkywaygalaxy.freeservers.com"
TARGET="_top"
>&#13;        "http://www.milkywaygalaxy.freeservers.com" 
      </A
>
      webhelyen, tükrözései megtalálhatók a 
      <A
HREF="http://www.angelfire.com/country/aldev0"
TARGET="_top"
>&#13;        angelfire 
      </A
>
      , 
      <A
HREF="http://www.geocities.com/alavoor/index.html"
TARGET="_top"
>&#13;        geocities 
      </A
>
      , 
      <A
HREF="http://aldev0.virtualave.net"
TARGET="_top"
>&#13;        virtualave 
      </A
>
      , 
      <A
HREF="http://members.fortunecity.com/aldev"
TARGET="_top"
>&#13;        Fortunecity 
      </A
>
      , 
      <A
HREF="http://aldev.freewebsites.com"
TARGET="_top"
>&#13;        Freewebsites 
      </A
>
      , 
      <A
HREF="http://members.tripod.lycos.com/aldev"
TARGET="_top"
>&#13;        Tripod 
      </A
>
      , 
      <A
HREF="http://www.101xs.com/101xs/aldev"
TARGET="_top"
>&#13;        101xs 
      </A
>
      és 
      <A
HREF="http://aldev0.50megs.com"
TARGET="_top"
>&#13;        50megs 
      </A
>
      webhelyeken) 
    </P
><P
>&#13;      Ezt a dokumentumot 14 különbözõ formátumban terjesztik, ezek a következõk: DVI, 
      Postscript, Latex, Adobe Acrobat PDF, LyX, GNU-info, HTML, RTF (Rich Text 
      Format), egyszerû szöveg, Unix man oldal, egyoldalas HTML fájl, SGML (Linuxdoc 
      formátum), SGML (Docbook formátum), MS WinHelp formátum. 
    </P
><P
>&#13;      A dokumentum megtalálható a 
      <P
></P
><UL
><LI
><P
>&#13;            <A
HREF="http://www.tldp.org"
TARGET="_top"
>&#13;              "http://www.tldp.org" 
            </A
>
            webhelyen, itt kattints a "HOWTO" hivatkozásra és keresd a 
	    CTRL-f vagy ALT-f segítségével a dokumentum nevét a honlapon. 
          </P
></LI
></UL
>
    </P
><P
>&#13;      A következõ tüköroldalakon is megtalálhatod ezt a dokumentumot: 
      <P
></P
><UL
><LI
><P
>&#13;            <A
HREF="http://www.caldera.com/LDP/HOWTO"
TARGET="_top"
>&#13;              "http://www.caldera.com/LDP/HOWTO" 
            </A
>
          </P
></LI
><LI
><P
>&#13;            <A
HREF="http://www.linux.ucla.edu/LDP"
TARGET="_top"
>&#13;              "http://www.linux.ucla.edu/LDP" 
            </A
>
          </P
></LI
><LI
><P
>&#13;            <A
HREF="http://www.cc.gatech.edu/linux/LDP"
TARGET="_top"
>&#13;              "http://www.cc.gatech.edu/linux/LDP" 
            </A
>
          </P
></LI
><LI
><P
>&#13;            <A
HREF="http://www.redhat.com/mirrors/LDP"
TARGET="_top"
>&#13;              "http://www.redhat.com/mirrors/LDP" 
            </A
>
          </P
></LI
><LI
><P
>&#13;            Egyéb, hozzád közeli tüköroldalak (hálózati címtõl függ) találhatók a 
            <A
HREF="http://www.tldp.org/mirrors.html"
TARGET="_top"
>&#13;              "http://www.tldp.org/mirrors.html" 
            </A
>
            honlapon. Válassz egy webhelyet és lépj be az /LDP/HOWTO/xxxxx-HOWTO.html könyvtárba. 
          </P
></LI
></UL
>
    </P
><P
>&#13;      <P
></P
><UL
><LI
><P
>&#13;            A dokumentumot egyszerû tar csomagként is letöltheted HTML, 
	    DVI, Postscript vagy SGML formátumban a 
            <A
HREF="ftp://www.tldp.org/pub/Linux/docs/HOWTO/other-formats/"
TARGET="_top"
>&#13;              "ftp://www.tldp.org/pub/Linux/docs/HOWTO/other-formats/" 
            </A
>
            és 
            <A
HREF="http://www.tldp.org/docs.html#howto"
TARGET="_top"
>&#13;              "http://www.tldp.org/docs.html#howto" 
            </A
>
	    honlapokról. 
          </P
></LI
><LI
><P
>&#13;            A sima szöveges formátum megtalálható az 
            <A
HREF="ftp://www.tldp.org/pub/Linux/docs/HOWTO"
TARGET="_top"
>&#13;              "ftp://www.tldp.org/pub/Linux/docs/HOWTO" 
            </A
>
            tárhelyen illetve a 
            <A
HREF="http://www.tldp.org/docs.html#howto"
TARGET="_top"
>&#13;              "http://www.tldp.org/docs.html#howto" 
            </A
>
	    honlapon. 
          </P
></LI
><LI
><P
>&#13;            Egyoldalas HTML fájlként letöltheted a 
            <A
HREF="http://www.tldp.org/docs.html#howto"
TARGET="_top"
>&#13;              "http://www.tldp.org/docs.html#howto" 
            </A
>
	    honlapról. Az egyoldalas HTML fájlt a következõ paranccsal állítható elõ 
	    (olvasd az sgml2html kézikönyvoldalát): sgml2html -split 0 xxxxhowto.sgml 
          </P
></LI
><LI
><P
>&#13;            Más nyelvi (mint például francia, német, spanyol, kínai, japán) 
	    fordítások találhatók a 
            <A
HREF="ftp://www.tldp.org/pub/Linux/docs/HOWTO"
TARGET="_top"
>&#13;              "ftp://www.tldp.org/pub/Linux/docs/HOWTO" 
            </A
>
            és 
            <A
HREF="http://www.tldp.org/docs.html#howto"
TARGET="_top"
>&#13;              "http://www.tldp.org/docs.html#howto" 
            </A
>
	    honlapokon. Jól jön bármely segítség tõletek a más nyelvre való 
	    fordításhoz (íme :) - a ford.) 
          </P
></LI
></UL
>
      (Ez a rész mára elavult - a lektor) A dokumentum az "SGML-Tools" nevû eszköz 
      segítségével készült, amely letölthetõ a 
      <A
HREF="http://www.sgmltools.org"
TARGET="_top"
>&#13;        "http://www.sgmltools.org" 
      </A
>
      webhelyrõl. A forrás lefordítása után a következõ parancsot 
      használhatod a konvertáláshoz: 
      <P
></P
><UL
><LI
><P
>&#13;            sgml2html xxxxhowto.sgml (többoldalas HTML fájlt készít) 
          </P
></LI
><LI
><P
>&#13;            sgml2html -split 0 xxxxhowto.sgml (egyoldalas HTML fájlt készít) 
          </P
></LI
><LI
><P
>&#13;            sgml2rtf xxxxhowto.sgml (RTF fájlt készít) 
          </P
></LI
><LI
><P
>&#13;            sgml2latex xxxxhowto.sgml (LaTeX fájlt készít) 
          </P
></LI
></UL
>
    </P
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="acrobatpdf"/>14.1. Acrobat PDF formátum</H3
><P
>&#13;        PDF fájlt a postscript fájl felhasználásával lehet készíteni, vagy az acrobat 
        <EM
>&#13;          distill 
        </EM
>
        illetve 
        <EM
>&#13;          Ghostscript 
        </EM
>
        segítségével. A postscript fájlt DVI-bõl lehet elkészíteni, 
	ami viszont közvetlenül LaTex fájlból készül. A distill szoftver letölthetõ a
        <A
HREF="http://www.adobe.com"
TARGET="_top"
>&#13;          "http://www.adobe.com" 
        </A
>
        webhelyrõl. Alább egy egyszerû példa látható: 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash$ man sgml2latex
	bash$ sgml2latex filename.sgml
	bash$ man dvips
	bash$ dvips -o filename.ps filename.dvi
	bash$ distill filename.ps
	bash$ man ghostscript
	bash$ man ps2pdf
	bash$ ps2pdf input.ps output.pdf
	bash$ acroread output.pdf &amp;
        </PRE
></FONT
></TD
></TR
></TABLE
>
        Esetleg használhatod a következõ Ghostscript parancsot: 
        <EM
>&#13;          ps2pdf 
        </EM
>
        . A ps2pdf hasonlóan mûködik mint az Adobe Acrobat Distiller program, 
	és majdnem minden funkcióját tudja: konvertálja a PostScript fájlokat 
	Portable Document Format (PDF) formátumba. A
        <EM
>&#13;          ps2pdf 
        </EM
>
        konvertálást egy nagyon kicsi parancsszkriptben (batch fájlban) valósították meg, 
	ami meghívja a GhostScript programot, kiválasztva egy speciális "kimeneti eszközt", 
	amely a 
        <EM
>&#13;          pdfwrite 
        </EM
>
        . A ps2pdf használatához a pdfwrite eszközt be kell szúrni a Makefile-ba, 
	a GhostScript programfordításakor; olvasd a fordítási dokumentációt továbi
	részletekért. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="linuxdoc2docbook"/>14.2. Konvertálás Linuxdoc-ról Docbook formátumra</H3
><P
>&#13;        (Ez a fejezet mára elavult, bár bizonyos részei használhatók - a lektor)
	Ez a dokumentum Linuxdoc SGML formátumban készült. A Docbook SGML 
	formátum helyettesíti a Linuxdoc formátumot, mivel sokkal több 
	szolgáltatása van, mint annak. A Linuxdoc formátum nagyon egyszerû 
	és könnyû használni. A formátumának Docbook SGML-re való konvertálásához 
	használd a 
        <EM
>&#13;          ld2db.sh 
        </EM
>
        szkriptet, valamint néhány perl szkriptet. Az ld2db kimenete nem 100%-ig tiszta, 
	ezért használd a 
        <EM
>&#13;          clean_ld2db.pl 
        </EM
>
        perl szkriptet. Lehet, hogy kézzel is kell javítani néhány sort a 
	doksiban. 
        <P
></P
><UL
><LI
><P
>&#13;              Töltsd le a ld2db programot a
              <A
HREF="http://www.dcs.gla.ac.uk/~rrt/docbook.html"
TARGET="_top"
>&#13;                "http://www.dcs.gla.ac.uk/~rrt/docbook.html" 
              </A
>
              vagy a 
              <A
HREF="http://milkyway.has.it"
TARGET="_top"
>&#13;                "http://milkyway.has.it" 
              </A
>
              , 
              <A
HREF="http://www.milkywaygalaxy.freeservers.com"
TARGET="_top"
>&#13;                Milkyway Galaxy site 
              </A
>
	      webhelyrõl.
            </P
></LI
><LI
><P
>&#13;              A cleanup_ld2db.pl perl szkriptet letöltheted a 
              <A
HREF="http://milkyway.has.it"
TARGET="_top"
>&#13;                "http://milkyway.has.it" 
              </A
>
              és 
              <A
HREF="http://www.milkywaygalaxy.freeservers.com"
TARGET="_top"
>&#13;                Milkyway Galaxy site 
              </A
>
	      webhelyekrõl. 
            </P
></LI
></UL
>
        Az ld2db.sh nem 100%-ig korrekt, sok hibát fogsz kapni, mikor kiadod a  
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;		bash$ ld2db.sh file-linuxdoc.sgml db.sgml
		bash$ cleanup.pl db.sgml &gt; db_clean.sgml
		bash$ gvim db_clean.sgml 
		bash$ docbook2html db.sgml
        </PRE
></FONT
></TD
></TR
></TABLE
>
        parancsokat. Valószínûleg kézzel kell szerkesztened néhány kisebb hibát, 
	miután futtattad a szkriptet. Például a záró &lt;/Para&gt; tag-eket 
	neked kell kitenni minden &lt; Listitem&gt; után. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="mswinhelp"/>14.3. Konvertálás MS WinHelp formátumra</H3
><P
>&#13;        Átalakíthatod a Microsoft Windows Help formátumára is az SGML dokumentumot, 
	elõször konvertáld át HTML formátumba a következõ parancsok használatával: 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;		bash$ sgml2html xxxxhowto.sgml     (ez HTML fájlt készít)
		bash$ sgml2html -split 0   xxxxhowto.sgml (to generate a single page html file)
        </PRE
></FONT
></TD
></TR
></TABLE
>
        Majd használd a 
        <A
HREF="http://javadocs.planetmirror.com/htmltohlpe.html"
TARGET="_top"
>&#13;          HtmlToHlp 
        </A
>
        segédprogramot. Ezen kívül használható az sgml2rtf is, majd az RTF fájlokat 
	lehet a WinHelp legyártásához felhasználni. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="readformats"/>14.4. A különbözõ formátumok olvasása</H3
><P
>&#13;        A dokumentum dvi formátumban történõ olvasásához használd az 
	xdvi programot. Az xdvi a tetex-xdvi*.rpm csomagban van a RedHat 
	Linuxban, amit meg lehet találni a Control Panel | Applications | 
	Publishing | TeX menüpontokon keresztül. Az olvasáshoz add ki a 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;          xdvi -geometry 80x90 howto.dvi man xdvi 
        </PRE
></FONT
></TD
></TR
></TABLE
>
        parancsot. Méretezd át az ablakot egérrel. A navigáláshoz használd a 
	nyílbillentyûket, a Page Up/Down gombokat, de az "f", "d", "u", "c", 
	"l", "r", "p", "n" billentyûket is a fel/le mozgáshoz, középre igazításhoz, 
	következõ/elõzõ oldal kéréséhez stb. A haladó menü kikapcsolásához nyomj "x"-et.
      </P
><P
>&#13;        A postscript fájlt a "gv" (ghostview) vagy a "ghostscript" programmal 
	nézheted meg. A ghostscript program a ghostscript*.rpm csomagban van, 
	a gv pedig a gv*.rpm-ben a RedHat Linux alatt, ami elérhetõ a 
	ControlPanel | Applications | Graphics menüpontokon keresztül. 
	A gv program sokkal felhasználóbarátabb, mint a ghostscript. 
	Ezenkívül a ghostscipt és a gv is elérhetõ más platformokon, mint OS/2, 
	Windows 95 és NT, még ezeken is megnézheted ezt a doksit. 
      </P
><P
>&#13;        <P
></P
><UL
><LI
><P
>&#13;              A Windows 95, OS/2 és egyéb operációs rendszerekhez beszerezhetõ a 
              <A
HREF="http://www.cs.wisc.edu/~ghost"
TARGET="_top"
>&#13;                "http://www.cs.wisc.edu/~ghost" 
              </A
>
	      webhelyrõl.
            </P
></LI
></UL
>
      </P
><P
>&#13;        A postscipt dokumentum olvasásához add ki a 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>&#13;          gv howto.ps ghostscript howto.ps 
        </PRE
></FONT
></TD
></TR
></TABLE
>
	parancsot. 
      </P
><P
>&#13;        A HTML formátumú doksit olvashatod a Netscape Navigator, Microsoft 
        Internet explorer, Redhat Baron és vagy 10 másik böngészõprogram 
	segítségével. 
      </P
><P
>&#13;        A latex, LyX kimenet olvasásához használd a LyX X-Window elõtétprogramot a 
	latex programmal. 
      </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR/><H2
CLASS="sect1"
><A
NAME="create_initrd"/>15. "A" függelék - initrd.img fájl készítése</H2
><P
>&#13;      Az 
      <EM
>&#13;        initrd 
      </EM
>
      az "initial ramdisk" (kezdeti RAM-lemez) rövidítése. Egy RAM-lemezen elegendõ 
      fájl fér el a szükséges eszközmeghajtók tárolásához. Ezek a meghajtók kellenek 
      ahhoz, hogy a rendszermag fel tudja csatolni a / könyvtárat, és el tudja 
      indítani az init-et. Az initrd-t tipikusan a hardver átmeneti 
      "beindítására" használjuk, ezután a valódi rendszermag (vmlinuz) 
      folytatja a betöltési folyamatot. Például, ha a rendszermag nem 
      tudja olvasni az scsi merevlemezt az scsi eszközmeghajtó betöltése 
      elõtt. (Megoldás: tölts be egy initrd rendszermagot, amely majd 
      betölti az igazi rendszermagot és használd az initrd-t az scsi 
      betöltési problémájának megoldására.) 
    </P
><P
>&#13;      Megszabadulhatsz az "initrd.img" fájltól és nem szükséges akkor, 
      ha az SCSI eszközvezérlõket fixen a rendszermagba fordítod, 
      nem pedig modulba rakod. (Sokan ajánlják ezt). 
    </P
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1083"/>15.1. Az mkinitrd használata</H3
><P
>&#13;        Az mkinitrd segédprogram készíti el az initrd fájlt, egyetlen paranccsal. 
	Ez a parancs a RedHat jellegzetessége. A Linux többi terjesztéseinél 
	hasonló parancsok létezhetnek. Nagyon kényelmes program. 
      </P
><P
>&#13;        Olvasd el az mkinitrd kézikönyv oldalát. 
      </P
><P
>&#13;        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	/sbin/mkinitrd --help   # vagy egyszerûen: "mkinitrd --help"
	usage: mkinitrd [--version] [-v] [-f] [--preload &lt;module&gt;]
	       [--omit-scsi-modules] [--omit-raid-modules] [--omit-lvm-modules]
	       [--with=&lt;module&gt;] [--image-version] [--fstab=&lt;fstab&gt;] [--nocompress]
	       [--builtin=&lt;module&gt;] [--nopivot] &lt;initrd-image&gt; &lt;kernel-version&gt;
	       (example: mkinitrd /boot/initrd-2.2.5-15.img 2.2.5-15)
	# olvasd el a kezikonyv oldalt .....
	man mkinitrd
	su - root
	# Az alábbi parancs elkészíti az initrd fájlt
	mkinitrd  ./initrd-2.4.18-19.8.0custom.img   2.4.18-19.8.0custom
	ls -l initrd-2.4.18-19.8.0custom.img
	-rw-r--r--    1 root     root       127314 Mar 19 21:54 initrd-2.4.18-19.8.0custom.img
	cp  ./initrd-2.4.18-19.8.0custom.img   /boot
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
><P
>&#13;        A következõ fejezetekben olvashatsz arról, 
	hogyan kell kézzel elkészíteni az initrd fájlt. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1090"/>15.2. Rendszermag-dokumentációk</H3
><P
>&#13;        A /boot/initrd.img elkészítésérõl szól az 
        /usr/src/linux/Documentation/initrd.txt leírás, valamint a 
        <A
HREF="http://www.tldp.org/HOWTO/mini/Loopback-Root-FS-3.html#ss3.3"
TARGET="_top"
>&#13;          Loopback-Root-mini-HOWTO 
        </A
>
        . 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1094"/>15.3. Linuxman Book</H3
><P
>&#13;        Egy részlet a 
        <A
HREF="http://www.linuxman.com.cy/rute/node1.html"
TARGET="_top"
>&#13;          "http://www.linuxman.com.cy/rute/node1.html" 
        </A
>
        31.7. fejezetébõl.
      </P
><P
>&#13;        Az SCSI telepítésének buktatói és az initrd 
      </P
><P
>&#13;        A következõ leírás némelyike nehezen lesz érthetõ anélkül, 
	hogy tudnál valamit a rendszermag-modulokról, amiket a 42. 
	fejezetben mutat be. Késõbb térj vissza erre a fejezetre.
      </P
><P
>&#13;        Képzeljünk el egy rendszert, amiben egyetlen IDE lemez sincs, csak egy 
	SCSI lemez tartalmazza a telepített Linuxot. Vannak az SCSI lemezt 
	olvasó BIOS megszakítások, ugyanúgy, mint az IDE-hez, tehát a LILO vígan 
	hozzá tud férni egy SCSI partíción lévõ rendszermaghoz. Azonban a 
	rendszermag "el fog veszni" a rendszermag-modulok nélkül [lásd 42. fejezet. 
	A rendszermag magától nem tudja az összes létezõ hardver elemet támogatni. 
	Ez általában egy fõ részre (a rendszermag fájlra, amit ebben a fejezetben 
	tárgyalunk) és modulok százaira (betölthetõ részek, amik a /lib/modules alatt 
	találhatók) tagolható szét [ amik támogatják a sokféle típusú SCSI, hálózati, 
	hangeszközt stb. ], amely képes vezérelni azt a bizonyos SCSI meghajtót. 
	Így bár a rendszermag be tud töltõdni és el tud indulni, de nem tudja 
	felcsatolni a gyökér fájlrendszert az SCSI modul elõzetes betöltése nélkül. 
	Viszont a modul maga a gyökér fájlrendszeren foglal helyet a /lib/modules-ban. 
	Ez egy trükkös helyzet, és kétféle módon lehet megoldani: (a) vagy elõre 
	engedélyezett (preenabled) SCSI támogatású rendszermagot, vagy (b) 
	egy initrd elõzetes gyökér fájlrendszernek nevezett fájlt használunk. 
      </P
><P
>&#13;        Az elsõ módszert ajánlom. Magától értetõdõ (bár idõigényes) folyamat egy 
	olyan rendszermag elkészítése, ami beépített támogatást nyújt az SCSI 
	kártyádhoz (és nem egy külön modulban). A beépített SCSI és hálózati meghajtók 
	legtöbbször automatikus detektálást is végeznek, lehetõvé téve az eszközhöz való 
	idõközbeni hozzáférést - mindenféle kapcsoló megadása nélkül mûködnek. [lsqb ] 
	A 42. fejezet tárgyalja.] és ami még fontosabb, anélkül, hogy olvasnod kéne 
	a beállításukról. Ennek befordított hardvertámogatás a neve (a modulos 
	támogatással szemben). Az így készült rendszermag a modul méretével 
	lesz nagyobb. A 42. fejezet taglalja az ilyen fajta programfordítást. 
      </P
><P
>&#13;        A második módszer gyorsabb, de trükkösebb. A Linux támogat egy olyan dolgot, 
	amit initrd (initial RAM disk) néven ismernek. Ez egy kicsi, +1.5 MB méretû 
	fájlrendszer, amit a LILO tölt be, és a rendszermag a valódi gyökér fájlrendszer 
	helyett csatol fel. A rendszermag RAM-lemezként csatolja fel ezt a fájlrendszert, 
	végrehajtja a /linuxrc fájlt, majd felcsatolja a valódi fájlrendszert. 
      </P
><P
>&#13;        31.6 fejezet initrd fájl készítése 
      </P
><P
>&#13;        Kezdjük egy kis fájlrendszer elkészítésével. Készíts egy könyvtárat 
	[nbsp ]/initrd néven és másold át a következõ fájlokat oda: 
      </P
><P
>&#13;        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	drwxr-xr-x    7 root     root         1024 Sep 14 20:12 initrd/
	drwxr-xr-x    2 root     root         1024 Sep 14 20:12 initrd/bin/
	-rwxr-xr-x    1 root     root       436328 Sep 14 20:12 initrd/bin/insmod
	-rwxr-xr-x    1 root     root       424680 Sep 14 20:12 initrd/bin/sash
	drwxr-xr-x    2 root     root         1024 Sep 14 20:12 initrd/dev/
	crw-r--r--    1 root     root       5,   1 Sep 14 20:12 initrd/dev/console
	crw-r--r--    1 root     root       1,   3 Sep 14 20:12 initrd/dev/null
	brw-r--r--    1 root     root       1,   1 Sep 14 20:12 initrd/dev/ram
	crw-r--r--    1 root     root       4,   0 Sep 14 20:12 initrd/dev/systty
	crw-r--r--    1 root     root       4,   1 Sep 14 20:12 initrd/dev/tty1
	crw-r--r--    1 root     root       4,   1 Sep 14 20:12 initrd/dev/tty2
	crw-r--r--    1 root     root       4,   1 Sep 14 20:12 initrd/dev/tty3
	crw-r--r--    1 root     root       4,   1 Sep 14 20:12 initrd/dev/tty4
	drwxr-xr-x    2 root     root         1024 Sep 14 20:12 initrd/etc/
	drwxr-xr-x    2 root     root         1024 Sep 14 20:12 initrd/lib/
	-rwxr-xr-x    1 root     root           76 Sep 14 20:12 initrd/linuxrc
	drwxr-xr-x    2 root     root         1024 Sep 14 20:12 initrd/loopfs/
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
><P
>&#13;        Az én rendszeremen, a initrd/bin/insmod fájl statikusan linkelt [ami azt jelenti, 
	hogy nem igényel megosztott könyvtárakat ], a /sbin/insmod.static fájlból - ez a 
	modutils-2.3.13 csomag része. Az initrd/bin/sash egy statikusan linkelt 
	parancsértelmezõ a sash-3.4 csomagból. Az insmod-ot újra is fordíthatod 
	forrásból, ha nincs statikus verziód. Esetleg másold be a szükséges DLL-eket a 
	/lib-bõl az initrd/lib könyvtárba. (A szükséges DLL-ek listáját megkapod, 
	ha az "ldd /sbin/insmod" parancsot kiadod. Ne felejtsd el átmásolni a szimbolikus 
	linkeket sem, valamint futtatni a "strip -s {lib}" parancsot, a DLL-ek 
	méretének csökkentéséhez. 
      </P
><P
>&#13;        Most másold át az initrd/lib/ könyvtárba a szükséges SCSI modulokat. 
	Például, ha egy Adaptec AIC-7850 SCSI adaptered van, akkor az aic7xxx.o modul 
	kell a /lib/modules/{version}/scsi/aic7xxx.o fájlokból. Ezek után rakd be ezt a 
	initrd/lib/ könyvtárba. 
      </P
><P
>&#13;        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	-rw-r--r--    1 root     root       129448 Sep 27  1999 initrd/lib/aic7xxx.o
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
><P
>&#13;        Az initrd/linuxrc fájlnak egy szkriptet kell tartalmaznia, hogy betöltse az 
	összes modult a rendszermag számára, hogy hozzáférhessen az SCSI partícióhoz. 
	Ebben az esetben, csak az aic7xxx modul kell [ az insmod az eszköz IRQ-ira és 
	IO-címeire vonatkozó paramétereket is megkaphat, lásd a 42. fejezetet.]: 
      </P
><P
>&#13;        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	#!/bin/sash
	 
	aliasall
	 
	echo "Loading aic7xxx module"
	insmod /lib/aic7xxx.o 
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
><P
>&#13;        Alaposan ellenõrizd az összes jogosultságot, majd futtasd a chroot parancsot 
	a fájlrendszer teszteléséhez. 
      </P
><P
>&#13;        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	chroot ~/initrd /bin/sash
	/linuxrc
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
><P
>&#13;        Ezután készíts egy "fájlrendszer-fájlt" (file system image), hasonlóan a 19.9 fejezetben leírtakhoz: 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	dd if=/dev/zero of=~/file-inird count=2500 bs=1024
	losetup /dev/loop0 ~/file-inird
	mke2fs /dev/loop0
	mkdir ~/mnt
	mount /dev/loop0 ~/mnt
	cp -a initrd/* ~/mnt/
	umount ~/mnt
	losetup -d /dev/loop0
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
><P
>&#13;        Végül tömörítsd össze a fájlrendszert a gzip programmal, valamilyen néven: 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	gzip -c ~/file-inird &gt; initrd-&lt;kernel-version&gt;
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
><P
>&#13;        31.7 fejezet A lilo.conf módosítása az initrd használatához 
      </P
><P
>&#13;        A lilo.conf fájlt annak megfelelõen kell megváltoztatni, hogy az initrd 
	fájlrendszert töltse be. Egyszerûen add hozzá az initrd kapcsolót. Például: 
      </P
><P
>&#13;        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	boot=/dev/sda
	prompt
	timeout = 50
	compact
	vga = extended
	linear
	image = /boot/vmlinuz-2.2.17
	        initrd = /boot/initrd-2.2.17
	        label = linux
	        root = /dev/sda1
	        read-only
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
><P
>&#13;        Figyeld meg a "linear" kapcsoló használatát. Ez egy BIOS trükk, amirõl a 
	lilo(5) kézikönyv oldalán olvashatsz. Ez gyakran szükséges, viszont azt 
	eredményezheti, hogy az SCSI lemezek nem lesznek átvihetõk különbözõ 
	BIOS-al rendelkezõ gépekre (azt jelenti, hogy újra le kell futtatni a 
	lilo-t, ha egy másik gépbe rakod át a lemezt).
      </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR/><H2
CLASS="sect1"
><A
NAME="liloconf"/>16. "B" függelék - lilo.conf mintafájl</H2
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
NAME="AEN1128"/>16.1. LILO forrásanyagok</H3
><P
>&#13;        A következõ dokumentumokban olvashatsz a témáról: 
        <P
></P
><UL
><LI
><P
>&#13;              <A
HREF="http://www.tldp.org/HOWTO/mini/LILO.html"
TARGET="_top"
>&#13;                http://www.tldp.org/HOWTO/mini/LILO.html 
              </A
>
            </P
></LI
><LI
><P
>&#13;              Olvasd a rendszereden lévõ LILO dokumentációt: 
              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	# Használd a kghostview, ghostview vagy gv parancsot 
	kghostview /usr/share/doc/lilo-21.4.4/doc/user.ps
	  
	# A HTML formátum olvasásához tedd ezt: 
	mkdir $HOME/lilodocs
	cd $HOME/lilodocs
	cp /usr/share/doc/lilo-21.4.4/doc/user.tex  .
	latex2html user
	  
	# Ez létrehozza a html fájlokat az usr könyvtárban 
      		</PRE
></FONT
></TD
></TR
></TABLE
>
            </P
></LI
><LI
><P
>&#13;              <A
HREF="#grubconf"
>17 </A
>
              GRUB beállítófájl 
            </P
></LI
><LI
><P
>&#13;              <A
HREF="http://www.tldp.org/HOWTO/LILO-crash-rescue-HOWTO.html"
TARGET="_top"
>&#13;                "http://www.tldp.org/HOWTO/LILO-crash-rescue-HOWTO.html" 
              </A
>
              . 
            </P
></LI
></UL
>
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1144"/>16.2. LILO hibaelhárítás</H3
><P
>&#13;        A csipogó (beeper) hibakód-táblázata: 
        <DIV
CLASS="table"
><A
NAME="AEN1147"/><P
><B
>Táblázat 1. 
            Csipogó hibakód-táblázat 
          </B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;                  Kód 
                </TH
><TH
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;                  Leírás 
                </TH
></TR
></THEAD
><TBODY
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;                  0 
                </TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;                  PC-hangszóró hiba 
                </TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;                  1 
                </TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;                  DRAM frissítési hiba 
                </TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;                  2 
                </TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;                  Paritáshiba (Paritykring defect) 
                </TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;                  3 
                </TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;                  Hiba az alap 64K RAM-ban 
                </TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;                  4 
                </TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;                  Rendszeridõzítõ hiba 
                </TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;                  5 
                </TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;                  Processzor hiba 
                </TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;                  6 
                </TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;                  Billentyûzet-vezérlõ hiba 
                </TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;                  7 
                </TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;                  Virtuális mód hiba 
                </TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;                  8 
                </TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;                  A videomemória tesztje nem sikerült 
                </TD
></TR
><TR
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;                  9 
                </TD
><TD
WIDTH="50%"
ALIGN="LEFT"
VALIGN="MIDDLE"
>&#13;                  hibás ROM-BIOS ellenõrzõ összeg 
                </TD
></TR
></TBODY
></TABLE
></DIV
>
      </P
><P
>&#13;        2 rövid csipogás: a POST nem megfelelõ. Hiba a hardver tesztben. 1 rövid 
	és 2 hosszú csipogás: video hiba. 1) Video ROM BIOS, paritás hiba. 
	2) Probléma a videokártya vízszintes visszatérésével. 1 hosszú és 3 
	rövid csipogás: video hiba. 1) videokártya hiba. 2) a monitor 
	hibás detektálása. 3) Video RAM hiba. 1 hosszú csipogás: a POST rendben 
	lefutott. Ha a POST-ban hiba lép fel, akkor hardverprobléma van. Ellenõrizd 
	a bõvítõkártyák érintkezését 
      </P
><P
>&#13;        A témáról olvashatsz a 
        <A
HREF="http://www.preggers.easynet.be/lilo.html"
TARGET="_top"
>&#13;          http://www.preggers.easynet.be/lilo.html 
        </A
>
	honlapon.
      </P
><P
>&#13;        Ha a LILO-val vannak problémák, olvasd el a következõ tippeket. Ha a betöltés 
	közben a "L0101010101010101 ...." hibával találkozol, akkor a következõket tedd:
        <P
></P
><UL
><LI
><P
>&#13;              A kedvenc szövegszerkesztõddel nyisd meg a /etc/lilo.conf fájlt:
              <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;# keresd meg a következõ sort:
linear
# tegyél elé megjegyzés jelet (kettõs keresztet - a lektor), hogy így nézzen ki:
# linear
Mentsd el és futtasd a lilo-t.
      </PRE
></FONT
></TD
></TR
></TABLE
>
            </P
></LI
><LI
><P
>&#13;              A boot-partíciónak a 8GB-os határon belül kell lennie. Ha problémád van, 
	      olyan programokkal, mint a Partition Magic vagy a Mandrake-féle DiskDrake, 
	      könnyen orvosolhatod. 
            </P
></LI
><LI
><P
>&#13;              A 01 a DRAM frissítési hiba. Ha csak szimplán "L 01"-et látsz, 
	      indíts újra a gépet a CTRL+ATL+DEL kombinációval (viszont ne kapcsold 
	      ki a gépet, csak CTRL+ATL+DEL-t nyomj). Ez javíthatja a problémát. 
            </P
></LI
></UL
>
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1199"/>16.3. Egy LILO beállítófájl minta</H3
><P
>&#13;        Mindig adj egy dátumra vonatkozó kiterjesztést a fájlnévhez, mert ez jelzi, 
	mikor készítetted a rendszermagot, amint alább is látható: 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# man lilo
	bash# man lilo.conf
	Szerkeszd az /etc/lilo.conf fájlt és rakd be ezeket a sorokat: 
		image=/boot/bzImage.myker.26mar2001 
		label=myker
		root=/dev/hda1 
		read-only 
	Az eszköznevet a "root=" számára a következõ paranccsal ellenõrizheted: 
		bash# df   / 
	Most add ki a következõ parancsokat: 
		bash# lilo 
		bash# lilo -q 
      </PRE
></FONT
></TD
></TR
></TABLE
>
        Akkor is újra kell futtatnod a lilo-t, ha a "myker" bejegyzés létezik, 
	valahányszor új bzImage fájlt készítesz. 
      </P
><P
>&#13;        Alább egy példa /etc/lilo.conf látható. Az elnevezési szabályokat is követheted, 
	mint ker2217 (a 2.2.17-es rendszermaghoz), ker2214 (a 2.2.14-hez). Sok rendszermag 
	fájlod lehet ugyanabban a /boot rendszerben. Az én gépemen valami hasonló van: 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	boot=/dev/hda
	map=/boot/map
	install=/boot/boot.b
	prompt
	timeout=50
	default=firewall
	image=/boot/vmlinuz-2.2.14-5.0
		label=ker2214
		read-only
		root=/dev/hda9
	image=/boot/vmlinuz-2.2.17-14
		label=ker2217
		read-only
		root=/dev/hda9
	#image=/usr/src/linux/arch/i386/boot/bzImage 
	#	label=myker 
	#	root=/dev/hda7
	#	read-only 
	image=/boot/bzImage.myker.11feb2001
		label=myker11feb 
		root=/dev/hda9
		read-only 
	image=/boot/bzImage.myker.01jan2001
		label=myker01jan 
		root=/dev/hda9
		read-only 
	image=/boot/bzImage.myker-firewall.16mar2001
		label=firewall 
		root=/dev/hda9
		read-only 
      </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR/><H2
CLASS="sect1"
><A
NAME="grubconf"/>17. "C" függelék - GRUB részletesen, grub.conf mintafájl</H2
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
NAME="AEN1207"/>17.1. GRUB forrásanyagok</H3
><P
>&#13;        Olvasd a 
        <P
></P
><UL
><LI
><P
>&#13;              <A
HREF="http://www.tldp.org/HOWTO/Linux+Win9x+Grub-HOWTO/intro.html"
TARGET="_top"
>&#13;                "http://www.tldp.org/HOWTO/Linux+Win9x+Grub-HOWTO/intro.html" 
              </A
>
	      (<A
HREF="http://tldp.fsf.hu/HOWTO/Linux+Win9x+Grub-HOWTO-hu.html"
TARGET="_top"
>&#13;                "http://tldp.fsf.hu/HOWTO/Linux+Win9x+Grub-HOWTO-hu.html" 
              </A
>)
	      dokumentumot. 
            </P
></LI
><LI
><P
>&#13;              GNU GRUB 
              <A
HREF="http://www.gnu.org/software/grub"
TARGET="_top"
>&#13;                "http://www.gnu.org/software/grub" 
              </A
>
            </P
></LI
><LI
><P
>&#13;              <A
HREF="http://www.redhat.com/docs/manuals/linux/RHL-7.2-Manual/ref-guide/ch-grub.html"
TARGET="_top"
>&#13;                Redhat Manual 
              </A
>
              (RedHat kézikönyv). 
            </P
></LI
><LI
><P
>&#13;              <A
HREF="http://www.tldp.org/HOWTO/mini/Multiboot-with-GRUB.html"
TARGET="_top"
>&#13;                Multiboot-with-GRUB minihowto 
              </A
>
            </P
></LI
><LI
><P
>&#13;              <A
HREF="http://www.mcc.ac.uk/grub/grub_toc.html"
TARGET="_top"
>&#13;                Grub Manual 
              </A
>
	      (Grub kézikönyv)
            </P
></LI
></UL
>
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# man grub
	bash# man grubby   # (parancssoros eszköz a grub, lilo, és elilo beállításához)
	bash# man grub-install
      </PRE
></FONT
></TD
></TR
></TABLE
>
        Szerkeszd az /etc/grub.conf fájlt, az új rendszermagok bejegyzéseinek létrehozásához. 
	Lásd az alábbi mintafájlt: 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1228"/>17.2. GRUB tippek</H3
><P
>&#13;        A RedHat Linuxban a grub képernyõjénél állva nyomj egy c-t a 
	parancssori kapcsolók megtekintéséhez: 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	A Linux betöltéséhez tedd ezt:
    grub&gt; help
	  
    grub&gt; root
        (hd1,1): Filesystem is type ext2fs, partition type 0x83
    grub&gt; root (hd1,0)
	  
    grub&gt; kernel / &lt;Nyomj-TAB-ot&gt;
    Kilistázza az összes fájlt.
	  
    grub&gt; kernel /boot &lt;Nyomj-TAB-ot&gt;
    Kilistázza a /boot könyvtár tartalmát.
	  
    grub&gt; kernel /boot/vmlinuz
	  
    grub&gt; boot
      </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
><P
>&#13;        Errõl a 
        <A
HREF="http://www.gnu.org/manual/grub/html_mono/grub.html"
TARGET="_top"
>&#13;          GRUB Manual 
        </A
>
        (GRUB kézikönyv) dokumentációban is olvashatsz. A MS Windows 95/2000 stb. 
	betöltéséhez tedd ezt: ha nem támogatott operációs rendszert (például 
	Windows 95) akarsz betölteni, csinálj betöltési láncot (chain-load) az 
	operációs rendszer betöltõjéhez. Normál esetben a rendszerbetöltõt 
	annak a partíciónak a boot szektora tartalmazza, amelyikre az operációs 
	rendszert telepítettük. 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	grub&gt; help
	grub&gt; help rootnoverify
	grub&gt; rootnoverify (hd0,0)
	grub&gt; makeactive
	grub&gt; chainloader +1
	grub&gt; boot
      </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1235"/>17.3. Egy GRUB beállítófájl minta</H3
><P
>&#13;        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	# grub.conf generated by anaconda
	#
	# Figyeld meg, hogy nem kell ujrafuttatni a grub-ot, ha valtoztatsz a fajlon
	# FIGYELEM: nincs /boot particiod. Ez azt jelenti, hogy minden rendszermag es
	# initrd utvonal a / könyvtárhoz viszonyitott, például: 
	#          root (hd0,8)
	#          kernel /boot/vmlinuz-version ro root=/dev/hda9
	#          initrd /boot/initrd-version.img
	#boot=/dev/hda
	# Alapertelmezesben a masodik bejegyzes inditasa.
	default=1
	# Az elso bejegyzes a biztonsagi tartalek.
	fallback 0
	# Automatikus betoltes 2 perc elteltevel.
	timeout=120
	splashimage=(hd0,8)/boot/grub/splash.xpm.gz
	title Windows 2000 
	unhide (hd0,0)
	hide (hd0,1)
	hide (hd0,2)
	rootnoverify (hd0,0)
	chainloader +1
	makeactive
	title Red Hat Linux (2.4.18-19.8.0.19mar2003)
		root (hd0,8)
		kernel /boot/bzImage.2.4.18-19.8.0.19mar2003 ro root=LABEL=/ hdd=ide-scsi
		initrd /boot/initrd-2.4.18-19.8.0custom.img.19mar03
	title Red Hat Linux (2.4.18-19.8.0custom)
		root (hd0,8)
		kernel /boot/vmlinuz-2.4.18-19.8.0custom ro root=LABEL=/ hdd=ide-scsi
		initrd /boot/initrd-2.4.18-19.8.0custom.img
	title Red Hat Linux (2.4.18-14)
		root (hd0,8)
		kernel /boot/vmlinuz-2.4.18-14 ro root=LABEL=/ hdd=ide-scsi
		initrd /boot/initrd-2.4.18-14.img
	title MyKernel.26jan03 (Red Hat Linux 2.4.18-14)
		root (hd0,8)
		kernel /boot/bzImage.myker.26jan03 ro root=LABEL=/ hdd=ide-scsi
		initrd /boot/initrd-2.4.18-19.8.0.img
	title Windows 98
	hide (hd0,0)
	hide (hd0,1)
	unhide (hd0,2)
	rootnoverify (hd0,2)
	chainloader +1
	makeactive
	title DOS 6.22
	hide (hd0,0)
	unhide (hd0,1)
	hide (hd0,2)
	rootnoverify (hd0,1)
	chainloader +1
	makeactive
	title Partition 2 (floppy)
	hide (hd0,0)
	unhide (hd0,1)
	hide (hd0,2)
	chainloader (fd0)+1
	title Partition 3 (floppy)
	hide (hd0,0)
	hide (hd0,1)
	unhide (hd0,2)
	chainloader (fd0)+1
      </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR/><H2
CLASS="sect1"
><A
NAME="post_kernel_building"/>18. "D" függelék - utólagos rendszermag fordítás</H2
><P
>&#13;      Miután sikeresen felépítettük (build) és betöltöttük a Linux-rendszermagot, a 
      következõ kiegészítõ lépésekre azért van szükség, hogy bizonyos eszközöket 
      mûködésre bírjunk Linux alatt. (Az alábbi lépéseket RedHat Linuxon teszteltük, 
      de más terjesztésekkel is mûködnie kell.)
    </P
><P
>&#13;      <EM
>&#13;        Videokártya/Monitor beállítása:
      </EM
>
      <P
></P
><UL
><LI
><P
>&#13;            Nézd meg a videokártya leírását, amit általában együtt szállítanak a PC-vel. 
	    Keresd meg a "Technical Specifications" ("Technikai paraméterek") oldalt. 
          </P
></LI
><LI
><P
>&#13;            Nézd meg a monitor leírását, és keresd meg a "Technical 
            Specifications" ("Technikai paraméterek") oldalt. 
          </P
></LI
></UL
>
    </P
><P
>&#13;      Ha a legújabb Linuxot (2.4 vagy késõbbi) használod, kattints a KDE/GNOME 
      munkaasztalon belül a Start-&gt;"System Settings"-&gt;Display menüpontra. 
    </P
><P
>&#13;      A Linux régebbi verzióinál kövesd az alábbi lépéseket: 
    </P
><P
>&#13;      A videokártyát és a monitort a következõ parancsokkal állíthatod be: 
      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash$ su - root
	bash# man Xconfigurator
	bash# /usr/bin/X11/Xconfigurator --help
	bash# /usr/bin/X11/Xconfigurator 
	bash# /usr/bin/X11/Xconfigurator --expert
	See also:
	bash# man xf86config
	bash# /usr/bin/X11/xf86config
      </PRE
></FONT
></TD
></TR
></TABLE
>
      Ha a kártyádat nem ismerte fel automatikusan a rendszer, akkor használhatod a 
      --expert opciót, és válaszd az "Unlisted card" (fel nem sorolt kártya) menüpontot. 
      Ha a monitorod nincs felsorolva, akkor válaszd az általános SVGA 1024x768 típust. 
    </P
><P
>&#13;      <EM
>&#13;        Hangkártya beállítása: 
      </EM
>
      <P
></P
><UL
><LI
><P
>&#13;            Kösd be a külsõ hangszórókat a hangkártya kimentére. 
          </P
></LI
><LI
><P
>&#13;            Kösd össze a CD-ROM audiokábelét a hangkártya 4 tûs audio-aljzatával. 
	    (Egyébként a zenei CD-ket nem fogod hallani a kártyával.) 
          </P
></LI
><LI
><P
>&#13;            Olvasd a hanggal foglalkozó HOGYANokat a 
            <A
HREF="http://www.tldp.org"
TARGET="_top"
>&#13;              "http://www.tldp.org" 
            </A
>
	    webhelyen (továbbá a <A
HREF="http://tldp.fsf.hu/HOWTO/HOWTO-INDEX/hardware.html#HWSOUND"
TARGET="_top"
>&#13;              "HOGYAN-INDEX - MIDI, hangkártyák" 
            </A
> honlapon - a lektor). 
          </P
></LI
></UL
>
      Ha a legújabb Linuxot (2.4 vagy késõbbi) használod, kattints a KDE/GNOME 
      munkaasztalon belül a Start-&gt;"System Settings"-&gt;Soundcard Detection menüpontra.
    </P
><P
>&#13;      A régebbi Linux verzióknál kövesd az alábbi lépéseket: 
    </P
><P
>&#13;      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash$ su - root
	bash# man sndconfig
	bash# /usr/sbin/sndconfig
      </PRE
></FONT
></TD
></TR
></TABLE
>
      Majd indítsd el az X-Window rendszer "KDE-munkaasztalát" a "startx" paranccsal. 
      Kattints a "K Start-&gt;ControlCenter-&gt;SoundServer-&gt;General-&gt;Test Sound" 
      menüpontra. Ennek le kell játszania a teszthangot. Aztán kattints a 
      "K Start-&gt;MultiMedia-&gt;SoundMixer-&gt;SoundVolumeSlider" menüpontra és állítsd be 
      a hangerõt. 
    </P
><P
>&#13;      <EM
>&#13;        Hálózati kártya beállítása: 
      </EM
>
      Ha a legújabb Linuxot (2.4 vagy késõbbi) használod, kattints a KDE/GNOME 
      munkaasztalon belül a Start-&gt;"System Settings"-&gt;Network menüpontra. 
    </P
><P
>&#13;      A régebbi Linux verzióknál kövesd az alábbi lépéseket: 
    </P
><P
>&#13;      <P
></P
><UL
><LI
><P
>&#13;            Használd az /sbin/linuxconf programot 
          </P
></LI
><LI
><P
>&#13;            vagy a KDE vezérlõpultot 
          </P
></LI
><LI
><P
>&#13;            Olvasd a hálózattal foglalkozó HOGYANokat a 
            <A
HREF="http://www.tldp.org"
TARGET="_top"
>&#13;              "http://www.tldp.org" 
            </A
>
	    webhelyen (továbbá a <A
HREF="http://tldp.fsf.hu/HOWTO/HOWTO-INDEX/networking.html"
TARGET="_top"
>&#13;              "HOGYAN-INDEX - Hálózat" 
            </A
> honlapon - a lektor). 
          </P
></LI
></UL
>
    </P
><P
>&#13;      <EM
>&#13;        Tûzfal és IP-álcázás beállítása: 
      </EM
>
      A rendszermag 2.4-es és a feletti verzióinál a tûzfal és az IP-álcázás a NetFilter 
      csomaggal lett megvalósítva. Ezért a rendszermag beállítása közben engedélyezned 
      kell a Netfilter-t és futtatni a tûzfal/IPmaszk szkripteket. Töltsd le a szkripteket a 
      <A
HREF="http://www.BoingWorld.com/workshops/linux/iptables-tutorial"
TARGET="_top"
>&#13;        Firewall-IPMasq scripts 
      </A
>
      honlapról, a NetFilter címoldalát a 
      <A
HREF="http://netfilter.samba.org"
TARGET="_top"
>&#13;        "http://netfilter.samba.org" 
      </A
>
      webhelyen találod. Idevágó anyagokat találsz a 
      <A
HREF="http://www.linuxsecurity.com/feature_stories/kernel-netfilter.html"
TARGET="_top"
>&#13;        firewalling-matures 
      </A
>
      és 
      <A
HREF="http://netfilter.filewatcher.org/netfilter-faq.html"
TARGET="_top"
>&#13;        Netfilter-FAQ 
      </A
>
      honlapokon (valamint magyarul, a 
      <A
HREF="http://doc.skylinux.org/"
TARGET="_top"
>&#13;        Firewall LDP Team 
      </A
> webhelyén - a lektor). 
    </P
><P
>&#13;      
      A 2.4 alatti verziókhoz telepítheted a tûzfal rpm csomagjait a 
      <A
HREF="http://rpmfind.net/linux/rpm2html/search.php?query=firewall"
TARGET="_top"
>&#13;        rpmfind.net 
      </A
>
      vagy a
      <A
HREF="http://rpmfind.net/linux/RPM/contrib/noarch//SRPMS//firewall-2.2-3.src.html"
TARGET="_top"
>&#13;        firewall.src.rpm 
      </A
>
      honlapról. 
    </P
><P
>&#13;      <EM
>&#13;        Egyéb eszközök beállítása: 
      </EM
>
      Olvasd az ezzel foglalkozó HOGYANokat a 
      <A
HREF="http://www.tldp.org"
TARGET="_top"
>&#13;        "http://www.tldp.org" 
      </A
>
      webhelyen (továbbá a <A
HREF="http://tldp.fsf.hu/HOWTO/HOWTO-INDEX/hardware.html"
TARGET="_top"
>&#13;      "HOGYAN-INDEX - Hardver"</A
> honlapon - a lektor). 
    </P
></DIV
><DIV
CLASS="sect1"
><HR/><H2
CLASS="sect1"
><A
NAME="troubleshoot"/>19. "E" függelék - a gyakori hibák elhárítása</H2
><DIV
CLASS="sect2"
><H3
CLASS="sect2"
><A
NAME="AEN1296"/>19.1. A rendszermag rendben elkészül, de a "make modules" nem sikerül</H3
><P
>&#13;        Jelenség: A rendszermag elkészül, és elkészül a bzImage, de a "make modules" 
	már nem sikerül. 
      </P
><P
>&#13;        Megoldás: Ez a legtrükkösebb probléma, számos oka lehet. Ilyenek 
	például a Linux terjesztés maga, nem frissített csomagfüggõségek. 
	Ez nagyon jellemzõ a RedHat terjesztésre, de másiknál is elõfordulhat. 
	Okozhatja továbbá néhány "ott felejtett" fájl is, amelyek felfüggesztik 
	a programfordítási folyamatot, ezáltal problémát okoznak. Ennek ellenszere 
	a "make mrproper" és "make clean", majd a "make modules" parancs kiadása. 
	Szükséged lehet a beállítási fájlok mentésére, alább látható ennek menete: 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;bash# cd /usr/src/linux 
bash# mkdir /usr/src/kernelconfigs ;
bash# cp /usr/src/linux/.config  /usr/src/kernelconfigs/.config.save;
bash# cp /usr/src/linux/.config  /usr/src/linux/configs/.config.save  # Különösen biztonságos
bash# cp /boot/config*  /usr/src/linux/configs/  # Különösen biztonságos
bash# make clean
bash# make mrproper  # "EL KELL VÉGEZNED ezt az mrproper-t", különben pokolian sok problémával 
                     # kell szembenézned
bash# make clean
bash# cp /usr/src/kernelconfigs/.config.save .config  # abban az esetben, ha újra fel akarod 
                                                      # használni a beállítófájlt ??
	  	</PRE
></FONT
></TD
></TR
></TABLE
>
      </P
><DIV
CLASS="sect3"
><HR/><H4
CLASS="sect3"
><A
NAME="AEN1301"/>19.1.1. Nem megfelelõ beállítófájl</H4
><P
>&#13;          Ha az elõzõ bekezdésben ajánlott "make mrproper" nem oldja meg a 
	  problémát, egyéb körmönfont probléma ejtett csapdájába. Talán 
	  valami komoly hiba van a beállítófájlban. Talán nem a processzorodnak 
	  megfelelõ beállítófájlból indultál ki (talán ATHLON CPU típust 
	  választottál Pentium vagy Cyrix CPU típust Athlon processzoros 
	  gépedhez) Kezdd elölrõl az egészet, ha Athlon CPU-s az athlon.config 
	  vagy ha Intel 696 CPU-s géped géped van az i686.config fájlt másold le. 
	  Töltsd le az aktuális beállítófájlt az /usr/src/linux/configs könyvtárból 
          <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# cp /usr/src/linux/configs/kernel-2.4.18-i686.config  /usr/src/linux/.config
	Vagy Athlon processzorok esetében 
	bash# cp /usr/src/linux/configs/kernel-2.4.18-athlon.config  /usr/src/linux/.config
			  </PRE
></FONT
></TD
></TR
></TABLE
>
          Kövesd a <A
HREF="#quick_steps"
TARGET="_top"
>Gyors lépések - a rendszermag fordítása</A
>
	  fejezetben leírtakat. 
        </P
></DIV
><DIV
CLASS="sect3"
><HR/><H4
CLASS="sect3"
><A
NAME="AEN1306"/>19.1.2. A csomagok nincsenek szinkronban</H4
><P
>&#13;          Még mindig problémáid vannak? Ha a fenti bekezdésben leírtak nem oldották 
	  meg a problémát, egyéb körmönfont probléma ejtett csapdájába. Biztos vagy 
	  benne, hogy az összes csomagfüggõség rendben van? Az összes függõ csomag 
	  szinkronban van a többivel? Telepítettél csomagot a "--nodeps" kapcsolóval? 
	  Automatizálhatod a csomagfüggõségek feloldását egy olyan nagyszerû 
	  eszközzel, mint az apt-get (Olvasd el a <A
HREF="#apt-get"
TARGET="_top"
>Telepítés, frissítés fénysebességgel</A
> 
	  fejezetet.) Kézzel szinkronban tartani csomagok és programozói könyvtárak 
	  százait fene nagy munka, használd az apt-get programot. 
        </P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1310"/>19.2. A programfordítás rendben megtörténik, de a rendszermag nem indul</H3
><P
>&#13;        Jelenség: ha a rendszermag rendben lefordul, de nem töltõdik be és mindig 
	rendszermag pánikra panaszkodik valahol az /sbin/modprobe körül. 
      </P
><P
>&#13;        Megoldás: nem készítetted el az initrd fájlt. Olvasd el az 
	<A
HREF="#create_initrd"
TARGET="_top"
>"A" függelék - initrd.img fájl készítése</A
>
	fejezetet. 
      </P
><P
>&#13;        Az initrd elkészítésén kívül, ki kell adnod egy "make modules" és "make modules_install" 
	parancsot. Még ha ki is adtad a "make modules" parancsot elõtte, próbáld meg másodszor 
	is lefuttatni (nem árthat). Add ki a "make modules" és "make modules_install" parancsokat 
	még egyszer, hogy teljesen megbizonyosodj arról, miszerint a betölthetõ modulok a 
	helyükre kerültek. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1316"/>19.3. A rendszer mûködése felfüggesztõdik a LILO-nál</H3
><P
>&#13;        <EM
>&#13;          Jelenség: 
        </EM
>
        Miután felépítetted a rendszermagot és újraindítottál, a rendszer várakozik épp a 
	LILO elõtt. 
      </P
><P
>&#13;        <EM
>&#13;          Ok: 
        </EM
>
        Valószínûleg nem állítottad be a BIOS-ban a megfelelõ elsõdleges mester 
	IDE és másodlagos szolga IDE merevlemez partíciót. 
      </P
><P
>&#13;        <EM
>&#13;          Megoldás: 
        </EM
>
        Kapcsold be a gépet és nyomd meg a DEL gombot a BIOS (Basic Input 
	Output System) Setup menübe történõ belépéshez. Válaszd az IDE 
	beállításokat és állítsd be a megfelelõ elsõdleges merevlemez 
	partíciót és a szolga-meghajtókat. Amikor a rendszer indul, 
	megkeresi az elsõdleges IDE merevlemezt és a Master Boot Record 
	partíciót. Kiolvassa az MBR-t és elkezdi betölteni a Linux-rendszermagját 
	a merevlemez partíciójáról. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1324"/>19.4. No init found (nem található init)</H3
><P
>&#13;        A következõ hibát gyakran követik el a kezdõ felhasználók. 
      </P
><P
>&#13;        Ha az új rendszermagod nem indul el, és a következõt hibaüzenetet kapod: 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	Warning: unable to open an initial console
	Kernel panic: no init found. Try passing init= option to kernel
        </PRE
></FONT
></TD
></TR
></TABLE
>
        Az a probléma, hogy 
        <EM
>&#13;          nem állítottad be megfelelõen 
        </EM
>
        a "root=" paramétert az /etc/lilo.conf fájlban. Az én esetemben, a 
	root=/dev/hda1 partíciót használom, amin a gyökér "/" partíció van. 
	Jól kell beállítanod a root-eszközt, olyasminek kell lennie, mint 
	/dev/hdb2 vagy /dev/hda7. 
      </P
><P
>&#13;        Lehetnek hibák ez elõtt a rendszermag pánik elõtt is. Nézd meg és 
	olvasd el a lehetséges hibaüzeneteket a "Kernel panic:" felirat elõtt. 
	A hibát okozhatja bármely ez elõtti hiba is (összegzõdõ hatás). 
	Például a "Kernel panic:" hibaüzenet elõtt láthatsz olyat is, hogy 
	"kernel-module version mismatch" (a rendszermag-modul verzió nem egyezik) 
	vagy "ilyen-olyan-egyéb-hibaüzenet"-eket is. Próbáld meg az ELSÕ, 
	rendszer által jelzett hibát kijavítani. 
      </P
><P
>&#13;        A rendszermag az init parancsot az /sbin/init alatt keresi. Az /sbin könyvtár 
	pedig a gyökér-partíción van. További részleteket a 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# man init
        </PRE
></FONT
></TD
></TR
></TABLE
>
        parancs kiadásával, valamint a 
        <A
HREF="#grubconf"
TARGET="_top"
>"C" függelék - GRUB részletesen, grub.conf mintafájl</A
>
        és 
        <A
HREF="#liloconf"
TARGET="_top"
>"B" függelék - lilo.conf mintafájl</A
>
        fejezetek olvasásával tudhatsz meg. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1335"/>19.5. Csomó fordítási hiba (compile error)</H3
><P
>&#13;        A "make", "make bzImage", "make modules" vagy "make modules_install" 
        fordítási hibákat jelez. Add ki a "make mrproper" parancsot a "make" 
	parancs kiadása elõtt. 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# make clean &amp;&amp; make mrproper # "KÖTELEZÕ KIADNOD AZ mrproper parancsot", egyébként problémák százai jelentkeznek! 
        </PRE
></FONT
></TD
></TR
></TABLE
>
        Ha a probléma változatlanul fennáll, próbáld ki a "menuconfig"-ot 
	az "xconfig" helyett. Néha a GUI adott verziója problémázik az "xconfig"-al:
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# export TERM=VT100
	bash# make menuconfig  # Újabb, az "ncurses"/"curses"-t használja, ha nincs telepítve nem mûködik 
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1340"/>19.6. A "depmod" parancs "Unresolved symbol error messages" hibaüzenetet ír ki</H3
><P
>&#13;        A 
        <TT
CLASS="literal"
>&#13;          depmod 
        </TT
>
        parancs futásakor "Unresolved symbols" hibaüzenetet ír ki. Az alábbi példa 
	mutatja be az esetet: 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash$ su - root
	bash# man depmod
	bash# depmod
	depmod: *** Unresolved symbols in /lib/modules/version/kernel/drivers/md/linear.o
	depmod: *** Unresolved symbols in /lib/modules/version/kernel/drivers/md/multipath.o
	depmod: *** Unresolved symbols in /lib/modules/version/kernel/drivers/md/raid0.o
	depmod: *** Unresolved symbols in /lib/modules/version/kernel/drivers/md/raid1.o
	depmod: *** Unresolved symbols in /lib/modules/version/kernel/drivers/md/raid5.o
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
><P
>&#13;        <EM
>&#13;          Ok: 
        </EM
>
        Nem fordítottad és telepítetted a modulokat az új 
	rendszermag elkészítése (
        <TT
CLASS="literal"
>&#13;          "make bzImage" 
        </TT
>
         ) után. 
      </P
><P
>&#13;        <EM
>&#13;          Megoldás: 
        </EM
>
        Az új rendszermag elkészítése után muszáj ezt tenned: 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash$ su - root
	bash# cd /usr/src/linux
	bash# make modules
	bash# make modules_install
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1351"/>19.7. A rendszermag nem tölti be a modult, "Unresolved symbols" hibaüzenetet ír ki</H3
><P
>&#13;        Amikor betöltöd a rendszert, és az bármely modult megpróbálva betölteni a 
	"Unresolved symbol : __some_function_name" üzenetet ír ki, akkor ez azt jelenti, 
	hogy nem "tiszta helyzetbõl kiindulva" fordítottad a modulokat és 
	a rendszermagot. Elengedhetetlen, a 
        <EM
>&#13;          make clean 
        </EM
>
        parancs kiadása, majd a modulok fordítása. Ezt az 
	alábbi parancsok kiadásával teheted meg: 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;		bash# cd /usr/src/linux
		bash# make dep
		bash# make clean
		bash# make mrproper  # "MUST DO THIS mrproper", otherwise you will face hell lot of problems !!
		bash# make clean
		bash# nohup make bzImage &amp;  
		bash# tail -f nohup.out     (.... to monitor the progress) 
		bash# make modules
		bash# make modules_install
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1356"/>19.8. A rendszermag nem tud betölteni egy modult</H3
><P
>&#13;        Ha a rendszermag nem tud betölteni egy modult (mondjuk egy hálózati 
	kártyáét vagy más eszközét), akkor megpróbálhatod az eszközt közvetlenül 
	a rendszermagba fordítani. Néha a 
        <EM
>&#13;          <EM
>&#13;            betölthetõ modul NEM mûködik 
          </EM
>
        </EM
>
        és a meghajtót fixen a rendszermagba kell fordítani. 
	Például - néhány hálózati kártya nem támogatja a betölthetõ modul 
	szolgáltatást - egybõl a rendszermagba KELL fordítanod. Ezért a 
	"make xconfig"-ban NEM SZABAD a betölthetõ modul opciót választani 
	ehhez az eszközhöz. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1361"/>19.9. Betölthetõ modulok</H3
><P
>&#13;        Az alapértelmezett betölthetõ modulokat telepítheted így: 
      </P
><P
>&#13;        Az alább megadott lépés nem szükséges, de 
        <EM
>&#13;          HIBA ESETÉN SZÜKSÉG LEHET RÁ 
        </EM
>
        , amikor a /lib/modules fájljai megsérültek. Ha már létezik a /lib/modules 
	könyvtár, és ki akarod cserélni a tartalmát, használd a "--force" kapcsolót 
	a csomag lecseréléséhez és válaszd a megfelelõ CPU architektúrát. 
      </P
><P
>&#13;        A RedHat Linux új verzióiban (mint a 6.0 vagy késõbbi) a rendszermag-modulokat 
	a kernel-2.2*.rpm tartalmazza. Telepítsd a rendszermagot és a modulokat: 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;		Ez kilistázza a már telepített csomagokat. 
	bash# rpm -qa | grep -i kernel
		
	bash# rpm -U --force  /mnt/cdrom/Redhat/RPMS/kernel-2.2.14-5.0.i686.rpm
	(or)
	bash# rpm -U --force  /mnt/cdrom/Redhat/RPMS/kernel-2.2.14-5.0.i586.rpm
	(or)
	bash# rpm -U --force  /mnt/cdrom/Redhat/RPMS/kernel-2.2.14-5.0.i386.rpm
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
><P
>&#13;        Ez csak a régi, 5.2 és az elõtti verziókhoz szól. Indíts az új rendszermaggal 
	és telepítsd a betölthetõ modulokat a RedHat "contrib" CD-ROM-ról: 
        cdrom 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash# rpm -i /mnt/cdrom/contrib/kernel-modules*.rpm 
	....(A régi Linux rendszerekhez, amikben nincs elõre telepítve az insmod) 
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1370"/>19.10. Olvasd el a dokumentációt</H3
><P
>&#13;        Ha további problémák vannak, elolvashatod az /usr/src/linux/README 
	(legalább egyszer), valamint az /usr/src/linux/Documentation  fájlt is. 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;	bash [/] # cd /usr/src/linux/Documentation

	bash [/usr/src/linux/Documentation] # ls *.txt

	binfmt_misc.txt  ioctl-number.txt           nbd.txt               serial-console.txt
	cachetlb.txt     IO-mapping.txt             nfsroot.txt           sgi-visws.txt
	cciss.txt        IRQ-affinity.txt           nmi_watchdog.txt      smart-config.txt
	computone.txt    isapnp.txt                 oops-tracing.txt      smp.txt
	cpqarray.txt     java.txt                   paride.txt            sonypi.txt
	devices.txt      kernel-doc-nano-HOWTO.txt  parport-lowlevel.txt  specialix.txt
	digiboard.txt    kernel-docs.txt            parport.txt           spinlocks.txt
	digiepca.txt     kernel-parameters.txt      pci.txt               stallion.txt
	DMA-mapping.txt  kmod.txt                   pcwd-watchdog.txt     svga.txt
	dnotify.txt      locks.txt                  pm.txt                swsusp.txt
	exception.txt    logo.txt                   ramdisk.txt           sx.txt
	floppy.txt       magic-number.txt           riscom8.txt           sysrq.txt
	ftape.txt        mandatory.txt              rtc.txt               unicode.txt
	hayes-esp.txt    mca.txt                    SAK.txt               VGA-softcursor.txt
	highuid.txt      md.txt                     sched-coding.txt      watchdog-api.txt
	i810_rng.txt     memory.txt                 sched-design.txt      watchdog.txt
	ide.txt          modules.txt                scsi-generic.txt      zorro.txt
	initrd.txt       mtrr.txt                   scsi.txt
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1374"/>19.11. make clean</H3
><P
>&#13;        Ha az új rendszermag valóban furcsa dolgokat csinál egy rutinszerû frissítés 
	után, esélye van annak, hogy elfelejtetted kiadni a 
        <TT
CLASS="literal"
>&#13;          make clean 
        </TT
>
        parancsot az új rendszermag fordítása elõtt. A jelenségek kiterjedhetnek 
	bármire az egybõli lefagyástól, a különös I/O hibákon át a csapnivaló 
	teljesítményig. Bizonyosodj meg, hogy kiadtad a 
        <TT
CLASS="literal"
>&#13;          make dep 
        </TT
>
        parancsot is. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1379"/>19.12. Óriási vagy lassú rendszermag</H3
><P
>&#13;        Ha a rendszermagod sok memóriát zabál, túl nagy, és/vagy örökké tart a 
	programfordítása még az új Quadbazillium-III/4400-as gépeden is, 
	akkor valószínûleg sok felesleges cuccot (eszközmeghajtót, fájlrendszert stb.) 
	tettél bele. Ha nem használod, ne állítsd be, mivel memóriát foglal. 
	A legkézenfekvõbb jelenség a rendszermag felfúvódására a memória állandó 
	oda- visszatöltése a lemezrõl; ha a lemezed sok zajt bocsát ki, és nem egyike 
	a régi Fujitsu Eagles-eknek (ami kikapcsoláskor olyan hangot ad ki, 
	mint egy leszálló repülõgép), akkor nézd át a beállításaidat. 
      </P
><P
>&#13;        Megállapíthatod, hogy mennyi memóriát használ a rendszermag, 
	ha veszed a teljes memóriamennyiséget és kivonod belõle a 
	"total mem" értékét, amit a 
        <TT
CLASS="literal"
>&#13;          /proc/meminfo 
        </TT
>
        mutat, vagy a "
        <TT
CLASS="literal"
>&#13;          free 
        </TT
>
        " parancs. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1385"/>19.13. A párhuzamos port/nyomtató nem mûködik</H3
><P
>&#13;        A PC-k beállítási lépései: elõször is, a "General Setup" kategóriában válaszd a "
	Parallel port support" és "PC-style hardware" beállításokat. 
	Aztán a "Character devices" alatt, válaszd a "Parallel printer support"-ot. 
      </P
><P
>&#13;        Ezután következnek a nevek. A Linux 2.2 máshogy nevezi a nyomtatóeszközöket, 
	mint a korábbi kiadások. Ennek az a következménye, hogy ha
        <TT
CLASS="literal"
>&#13;          lp1 
        </TT
>
        eszközöd van a régi rendszermag alatt, ez valószínûleg 
        <TT
CLASS="literal"
>&#13;          lp0 
        </TT
>
        az új verziónál. Használd a " 
        <TT
CLASS="literal"
>&#13;          dmesg 
        </TT
>
        parancsot , vagy nézd meg a naplókat a 
        <TT
CLASS="literal"
>&#13;          /var/log 
        </TT
>
        könyvtárban, hogy kiderítsd az eszköz nevét. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1393"/>19.14. A rendszermag nem fordul le</H3
><P
>&#13;        Ha nem fordul le, akkor lehetséges, hogy egy foltozás nem sikerült, 
	vagy a forrásod valamiért nem jó. A gcc verziód szintén nem biztos, 
	hogy megfelelõ, vagy szintén nem jó (például az include fájlok 
	lehetnek hibásak). Gyõzõdj meg, hogy a Linus által leírt szimbolikus 
	linkek, amiket a 
        <TT
CLASS="literal"
>&#13;          README 
        </TT
>
        fájlban ír le, jól vannak beállítva. Általánosan, ha egy hagyományos 
	rendszermag nem fordul le, akkor valami komoly gond van a rendszerben, 
	és bizonyos eszközök újbóli telepítése válhat szükségessé. 
      </P
><P
>&#13;        Néhány esetben, a gcc hardver problémák miatt szállhat el. A hibaüzenet 
	olyasmi lehet, hogy "xxx exited with signal 15" és ez általában nagyon 
	rejtélyesen néz ki. Valószínûleg nem említettem volna, de megtörtént velem, 
	egyszer volt egy kevés rossz cache-memóriám, és idõnként a fordító 
	véletlenszerûen elhányta magát. Elõször próbáld meg a gcc-t kicserélni, 
	ha problémád van. Kisakkozhatod, hogy lefordul-e a rendszermag a 
	külsõ gyorsítótár kikapcsolásával, csökkentett méretû RAM-mal stb. 
      </P
><P
>&#13;        Fel tudja zaklatni az embereket, ha azt mondják nekik, hogy rossz a hardverük. 
	Nos, én nem adom fel. Létezik egy GYIK is errõl, ezen a 
        <A
HREF="http://www.bitwizard.nl/sig11"
TARGET="_top"
>&#13;          "http://www.bitwizard.nl/sig11" 
        </A
>
        webhelyen. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1400"/>19.15. A rendszermag új verziója nem töltõdik be</H3
><P
>&#13;        Nem futtattad a LILO-t, vagy nincs rendesen beállítva. Egy dolog, 
	ami "megfogott" engem egyszer, egy konfigurációs fájl problémája volt: 
	ez volt benne: "
        <TT
CLASS="literal"
>&#13;          boot = /dev/hda1 
        </TT
>
        " ahelyett, hogy " 
        <TT
CLASS="literal"
>&#13;          boot = /dev/hda 
        </TT
>
        " lett volna. (Ez elõször tényleg zavaró lehet, de ha egyszer van egy mûködõ 
	beállítófájlod, nem kell megváltoztatnod). 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1405"/>19.16. Elfelejtetted futtatni a LILO-t, vagy a rendszered egyáltalán nem indul el</H3
><P
>&#13;        Hoppá! A legjobb dolog, amit ekkor tehetsz, hogy hajlékonylemezrõl vagy 
	CD-ROM-ról indítasz, és készítesz egy másik indítólemezt (amit a " 
        <TT
CLASS="literal"
>&#13;          make zdisk 
        </TT
>
        " paranccsal is megtehetsz). Tudnod kell, hol van a gyökér ( 
        <TT
CLASS="literal"
>&#13;          / 
        </TT
>
        ) fájlrendszered és milyen típusú (tehát például ext2, minix). Az alábbi 
	példában azt is tudnod kell, milyen fájlrendszeren van a 
        <TT
CLASS="literal"
>&#13;          /usr/src/linux 
        </TT
>
        forrásfád, ennek típusát, és normál esetben hova csatolódik fel. 
      </P
><P
>&#13;        A következõ példában a 
        <TT
CLASS="literal"
>&#13;          / 
        </TT
>
        a 
        <TT
CLASS="literal"
>&#13;          /dev/hda1 
        </TT
>
        , és a fájlrendszer, ami tartalmazza a 
        <TT
CLASS="literal"
>&#13;          /usr/src/linux 
        </TT
>
        könyvtárat, a 
        <TT
CLASS="literal"
>&#13;          /dev/hda3 
        </TT
>
        , normál esetben a 
        <TT
CLASS="literal"
>&#13;          /usr 
        </TT
>
        alá van felcsatolva. Mindkettõ second extended (ext2) fájlrendszer. 
	A mûködõ rendszermag helye a 
        <TT
CLASS="literal"
>&#13;          /usr/src/linux/arch/i386/boot 
        </TT
>
        könyvtár, és 
        <TT
CLASS="literal"
>&#13;          bzImage 
        </TT
>
        a neve. 
      </P
><P
>&#13;        Az ötlet az, hogy ha van egy mûködõ 
        <TT
CLASS="literal"
>&#13;          bzImage 
        </TT
>
        , akkor azt használhatod egy új hajlékonylemez készítéséhez. Egy másik lehetõséget, 
	ami vagy jobban mûködik, vagy nem (attól az egyedi módszertõl függ, amivel 
	szétbarmoltad a rendszered) beszélünk meg a példa után. 
      </P
><P
>&#13;        Elõször indíts egy boot/root lemezpárosról vagy mentõlemezrõl, 
	és csatold fel a mûködõ rendszermagot tartalmazó fájlrendszert: 
      </P
><P
>&#13;        mkdir /mnt mount -t ext2 /dev/hda3 /mnt 
      </P
><P
>&#13;        Ha az 
        <TT
CLASS="literal"
>&#13;          mkdir 
        </TT
>
        azt írja ki, hogy a könyvtár már létezik, ne törõdj vele. Most a
        <TT
CLASS="literal"
>&#13;          cd 
        </TT
>
        paranccsal lépj be arra a helyre, ahol a mûködõ rendszermag van. 
	Figyeld meg, hogy  /mnt + /usr/src/linux/arch/i386/boot - /usr = 
	/mnt/src/linux/arch/i386/boot. Helyezz egy formázott lemezt az 
	"A" meghajtóba (ne a boot vagy root lemezed!), másold ki a fájlt a 
	lemezre, és állítsd be a gyökér fájlrendszeredhez: 
      </P
><P
>&#13;        cd /mnt/src/linux/arch/i386/boot dd if=bzImage of=/dev/fd0 rdev 
        /dev/fd0 /dev/hda1 
      </P
><P
>&#13;        A 
	<TT
CLASS="literal"
>&#13;          cd 
        </TT
>
        paranccsal lépj be a 
        <TT
CLASS="literal"
>&#13;          / 
        </TT
>
        könyvtárba és válaszd le a normál 
        <TT
CLASS="literal"
>&#13;          /usr 
        </TT
>
	fájlrendszert: 
      </P
><P
>&#13;        cd / umount /mnt 
      </P
><P
>&#13;        Most már képesnek kell lenned normál módon újraindítani a rendszert errõl a 
	hajlékonylemezrõl. Ne felejtsd el futtatni a lilo-t (vagy bármi volt, amit 
	elrontottál) az újraindítás után! 
      </P
><P
>&#13;        Amint fentebb említettük, van egy másik általános lehetõség. Ha véletlenül 
	van egy mûködõ rendszermag a
        <TT
CLASS="literal"
>&#13;          / 
        </TT
>
        könyvtárban ( 
        <TT
CLASS="literal"
>&#13;          /vmlinuz 
        </TT
>
        például), használhatod azt is a indítólemezhez. Feltéve, hogy teljesül az 
	összes fenti feltétel, és a rendszermagod a 
        <TT
CLASS="literal"
>&#13;          /vmlinuz 
        </TT
>
        , csak ezeket a változásokat tedd meg a fenti példához képest: 
	változtasd meg a 
        <TT
CLASS="literal"
>&#13;          /dev/hda3 
        </TT
>
        -at 
        <TT
CLASS="literal"
>&#13;          /dev/hda1 
        </TT
>
        -re (a 
        <TT
CLASS="literal"
>&#13;          / 
        </TT
>
        fájlrendszerre), az 
        <TT
CLASS="literal"
>&#13;          /mnt/src/linux 
        </TT
>
        -ot a 
        <TT
CLASS="literal"
>&#13;          /mnt 
        </TT
>
        -re, és a 
        <TT
CLASS="literal"
>&#13;          if=bzImage 
        </TT
>
        -et 
        <TT
CLASS="literal"
>&#13;          if=vmlinuz 
        </TT
>
        -ra. A jegyzet arról, hogyan származtatjuk a 
        <TT
CLASS="literal"
>&#13;          /mnt/src/linux 
        </TT
>
        -ot, figyelmen kívül hagyható. 
      </P
><P
>&#13;        A LILO használata nagy meghajtókkal (több mint 1024 cilinderrel) 
	problámákat okozhat. Olvasd a LILO mini-HOWTO (LILO mini HOGYAN) 
	, vagy egyéb dokumetációt ennek a kivédésérõl. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1446"/>19.17. Azt írja ki: "warning: bdflush not running"</H3
><P
>&#13;        Ez komoly probléma lehet. A rendszermag v1.0-ás verziójától kezdve 
	(1994. ápr. 20-körül), az "
        <TT
CLASS="literal"
>&#13;          update 
        </TT
>
        " nevû programot, ami rendszeresen üríti a fájlrendszer puffereit, 
	fejlesztették/kicserélték. Szerezd meg a "
        <TT
CLASS="literal"
>&#13;          bdflush 
        </TT
>
        " forrását (ott találod, ahol a rendszermag forrását), és telepítsd fel 
	(valószínûleg a régi rendszermaggal futtatod a rendszert, amíg ezt teszed.) 
	Ez önmagát "
        <TT
CLASS="literal"
>&#13;          update 
        </TT
>
        " néven telepíti, és miután újraindítottad a rendszert, az új rendszermagnak 
	már nem szabad panaszkodnia. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1452"/>19.18. Nem tudom mûködésre bírni az IDE/ATAPI CD-ROM-ot</H3
><P
>&#13;        Különös módon sokan nem tudják mûködésre bírni az ATAPI meghajtóikat, 
	valószínûleg mert több dolog sem stimmel. 
      </P
><P
>&#13;        Ha a CD-ROM az egyetlen eszköz egy bizonyos IDE csatolón, akkor 
	"master"-ként és nem "slave"-ként kell beállítani. Meglepõ, de ez a 
	legáltalánosabb hiba. 
      </P
><P
>&#13;        A Creative Labs (elsõként) IDE csatolót rakott a hangkártyáira. 
	Ez azonban ahhoz az érdekes problémához vezetett, hogy míg néhányan 
	csak egy csatolóval rendelkeztek, sokan viszont  kettõvel, beépítve 
	az alaplapon (általában a 15-ös IRQ-n), így egy általános megoldás 
	lett a SoundBlaster csatolóját a harmadik IDE portnak venni 
	(IRQ11, legalábbis így mondták). 
      </P
><P
>&#13;        Ez a régi, 1.3-as és az alatti Linux-verzióknál gondot okozott. 
	Ezekben a verziókban a Linux nem támogatta a harmadik IDE csatolót. 
	Ennek megkerülésére kevés lehetõség van. 
      </P
><P
>&#13;        Ha már van egy második IDE port, van esély rá, hogy nem használod, 
	vagy nincs még rajta két eszköz. Vedd le az ATAPI meghajtót a 
	hangkártyáról és rakd a második csatolóra. Ezek után le tudod 
	tiltani a hangkártya csatolóját, ami egyébként egy IRQ-t is megspórol. 
      </P
><P
>&#13;        Ha nincs második csatolód, jumperrel állítsd be a hangkártya csatolóját 
	(ne a kártya hang-részét) az IRQ15-re, a második csatolóra. Ennek mûködni 
	kell. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1460"/>19.19. Furcsa dolgokat jelez elavult útválasztási kérésekrõl (routing requests)</H3
><P
>&#13;        Szerezd be a 
        <TT
CLASS="literal"
>&#13;          route 
        </TT
>
        program újabb verzióját és bármely egyéb programét is, ami útválasztási 
	információkat kezel. Az 
        <TT
CLASS="literal"
>&#13;          /usr/include/linux/route.h 
        </TT
>
        (ami igazából egy fájl a 
        <TT
CLASS="literal"
>&#13;          /usr/src/linux 
        </TT
>
        könyvtárban) megváltozott. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1466"/>19.20. "Not a compressed kernel Image file" (nem tömörített rendszermag)</H3
><P
>&#13;        Ne használd betöltõfájlként a 
        <TT
CLASS="literal"
>&#13;          vmlinux 
        </TT
>
        fájlt, ami a 
        <TT
CLASS="literal"
>&#13;          /usr/src/linux 
        </TT
>
        könyvtárban van, a
        <TT
CLASS="literal"
>&#13;          [..]/arch/i386/boot/bzImage 
        </TT
>
        a megfelelõ. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1472"/>19.21. Problémák a konzolos terminállal, miután 1.3.x-re frissítettünk</H3
><P
>&#13;        Változtasd meg a 
        <TT
CLASS="literal"
>&#13;          dumb 
        </TT
>
        szót 
        <TT
CLASS="literal"
>&#13;          linux 
        </TT
>
        -ra a konzol termcap bejegyzésében, a 
        <TT
CLASS="literal"
>&#13;          /etc/termcap 
        </TT
>
        fájlban. Ezen kívül egy terminfo bejegyzést is létre kell hoznod. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1478"/>19.22. Úgy néz ki, hogy nem fordíthatók le dolgok a rendszermag frissítése után</H3
><P
>&#13;        A Linux-rendszermag forrása tartalmaz számos ún. include fájlt 
	(azok a dolgok, amik 
        <TT
CLASS="literal"
>&#13;          .h 
        </TT
>
        -val végzõdnek), amikre a standard 
        <TT
CLASS="literal"
>&#13;          /usr/include 
        </TT
>
        könyvtárban lévõ fájlok is hivatkoznak. Általában a következõ módon 
	hivatkoznak rájuk (ahol a 
        <TT
CLASS="literal"
>&#13;          xyzzy.h 
        </TT
>
        valamilyen fájl a 
        <TT
CLASS="literal"
>&#13;          /usr/include/linux 
        </TT
>
        könyvtárban): #include &lt;linux/xyzzy.h&gt; Normál esetben van egy 
        <TT
CLASS="literal"
>&#13;          linux 
        </TT
>
        nevû link a 
        <TT
CLASS="literal"
>&#13;          /usr/include 
        </TT
>
        könyvtárban az 
        <TT
CLASS="literal"
>&#13;          include/linux 
        </TT
>
        könyvtárra, ami a forráson belül van ( 
        <TT
CLASS="literal"
>&#13;          /usr/src/linux/include/linux 
        </TT
>
        egy tipikus rendszeren). Ha ez a link nincs ott, vagy rossz helyre mutat, 
	a legtöbb dolog egyáltalán nem fordítódik le. Ha úgy döntesz, hogy a 
	rendszermag forrása túl sok helyet foglal és letörlöd, ez bizony probléma 
	lehet. Egy másik dolog, ami rossz lehet, a fájlok tulajdonjogai; ha a 
        <TT
CLASS="literal"
>&#13;          root 
        </TT
>
        felhasználónak olyan fájlmaszkja van, ami nem engedi meg alapértelmezésben 
	a többi felhasználónak, hogy lássa a fájljait, és a rendszermag forrását a 
        <TT
CLASS="literal"
>&#13;          p 
        </TT
>
        (preserve filemodes) opció nélkül csomagoltad ki, ezek a felhasználók nem 
	tudják használni a C fordítót sem. Bár használhatod a 
        <TT
CLASS="literal"
>&#13;          chmod 
        </TT
>
        parancsot ennek kijavítására, valószínûleg egyszerûbb újra kicsomagolni 
	az include fájlokat. Ezt ugyanúgy teheted meg, ahogy a teljes forrást az 
	elején, csak egy kiegészítõ argumentummal: 
      </P
><P
>&#13;        blah# tar zxvpf linux.x.y.z.tar.gz linux/include Figyelem: a " 
        <TT
CLASS="literal"
>&#13;          make config 
        </TT
>
        " újra létrehozza a 
        <TT
CLASS="literal"
>&#13;          /usr/src/linux 
        </TT
>
        linket, ha az nincs ott. 
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1495"/>19.23. Korlátok kitolása</H3
><P
>&#13;        A következõ néhány 
        <EM
>&#13;          példa 
        </EM
>
        parancs hasznos lehet azoknak, akik kíváncsiak arra, hogyan kell megemelni néhány 
	változtatható korlátot, amit a rendszermag ránk kényszerít: 
        <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;			echo 4096 &gt; /proc/sys/kernel/file-max 
			echo 12288 &gt; /proc/sys/kernel/inode-max 
			echo 300 400 500 &gt; /proc/sys/vm/freepages 
        </PRE
></FONT
></TD
></TR
></TABLE
>
      </P
></DIV
><DIV
CLASS="sect2"
><HR/><H3
CLASS="sect2"
><A
NAME="AEN1500"/>19.24. Hová küldjem a hibajelentést?</H3
><P
>&#13;        Részletesen a 
	<A
HREF="#quick_steps"
TARGET="_top"
>Gyors lépések - Rendszermag-fordítás</A
>
	fejezet 
        <A
HREF="#reportbugs"
TARGET="_top"
>Hová küldjem a hibajelentést?</A
>
        alfejezetében olvashatsz errõl. 
      </P
></DIV
></DIV
></DIV
></BODY
></HTML
>
