<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.21">
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-2">

 <TITLE>Bevezetés a bash programozásba HOGYAN</TITLE>
</HEAD>
<BODY>
<H1>Bevezetés a bash programozásba HOGYAN</H1>

<H2>Mike G <CODE>mikkey at dynamo.com.ar</CODE></H2>    2000. július 27.
    
<HR>
<EM>     Ezen dokumentum célja, hogy bevezessen az alap- illetve középszintû
    shell szkript írásba. A dokumentum nem egy
    minden részletre kiterjedõ leírás (ez a címébõl is kitûnik). Én nem vagyok se
    profi shell programozó, se guru. Azért döntöttem úgy, hogy
    megírom ezt a HOGYANt, mert sokat tanulhatok belõle és talán másoknak is
    hasznára válhat. Minden visszajelzésért hálás vagyok, különösképpen, ha
    folt (patch) formájában küldöd el. :)
    </EM>
<HR>
<H2><A NAME="s1">1. Bevezetés</A></H2>

<H2><A NAME="ss1.1">1.1 A dokumentum legújabb változata</A>
</H2>

<P>A dokumentum legújabb változata megtalálható a
<A HREF="http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html">http://tldp.org/HOWTO/Bash-Prog-Intro-HOWTO.html</A>
honlapon</P>


<H2><A NAME="ss1.2">1.2 Szükséges alapok</A>
          </H2>

<P> Jól jöhet, ha ismered a GNU/Linux rendszerek parancssorát, és
hasznos, ha tisztában vagy az alapvetõ programozási elvekkel. Noha ez nem egy
programozásba bevezetõ leírás, sok ilyet is megpróbálok majd bemutatni.</P>

<H2><A NAME="ss1.3">1.3 A dokumentum használata</A>
          </H2>

<P> Ez a dokumentum a következõ esetekben lehet hasznos:
<UL>
<LI> Már tudsz valamennyire programozni, és szeretnél végre
shell szkripteket írni.</LI>
<LI> Van valami halvány fogalmad a shell programozásról, és
szeretnél többet megtudni róla.</LI>
<LI> Látni akarsz pár shell szkriptet és némi magyarázatot,
hogy hozzáláthass sajátod megírásához.</LI>
<LI> DOS/Windows rendszerrõl jössz/jöttél és "batch"
programokat akarsz írni.</LI>
<LI> Annyira pedál vagy, hogy már
minden létezõ HOGYANt elolvastál.</LI>
</UL>
</P>
<H2><A NAME="ss1.4">1.4 Magyar fordítás</A>
          </H2>

<P> A magyar fordítást 
<A HREF="mailto:    Kovacs.Ferenc.5[kukac]stud.u-szeged[pont]hu"> Kovács Ferenc</A> készítette (2004.06.18). A lektorálást 
<A HREF="mailto: dacas[kukac]freemail[pont]hu">Daczi László</A> végezte el (2004.06.20). A dokumentum legfrissebb változata megtalálható a 
<A HREF="http://tldp.fsf.hu/">Magyar Linux Dokumentációs Projekt</A> honlapján. A dokumentum fordítása a 
<A HREF="http://www.u-szeged.hu/">Szegedi Tudományegyetem</A> 
<A HREF="http://www.inf.u-szeged.hu/~havasi/opensource/">nyílt forráskódú szoftverfejlesztés speciálkollégium</A>ának segítségével valósult meg.</P>
<H2><A NAME="s2">2. Egyszerû szkriptek</A>    </H2>

<P> Ez a HOGYAN megpróbál útmutatóként szolgálni a shell
szkriptek megismeréséhez. A témát gyakorlati oldalról, példákon keresztül
közelítjük meg.</P>
<P> Az ebben a részben található néhány példa remélhetõleg segít majd
megérteni pár alapvetõ módszert.</P>

<H2><A NAME="ss2.1">2.1 A szokásos hello world szkript</A>
                </H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
          #!/bin/bash
          echo Hello World
        
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P> A szkript csak két sorból áll.
Az elsõben jelezzük a rendszernek, hogy melyik
programot használja a szkript futtatásához.</P>
<P> A másodikban pedig kiírjuk a "Hello World" szöveget a terminálra.</P>
<P> Ha a képernyõn a <I>./hello.sh: Command not found.</I> vagy ehhez
hasonló üzenet jelenik meg, akkor valószínûleg az elsõ sorban lévõ
"#!/bin/bash" lesz a ludas. A hiba javításához módosítsd az elsõ sort
úgy, hogy az a bash tényleges elérési útvonalát tartalmazza. Az útvonal
lekérésére használható a "whereis bash" parancs, vagy olvasd el
"A bash felkutatása" címû fejezetet.</P>
<H2><A NAME="ss2.2">2.2 Egy nagyon egyszerû backup szkript</A>
        </H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
        #!/bin/bash
        tar -cZf /var/my-backup.tgz /home/me/
        
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P> Ebben a szkriptben, az elõzõtõl eltérõen, nem szöveget jelenítünk meg a
képernyõn, hanem a felhasználó "home" könyvtárában lévõ fájlokat
összefûzzük egyetlen tar fájlba. Ez csak a példa kedvéért szerepel most
itt, késõbb egy sokkal használhatóbb backup szkriptet is bemutatunk.</P>
<H2><A NAME="s3">3. Az átirányításról</A>        </H2>

<H2><A NAME="ss3.1">3.1 Elmélet és gyors útbaigazítás</A>
        </H2>

<P> Három fájlleíró van: stdin, stdout és stderr (std=standard).</P>

<P>Alapvetõen a következõk tehetõk meg:
<OL>
<LI> stdout fájlba irányítása</LI>
<LI> stderr fájlba irányítása</LI>
<LI> stdout stderr-be irányítása</LI>
<LI> stderr stdout-ba irányítása</LI>
<LI> stderr és stdout fájlba irányítása</LI>
<LI> stderr és stdout stdout-ba irányítása</LI>
<LI> stderr és stdout stderr-be irányítása</LI>
</OL>

Az 1 az stdout, a 2 az stderr (a 0 pedig az stdin
- a ford.).</P>
<P> Egy kis magyarázat, hogyan is kell mindezt érteni: a less paranccsal
meg tudod nézni mind az stdout "tartalmát" (ami a bufferen marad), mind
az stderr-ét, ami a képernyõn jelenik meg, de törlõdik, amint olvasni
próbálod a buffert.</P>
<H2><A NAME="ss3.2">3.2 Példa: az stdout fájlba irányítása</A>
        </H2>

<P> Ennek hatására a program kimenete fájlba íródik.
<BLOCKQUOTE><CODE>
<PRE>
        ls -l > ls-l.txt
        
</PRE>
</CODE></BLOCKQUOTE>

Itt létrejön az "ls-l.txt" nevû fájl, melynek tartalma meg fog egyezni
azzal, amit az "ls -l" parancs futtatásakor a képernyõn látnál.</P>
<H2><A NAME="ss3.3">3.3 Példa: az stderr fájlba irányítása</A>
        </H2>

<P> Hatására a program stderr kimenete fájlba íródik.
<BLOCKQUOTE><CODE>
<PRE>
        grep da * 2> grep-errors.txt
        
</PRE>
</CODE></BLOCKQUOTE>

Itt is létrejön a "grep-errors.txt" nevû fájl, melynek tartalma a "grep
da *" parancs stderr kimenetével fog megegyezni.</P>
<H2><A NAME="ss3.4">3.4 Példa: az stdout stderr-be történõ irányítása</A>
        </H2>

<P> Ennek hatására a program stderr kimenetére lesznek írva az stdout-ra
küldött adatok is.
<BLOCKQUOTE><CODE>
<PRE>
        grep da * 1>&amp;2
        
</PRE>
</CODE></BLOCKQUOTE>

Itt a parancs stdout kimenete az stderr-re lesz elküldve, ahogy ezt
már bizonyára észrevetted.</P>
<H2><A NAME="ss3.5">3.5 Példa: az stderr stdout-ba történõ irányítása</A>
        </H2>

<P> Most a program stderr kimenete az stdout-nak megfelelõ fájlleíróba
lesz írva.
<BLOCKQUOTE><CODE>
<PRE>
        grep * 2>&amp;1
        
</PRE>
</CODE></BLOCKQUOTE>

Itt az stderr-ra küldött adatok is az stdout-on jelennek meg. Ha ezt egy
csõvel (pipe) összekötöd a less programmal láthatod, hogy azok a sorok, amik
normális esetben eltûnnének (mivel az stderr-ra írtuk õket), most
megmaradnak (hiszen az stdout-ra lettek irányítva).</P>
<H2><A NAME="ss3.6">3.6 Példa: az stderr és stdout fájlba irányítása</A>
        </H2>

<P> Ebben az esetben a program minden kimenete fájlba kerül. Ez néha
hasznos lehet például a cron bejegyzések esetén, ha egy programot
teljes csöndben akarsz futtatni.
<BLOCKQUOTE><CODE>
<PRE>
        rm -f $(find / -name core) &amp;> /dev/null
        
</PRE>
</CODE></BLOCKQUOTE>

Ez (gondolva itt a cron bejegyzésekre) minden könyvtárból kitörli a "core"
nevû fájlokat. Fontos tisztában lenned azzal, hogy egy program
pontosan mit is csinál, mielõtt "megszünteted" a kimenetét.</P>
<H2><A NAME="s4">4. Csövek (pipe)</A>        </H2>

<P> Ebben a fejezetben a csövek használatának egy egyszerû és hasznos
módját ismertetjük, valamint elmondjuk hol lehet szükséged rájuk.</P>

<H2><A NAME="ss4.1">4.1 A csövek és azok használata</A>
                </H2>

<P> A csövek olyan egyszerû eszközök, melyek lehetõvé teszik,
hogy egy program bemenetét egy másik program kimenetérõl vegye.</P>
<H2><A NAME="ss4.2">4.2 Példa: csövek és a sed</A>
        </H2>

<P> Ez a csövek használatának egy nagyon egyszerû módja.
<BLOCKQUOTE><CODE>
<PRE>
        ls -l | sed -e "s/[aeio]/u/g"
        
</PRE>
</CODE></BLOCKQUOTE>

Itt a következõ történik: elõször az ls -l parancs végrehajtódik, de a
kimenete nem lesz kiírva a képernyõre, hanem el lesz küldve a sed
programnak, ami ezt bemenetként értelmezi és ebbõl elõállítja saját
kimenetét.</P>
<H2><A NAME="ss4.3">4.3 Példa: az ls -l *.txt parancs másként</A>
        </H2>

<P> A következõ parancs minden bizonnyal sokkal bonyolultabb, mint a
szokásos ls -l *.txt, de a csövek tulajdonságainak illusztrálására jó
példa. A gyakorlatban ilyen listázási problémák megoldására lehetõleg
ne használjunk csöveket.
<BLOCKQUOTE><CODE>
<PRE>
        ls -l | grep "\.txt$"
        
</PRE>
</CODE></BLOCKQUOTE>

Itt az ls -l program kimenete el lesz küldve a grep programnak, ami
kiírja azokat a sorokat, melyek illeszkednek a "\.txt$" reguláris
kifejezésre.</P>
<H2><A NAME="s5">5. Változók</A>            </H2>

<P> Ugyanúgy használhatsz változókat, mint bármely más programozási
nyelvben. Adattípusok nincsenek. Egy bash változó tárolhat számot,
karaktert és karakterekbõl álló sztringet.</P>
<P> A változókat nem kell külön deklarálni, a rájuk való hivatkozáskor
automatikusan létrejönnek.</P>


<H2><A NAME="ss5.1">5.1 Példa: Hello World! változókkal</A>
            </H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
            #!/bin/bash
            STR="Hello World!"
            echo $STR
            
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P> A második sorban létrejön egy STR nevû változó, melynek értéke
a "Hello World!" (sztring) lesz. Ezután a változó neve elé tett "$"
jellel tudjuk elérni annak értékét. Jegyezd meg (és próbáld is
ki), hogy ha nem használod a "$" jelet, a program kimenete más lesz
és valószínûleg nem az, amit szeretnél.</P>
<H2><A NAME="ss5.2">5.2 Példa: Egyszerû backup szkript (kicsivel jobb változat)</A>
           </H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
           #!/bin/bash
           OF=/var/my-backup-$(date +%Y%m%d).tgz
           tar -cZf $OF /home/me/
           
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P> Ez a szkript felvet egy másik dolgot is. De mindenek elõtt
tisztában kell lenned a változók létrehozásával, az értékadással
kapcsolatos dolgokkal (ez a második sorban látható). Most vegyük
szemügyre a "$(date +%Y%m%d)" kifejezést. Ha futtatod a szkriptet
a zárójelek közti parancs is lefut, létrehozva kimenetét.</P>

<P> Azt is vegyük észre, hogy a kimeneti fájl neve minden nap más és más
lesz, a date parancs formátum-kapcsolóinak (+%Y%m%d) köszönhetõen.
Ezt módosíthatod más formátum megadásával.</P>
<P> Még néhány példa:</P>
<P> echo ls</P>
<P> echo $(ls)</P>
<H2><A NAME="ss5.3">5.3 Lokális változók</A>
        </H2>

<P> Lokális változókat a <I>local</I> kulcsszóval tudunk létrehozni.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
                #!/bin/bash
                HELLO=Hello
                function hello {
                        local HELLO=World
                        echo $HELLO
                }
                echo $HELLO
                hello
                echo $HELLO
        
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P> Ennek a példának elégnek kell lennie, hogy bemutassa a
lokális változók használatát.</P>
<H2><A NAME="s6">6. Feltételes utasítások</A>    </H2>

<P> A feltételes utasítások segítségével dönthetünk, hogy végrehajtunk-e
valamit vagy nem. A döntés itt egy kifejezés kiértékelésébõl áll.</P>

<H2><A NAME="ss6.1">6.1 Elmélet</A>
        </H2>

<P> A feltételes utasításoknak több formája is van. A legalapvetõbb a
következõ: <B>if</B> <I>kifejezés</I> <B>then</B> <I>utasítás</I>,
ahol az "utasítás" csak akkor kerül végrehajtásra, ha a kifejezés,
kiértékelése után igazat ad vissza. Például a "2&lt;1" kifejezés kiértékelés
utáni értéke hamis, míg a "2>1" esetén igaz.</P>

<P> A másik eset:
<B>if</B> <I>kifejezés</I>
<B>then</B> <I>utasítás1</I> <B>else</B> <I>utasítás2</I>.
Az "utasítás1" akkor hajtódik végre, ha a kifejezés igaz, egyéb esetben
az "utasítás2" kerül végrehajtásra.</P>
<P> A feltételes utasítás egy másik formája:
<B>if</B> <I>kifejezés1</I>
<B>then</B> <I>utasítás1</I>
<B>else if</B> <I>kifejezés2</I> <B>then</B> <I>utasítás2</I>
<B>else</B> <I>utasítás3</I>.
Ebben az esetben csak az
"ELSE IF 'kifejezés2' THEN 'utasítás2'" részt adtuk hozzá, így az
utasítás2 akkor lesz végrehajtva, ha a kifejezés2 kiértékelés utáni
értéke igaz. A többit már magad is el tudod képzelni (nézd meg az
elõzõ formákat).</P>
<P> Pár szó a szintaxisról:</P>
<P> Bash-ban az "if" szerkezetek a következõképp néznek ki:</P>
<P> if [kifejezés];</P>
<P> then</P>
<P>    a "kifejezés" igaz volta esetén végrehajtódó kód</P>
<P> fi</P>
<H2><A NAME="ss6.2">6.2 Példa: alapvetõ feltételes utasítás (if ... then)</A>
            </H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
            #!/bin/bash
            if [ "foo" = "foo" ]; then
               echo a feltétel igaz
            fi
            
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P> A szögletes zárójelbe tett kifejezés igaz értéke esetén végrehajtódó
kód a "then" kulcsszó után és a "fi" kulcsszó elõtt helyezkedik el. A
"fi" kulcsszó jelzi a feltételesen végrehajtandó kód végét.</P>
<H2><A NAME="ss6.3">6.3 Példa: alapvetõ feltételes utasítás (if ... then ... else)</A>
            </H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
            #!/bin/bash
            if [ "foo" = "foo" ]; then
               echo a feltétel igaz
            else
               echo a feltétel hamis
            fi
            
</PRE>
</CODE></BLOCKQUOTE>
</P>
<H2><A NAME="ss6.4">6.4 Példa: Változók és feltételes utasítások</A>
            </H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
            #!/bin/bash
            T1="foo"
            T2="bar"
            if [ "$T1" = "$T2" ]; then
                echo a feltétel igaz
            else
                echo a feltétel hamis
            fi
            
</PRE>
</CODE></BLOCKQUOTE>
</P>
<H2><A NAME="s7">7. Ciklusok (for, while és until)</A>        </H2>

<P> Ebben a részben a for, while és until ciklusokról lesz szó.</P>
<P> A <B>for</B> ciklus egy kicsit eltér a más nyelvekben megszokottaktól.
Alapvetõen egy sztringekben szereplõ szavak halmazának feldolgozására
használjuk.</P>
<P> A <B>while</B> ciklus addig ismétli a ciklusmagot, amíg a ciklusfeltétel
hamissá nem válik (vagy ki nem ugrunk a ciklusmagból a break utasítással).</P>
<P> Az <B>until</B> ciklus tulajdonképpen azonos a while ciklussal, a különbség
csupán annyi, hogy az ismétlés addig folytatódik, amíg a feltétel hamis.</P>
<P> Ha gyanús volt számodra, hogy a while és az until ciklusok mennyire
hasonlók, akkor igazad volt.</P>
<H2><A NAME="ss7.1">7.1 Példa for ciklusra</A>
        </H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
        #!/bin/bash
        for i in $( ls ); do
            echo elem: $i
        done
        
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P> A második sorban deklaráltunk egy "i" nevû változót, ami majd sorra
felveszi a $( ls ) sztring különbözõ értékeit.</P>
<P> A harmadik sor szükség esetén méretesebb is lehet, vagy több sor is
szerepelhet a ciklusmagban a done (4. sor) kulcsszó elõtt.</P>
<P> A "done" (4. sor) jelzi, hogy a $i értéket használó kódrészlet
befejezõdött. Innentõl kezdve a $i új értéket vehet fel.</P>
<P> Ennek a szkriptnek így nem sok értelme van. A for ciklus használatának
egy sokkal hasznosabb módja, ha az elõzõ példánál csak bizonyos fájlokat
vizsgálunk.</P>

<H2><A NAME="ss7.2">7.2 C-szerû for ciklus</A>
        </H2>

<P> Fiesh tanácsára került ide ez a példa, ami egy C/Perl-szerû for
ciklust mutat be.
<BLOCKQUOTE><CODE>
<PRE>
        #!/bin/bash
        for i in `seq 1 10`;
        do
                echo $i
        done
        
</PRE>
</CODE></BLOCKQUOTE>
</P>
<H2><A NAME="ss7.3">7.3 While példa</A>
         </H2>

<P> 
<BLOCKQUOTE><CODE>
<PRE>
         #!/bin/bash
         COUNTER=0
         while [  $COUNTER -lt 10 ]; do
             echo A számláló értéke: $COUNTER
             let COUNTER=COUNTER+1
         done
         
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P> Ez a szkript a jól ismert "for" ciklust utánozza (C, Pascal, perl, stb.).</P>
<H2><A NAME="ss7.4">7.4 Until példa</A>
         </H2>

<P> 
<BLOCKQUOTE><CODE>
<PRE>
         #!/bin/bash
         COUNTER=20
         until [  $COUNTER -lt 10 ]; do
             echo COUNTER $COUNTER
             let COUNTER-=1
         done
         
</PRE>
</CODE></BLOCKQUOTE>
</P>
<H2><A NAME="s8">8. Függvények</A>     </H2>

<P> Mint a legtöbb programozási nyelvben itt is használhatunk függvényeket
a kód logikailag összetartozó részeinek csoportosítására, vagy ha csak áldozni
szeretnénk a rekurzió virtuális oltára elõtt (azaz ha rekurzív függvényeket akarunk írni).</P>
<P> A függvénydeklaráció csupán ennyibõl áll: function my_func { my_code }.</P>
<P> A függvény hívása pedig ugyanúgy történik, mint bármelyik program esetén, csak leírjuk a nevét.</P>

<H2><A NAME="ss8.1">8.1 Példa függvényekre</A>
           </H2>

<P> 
<BLOCKQUOTE><CODE>
<PRE>
           #!/bin/bash
           function quit {
               exit
           }
           function hello {
               echo Hello!
           }
           hello
           quit
           echo foo
           
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P> A 2-4 sorok tartalmazzák a "quit", az 5-7 sorok pedig a "hello"
függvényt. Ha nem teljesen világos számodra, hogy mit is csinál a szkript,
próbáld ki!</P>
<P> Megjegyzendõ, hogy a függvénydeklaráció sorrendje tetszõleges.</P>
<P> Amikor lefuttatjuk a szkriptet látjuk, hogy elõször a "hello", majd a "quit"
függvények hívódnak meg és a program sohasem éri el a 10. sort (echo foo).</P>
<H2><A NAME="ss8.2">8.2 Példa paraméteres függvényekre</A>
           </H2>

<P> 
<BLOCKQUOTE><CODE>
<PRE>
                #!/bin/bash
                function quit {
                   exit
                }
                function e {
                    echo $1
                }
                e Hello
                e World
                quit
                echo foo

           
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P> Ez a szkript nagyrészt megegyezik az elõzõvel. A fõ különbség az
"e" nevû függvényben rejlik, ami nem csinál mást, mint kiírja az elsõ
átvett argumentumot. A függvényeknél szereplõ argumentumok ugyanúgy
kezelhetõk, mint a szkriptnek átadott argumentumok.</P>
<H2><A NAME="s9">9. Felhasználói felületek</A>          </H2>

<H2><A NAME="ss9.1">9.1 Egyszerû menü a "select" használatával</A>
           </H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
           #!/bin/bash
           OPTIONS="Hello Quit"
           select opt in $OPTIONS; do
               if [ "$opt" = "Quit" ]; then
                echo done
                exit
               elif [ "$opt" = "Hello" ]; then
                echo Hello World
               else
                clear
                echo rossz válasz
               fi
           done
          
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P> Ha lefuttatod a szkriptet láthatod, hogy ez a programozók álma,
ha szöveges menükrõl van szó. Biztos észrevetted, hogy ez nagyon
hasonlít a "for" ciklusra. Csak itt ahelyett, hogy minden $OPTIONS
elemre egyszerûen végrehajtanánk a ciklust, mindig "megállítjuk" a
felhasználót.</P>

<H2><A NAME="ss9.2">9.2 A parancssor használata</A>
         </H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
          #!/bin/bash
          if [ -z "$1" ]; then
              echo használat: $0 könyvtárnév
              exit
          fi
          SRCD=$1
          TGTD="/var/backups/"
          OF=home-$(date +%Y%m%d).tgz
          tar -cZf $TGTD$OF $SRCD
         
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P> Világosnak kell lennie számodra annak, hogy ez a szkript mit csinál. Az
elsõ feltételben szereplõ kifejezéssel megnézzük, hogy a program
kapott-e argumentumot ($1). Ha nem, kilépünk, és egy használati
útmutatót jelenítünk meg a felhasználónak. A program többi részének
ezen a ponton már tisztának kell lennie.</P>
<H2><A NAME="s10">10. Egyebek</A>        </H2>

<H2><A NAME="ss10.1">10.1 Adatok bekérése felhasználótól: read</A>
         </H2>

<P> Sok esetben szükség lehet arra, hogy adatokat kérjünk be a
felhasználótól. Erre számos lehetõségünk van, melyek közül egy a
következõ:
<BLOCKQUOTE><CODE>
<PRE>
                #!/bin/bash
                echo Kérlek add meg a neved
                read NAME
                echo "Hi $NAME!"
        
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P> A read segítségével egyszerre több adatot is be tudsz olvasni. A
következõ példa ezt tisztázza.
<BLOCKQUOTE><CODE>
<PRE>
                #!/bin/bash
                echo Kérlek add meg a vezeték- és keresztneved
                read FN LN
                echo "Hi! $LN, $FN !"
        
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H2><A NAME="ss10.2">10.2 Aritmetikai kifejezések kiértékelése</A>
         </H2>

<P> A parancssorba (vagy a shell-be) írd be a következõt:</P>
<P> echo 1 + 1</P>
<P> Ha "2"-t vártál eredményül bizonyára csalódott vagy. De mi van
akkor, ha azt szeretnéd, hogy a bash ki is értékelje a számokat? A
megoldás a következõ:</P>
<P> echo $((1+1))</P>
<P> Ez már sokkal logikusabb kimenetet ad. Így kell egy aritmetikai
kifejezést kiértékelni. Ugyanezt az eredményt kapod a következõvel:</P>
<P> echo $[1+1]</P>

<P> Ha törtekre vagy más matematikai jellegû dolgokra van szükséged,
vagy egyszerûen csak ezt szeretnéd használni, akkor bc-vel is kiértékelheted
az aritmetikai kifejezéseket.</P>
<P> Ha beírom a parancssorba, hogy "echo $[3/4]", akkor 0-t kapok,
mivel a bash csak egészekkel dolgozik. Az "echo 3/4|bc -l" parancsra
viszont már helyes eredményt ad, azaz 0.75-öt.</P>
<H2><A NAME="ss10.3">10.3 A bash felkutatása</A>
        </H2>

<P> Mike levele nyomán (nézd meg a köszönetnyilvánítást):</P>
<P> Eddig mindig a "#!/bin/bash" formát használtuk, most itt van pár példa arra,
hogyan tudhatod meg a bash konkrét elérési útját.</P>
<P> A "locate bash" az egyik legjobb módszer erre a feladatra, de nem minden rendszeren van locate.</P>
<P> A gyökérbõl kiadott "find ./ -name bash" legtöbbször mûködik.</P>
<P> A lehetséges helyek, ahol nézelõdhetsz:</P>
<P>         ls -l /bin/bash</P>
<P>         ls -l /sbin/bash</P>
<P>         ls -l /usr/local/bin/bash</P>
<P>         ls -l /usr/bin/bash</P>
<P>         ls -l /usr/sbin/bash</P>
<P>         ls -l /usr/local/sbin/bash</P>
<P> (Most kapásból nem jut több eszembe...  A legtöbb rendszeren</P>
<P> ezen könyvtárak valamelyikében lesz).</P>
<P> Vagy megpróbálhatod a "which bash" parancsot is.</P>
<H2><A NAME="ss10.4">10.4 Program visszatérési értékének kiderítése</A>
        </H2>

<P> Bash-ban a programok visszatérési értéke egy speciális változóban tárolódik, melynek neve $?.</P>
<P> A következõ példa bemutatja, hogyan deríthetjük ki egy program
visszatérési értékét. Feltételezem, hogy a <I>dada</I> nevû könyvtár nem
létezik. (Ez szintén Mike javaslatára került ide.)
<BLOCKQUOTE><CODE>
<PRE>
        #!/bin/bash
        cd /dada &amp;> /dev/null
        echo rv: $?
        cd $(pwd) &amp;> /dev/null
        echo rv: $?
        
</PRE>
 
</CODE></BLOCKQUOTE>
</P>
<H2><A NAME="ss10.5">10.5 Parancs kimenetének tárolása</A>
         </H2>

<P> A következõ szkript listázza az összes táblát az összes adatbázisból (felteszem, hogy MySQL-t használsz).
Megváltoztathatod a "mysql" parancsot úgy, hogy valódi felhasználónevet és jelszót használsz.
<BLOCKQUOTE><CODE>
<PRE>
        #!/bin/bash
        DBS=`mysql -uroot  -e"show databases"`
        for b in $DBS ;
        do
                mysql -uroot -e"show tables from $b"
        done
        
</PRE>
</CODE></BLOCKQUOTE>
</P>
<H2><A NAME="ss10.6">10.6 Több forrásfájl használata</A>
        </H2>

<P> A "source" parancs segítségével több fájlt is használhatsz egyszerre.</P>
<P> __TO-DO__</P>
<H2><A NAME="s11">11. Táblázatok</A>        </H2>

<H2><A NAME="ss11.1">11.1 Sztring összehasonlító operátorok</A>
    </H2>

<P> (1) s1 = s2</P>
<P> (2) s1 != s2</P>
<P> (3) s1 &lt; s2</P>
<P> (4) s1 > s2</P>
<P> (5) -n s1</P>
<P> (6) -z s1</P>

<P> (1) s1 megegyezik s2-vel</P>
<P> (2) s1 nem egyezik meg s2-vel</P>
<P> (3) __TO-DO__</P>
<P> (4) __TO-DO__</P>
<P> (5) s1 nem nulla (egy vagy több karakterbõl áll)</P>
<P> (6) s1 nulla</P>
<H2><A NAME="ss11.2">11.2 Példák sztingek összehasonlítására</A>
        </H2>

<P> Két sztring összehasonlítása.
<BLOCKQUOTE><CODE>
<PRE>
        #!/bin/bash
        S1='string'
        S2='String'
        if [ $S1=$S2 ];
        then
                echo "S1('$S1') nem egyenlõ S2('$S2')-vel"
        fi
        if [ $S1=$S1 ];
        then
                echo "S1('$S1') egyenlõ S1('$S1')-vel"
        fi
        
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P> Most idézek egy részt Andreas Beck levelébõl, az <I>if [ $1 = $2 ]</I>
alakú utasításokkal kapcsolatban.</P>
<P> Nem túl jó ötlet a fenti példában is látható módszert használni, mert
ha a $S1 vagy a $S2 üres, értelmezési hibát kapunk. Helyette használjuk
inkább az x$1=x$2 vagy a "$1"="$2" formát.</P>

<H2><A NAME="ss11.3">11.3 Aritmetikai operátorok</A>
    </H2>

<P> +</P>
<P> -</P>
<P> *</P>
<P> /</P>
<P> % (maradék)</P>
<H2><A NAME="ss11.4">11.4 Aritmetikai relációs operátorok</A>
    </H2>

<P> -lt (&lt;)</P>
<P> -gt (>)</P>
<P> -le (&lt;=)</P>
<P> -ge (>=)</P>
<P> -eq (==)</P>
<P> -ne (!=)</P>
<P> A C programozók egyszerûen össze tudják vetni ezen operátorokat a
zárójelek közt megadottakkal.</P>
<H2><A NAME="ss11.5">11.5 Hasznos parancsok</A>
         </H2>

<P> Ezt a részt Kees újraírta (nézd meg a köszönetnyilvánítást...).</P>
<P>  Néhány ezek közül a programok közül egy komplett programozási nyelvet takar.
Ezen parancsok esetén csak az alapokat ismertetjük. Ha részletes leírásra
is szükséged van nézd meg a parancsok kézikönyv oldalait (man pages).</P>
<P><B>sed</B> (folyam szerkesztõ)</P>

<P> A sed egy nem interaktív szerkesztõprogram. Ez azt jelenti, hogy a fájlok
módosítása nem úgy megy, hogy mozgatod a kurzort a képernyõn. Itt szerkesztõ
utasításokból álló szkripteket használunk és egy fájlnevet, amit szerkeszteni
akarunk. A sed tulajdonképpen egy szûrõnek is felfogható. Nézzük az alábbi
példákat:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        $sed 's/mit_cseréljek/mire_cseréljem/g' /tmp/dummy
        
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P> A sed kicseréli a "mit_cseréljek" szöveget a "mire_cseréljem" szöveggel,
és a bemenetét a /tmp/dummy fájlból veszi. A végeredmény az stdout-ra lesz
küldve (ami alapesetben a konzol), de ha a sor végéhez írod, hogy "> fájlnév",
akkor a sed kimenetét a "fájlnév" nevû fájlba küldi.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        $sed 12, 18d /tmp/dummy
        
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P> A sed, a 12. és 18. sorok közti rész kivételével kiírja a fájl
tartalmát. Az eredeti fájl nem változik.</P>
<P><B>awk</B> (fájlok módosítása, szöveg kinyerése és szerkesztése)</P>

<P> Az AWK-nak számos implementációja létezik (a legismertebbek a GNU-s
gawk és az ún. "új awk", a mawk). Az alapelv egyszerû: az AWK mintát
keres és minden illeszkedõ mintára végrehajt valamilyen mûveletet.</P>
<P> Megint létrehoztam egy dummy nevû fájlt, ami a következõ sorokból áll:</P>
<P> <I>"test123</I></P>
<P> <I>test</I></P>
<P> <I>tteesstt"</I></P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        $awk '/test/ {print}' /tmp/dummy
        
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P> test123</P>

<P> test</P>

<P> A minta, amit az AWK keres, a "test". Ha a /tmp/dummy fájlban talált
egy sort, amiben szerepelt a "test" szó, akkor végrehajtotta rá a "print"
mûveletet.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        $awk '/test/ {i=i+1} END {print i}' /tmp/dummy
        
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P> 3</P>

<P> Ha sokféle mintára keresel, cseréld ki az idézõjelek közti szöveget
"-f file.awk"-ra és a mintákat, végrehajtandó tevékenységeket írd a
"file.awk" nevû fájlba.</P>
<P><B>grep</B> (a keresési mintára illeszkedõ sorok kiírása)</P>

<P> Az elõzõ fejezetekben már jó néhány grep parancsot láttunk, amelyek az
illeszkedõ sorokat írták ki. De a grep többre is képes.
<BLOCKQUOTE><CODE>
<PRE>
        $grep "ezt keressük" /var/log/messages -c
        
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P> 12</P>
<P> Az "ezt keressük" szöveg 12-szer szerepelt a /var/log/messages nevû fájlban.</P>

<P> [Jó, ez csak egy kitalált példa, a /var/log/messages meg lett buherálva. :-)]</P>
<P><B>wc</B> (sorok, szavak, bájtok megszámolása)</P>

<P> A következõ példában mást kapunk, mint amit várunk. A dummy nevû fájl,
amit most használunk, a következõ szöveget tartalmazza:
<I>"bash bevezetés</I>
<I> HOWTO teszt fájl"</I></P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        $wc --words --lines --bytes /tmp/dummy
        
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P> 2 5 34 /tmp/dummy</P>

<P> A wc nem foglalkozik a paraméterek sorrendjével. Mindig egy elõre megadott
sorrendben írja ki õket, amint azt te is láthatod: (sorok)(szavak)(bájtok)(fájlnév).</P>
<P><B>sort</B> (szöveges fájl sorainak rendezése)</P>

<P> Most a dummy fájl a következõket tartalmazza:</P>
<P> <I>"b</I></P>
<P> <I>c</I></P>
<P> <I>a"</I>
<BLOCKQUOTE><CODE>
<PRE>
        $sort /tmp/dummy
        
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P> A kimenet kábé így néz ki:</P>

<P> <I>a</I></P>
<P> <I>b</I></P>
<P> <I>c</I></P>

<P> A parancsok nem lehetnek ilyen egyszerûek :-)</P>
<P><B>bc</B> (egy számológépes programozási nyelv)</P>

<P> A bc a parancssorból kapja meg a számítási feladatokat (fájlból, nem pedig átirányítás vagy csõ útján),
esetleg egy felhasználói felületrõl. A következõkben példákon keresztül
bemutatunk néhány parancsot.</P>
<P> A bc-t a -q paraméterrel indítom, hogy ne írja ki az üdvözlõ szöveget.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
   $bc -q
        
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P> <I>1 == 5</I></P>
<P> <I>0</I></P>
<P> <I>0.05 == 0.05</I></P>
<P> <I>1</I></P>
<P> <I>5 != 5</I></P>
<P> <I>0</I></P>
<P> <I>2 ^ 8</I></P>
<P> <I>256</I></P>
<P> <I>sqrt(9)</I></P>
<P> <I>3</I></P>
<P> <I>while (i != 9) {</I></P>
<P> <I>i = i + 1;</I></P>
<P> <I>print i</I></P>
<P> <I>}</I></P>
<P> <I>123456789</I></P>
<P> <I>quit</I></P>
<P><B>tput</B> (terminál inicializálására vagy a terminfo adatbázis lekérdezésére)</P>

<P> Egy kis példa a tput képességeinek demonstrálására:
<BLOCKQUOTE><CODE>
<PRE>
        $tput cup 10 4
        
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P> A kurzor a (y10,x4)-es pozícióban jelenik meg.
<BLOCKQUOTE><CODE>
<PRE>
        $tput reset
        
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P> Törli a képernyõt, és a kurzor az (y1,x1) pozícióba kerül. Az (y0,x0) a bal felsõ sarok koordinátája.
<BLOCKQUOTE><CODE>
<PRE>
        $tput cols
        
</PRE>
</CODE></BLOCKQUOTE>

<I>80</I></P>
<P> Az x tengely irányában maximálisan elhelyezhetõ karakterek száma.</P>
<P> Nagyon ajánlott, hogy legalább ezen programok használatával tisztában
legyél. Millió olyan kis program van, amikkel csodákra lehetsz képes a
parancssorban.</P>
<P> [Néhány példa kézikönyv oldalból vagy GYIK-bõl származik.]</P>
<H2><A NAME="s12">12. Még néhány szkript</A>     </H2>

<H2><A NAME="ss12.1">12.1 Parancs végrehajtása a könyvtárban lévõ összes fájlra</A>
     </H2>


<H2><A NAME="ss12.2">12.2 Példa: egyszerû backup szkript (egy kicsivel jobb verzió)</A>
           </H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
            #!/bin/bash
            SRCD="/home/"
            TGTD="/var/backups/"
            OF=home-$(date +%Y%m%d).tgz
            tar -cZf $TGTD$OF $SRCD
           
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H2><A NAME="ss12.3">12.3 Fájl átnevezõ program</A>
          </H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>

             #!/bin/sh
             # renna: egyszerre több fájl átnevezése különbözõ szabályok szerint
             # írta: Felix Hudson (2000. január)

             # elõször is megnézzük, hogy a program milyen "üzemmódban" van
             # ha az elsõ paraméter ($1) alapján valamelyik feltétel teljesül végrehajtjuk
             # a hozzá tartozó programrészt és kilépünk

             # elõtag (prefix) szerint történõ átnevezés?
             if [ $1 = p ]; then

             # most megszabadulunk a módot tartalmazó változótól ($1) és a prefixtõl ($2)
               prefix=$2 ; shift ; shift

             # megnézzük, adtak-e meg fájlnevet
             # ha nem, jobb ha nem csinálunk semmit, minthogy nemlétezõ fájlokat
             # nevezzünk át

               if [$1 = ]; then
                  echo "nem adtál meg fájlnevet"
                  exit 0
               fi

             # ez a for ciklus végigmegy a megadott fájlokon és mindet
             # egyenként átnevezi
               for file in $*
                 do
                 mv ${file} $prefix$file
               done

             # kilépünk a programból
               exit 0
             fi

             # utótag (suffix) szerinti átnevezés?
             # az ide tartozó rész tulajdonképpen megegyezik az elõzõvel
             # nézd meg az ottani megjegyzéseket
             if [ $1 = s ]; then
               suffix=$2 ; shift ; shift

                if [$1 = ]; then
                 echo "nem adtál meg fájlnevet"
                exit 0
                fi

              for file in $*
               do
                mv ${file} $file$suffix
              done

              exit 0
             fi

             # helyettesítéses átnevezés?
             if [ $1 = r ]; then

               shift

             # ezt a részt azért raktam bele, hogy ne tegyük tönkre a felhasználó egyik
             # állományát se, ha helytelenek a paraméterek
             # ez csak egy biztonsági intézkedés

               if [ $# -lt 3 ] ; then
                 echo "használat: renna r [kifejezés] [helyettesítés] fájlok... "
                 exit 0
               fi

             # továbblépünk a paraméterlistán
               OLD=$1 ; NEW=$2 ; shift ; shift

             # Ez a for ciklus végigmegy az összes fájlon amit a programnak átadtak,
             # és egyenként átnevezi õket a "sed" program segítségével.
             # A "sed" egyszerû parancssori program, ami értelmezi a bemenetet és
             # kicseréli a beállított kifejezést egy adott szövegre.
             # Mi itt a fájl nevét adjuk át neki (standard bemenetként), és kicseréljük
             # benne a kifejezésnek megfelelõ szövegrészeket.

               for file in $*
               do
                 new=`echo ${file} | sed s/${OLD}/${NEW}/g`
                 mv ${file} $new
               done
             exit 0
             fi

             # Ha idáig eljutottunk, akkor semmi használhatót nem adtak át a programnak
             # ezért kiírjuk a felhasználónak, hogyan használja ezt a szkriptet.
             echo "használat:"
             echo " renna p [elõtag] fájlok.."
             echo " renna s [utótag] fájlok.."
             echo " renna r [kifejezés] [helyettesítés] fájlok.."
             exit 0
             
             #ennyi!
             
          
</PRE>
</CODE></BLOCKQUOTE>
</P>
<H2><A NAME="ss12.4">12.4 Átnevezõ program (egyszerû változat)</A>
     </H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
     #!/bin/bash
     # renames.sh
     # egyszerû átnevezõ program

     criteria=$1
     re_match=$2
     replace=$3
     
     for i in $( ls *$criteria* ); 
     do
         src=$i
         tgt=$(echo $i | sed -e "s/$re_match/$replace/")
         mv $src $tgt
     done
     
</PRE>
</CODE></BLOCKQUOTE>
</P>
<H2><A NAME="s13">13. Ha gond van... (hibakeresés)</A>     </H2>

<H2><A NAME="ss13.1">13.1 A bash meghívásának módjai</A>
          </H2>

<P> Jó dolog, ha az elsõ sorban a következõ szerepel:
<BLOCKQUOTE><CODE>
<PRE>
          #!/bin/bash -x
          
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P> Ennek hatására érdekes kimeneti információkat kaphatunk.</P>
<H2><A NAME="s14">14. A dokumentumról</A>     </H2>

<P> Szabadon küldhetsz javaslatokat/hibajavításokat vagy bármi olyat, 
amirõl úgy gondolod, hogy érdekes és szívesen látnád a dokumentumban. 
Megpróbálom majd olyan gyakran frissíteni a leírást, amilyen gyorsan csak
tudom.</P>
<H2><A NAME="ss14.1">14.1 (nincs) garancia</A>
          </H2>

<P> A dokumentummal kapcsolatban semmiféle garancia nincs.</P>
<H2><A NAME="ss14.2">14.2 Fordítások</A>
        </H2>

<P> Olasz: by William Ghelfi (wizzy at tiscalinet.it) 
<A HREF="http://web.tiscalinet.it/penguin_rules">itt a cím</A></P>
<P> Francia: by Laurent Martelli 
<A HREF="http://">nincs cím</A></P>
<P> Koreai: Minseok Park 
<A HREF="http://kldp.org">http://kldp.org</A></P>
<P> Koreai: Chun Hye Jin 
<A HREF="">ismeretlen</A></P>
<P> Spanyol: ismeretlen 
<A HREF="http://www.insflug.org">http://www.insflug.org</A></P>
<P> Lehet, hogy több fordítás is van, de én nem tudok róla. Ha neked ilyen
van, kérlek küldd el, hogy frissíthessem ezt a részt.</P>
<H2><A NAME="ss14.3">14.3 Köszönet</A>
     </H2>

<P>
<UL>
<LI> Azoknak, akik más nyelvekre fordították a dokumentumot (lásd: elõzõ rész).</LI>
<LI> Nathan Hurstnek a sok hibajavításért.</LI>
<LI> Jon Abbottnak az aritmetikai kifejezések kiértékeléséhez fûzött megjegyzéseiért.</LI>
<LI> Felix Hudsonnak a <I>renna</I> szkriptért</LI>
<LI> Kees van den Broeknek (számos hibajavításért és a "Hasznos parancsok" címû fejezet újraírásáért)</LI>
<LI> Mikenak (pink), a bash felkutatásával és fájlok tesztelésével kapcsolatos javaslataiért.</LI>
<LI> Fieshnek, a ciklusokkal foglalkozó részben tett hasznos megjegyzéséért.</LI>
<LI> Lionnak, akinek javaslatára megemlítettünk egy gyakori hibát (./hello.sh: Command not found).</LI>
<LI> Andreas Becknek a hibajavításokért és megjegyzésekért.</LI>
</UL>
</P>
<H2><A NAME="ss14.4">14.4 Történet</A>
        </H2>

<P> Új fordítások és lényegi javítások.</P>
<P> A Kess által átírt hasznos parancsok rész hozzáadása.</P>
<P> Hibajavítások, javaslatok.</P>
<P> Példák a sztring összehasonlításhoz.</P>
<P> v0.8 Elhagyom a verziószámozást, rájöttem, hogy a dátum is elég.</P>
<P> v0.7 Számos hibajavítás és pár régi TO-DO rész megírása.</P>
<P> v0.6 Kisebb javítások.</P>
<P> v0.5 Az átirányítással foglalkozó rész hozzáadása.</P>
<P> v0.4 A volt fõnökömnek köszönhetõen a doksi eltûnt a régi helyérõl, most
a www.linuxdoc.org címen érhetõ el.</P>
<P> elõtte: Nem emlékszem, nem használtam se rcs-t, se cvs-t. :(</P>
<H2><A NAME="ss14.5">14.5 További források</A>
          </H2>


<P> Bevezetés a bash programozásba (BE alatt) 
<A HREF="http://org.laol.net/lamug/beforever/bashtut.htm">http://org.laol.net/lamug/beforever/bashtut.htm</A></P>
<P> Bourne shell programozás
<A HREF="http://207.213.123.70/book/">http://207.213.123.70/book/</A></P>

<H2><A NAME="ss14.6">14.6 További források magyarul</A>
          </H2>


<P>(Ezeket a forrásokat a lektor gyûjtötte össze.)</P>

<P> Büki András: "UNIX/Linux héjprogramozás" (ISBN: 963 9301 10 8)</P>
<P> Bourne shell programozás
<A HREF="http://www.inf.u-szeged.hu/~bmse/unix/unix3.html">http://www.inf.u-szeged.hu/~bmse/unix/unix3.html</A></P>
<P> Shell programozás
<A HREF="http://shell-script-programing.sync.hu/SHELL_PROGRAMOZAS.htm">http://shell-script-programing.sync.hu/SHELL_PROGRAMOZAS.htm</A></P>
<P> Shell programozás
<A HREF="http://www.fsz.bme.hu/~szebi/slides/U3/sld010.htm">http://www.fsz.bme.hu/~szebi/slides/U3/sld010.htm</A></P>
<P> Shell programozás
<A HREF="http://www.szabilinux.hu/ufi/10.html">http://www.szabilinux.hu/ufi/10.html</A></P>
</BODY>
</HTML>
