<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>LinuxDoc+Emacs+Ispell-HOWTO</TITLE>


</HEAD>
<BODY>
<H1>LinuxDoc+Emacs+Ispell-HOWTO</H1>

<H2> Auteur: Philippe MARTIN
 (
<A HREF="mailto:feloy@wanadoo.fr">feloy@wanadoo.fr</A>) <BR>
 Vertaler: S&eacute;bastien Blondeel
 (
<A HREF="mailto:Sebastien.Blondeel@lifl.fr">Sebastien.Blondeel@lifl.fr</A>)
 Vertaler (nl): Ellen Bokhorst
 (
<A HREF="mailto:bokkie@nl.linux.org">bokkie@nl.linux.org</A>)
 </H2>v0.4, 27 Februari 1998
<P><HR>
<EM> Dit document is bedoeld voor schrijvers en vertalers van Linux HOWTO's of
enig ander document voor het Linux Documentatie Project. Het geeft aanwijzingen voor het gebruiken van hulpmiddelen waaronder Emacs en Ispell.</EM>
<HR>
<H2><A NAME="s1">1. Inleiding</A></H2>

<H2>1.1 Copyright</H2>

<P>Copyright Philippe Martin 1998<BR>
Je mag dit document herdistribueren en/of wijzigen zolang als je
voldoet aan de voorwaarden van de GNU General Public Licence, versie 2 of
later.
<H2>1.2 Verdiensten</H2>

<P>Speciale dank gaat uit naar S&eacute;bastien Blondeel, een akelige vent
die me nogal veel vroeg over het instellen van Emacs. 
Zijn slimme vragen lieten me het beter
begrijpen en de kennis via dit document aan je door te geven.
<H2>1.3 Commentaar</H2>

<P>Aarzel niet me te vertellen waarvan je denkt dat het kan helpen dit
document te verbeteren. Ik zal je kritiek door en door bestuderen.<BR>
Aarzel ook niet om me vragen te stellen die te maken hebben met de
onderwerpen die hier worden besproken.
Ik zal ze met plezier beantwoorden, aangezien ze me kunnen helpen dit
document verder te verbeteren.
<BLOCKQUOTE>Opmerking van de vertaler: als de vertaling niet deugt, dan gaat dat naar mij!</BLOCKQUOTE>
<H2>1.4 Versies</H2>

<P>Dit document gaat uit van de volgende versies:
<UL>
<LI>Sgml-tools versie 0.99,</LI>
<LI>Emacs versie 19.34,</LI>
<LI>Ispell versie 3.1,</LI>
<LI>Alle Emacs libraries waarnaar in dit document wordt verwezen,
worden met de bovengenoemde versie van Emacs gedistribueerd, 
afgezien van <CODE>iso-sgml</CODE>, dat met
XEmacs wordt gedistribueerd, en <CODE>psgml</CODE> is een stand-alone library.</LI>
</UL>
<H2><A NAME="s2">2. Introductie</A></H2>

<H2>2.1 SGML</H2>

<P><I>Standard Generalised Mark-up Language</I>, of 
<B>SGML</B>, is een taal voor het defini&eacute;ren van documenttypen.
<P>Men kan het documenttype bijvoorbeeld defini&euml;ren als een <I>recept</I>,
met een eerste deel dat de ingredi&euml;nten presenteert,
een tweede deel dat de accesoires introduceert,
een derde deel waarin stap-voor-stap instructies worden
gegeven voor het bakken van de cake, en een aardig laatste plaatje
om de uitkomst van dit alles te tonen.
<P>     
Dit wordt een <I>Document Type Definition</I> genoemd. 
Het definieert niet hoe het uiteindelijke product er uit zal zien, het
definieert slechts wat er in zou kunnen staan.
<P>     
Om nogmaals hetzelfde voorbeeld aan te halen, ik ben er zeker van dat
bij het lezen van mijn idee van een recept, 
je jouw favoriete bereidingen herkent. Niettemin zien ze
er in feite anders uit: van de mijne is er een plaatje in de bovenste
linkerhoek van de badkamerkast, en de lijst met ingredi&euml;nten bevindt
zich in de achtertuin, tussen het zwembad en de barbecue. En de jouwe?
<P>     
Met dank aan deze standaarddefinitie; men kan een document schrijven zonder
acht te slaan op hoe het er uiteindelijk richting de gebruiker uit komt
te zien.
<H2>2.2 De <CODE>LinuxDoc</CODE> Type Definitie</H2>

<P>Dit type wordt gebruikt, zoals je misschien al hebt geraden, om
documenten gerelateerd aan Linux, te schrijven.
<P>Dergelijke documenten worden in het algemeen als volgt opgebouwd: 
ze beginnen met een titel gevolgd door de naam van de auteur, en het 
versienummer en de -datum.
Vervolgens komt de samenvatting (zodat je er niet doorheen hoeft te bladeren,
voordat je je achteraf realiseert dat het niet hetgeen is waarnaar je zocht), 
en dan de inhoud die de structuur toont, zodat degene die haast hebben, direct
naar dat deel kunnen gaan wat ze willen lezen.
<P>Vervolgens komt er een lijst met hoofdstukken, secties en paragrafen. 
Hiertussen kan men stukken programma invoegen, het font wijzigen om
een woord of een zin te benadrukken, lijsten invoegen, naar een ander 
deel van het document verwijzen, enz.
<P>Om een dergelijk document te schrijven, zul je gewoon op het juiste
moment de titel, de auteur, de datum en de versie van het document, de
hoofdstukken en paragrafen moeten schrijven en laten we zeggen, welke
elementen er in een lijst staan als deze moeten worden ingevoegd, enz.
<H2>2.3 <CODE>SGML-Tools</CODE></H2>

<P><B>SGML-Tools</B> zal de specificatie van een document in het
uiteindelijke resultaat omzetten in de vorm waaraan je de voorkeur geeft.
Als je wilt dat het een onderdeel van je persoonlijke bibliotheek vormt, 
zul je voor <I>PostScript</I> kiezen. 
Als je het wilt delen met de rest van de wereld via het Web, zal het
<I>HTML</I> zijn. Als je er niets aan kunt doen en het onder Windows
moet lezen, kun je het omzetten in <I>RTF</I> zodat je het in iedere 
tekstverwerker in kunt lezen.
Of misschien wil je alle drie de formaten gebruiken om aan je wisselende
stemmingen tegemoet te komen.
<P>SGML-Tools zijn beschikbaar via anonieme FTP op 
<A HREF="ftp://ftp.lip6.fr/pub/sgml-tools/">ftp://ftp.lip6.fr/pub/sgml-tools/</A><H2><A NAME="s3">3. Je eerste document</A></H2>

<H2>3.1 Vanuit een tekstdocument</H2>

<P>Als je een tekstdocument in SGML wilt omzetten om het over te zetten naar
andere formaten, is dit de manier waarop je 't doet:
<P>
<OL>
<LI>Voeg de volgende regels aan het begin toe:
 
<PRE>
        &lt;!doctype linuxdoc system>
        &lt;article>
        &lt;title>De titel staat hier&lt;/title>
        &lt;author>
        naam van de auteur, e-mail van de auteur, enz.
        &lt;/author>
        &lt;date>
        versie en datum 
        &lt;&lt;/date>
</PRE>
</LI>
<LI>Als je aan het begin van het document de inhoud ervan in het
kort beschrijft, omsluit die paragraaf dan met de
<CODE>&lt;abstract&gt;</CODE> en <CODE>&lt;/abstract&gt;</CODE> tags.</LI>
<LI>Voeg dan de <CODE>&lt;toc&gt;</CODE> tag in, wat staat voor 
<EM>Inhoudsopgave</EM>. </LI>
<LI>Aan het begin van ieder nieuw hoofdstuk, vervang je de regel waarin het
nummer en de titel van het hoofdstuk staan door:
        
<PRE>
        &lt;sect&gt;&lt;heading>De Titel Van Het Hoofdstuk&lt;/heading&gt;
        
</PRE>

en voeg de <CODE>&lt;/sect&gt;</CODE> tag aan het einde van het
hoofdstuk toe.<BR>
<B>Opmerking:</B> Je hoeft het hoofdstuknummer niet aan te geven,
dit gebeurt automatisch.</LI>
<LI>Ga op dezelfde wijze door met paragrafen. Je zult de nummers
moeten verwijderen en de titels laten beginnen met de <CODE>&lt;sect1&gt;</CODE>
tag en laten be&euml;indigen met de <CODE>&lt;/sect1&gt;</CODE> tag.</LI>
<LI>Je kunt op vergelijkbare wijze 4 niveuas in de secties nesten,
door gebruik te maken van <CODE>&lt;sectn&gt;</CODE> en 
<CODE>&lt;/sectn&gt;</CODE> waar de
<CODE>n=</CODE> staat voor 2, 3, of 4.</LI>
<LI>Aan het begin van iedere paragraaf voeg je de <CODE>&lt;p&gt;</CODE> tag in.</LI>
<LI>Als je een aantal delen wilt benadrukken, omsluit ze dan met de
<CODE>&lt;it&gt;</CODE> en <CODE>&lt;/it&gt;</CODE>
(<I>cursief</I>), <CODE>&lt;bf&gt;</CODE> en <CODE>&lt;/bf&gt;</CODE>
(<B>vet</B>), of <CODE>&lt;tt&gt;</CODE> en <CODE>&lt;/tt&gt;</CODE>
(<CODE>typewriter stijl</CODE>).</LI>
<LI>Om een op de volgende gelijkende lijst in te voegen:

<PRE>
   Dit is een lijst met vier regels:

 - hier komt de eerste regel
 - vervolgens komt de tweede regel
 - nog een andere
 - dat is het.
 
</PRE>

 
je moet dit vervangen door:
 
<PRE>
 Dit is een lijst met vier regels:
 &lt;itemize>
 &lt;item>hier komt de eerste regel&lt;/item>
 &lt;item>vervolgens komt de tweede regel&lt;/item>
 &lt;item>nog een andere&lt;/item>
 &lt;item>dat is het.&lt;/item>
 &lt;/itemize>
 
</PRE>
</LI>
<LI>Als een geheel blok uit een gedeelte van een programma bestaat, of iets anders
dat in 't oog moet springen: 

<PRE>
        10 REM Oh mijn God wat is dit?
        20 REM Ik dacht dat dit al lang niet meer bestond!
        30 PRINT "Ik ben terug bij";
        40 PRINT "red de wereld."
        50 INPUT "Van wie denk je dat 't is? ",M$
        60 IF M$="Bill" THEN PRINT "Gij bent verstandig.":GOTO PARADISE
        70 ELSE PRINT "Je snapt er niks van...":GOTO RICHMOND
        &lt;/verb>
 
</PRE>
</LI>
<LI>Tot dusverre zijn je SGML-formatterings vaardigheden al tamelijk goed. Als je
je document bij wilt schaven, zou je de gebruikersgids 
<B>SGML-Tools</B> eens kunnen bekijken, waarin meer details staan over het
<B>LinuxDoc</B> documenttype.</LI>
</OL>
<H2><A NAME="s4">4. Configureren van Emacs</A></H2>

<H2>4.1 Geaccentueerde Tekens</H2>

<P>Als je documenten in het Frans of elke andere West-Europese taal wilt
schrijven, zul je 8-bit tekens nodig hebben.
Je kunt Emacs als volgt instellen dat het dergelijke tekens accepteert.
<H3>Het tonen van 8-bit tekens</H3>

<P>Om in Emacs 8-bits tekens te kunnen tonen, zul je de volgende regels in
het bestand <CODE>.emacs</CODE> nodig hebben:
<PRE>
(standard-display-european 1)
(load-library "iso-syntax")
</PRE>
<P>Als je Emacs op een terminal gebruikt die geen ondersteuning voor 8-bit geeft,
kun je de <CODE>iso-ascii</CODE> library (<CODE>(load-library "iso-ascii")</CODE>) 
gebruiken, waarmee Emacs de opdracht krijgt om dergelijke tekens zo goed 
mogelijk te benaderen.
<H3>Het typen van 8-bit tekens</H3>

<P>Als je toetsenbord je de mogelijkheid geeft om geaccentueerde tekens
in te voeren, geen probleem. Als dit niet zo is zijn hier een aantal remedies:
<H3>De iso-acc-library</H3>

<P>De Emacs <CODE>iso-acc</CODE> library geeft je de mogelijkheid om
8-bits tekens vanaf een 7-bit toetsenbord in te tikken.
<P>Om het te kunnen gebruiken, voeg je de volgende regel toe aan het bestand 
<CODE>.emacs</CODE>:
<PRE>
(load-library "iso-acc")
</PRE>
<P>Vervolgens, als je Emacs draait en het bestand opent dat je wilt
wijzigen, tik je in:
<CODE>Meta-x iso-accents-mode</CODE>.
<P>Je kunt dan de <B>&eacute;</B> van het Franse woord 
<EM>caf&eacute;</EM> invoegen door <B>'</B> te typen en 
vervolgens <CODE>e</CODE>. Meer in het algemeen, je
zult een geaccentueerd teken intikken door als eerste het accent in te tikken
en vervolgens de letter die moet worden geaccentueerd
(kleine- of hoofdletter). Je kunt de volgende accenten gebruiken:
<P>
<LI><CODE>'</CODE>&nbsp;: Accent Aigu</LI>
<LI><CODE>`</CODE>&nbsp;: Accent Grave</LI>
<LI><CODE>^</CODE>&nbsp;: Accent Circonflexe</LI>
<LI><CODE>"</CODE>&nbsp;: Dubbel aanhalingsteken</LI>
<LI><CODE>~</CODE>&nbsp;: Tilde, cedille, en andere speciale gevallen
(cf iso-acc.el).</LI>
<LI><CODE>/</CODE>&nbsp;: Om tekens te scheiden, enz.</LI>
      
<P>Als je &eacute;&eacute;n van deze tekens nodig hebt en niet een geaccentueerde
letter, typ je er een spatie achter.
Om bijvoorbeeld
<I>l'&eacute;l&eacute;phant</I> te typen, typ je 
<CODE>l ' spc ' e l ' e ...</CODE>
<P>Alle mogelijke combinaties zijn in het bestand <CODE>iso-acc.el</CODE> te vinden.
<H3>De Meta-toets</H3>

<P>Een aantal terminals staan je toe om 8-bits tekens in te tikken met de
&lt;Meta&gt; (of &lt;Alt&gt;) toets. Als je bijvoorbeeld
<B>&lt;Meta&gt;-i</B> indrukt, zul je het <B>&eacute;</B>-teken krijgen.
<P>Maar Emacs heeft de &lt;Meta&gt;-toets voor andere doeleinden gereserveerd, 
en ik ken geen library die je het laat gebruiken voor geaccentueerde tekens.
<P>Dit is een oplossing:
<BLOCKQUOTE><CODE>
<PRE>
(global-set-key "\ei" '(lambda () (interactive) (insert ?\351)))
     _                                      ___
</PRE>
</CODE></BLOCKQUOTE>

Als je een dergelijk regel in het bestand
<CODE>.emacs</CODE> invoegt, kun je een
<B>&eacute;</B> intikken door gebruik te maken van de 
<B>&lt;Meta&gt;-i</B> toetsaanslag. 
Je kunt op die manier de combinaties, die je nodig hebt, herdefini&euml;ren
als je de <B>i</B> door de juiste toets en
<B>351</B> door de juiste code (de code uit de
ISO-8859-1 tekenset) vervangt.
<P><B>Waarschuwing!</B> Het kan zijn dat een aantal lokale modes
dergelijke toetscombinaties herdefini&euml;ren.
<H3>Het tonen van 8-bits SGML-tekens</H3>

<P>Onder SGML kun je geaccentueerde tekens met macros intikken. 
De <B>&eacute;</B> toets bijvoorbeeld is <B>&amp;eacute;</B>. 
In het algemeen kunnen de applicaties die SGML in moeten kunnen lezen, 
8-bit tekens inlezen en is het dus niet nodig om
deze macro's te gebruiken.
Maar een aantal ervan kunnen dit mogelijk niet. Aangezien er een manier
is om dit probleem op te lossen, zou het zonde zijn om het hierdoor vast
te laten lopen.
<P>De <CODE>iso-sgml</CODE> library laat je zoals altijd geaccentueerde tekens 
onder Emacs typen, maar bij het opslaan van je bestand naar disk, zal
het deze 8-bits tekens omzetten in de SGML-equivalente.
<P>Dankzij deze library is het daarom makkelijk om je document onder 
Emacs in te typen en het opnieuw in te lezen, zodat je er zeker van kunt
zijn dat een niet-8-bit-clean-applicatie je document zal accepteren.
<P>Om deze bibliotheek te kunnen gebruiken, hoef je slechts de volgende regels
aan het bestand <CODE>.emacs</CODE> toe te voegen:
<BLOCKQUOTE><CODE>
<PRE>
(setq sgml-mode-hook
'(lambda () "Standaards voor SGML mode."
 (load-library "iso-sgml")))
</PRE>
</CODE></BLOCKQUOTE>
<H2>4.2 SGML mode</H2>

<P>Bij het laden van een bestand met de <B>.sgml</B> extensie,
schakelt Emacs automatisch over op de <B>sgml mode</B>. Als dit niet gebeurt,
kun je dit handmatig doen door
<CODE>Meta-x sgml-mode</CODE> in te tikken, of 
automatisch door de volgende regels aan het <CODE>.emacs</CODE> bestand toe te
voegen:
<P>
<PRE>
(setq auto-mode-alist
(append '(("\.sgml$"  . sgml-mode))
auto-mode-alist))
 
</PRE>
<P>Deze mode laat je kiezen uit hoe je bijvoorbeeld 8-bit tekens in wilt voegen.
Met de <CODE>Meta-x sgml-name-8bit-mode</CODE> (of het menu-item
<I>SGML/Toggle 8-bit insertion</I>), je kunt ervoor kiezen om de 9-bit
tekens in te tikken, of in SGML vorm, b.v. in de vorm <B>&amp;...;</B>.
<P>Het laat je met <CODE>Meta-x sgml-tags-invisible</CODE> 
(of het menu-item <I>SGML/Toggle Tag
Visibility</I>) ook de SGML-tags verbergen of tonen.
<H2>4.3 PSGML mode</H2>

<P>De PSGML mode kan veel bijdragen aan het wijzigen van SGML-documenten
met Emacs.
<P>De 
<A HREF="http://www.linux-france.com/article/psgml-linuxdoc">psgml-linuxdoc</A>
documentatie geeft een uitleg over hoe je deze mode met 
<I>LinuxDoc</I> kunt installeren en gebruiken. 
<H2>4.4 Diverse</H2>

<H3>auto-fill mode</H3>

<P>Als je in de normale mode een paragraaf typt en aan het einde van de regel
komt, moet je de &lt;Return&gt;-toets gebruiken om naar de volgende regel
te gaan, anders komt de gehele paragraaf op &eacute;&eacute;n regel.
Als je de &lt;Return&gt; gebruikt om naar de volgende regel te gaan,
krijg je een paragraaf met ongelijke rechtermarges.
<P>Als je een aantal regels voorbij een redelijke breedte laat gaan, kun
je ze met een aantal editors niet zien.
<P>De <B>auto-fill</B> mode zorgt dat deze saaie taak automatisch wordt
gedaan: als je verder gaat dan een bepaalde kolom
(standaard de 70e), ga je automatisch naar de volgende regel.
<P>Je kunt deze mode als volgt gebruiken en de breedte-instelling van je
regels op 80 instellen:
<P>
<BLOCKQUOTE><CODE>
<PRE>
 (setq sgml-mode-hook
 '(lambda () "Standaardwaarden voor SGML mode."
 (auto-fill-mode)       
 (setq fill-column 80)))
 
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="s5">5. Ispell</A></H2>

<P>Als je vanuit Emacs je document op spelling wilt controleren, kun je daarvoor
het <B>Ispell</B>-package gebruiken in de Emacs mode.
<H2>5.1 Kiezen van je standaard-woordenboeken</H2>

<P>Je kunt Emacs zo instelen, dat het bij het laden van een bestand, automatisch
woordenboeken selecteert (je kunt er verscheidene gebruiken).
De eerste, zeker de belangrijkste, is het hoofdwoordenboek,
dat met Ispell wordt gedistribueerd.
Je kunt tussen verscheidene talen kiezen. De tweede is
je persoonlijke woordenboek, waarin Ispell die woorden zal zetten die het
niet in het hoofdwoordenboek kon vinden maar waarvan je aangaf dat ze 
moesten worden `onthouden'.
<P>Als je het Franse woordenboek dat met Ispell wordt meegeleverd, wilt gebruiken
als standaard-woordenboek en als je het bestand
<CODE>.ispell-dico-perso</CODE> in je home-directory als een persoonlijk
woordenboek wilt gebruiken, zet dan de volgende regels in het bestand 
<CODE>.emacs</CODE>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
 (setq sgml-mode-hook
 '(lambda () "Standaardwaarde voor SGML mode."
 (setq ispell-personal-dictionary "~/.ispell-dico-perso")
 (ispell-change-dictionary "francais")
 ))
 
</PRE>
</CODE></BLOCKQUOTE>
<H2>5.2 Selecteren van speciale woordenboeken voor bepaalde bestanden</H2>

<P>Het kan een probleem zijn als je de spelling in je documenten niet altijd
in dezelfde taal wilt controleren.
Als je documenten vertaalt, is het zeer waarschijnlijk dat je vaak van
taal (en woordenboeken) verwisselt.
<P>Ik weet niet hoe je op enige Lisp-wijze, ofwel
automatisch of met een enkele muisklik, het hoofdwoordenboek en
persoonlijke woordenboeken geassocieerd met de taal die op dat moment
wordt gebruikt, kunt selecteren.
(Als je dit wel weet, laat me dit dan alsjeblieft weten!)
<P>Het is echter mogelijk om aan het einde van het bestand aan te geven, welke
woordenlijsten je voor het huidige bestand (en slechts deze) wilt gebruiken.
Het volstaat om ze als commentaar toe te voegen, zodat Ispell
ze bij het opstarten van de spellingscontrole kan inlezen:
<P>
<PRE>
&lt;!-- Local IspellDict: english -->
&lt;!-- Local IspellPersDict: ~/emacs/.ispell-english -->
 
</PRE>
<P>Als je voorheen, in het bestand <CODE>.emacs</CODE>, hebt opgegeven dat
je standaard-woordenboeken de Franse woordenboeken zijn, dan kun
je deze regels aan het einde van ieder bestand in 't
Engels toevoegen.
<H2>5.3 Controleren van de spelling in je document</H2>

<P>Om je gehele document op spelling te controleren, gebruik je vanuit een
willekeurige plaats in het document het commando
<CODE>Meta-x ispell-buffer</CODE>. Je kunt ook slechts de spelling van een
deel van je document controleren:
<P>
<UL>
<LI> Markeer het begin van het gebied met <CODE>Ctrl-Spc</CODE>
(mark-set-command),</LI>
<LI> Ga naar het einde van het gebied dat moet worden gecontroleerd,</LI>
<LI> typ <CODE>Meta-x ispell-region</CODE>.</LI>
</UL>
<P>Emacs start dan vervolgens Ispell op. Zodra het een onbekend woord tegenkomt,
wordt het woord getoond (meestal benadrukt) en wacht tot je 
&eacute;&eacute;n van de volgende toetsen indrukt:
<P>
<UL>
<LI><B>spc </B>accepteer alleen deze keer het woord,</LI>
<LI><B>i </B>accepteer het woord en voegt het toe aan je
persoonlijke woordenboek,</LI>
<LI><B>a </B>accepteer het woord voor deze sessie,</LI>
<LI><B>A </B>accepteer het woord voor dit bestand, en voeg het toe
aan het lokale woordenboekbestand</LI>
<LI><B>r </B>staat je toe om het woord handmatig te wijzigen</LI>
<LI><B>R </B>staat je toe om het onjuist gespelde woord in alle 
voorkomende gevallen te wijzigen,</LI>
<LI><B>x </B>stop het controleren en zet de cursor weer terug op
z'n plaats,</LI>
<LI><B>X </B>stop het controleren en laat de cursor waar het is,
zodat je je bestand kunt corrigeren;je zul later weer verder kunnen gaan
met het controleren van de spelling als je
<CODE>Meta-x ispell-continue</CODE> intikt,</LI>
<LI><B>? </B>geeft je online-help.</LI>
</UL>
<P>Als ispell &eacute;&eacute;n of meerdere woorden vindt, die het onbekende
woord benaderen, zal het ze in een klein venster tonen, waarbij ieder woord
wordt voorafgegaan door een cijfer. Typ gewoon dit cijfer in om het
onjuist gespelde woord te vervangen door het corresponderende woord.
<H2>5.4 Persoonlijk woordenboek versus lokaal woordenboekbestand</H2>

<P>Met de <B>i</B> toets kun je een woord invoegen in je persoonlijke
woordenboek, en met <B>A</B> kun je een woord invoegen in het
lokale woordenboekbestand.
<P>Het lokale woordenboekbestand bestaat uit een reeks woorden die aan het
einde van het bestand als commentaar worden ingevoegd, en iedere keer
dat Ispell met dit bestand wordt opgestart, opnieuw worden ingelezen.
Op deze manier, kun je een aantal woorden accepteren, die in dit bestand,
maar niet noodzakelijk in andere bestanden zijn toegestaan.
<P>Wat mezelf betreft, denk ik dat het beter is dat het persoonlijke
woordenboek gereserveerd moet zijn voor woorden die niet in het
hoofdwoordenboek staan maar die wel aan de taal toebehoren
(zoals afgebroken woorden), plus een aantal algemene woorden zoals
proper nouns of anderen (zoals <I>Linux</I>), alz ze niet te veel
op een echt woord uit het hoofdwoordenboek lijken;
het toevoegen van te veel woorden in het persoonlijke woordenboek
zoals voornamen, kan risico's met zich meebrengen omdat ze op een
woord uit de werkelijke taal kunnen lijken
(je kunt je voorstellen dat Ispell door het volgende wordt gefopt:
`<I>When the going gets tof, the tof get going</I>
<BLOCKQUOTE><EM>Tof</EM> is een Franse afkorting voor de voornaam
<EM>Christophe</EM>!').</BLOCKQUOTE>
<H2>5.5 Controleren van de spelling tijdens het typen</H2>

<P>Ispell kan je bestand tijdens het typen op spelling controleren.
Hiervoor moet je de <B>ispell-minor-mode</B> gebruiken.
Om het te starten of te stoppen, tik je in:
<CODE>Meta-x ispell-minor-mode</CODE>. Ispell zal iedere keer dat je
een woord intikt en het niet kent een <EM>beep</EM> produceren.
<P>Als die <EM>beeps</EM> je irriteren (of je kamergenoot doet een dutje),
kun je die hinderlijke <EM>beeps</EM> vervangen door 
een flits op het scherm, met het commando
<CODE>Meta-x set-variable RET visible-bell RET t RET</CODE>. Je kunt
de volgende regel aan je bestand <CODE>.emacs</CODE> toevoegen om Emacs voorgoed
tot zwijgen brengen:
<P>
<PRE>
 (setq visible-bell t)
</PRE>
<H2><A NAME="s6">6. Truuks</A></H2>

<H2>6.1 Automatisch invoegen van een header</H2>

<P>Emacs staat je toe om een aantal acties aan een event te <EM>koppelen</EM>
(openen van een bestand, opslaan, opstarten van een nieuwe mode, enz).
<P>De <B>autoinsert</B> library maakt van deze faciliteit gebruik: 
als je een nieuw bestand onder Emacs opent, voegt deze library,
overeenkomstig het type bestand, een <EM>standaard</EM> header in.
<P>In ons geval, zou deze <EM>standaard</EM>
header evengoed het deel kunnen zijn dat het documenttype
(LinuxDoc), de titel, de auteur, en de datum declareert.
<P>Ik zal hier twee manieren beschrijven om een dergelijke header in te voegen. 
Je zou een sjabloon-bestand met informatie in kunnen voegen, of je zou
een <B>elisp</B>-routine op kunnen starten.
<H3>door het invoegen van een bestand</H3>

<P>Je moet Emacs eerst laten weten dat het de
<CODE>auto-insert</CODE> opstart als het een bestand opent, dan
de <B>autoinsert</B> library in te lezen, die de
<CODE>auto-insert-alist</CODE> lijst declareert die we moeten wijzigen. Deze
lijst definieert de header voor ieder bestandstype die moet worden ingevoegd. 
Standaard moet het bestand dat moet worden ingevoegd in de
<CODE>~/insert/</CODE> directory staan, maar het is mogelijk om de
<CODE>auto-insert-directory</CODE> variabele te herdefini&euml;ren,
als je het ergens anders wilt plaatsen.
<P>Voeg de volgende regels toe aan je <CODE>.emacs</CODE> bestand om het
bestand <CODE>~/emacs/sgml-insert.sgml</CODE> iedere keer dat je een
nieuw SGML-bestand opent, in te voegen:
<P>
<PRE>
(add-hook 'find-file-hooks 'auto-insert)
(load-library "autoinsert")
(setq auto-insert-directory "~/emacs/")
(setq auto-insert-alist
(append '((sgml-mode .  "sgml-insert.sgml"))
  auto-insert-alist))
</PRE>
<P>Vervolgens kun je in het bestand <CODE>~/emacs/sgml-insert.sgml</CODE>
je aangepaste header wegschrijven en dan Emacs opnieuw opstarten en
&eacute;&eacute;n of ander bestand
<CODE>foobar.sgml</CODE> openen. Emacs zou je moeten vragen om de automatische
invoeging te bevestigen en als je `yes' antwoordt, je header invoegen.
<H3>door het opstarten van een routine</H3>

<P>Dit werkt net als voorheen, maar in plaats van de
<CODE>auto-insert-alist</CODE> in te stellen op een bestand dat moet worden
ingevoegd, zul je het in moeten stellen
op een functie die moet worden uitgevoerd.
Zo kunt je verdergaan, ervan uitgaande dat je deze functie wilt wegschrijven
in een bestand met de naam <CODE>~/emacs/sgml-header.el</CODE>.
(het is niet nodig je <CODE>.emacs</CODE> bestand met een dergelijke functie
te belasten, aangezien het nogal lang kan worden):
<P>
<PRE>
(add-hook 'find-file-hooks 'auto-insert)
(load-library "autoinsert")
(add-to-list 'load-path "~/emacs")
(load-library "sgml-header")
(setq auto-insert-alist
(append '(((sgml-mode .  "SGML Mode") . insert-sgml-header))
                    auto-insert-alist))
</PRE>
<P>In de 
<A HREF="#insert-sgml-header">appendix</A> zul je een
voorbeeld aantreffen van de <CODE>insert-sgml-header</CODE> functie.
<H2>Appendix</H2>
<H2><A NAME="insert-sgml-header"></A> <A NAME="s7">7. Een insert-sgml-header functie </A></H2>

<P>Deze functie zal voor de gebruiker een aangepaste header, voor een Linux
Documentatie Project document, in een nieuw bestand invoegen. Het kan
automatisch, wanneer er een nieuw bestand wordt geopend,
of expliciet door de gebruiker worden aangeroepen.
<P>Deze functie vraagt de gebruiker, via de <EM>mini-buffer</EM>,
om wat informatie, een deel daarvan is nodig, een deel daarvan niet.
<P>Als eerste komt de titel. Als er geen wordt opgegeven, keert de functie
onmiddellijk terug, en voegt niets in. Dan komt de datum, de auteur, 
zijn e-mail en home-page (deze laatste twee zijn optioneel).
<P>Dan komt een verzoek voor de naam van de vertaler. Als er geen is,
typ je gewoon <EM>Return</EM>, en er zullen verder geen vragen meer 
worden gesteld over een hypothetische vertaler.
Als er wel &eacute;&eacute;n is, wordt
je om zijn e-mail en home-pagina gevraagd (ook optioneel).
<P>Deze functie drukt je verzoek vervolgens naar de huidige buffer af,
natuurlijk inclusief alle informatie die je in het invoerformulier
hebt ingetikt, en ook inclusief de tags die dienen voor de samenvatting
en het eerste hoofdstuk. Als laatste zet het de cursor op die plaats waar
de samenvatting moet worden ingetypt.
<P>
<PRE>
(defun insert-sgml-header ()
"Voegt de header voor een LinuxDoc document in"
(interactive)
(let (title author email home translator email-translator home-translator date 
              starting-point)
(setq title (read-from-minibuffer "Titel: "))
(if (> (length title) 0)
        (progn 
          (setq date (read-from-minibuffer "Datum: ")
                author (read-from-minibuffer "Auteur: ")
                email (read-from-minibuffer "Auteur e-mail: ")
                home (read-from-minibuffer "Auteur home-pagina: http://")
                translator (read-from-minibuffer "Vertaler: "))
          (insert "&lt;!doctype linuxdoc system>\n&lt;article>\n&lt;title>")
          (insert title)
          (insert "&lt;/title>\n&lt;author>\nAuthor: ") (insert author) (insert "&lt;newline>\n")
          (if (> (length email) 0)
              (progn
                (insert "&lt;htmlurl url=\"mailto:")
                (insert email) (insert "\" name=\"") (insert email)
                (insert "\">&lt;newline>\n")))
          (if (> (length home) 0)
              (progn
                (insert "&lt;htmlurl url=\"http://")
                (insert home) (insert "\" name=\"") (insert home)
                (insert "\">\n&lt;newline>")))
          (if (> (length translator) 0)
              (progn
                (setq email-translator (read-from-minibuffer "Vertaler e-mail: ")
                      home-translator (read-from-minibuffer "Vertaler home-pagina: http://"))
                (insert "Vertaald door : ") 
                (insert translator) 
                (insert "&lt;newline>\n")
                (if (> (length email-translator) 0)
                    (progn 
                      (insert "&lt;htmlurl url=\"mailto:") 
                      (insert email-translator) (insert "\" name=\"") 
                      (insert email-translator)
                      (insert "\">&lt;newline>\n")))
                (if (> (length home-translator) 0)
                    (progn 
                      (insert "&lt;htmlurl url=\"http://") 
                      (insert home-translator) (insert "\" name=\"")
                      (insert home-translator)
                      (insert "\">&lt;newline>\n")))))
          (insert "&lt;/author>\n&lt;date>\n")
          (insert date)
          (insert "\n&lt;/date>\n\n&lt;abstract>\n")
          (setq point-beginning (point))
          (insert "\n&lt;/abstract>\n&lt;toc>\n\n&lt;sect>\n&lt;p>\n\n\n&lt;/sect>\n\n&lt;/article>\n")
          (goto-char point-beginning)
          ))))
 
</PRE>
</BODY>
</HTML>
