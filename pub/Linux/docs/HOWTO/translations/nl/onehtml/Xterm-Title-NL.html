<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>De titel van een xterm wijzigen</TITLE>


</HEAD>
<BODY>
<H1>De titel van een xterm wijzigen</H1>

<H2>Ric Lister, <CODE>ric@giccs.georgetown.edu</CODE>,<BR>
Vertaald door: Ellen Bokhorst <CODE>bokkie@nl.linux.org</CODE></H2>v2.0, 27 oktober 1999
<P><HR>
<EM>In dit document wordt uitgelegd hoe escape sequences kunnen worden gebruikt
om dynamisch de titel van een xterm-venster en een ikoon te wijzigen.
Voor verscheidene shells wordt voorzien in voorbeelden, en in de appendix
zijn escape sequences gegeven voor een aantal andere typen terminals.</EM>
<HR>
<H2><A NAME="s1">1. Waar dit document is te vinden</A></H2>

<P>Dit document maakt nu onderdeel uit van de
<A HREF="http://sunsite.unc.edu/LDP/HOWTO/">Linux HOWTO Index</A>
en het is te vinden op
<A HREF="http://sunsite.unc.edu/LDP/HOWTO/mini/Xterm-Title.html">http://sunsite.unc.edu/LDP/HOWTO/mini/Xterm-Title.html</A>.
<P>De laatste versie is altijd in verscheidene formaten te vinden op
<A HREF="http://www.giccs.georgetown.edu/~ric/howto/Xterm-Title/">http://www.giccs.georgetown.edu/~ric/howto/Xterm-Title/</A>.
<P>Dit document overvleugelt de oorspronkelijke howto geschreven door
Winfried Tr&uuml;mper.
<H2><A NAME="s2">2. Statische titels</A></H2>

<P>Een statische titel kan voor ieder van de terminals <CODE>xterm</CODE>,
<CODE>color-xterm</CODE> of <CODE>rxvt</CODE> worden ingesteld, door gebruik te
maken van de opties <CODE>-T</CODE> en <CODE>-n</CODE>:
<BLOCKQUOTE><CODE>
xterm -T "Mijn XTerm Titel" -n "Mijn XTerm Ikoon Titel"
</CODE></BLOCKQUOTE>
<H2><A NAME="s3">3. Dynamische titels</A></H2>

<P>Veel mensen vinden het handig om de titel van een terminal zo in
te stellen dat het dynamisch informatie weergeeft, zoals de hostnaam
waarop de gebruiker is ingelogd of de huidige werkdirectory, enz.
<H2>3.1 xterm escape sequences</H2>

<P>Ikoon- en venstertitels van een draaiende xterm kunnen worden gewijzigd
door gebruik te maken van XTerm escape sequences. In deze zin zijn 
de volgende sequences nuttig:
<UL>
<LI><CODE>ESC]0;<B>string</B>BEL</CODE> -- Stel de naam van het ikoon en
de venstertitel in op <B>string</B></LI>
<LI><CODE>ESC]1;<B>string</B>BEL</CODE> -- Stel de naam van het ikoon in op
<B>string</B></LI>
<LI><CODE>ESC]2;<B>string</B>BEL</CODE> -- Stel de venstertitel in op
<B>string</B></LI>
</UL>
<P><CODE>ESC</CODE> is hier het <B>escape</B>-teken (\033), en <CODE>BEL</CODE> is
het <B>bell</B> teken (\007).
<P>Het afdrukken van &eacute;&eacute;n van deze sequences zorgt dat
de titel van het venster of de ikoon wordt gewijzigd.
<P><B>Opmerking</B>: deze sequences zijn van toepassing op de meeste
afgeleiden van xterm, zoals <CODE>nxterm</CODE>, <CODE>color-xterm</CODE> en
<CODE>rxvt</CODE>. Andere typen terminals maken vaak gebruik van andere
escapes; zie de appendix voor voorbeelden.
Zie het bestand
<A HREF="http://www.giccs.georgetown.edu/~ric/howto/Xterm-Title/ctlseq2.txt">ctlseq2.txt</A>,
Voor een volledige lijst met xterm escape sequences, welke met de xterm
distributie wordt meegeleverd, of
<A HREF="http://www.giccs.georgetown.edu/~ric/howto/Xterm-Title/xterm.seq">xterm.seq</A>, welke wordt meegeleverd met de 
<A HREF="http://www.rxvt.org/">rxvt</A> distributie.
<H2>3.2 Afdrukken van escape sequences</H2>

<P>Voor informatie die gedurende de levensduur van deze shell gelijk blijft,
zoals de host- en gebruikersnaam, volstaat een echo-commando door 
eenvoudigweg de escape string in het rc bestand van de shell te plaatsen:
<BLOCKQUOTE><CODE>
<PRE>
echo -n "\033]0;${USER}@${HOST}\007"
</PRE>
</CODE></BLOCKQUOTE>

zal een titel produceren zoals <CODE>username@hostname</CODE>, in de
veronderstelling dat de shellvariabelen
<CODE>$USER</CODE> en <CODE>$HOST</CODE> correct zijn ingesteld.
De benodigde opties voor <CODE>echo</CODE> kunnen per shell vari&euml;ren
(zie de voorbeelden verderop).
<P>Voor informatie die tijdens de levensduur kan wijzigen, zoals de
huidige werkdirectory, moeten deze escapes echt, iedere keer dat de
prompt wijzigt, worden aangepast.
Zo wordt bij iedere opdracht die je aanroept de string
gewijzigd en kan informatie worden bijgehouden zoals de huidige
werkdirectory, naam van de gebruikers, hostnaam, enz. Een aantal shells
voorziet in speciale functies voor dit doel, een aantal doet dit niet en
we moeten de titel sequences direct in de promptstring voegen.
Dit wordt in de volgende sectie ge&iuml;llustreerd.
<H2><A NAME="s4">4. Voorbeelden voor verschillende shells</A></H2>

<P>Hieronder wordt een set voorbeelden gegeven voor de wat meer gebruikelijke
shells. We beginnen met <CODE>zsh</CODE> aangezien het diverse mogelijkheden
biedt die onze taak er veel eenvoudiger op maken.
We zullen vervolgens steeds moeilijkere voorbeelden doorwerken.
<P>In alle voorbeelden testen we de omgevingsvariabele <CODE>$TERM</CODE>
om er zeker van te zijn dat we de escapes alleen toepassen op xterms. 
We testen op <CODE>$TERM=xterm*</CODE>; het jokerteken wordt gebruikt omdat
een aantal varianten (zoals rxvt) deze omgevingsvariabele in kan
stellen op <CODE>$TERM=xterm-color</CODE>.
<P>We zouden een extra opmerking over C-shellafgeleiden, zoals
<CODE>tcsh</CODE> en <CODE>csh</CODE> moeten maken. In C shells, worden
ongedefinieerde variabelen als fatale fouten beschouwd.
Daarom is het nodig voor het testen van de variabele <CODE>$TERM</CODE>, 
te testen op het bestaan ervan. Om dit te bereiken moet je de voorbeelden
hieronder wijzigen in zoiets als:
<BLOCKQUOTE><CODE>
<PRE>
  if ($?TERM) then
      ...
  endif
</PRE>
</CODE></BLOCKQUOTE>

(Wij vinden dit &eacute;&eacute;n van de vele redenen om geen gebruik te
maken van C-shells. Zie
<I>
<A HREF="http://language.perl.com/versus/csh.whynot">Csh Programming Considered Harmful</A></I> voor een
nuttige bespreking).
<P>De voorbeelden hierna zouden kunnen worden gebruikt door ze te plaatsen
in het van toepassing zijnde shell-initialisatiebestand; d.w.z. 
&eacute;&eacute;n die bij het opstarten door interactieve shells wordt
ingelezen. In de meeste gevallen heeft deze een naam zoals in
<CODE>.<I>shell</I>rc</CODE> (b.v. <CODE>.zshrc</CODE>, <CODE>.tcshrc</CODE>, enz).
<H2>4.1 zsh</H2>

<P><CODE>zsh</CODE> biedt de volgende functies en uitbreidingen, waar
we gebruik van zullen maken:
<BLOCKQUOTE><CODE>
<PRE>
precmd ()   een functie die v&oacute;&oacute;r iedere prompt wordt uitgevoerd
chpwd ()    een functie die wordt uitgevoerd wanneer de directory wijzigt
\e          escape sequence voor escape (ESC)
\a          escape sequence voor bell (BEL)
%n          extraheert naar $USERNAME
%m          extraheert naar hostnaam tot aan de eerste '.'
%~          extraheert naar directory, $HOME wordt vervangen door '~'
</PRE>
</CODE></BLOCKQUOTE>

Er zijn nog heel wat meer uitbreidingen beschikbaar: zie de 
<CODE>zshmisc</CODE> man page.
<P>Dus het volgende zal de xterm titel instellen op
"<CODE><I>gebruikersnaam</I>@<I>hostnaam</I>: <I>directory</I></CODE>":
<BLOCKQUOTE><CODE>
<PRE>
case $TERM in
    xterm*)
        precmd () {print -Pn "\e]0;%n@%m: %~\a"}
        ;;
esac
</PRE>
</CODE></BLOCKQUOTE>

Dit zou ook bewerkstelligd kunnen worden door gebruik te maken van
<CODE>chpwd()</CODE> in plaats van <CODE>precmd()</CODE>. 
De ingebouwde opdracht <CODE>print</CODE> werkt net als
<CODE>echo</CODE>, maar geeft ons ook nog eens toegang tot de <CODE>%</CODE>
prompt escapes.
<H2>4.2 tcsh</H2>

<P><CODE>tcsh</CODE> heeft een aantal functies en uitbreidingen die vergelijkbaar
zijn met die van <CODE>zsh</CODE>:
<BLOCKQUOTE><CODE>
<PRE>
precmd ()   een functie die voor iedere prompt wordt uitgevoerd
cwdcmd ()   een functie die wordt uitgevoerd wanneer de directory wijzigt
%n          extraheert naar gebruikersnaam
%m          extraheert naar hostnaam
%~          extraheert naar directory, $HOME wordt vervangen door '~'
%#              breidt uit naar '>' voor gewone gebruikers, '#' voor
%root-gebruikers
%{...%}     voegt een string in als een letterlijke escape sequence
</PRE>
</CODE></BLOCKQUOTE>
<P>Helaas is er geen equivalente voor de opdracht <CODE>print</CODE> van <CODE>zsh</CODE>
die het ons toestaat prompt escapes in de titelstring te gebruiken,
dus het beste wat we kunnen doen is gebruik te maken van
shellvariabelen (in <CODE>~/.tcshrc</CODE>):
<BLOCKQUOTE><CODE>
<PRE>
switch ($TERM)
    case "xterm*":
        alias precmd 'echo -n "\033]0;${HOST}:$cwd\007"'
        breaksw
endsw
</PRE>
</CODE></BLOCKQUOTE>

Hierdoor krijg je echter het volledige pad van de directory in plaats
dat er gebruik wordt gemaakt van <CODE>~</CODE>.
In plaats daarvan kun je de string in de prompt plaatsen:
<BLOCKQUOTE><CODE>
<PRE>
switch ($TERM)
    case "xterm*":
        set prompt="%{\033]0;%n@%m:%~\007%}tcsh%# "
        breaksw
    default:
        set prompt="tcsh%# "
        breaksw
endsw
</PRE>
</CODE></BLOCKQUOTE>

hiermee wordt de prompt ingesteld op "<CODE>tcsh% </CODE>", en een xterm-titel
en ikoon "<CODE><I>gebruikersnaam</I>@<I>hostnaam</I>: <I>directory</I></CODE>". Houd in de gaten dat de "<CODE>%{...%}</CODE>" tussen escape sequences
moet worden geplaatst (en niet het laatste item in de prompt kan zijn:
zie de manpage van <CODE>tcsh</CODE> voor details).
<H2>4.3 bash</H2>

<P><CODE>bash</CODE> voorziet in de variabele <CODE>$PROMPT_COMMAND</CODE> waaraan
de opdracht is toegekend welke v&oacute;&oacute;r de weergave van de
prompt wordt uitgevoerd. Dit voorbeeld stelt de titel in op
<CODE>gebruikersnaam@hostnaam: directory</CODE>:
<BLOCKQUOTE><CODE>
<PRE>
PROMPT_COMMAND='echo -ne "\033]0;${USER}@${HOSTNAME}: ${PWD}\007"'
</PRE>
</CODE></BLOCKQUOTE>

<CODE>\033</CODE> is hier de tekencode voor <CODE>ESC</CODE>,
en <CODE>\007</CODE> voor <CODE>BEL</CODE>.
<P>De aanhalingstekens zijn hier belangrijk: variabelen worden ge&euml;xtraheerd
naar <CODE>"..."</CODE>, en niet naar <CODE>'...'</CODE>. 
Dus<CODE>$PROMPT_COMMAND</CODE> wordt op een niet ge&euml;xtraheerde waarde
ingesteld, en de variabelen binnen de <CODE>"..."</CODE> worden ge&euml;xtraheerd
wanneer <CODE>$PROMPT_COMMAND</CODE> wordt gebruikt.
<P><CODE>$PWD</CODE> produceert echter het volledige pad van de directory. 
Als we de verkorte vorm
<CODE>~</CODE> willen, moet we de escape string in de prompt opnemen,
wat maakt dat we voordeel kunnen hebben van de door in de shell voorziene
uitbreidingen op de prompt:
<BLOCKQUOTE><CODE>
<PRE>
\u          extraheert naar $USERNAME
\h          extraheert naar hostnaam tot aan de eerste '.'
\w          extraheert naar directory, $HOME wordt vervangen door '~'
\$              extraheert voor gewone gebruikers naar '$', '#' voor root
\[...\]     sluit een reeks in met niet afdrukbare tekens
</PRE>
</CODE></BLOCKQUOTE>
<P>Dus het volgende produceert een prompt <CODE>bash$ </CODE>, en een xterm
titel <CODE>gebruikersnaam@hostnaam: directory</CODE>:
<BLOCKQUOTE><CODE>
<PRE>
case $TERM in
    xterm*)
        PS1="\[\033]0;\u@\h: \w\007\]bash\\$ "
        ;;
    *)
        PS1="bash\\$ "
        ;;
esac
</PRE>
</CODE></BLOCKQUOTE>

Let op het gebruik van <CODE>\[...\]</CODE>, waarmee aan <CODE>bash</CODE> wordt
aangegeven de niet afdrukbare controletekens te negeren, wanneer de breedte
van de prompt wordt berekend. Anders onstaat er verwarring bij het plaatsen
van de cursor bij regelediting opdrachten.
<H2>4.4 ksh</H2>

<P><CODE>ksh</CODE> voorziet in weinig functies en uitbreidingen, dus moeten
we de escapestring in de prompt voegen, om het dynamisch te laten
bijwerken. Dit voorbeeld produceert een titel met
<CODE>gebruikersnaam@hostnaam: directory</CODE> en een prompt <CODE>ksh$ </CODE>.
<BLOCKQUOTE><CODE>
<PRE>
case $TERM in
    xterm*)
        HOST=`hostname`
        PS1='^[]0;${USER}@${HOST}: ${PWD}^Gksh$ '
        ;;
    *)
        PS1='ksh$ '
        ;;
esac
</PRE>
</CODE></BLOCKQUOTE>

<CODE>$PWD</CODE> produceert echter het volledige pad van de directory. 
We kunnen het voorvoegsel
<CODE>$HOME/</CODE> van de directory verwijderen door gebruik te maken van
de constructie <CODE>${...##...}</CODE>.
We kunnen ook gebruik maken van <CODE>${...%%...}</CODE> om de hostnaaam
af te kappen:
<BLOCKQUOTE><CODE>
<PRE>
HOST=`hostname`
HOST=${HOST%%.*}
PS1='^[]0;${USER}@${HOST}: ${PWD##${HOME}/}^Gksh$ '
</PRE>
</CODE></BLOCKQUOTE>

De <CODE>^[</CODE> en <CODE>^G</CODE> in de promptstring zijn enkele tekens voor
<CODE>ESC</CODE> en <CODE>BEL</CODE> (kan in emacs door het invoeren
van <CODE>C-q ESC</CODE> en <CODE>C-q C-g</CODE>).
<H2>4.5 csh</H2>

<P>Dit is in <CODE>csh</CODE> inderdaad erg moeilijk, en we komen ongeveer hierop
uit:
<BLOCKQUOTE><CODE>
<PRE>
switch ($TERM)
    case "xterm*":
        set host=`hostname`
        alias cd 'cd \!*; echo -n "^[]0;${user}@${host}: ${cwd}^Gcsh% "'
        breaksw
    default:
        set prompt='csh% '
        breaksw
endsw
</PRE>
</CODE></BLOCKQUOTE>

waarbij we een alias voor de opdracht <CODE>cd</CODE> opdracht gebruiken om
de escape sequence te sturen.
De <CODE>^[</CODE> en <CODE>^G</CODE> in de string zijn enkele tekens voor
<CODE>ESC</CODE> en <CODE>BEL</CODE>
(kunnen in emacs worden ingevoerd met <CODE>C-q ESC</CODE> en <CODE>C-q C-g</CODE>).
<P>Opmerkingen: op een aantal systemen kan <CODE>hostname -s</CODE> worden
gebruikt om een afgekorte versie, in plaats van de fully-qualified
hostnaam te verkrijgen. Een aantal gebruikers met symlinked directory's
bemerken mogelijk dat <CODE>`pwd`</CODE> (achterwaartse aanhalingstekens voor
het uitvoeren van de opdracht <CODE>pwd</CODE>) een accurater pad teruggeeft dan
<CODE>$pwd</CODE>.
<H2><A NAME="s5">5. Afdrukken van de huidige jobnaam</A></H2>

<P>Vaak zal een gebruiker een voorgrondtaak opstarten zoals <CODE>top</CODE>,
een editor, een emailclient, enz, en willen dat de naam van de job in
de titel wordt weergegeven. Dit is een wat neteliger probleem en kan alleen
eenvoudig worden bewerkstelligd met <CODE>zsh</CODE>.
<H2>5.1 zsh</H2>

<P><CODE>zsh</CODE> voorziet in een ideale ingebouwde functie voor dit doel:
<BLOCKQUOTE><CODE>
<PRE>
preexec()   een functie die net voor uitvoering van een opdracht wordt
uitgevoerd
$*,$1,...   argumenten doorgegeven aan preexec()
</PRE>
</CODE></BLOCKQUOTE>

Dus we kunnen als volgt de jobnaam in de titel voegen:
<BLOCKQUOTE><CODE>
<PRE>
case $TERM in
    xterm*)
      preexec () {
        print -Pn "\e]0;$*\a"
      }
    ;;
esac
</PRE>
</CODE></BLOCKQUOTE>

Opmerking: de <CODE>preexec()</CODE> functie verscheen zo rond versie 3.1.2
van <CODE>zsh</CODE>, dus wellicht moet je een eerdere versie upgraden.
<H2>5.2 Andere shells</H2>

<P>Dit is in andere shells niet eenvoudig door het ontbreken van een
equivalente opdracht als de
<CODE>preexec()</CODE> functie. Als iemand anders voorbeelden heeft, email 
deze dan alsjeblieft naar de auteur.
<H2><A NAME="s6">6. Appendix: escapes voor andere typen terminals</A></H2>

<P>Veel moderne terminals zijn afgeleid van <CODE>xterm</CODE> of <CODE>rxvt</CODE>
en ondersteunen de tot nu toe gebruikte escape sequences. 
Een aantal eigen terminals die met diverse varianten van unix worden
meegeleverd maken gebruik van eigen escape sequences.
<H2>6.1 IBM <CODE>aixterm</CODE></H2>

<P><CODE>aixterm</CODE> herkent de <CODE>xterm escape</CODE> sequences.
<H2>6.2 SGI <CODE>wsh</CODE>, <CODE>xwsh</CODE> en <CODE>winterm</CODE></H2>

<P>Deze terminals zetten de termvariabele in als <CODE>$TERM=iris-ansi</CODE> 
en gebruiken de volgende escapes:
<UL>
<LI><CODE>ESCP1.y<I>string</I>ESC\      Stel de venstertitel in op
<I>string</I></CODE></LI>
<LI><CODE>ESCP3.y<I>string</I>ESC\      Stel de ikoontitel in op
<I>string</I></CODE></LI>
</UL>

Zie de manpage van <CODE>xwsh(1G)</CODE> voor een volledige lijst met <CODE>xwsh</CODE>
escapes.
<P>De Irix terminals ondersteunen ook de <CODE>xterm</CODE> escapes om afzonderlijk
te venstertitel en ikoontitel in te stellen, maar niet de escape om ze beiden
in te stellen.
<H2>6.3 Sun <CODE>cmdtool</CODE> en <CODE>shelltool</CODE></H2>

<P><CODE>cmdtool</CODE> en <CODE>shelltool</CODE> stellen stellen de termvariabele
beiden in als <CODE>$TERM=sun-cmd</CODE> en maken gebruik van de volgende
escapes:
<UL>
<LI><CODE>ESC]l<I>string</I>ESC\    Stel de venster titel in op <I>string</I></CODE></LI>
<LI><CODE>ESC]L<I>string</I>ESC\    Stel de titel van het ikoon in op <I>string</I></CODE></LI>
</UL>

Dit zijn werkelijk afgrijselijke programma's: gebruik iets anders.
<H2>6.4 CDE <CODE>dtterm</CODE></H2>

<P><CODE>dtterm</CODE> stelt de termvariabele in op <CODE>$TERM=dtterm</CODE>, 
en blijkt standaard zowel de standaard
<CODE>xterm</CODE> als de Sun <CODE>cmdtool</CODE>
sequences te herkennen (getest onder Solaris 2.5.1, Digital Unix 4.0, HP-UX 10.20).
<H2>6.5 HPterm</H2>

<P><CODE>hpterm</CODE> stelt de termvariabele in als <CODE>$TERM=hpterm</CODE> en
gebruikt de volgende escapes:
<UL>
<LI><CODE>ESC&amp;f0k<I>length</I>D<I>string</I>   Stel venstertitel in op <I>string</I> van lengte <I>length</I></CODE></LI>
<LI><CODE>ESC&amp;f-1k<I>length</I>D<I>string</I> Stel ikoontitel in op <I>string</I> met de lengte <I>length</I></CODE></LI>
</UL>
<P>Een basis C-programma om de lengte van de string te berekenen en deze
terug te geven, ziet er ongeveer zo uit:
<BLOCKQUOTE><CODE>
<PRE>
#include &lt;string.h>
int main(int argc, char *argv[])
{
    printf("\033&amp;f0k%dD%s", strlen(argv[1]), argv[1]);
    printf("\033&amp;f-1k%dD%s", strlen(argv[1]), argv[1]);
    return(0);
}
</PRE>
</CODE></BLOCKQUOTE>
<P>We kunnen een vergelijkbaar script schrijven door gebruik te maken van
de <CODE>${#string}</CODE>
(<CODE>zsh</CODE>, <CODE>bash</CODE>, <CODE>ksh</CODE>) of <CODE>${%string}</CODE>
(<CODE>tcsh)</CODE>'s uitbreiding om de lengte van de string te achterhalen. 
Het volgende geldt voor <CODE>zsh</CODE>:
<BLOCKQUOTE><CODE>
<PRE>
case $TERM in
    hpterm)
        str="\e]0;%n@%m: %~\a"
        precmd () {print -Pn "\e&amp;f0k${#str}D${str}"}
        precmd () {print -Pn "\e&amp;f-1k${#str}D${str}"}
        ;;
esac
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="s7">7. Appendix: voorbeelden in andere talen</A></H2>

<P>Het kan handig zijn een klein programma te schrijven waarbij een argument
naar de titel wordt afgedrukt door gebruik te maken van
de <CODE>xterm</CODE> escapes. Hierna wordt een aantal voorbeelden gegeven.
<H2>7.1 C</H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
#include &lt;stdio.h>

int main (int argc, char *argv[]) {
  printf("%c]0;%s%c", '\033', argv[1], '\007');
  return(0);
}
</PRE>
</CODE></BLOCKQUOTE>
<H2>7.2 Perl</H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
#!/usr/bin/perl
print "\033]0;@ARGV\007";
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="s8">8. Krediet</A></H2>

<P>Met dank aan de volgende mensen die voorzagen in advies, correcties op
fouten en voorbeelden voor dit document.
<P>Paul D. Smith <CODE>&lt;psmith@BayNetworks.COM&gt;</CODE> en
Christophe Martin <CODE>&lt;cmartin@ipnl.in2p3.fr&gt;</CODE>
wezen er beiden op dat ik de aanhalingstekens verkeerd om had in 
<CODE>$PROMPT_COMMAND</CODE> van <CODE>bash</CODE>. Ze juist plaatsen betekent
dat variabelen dynamisch <I>worden</I> ge&euml;xtraheerd.
<P>Paul D. Smith <CODE>&lt;psmith@BayNetworks.COM&gt;</CODE>
deed de suggestie voor het gebruik van <CODE>\[...\]</CODE> in de <CODE>bash</CODE>
prompt voor het opnemen van niet afdrukbare tekens.
<P>Christophe Martin <CODE>&lt;cmartin@ipnl.in2p3.fr&gt;</CODE>
leverde de oplossing voor <CODE>ksh</CODE>.
<P>Keith Turner <CODE>&lt;keith@silvaco.com&gt;</CODE>
leverde de escape sequences voor Sun <CODE>cmdtool</CODE> en
<CODE>shelltool</CODE>.
<P>Jean-Albert Ferrez <CODE>&lt;ferrez@dma.epfl.ch&gt;</CODE>
wees op een aantal inconsequenties in het gebruik van "<CODE>PWD</CODE>"
en "<CODE>$PWD</CODE>", en in het gebruik van "<CODE>\</CODE>" vs "<CODE>\\</CODE>".
<P>Bob Ellison <CODE>&lt;papillo@hpellis.fc.hp.com&gt;</CODE> en
Jim Searle <CODE>&lt;jims@broadcom.com&gt;</CODE> testte <CODE>dtterm</CODE>
onder HP-UX.
<P>Teng-Fong Seak <CODE>&lt;seak@drfc.cad.cea.fr&gt;</CODE> deed de suggestie
voor het gebruik van de
<CODE>-s</CODE> optie voor <CODE>hostname</CODE>, het gebruik van <CODE>`pwd`</CODE>, en
<CODE>echo</CODE> onder <CODE>csh</CODE>.
<P>Trilia <CODE>&lt;trilia@nmia.com&gt;</CODE> deed de suggestie voor voorbeelden
in andere talen.
<P>Brian Miller <CODE>&lt;bmiller@telstra.com.au&gt;</CODE> leverde de
escape sequences en voorbeelden aan voor <CODE>hpterm</CODE>.
<P>Lenny Mastrototaro <CODE>&lt;lenny@click3x.com&gt;</CODE> gaf een
uitleg van Irix terminal's gebruik van xterm escape sequences.
<P>Paolo Supino <CODE>&lt;paolo@init.co.il&gt;</CODE> deed de suggestie voor het
gebruik van <CODE>\\$</CODE> in de <CODE>bash</CODE> prompt.
</BODY>
</HTML>
