<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Remote X Apps mini-HOWTO</TITLE>


</HEAD>
<BODY>
<H1>Remote X Apps mini-HOWTO</H1>

<H2>Autheur:
<A HREF="http://www.xs4all.nl/~zweije/"> Vincent Zweije</A>, 
<A HREF="mailto:zweije@xs4all.nl">zweije@xs4all.nl</A><BR>
Vertaler: 
<A HREF="http://people.zeelandnet.nl/reggye"> Reggy Ekkebus</A>, 
<A HREF="mailto:reggy@zeelandnet.nl">reggy@zeelandnet.nl</A></H2>v, 19 November 1999
<P><HR>
<EM>Deze mini-HOWTO beschrijft hoe je remote X applicaties kan draaien. Dit betekent dat je een X programma van de ene computer op een
andere computer kunt draaien. Simpel gezegd: hoe kan ik een X programma draaien op een andere computer dan de computer waar ik achter zit.
Het kenmerk van deze mini-HOWTO is veiligheid. Deze mini-HOWTO bevat ook
informatie over het runnen van X applicaties lokaal met verschillende
ussers.</EM>
<HR>
<H2><A NAME="s1">1.  Introductie</A></H2>

<P>Deze mini-HOWTO is een handleiding over hoe te doen met remote X
applicaties. Hij is geschreven om verschillende redenen.
<OL>
<LI> Er zij al veel vragen gesteld over het draaien van remote 
X applicaties in de newsgroepen.</LI>
<LI> Ik zie heel veel hints als ``gebruik <CODE>xhost + hostname</CODE>''of zelfs
``<CODE>xhost +</CODE>'' om X connecties toe te staan. <B>Dit is belachelijk
onveilig</B>, want er zijn betere methodes.</LI>
<LI> Ik ken geen eenvoudig document dat de opties beschrijft die 
je hebt. Mail mij 
<A HREF="mailto:zweije@xs4all.nl">zweije@xs4all.nl</A> als jij iets beters weet.</LI>
</OL>
<P>Dit document is geschreven met unix achtige systemen in mijn gedachten.
Maar ook al is je lokaal of remote besturings systeem van een ander merk,
dan kun je hier toch vinden hoe sommige dingen werken, je zal wel enige
dingen moeten aanpassen  voor gebruik met je eigen systeem(en). 
<P>De meest recente versie van dit document is altijd aanwezig op
WWW 
<A HREF="http://www.xs4all.nl/~zweije/xauth.html">http://www.xs4all.nl/~zweije/xauth.html</A>. Het
is ook altijd aanwezig op de Remote X Apps mini-HOWTO op
<A HREF="http://sunsite.unc.edu/LDP/HOWTO/mini/Remote-X-Apps">http://sunsite.unc.edu/LDP/HOWTO/mini/Remote-X-Apps</A>. Linux
(mini-)HOWTOs zijn aanwezig op http of ftp van 
<A HREF="http://sunsite.unc.edu/LDP/HOWTO/HOWTO-INDEX-2.html">sunsite.unc.edu</A>.
<P>Dit is versie 0.6.1. Geen waarborg, enkel goede bedoelingen. Ik ben open
voor suggesties, idee&euml;n, nuttige toevoegingen, (fout) correcties,
Etc .. Ik wil dat dit een simpel document blijft, alhoewel met de beste bedoeling 
In HOWTO stijl.
De laatste update dateert van 19 November 1999 door 
<A HREF="http://www.xs4all.nl/~zweije/index.html">Vincent Zweije</A><H2><A NAME="s2">2.  Aanverwante documentatie</A></H2>

<P>Een vergelijkbaar document op WWW is ``What to do when Tk says that your display
is insecure'', 
<A HREF="http://ce-toolkit.crd.ge.com/tkxauth/">http://ce-toolkit.crd.ge.com/tkxauth/</A>. Dit is geschreven door
<A HREF="http://ce-toolkit.crd.ge.com/people/kennykb.html">Kevin Kenny</A>. het is een vergelijkbare oplossing voor X authentificatie
zoals (xauth) in dit document. Alhoewel Kevin zich meer spitst op het
gebruik van xdm met xauth.        
<P>Het X Windows systeem Vol 8 X ``Window System Administrator's
Guide'' van 
<A HREF="http://www.ora.com/">O'Reilly and Associates</A> is ook een goede bron van informatie. 
Enkel ben ik niet in staat geweest om dit te checken.
<P>
<P>Een ander document dat veel lijkt op dat wat je nu leest
met als titel ``Securing X Windows'' is aanwezig op 
<A HREF="http://ciac.llnl.gov/ciac/documents/ciac2316.html">http://ciac.llnl.gov/ciac/documents/ciac2316.html</A>.
<P>Kijk ook eens in de newsgroepen, zoals <CODE>comp.windows.x</CODE>,
<CODE>comp.os.linux.x</CODE>, en <CODE>comp.os.linux.networking</CODE>.
<H2><A NAME="s3">3.  Een voorbeeld</A></H2>

<P>Je gebruikt twee computers, en je gebruikt het X windows systeem van de 
eerste om te typen en om naar te kijken. Je gebruikt de tweede om wat belangrijk
grafisch werk op te doen. Je wilt de tweede gebruiken om naar de uitvoer op het scherm te kijken
van de eerste. Dit maakt het X windows systeem mogelijk.
<P>Je hebt hier natuurlijk een netwerk-connectie voor nodig. Het liefst een snelle;
Het X protocol is een netwerk slak. Maar met een beetje geduld
en een geschikt compressie protocol, kun je zelfs X applicaties runnen via een modem.
Voor het X compressie protocol moet je even kijken op dxpc
<A HREF="http://ccwf.cc.utexas.edu/~zvonler/dxpc/">http://ccwf.cc.utexas.edu/~zvonler/dxpc/</A> of LBX
<A HREF="http://www.ultranet.com/~pauld/faqs/LBX-HOWTO.html">http://www.ultranet.com/~pauld/faqs/LBX-HOWTO.html</A> (ook
bekent als 
<A HREF="http://suncite.unc.edu/LDP/HOWTO/mini/LBX">LBX mini-HOWTO</A>).
<P>
<P>
<P>Je moet twee dingen doen om dit te volbrengen:
<P>
<OL>
<LI> Vertel het lokale display (server) dat hij connecties moet accepteren
van een remote computer</LI>
<LI> Vertel de remote applicatie (client) dat hij zijn output naar het
lokale display moet sturen</LI>
</OL>
<H2><A NAME="s4">4.  Een beetje theorie</A></H2>

<P>Het magische woord is <CODE>DISPLAY</CODE>. In het X window systeem
bestaat het display (simpel gezegd) uit een keyboard, muis en een scherm.
Een display wordt aangestuurd door een server programma beter bekend als 
de X server. De server bediend de display mogelijkheden van programma's 
die ermee connecten.
<P>Een display wordt aangegeven met een naam bv:
<P>
<UL>
<LI> <CODE>DISPLAY=light.uni.verse:0</CODE></LI>
<LI> <CODE>DISPLAY=localhost:4</CODE></LI>
<LI> <CODE>DISPLAY=:0</CODE></LI>
</UL>
<P>Een display bestaat uit een host naam  ( zoals <CODE>light.uni.verse</CODE> en
<CODE>localhost</CODE>), een dubbele punt (<CODE>:</CODE>), een volgorde nummer (zoals <CODE>0</CODE>
en <CODE>4</CODE>). De host-naam van de display is de naam van de computer waar de
X server draait. Als je de host-naam weg laat betekent dit de lokale host.
Het  volgorde nummer is normaal 0 - maar het kan varieer-en als er meerdere
Displays zijn aangesloten op een computer.
<P>Als je ooit een display tegenkomt met een extra <CODE>.n</CODE> indicatie 
erachter, dan is dat het scherm nummer. Een display kan eigenlijk meer
schermen aan. Een display kan eigenlijk meerdere schermen aan.
Normaal is er maar een scherm, met het nummer <CODE>n=0</CODE>, dus dat is
standaard.
<P>Andere formaten van <CODE>DISPLAY</CODE> zijn er, maar die hierboven doet het 
goed voor onze plannen.
<P>Voor technische nieuwsgierigheid:
<UL>
<LI> <CODE>hostname:D.S</CODE> Betekend <CODE>S</CODE> op display <CODE>D</CODE> van host
<CODE>hostname</CODE>; de X server voor dit display luistert op de TCP
poort <CODE>6000+D</CODE>.</LI>
<LI> <CODE>host/unix:D.S</CODE> betekend scherm <CODE>S</CODE> op display <CODE>D</CODE>
van host <CODE>host</CODE>; de X server voor dit display luistert op de
UNIX domein socket <CODE>/tmp/.X11-unix/XD</CODE> listening (dus
hij is alleen berijkbaar vanaf <CODE>host</CODE>)</LI>
<LI> <CODE>:D.S</CODE> is hetzelfde als <CODE>host/unix:D.S</CODE>, waar <CODE>host</CODE>
de locale hostname is.</LI>
</UL>
<H2><A NAME="s5">5.  De client vertellen</A></H2>

<P>Het client programma (Bijvoorbeeld je grafische applicatie) weet
naar welk display hij moet connecten door te kijken naar het
<CODE>DISPLAY</CODE> variabel. Deze instelling kan veranderd worden, door de
client als optie <CODE>-display hostname:0</CODE> te geven als je hem opstart.
Sommige van deze voorbeelden zullen dit duidelijker maken.
<P>Onze computer, is bekend voor de andere computers als light, en we
zitten in het domein uni.verse. Als we een normale X server draaien, de
display is bekend als <CODE>light.uni.verse:0</CODE>. We willen het tekenprogramma
xfig runnen op een remote computer, die als naam heeft <CODE>dark.matt.er</CODE>,
en hij moet zijn output laten zien op light.
<P>Ik ga er van uit dat je op de remote computer (<CODE>dark.matt.er</CODE>) bent in gelogd.
<P>Als je csh draait op de remote computer:
<P>
<BLOCKQUOTE><CODE>
<PRE>
dark% setenv DISPLAY light.uni.verse:0
dark% xfig &amp;
</PRE>
</CODE></BLOCKQUOTE>
<P>of:
<P>
<BLOCKQUOTE><CODE>
<PRE>
dark% xfig -display light.uni.verse:0 &amp;
</PRE>
</CODE></BLOCKQUOTE>
<P>Als je sh of bash draait op de remote computer:
<P>
<BLOCKQUOTE><CODE>
<PRE>
dark$ DISPLAY=light.uni.verse:0
dark$ export DISPLAY
dark$ xfig &amp;
</PRE>
</CODE></BLOCKQUOTE>
<P>of:
<P>
<BLOCKQUOTE><CODE>
<PRE>
dark$ DISPLAY=light.uni.verse:0 xfig &amp;
</PRE>
</CODE></BLOCKQUOTE>
<P>of:
<P>
<BLOCKQUOTE><CODE>
<PRE>
dark$ xfig -display light.uni.verse:0 &amp;
</PRE>
</CODE></BLOCKQUOTE>
<P>Het ziet er naar uit dat sommige versies van telnet automatisch het <CODE>DISPLAY</CODE> variabel
gelijk goed zetten op de remote host. Als je er zo een hebt dan heb veel geluk 
en moet je het niet allemaal met de hand doen. Zo niet, de meeste versies
van telnet trans porteren het <CODE>TERM</CODE> variabel; met een beetje hacken is het 
mogelijk om het <CODE>DISPLAY</CODE> variabele met het <CODE>TERM</CODE> variabel mee te 
laten komen. 
<P>Het idee van het transporteren is een beetje scripting om het volgende te
bereiken: voordat je telnet, bevestigen we het variabel <CODE>DISPLAY</CODE> aan <CODE>TERM</CODE>.
Dan telnet op de remote host, in de <CODE>.*shrc</CODE> file, lees het variabel <CODE>DISPLAY</CODE> van <CODE>TERM</CODE>. 
<H2><A NAME="s6">6.  De server vertellen</A></H2>

<P>De server zal niet zomaar een connectie van iedereen accepteren. Je wilt toch niet dat
iedereen zo maar een window op je scherm kan zetten. Of lezen wat je 
schrijft -- onthoud je keyboard is onderdeel van het display!
<P>Veel mensen schijnen zich niet te realiseren dat het toestaan van toegang tot je 
display een groot security risico is. Iemand met toegang to je display kan
lezen van en schrijven naar je scherm, alles lezen wat je typt, en je muis
acties registreren.
<P>De meeste servers kennen twee manieren voor het legaliseren van connecties
naar de server: het host lijst mechanisme (xhost) en het magic cookie mechanisme (xauth).
Dan is er ook nog ssh, de secure shell, die kan X connecties ook doorsturen.
<H2>6.1  Xhost</H2>

<P>Xhost laat connecties toe op hostnaam. De server houd een lijst bij
van host die mogen connecten. Het kan ook host checking volledig uitschakelen.
Onthoud: dat betekend dat er geen checks meer uitgevoerd worden, dus
<EM>iedere</EM> host mag connecten!
<P>Je kan de servers host list bijhouden met het programmatje xhost. Om dit te 
gebruiken moet je het mechanisme uit het volgende voorbeeld gebruiken.
<P>
<BLOCKQUOTE><CODE>
<PRE>
light$ xhost +dark.matt.er
</PRE>
</CODE></BLOCKQUOTE>
<P>Dit staat connecties van de host <CODE>dark.matt.er</CODE> toe. 
Zodra je X client een connectie heeft gemaakt en een window weergeeft, 
schakel voor de veiligheid meer connecties uit met:
<P>
<BLOCKQUOTE><CODE>
<PRE>
light$ xhost -dark.matt.er
</PRE>
</CODE></BLOCKQUOTE>
<P>Je kan host verificatie uitschakelen met:
<P>
<BLOCKQUOTE><CODE>
<PRE>
light$ xhost +
</PRE>
</CODE></BLOCKQUOTE>
<P>Dit schakelt de host toegang verificatie uit en dus <EM>iedereen</EM>
mag connecten. Je moet dit <EM>nooit</EM> doen op een netwerk waar
je niet <EM>alle</EM> gebruikers vertrouwd (internet bijvoorbeeld).
Je kunt host verificatie weer aanzetten met:
<P>
<BLOCKQUOTE><CODE>
<PRE>
light$ xhost -
</PRE>
</CODE></BLOCKQUOTE>
<P>xhost - verwijderd <EM>niet</EM> alle host-Namen uit zichzelf van de toeganslijst
(dat zou niet echt slim zijn - je kan dan niet meer connecten naar je 
Xserver van waar dan ook - zelfs niet vanaf localhost).
<P><EM>Xhost is een zeer onveilig mechanisme.</EM> Het maakt geen onderscheid tussen
verschillende gebruikers op de remote host. Ook host-Namen (eigenlijk adressen)
kunnen gespoofd worden. Dit is vervelend als je op een onbetrouwbaar netwerk zit
(internet bijvoorbeeld).
<H2>6.2  Xauth</H2>

<P>Xauth staat connectie toe aan iedereen die het juiste geheim weet. Zo'n geheim wordt 
authorization record genoemd, of magic cookie. Dit legalisatie schema is 
formeel genoemd MIT-MAGIC-COOKIE-1.
<P>De cookies voor verschillende displays staan samen is 
<CODE>~/.Xauthority</CODE>. Jouw <CODE>~/.Xaurthority</CODE> moet niet toegangkelijk 
zijn voor andere groepen en gebruikers. Het xauth programmatje houd deze 
cookies bij, vandaar de bijnaam xauth voor het schema.
<P>Bij het starten van een sessie, leest de server de cookie uit het bestand
die aangegeven wordt door de optie <CODE>-auth</CODE>. Nadat, de server alleen
connecties vanaf clients toelaat met de zelfde cookie. Als de
cookie in <CODE>~/.Xauthority</CODE> veranderd, <EM>de server zal de
verandering dan niet doorvoeren</EM>.
<P>Nieuwere servers genereren cookies gelijk als clients er om vragen.
Cookies blijven nog steeds behouden binnenin de server; ze komen niet
terecht in <CODE>~/.Xauthority</CODE> behalve als een client ze daar
zet. Volgens David Wiggins:
<P>
<BLOCKQUOTE>
Een volgende plooi is toegevoegd aan X11R6.3 daar zou je in ge&iuml;nteresseerd kunnen zijn.
Via het nieuwe SECURITY extensie, kan de X server zelf nieuwe cookies genereren
en terugplaatsen ad-hoc.  Verder, de cookies kunnen on vertrouwd worden aan gesteld
daarom worden applicaties met zulke cookies beperkt in hun handeling. 
Bijvoorbeeld, ze kunnen dan niet de invoer van muis en keyboard lezen,
of de inhoud van windows, van andere vertrouwde gebruikers.
Er is een nieuw sub commando gemaakt voor xauth om dit mogelijk
te maken voor gebruik.
</BLOCKQUOTE>
<P>Xauth heeft is duidelijk veiliger dan xhost. Je kan beperkte toegang voor 
bepaalde gebruikers en hosts instellen. Het struikelt niet over gespoofde
adressen zoals xhost. En als je wilt kun je xhost er ook nog bij gebruiken.
<H3> De Cookie maken</H3>

<P>Als je xauth wilt gebruiken, moet je de X server starten met de optie
<CODE>-auth authfile</CODE>. Als je het startx script gebruikt, dan is dat goede
plaats om het te doen. Maak een authorization record net als hieronder in 
je startx script.
<P>Stukje uit <CODE>/usr/X11R6/bin/startx</CODE>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
mcookie|sed -e 's/^/add :0 . /'|xauth -q
xinit -- -auth "$HOME/.Xauthority"
</PRE>
</CODE></BLOCKQUOTE>
<P>Mcookie is een heel klein programmatje in het util-linux pakkage,
hoofd site 
<A HREF="ftp://ftp.math.uio.no/pub/linux/">ftp://ftp.math.uio.no/pub/linux/</A>.  Als alternatief kun je ook
md5sum gebruiken om verschillende data (van, bijvoorbeeld <CODE>/dev/urandom</CODE>
of <CODE>ps -axl</CODE>) in cookie om te zetten:
<P>
<BLOCKQUOTE><CODE>
<PRE>
dd if=/dev/urandom count=1|md5sum|sed -e 's/^/add :0 . /'|xauth -q
xinit -- -auth "$HOME/.Xauthority"
</PRE>
</CODE></BLOCKQUOTE>
<P>Als je het startx script niet kunt aanpassen (omdat je geen root bent)
ga dan naar je systeem administrator en vraag hem om dit te doen, of
laat hem xdm starten. Als hij het niet kan of wil, dan maak je een <CODE>~/.xserverrc</CODE>
script. Als je het script hebt, zal xinit het runnen ipv de echte
X server. Dan kun je de echte X server starten vanuit het script met
de goed opties natuurlijk. Om dat te doen, laat je <CODE>~/.xserverrc</CODE>
de magic cookie regel gebruiken en dan de echte X server starten:
<P>
<BLOCKQUOTE><CODE>
<PRE>
#!/bin/sh
mcookie|sed -e 's/^/add :0 . /'|xauth -q
exec /usr/X11R6/bin/X "$@" -auth "$HOME/.Xauthority"
</PRE>
</CODE></BLOCKQUOTE>
<P>Als je xdm gebruikt om je X sessie bij te houden, kun
je xauth gemakkelijk gebruiken. Zet het regeltje 'DisplayManager.authDir
in <CODE>/etc/X11/xdm/xdm-config</CODE>. Xdm zal nu de optie <CODE>-auth</CODE>
gebruiken als de server start. Als je inlogd bent met xdm, dan zet xdm de
cookie in <CODE>~/.Xauthority</CODE> voor je. Zie xdm(1) voor meer
informatie. Bijvoorbeeld, mijn <CODE>/etc/X11/xdm/xdm-config</CODE> heeft de
volgend regel:
<P>
<BLOCKQUOTE><CODE>
<PRE>
Display Manager.authDir: /var/lib/xdm
</PRE>
</CODE></BLOCKQUOTE>
<H3> De cookie transporteren</H3>

<P>Als je de X server gestart hebt op de server host <CODE>light.uni.verse</CODE>
en je hebt je cookie in <CODE>~/.Xauthority</CODE>, dan moet je de
cookie transporteren naar de client <CODE>dark.matt.er</CODE>.
<P>Het makkelijkst is als je home dir op light en dark zijn gedeeld.
De <CODE>~/.Xauthority</CODE> files zijn het zelfde, dus de cookie
wordt gelijk getransporteerd. Maar, er zit een addertje onder het gras:
als je een cookie voor <CODE>:0</CODE> in de file zet dan denkt dark dat het 
voor zichzelf is ipv voor light. Dus je moet de volledige host-naam gebruiken
als je de cookie maakt; Je kunt het niet weg laten. Je kunt dezelfde cookie 
installeren voor <CODE>:0</CODE> en <CODE>light:0</CODE> met: 
<P>
<BLOCKQUOTE><CODE>
<PRE>
#!/bin/sh
cookie=`mcookie`
xauth add :0 . $cookie
xauth add "$HOST:0" . $cookie
exec /usr/X11R6/bin/X "$@" -auth "$HOME/.Xauthority"
</PRE>
</CODE></BLOCKQUOTE>
<P>Als de homedirectory's niet zijn gedeeld, kun je de cookie transporteren
door middel van rsh, de remote shell:
<P>
<BLOCKQUOTE><CODE>
<PRE>
light$ xauth list "${HOST}:0" | rsh dark.matt.er xauth nmerge -
</PRE>
</CODE></BLOCKQUOTE>
<P>
<OL>
<LI> Haal de cookie uit je locale <CODE>~/.Xauthority</CODE>
(<CODE>xauth nlist :0</CODE>).</LI>
<LI> Verplaats het naar dark.matt.er (<CODE>| rsh dark.matt.er</CODE>).</LI>
<LI> Zet het in <CODE>~/.Xauthority</CODE> daar (<CODE>xauth nmerge -</CODE>).</LI>
</OL>
<P>Notitie voor het gebruik van <CODE>${HOST}</CODE>. Je moet de cookie transporteren
die samenhangt met local host. Een remote X applicatie zal het display value 
<CODE>:0</CODE> gebruiken op de remote machine, dat is niet wat je wilde!
<P>Het is mogelijk dat rsh niet voor je werkt. Naast dat, heeft rsh ook een
security probleem (gespoofde host namen). Als je niet wil of kan gebruik maken
van rsh, kun je het ook handmatig transporteren, zoals dit:
<P>
<BLOCKQUOTE><CODE>
<PRE>
light$ echo $DISPLAY
:0
light$ xauth list $DISPLAY
light/unix:0 MIT-MAGIC-COOKIE-1 076aaecfd370fd2af6bb9f5550b26926
light$ rlogin dark.matt.er
Pass-word:
dark% setenv DISPLAY light.uni.verse:0
dark% xauth add $DISPLAY . 076aaecfd370fd2af6bb9f5550b26926
dark% xfig &amp;
[15332]
dark% log out
light$
</PRE>
</CODE></BLOCKQUOTE>
<P>Zie ook rsh(1) en xauth(1) voor meer informatie
<P>Het is mogelijk om de cookie te transporteren met het <CODE>TERM</CODE> variabel of
<CODE>DISPLAY</CODE> variabel als je tel-net doet naar een remote host. Dit werk het
zelfde als het transporteren van het <CODE>DISPLAY</CODE> variabel met het <CODE>TERM</CODE>
variabel. Zie Sectie 5: De client vertellen. 
<H3> De Cookie gebruiken</H3>

<P>Een X applicatie op dark.matt.er, zoals xfig, zal automatisch kijken in
<CODE>~/.Xauthority</CODE> om zichzelf te legaliseren.
<P>Er is een klein probleem als je gebruikt <CODE>localhost:D</CODE>. X client
applicaties kunnen dit vertalen in <CODE>host/unix:D</CODE> voor het 
doel om de cookie te ontvangen. Dat betekend dat de cookie voor  <CODE>localhost:D</CODE>
in je <CODE>~/.Xauthority</CODE>   <EM>geen</EM> zin meer heeft.
<H2>6.3  Ssh</H2>

<P>Authorizatie records worden gezonden zonder encryptie. Als bang bent
dat iemand je connectie afluistert, gebruik dan ssh, de secure shell.
Het gebruikt X forwarding over ge&euml;ncrypte connecties. En daarnaast
is het geweldig op andere manieren. Het is een goede structurele toevoeging
aan je systeem. Ga naar 
<A HREF="http://www.cs.hut.fi/ssh/">http://www.cs.hut.fi/ssh/</A> , de ssh home page.
<P>Wie weet er andere manieren voor legaliserings schema's of encrypted
X connecties? Misschien kerberos?
<H2><A NAME="s7">7.  X Applicatie van een andere User-id</A></H2>

<P>Stel dat je een grafische applicatie wilt draaien met root
authenthificatie. Alhoewel je X sessie onder je eigen account draait.
Op het eerste gezicht lijkt dit vreemd, maar de X server kan de tool
toegang <EM>niet</EM> toestaan op jou display. Hoe is dit mogelijk, als de root
normaal alles mag doen? en hoe ga je dit probleem oplossen ?
<P>
<P>Laat ons focussen op de situatie, je wilt een X applicatie onder
een User-id <CODE>clientuser</CODE>, maar de X sessie is gestart door
<CODE>serveruser</CODE>. Als je de sectie over cookies hebt gelezen, dan is het
duidelijk waarom <CODE>clientuser</CODE> geen toegang krijgt tot jou display:
<CODE>~clientuser/.Xauthority</CODE> heeft niet de goede magic cookie
voor toegang tot de display. De goede cookie kun je vinden in
<CODE>~serveruser/.Xauthority</CODE>.
<H2>7.1  Verschillende gebruikers op dezelfde Host</H2>

<P>Alles dat werkt voor remote X werkt natuurlijk ook voor X van
een ander User-id  (vooral <CODE>slogin localhost -l clientuser</CODE>). het is waar dat de client host en de server toevallig
hetzelfde zijn. Alhoewel, als de hosts hetzelfde zijn, dan is er een
kortere weg om de magic cookie te transporteren.
<P>We nemen aan dat jij gebruikt maakt van <CODE>su</CODE> om van User-id te wisselen.
Wat je normaal kunt doen is een script schrijven om <CODE>su</CODE> aan te roepen,
maar zet in het script dat <CODE>su</CODE> execute enkel de dingen die nodig zijn
voor remote X. Dit zijn de <CODE>DISPLAY</CODE> variabele en de transfer van de magic cookie.
<P>Het vaststellen van het <CODE>DISPLAY</CODE> variabel het is best simpel; het betekend
alleen het vaststellen van <CODE>DISPLAY="$DISPLAY"</CODE> voordat je het su commando
optie start. Dus je kunt het zo doen:
<P>
<BLOCKQUOTE><CODE>
<PRE>
su - clientuser -c "env DISPLAY=$DISPLAY client-program &amp;"
</PRE>
</CODE></BLOCKQUOTE>
<P>Dit werkt nog niet, omdat we nog steeds de cookie moeten transporteren.
We kunnen de cookie ophalen door middel van <CODE>xauth list "$DISPLAY"</CODE>.
Die commando gebeurd om de cookie in een format goed formaat te krijgen
voor het terug sturen naar <CODE>xauth</CODE>; dat is wat we willen! Dus we sturen
de goede cookie terug naar <CODE>xauth</CODE> in het <CODE>su</CODE> commando, het variabel 
<CODE>DISPLAY daar</CODE>, en het commando starten wat we willen.
<P>
<BLOCKQUOTE><CODE>
<PRE>
su - clientuser -c "xauth add `xauth list $DISPLAY`; \
                    exec env DISPLAY=$DISPLAY client-program"
</PRE>
</CODE></BLOCKQUOTE>
<P>We kunnen een scripts rond dit alles schrijven met de volgende variabelen
<CODE>clientuser</CODE> en <CODE>client-program</CODE>. Laten we het script een beetje 
verbeteren en het minder leesbaar maken. Het ziet eruit als dit:
<P>
<BLOCKQUOTE><CODE>
<PRE>
#!/bin/sh
if [ $# -lt 2 ]
then echo "usage: `basename $0` clientuser command" >&amp;2
     exit 2
fi
CLIENTUSER="$1"; shift
exec su - "$CLIENTUSER" -c "xauth add `xauth list \"$DISPLAY\"`; \
                            exec env DISPLAY='$DISPLAY' "'"$SHELL"'" -c '$*'"
</PRE>
</CODE></BLOCKQUOTE>
<P>Ik denk dat het wel werkt in de meeste situaties.
De enige tekort komming die ik met kan met nu kan indenken is dat,
door het gebruik van <CODE>'$*'</CODE>, single quotes in <CODE>command</CODE> zullen
het <CODE>su</CODE> commando met argument (<CODE>'$*'</CODE>) een beetje in de war
brengen. Als je denk dat er iets echt mis is mail me.
<P>Roep het script aan <CODE>/usr/local/bin/xsu</CODE>, en je kunt doen:
<P>
<BLOCKQUOTE><CODE>
<PRE>
xsu clientuser 'command &amp;'
</PRE>
</CODE></BLOCKQUOTE>
<P>Makkelijk?, nee
<H2>7.2  Client gebruiker is Root</H2>

<P>Blijkbaar kan alles dat voor niet root client gebruikers werkt
ook werken voor root. Alhoewel als root kun je het gemakkelijker maken ,
dit omdat de root iedereen zijn <CODE>~/.Xauthority</CODE> file  mag lezen.
Het is niet nodig de cookie te transporteren. Het enigste dat je hebt te doen
is het <CODE>DISPLAY</CODE> zetten, en <CODE>XAUTHORITY</CODE> naar <CODE>~serveruser/.Xauthority</CODE>.
Dus je kan:
<P>
<BLOCKQUOTE><CODE>
<PRE>
su - -c "exec env DISPLAY='$DISPLAY' \
                  XAUTHORITY='${XAUTHORITY-$HOME/.Xauthority}' \
                  command"
</PRE>
</CODE></BLOCKQUOTE>
<P>Als je hier een script van maakt, dan ziet het er ongeveer zo uit:
<P>
<BLOCKQUOTE><CODE>
<PRE>
#!/bin/sh
if [ $# -lt 1 ]
then echo "usage: `basename $0` command" >&amp;2
     exit 2
fi
su - -c "exec env DISPLAY='$DISPLAY' \
                  XAUTHORITY='${XAUTHORITY-$HOME/.Xauthority}' \
                  "'"$SHELL"'" -c '$*'"
</PRE>
</CODE></BLOCKQUOTE>
<P>Noem het script <CODE>/usr/local/bin/xroot</CODE>, en dan kun je:
<P>
<BLOCKQUOTE><CODE>
<PRE>
xroot 'control-panel &amp;'
</PRE>
</CODE></BLOCKQUOTE>
<P>Kan het nog eenvoudiger, nee?
<H2><A NAME="s8">8.  Een  Remote Window Manager draaien</A></H2>

<P>Een window manager (als <CODE>twm</CODE>, <CODE>wmaker</CODE>, of <CODE>fvwm95</CODE>) is een
applicatie als elk ander. De normale procedure zou dus moeten werken.
<P>Vaak, in elk geval een window manager kan op elke tijd op een display draaien.
Als je al een lokale window manager hebt draaien, dan kun je niet nog een
remote starten (het wordt te ingewikkeld en stopt) je moet dan de lokale
quiten of killen.
<P>Veel X sessie scripts eindigen ongelukkig met:
<P>
<BLOCKQUOTE><CODE>
<PRE>
exec window-manager-of-choice
</PRE>
</CODE></BLOCKQUOTE>
<P>En dat betekend dat als de lokale window manager stopt, ook je sessie
stopt. Het X systeem (xdm of xinit) neemt je sessie over en logt jou uit.
<P>Je moet een beetje moeite doen, maar het kan en het
is niet echt moeilijk, speel eens wat met je session script (normaal 
<CODE>~/.xsession</CODE> of <CODE>~/.xinitrc</CODE>) om het voor elkaar te krijgen.
<P>Onthoud dat sommige window managers vaak de optie bieden om nieuwe programma's
te starten en dat zal runnen op de lokale machine. Dat is, lokaal waar
de window manager draait. Als je een remote window manager draait, zal
het ook remote applicaties starten en dat is niet wat je wilt. Natuurlijk
zullen ze wel verschijnen op wat voor jouw lokaal is.
<H2><A NAME="s9">9.  Problemen oplossen</A></H2>

<P>De eerste keer dat je een remote applicatie probeert te draaien, is het
normaal dat het niet werkt. Hier een paar normale fout boodschappen, en
mogelijke oplossingen om je op weg te helpen
<P>
<BLOCKQUOTE><CODE>
<PRE>
xterm Xt error: Can't open display:
</PRE>
</CODE></BLOCKQUOTE>
<P>Er is geen <CODE>DISPLAY</CODE> variabele in de omgeving, en je hebt de
applicatie niet vertelt welke <CODE>-display</CODE> joker. De applicatie heeft
een lege string aangenomen, maar dat is syntactisch niet goed. Om dit op
te lossen moet je de goede <CODE>DISPLAY</CODE> omgevings variabele zetten
(met <CODE>setenv</CODE> of <CODE>export</CODE> afhankelijk van je shell).
<P>
<BLOCKQUOTE><CODE>
<PRE>
_X11TransSocketINETConnect: Can't connect: errno = 101
xterm Xt error: Can't open display: love.dial.xs4all.nl:0
</PRE>
</CODE></BLOCKQUOTE>
<P>Errno 101 is ``Network is unreachable''.  De applicatie kan geen netwerk-
connectie maken naar de server. Kijk of je de goede <CODE>DISPLAY</CODE> heb gezet,
en of de server berijkbaar vanaf jou machine ( dit zou goed moeten wanneer je
al op de server bent in gelogd en kan tel-netten naar de client)
<P>
<BLOCKQUOTE><CODE>
<PRE>
_X11TransSocketINETConnect: Can't connect: errno = 111
xterm Xt error: Can't open display: love.dial.xs4all.nl:0
</PRE>
</CODE></BLOCKQUOTE>
<P>Errno 111 is ``Connection refused''.  De server waar je naar probeert
te connecten is bereikbaar, maar de desbetreffende server bestaat daar niet
Kijk of je de goede host-naam gebruik en het goede display nummer.
<P>
<BLOCKQUOTE><CODE>
<PRE>
Xlib: connection to ":0.0" refused by server
Xlib: Client is not authorized to connect to Server
xterm Xt error: Can't open display: love.dial.xs4all.nl:0.0
</PRE>
</CODE></BLOCKQUOTE>
<P>De client kan connectie maken met de server, maar de server geeft
geen toestemming voor de client (niet geauthoriseerd). Weet je zeker dat je
magic cookie goed hebt getransporteerd, en dat deze nog geldig
is (de server gebruikt steeds een nieuwe cookie als er een nieuwe sessie wordt gestart).
</BODY>
</HTML>
