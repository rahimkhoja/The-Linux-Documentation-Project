  Automount mini-Howto
  Rahul Sundaram, rahulsundaram@yahoo.co.in
  <mailto:Rahulsundaram AT yahoo DOT co DOT in>
  v1.6, 27 Dicembre 2002

  Questo file descrive l'automounter autofs, come configurarlo, ed evi­
  denzia alcuni problemi da evitare.  Traduzione di Zaxa Zaxu bez­
  zolone@yahoo.it.  Aggiornamento a cura di Tito Rizzo, tito.rizzo@tis­
  cali.it.
  ______________________________________________________________________

  Indice Generale


  1. Introduzione
     1.1 Storia delle Revisioni
     1.2 Automount - come e perché
     1.3 Tipi di automount

  2. Amministrazione
     2.1 Informazioni sul Copyright
     2.2 Liberatoria

  3. Installazione
  4. Configurazione
  5. La lunga attesa per l'unmount
  6. Domande
     6.1 Non riesco a vedere /auto/floppy, o altri mount point che sto cercando.
     6.2 Come faccio a vedere che cosa è in stato di mount?
     6.3 Ho inserito un disco win95 ("vfat") che è stato riconosciuto automaticamente come un semplice disco FAT.
     6.4 Il mio filesystem /auto/cicciopippo è in stato di mount e non riesco a fare l'unmount con kill -SIGUSR1.
     6.5 Cosa succede se scelgo / come directory per l'automounter?
     6.6 Posso avere due "map file" nella stessa directory?
     6.7 Utilizzo SuSE 6.0 e ho dovuto usare ---timeout al posto di --timeout
     6.8 Come devo impostare i permessi per il filesystem FAT(per es.)?
     6.9 Come sfogliare il contenuto di una directory autofs, se le sottodirectory non sono correntemente montate?
     6.10 Chi devo ringraziare per autofs?
     6.11 Dove posso saperne di più, sull'automount?
     6.12 Come contattare gli sviluppatori? Esiste una mailing-list per autofs ?

  7. Ringraziamenti, feedback e dediche.


  ______________________________________________________________________

  11..  IInnttrroodduuzziioonnee

  11..11..  SSttoorriiaa ddeellllee RReevviissiioonnii


  1. Versioni anteriori alla 1.5 - Scritte da Don.

  2. Versione 1.5   - Aggiunta del copyright e altri dettagli minori.
     Raul Sundaram si prende carico del mantenimento.

  3. Versione 1.5.1 - Aggiunta di alcuni dettagli riguardanti VFAT.

  4. Versione 1.5.2 - Storia delle revisioni e altri dettagli minori.

  5. Versione 1.6 - Aggiunta di alcune domande e risposte.

  11..22..  AAuuttoommoouunntt -- ccoommee ee ppeerrcchhéé

  L'automount è il processo con cui il montaggio e lo smontaggio di
  certi filesystem è effettuato automaticamente da un demone. Se un
  utente tenta di accedere a un filesystem smontato, quest'ultimo sarà
  montato automaticamente.  Ciò è utile in particolar modo in ambienti
  di rete molto estesi, oppure quando si ha la necessità di avere
  numerosi mount incrociati anche tra poche macchine (specialmente se
  alcune non sono sempre attive). Inoltre, può essere molto utile per i
  dispositivi removibili, o per qualche altro uso, tipo un agevole
  passaggio tra un mount in modalità conversione ascii attivata e uno in
  modalità conversione ascii disattivata dello stesso filesystem dos.
  Se siete dei novellini di Linux e non comprendete cosa siano il mount
  e i demoni, fate allora riferimento a qualche documento che ne tratti.


  11..33..  TTiippii ddii aauuttoommoouunntt

  Ci sono due diversi tipi di automounter in linux; _A_M_D e _a_u_t_o_f_s. AMD è
  il demone automount che funziona in maniera analoga al demone AMD del
  SunOS. È implementato nello spazio utente e non fa parte del kernel.
  Non è necessario per il kernel avere la funzionalità di automount
  integrata se viene eseguito il mount NFS utilizzando il demone AMD, in
  quanto il traffico diretto ai filesystem automontati vengono passati
  attraverso il sistema NFS.  Autofs è un sitema più recente ed è
  assistito dal kernel. Questo significa che il codice del kernel che
  gestisce i filesystem conosce quali sono i punti di mount dei
  filesystem automontati. Il programma che esegue l'automount si rivolge
  al kernel per conoscerli. In questo mini-howto verrà descritta solo
  l'utility autofs.


  22..  AAmmmmiinniissttrraazziioonnee

  22..11..  IInnffoorrmmaazziioonnii ssuull CCooppyyrriigghhtt

  This mini-HOWTO is Copyright Rahul Sundaram Sundaram.All rights
  reserved.This document is licensed under the Linux Documentation
  Project license <http://tldp.org/copyright.html>.I welcome any kind of
  commercial distrubution but I would like to receive information
  regarding this.I would also help anyone willing to translate this
  document.If you require any exceptions to the licensing terms please
  contact me Rahul Sundaram <mailto:rahulsundaram@yahoo.co.in>. The
  latest version  of this document is always available at the Linux
  Documentation website at  <http://tldp.org/HOWTO/mini/Automount.html>.


  Questo mini-HOWTO è Copyright di  Rahul Sundaram. Tutti i diritti
  riservati. L'uso è consentito entro i termini della Linux
  Documentation Project license <http://tldp.org/copyright.html>. Ogni
  forma di distribuzione commerciale sarà ben accetta, ma l'autore
  gradirebbe esserne informato. L'autore si dichiara disponibile ad
  aiutare chiunque nella traduzione di questo documento. Per richiedere
  qualsivoglia eccezione ai termini della licenza si può contattare
  l'autore Rahul Sundaram <mailto:rahulsundaram.yahoo.co.in>. La
  versione più recente di questo documento si può trovare sul sito web
  del Linux Documentation Project:
  <http://tldp.org/HOWTO/mini/Automount.html>.


  22..22..  LLiibbeerraattoorriiaa

  Per quanto l'autore abbia fatto del suo meglio nel curare la forma di
  questo howto, non si ritiene responsabile per i danni derivanti dalla
  messa in pratica delle informazioni contenute in questo documento. È
  impossibile verificare che le cose funzionino con ogni configurazione,
  per cui è probabile che alcuni dei suggerimenti dati in questo
  documento possano essere non corretti o possano non funzionare su un
  determinato sistema. Nel caso si riscontri qualche malfunzionamento,
  si avvisi l'autore, che  provvederà appena possibile ad apportare le
  correzioni necessarie.
  Questo documento è fornito ``così com'è''. L'autore ha posto il
  massimo impegno nella sua stesura, ma l'uso delle informazioni che vi
  sono contenute è a proprio rischio e pericolo. In nessun caso l'autore
  potrà essere ritenuto responsabile per danni derivanti dall'uso del
  suo lavoro.


  33..  IInnssttaallllaazziioonnee

  Autofs si basa su funzionalità del kernel, perciò il kernel deve
  essere compilato abilitandone il supporto. Tutte le versioni del
  kernel a partire dalla 2.2.xx supportano autofs.

  Per il corretto funzionamento sono necessari anche il programma
  automount e i file di configurazione; usando gli rpm.  La
  distribuzione RedHat rende questo pacchetto disponibile come parte
  dell'installazione.


  44..  CCoonnffiigguurraazziioonnee

  L'installazione del package RPM dovrebbe essere abbastanza agevole, ma
  ci sono alcuni particolari che è meglio controllare, soprattutto se
  non lo si è mai fatto prima.


  Ci sono due file in /etc, che si chiamano auto.master e auto.misc.  Un
  auto.master di esempio appare così:

  /auto   /etc/auto.misc  --timeout 60



  Il primo parametro non è il mount point, ma il percorso base del set
  di mount point (indicati dal secondo parametro). Il terzo parametro
  indica che i filesystem montati possono cominciare a tentare l'unmount
  60 secondi dopo l'utilizzo. Si dovrà interoompere l'utilizzo del disco
  prima di smontarlo.

  Auto.misc è un "map file". Il "map file" può avere qualsiasi nome;
  questo si chiama auto.misc perché originariamente controllava /misc.
  All'interno di auto.master possono essere definiti più "map file".  Il
  mio auto.misc appare così:

  kernel          -ro,soft,intr           ftp.kernel.org:/pub/linux
  cd              -fstype=iso9660,ro      :/dev/cdrom
  zip             -fstype=auto            :/dev/hdd4
  floppy          -fstype=vfat            :/dev/fd0



  La prima colonna ("chiave") indica il mount point. In questo caso
  potrebbe essere /auto/floppy o qualunque altro.  La colonna centrale
  indica le opzioni; leggete la pagina man di mount per dettagli al
  riguardo.  L'ultima colonna specifica la provenienza del filesystem.
  La voce "kernel" è un ipotetico mount NFS. Il simbolo : sulle altre
  righe indica un dispositivo locale.


  55..  LLaa lluunnggaa aatttteessaa ppeerr ll''uunnmmoouunntt

  Alcuni di voi avranno dato un'occhiata ai 60 secondi di timeout,
  pensando: _c_'_è _t_r_o_p_p_o _d_a _a_s_p_e_t_t_a_r_e _p_e_r _p_o_t_e_r _e_s_p_e_l_l_e_r_e _u_n _d_i_s_c_h_e_t_t_o_.
  _M_a_g_a_r_i _b_a_s_t_e_r_e_b_b_e _f_a_r_e _i_l _s_y_n_c _d_e_l _d_i_s_c_o _e_d _e_s_t_r_a_r_l_o _m_o_n_t_a_t_o_, _s_e_n_z_a
  _c_h_e _n_e_s_s_u_n_o _s_e _n_e _a_c_c_o_r_g_a_.  Vorrei suggerire una strategia più sicura.
  Innanzitutto è possibile modificare il timeout. Ma istruire il sistema
  perché esegua l'unmount dopo solo 15 secondi, o qualsiasi altra
  impostazione, potrebbe risultare poco efficace. In base alla vostra
  configurazione, potreste essere in grado di lanciare semplicemente il
  comando umount come normale utente. Ma, in realtà, esiste un modo per
  ordinare al programma automount di eseguire l'unmount. Se inviate
  (tramite il programma kill) il segnale SIGUSR1 al processo automount,
  questo smonterà tutto ciò che potrà. Ma prima che si inizino a creare
  pulsanti per l'unmount sul desktop , c'è un piccolo problema.

  Il processo automount è lanciato dall'utente root e accetta segnali
  solamente da root. Una delle ragioni per cui probabilmente si utilizza
  l'automunt è al contrario la possibilità di eseguire il mount e
  l'unmount senza essere root. Sarebbe semplice creare un programma C
  che esegua il "lavoro brutale" come suid-root.  Comunque è possibile
  utilizzare sudo per permettere agli utenti di mandare l'opportuno
  segnale di kill. L'unico problema è che sudo non permette di
  utilizzare i sottocomandi di processo, che sarebbe necessario usare
  per individuare il PID corrente. Si dovrebbe invece disporre del
  programma killall, che permette di eseguire quanto segue:

  ALL     ALL=NOPASSWD:/usr/bin/killall -USR1 automount


  In alternativa si dovrebbe permettere agli utenti di mandare il seg­
  nale -SIGUSR1 a tutti i processi. Questo però potrebbe avere effetti
  collaterali su altri programmi: costringere il riciclo di alcuni win­
  dow manager e forzare la chiusura di xemacs. È perciò sperabile che
  non ci siano buffer overrun in killall...


  66..  DDoommaannddee



  66..11..  NNoonn rriieessccoo aa vveeddeerree //aauuttoo//ffllooppppyy,, oo aallttrrii mmoouunntt ppooiinntt cchhee ssttoo
  cceerrccaannddoo..

  Se automount è configurato correttamente, qualunque mount point che si
  stia ricercando sarà disponibile al momento dell'utilizzo, anche se
  non lo si vede nel momento in cui non viene utilizzato. Se si sta
  eseguendo il browse delle directory con un programma grafico potrebbe
  essere necessario digitare manualmente il percorso; la maggior parte
  dei programmi proverà ciò che gli trasmettete, e il dispositivo verrà
  montato prima che sia rilevato. Sfortunatamente, l'impossibilità di
  scegliere tra i punti di mount disponibili, ma invisibili, è
  probabilmente uno dei maggiori inconvenienti di autofs. Se ciò risulta
  inaccettabile, modificate la configurazione del sistema (per inciso i
  file che terminano in .c come "configurazione").

  Una soluzione che svariate persone hanno provato, è quella di creare
  link simbolici a ciò che automount crea una volta che sia montato. Ciò
  impedirà probabilmente, che il programma lamenti l'inesistenza di una
  directory (se il mount funziona, ovvio) ma un'elencazione disattenta
  di directory provocherebbe il montaggio dei filesystem.


  66..22..  CCoommee ffaacccciioo aa vveeddeerree cchhee ccoossaa èè iinn ssttaattoo ddii mmoouunntt??

  Con il comando df. Lo stesso si ottiene con un semplice  mount,
  ottenendo in più anche le opzioni utilizzate per eseguire il mount.


  66..33..  HHoo iinnsseerriittoo uunn ddiissccoo wwiinn9955 ((""vvffaatt"")) cchhee èè ssttaattoo rriiccoonnoosscciiuuttoo
  aauuttoommaattiiccaammeennttee ccoommee uunn sseemmpplliiccee ddiissccoo FFAATT..


  Questo non è un problema di automount.  Il tipo di filesystem "auto"
  non prova a montare un filesystem come vfat se prima non è riuscito a
  montarlo come filesystem MS-DOS. VFAT è una estensione del filesystem
  FAT/MS-DOS, che permette l'utilizzo dei nomi di file lunghi.

  Stando alle osservazioni di uno degli autori di mount, il programma
  mount è soltanto una interfaccia ad una chiamata di sistema, ed è
  comunque responsabilità dell'utente specificare il tipo di filesystem.
  Si sta valutando di far sì che mount segua una lista di filesystem da
  provare in un ordine ben preciso al posto dell'attuale metodo
  "euristico". Alcuni utenti non hanno semplicemente compilato il
  supporto per msdos nel kernel; questo impedisce che venga testato
  prima di vfat. Per la maggioranza potrebbe andare bene anche così,
  visto che solo pochi hanno realmente bisogno di msdos e esiste in
  effetti una soluzione: bisogna copiare /proc/filesystems come
  /etc/filesystems e editarlo per cambiare l'ordine in modo che vfat
  appaia prima di msdos.(Grazie Mark)

  Ariel (aslinux@dsgml.com) scrive

  " per far sì che mount provi vfat prima di fat, si crei o si editi il
  file /etc/filesystems

  Si elenchi, in ordine di priorità, quale filesystem si voglia provare
  come 'auto'.

  Si crei il file con cp /proc/filesystems /etc/filesystems.

  Si editi la lista per cambiarne l'ordine. Si mettano per primi i tipi
  di filesystem che siano identificabili con grande sicurezza, come ext2
  (che saranno quindi controllati molto rapidamente), e quindi quelli di
  uso più comune. Si metta vfat prima di msdos ed ecco fatto. Ci si
  assicuri di inserirli entrambi, nel caso si monti qualcosa che non sia
  vfat.

  Il mio appare così:

  ext2 vfat msdos iso9660

  ****

  Io uso un timeout di 1 secondo per i dispositivi removibili. Create
  file map separati, in base ai timeout che vi servono.

  State pensando che 1 secondo sia un grande spreco di risorse? - ma non
  non è così.  Ricordate che il sistema smonta i dispositivi solo quando
  non sono più in uso.

  1 secondo significa che il dispositivo sarà smontato appena non sarà
  più in uso..

  Quindi, assicuratevi di mettere 'sync' come opzione per il floppy!

  cioè:

  floppy      -fstype=auto,sync,user,umask=002,gid=floppy     :/dev/fd0"

  Questo dovrebbe rendere chiara la risposta.


  66..44..  IIll mmiioo ffiilleessyysstteemm //aauuttoo//cciicccciiooppiippppoo  èè iinn ssttaattoo ddii mmoouunntt ee nnoonn
  rriieessccoo aa ffaarree ll''uunnmmoouunntt ccoonn kkiillll --SSIIGGUUSSRR11 ..

  È sicuramente in uso da parte di qualcuno o qualcosa. Probabilmente
  neppure root è in grado di smontarlo manualmente. Se siete voi che ne
  avete causato il montaggio (non può essere cioè che qualcun altro lo
  stia usando) controllate che qualche sheell non sia posizionata sulla
  directory, oppure che qualche applicazione (in particolare qualcosa
  che possa essere entrato in quella directory, come un browser di
  directory) non abbia messo per così dire un piede in mezzo alla porta.
  Se non si riesce ad individuare chi o cosa stia effettuando il blocco,
  provare a utilizzare il programma fuser.


  66..55..  CCoossaa ssuucccceeddee ssee sscceellggoo // ccoommee ddiirreeccttoorryy ppeerr ll''aauuttoommoouunntteerr??

  Non te lo consiglio. Se vuoi proprio usare /cicciopippo ti suggerisco
  piuttosto un link simbolico. Sarebbe più sicuro.


  66..66..  PPoossssoo aavveerree dduuee ""mmaapp ffiillee"" nneellllaa sstteessssaa ddiirreeccttoorryy??

  Per quanto ne sappia io, no. Prova a usare un "map file", con opzioni
  specifiche per le singole voci.


  66..77..  UUttiilliizzzzoo SSuuSSEE 66..00 ee hhoo ddoovvuuttoo uussaarree ------ttiimmeeoouutt  aall ppoossttoo ddii
  ----ttiimmeeoouutt

  Un'altra soluzione a problemi di "timeout non funzionante" potrebbe
  essere aggiungere un'opzione -t time allo script autofs.


  66..88..  CCoommee ddeevvoo iimmppoossttaarree ii ppeerrmmeessssii ppeerr iill ffiilleessyysstteemm FFAATT((ppeerr eess..))??

  Controlla la pagina man di mount per alcune possibili opzioni, come le
  impostazioni di uid=valore o umask=valore. Un'opzione che sembra
  essere scomparsa per il filesystem FAT è mode=valore. Spiacente.
  Verifica presso le persone che si occupano di mount.


  66..99..  CCoommee ssffoogglliiaarree iill ccoonntteennuuttoo ddii uunnaa ddiirreeccttoorryy aauuttooffss,, ssee llee ssoott­­
  ttooddiirreeccttoorryy nnoonn ssoonnoo ccoorrrreenntteemmeennttee mmoonnttaattee??

  Philippe Froidevaux  scrive



  " L'autore di autofs afferma che "non c'è modo"

  un possibile hack è (ripreso dal newsgroup):

  "non montate sotto /home/blauser  ma sotto  /mount/.auto/blauser
  quindi aggiungete un link  /home/blauser -> /mount/.auto/blauser

  ora potete entrare in /home e vedere la home degli utenti, che verrà
  montata non appena ci si entra;

  problema: non è una soluzione così pulita e comporta un po' di lavoro
  per ogni utente;

  un'altra soluzione sarebbe usare 'amd' al posto di 'autofs', ma amd è
  meno performante.



  66..1100..  CChhii ddeevvoo rriinnggrraazziiaarree ppeerr aauuttooffss??

  Questa è solo documentazione che vi viene offerta per attirare
  l'attenzione di tutti sul grande lavoro che è stato fatto con autofs,
  e quanto sia facile da usare. Confrontato con il precursore AMD,
  autofs è molto ben documentato e i suoi sviluppatori hanno tutti i
  miei ringraziamenti. Il copyright indicato è Transmeta, per cui non ho
  a disposizione una lista di nomi, per quanto Peter Anvin ne sia
  probabilmente il maggiore responsabile. Peter tenne anche una sessione
  su autofs al linuxworldexpo il 3 marzo 1999.


  66..1111..  DDoovvee ppoossssoo ssaappeerrnnee ddii ppiiùù,, ssuullll''aauuttoommoouunntt??

  È possibile trovare un tutorial su autofs qui
  <http://www.linuxhq.com/lg/issue24/nielsen.html>.  Provare inoltre le
  am-utils qui  <http://www.cs.columbia.edu/~ezk/am-utils>.



  66..1122..  CCoommee ccoonnttaattttaarree ggllii ssvviilluuppppaattoorrii?? EEssiissttee uunnaa mmaaiilliinngg--lliisstt ppeerr
  aauuttooffss ??

  Non sono stato in grado di reperire informazioni al riguardo. Fatemi
  sapere se per caso trovate qualcosa.


  77..  RRiinnggrraazziiaammeennttii,, ffeeeeddbbaacckk ee ddeeddiicchhee..

  Desidero ringraziare Don <mailto:don@sabotage.org> (l'indirizzo email
  non sembra più valido), autore della prima stesura di questo mini-
  Howto.Ringrazio Ariel per la sua risposta in merito alla questione
  "win95 vfat".Ringrazio i miei amici per il loro appoggio e chiunque si
  sia dimostrato abbastanza paziente mentre completavo questo lavoro.
  Vi prego di scrivermi qui Rahul Sundaram <mailto:Rahulsundaram AT
  yahoo DOT co DOT in> per ogni suggerimento, miglioramento o nel caso
  abbiate qualche idea brillante.  Scrivetemi se disponete di qualche
  buon tutorial o di materiale che io possa inserire in questo
  documento. Grazie fin d'ora.  Dedico questo lavoro ai miei defunti
  genitori Mr.V.Sundaram e Mrs.S.Soundara Sundaram.



