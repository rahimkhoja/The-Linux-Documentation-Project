<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Guide pratique du Plug-and-Play</title><link href="style.css" rel="stylesheet" type="text/css" /><meta content="DocBook XSL Stylesheets V1.73.2" name="generator" /><meta name="description" content="Le Plug-and-Play (ou PnP) est un système de détection et de configuration automatique du matériel PC. Ce guide pratique présente en détail les différentes ressources bas niveau gérées par le Plug-and-Play, telles que les adresses, les interruptions, et cætera. Ce guide couvre le bus PCI (qui a été conçu dès le départ pour le Plug-and-Play) et l'utilisation du Plug-and-Play sur l'ancien bus ISA. Si le Plug-and-Play faisait son travail correctement, vous n'auriez pas besoin de ce guide pratique. Dans le cas contraire ou si vous disposez d'un vieux matériel qui n'utilise pas le Plug-and-Play pour toutes les cartes, ce guide pratique vous aidera. Il ne couvre pas le UPnP (Universal Plug and Play)." /></head><body><div class="article" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="N10001" />Guide pratique du Plug-and-Play</h2></div><div><h3 class="subtitle"><i>
    Adaptation française du <span class="foreignphrase"><em class="foreignphrase">Plug-and-Play
    HOWTO</em></span>
  </i></h3></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">David</span> <span class="othername">S.</span> <span class="surname">Lawyer</span></h3><div class="affiliation"><div class="address"><p><span style="white-space: pre;">
          <code class="email">&lt;<a class="email" href="mailto:dave CHEZ lafn POINT org">dave CHEZ lafn POINT org</a>&gt;</code>
        </span></p></div></div></div></div></div><div><div class="othercredit"><h3 class="othercredit"><span class="firstname">Guillaume</span> <span class="surname">Lelarge</span></h3><span class="contrib">Traduction française</span> <code class="email">&lt;<a class="email" href="mailto:gleu CHEZ wanadoo POINT fr">gleu CHEZ wanadoo POINT fr</a>&gt;</code></div></div><div><div class="othercredit"><h3 class="othercredit"><span class="firstname">Jean-Philippe</span> <span class="surname">Guérard</span></h3><span class="contrib">Préparation de la publication de la v.f.</span> <code class="email">&lt;<a class="email" href="mailto:fevrier CHEZ tigreraye POINT org">fevrier CHEZ tigreraye POINT org</a>&gt;</code></div></div><div><p class="releaseinfo">Version : 1.15.fr.0.9</p></div><div><p class="copyright">Copyright © 1998-2007 David S. Lawyer</p></div><div><p class="copyright">Copyright © 2003-2007 Guillaume Lelarge, Jean-Philippe Guérard</p></div><div><p class="pubdate">2006-09-04</p></div><div><div class="revhistory"><table summary="Revision history" width="100%" border="1"><tr><th colspan="3" valign="top" align="left"><b>Historique des versions</b></th></tr><tr><td align="left">Version 1.15.fr.0.9</td><td align="left">2007-09-04</td><td align="left">GL, JPG</td></tr><tr><td colspan="3" align="left">
      
         Version française mise à jour mais non relue.
      
      </td></tr><tr><td align="left">Version 1.15</td><td align="left">2007-08-??</td><td align="left">DSL</td></tr><tr><td align="left">Version 1.14.fr.0.9</td><td align="left">2006-03-07</td><td align="left">GL, JPG</td></tr><tr><td colspan="3" align="left">
      
         Version française mise à jour mais non relue.
	 Prise en compte des corrections suggérées par Jean-Philippe Guérard
	 et par Bernard Adrian.
      
      </td></tr><tr><td align="left">Version 1.14</td><td align="left">2006-02-??</td><td align="left">DSL</td></tr><tr><td align="left">Version 1.13.fr.0.9</td><td align="left">2005-08-22</td><td align="left">GL, JPG</td></tr><tr><td colspan="3" align="left">
      
         Version française non relue. Prise en compte des 
         corrections suggérées par Black Myst.
      
      </td></tr><tr><td align="left">Version 1.13</td><td align="left">2005-08-??</td><td align="left">DSL</td></tr><tr><td align="left">Version 1.12</td><td align="left">2005-03-??</td><td align="left">DSL</td></tr><tr><td align="left">Version 1.11.fr.0.9</td><td align="left">2004-11-20</td><td align="left">GL, JPG</td></tr><tr><td align="left">Version 1.11</td><td align="left">2004-11-??</td><td align="left">DSL</td></tr><tr><td align="left">Version 1.10.fr.0.9</td><td align="left">2004-09-11</td><td align="left">GL, JPG</td></tr><tr><td align="left">Version 1.10</td><td align="left">2004-08-??</td><td align="left">DSL</td></tr><tr><td align="left">Version 1.09</td><td align="left">2004-08-??</td><td align="left">DSL</td></tr><tr><td align="left">Version 1.08.fr.0.9</td><td align="left">2004-07-22</td><td align="left">GL</td></tr><tr><td align="left">Version 1.08</td><td align="left">2004-06-??</td><td align="left">DSL</td></tr><tr><td align="left">Version 1.07.fr.0.9</td><td align="left">2003-09-27</td><td align="left">GL</td></tr><tr><td align="left">Version 1.07</td><td align="left">2002-08-??</td><td align="left">DSL</td></tr><tr><td align="left">Version 1.06.fr.0.9</td><td align="left">2003-05-08</td><td align="left">GL</td></tr><tr><td align="left">Version 1.06</td><td align="left">2002-09-??</td><td align="left">DSL</td></tr></table></div></div><div><div class="abstract"><p class="title"><b>Résumé</b></p><p>

     Le Plug-and-Play (ou PnP) est un système de détection et de 
     configuration automatique du matériel PC. Ce guide pratique présente 
     en détail les différentes ressources bas niveau gérées par le Plug-and-Play,
     telles que les adresses, les interruptions, et cætera. Ce guide couvre le
     bus PCI (qui a été conçu dès le départ pour le Plug-and-Play) et 
     l'utilisation du Plug-and-Play sur l'ancien bus ISA. Si le 
     Plug-and-Play faisait son travail correctement, vous n'auriez pas 
     besoin de ce guide pratique. Dans le cas contraire ou si vous disposez
     d'un vieux matériel qui n'utilise pas le Plug-and-Play pour toutes les
     cartes, ce guide pratique vous aidera. Il ne couvre pas le UPnP
     (<span class="foreignphrase" lang="en"><em class="foreignphrase">Universal Plug and Play</em></span>).

   </p></div></div></div><hr /></div><div class="toc"><p><b>Table des matières</b></p><dl><dt><span class="sect1"><a href="#N100F4">1. Introduction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#N100F7">1.1. Droits d'utilisation, avertissements et remerciements</a></span></dt><dt><span class="sect2"><a href="#N1015E">1.2. Plans futurs : vous pouvez aider</a></span></dt><dt><span class="sect2"><a href="#N1016E">1.3. Nouvelles versions de ce guide pratique</a></span></dt><dt><span class="sect2"><a href="#N10179">1.4. Nouveautés des dernières versions</a></span></dt><dt><span class="sect2"><a href="#N1019D">1.5. Introduction générale. Avez-vous besoin de ce guide
pratique ?</a></span></dt></dl></dd><dt><span class="sect1"><a href="#N1024A">2. Ce que <acronym class="acronym">PnP</acronym> doit faire : allouer des
« <span class="quote">ressources bus</span> »</a></span></dt><dd><dl><dt><span class="sect2"><a href="#N10252">2.1. En quoi consiste le Plug-and-Play
(<acronym class="acronym">PnP</acronym>) ?</a></span></dt><dt><span class="sect2"><a href="#dev_commun">2.2. Périphériques matériels et la communication avec
ces derniers</a></span></dt><dt><span class="sect2"><a href="#N1030A">2.3. Adresses</a></span></dt><dt><span class="sect2"><a href="#N10326">2.4. Adresses d'entrées/sorties (principes relatifs à d'autres
ressources)</a></span></dt><dt><span class="sect2"><a href="#mem_">2.5. Plages mémoire</a></span></dt><dt><span class="sect2"><a href="#interrupt_over">2.6. <acronym class="acronym">IRQ</acronym> - un aperçu</a></span></dt><dt><span class="sect2"><a href="#dma_">2.7. <acronym class="acronym">DMA</acronym> (accès direct à la
mémoire) ou maîtrise du bus</a></span></dt><dt><span class="sect2"><a href="#dma_isa">2.8. Canaux <acronym class="acronym">DMA</acronym> (non pas pour le bus
<acronym class="acronym">PCI</acronym>)</a></span></dt><dt><span class="sect2"><a href="#N10481">2.9. « <span class="quote">Ressources</span> » du périphérique et du pilote</a></span></dt><dt><span class="sect2"><a href="#N1049F">2.10. Les ressources sont limitées</a></span></dt></dl></dd><dt><span class="sect1"><a href="#N104E1">3. Deuxième introduction au Plug-and-Play (<acronym class="acronym">PnP</acronym>)</a></span></dt><dd><dl><dt><span class="sect2"><a href="#N104E7">3.1. Introduction à <acronym class="acronym">PnP</acronym></a></span></dt><dt><span class="sect2"><a href="#N1054E">3.2. Comment fonctionne le <acronym class="acronym">PnP</acronym> (explication simplifiée)</a></span></dt><dt><span class="sect2"><a href="#N105C5">3.3. Démarrer le PC</a></span></dt><dt><span class="sect2"><a href="#N105F9">3.4. Les bus</a></span></dt><dt><span class="sect2"><a href="#how_linux_pnps">3.5. Comment Linux gère-t-il le
<acronym class="acronym">PnP</acronym></a></span></dt><dt><span class="sect2"><a href="#N106C6">3.6. Problèmes avec Linux <acronym class="acronym">PnP</acronym></a></span></dt></dl></dd><dt><span class="sect1"><a href="#conf_pnp_bios">4. Configurer un <acronym class="acronym">BIOS</acronym>
<acronym class="acronym">PnP</acronym></a></span></dt><dd><dl><dt><span class="sect2"><a href="#bios_pnp_os">4.1. Avez-vous un système d'exploitation
<acronym class="acronym">PnP</acronym> ?</a></span></dt><dt><span class="sect2"><a href="#escd_resources">4.2. Affecter les ressources par le
<acronym class="acronym">BIOS</acronym> ?</a></span></dt><dt><span class="sect2"><a href="#escd_reset">4.3. Réinitialiser la configuration</a></span></dt></dl></dd><dt><span class="sect1"><a href="#N108C7">5. Gérer les cartes <acronym class="acronym">PnP</acronym></a></span></dt><dd><dl><dt><span class="sect2"><a href="#N108CC">5.1. Introduction à la gestion des périphériques
<acronym class="acronym">PnP</acronym></a></span></dt><dt><span class="sect2"><a href="#dev_d_conf">5.2. Configuration du pilote de périphérique,
réservation des ressources</a></span></dt><dt><span class="sect2"><a href="#sys_">5.3. /sys : interface de configuration pour
l'utilisateur</a></span></dt><dt><span class="sect2"><a href="#bios_conf">5.4. Configuration du <acronym class="acronym">BIOS</acronym></a></span></dt><dt><span class="sect2"><a href="#disable_pnp">5.5. <acronym class="acronym">ISA</acronym> seulement :
Désactiver <acronym class="acronym">PnP</acronym> ?</a></span></dt><dt><span class="sect2"><a href="#isapnp_">5.6. Bus <acronym class="acronym">ISA</acronym> : Isapnp (outil
faisant partie d'isapnptools)</a></span></dt><dt><span class="sect2"><a href="#pciutils_">5.7. Les utilitaires <acronym class="acronym">PCI</acronym></a></span></dt><dt><span class="sect2"><a href="#windows_conf">5.8. Configuration de Windows</a></span></dt><dt><span class="sect2"><a href="#sw_and_docs">5.9. Documents/Logiciels
<acronym class="acronym">PnP</acronym></a></span></dt></dl></dd><dt><span class="sect1"><a href="#tell_driver_config">6. Indiquer au pilote la
configuration ??</a></span></dt><dd><dl><dt><span class="sect2"><a href="#N10CB1">6.1. Introduction</a></span></dt><dt><span class="sect2"><a href="#N10CF4">6.2. Exemple de pilote de port série</a></span></dt></dl></dd><dt><span class="sect1"><a href="#current_config">7. Comment puis-je trouver les périphériques et
comment sont-ils configurés ?</a></span></dt><dd><dl><dt><span class="sect2"><a href="#N10D54">7.1. La recherche des périphériques et la découverte de la
configuration sont liés</a></span></dt><dt><span class="sect2"><a href="#N10D59">7.2. Les périphériques pourraient avoir deux « <span class="quote">configurations</span> »</a></span></dt><dt><span class="sect2"><a href="#N10D7C">7.3. Trouver le matériel</a></span></dt><dt><span class="sect2"><a href="#boot_time_msgs">7.4. Messages de démarrage</a></span></dt><dt><span class="sect2"><a href="#proc_dir">7.5. Le répertoire /proc</a></span></dt><dt><span class="sect2"><a href="#sys_dir">7.6. Le répertoire /sys</a></span></dt><dt><span class="sect2"><a href="#pci_">7.7. Inspection du bus <acronym class="acronym">PCI</acronym></a></span></dt><dt><span class="sect2"><a href="#isa_bus">7.8. Introduction au bus <acronym class="acronym">ISA</acronym></a></span></dt><dt><span class="sect2"><a href="#isa_pnp">7.9. Cartes <acronym class="acronym">ISA</acronym>
<acronym class="acronym">PnP</acronym></a></span></dt><dt><span class="sect2"><a href="#lpc_">7.10. Bus <acronym class="acronym">LPC</acronym></a></span></dt><dt><span class="sect2"><a href="#N1105B">7.11. X-bus</a></span></dt><dt><span class="sect2"><a href="#non_pnp">7.12. Cartes non <acronym class="acronym">PnP</acronym></a></span></dt><dt><span class="sect2"><a href="#jumpers_">7.13. Cartes non <acronym class="acronym">PnP</acronym> avec
cavaliers</a></span></dt><dt><span class="sect2"><a href="#neither_">7.14. Cartes non <acronym class="acronym">PnP</acronym> et sans
cavaliers</a></span></dt><dt><span class="sect2"><a href="#hw_detect">7.15. Outils pour détecter ou configurer le matériel</a></span></dt><dt><span class="sect2"><a href="#hw_detect_one_type">7.16. Outils pour détecter et configurer un type de matériel</a></span></dt><dt><span class="sect2"><a href="#check_ms">7.17. Utilisez MS Windows</a></span></dt></dl></dd><dt><span class="sect1"><a href="#pci_int">8. Interruptions PCI</a></span></dt><dd><dl><dt><span class="sect2"><a href="#N11146">8.1. Introduction</a></span></dt><dt><span class="sect2"><a href="#N11153">8.2. Historique : des interruptions ISA aux PCI</a></span></dt><dt><span class="sect2"><a href="#N1115A">8.3. Contrôleur avancé d'interruptions programmées
  (<acronym class="acronym">APIC</acronym>, acronyme de <span class="foreignphrase"><em class="foreignphrase">Advanced Programmable
  Interrupt Controller</em></span>)</a></span></dt><dt><span class="sect2"><a href="#N11179">8.4. Interruptions signalées par message (MSI)</a></span></dt><dt><span class="sect2"><a href="#N11186">8.5. Partage des interruptions PCI</a></span></dt><dt><span class="sect2"><a href="#N11191">8.6. Recherche dans les tables de routage</a></span></dt><dt><span class="sect2"><a href="#N1119F">8.7. Pour plus d'informations</a></span></dt></dl></dd><dt><span class="sect1"><a href="#N111AD">9. Lier les interruptions PCI</a></span></dt><dt><span class="sect1"><a href="#N111D9">10. <acronym class="acronym">PnP</acronym> pour les périphériques externes et
ajoutés</a></span></dt><dd><dl><dt><span class="sect2"><a href="#N111DE">10.1. Bus <acronym class="acronym">USB</acronym></a></span></dt><dt><span class="sect2"><a href="#N1121B">10.2. Hot Plug</a></span></dt><dt><span class="sect2"><a href="#N1122D">10.3. Hot Swap</a></span></dt><dt><span class="sect2"><a href="#N11237">10.4. <acronym class="acronym">PnP</acronym> détecte les périphériques connectés aux
ports séries</a></span></dt></dl></dd><dt><span class="sect1"><a href="#N11253">11. Messages d'erreurs</a></span></dt><dd><dl><dt><span class="sect2"><a href="#N11256">11.1. Unexpected Interrupt (Interruption inattendue)</a></span></dt><dt><span class="sect2"><a href="#N1125E">11.2. Erreur de configuration Plug and Play (<acronym class="acronym">BIOS</acronym>
Dell)</a></span></dt><dt><span class="sect2"><a href="#N11269">11.3. isapnp: Write Data Register 0xa79 already used (à partir des
journaux)</a></span></dt><dt><span class="sect2"><a href="#N1126E">11.4. Impossible d'allouer la région (<acronym class="acronym">PCI</acronym>)</a></span></dt></dl></dd><dt><span class="sect1"><a href="#N11289">12. Partage et conflit d'interruption</a></span></dt><dd><dl><dt><span class="sect2"><a href="#N1128C">12.1. Introduction</a></span></dt><dt><span class="sect2"><a href="#N112A1">12.2. Vrai conflit d'interruption</a></span></dt><dt><span class="sect2"><a href="#N112B0">12.3. Aucune interruption disponible</a></span></dt></dl></dd><dt><span class="sect1"><a href="#N112E9">13. Annexe</a></span></dt><dd><dl><dt><span class="sect2"><a href="#UPnP_">13.1. Universal Plug and Play
(<acronym class="acronym">UPnP</acronym>)</a></span></dt><dt><span class="sect2"><a href="#address_details">13.2. Détails des adresses</a></span></dt><dt><span class="sect2"><a href="#isa_conf_addresses">13.3. Adresses de configuration du bus
<acronym class="acronym">ISA</acronym> (Port de lecture et cætera)</a></span></dt><dt><span class="sect2"><a href="#interrupt_detail">13.4. Détails sur les interruptions</a></span></dt><dt><span class="sect2"><a href="#N1148F">13.5. Comment le pilote de périphérique récupère son
interruption</a></span></dt><dt><span class="sect2"><a href="#isolation_">13.6. Isolation <acronym class="acronym">ISA</acronym></a></span></dt><dt><span class="sect2"><a href="#N11505">13.7. Maîtrise du bus et ressources <acronym class="acronym">DMA</acronym></a></span></dt><dt><span class="sect2"><a href="#N11527">13.8. Historique et obsolescence</a></span></dt></dl></dd><dt><span class="appendix"><a href="#N11570">A. Adaptation française</a></span></dt><dd><dl><dt><span class="section"><a href="#N11573">1. Traduction</a></span></dt><dt><span class="section"><a href="#N1157B">2. Préparation de la publication</a></span></dt></dl></dd></dl></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="N100F4" />1. Introduction</h2></div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N100F7" />1.1. Droits d'utilisation, avertissements et remerciements</h3></div></div></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N100FA" />1.1.1. Copyright</h4></div></div></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td valign="top" align="center" rowspan="2" width="25"><img alt="[Important]" src="images/important.png" /></td><th align="left">Important</th></tr><tr><td valign="top" align="left"><p>
Le texte ci-dessous est la licence de ce document. Ce texte fait foi. Il 
est composé de la licence (en anglais) du document original, suivi de la 
licence (en français) de sa traduction.
</p></td></tr></table></div><p>Copyright © 1998-2005 by David S. Lawyer
<code class="email">&lt;<a class="email" href="mailto:dave CHEZ lafn POINT org">dave CHEZ lafn POINT org</a>&gt;</code>.</p><p>Please freely copy and distribute (sell or give away) this document
in any format.  Send any corrections and comments to the document
maintainer.  You may create a derivative work and distribute it
provided that you:</p><div class="itemizedlist"><ul><li><p>

If it's not a translation: Email a copy of your derivative work (in a 
format LDP accepts) to the author(s) and maintainer (could be the same 
person). If you don't get a response then email the LDP (Linux 
Documentation Project):

<code class="email">&lt;<a class="email" href="mailto:submit CHEZ en POINT tldp POINT org">submit CHEZ en POINT tldp POINT org</a>&gt;</code>.

</p></li><li><p>

License the derivative work in the spirit of this license or use GPL. 
Include a copyright notice and at least a pointer to the license 
used.</p></li><li><p>Give due credit to previous 
authors and major contributors.

</p></li></ul></div><p>If you're considering making a derived work other than a translation, it's
requested that you discuss your plans with the current maintainer.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N10116" />1.1.2. Droits d'utilisation</h4></div></div></div><p>Copyright © 1998-2005 par David S. Lawyer
<code class="email">&lt;<a class="email" href="mailto:dave CHEZ lafn POINT org">dave CHEZ lafn POINT org</a>&gt;</code>.

</p><p>Copyright © 2003-2005 par Guillaume 
Lelarge <code class="email">&lt;<a class="email" href="mailto:gleu CHEZ wanadoo POINT fr">gleu CHEZ wanadoo POINT fr</a>&gt;</code> &amp; ? <code class="email">&lt;<a class="email" href="mailto:?">?</a>&gt;</code>.
</p><p>Vous pouvez copier et distribuer librement (vendre ou donner) ce document
quel que soit son format. Envoyez toute correction ou tout commentaire à
l'auteur du document. Vous pouvez créer et distribuer une version dérivée à
condition que :
<div class="itemizedlist"><ul><li><p>
  
    vous envoyez au gestionnaire et à l'auteur (s'il ne s'agit pas de la 
    même personne) une copie de votre travail par courrier électronique 
    (s'il ne s'agit pas d'une traduction) dans un format que le LDP 
    accepte. Si vous n'obtenez pas de réponse, alors envoyez votre 
    message au LDP (Linux Documentation Project) : 

    <code class="email">&lt;<a class="email" href="mailto:submit CHEZ en POINT tldp POINT org">submit CHEZ en POINT tldp POINT org</a>&gt;</code> ;
    
  </p></li><li><p>
  
  la licence utilisée pour votre travail soit dans le même esprit que 
  cette licence ou utilise la licence GPL. Incluez les informations de 
  droit d'utilisation ou au moins un pointeur vers la licence 
  utilisée ;

  </p></li><li><p>vous donnez crédit aux auteurs précédents et aux contributeurs
    majeurs.</p></li></ul></div>
</p><p>Si vous pensez faire un travail dérivé autre qu'une traduction, vous devez
en discuter avec le gestionnaire actuel.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N10138" />1.1.3. Avertissements</h4></div></div></div><p>Bien que je n'aie pas essayé de vous tromper intentionnellement, il est
probable que des erreurs restent dans ce document. Faites-le moi savoir si vous
en trouvez. Comme il s'agit d'une documentation libre, il est évident que je ne
peux pas être tenu responsable des erreurs contenues dans ce texte.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N1013D" />1.1.4. Marques déposées</h4></div></div></div><p>Tout nom de marque (avec une majuscule initiale tel que MS Windows) sera
supposé être une marque déposée. Elles appartiennent à leur propriétaires 
respectifs.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N10142" />1.1.5. Remerciements</h4></div></div></div><p>
<div class="itemizedlist"><ul><li><p>
  
    Daniel Scott a relu ce document en mars 2000 et y a trouvé de
    nombreuses erreurs ;
    
  </p></li><li><p>
  
    Pete Barrett a donné une astuce pour empêcher Windows de 
    réinitialiser les <acronym class="acronym">IRQ</acronym> 
    <acronym class="acronym">PCI</acronym> ;
    
  </p></li><li><p>
  
    Août 2004 : Ross Boylan a trouvé des erreurs et a 
    indiqué un manque de clarté dans la partie où on indique au 
    <acronym class="acronym">BIOS</acronym> qu'il s'agit d'un système d'exploitation 
    <acronym class="acronym">PnP</acronym>.

  </p></li></ul></div>
</p></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N1015E" />1.2. Plans futurs : vous pouvez aider</h3></div></div></div><p>

Merci de m'indiquer toute erreur, que ce soit dans les faits, les 
opinions, la logique, l'orthographe, la grammaire, la clarté, les liens, 
et cætera. Mais tout d'abord, si la date du document est vieille de plus 
de plusieurs mois, vérifiez que vous possédez bien la dernière version. 
Envoyez-moi toute information que vous trouvez intéressante pour ce 
document.

</p><p>Je n'ai pas encore étudié le code utilisé par les différents pilotes
Linux et par le noyau pour implémenter le Plug-and-Play. Mais, j'ai commencé à
jeter un œil, notamment aux commentaires. Donc, ce guide pratique est
encore incomplet. Il devrait expliquer plus en profondeur le « <span class="quote">hot
swapping</span> », le « <span class="quote">hot-plug</span> » et le nouveau logiciel
<acronym class="acronym">PnP</acronym> du noyau 2.6. Et il ne couvre pas le firewire. Il
comporte certainement quelques erreurs (faites-moi savoir où je me trompe). Dans
ce guide pratique, j'ai utilisé deux points d'interrogation (??) pour signaler
que je n'ai pas vraiment la réponse.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N1016E" />1.3. Nouvelles versions de ce guide pratique</h3></div></div></div><p>De nouvelles versions du guide pratique Plug-and-Play devraient apparaître
tous les ans et seront disponibles à la navigation et en téléchargement sur
les sites miroirs du LDP. Pour une liste des sites miroirs, voir <a class="ulink" href="http://www.tldp.org/mirrors.html" target="_top">http://www.tldp.org/mirrors.html</a>. Différents formats sont disponibles.
Si vous voulez seulement vérifier rapidement la date de la dernière version,
regardez sur <a class="ulink" href="http://www.traduc.org/docs/howto/lecture/Plug-and-Play-HOWTO.html" target="_top">http://www.traduc.org/docs/howto/lecture/Plug-and-Play-HOWTO.html</a>.
La version que vous lisez actuellement est la traduction française 
de la v1.15, d'août 2007.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N10179" />1.4. Nouveautés des dernières versions</h3></div></div></div><p>Pour un historique complet des révisions, voir le fichier source
(dans son format DocBook SGML) sur <a class="ulink" href="http://cvsview.tldp.org/index.cgi/LDP/howto/linuxdoc/Plug-and-Play-HOWTO.sgml." target="_top">http://cvsview.tldp.org/index.cgi/LDP/howto/linuxdoc/Plug-and-Play-HOWTO.sgml.</a>.
<div class="itemizedlist"><ul><li><p>v1.15, Août 2007 : Révision de la section sur les
   interruptions. Suppression de deux paragraphes redondants et confus portant
   sur une mystérieuse fonction « h() ».</p></li><li><p>v1.14, Février 2006 : Révision de « <span class="quote">Comment Linux
    gère-t'il le <acronym class="acronym">PnP</acronym></span> » ; LPC devait être configuré
    par le BIOS. Balance des <acronym class="acronym">IRQ</acronym>. Linux peut trouver des
    pilotes pour les périphériques détectés.</p></li><li><p>v1.13, Juillet 2005 : Conflit d'IRQ. Plus grande clarté
    dans les descriptions des ressources. /proc/bus. Espace de configuration
    PCI accédé via l'espace d'adressage des entrées/sorties. Plus d'outils de
    détection de matériel. Message d'erreur <span class="foreignphrase"><em class="foreignphrase">Can't allocate
    region</em></span>.</p></li><li><p>v1.12, Mars 2005 : /dev/eth0 n'existe plus. Informations
    modifiées dans /sys et /proc depuis le noyau 2.6. L'espace d'adressage de
    la configuration PCI est « <span class="quote">géographique</span> ». scanpci pourrait
    trouver un périphérique que lspci ne voit pas. Le noyau peut affecter des
    adresses au démarrage.</p></li></ul></div>
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N1019D" />1.5. Introduction générale. Avez-vous besoin de ce guide
pratique ?</h3></div></div></div><p>

Le Plug-and-Play (<acronym class="acronym">PnP</acronym>) est un système détectant 
automatiquement les périphériques tels que les disques, les cartes son, 
les cartes réseau, les modems, et cætera. Il trouve tous les 
périphériques du bus <acronym class="acronym">PCI</acronym> et tous les périphériques 
supportant <acronym class="acronym">PnP</acronym> sur l'ancien bus 
<acronym class="acronym">ISA</acronym>. Avant <acronym class="acronym">PnP</acronym>, beaucoup de 
périphériques étaient automatiquement recherchés en utilisant des 
méthodes non <acronym class="acronym">PnP</acronym> mais n'étaient pas trouvés quelque 
fois. <acronym class="acronym">PnP</acronym> fournit un moyen de trouver tous les 
périphériques supportant <acronym class="acronym">PnP</acronym>. Il réalise aussi une 
configuration de bas niveau de ces périphériques. Les périphériques non 
<acronym class="acronym">PnP</acronym> (et les périphériques <acronym class="acronym">PnP</acronym> 
ayant été correctement configurés avec <acronym class="acronym">PnP</acronym>) peuvent 
souvent être détectés par des méthodes n'utilisant pas 
<acronym class="acronym">PnP</acronym>. Le bus <acronym class="acronym">PCI</acronym> a été conçu pour 
le <acronym class="acronym">PnP</acronym> alors que le vieux bus <acronym class="acronym">ISA</acronym> 
ne l'a pas été à ses origines mais son support lui a été ajouté plus 
tard. Donc, souvent, <acronym class="acronym">PnP</acronym> est utilisé pour signifier 
uniquement <acronym class="acronym">PnP</acronym> pour l'ancien bus 
<acronym class="acronym">ISA</acronym>. Par exemple, lorsque vous apercevez au démarrage 
des messages d'isapnp du style : « <span class="quote">Plug &amp; Play 
device</span> », cela signifie seulement qu'il y a un périphérique 
<acronym class="acronym">ISA</acronym> <acronym class="acronym">PnP</acronym>. Dans ce guide pratique, 
nous traitons à la fois le PnP du bus <acronym class="acronym">ISA</acronym> et du bus 
<acronym class="acronym">PCI</acronym>.

</p><p>Avec le temps, le noyau Linux améliore son support de
<acronym class="acronym">PnP</acronym>. À la fin du 20è siècle, on pouvait dire que Linux
n'était pas un système d'exploitation <acronym class="acronym">PnP</acronym>. Mais il est dit
qu'avec la version 2.6 du noyau, Linux est maintenant totalement
compatible avec <acronym class="acronym">PnP</acronym> (en supposant que le noyau est construit
avec le support de <acronym class="acronym">PnP</acronym>). Bien que le système
<acronym class="acronym">PnP</acronym> n'est pas centralisé comme cela peut l'être avec MS
Windows (et son registre), le <acronym class="acronym">PnP</acronym> Linux décentralisé semble
fonctionner correctement.</p><p>Linux conserve la trace des affectations de ressources demandées par les
pilotes de périphériques et refuse toute requête s'il estime que cela causerait
un conflit. Le noyau fournit aussi des programmes que les pilotes de
périphériques peuvent appeler pour effectuer leurs opérations de plug-and-play.
Le noyau lit aussi tous les registres de configuration de tous les périphériques
<acronym class="acronym">PnP</acronym> et maintient leur tables que les pilotes de périphériques
peuvent consulter. Cette table aide les pilotes à trouver leur matériel. Le
noyau 2.6 fournit aussi un meilleur support pour le
« <span class="quote">hot-plug</span> ».</p><p>Le <acronym class="acronym">BIOS</acronym> de votre <acronym class="acronym">PC</acronym> travaillera
certainement un peu pour le plug-and-play. Donc, si tout fonctionne en harmonie
avec <acronym class="acronym">PnP</acronym>, vous pouvez utiliser votre ordinateur sans avoir
besoin de tout connaître sur le plug-and-play. Mais, si certains périphériques
supportés par Linux ne fonctionnent pas (parce qu'ils n'ont pas été repérés
par Linux ou parce qu'ils ont été mal configurés), vous aurez besoin de
lire au moins une partie de ce guide pratique. Vous en apprendrez sur le
<acronym class="acronym">PnP</acronym> mais aussi sur la façon dont la communication prend place
dans un ordinateur. Si vous avez un ordinateur moderne avec un bus
<acronym class="acronym">PCI</acronym> mais sans bus <acronym class="acronym">ISA</acronym>, vous pouvez passer
les parties sur le bus <acronym class="acronym">ISA</acronym>.</p><p>Si vous avez des problèmes avec un périphérique, regardez les
messages affichés lors du démarrage (remontez la liste avec
<span class="keycap"><strong>Shift</strong></span>+<span class="keycap"><strong>PageUp</strong></span>). Si
cela n'affiche pas aussi les messages du lancement, à partir du
<acronym class="acronym">BIOS</acronym>,
utilisez la touche Pause (voir <a class="xref" href="#pause_">Section 7.4, « Messages de démarrage »</a>).</p><p>Vérifiez
que vous utilisez le bon pilote pour un périphérique et que ce pilote est trouvé
et utilisé. Si le pilote est un module, tapez <span class="command"><strong>insmod</strong></span> (en tant
qu'utilisateur privilégié) pour voir s'il est chargé (et utilisé). Si ce n'est
pas un module, alors il doit être intégré au noyau.</p><p>Ce guide pratique ne couvre pas le problème de la recherche et de
l'installation de pilotes de périphériques. Peut-être qu'il devrait. Un des
problèmes possibles est qu'une carte (ou un autre périphérique physique) peut ne pas dire
le type de composants qu'elle utilise. Le nom du pilote correspond souvent au
nom de la puce et non pas au nom de la marque. Une façon de commencer la
vérification du pilote est de regarder s'il en est question dans la
documentation du noyau, dans un autre guide pratique ou plus généralement sur
Internet. Attention : de telles documentations peuvent ne plus être à jour.
</p><p>Les ordinateurs disposant de bus <acronym class="acronym">PCI</acronym> (et sans bus
<acronym class="acronym">ISA</acronym>) ont significativement réduit le nombre de points posant
problèmes. Concernant le bus <acronym class="acronym">ISA</acronym> et le manque de support au niveau
noyau pour l'<acronym class="acronym">ISA</acronym> <acronym class="acronym">PnP</acronym> (avant le noyau 2.4),
beaucoup de choses
posaient problèmes. Rappelez-vous que, parfois les problèmes semblant être
relatifs à <acronym class="acronym">PnP</acronym> sont dûs en réalité à un matériel défectueux
ou à un matériel non conforme aux spécifications <acronym class="acronym">PnP</acronym>.</p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="N1024A" />2. Ce que <acronym class="acronym">PnP</acronym> doit faire : allouer des
« <span class="quote">ressources bus</span> »</h2></div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N10252" />2.1. En quoi consiste le Plug-and-Play
(<acronym class="acronym">PnP</acronym>) ?</h3></div></div></div><p>Si vous ne comprenez pas cette section, lisez <a class="link" href="#dev_commun" title="2.2. Périphériques matériels et la communication avec ces derniers">Périphériques matériels et la communication avec ces
derniers</a>.</p><p>En simplifiant à l'extrême, Plug-and-Play indique aux pilotes de
périphériques où trouver les différents matériels (périphériques) tels que
modems, cartes réseau, cartes son, et cætera. La tâche du Plug-and-Play est de
faire correspondre les périphériques physiques avec les logiciels (pilotes de
périphériques) qui les font fonctionner, et d'établir des canaux de
communication entre chaque périphérique physique et son pilote. Pour ce faire,
<acronym class="acronym">PnP</acronym> alloue les « <span class="quote">ressources bus</span> » suivantes
aux matériels : adresses d'entrée/sortie, plages mémoire,
<acronym class="acronym">IRQ</acronym>, canaux <acronym class="acronym">DMA</acronym> (uniquement pour les bus
<acronym class="acronym">LPC</acronym> et <acronym class="acronym">ISA</acronym>). Ces quatre dernières sont
parfois appelées des ressources de premier ordre ou simplement des ressources.
<acronym class="acronym">PnP</acronym> maintient un enregistrement de ce qu'il fait et autorise
l'accès à ces informations aux pilotes de périphériques. Si vous ne comprenez
pas ce que sont ces quatre ressources bus, lisez les sous-sections suivantes de
ce guide pratique : Adresses d'entrée/sortie, <acronym class="acronym">IRQ</acronym>,
Canaux <acronym class="acronym">DMA</acronym>, Régions mémoire. Un article de la Linux Gazette
parle de trois des ressources bus. Il est disponible sur <a class="ulink" href="http://www.linuxgazette.com/issue38/blanchard.html" target="_top">
Introduction aux <acronym class="acronym">IRQ</acronym>, <acronym class="acronym">DMA</acronym> et adresses de
base</a> (NdT : une traduction française est disponible sur <a class="ulink" href="http://www.linuxgazette.com/issue38/blanchard.html" target="_top">traduc.org</a>).
Une fois que ces ressources bus ont été assignées (et si le bon pilote est
installé), le pilote actuel et ses « <span class="quote">fichiers</span> » du répertoire
<code class="filename">/dev</code> sont prêt à être utilisés.</p><p>Cette méthode d'affectation <acronym class="acronym">PnP</acronym> des ressources bus est
parfois appelée « <span class="quote">configuration</span> » mais il s'agit seulement d'une
configuration bas-niveau. Le répertoire <code class="filename">/etc</code>
comprend beaucoup de fichiers de configuration mais un grand nombre d'entre eux
ne concernent pas la configuration de <acronym class="acronym">PnP</acronym>. Donc, la grande
majorité des configurations de périphériques physiques n'a rien à voir avec
<acronym class="acronym">PnP</acronym> ou les ressources bus. Par exemple, l'initialisation d'un
modem par une phrase d'initialisation ou la configuration de sa vitesse ne
concerne pas <acronym class="acronym">PnP</acronym>. Donc lorsque nous parlons de
<acronym class="acronym">PnP</acronym>, la configuration ne concerne qu'un seul type de
configuration. Alors que d'autres documentations (telles que celles pour MS
Windows) appellent les ressources bus « <span class="quote">ressources</span> », j'ai utilisé le
terme de
ressources bus au lieu du simple « <span class="quote">ressources</span> » pour les distinguer
des
nombreux autres types de ressources.
</p><p><acronym class="acronym">PnP</acronym> est un long processus réalisé par différents logiciels
et matériels. Si seul un programme gérait <acronym class="acronym">PnP</acronym> sur Linux,
cela serait simple. Mais, avec Linux, chaque pilote de périphérique fait son
propre <acronym class="acronym">PnP</acronym> en utilisant le logiciel fourni par le noyau. Le
matériel du BIOS du PC utilise <acronym class="acronym">PnP</acronym> au démarrage du PC. Et il
y a bien plus que cela.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="dev_commun" />2.2. Périphériques matériels et la communication avec
ces derniers</h3></div></div></div><p>Un ordinateur est composé d'un processeur (<acronym class="acronym">CPU</acronym>)
réalisant
les opérations et de mémoire vive (<acronym class="acronym">RAM</acronym>) pour stocker les
programmes et les données (en accès rapide). De plus, il existe de nombreux
périphériques tels que différents types de disques, une carte vidéo, un clavier,
des périphériques réseaux, des cartes modem, des périphériques sons, le bus
<acronym class="acronym">USB</acronym>,
les ports séries et parallèles, et cætera. Dans les anciens temps, la plupart des
périphériques étaient des cartes insérées dans des emplacements du PC. Aujourd'hui,
beaucoup de périphériques, qui étaient auparavant des cartes, sont maintenant
compris dans les composants intégrés à la carte-mère. On trouve aussi une
alimentation apportant l'électricité, différents bus sur la carte mère pour
connecter les périphériques au <acronym class="acronym">CPU</acronym> et une boîte pour contenir
le tout.</p><p>Les cartes se connectant sur la carte mère peuvent contenir plus d'un
périphérique. Les cartes mémoires sont quelque fois considérées comme des
périphériques mais ils ne sont pas Plug-and-Play si on suit le sens utilisé dans
ce guide pratique.</p><p>Pour que l'ordinateur fonctionne bien, chaque périphérique doit être sous
le contrôle de son « <span class="quote">pilote</span> ». Il s'agit d'un logiciel faisant partie du
système
d'exploitation, pouvant être chargé en tant que module et exécuté à partir du
<acronym class="acronym">CPU</acronym>. Les pilotes de périphériques sont associés à des
« <span class="quote">fichiers spéciaux</span> » rangés dans le répertoire <code class="filename">/dev</code>, bien qu'ils ne soient pas vraiment des
fichiers. Ils ont des noms tels que hda3 (troisième partition du disque a),
ttyS1 (deuxième port série), eth0 (première carte Ethernet), et cætera.</p><p>Le périphérique eth0 est celui de la carte ethernet (carte réseau).
Auparavant, il s'agissait de /dev/eth0 mais c'est maintenant un périphérique
virtuel du noyau. Ce que eth0 référence dépend du type de carte ethernet que
vous avez. Si le pilote est un module, cette affectation se trouve probablement
dans une table interne du noyau mais pourrait aussi se trouver dans
<code class="filename">/etc/modules.conf</code> (appelé « <span class="quote">alias</span> »). Par
exemple, si vous disposez d'une carte ethernet utilisant le composant
« <span class="quote">tulip</span> », vous devez placer la ligne « <span class="quote">alias eth0 tulip</span> »
dans <code class="filename">/etc/modules.conf</code> pour que, lorsque votre PC cherche
eth0, il trouve le pilote tulip. Néanmoins, les noyaux modernes peuvent
généralement trouver le bon module du périphérique. De cette façon, vous n'aurez
pas à le spécifier vous-même.</p><p>Pour contrôler un périphérique, le <acronym class="acronym">CPU</acronym> (sous le
contrôle du pilote de périphérique) envoie des commandes et des données du
périphérique. Il reçoit aussi l'état et des données des différents
périphériques. Pour cela, chaque pilote doit connaître l'adresse du périphérique
qu'il doit contrôler. Connaître cette adresse revient à mettre en place un canal
de communication, même si le « <span class="quote">canal</span> » physique se trouve être le bus
de données interne au PC, bus partagé avec beaucoup d'autres périphériques.</p><p>Ce canal de communication est en fait un peu plus complexe que ce qui est
décrit ci-dessus. Une « <span class="quote">adresse</span> » est en fait une plage d'adresses,
ce qui fait que, parfois, le mot « <span class="quote">plage</span> » est utilisé à la place du
mot « <span class="quote">adresse</span> ». Il peut exister plus d'une plage (sans recoupement)
pour un seul périphérique. Il existe aussi un autre canal connu sous le nom
d'interruptions permettant au périphérique d'envoyer une requête de
« <span class="quote">demande d'aide</span> » urgente à leur pilote.
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N1030A" />2.3. Adresses</h3></div></div></div><p>Le bus PCI a trois plages d'adressage : les entrées/sorties, 
la mémoire principale (mémoire d'entrées/sorties) et la configuration. 
L'ancien bus <acronym class="acronym">ISA</acronym> ne dispose pas de cette dernière. 
Seules les entrées/sorties et la mémoire principale sont utilisées pour 
les entrées/sorties du périphérique. Les adresses de configuration sont 
fixes et ne peuvent pas être modifiées donc elles n'ont pas besoin 
d'être affectées. Pour plus d'informations, voir <a class="link" href="#pci_conf">Espace d'adressage de la configuration 
PCI</a>.</p><p>Quand le CPU veut accéder à un périphérique, il place l'adresse du 
périphérique sur un bus important de l'ordinateur (pour le PCI : le 
bus d'adresse/données). Tous les types d'adresses (tels que les 
entrées/sorties et la mémoire principale) partagent le même bus sur le 
PC. Mais la présence ou l'absence de voltage sur certains fils dédiés 
sur le bus du PC indique l'espace occupée par une adresse : 
entrée/sortie, mémoire principale (voir <a class="link" href="#mem_" title="2.5. Plages mémoire">Espaces 
d'adressage</a>) ou la configuration (seulement PCI). Ceci est un peu 
trop simplifié car indiquer à un périphérique PCI qu'il s'agit d'une 
adresse de configuration est réellement plus complexe que la description 
ci-dessus. Voir <a class="link" href="#pci_conf">Espace d'adressage pour la 
configuration PCI</a> pour plus d'informations. Voir <a class="link" href="#address_details" title="13.2. Détails des adresses">Détails des adresses</a> pour plus 
d'informations sur l'adressage en général.</p><p>Les adresses d'un périphérique sont stockées dans les registres du
matériel physique. Elles peuvent être changées par logiciel et elles peuvent
être désactivées pour que le périphérique ne soit plus adressable, sauf en ce
qui concerne les adresses de configuration du PCI qui ne peuvent être ni
modifiées ni désactivées.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N10326" />2.4. Adresses d'entrées/sorties (principes relatifs à d'autres
ressources)</h3></div></div></div><p>Les périphériques étaient originellement situés dans la plage d'adresses
des entrées/sorties mais, aujourd'hui, ils peuvent utiliser la plage en mémoire
principale. Une adresse d'entrée/sortie est quelque fois simplement appelée
« <span class="quote">I/O</span> », « <span class="quote">IO</span> », « <span class="quote">i/o</span> » ou « <span class="quote">io</span> ».
Les termes « <span class="quote">port I/O</span> » ou « <span class="quote">plage d'entrées/sorties</span> »
sont aussi utilisés. Ne confondez pas ces ports d'entrées/sorties avec la
mémoire d'entrées/sorties située en mémoire principale. Il existe deux étapes
principales pour allouer des adresses I/O (ou d'autres ressources bus telles que
les interruptions sur le bus <acronym class="acronym">ISA</acronym>) :
<div class="itemizedlist"><ul><li><p>Initialiser l'adresse I/O, et cætera. dans le matériel (dans un de ses
    registres),</p></li><li><p>Laisser son pilote de périphérique reconnaître l'adresse I/O,
    et cætera.</p></li></ul></div>
</p><p>Souvent, le pilote du périphérique fait les deux (en quelque sorte).
Le pilote de périphérique n'a pas réellement besoin d'initialiser une
adresse d'entrée/sortie s'il découvre que l'adresse a déjà été initialisée
(peut-être par le <acronym class="acronym">BIOS</acronym>) et qu'il souhaite accepter cette
adresse. Une fois que le pilote a soit trouvé une adresse précédemment
configurée soit configuré l'adresse lui-même, alors il sait évidemment de quelle
adresse il s'agit, donc il n'est pas nécessaire de lui fournir cette
information -- il la connaît déjà.</p><p>Le processus en deux étapes ci-dessus (1. configurer l'adresse au niveau
matériel.  2. mettre au courant le pilote.) ressemble aux deux
parties d'un problème pour trouver le numéro de la maison d'une personne dans
la rue. Quelqu'un doit installer un numéro sur l'entrée de la maison pour
qu'elle puisse être trouvée, puis les personnes qui souhaitent aller à cette
adresse doivent obtenir (et conserver) ce numéro pour qu'elles puissent trouver
la maison. En informatique, le matériel du périphérique doit d'abord obtenir
son adresse, qu'il placera dans un registre matériel spécial (ce qui revient à
conserver le numéro dans notre exemple), puis le pilote de périphérique doit obtenir
cette adresse (écrire ce numéro dans son carnet d'adresses). Les deux doivent
être réalisés, soit automatiquement par le logiciel soit en saisissant
manuellement des données dans des fichiers de configuration. Des problèmes
pourraient survenir si seulement un des deux est fait correctement.</p><p>Pour la configuration manuelle de <acronym class="acronym">PnP</acronym>, des personnes
font l'erreur de ne faire qu'une de ces deux étapes et se demandent ensuite pourquoi
l'ordinateur ne peut pas trouver le périphérique. Par exemple, ils utilisent
<span class="command"><strong>setserial</strong></span> pour associer une adresse au port série sans
réaliser que ceci ne fait que donner une adresse au pilote. Cela n'enregistre
pas cette adresse au niveau du port série physique. Si vous avez dit une bêtise
au port série, alors vous avez un problème. Une autre façon de parler au pilote
est de donner l'adresse comme option au module du noyau (pilote de périphérique).
Si ce que vous dites est faux, il peut y avoir des problèmes. Un pilote
intelligent pourrait détecter comment le matériel est réellement configuré
et rejeter les mauvaises informations fournies par l'option (ou au moins
afficher un message d'erreur).</p><p>

Un pré-requis évident est que le périphérique physique (comme une carte) 
doit connaître son adresse avant le pilote du périphérique. Comme les 
pilotes de périphérique se lancent souvent tout de suite après le 
démarrage de l'ordinateur, ils peuvent tenter d'accéder à une carte 
(pour vérifier sa présence, et cætera) avant que l'adresse ne soit 
enregistrée au niveau de la carte par le programme de configuration 
<acronym class="acronym">PnP</acronym>. Et vous verrez un message d'erreur indiquant 
l'absence de la carte même si elle est bien dans le PC (mais n'a pas 
encore obtenue son adresse).

</p><p>Ce qui a été dit dans les derniers paragraphes concernant les
adresses I/O s'applique de la même manière à la majorité des autres
ressources bus : <a class="xref" href="#mem_" title="2.5. Plages mémoire">Section 2.5, « Plages mémoire »</a>, <a class="xref" href="#interrupt_over" title="2.6. IRQ - un aperçu">Section 2.6, « <acronym class="acronym">IRQ</acronym> - un aperçu »</a> et <a class="xref" href="#dma_" title="2.7. DMA (accès direct à la mémoire) ou maîtrise du bus">Section 2.7, « <acronym class="acronym">DMA</acronym> (accès direct à la
mémoire) ou maîtrise du bus »</a>. Les trois
prochaines sections expliqueront ce qu'ils sont. La seule exception est
que les interruptions du bus <acronym class="acronym">PCI</acronym> ne sont pas
données par les registres d'une carte mais elles sont plutôt déroutées
vers les <acronym class="acronym">IRQ</acronym> par un composant de la carte mère. Ensuite,
l'<acronym class="acronym">IRQ</acronym> utilisée par cette carte <acronym class="acronym">PCI</acronym> est
inscrite dans un registre de la carte dans un but unique d'informer.</p><p>Pour voir quelles adresses d'entrées/sorties sont utilisées sur votre
<acronym class="acronym">PC</acronym>, regardez dans le fichier
<code class="filename">/proc/ioports</code>.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="mem_" />2.5. Plages mémoire</h3></div></div></div><p>Beaucoup de périphériques disposent d'une plage mémoire en mémoire
principale. C'est quelquefois appelé « <span class="quote">mémoire partagée</span> » ou
« <span class="quote">mémoire d'entrées/sorties</span> ». Cette mémoire est située physiquement
dans le périphérique physique mais l'ordinateur y accède comme s'il accédait à
des composants mémoire. En parlant de ressources bus, c'est souvent
simplement appelé « <span class="quote">mémoire</span> », « <span class="quote">mem</span> », voire
« <span class="quote">iomem</span> ». En plus de l'utilisation de cette « <span class="quote">mémoire</span> »,
un tel périphérique peut aussi utiliser une plage mémoire conventionnelle
d'entrées/sorties. Pour connaître la mémoire utilisée sur votre ordinateur,
cherchez dans <code class="filename">/proc/iomem</code>. Ce « <span class="quote">fichier</span> » inclut
la mémoire utilisée par les composants mémoire habituels de la RAM, donc il
affiche l'allocation mémoire en général et pas seulement l'allocation iomem.
Si vous apercevez un numéro étrange au lieu d'un nom, c'est probablement le
numéro d'un périphérique PCI, ce que vous pouvez vérifier en exécutant
« <span class="quote">lspci</span> ».</p><p>Lorsque vous insérez une carte utilisant iomem, vous êtes aussi en train
d'insérer un module mémoire pour la mémoire principale. Une adresse haute est
sélectionnée pour lui par <acronym class="acronym">PnP</acronym> de façon à ce que cela ne
rentre pas en conflit avec les modules de la mémoire principale (composants).
Cette mémoire peut être de la mémoire morte (<acronym class="acronym">ROM</acronym> ou Read Only
Memory) ou de la mémoire partagée. Cette dernière est partagée entre le
périphérique et le <acronym class="acronym">CPU</acronym> (ayant lancé le pilote du
périphérique) de la même façon que la plage d'adresses d'entrées/sorties est
partagée entre le périphérique et le <acronym class="acronym">CPU</acronym>. Cette mémoire
partagée sert en tant que moyen de « <span class="quote">transfert</span> » de données entre le
périphérique et la mémoire principale. C'est de l'entrée/sortie mais ce n'est
pas fait dans la plage d'adresses des entrées/sorties. La carte et le pilote
doivent connaître la plage d'adresses.</p><p>La <acronym class="acronym">ROM</acronym> (<span class="foreignphrase"><em class="foreignphrase">Read-Only Memory</em></span>,
soit mémoire en lecture seule) est un genre différent d'iomem. C'est plutôt un
programme (parfois un pilote de périphérique), utilisé avec ce périphérique.
Cela peut aussi être un code d'initialisation malgré que le pilote soit encore
nécessaire. Avec un peu de chance, il fonctionnera aussi sous Linux, et pas
seulement sous MS Windows. Elle peut être copiée en mémoire principale pour
fonctionner plus rapidement. Mais dans ce cas, elle n'est plus « <span class="quote">en lecture
seule</span> ».</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="interrupt_over" />2.6. <acronym class="acronym">IRQ</acronym> - un aperçu</h3></div></div></div><p>Après avoir lu ceci, vous pouvez lire <a class="xref" href="#interrupt_detail" title="13.4. Détails sur les interruptions">Section 13.4, « Détails sur les interruptions »</a> pour bien plus de détails. Ce qui suit
est volontairement simplifié : en plus des adresses, il existe
aussi un numéro d'interruption à gérer (tel que l'<acronym class="acronym">IRQ</acronym>
5). Cela s'appelle un numéro d'<acronym class="acronym">IRQ</acronym> (Interrupt
ReQuest, ou demande d'interruption), ou plus simplement une
« <span class="quote">irq</span> ». Nous avons déjà mentionné ci-dessus que le pilote de
périphérique doit connaître l'adresse d'une carte pour être capable de
communiquer avec elle. </p><p>Mais qu'en est-il de la communication en sens inverse ? Supposez que
le périphérique ait besoin de dire quelque chose à son pilote immédiatement.
Par exemple, le périphérique peut recevoir un grand nombre d'octets destinés à
la mémoire principale et le tampon utilisé pour stocker ces octets est
pratiquement plein. Du coup, le périphérique a besoin de demander à son pilote
de récupérer ces octets avant que le tampon ne se voit dépassé par le flot continu
d'octets. Un autre exemple serait de signaler au pilote que le périphérique a
terminé d'envoyer un ensemble d'octets et qu'il attend maintenant de nouveaux
octets à envoyer.</p><p>Comment le périphérique peut-il envoyer rapidement un signal à son
pilote ?
Il peut ne pas être capable d'utiliser le bus de données principal car il y a
des chances qu'il soit déjà utilisé. Au lieu de cela, il place un voltage sur
un fil d'interruption dédié (aussi appelé ligne ou trace) qui est souvent réservé
pour ce seul périphérique. Ce signal est appelé une demande d'interruption
(<acronym class="acronym">IRQ</acronym>) ou plus simplement une « <span class="quote">interruption</span> ». Il
existe l'équivalent de 16 (ou 24, et cætera.) fils de ce type dans un PC et chaque fil amène
(indirectement) à un certain pilote de périphérique. Chaque fil a un numéro
d'<acronym class="acronym">IRQ</acronym> unique. Le périphérique doit placer son interruption
sur le bon fil. Le fil sur lequel le périphérique envoie ces demandes
d'aide est déterminé par le numéro d'<acronym class="acronym">IRQ</acronym> enregistré dans le
périphérique. Ce même numéro d'<acronym class="acronym">IRQ</acronym> doit être connu par le
pilote du périphérique pour que celui-ci sache quelle interruption écouter.
</p><p>Une fois que le pilote reçoit l'interruption du périphérique, il
doit trouver pourquoi cette interruption a été générée et agir de
manière appropriée pour régler le problème. Sur le bus
<acronym class="acronym">ISA</acronym>, chaque périphérique a habituellement besoin de
son propre numéro unique d'<acronym class="acronym">IRQ</acronym>. Pour le bus
<acronym class="acronym">PCI</acronym> et dans d'autres cas spéciaux, le partage
d'<acronym class="acronym">IRQ</acronym> est autorisé (deux périphériques <acronym class="acronym">PCI</acronym>,
ou plus, pourraient avoir le même numéro d'<acronym class="acronym">IRQ</acronym>).
De même, pour le <acronym class="acronym">PCI</acronym>, chaque périphérique <acronym class="acronym">PCI</acronym>
a un fil fixe <span class="foreignphrase"><em class="foreignphrase">PCI Interrupt</em></span>. Mais un composant
de routage programmable fait correspondre les fils <acronym class="acronym">PCI</acronym> aux
interruptions de type <acronym class="acronym">ISA</acronym>. Voir <a class="xref" href="#interrupt_detail" title="13.4. Détails sur les interruptions">Section 13.4, « Détails sur les interruptions »</a> pour savoir comment cela fonctionne.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="dma_" />2.7. <acronym class="acronym">DMA</acronym> (accès direct à la
mémoire) ou maîtrise du bus</h3></div></div></div><p>Pour le bus <acronym class="acronym">PCI</acronym>, <acronym class="acronym">DMA</acronym> et maîtrise de
bus signifient la même chose. Avant l'arrivée du bus <acronym class="acronym">PCI</acronym>, la
maîtrise du bus était rare et le <acronym class="acronym">DMA</acronym> fonctionnait différemment
et était lent. L'accès direct à la mémoire (<acronym class="acronym">DMA</acronym>, acronyme de
<span class="foreignphrase"><em class="foreignphrase">Direct Memory Access</em></span>) est ce qui permet à un
périphérique de prendre la main sur le bus principal de l'ordinateur et de
transférer directement des octets vers la mémoire principale ou vers d'autres
périphériques. Normalement, le processeur s'occupe des transferts d'un
périphérique vers la mémoire principale par un processus en deux
étapes :</p><div class="itemizedlist"><ul><li><p>lire un ensemble d'octets à partir de la page mémoire
    d'entrées/sorties et les stocker dans le <acronym class="acronym">CPU</acronym> lui-même ;
    </p></li><li><p>écrire ces octets dans la mémoire principale.</p></li></ul></div><p>Avec le <acronym class="acronym">DMA</acronym>, il s'agit d'un processus en une seule 
étape consistant en l'envoi des octets directement du périphérique à la
mémoire. Les périphériques doivent disposer de capacités <acronym class="acronym">DMA</acronym>
intégrées et, du coup, tous les périphériques ne peuvent pas faire de
<acronym class="acronym">DMA</acronym>. Alors que le <acronym class="acronym">DMA</acronym> est en cours, le
processeur ne peut pas faire grand chose car le bus principal est en cours
d'utilisation par le transfert <acronym class="acronym">DMA</acronym>.</p><p>L'ancien bus <acronym class="acronym">ISA</acronym> peut faire du <acronym class="acronym">DMA</acronym>
lentement alors que le bus <acronym class="acronym">PCI</acronym> peut faire du
<acronym class="acronym">DMA</acronym> par maîtrise du bus. Le bus <acronym class="acronym">LPC</acronym> a à
la fois l'ancien et le nouveau <acronym class="acronym">DMA</acronym> (maîtrise du bus). Sur le
bus <acronym class="acronym">PCI</acronym>, ce qui devrait être appelé plus précisément
« maîtrise du bus » est souvent appelé « Ultra DMA », « BM-DNA », « udma » ou
tout simplement « DMA ». Sur le bus <acronym class="acronym">PCI</acronym>, la maîtrise du bus
est souvent appelé <acronym class="acronym">DMA</acronym>. La maîtrise du bus permet aux
périphériques de devenir temporairement les maîtres du bus et de transférer des
octets un peu comme lorsque le maître du bus était le processeur. Il n'utilise
aucun numéro de canal car l'organisation du bus <acronym class="acronym">PCI</acronym>
est telle que le matériel <acronym class="acronym">PCI</acronym> sait quel
périphérique est actuellement le maître du bus et quel périphérique
réclame à devenir le maître du bus. Du coup, il n'y a pas d'allocation de
ressources pour les canaux <acronym class="acronym">DMA</acronym> pour le bus
<acronym class="acronym">PCI</acronym> et aucune ressource de canaux <acronym class="acronym">DMA</acronym>
n'existe pour ce bus. Le bus <acronym class="acronym">LPC</acronym> est supposé être
configuré par le <acronym class="acronym">BIOS</acronym> pour que les utilisateurs n'aient
pas à se soucier des canaux <acronym class="acronym">DMA</acronym>.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="dma_isa" />2.8. Canaux <acronym class="acronym">DMA</acronym> (non pas pour le bus
<acronym class="acronym">PCI</acronym>)</h3></div></div></div><p>C'est seulement pour l'ancien bus ISA et le bus LPC. Quand un périphérique veut faire du
DMA, il lance une requête de DMA en utilisant les fils dédiés à cela, un peu
comme une requête d'interruption. En fait, le DMA aurait pû être géré en
utilisant des interruptions mais cela aurait introduit des délais, donc il est
plus rapide de faire cela en ayant un type spécial d'interruption connu en tant
que requête DMA. Comme les interruptions, les demandes DMA sont numérotées pour
identifier le périphérique lançant la requête. Ce nombre est appelé un canal DMA.
Comme les transferts DMA utilisant tous le bus principal (et qu'un seul peut être
lancé à la fois), ils utilisent tous les même canal pour le flot de données mais
le numéro de « <span class="quote">canal DMA</span> » sert à identifier qui utilise le canal. Les
registres matériels existent sur la carte mère, qui enregistre l'état actuel de
chaque canal. Du coup, pour lancer une requête DMA, le périphérique doit connaître
son numéro de canal DMA stocké dans un registre spécial du périphérique physique.
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N10481" />2.9. « <span class="quote">Ressources</span> » du périphérique et du pilote</h3></div></div></div><p>Donc, les pilotes de périphériques doivent être « <span class="quote">attachés</span> »
d'une façon quelconque au matériel qu'ils contrôlent. Ceci se fait en allouant
des ressources bus (I/O, mémoire, <acronym class="acronym">IRQ</acronym>, <acronym class="acronym">DMA</acronym>)
au périphérique physique et en laissant le pilote le découvrir. Par exemple,
un port série utilise seulement deux ressources : une
<acronym class="acronym">IRQ</acronym> et une adresse d'entrées/sorties. Ces deux valeurs
doivent être fournies au pilote et au périphérique physique. Le pilote (et son
périphérique) dispose d'un nom dans le répertoire /dev (tel que ttyS1).
L'adresse et le numéro <acronym class="acronym">IRQ</acronym> sont stockés par le périphérique
physique dans ses registres de configuration sur sa carte (ou dans un composant
de la carte mère). Les vieux matériels (dans les années 1990) utilisaient des
interrupteurs (ou des cavaliers) pour configurer physiquement l'<acronym class="acronym">IRQ</acronym>
et l'adresse au niveau du matériel. Ce paramétrage restera fixe tant qu'une
personne n'enlevera pas le boîtier pour déplacer les cavaliers.</p><p>Mais, dans le cas de <acronym class="acronym">PnP</acronym> (pas de cavaliers), les données
du registre de configuration sont habituellement perdues lorsque le PC est
éteint, donc les données des ressources bus doivent être fournies à chaque
périphérique à chaque allumage du PC.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N1049F" />2.10. Les ressources sont limitées</h3></div></div></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N104A2" />2.10.1. L'ordinateur idéal</h4></div></div></div><p>

L'architecture du PC n'apporte qu'un nombre limité de ressources : 
<acronym class="acronym">IRQ</acronym>, canaux <acronym class="acronym">DMA</acronym>, adresses 
d'entrées/sorties et de plages mémoires. S'il n'existait qu'un 
nombre limité de périphériques et qu'ils aient tous des ressources bus 
standardisées (telles que des adresses d'entrées/sorties et des numéros 
d'<acronym class="acronym">IRQ</acronym> uniques), il n'y aurait aucun souci pour 
attacher un pilote à son périphérique. Chaque périphérique devrait avoir 
un nombre fixe de ressources qui n'entreraient pas en conflit avec tout 
autre périphérique sur votre ordinateur. Deux périphériques ne devraient 
pas avoir les mêmes adresses, il n'y aurait pas de conflit 
d'<acronym class="acronym">IRQ</acronym> sur le bus <acronym class="acronym">ISA</acronym>, et cætera. 
Chaque pilote devrait être développé avec des adresses, des 
<acronym class="acronym">IRQ</acronym>, et cætera, uniques codées en dur dans le 
programme. La vie serait simple.

</p><p>Une autre façon d'empêcher les conflits d'adresses serait d'avoir un
numéro d'emplacement, inclus dans l'adresse, pour chaque carte. Du coup, il n'y
aurait plus de conflits d'adresses entre deux cartes différentes (car elles
sont dans des emplacements différents). La conception des cartes ne permettrait
pas les conflits d'adresses entre les différentes fonctions de la carte. Il en
ressort que l'espace d'adressage (utilisé pour la demande et l'affectation de
ressources) le fait réellement. Mais cela n'est pas pris en compte pour les
adresses d'entrées/sorties et pour les régions mémoire. Partager des IRQ comme
sur le bus PCI évite aussi des conflits mais peut poser d'autres problèmes.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N104BB" />2.10.2. L'ordinateur réel</h4></div></div></div><p>Mais l'architecture du PC a des problèmes de conflit. L'augmentation
du nombre de périphériques (incluant les multiples périphériques de même type)
a tendance à augmenter les conflits potentiels. En même temps, l'introduction
du bus PCI, où deux périphériques ou plus peuvent partager la même interruption
et l'introduction d'interruptions supplémentaires,
a tendance à réduire les conflits. Le résultat global, dû au passage au PCI,
a été une réduction des conflits car les ressources les plus faibles sont les
IRQ. Néanmoins, même sur le bus PCI, c'est un peu plus efficace pour éviter le
partage des IRQ. Dans certains cas où les interruptions arrivent en une
succession rapide et doivent être traitées rapidement (comme en audio),
le partage peut causer des dégradations dans les performances. Donc, il
n'est pas bon d'affecter tous les périphériques <acronym class="acronym">PCI</acronym>
au même <acronym class="acronym">IRQ</acronym>, l'affectation doit être partagée. Néanmoins,
certaines personnes trouvent que tous les périphériques <acronym class="acronym">PCI</acronym>
sont sur la même <acronym class="acronym">IRQ</acronym>.</p><p>Donc, les périphériques ont besoin d'avoir de la flexibilité de façon à ce
qu'ils puissent être initialisés avec n'importe quelle adresse,
<acronym class="acronym">IRQ</acronym>, et cætera. C'est nécessaire pour éviter tout conflit et arriver
à un point d'équilibre. Mais quelques <acronym class="acronym">IRQ</acronym> et adresses sont
pratiquement des standards, comme ceux de l'horloge et du clavier. Ils n'ont pas
besoin d'une telle flexibilité.</p><p>En plus du problème de conflit lors de l'allocation des ressources bus,
une indication erronée en indiquant au pilote de périphérique quelles sont les
ressources bus peut causer un autre problème. Cela a plus de chances d'arriver
dans le cas de la configuration manuelle où l'utilisateur saisit les ressources
utilisées dans un fichier de configuration sur le disque dur. Ceci fonctionne
généralement bien quand les ressources sont initialisées avec des cavaliers sur
les cartes (en supposant que l'utilisateur sache comment elles étaient
initialisées et n'a fait aucune faute en saisissant ces données dans les fichiers
de configuration). Mais, avec des ressources configurées par un logiciel
<acronym class="acronym">PnP</acronym>, elles ne seront pas toujours identiques et cela
pourrait poser problème pour toute configuration manuelle où l'utilisateur saisit
les valeurs des ressources bus configurées par <acronym class="acronym">PnP</acronym>.</p><p>L'allocation de ressources bus, lorsqu'elle est faite correctement, établit
des canaux de communications sans conflit entre le matériel physique et le
pilote associé. Par exemple, si une certaine plage mémoire d'entrées/sorties
(ressource) est allouée à la fois au pilote de périphérique et au matériel,
alors cela a établi une communication sur une voie à sens unique entre eux. Le
pilote peut envoyer des commandes et des informations au périphérique. C'est
donc un peu plus qu'une voie à sens unique car le pilote peut obtenir des
informations du périphérique en lisant ces registres. Mais le périphérique ne
peut pas initier une communication de cette façon. Pour initier une
communication, le périphérique a besoin d'une <acronym class="acronym">IRQ</acronym> pour qu'il
puisse envoyer une interruption à son pilote. Ceci crée un canal de
communication à double-sens où le périphérique physique et son pilote peuvent
initier une communication.</p></div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="N104E1" />3. Deuxième introduction au Plug-and-Play (<acronym class="acronym">PnP</acronym>)</h2></div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N104E7" />3.1. Introduction à <acronym class="acronym">PnP</acronym></h3></div></div></div><p>Le terme Plug-and-Play (<acronym class="acronym">PnP</acronym>) a différentes
significations. Au sens général, il s'agit de la configuration automatique
lorsqu'une personne connecte un périphérique et que celui-ci se configure
lui-même. Le sens utilisé dans ce livre est tout autre :
<acronym class="acronym">PnP</acronym> signifie la
configuration des ressources bus pour <acronym class="acronym">PnP</acronym> (les configurer au
niveau des périphériques physiques) et la communication de cette information aux pilotes
de périphériques. Dans le cas de Linux, il s'agit souvent d'un pilote
déterminant la façon dont le bus a initialisé les ressources bus et, si
nécessaire, le pilote donnant une commande pour changer (réinitialiser) les
ressources bus. Souvent, « <span class="quote">PnP</span> » ne signifie que <acronym class="acronym">PnP</acronym>
sur le bus <acronym class="acronym">ISA</acronym>  donc le message
d'isapnp, « <span class="quote">No Plug and Play device found</span> », signifie simplement qu'aucun
périphérique <acronym class="acronym">ISA</acronym> <acronym class="acronym">PnP</acronym> n'a été trouvé. Les
spécifications du <acronym class="acronym">PCI</acronym> standard (inventé
avant l'utilisation du terme « <span class="quote">PnP</span> ») apportent l'équivalent de
<acronym class="acronym">PnP</acronym> au
bus <acronym class="acronym">PCI</acronym>.</p><p><acronym class="acronym">PnP</acronym> fait correspondre les périphériques avec leur
pilote et spécifie leurs canaux de communication (en allouant des ressources
bus). Il communique électroniquement avec les registres de configuration situés
à l'intérieur des périphériques physiques en utilisant un protocole standardisé.
Sur le bus <acronym class="acronym">ISA</acronym> et avant le Plug-and-Play, les ressources bus
étaient simplement initialisées au niveau matériel avec des interrupteurs de
différentes sortes. Quelquefois, les ressources bus pouvaient être configurées
sur le matériel par un pilote (généralement écrit seulement pour un système MS
mais dans de rares cas supporté aussi par un pilote Linux). Cela ressemblait à du
<acronym class="acronym">PnP</acronym> mais aucun protocole standardisé n'était utilisé donc il
ne s'agissait pas vraiment de <acronym class="acronym">PnP</acronym>. Certaines cartes contiennent
un paramètrage par cavaliers qui peut être surchargé par un tel pilote. Pour Linux
avant le <acronym class="acronym">PnP</acronym>, les ressources bus étaient affectées aux pilotes
logiciels par des fichiers de
configuration (ou autre chose de ce genre) ou en parcourant le bus aux adresses
où il s'attendait à trouver le périphérique. Mais ces méthodes sont toujours
utilisées de nos jours pour permettre à Linux d'utiliser du matériel non
<acronym class="acronym">PnP</acronym>. Et, quelque fois, ces vieilles méthodes sont toujours
utilisées de nos jours sur du matériel <acronym class="acronym">PnP</acronym> (après que le
<acronym class="acronym">BIOS</acronym> ait affecté des ressources aux matériels par
les méthodes <acronym class="acronym">PnP</acronym>).</p><p>Le bus PCI ressemblait au <acronym class="acronym">PnP</acronym> dès le début mais il n'a
pas été appelé <acronym class="acronym">PnP</acronym> ou « plug and play », ce qui a eu comme
résultat que <acronym class="acronym">PnP</acronym> signifie souvent <acronym class="acronym">PnP</acronym> sur
le bus <acronym class="acronym">ISA</acronym>. Dans la documentation, <acronym class="acronym">PnP</acronym>
signifie habituellement <acronym class="acronym">PnP</acronym> sur le bus <acronym class="acronym">ISA</acronym>
comme sur le bus <acronym class="acronym">PCI</acronym>.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N1054E" />3.2. Comment fonctionne le <acronym class="acronym">PnP</acronym> (explication simplifiée)</h3></div></div></div><p>

Voici comment <acronym class="acronym">PnP</acronym> devrait fonctionner. L'hypothétique 
programme de configuration <acronym class="acronym">PnP</acronym> trouve tous les 
périphériques <acronym class="acronym">PnP</acronym> et demande à chacun les ressources 
bus dont il a besoin. Ensuite, il vérifie quelles sont les ressources 
bus qu'il peut affecter (<acronym class="acronym">IRQ</acronym>, et cætera). Bien sûr, 
s'il a réservé des ressources bus utilisées pour des périphériques non 
<acronym class="acronym">PnP</acronym> (s'il les connaît), il ne les donne pas. Il 
utilise certains critères (ne faisant pas partie des spécifications 
<acronym class="acronym">PnP</acronym>) pour donner les ressources bus de façon à ce 
qu'il n'y ait pas de conflit et de façon à ce que tous les périphériques 
disposent de ce qu'ils ont demandé (si possible). Il indique ensuite 
indirectement à chaque périphérique physique les ressources bus qui lui 
ont été assignées et les périphériques se configurent eux-mêmes pour 
n'utiliser que ces ressources-là. Enfin, les pilotes de périphériques 
trouvent d'une manière ou d'une autre quelles ressources sont utilisées 
par leur périphérique et sont donc capables de communiquer avec les 
périphériques qu'ils contrôlent.

</p><p>Par exemple, prenons une carte ayant besoin d'une <acronym class="acronym">IRQ</acronym>
(d'un numéro d'<acronym class="acronym">IRQ</acronym>) et de 1 Mo de mémoire partagée. Le
programme <acronym class="acronym">PnP</acronym> lit cette requête des registres de
configuration de la carte. Il lui affecte l'<acronym class="acronym">IRQ</acronym> 5 et
1 Mo d'espace mémoire, commençant à partir de l'adresse 0xe9000000. Le
programme <acronym class="acronym">PnP</acronym> lit aussi les informations d'identification de
la carte, indiquant ainsi le type de périphérique, son numéro 
d'identifiant, et cætera. Ensuite,
il informe, directement ou indirectement, le pilote de périphérique convenable
pour ce matériel, de ce qu'il a fait. Si le pilote lui-même gère le
<acronym class="acronym">PnP</acronym>, alors
il n'est pas nécessaire de trouver un pilote pour le périphérique (car le
pilote est déjà en cours d'exécution). Sinon, le bon pilote de périphérique doit
être trouvé et la configuration du périphérique doit lui être
communiquée.</p><p>Ce n'est pas toujours aussi simple car la carte (ou la table de routage
pour le PCI) pourrait indiquer qu'elle ne peut utiliser que certains numéros
d'<acronym class="acronym">IRQ</acronym> ou que les 1 Mo de mémoire doivent résider dans
un certain espace d'adresses. Les détails sont différents pour les bus
<acronym class="acronym">PCI</acronym> et <acronym class="acronym">ISA</acronym>, cette dernière étant la plus
complexe.</p><p>Une façon habituellement utilisée pour allouer des ressources est 
de commencer avec un périphérique et de lui allouer des ressources bus. 
Puis de faire la même chose avec le périphérique suivant, et cætera. Ensuite, 
si finalement tous les périphériques obtiennent les ressources allouées 
sans conflit, alors tout va bien. Mais si allouer une ressource requise 
créait un conflit, alors il serait nécessaire de revenir en arrière et 
d'essayer de faire quelques changements dans les allocations précédentes 
de façon à conserver la ressource bus nécessaire. Ceci s'appelle le 
balancement. Linux ne le fait pas mais MS Windows en est capable dans 
certains cas. Pour Linux, tout ceci est fait par le 
<acronym class="acronym">BIOS</acronym>, le noyau ou les pilotes de périphériques. Avec 
Linux, le pilote du périphérique n'obtient pas son allocation finale de 
ressources tant que le pilote n'est pas lancé, donc une façon d'éviter 
les conflits est de ne pas lancer un périphérique qui pourrait causer un 
conflit. Néanmoins, le <acronym class="acronym">BIOS</acronym> alloue fréquemment des 
ressources au périphérique physique avant que Linux ne soit complètement 
démarré et le noyau vérifie les périphériques <acronym class="acronym">PCI</acronym> 
pour les conflits d'adresse au démarrage.</p><p>Des raccourcis existent et le logiciel <acronym class="acronym">PnP</acronym> peut les
utiliser. Un d'eux est de garder la trace de la façon dont sont assignées les
ressources bus lors de la dernière configuration (lorsque l'ordinateur a été
utilisé pour la dernière fois) et de réutiliser cette information. Les
<acronym class="acronym">BIOS</acronym> le font ainsi que MS Windows mais le Linux standard
ne le fait pas. Mais, d'une certaine façon, il le fait car il utilise souvent
ce que le <acronym class="acronym">BIOS</acronym> a fait. Windows stocke cette information
dans sa base de registres sur le disque dur et un <acronym class="acronym">BIOS</acronym>
PnP/<acronym class="acronym">PCI</acronym> le stocke dans une mémoire non volatile de votre PC
(mémoire appelée
<acronym class="acronym">ESCD</acronym> ; voir <a class="xref" href="#escd_" title="5.4.2. La base de données ESCD du BIOS">Section 5.4.2, « La base de données <acronym class="acronym">ESCD</acronym> du
<acronym class="acronym">BIOS</acronym> »</a>). Certains disent
que ne pas avoir de registres (ce qui est le cas de Linux) est mieux car,
avec Windows, la base de registres peut être corrompue et elle est de toute
façon difficile à éditer. Mais <acronym class="acronym">PnP</acronym> sur Linux a aussi des
problèmes.</p><p>Alors que MS Windows (sauf en ce qui concerne Windows 3.x et NT4) est un
système	d'exploitation <acronym class="acronym">PnP</acronym>, Linux n'était pas originellement
un système d'exploitation <acronym class="acronym">PnP</acronym> mais l'est devenu
graduellement. Au début, <acronym class="acronym">PnP</acronym> a fonctionné avec Linux parce
qu'un <acronym class="acronym">BIOS</acronym> <acronym class="acronym">PnP</acronym> configurait les ressources
bus et que les pilotes de périphériques récupéraient cette information en
utilisant des programmes apportés par le noyau Linux. Aujourd'hui, la plupart
des pilotes peuvent envoyer des commandes pour réaliser leur propre
configuration et n'ont pas besoin de se reposer toujours sur le
<acronym class="acronym">BIOS</acronym>. Malheureusement, un pilote pourrait utiliser une
ressource bus dont un autre périphérique aurait besoin plus tard. D'autres pilotes
de périphériques enregistrent la dernière configuration dans un fichier de
configuration et l'utilisent la prochaine fois que l'ordinateur est
allumé.</p><p>Si le périphérique physique se rappelle de son ancienne configuration, alors
il n'y aura pas de matériel à configurer au prochain démarrage, mais il
semble oublier sa configuration lors de l'arrêt. Certains périphériques
disposent d'une configuration par défaut (mais pas nécessairement la dernière
utilisée). Donc, un périphérique <acronym class="acronym">PnP</acronym> a besoin d'être
reconfiguré à chaque fois que le PC est allumé. De la même manière, si un
nouveau périphérique est ajouté, alors il a besoin d'être configuré. Allouer
des ressources bus pour ce nouveau périphérique peut nécessiter de récupérer
des ressources données auparavant à un autre et d'affecter à ce dernier de
nouvelles ressources. Actuellement, Linux ne peut pas gérer ce niveau de
sophistication (et MS Windows XP pourrait aussi ne pas en être capable).</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N105C5" />3.3. Démarrer le PC</h3></div></div></div><p>Quand le PC est lancé la première fois, le <acronym class="acronym">BIOS</acronym> lance
son programme pour démarrer le PC (la première étape étant de vérifier le
matériel de la carte mère). Si le système d'exploitation est stocké sur disque
dur (ce qui est habituellement le cas), alors le <acronym class="acronym">BIOS</acronym> doit
disposer de certaines informations sur le disque dur. Si ce disque est
<acronym class="acronym">PnP</acronym>, le <acronym class="acronym">BIOS</acronym> peut utiliser des méthodes
<acronym class="acronym">PnP</acronym> pour le trouver.  De même, pour permettre à l'utilisateur
de configurer manuellement le <acronym class="acronym">CMOS</acronym> du <acronym class="acronym">BIOS</acronym>
et de répondre
aux messages d'erreur lors du démarrage, un écran (et donc une carte vidéo) et
un clavier sont aussi requis. Donc, le <acronym class="acronym">BIOS</acronym> doit toujours
configurer via <acronym class="acronym">PnP</acronym> les périphériques nécessaires au
chargement du système d'exploitation à partir du disque dur.</p><p>Une fois que le <acronym class="acronym">BIOS</acronym> a identifié le disque dur, la
carte vidéo et le clavier, il est prêt à commencer le démarrage (charger le
système d'exploitation en mémoire). Si vous avez indiqué au
<acronym class="acronym">BIOS</acronym> que vous disposez d'un système d'exploitation
<acronym class="acronym">PnP</acronym>, il devrait commencer le chargement comme indiqué
ci-dessus et laisser le système d'exploitation finir la configuration
<acronym class="acronym">PnP</acronym>. Autrement, un
<acronym class="acronym">BIOS</acronym>-<acronym class="acronym">PnP</acronym> essaiera de configurer le reste
des périphériques (mais sans en informer leur pilote). peuvent toujours
trouver les informations nécessaires en utilisant les fonctions disponibles
dans le noyau Linux.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N105F9" />3.4. Les bus</h3></div></div></div><p>Pour voir ce qui se trouve sur le bus <acronym class="acronym">PCI</acronym>, exécutez
<span class="command"><strong>lspci</strong></span> ou <span class="command"><strong>lspci -vv</strong></span>. Ou vous pouvez aussi
saisir <span class="command"><strong>scanpci -v</strong></span> pour la même information dans le format
de code numérique où le périphérique est indiqué par numéro (par exemple :
« <span class="quote">device 0x122d</span> ») au lieu du nom, et cætera. Dans de rares cas,
<span class="command"><strong>scanpci</strong></span> trouvera un périphérique que <span class="command"><strong>lspci</strong></span>
n'arrive pas à trouver.</p><p>Les messages au démarrage sur votre écran affichent les périphériques
qui ont été trouvés sur les différents bus (utilisez shift-PageUp pour les voir).
Voir <a class="link" href="#boot_time_msgs" title="7.4. Messages de démarrage">Messages au démarrage</a>.</p><p><acronym class="acronym">ISA</acronym> est l'ancien bus des PC compatibles IBM alors
que <acronym class="acronym">PCI</acronym> est le nouveau bus, plus rapide, d'Intel. Le bus
<acronym class="acronym">PCI</acronym> a été conçu pour ce qui est appelé de nos jours
<acronym class="acronym">PnP</acronym>. Ceci rend facile (comparé à ce qu'il faut faire pour le
bus <acronym class="acronym">ISA</acronym>) la découverte de l'affectation des ressources bus
<acronym class="acronym">PnP</acronym> aux périphériques matériels.</p><p>Pour le bus <acronym class="acronym">ISA</acronym>, il existait un problème réel
avec l'implémentation de <acronym class="acronym">PnP</acronym> car personne n'avait en
tête <acronym class="acronym">PnP</acronym> lorsque ce bus a été conçu et il existe
encore moins d'adresses d'entrées/sorties disponibles pour
<acronym class="acronym">PnP</acronym> pour envoyer des informations de configuration à
un périphérique physique. Du coup, la façon dont <acronym class="acronym">PnP</acronym>
a été réalisé pour le bus <acronym class="acronym">ISA</acronym> est très complexe. Des
livres entiers ont été écrits à ce sujet. Voir notamment <a class="link" href="#pnp_book">ce livre</a>. Entre autres choses, il requiert
que soit assigné par le programme <acronym class="acronym">PnP</acronym> à chaque
périphérique <acronym class="acronym">PnP</acronym> un point d'ancrage temporaire pour
que tout le monde puisse faire la configuration <acronym class="acronym">PnP</acronym>.
Assigner ces « <span class="quote">points d'ancrage</span> » est appelé
« <span class="quote">isolation</span> ». Voir <a class="xref" href="#isolation_" title="13.6. Isolation ISA">Section 13.6, « Isolation <acronym class="acronym">ISA</acronym> »</a> pour des
détails complexes.</p><p>Au fur et à mesure de la disparition du bus <acronym class="acronym">ISA</acronym>,
<acronym class="acronym">PnP</acronym> sera un peu plus facile. Il ne sera pas seulement plus
simple de savoir comment le <acronym class="acronym">BIOS</acronym> a configuré le matériel mais
il y aura aussi
moins de conflits, le <acronym class="acronym">PCI</acronym> pouvant partager des interruptions.
Il y aura toujours besoin de faire correspondre un pilote de périphérique à un
matériel et il y aura toujours besoin de configurer les périphériques ajoutés
lors du lancement du PC. Le sérieux problème des quelques périphériques non
supportés par Linux restera présent.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="how_linux_pnps" />3.5. Comment Linux gère-t-il le
<acronym class="acronym">PnP</acronym></h3></div></div></div><p>Linux a eu de sérieux problèmes dans le passé pour la gestion de
<acronym class="acronym">PnP</acronym> mais la plupart de ces problèmes sont maintenant résolus
(vers mi-2004). Linux est parvenu d'un système non <acronym class="acronym">PnP</acronym> à un
système qui peut être <acronym class="acronym">PnP</acronym> si le noyau est compilé avec
certaines options. Le BIOS peut affecter des IRQ mais Linux peut aussi
affecter certains d'entre eux ou même les refaire ce que le BIOS a déjà
fait. La partie de configuration de <acronym class="acronym">ACPI</acronym> (<span class="foreignphrase"><em class="foreignphrase">Advance
Configuration and Power Interface</em></span>) est conçu pour faciliter
la propre configuration des systèmes d'exploitation. Linux peut utiliser
l'ACPI si le noyau a été compilé avec son support.</p><p>Dans Linux, il est traditionnel qu'un pilote de périphérique fasse
sa propre configuration de bas niveau. C'était difficile jusqu'au moment
où le noyau Linux a fourni le logiciel que les pilotes peuvent utiliser
pour se faciliter le travail. Aujourd'hui (2005), c'est arrivé à un point où
le pilote peut simplement appelé la fonction pci_enable_device() du noyau
et où le périphérique se voit configuré en étant activé et en récupérant
une <acronym class="acronym">IRQ</acronym> (si nécessaire) et les adresses affectées au
périphérique. Cette affectation pourrait être ce qui avait été affecté
auparavant par le <acronym class="acronym">BIOS</acronym> ou ce que le noyau avait
réservé quand le périphérique PCI ou ISAPNP a été détecté par le noyau.
Il existe même une option ACPI pour que le noyau affecte toutes les IRQ
des périphériques lors du démarrage.</p><p>Donc aujourd'hui, d'une certaine façon, les pilotes font toujours la
configuration mais ils peuvent la faire en demandant simplement au noyau de
s'en charger (et Linux pourrait ne pas avoir besoin de faire grand chose
car il est quelque fois capable d'utiliser ce qui a déjà été configuré par
le BIOS ou par lui-même). Donc, c'est vraiment la partie du noyau, hors du
pilote, qui fait la grande partie de configuration. Du coup, il pourrait
être correct d'appeler Linux un système d'exploitation PnP, au moins pour
les architectures communes.</p><p>Ensuite, lorsqu'un pilote découvre son périphérique, il demande à
connaître les adresses et IRQ affectés (par le <acronym class="acronym">BIOS</acronym> ou
par Linux) et, habituellement, les accepte simplement. Mais, si le pilote le
souhaite, il peut essayer de modifier les adresses en utilisant les fonctions
fournies par le noyau. Cependant, le noyau n'acceptera pas d'adresses entrant
en conflit avec d'autres périphériques ou des adresses que le matériel ne peut
pas supporter. Quand le PC démarre, vous pouvez noter les messages à l'écran
montrant que certains pilotes de périphériques Linux ont trouvé leurs
périphériques matériels et quels sont leurs IRQ et adresses.</p><p>Donc, le noyau fournit des fonctions (programmes) que les pilotes
peuvent utiliser pour trouver si leur périphérique est présent, la façon
dont il est configuré et les fonctions qui permettent de modifier la
configuration si nécessaire. Le noyau 2.2 pouvait faire ceci pour
le bus <acronym class="acronym">PCI</acronym> seulement mais le noyau 2.4 contient cette
fonctionnalité pour les bus ISA et PCI (à condition que les options PnP et
PCI appropriés ont été sélectionnées avant la compilation du noyau). Le
noyau 2.6 est arrivé avec une meilleure utilisation de l'ACPI. Ceci ne
garantie en rien que tous les pilotes utilisent complètement et correctement
ces fonctionnalités. Les périphériques propriétaires que le BIOS ne connait
pas pourraient ne pas être configurés tant qu'une configuration manuelle ne
soit effectuée.</p><p>De plus, le noyau tente d'éviter les conflits d'adresses en ne
permettant pas à deux périphériques d'utiliser les même ressources bus
en même temps. Au début, ce n'était valable que pour les IRQ et les DMA
mais, maintenant, cela s'adresse aussi aux adresses.</p><p>Si vous avez un ancien bus ISA, le programme isapnp doit être exécuté au
démarrage pour trouver et configurer les périphériques PnP sur le bus ISA.
Regardez les messages avec « dmesg ».</p><p>Pour voir quelle aide le noyau peut apporter aux pilotes de
périphériques, consultez le répertoire <code class="filename">/usr/…/…/Documentation</code> où un des
« <span class="quote">…</span> » contient le mot « <span class="quote">kernel-doc</span> » ou quelque
chose
d'approchant. Attention : cette documentation a tendance à ne plus être à
jour pour avoir les dernières informations donc vous aurez besoin de lire les
messages des listes de diffusion des développeurs du noyau et peut-être aussi
de lire le code source et les commentaires qu'ils ont écrits. Dans le répertoire
de la documentation du noyau, voir pci.txt (« <span class="quote">How to Write Linux
<acronym class="acronym">PCI</acronym>
Drivers</span> », c'est-à-dire « <span class="quote">Comment écrire des pilotes
<acronym class="acronym">PCI</acronym> pour
Linux</span> ») ainsi que le fichier
<code class="filename">/usr/include/linux/pci.h</code>. Si vous êtes un gourou des
pilotes et si vous connaissez la programmation en C, ces fichiers sont écrits
d'une telle façon qu'il ne vont pas vous permettre d'écrire un pilote. Mais cela
vous donnera une idée des fonctions type <acronym class="acronym">PnP</acronym> disponibles pour
les pilotes.</p><p>Pour le noyau 2.4, voir <code class="filename">isapnp.txt</code>. Pour le noyau
2.6, <code class="filename">isapnp.txt</code> est remplacé par
<code class="filename">pnp.txt</code> qui est totalement différent et gère en plus le bus
PCI. Voir aussi le livre d'O'Reilly : Linux Device Drivers, 3è
édition, 2005. Le texte complet est disponible sur Internet.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N106C6" />3.6. Problèmes avec Linux <acronym class="acronym">PnP</acronym></h3></div></div></div><p>Il existe un certain nombre d'autres points qu'un
système d'exploitation <acronym class="acronym">PnP</acronym> devrait mieux gérer :
<div class="itemizedlist"><ul><li><p>Allouer des ressources bus quand il en existe peu par
    une réallocation des ressources si nécessaire ;</p></li><li><p>Gérer le choix d'un pilote lorsqu'il en existe plus d'un
    par périphérique ;</p></li></ul></div>
</p><p>Comme chaque pilote s'occupe de lui mais pas des autres, un pilote
pourrait récupérer les ressources bus nécessaires à d'autres périphériques (et
non encore alloués à ceux-ci par le noyau). Donc un noyau Linux
<acronym class="acronym">PnP</acronym> plus
perfectionné serait bien mieux, un noyau qui pourrait s'occuper de l'allocation
une fois toutes les requêtes envoyées. Une alternative serait d'essayer
de réallouer les ressources déjà affectées quand un pilote n'obtient pas toutes
les ressources qu'il a demandées.</p><p>Le problème de la « <span class="quote">rareté des ressources bus</span> » devient de
moins en moins
réel pour deux raisons : la première est que le bus
<acronym class="acronym">PCI</acronym>
est en train de remplacer le bus <acronym class="acronym">ISA</acronym>. Le bus
<acronym class="acronym">PCI</acronym> n'a pas ce type de problème pour les
<acronym class="acronym">IRQ</acronym> car celles-ci peuvent être partagées (bien que ce
partage rende le système un peu moins efficace). De plus, le
<acronym class="acronym">PCI</acronym>
n'utilise pas les ressources <acronym class="acronym">DMA</acronym> (bien qu'il dispose d'un
équivalent sans avoir besoin des ressources).</p><p>La deuxième raison est que plus d'espace d'adresses est disponible pour
les entrées/sorties des périphériques. Alors que l'espace d'adresses
conventionnel du bus <acronym class="acronym">ISA</acronym> était limité à 64 Ko, le bus
<acronym class="acronym">PCI</acronym> dispose de 4 Go. Comme plus de périphériques
physiques utilisent les adresses en mémoire principale au lieu de l'espace
d'adresses des entrées/sorties, il existe toujours un peu de place disponible,
y compris sur le bus <acronym class="acronym">ISA</acronym>. Sur les PC 32
bits, il y a un espace d'adressage de 4 Go en mémoire principale et la
plupart de ces ressources bus est disponible pour les entrées/sorties des
périphériques (à moins que vous ayez 4 Go de mémoire principale
installée).</p><p>Il y a eu au moins une tentative pour faire de Linux un vrai système
d'exploitation PnP. Voir <a class="ulink" href="http://www.astarte.free-online.co.uk" target="_top">http://www.astarte.free-online.co.uk</a>.
Bien que développé dès 1998, elle n'a jamais été intégrée au noyau (mais aurait
certainement dûe l'être).</p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="conf_pnp_bios" />4. Configurer un <acronym class="acronym">BIOS</acronym>
<acronym class="acronym">PnP</acronym></h2></div></div></div><p>Lorsque l'ordinateur est démarré, le <acronym class="acronym">BIOS</acronym> est lancé
avant que le système d'exploitation ne soit chargé. Les <acronym class="acronym">BIOS</acronym>
modernes sont <acronym class="acronym">PnP</acronym> et peuvent configurer la plupart des
périphériques <acronym class="acronym">PnP</acronym>. Quelques anciens <acronym class="acronym">BIOS</acronym>
<acronym class="acronym">PCI</acronym> vont seulement configurer le bus <acronym class="acronym">PCI</acronym>.
Voici quelques choix qui pourraient exister dans le menu <acronym class="acronym">CMOS</acronym>
de votre <acronym class="acronym">BIOS</acronym> :
<div class="itemizedlist"><ul><li><p><a class="xref" href="#bios_pnp_os" title="4.1. Avez-vous un système d'exploitation PnP ?">Section 4.1, « Avez-vous un système d'exploitation
<acronym class="acronym">PnP</acronym> ? »</a> ;</p></li><li><p><a class="xref" href="#escd_resources" title="4.2. Affecter les ressources par le BIOS ?">Section 4.2, « Affecter les ressources par le
<acronym class="acronym">BIOS</acronym> ? »</a> ;</p></li><li><p><a class="xref" href="#escd_reset" title="4.3. Réinitialiser la configuration">Section 4.3, « Réinitialiser la configuration »</a>.</p></li></ul></div>
</p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="bios_pnp_os" />4.1. Avez-vous un système d'exploitation
<acronym class="acronym">PnP</acronym> ?</h3></div></div></div><p>Quelle que soit votre réponse au <acronym class="acronym">BIOS</acronym>, le
<acronym class="acronym">BIOS</acronym> <acronym class="acronym">PnP</acronym> utilisera
<acronym class="acronym">PnP</acronym> pour paramétrer le disque dur, le lecteur de
disquette, la carte vidéo et le clavier, afin de permettre au système de
démarrer. Si vous dites avoir un système d'exploitation
<acronym class="acronym">PnP</acronym>, il laissera la fin de la configuration au
système d'exploitation (ou aux pilotes de périphériques). Si vous dites
ne pas avoir de système d'exploitation <acronym class="acronym">PnP</acronym>, alors le
<acronym class="acronym">BIOS</acronym> devra tout configurer.
</p><p>Comment répondre à cette question de votre <acronym class="acronym">BIOS</acronym> ?
Si vous avez au moins un noyau 2.4, vous pourriez répondre ce que vous voulez et
Linux fonctionnera habituellement correctement. Même si vous avez Windows
2000 ou XP sur le même PC, cela devrait fonctionner de toute façon tout
simplement parce que Windows et Linux sont tous les deux à priori des
systèmes d'exploitation <acronym class="acronym">PnP</acronym> et que si le système
d'exploitation est <acronym class="acronym">PnP</acronym>, il devrait être capable de gérer le
cas où le <acronym class="acronym">BIOS</acronym> a tout configuré lui-même (si vous avez
répondu que le système d'exploitation n'est pas <acronym class="acronym">PnP</acronym>). Mais,
je continue à suggèrer de répondre qu'il n'est pas <acronym class="acronym">PnP</acronym> sauf
si une raison valable vous oblige à faire autrement.</p><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="prior_2.4" />4.1.1. Linux avant le noyau 2.4</h4></div></div></div><p>La réponse n'est pas souvent claire dans ce cas. Si isapnp était utilisé
par Linux, alors Linux fera la configuration et il était indiqué qu'il est
mieux de dire qu'il s'agit d'un système d'exploitation <acronym class="acronym">PnP</acronym>.
La raison pour laquelle isapnp aurait des problèmes en présence de
périphériques déjà configurés par le <acronym class="acronym">BIOS</acronym> n'est pas claire
mais de tels problèmes arrivent quelquefois et sont corrigés en stoppant la
configuration du <acronym class="acronym">BIOS</acronym> (en répondant oui, c'est un système
d'exploitation <acronym class="acronym">PnP</acronym>). Il existe quelques cas où dire non
résolvait un problème. Donc, si isapnp n'est pas utilisé, non est généralement
mieux. Les pilotes Linux de périphériques <acronym class="acronym">PCI</acronym> devraient
configurer correctement ces périphériques. Mais pour le cas où les périphériques
<acronym class="acronym">PCI</acronym> pilotés par des pilotes non <acronym class="acronym">PCI</acronym>, alors
vous pourriez dire que le système d'exploitation n'est pas
<acronym class="acronym">PnP</acronym> pour obtenir du <acronym class="acronym">BIOS</acronym> qu'il les
configure directement.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N1078E" />4.1.2. Windows 2000 et XP</h4></div></div></div><p>Si vous utilisez aussi des systèmes d'exploitation Windows sur le même PC,
vous pourriez dire que vous n'avez pas un système d'exploitation
<acronym class="acronym">PnP</acronym>. C'est ce
que MS vous suggère de faire. Peut-être que MS souhaite que le
<acronym class="acronym">BIOS</acronym> fasse un
meilleur travail pour la configuration que Windows ne le fera. Ceci est sensé
parce que le <acronym class="acronym">BIOS</acronym> devrait être conçu pour les particularités
spécifiques de la
carte mère, et tout spécialement de nos jours où beaucoup de périphériques sont
intégrés à celle-ci. Dire non devrait aussi être bon pour les noyaux Linux
2.4 et ultérieurs. Mais pour les noyaux précédents, ce n'est pas si clair (voir
la section ci-dessous). Donc, si vous avez des problèmes avec Linux, vous
pourriez essayer de dire que vous avez un système d'exploitation Linux mais
ceci va contre ce que raconte MS (mais fonctionnera probablement bien de toute
façon).</p><p>Lorsque le <acronym class="acronym">BIOS</acronym> configure un périphérique différemment
de ce qui est
stocké dans la base de registres de Windows, celui-ci vous dira qu'il a
découvert un nouveau matériel. Ce qu'il est réellement en train de faire est de
trouver l'ancien matériel qui a été configuré différemment. De toute façon, il
enregistre la configuration que le <acronym class="acronym">BIOS</acronym> a utilisée dans ses
registres et le
périphérique devrait bien fonctionner à partir de ce moment.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N107A4" />4.1.3. MS Windows 95, 98 (et Me ?)</h4></div></div></div><p>Pour Windows9x, MS suggère de dire au <acronym class="acronym">BIOS</acronym> que vous
avez un système d'exploitation <acronym class="acronym">PnP</acronym> (l'opposé complet du cas
pour Windows 2000 et XP). Ceci devrait être bon pour Linux si vous disposez
d'un noyau 2.4 ou ultérieur. Mais si vous avez un noyau Linux précédent le
2.4, alors il est mieux pour Linux de dire qu'il ne s'agit pas d'un système
d'exploitation <acronym class="acronym">PnP</acronym>. Une façon de résoudre ce dilemme est de
le configurer pour le système d'exploitation que vous utilisez le plus
fréquemment. Ensuite, au démarrage de l'autre système d'exploitation, modifiez
manuellement la configuration du <acronym class="acronym">BIOS</acronym>. C'est très ennuyant
mais c'est faisable si vous n'utilisez pratiquement jamais l'autre système
d'exploitation. Sinon, il existe de meilleurs façons de résoudre ce dilemme.
</p><p>La deuxième façon de résoudre ce dilemme est de faire en sorte que Linux
configure toutes les ressources. Voir <a class="xref" href="#prior_2.4" title="4.1.1. Linux avant le noyau 2.4">Section 4.1.1, « Linux avant le noyau 2.4 »</a>. Ensuite,
vous dites au <acronym class="acronym">BIOS</acronym> qu'il s'agit d'un système d'exploitation
<acronym class="acronym">PnP</acronym>.</p><p>La troisième façon de résoudre ce dilemme est de dire au
<acronym class="acronym">BIOS</acronym> qu'il ne
s'agit pas d'un système d'exploitation <acronym class="acronym">PnP</acronym>. Ceci va à
l'encontre de ce que dit
MS mais il est possible d'obtenir un bon fonctionnement de MS Windows9x si vous
comprenez ce que vous faites (et pourquoi). Si vous dites au
<acronym class="acronym">BIOS</acronym> qu'il ne
s'agit pas d'un système d'exploitation <acronym class="acronym">PnP</acronym>, MS Windows ne
devrait-il pas
détecter la façon dont le <acronym class="acronym">BIOS</acronym> a configuré les périphériques
et modifier cela
s'il n'aime pas ce que le <acronym class="acronym">BIOS</acronym> a fait ? Cela devrait,
mais malheureusement,
cela ne semble pas fonctionner de cette façon.</p><p>Ce que Windows 9x semble faire lorsqu'il trouve un matériel déjà
configuré par le <acronym class="acronym">BIOS</acronym> est de le laisser seul et de ne pas le
reconfigurer. Maintenant, Windows 9x garde une trace de la configuration des
ressources bus dans sa base de registres. Si la configuration du
<acronym class="acronym">BIOS</acronym> est différent, il devrait soit corriger ce qui se
trouve dans sa base de registres soit tout reconfigurer suivant les indications
de cette même base. Mauvaise nouvelle : il semble ne rien faire et pense
que la configuration actuelle est la même que celle de la base de registres
alors qu'en fait elles sont différentes.</p><p>Mais si la base de registre contient une configuration des ressources bus
identique à celle du <acronym class="acronym">BIOS</acronym>, alors tout fonctionnera bien.  Un
périphérique
fonctionnera bien si le <acronym class="acronym">BIOS</acronym> l'a configuré de la même façon
que ce qui est
enregistré dans la base de registres. Donc, le moyen de faire fonctionner
correctement MS Windows est d'obtenir que la base de registres soit synchronisée
avec la configuration du <acronym class="acronym">BIOS</acronym>. Comme mentionné précédemment,
le <acronym class="acronym">BIOS</acronym> configure
les éléments suivant son <acronym class="acronym">ESCD</acronym> (qui est quelque chose comme la
base de registres
mais pour le <acronym class="acronym">BIOS</acronym>). Voir <a class="xref" href="#escd_" title="5.4.2. La base de données ESCD du BIOS">Section 5.4.2, « La base de données <acronym class="acronym">ESCD</acronym> du
<acronym class="acronym">BIOS</acronym> »</a>. Donc, nous
avons besoin
d'obtenir la synchronisation des registres avec l'<acronym class="acronym">ESCD</acronym> du
<acronym class="acronym">BIOS</acronym> pour que la base
de registres et <acronym class="acronym">ESCD</acronym> contiennent la même configuration. Dans
certains cas, ces
deux arrivent à être synchrones et vous n'avez pas besoin de faire quoi que ce
soit.</p><p>Une question à laquelle vous pourriez penser est : comment
l'<acronym class="acronym">ESCD</acronym> du
<acronym class="acronym">BIOS</acronym> et la base de registres Windows peuvent-ils se
désynchroniser ? Voici
un scénario. Vous installez Windows avec le <acronym class="acronym">BIOS</acronym> configuré
pour un système
d'exploitation <acronym class="acronym">PnP</acronym>. Alors, Windows configure la plupart des
éléments et
sauvegarde sa configuration dans sa base de registres. Puis, plus tard, vous
changez la configuration du <acronym class="acronym">BIOS</acronym> en précisant qu'il ne s'agit
pas d'un système
d'exploitation <acronym class="acronym">PnP</acronym>. Ensuite, après un redémarrage, le
<acronym class="acronym">BIOS</acronym> configure tout et il
ne fait pas exactement ce que Windows a fait. Donc, la configuration actuelle
du matériel et ce que Windows dispose dans sa base de registres sont maintenant
différents.</p><p>Une façon d'essayer d'obtenir que la base de registres et l'ESCD
disposent des mêmes informations est d'installer (ou de réinstaller) Windows
lorsque le <acronym class="acronym">BIOS</acronym> est configuré pour un système d'exploitation
non
<acronym class="acronym">PnP</acronym>. De cette façon, Windows disposera du matériel configuré
par le <acronym class="acronym">BIOS</acronym>. Si cette configuration est faite sans conflit,
Windows n'en changera pas et la sauvegardera dans sa base de registres. Et dans
ce cas, l'<acronym class="acronym">ESCD</acronym> et la base de registres seront
synchronisés.</p><p>

Une autre méthode est de supprimer les périphériques causant problèmes à 
Windows en cliquant « <span class="quote">Supprimer</span> » dans le gestionnaire des 
périphériques. Puis redémarrez avec « <span class="quote">OS non 
<acronym class="acronym">PnP</acronym></span> » (enregistré dans la mémoire 
<acronym class="acronym">CMOS</acronym> du <acronym class="acronym">BIOS</acronym> lorsque vous 
redémarrez). Windows va alors réinstaller les périphériques, en 
utilisant, on l'espère, les ressources bus configurées par le 
<acronym class="acronym">BIOS</acronym>. Faites attention que Windows vous demandera 
d'insérer le CD d'installation de Windows car il peut ne pas trouver les 
fichiers du pilote de périphériques, même s'il sont bien là. Un 
contournement est de sélectionner « <span class="quote">skip file</span> » ce qui 
évitera l'installation du fichier à partir du CD. Si le fichier est 
toujours sur le disque dur, avec un peu de chance, le pilote et tout ira 
bien, même si le programme d'installation de Windows vous a demandé de 
l'installer à partir du CD (ce que vous avez passé).

</p><p>Comme test, j'ai « <span class="quote">supprimé</span> » une carte réseau qui utilisait un
pilote
compatible Novell. Au redémarrage, Windows l'a réinstallé avec le Réseaux
Microsoft plutôt qu'avec Novell. Ceci signifie que le client Novell a dû être
réinstallé, un gros travail inutile. Donc, il serait mieux de ne pas continuer
avec Windows 95/98 mais laisser Linux configurer les ressources bus.</p><p>Lors de l'utilisation d'un PC Window-Linux (<span class="foreignphrase"><em class="foreignphrase">dual
boot</em></span>), vous pouvez noter un changement dans la façon dont le
<acronym class="acronym">BIOS</acronym> configure à cause de Windows9x (et des autres versions de
Windows ??) en modifiant l'<acronym class="acronym">ESCD</acronym>. Il fait cela seulement
si vous « <span class="quote">forcez</span> » une configuration ou une installation d'un périphérique
propriétaire. Voir <a class="xref" href="#W9x_ESCD" title="5.4.3. Utiliser Windows pour configurer l'ESCD">Section 5.4.3, « Utiliser Windows pour configurer l'ESCD »</a>. Les pilotes de périphériques
réalisant la configuration pourraient modifier ce que le <acronym class="acronym">BIOS</acronym>
a fait comme le font les outils <acronym class="acronym">PCI</acronym> et isapnp.</p></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="escd_resources" />4.2. Affecter les ressources par le
<acronym class="acronym">BIOS</acronym> ?</h3></div></div></div><p>Les <acronym class="acronym">BIOS</acronym> modernes vous permettent d'allouer
manuellement des ressources, principalement des <acronym class="acronym">IRQ</acronym>. Il
existe normalement une option pour configurer l'allocation à « <span class="quote">auto</span> »
de façon à ce que le <acronym class="acronym">BIOS</acronym> décide de l'allocation des
ressources. « <span class="quote">Auto</span> » est souvent un bon choix sauf si vous avez
d'anciennes cartes <acronym class="acronym">ISA</acronym> propriétaires non
<acronym class="acronym">PnP</acronym>.</p><p>Si vous avez de telles cartes non <acronym class="acronym">PnP</acronym>, alors il
peut être important de réserver les ressources (telles que les
<acronym class="acronym">IRQ</acronym>) pour celles-ci dans le <acronym class="acronym">BIOS</acronym>.
Sinon, le <acronym class="acronym">BIOS</acronym> pourrait utiliser ces ressources pour
d'autres périphériques et créer ainsi des conflits. Une exception concerne
quelques périphériques propriétaires communs, comme les ports parallèle et
séries, les disques durs. Le <acronym class="acronym">BIOS</acronym> pourrait les trouver
(jetez un œil à l'écran au démarrage) pour que vous n'ayez pas besoin
de réserver les ressources pour eux. Si vous avez utilisé Windows sur votre
PC, Windows pourrait déjà avoir renseigné le <acronym class="acronym">BIOS</acronym> en
utilisant l'outil ICU (ou un outil identique) sous Windows.</p><p>Pour le <acronym class="acronym">PCI</acronym>, le <acronym class="acronym">BIOS</acronym> devrait aussi
vous permettre d'affecter les <acronym class="acronym">IRQ</acronym> aux
emplacements de cartes 1, 2, 3, 4, et cætera. Si vous le faites, vous devez connaître
les emplacements où se trouvent les cartes. En fait, chaque emplacement dispose
de quatre <acronym class="acronym">IRQ</acronym> <acronym class="acronym">PCI</acronym> : A, B, C et D. Si
le menu du <acronym class="acronym">BIOS</acronym> ne vous dit pas
laquelle (A, B, C, D) est affectée à un numéro d'IRQ, il est probable qu'il
affecte seulement le numéro d'<acronym class="acronym">IRQ</acronym> à l'<acronym class="acronym">IRQ</acronym>
<acronym class="acronym">PCI</acronym> A. Mais, beaucoup de cartes
utilisent seulement l'<acronym class="acronym">IRQ</acronym> A donc il s'agit surtout d'affecter
une <acronym class="acronym">IRQ</acronym> à un emplacement. Voir les <a class="link" href="#pci_int" title="8. Interruptions PCI">interruptions PCI</a>.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="escd_reset" />4.3. Réinitialiser la configuration</h3></div></div></div><p>C'est aussi un peu risqué. Ceci va écraser les données du
<acronym class="acronym">BIOS</acronym> contenues dans l'<acronym class="acronym">ESCD</acronym> indiquant la
façon dont vos périphériques <acronym class="acronym">PnP</acronym> ont été configurés et
comment les périphériques non <acronym class="acronym">PnP</acronym> ont été configurés
manuellement. Ne faites jamais ceci à moins que vous ne soyez convaincu que la
base de données est mauvaise et a besoin d'être reconstruite. Il était indiqué
quelque part que vous deviez faire ceci seulement lorsque vous n'arrivez plus
à démarrer. Si le <acronym class="acronym">BIOS</acronym> perd les données sur les périphériques
<acronym class="acronym">ISA</acronym> non <acronym class="acronym">PnP</acronym>, alors vous devrez relancer
ICA une nouvelle fois sous DOS/Windows pour ré-enregistrer les données.</p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="N108C7" />5. Gérer les cartes <acronym class="acronym">PnP</acronym></h2></div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N108CC" />5.1. Introduction à la gestion des périphériques
<acronym class="acronym">PnP</acronym></h3></div></div></div><p>De nos jours, pratiquement toutes les nouvelles cartes internes sont
Plug-and-Play. Du coup, la configuration des ressources bus devraient être dans
la plupart des cas entièrement automatique. Si un périphérique ne fonctionne pas,
vérifiez s'il a été détecté, par exemple en redémarrant. Si le pilote de
périphérique ne peut pas configurer les ressources, alors probablement une ou
plus des méthodes du 2.6 le feront :

<div class="itemizedlist"><ul><li><p><a class="xref" href="#dev_d_conf" title="5.2. Configuration du pilote de périphérique, réservation des ressources">Section 5.2, « Configuration du pilote de périphérique,
réservation des ressources »</a> ;</p></li><li><p><a class="xref" href="#sys_" title="5.3. /sys : interface de configuration pour l'utilisateur">Section 5.3, « /sys : interface de configuration pour
l'utilisateur »</a> le noyau 2.6+ (pas encore pour le
<acronym class="acronym">PCI</acronym>
   et quelques autres sévères limitations) ;</p></li><li><p><a class="xref" href="#bios_conf" title="5.4. Configuration du BIOS">Section 5.4, « Configuration du <acronym class="acronym">BIOS</acronym> »</a> (pour le bus
    <acronym class="acronym">PCI</acronym>, vous avez seulement besoin d'un
    <acronym class="acronym">BIOS</acronym> <acronym class="acronym">PCI</acronym>, sinon vous avez besoin
    d'un <acronym class="acronym">BIOS</acronym>
<acronym class="acronym">PnP</acronym>) ;</p></li><li><p><a class="xref" href="#disable_pnp" title="5.5. ISA seulement : Désactiver PnP ?">Section 5.5, « <acronym class="acronym">ISA</acronym> seulement :
Désactiver <acronym class="acronym">PnP</acronym> ? »</a> par des cavaliers ou avec un
    logiciel DOS/Windows (mais la plupart des cartes ne le font pas) ;
    </p></li><li><p><a class="xref" href="#isapnp_" title="5.6. Bus ISA : Isapnp (outil faisant partie d'isapnptools)">Section 5.6, « Bus <acronym class="acronym">ISA</acronym> : Isapnp (outil
faisant partie d'isapnptools) »</a> est un programme que vous pouvez
    toujours utiliser pour configurer les périphériques <acronym class="acronym">PnP</acronym>
    du bus <acronym class="acronym">ISA</acronym> (seulement),</p></li><li><p><a class="xref" href="#pciutils_" title="5.7. Les utilitaires PCI">Section 5.7, « Les utilitaires <acronym class="acronym">PCI</acronym> »</a> permet de configurer le bus
    <acronym class="acronym">PCI</acronym> mais le pilote de périphérique devrait le
    gérer ;
    </p></li><li><p><a class="xref" href="#windows_conf" title="5.8. Configuration de Windows">Section 5.8, « Configuration de Windows »</a> et alors vous démarrez Linux à
    partir de Windows/DOS. A utiliser en dernier recours.</p></li></ul></div>
</p><p>N'importe lequel configurera les ressources bus au niveau matériel mais
seul le premier (voire le second) indiquera au pilote ce qui a été fait. La façon
dont le pilote est informé dépend du pilote. Vous pouvez avoir besoin de faire
quelque chose pour l'informer. Voir <a class="xref" href="#tell_driver_config" title="6. Indiquer au pilote la configuration ??">Section 6, « Indiquer au pilote la
configuration ?? »</a>.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="dev_d_conf" />5.2. Configuration du pilote de périphérique,
réservation des ressources</h3></div></div></div><p>Les pilotes de périphériques (avec l'aide de fonctions du
noyau) peuvent être écrits pour utiliser des méthodes <acronym class="acronym">PnP</acronym>
pour configurer les ressources bus du matériel mais seulement pour le
périphérique qu'ils contrôlent. Mais beaucoup de pilotes de périphériques
acceptent directement ce que le BIOS ou Linux a configuré et utilise le code
fourni par le noyau pour découvrir comme ce périphérique a été configuré.
Comme le pilote a vérifié la configuration et la certainement reconfiguré,
il connaît de façon évidente la configuration et il n'y a aucun besoin de lui
donner cette information. C'est dont la façon la plus simple de le faire car
vous n'avez rien à faire si le pilote fait tout.</p><p>Si vous avez un matériel datant d'avant l'<acronym class="acronym">ISA</acronym>
<acronym class="acronym">PnP</acronym>, le logiciel <acronym class="acronym">PnP</acronym> Linux
pourrait ne pas le savoir et pourrait ne pas connaître les ressources
bus qu'il réclame. Donc, il pourrait allouer de façon erronée des
ressources dont cet ancien matériel a besoin à un autre périphérique. Le
résultat est un conflit de ressources mais il existe un moyen de
l'éviter. Vous pouvez réserver les ressources dont cette ancienne carte
<acronym class="acronym">ISA</acronym> a besoin en configurant le <acronym class="acronym">BIOS</acronym>
au démarrage (habituellement), au module isa-pnp ou au noyau (si le support de
<acronym class="acronym">PnP</acronym> est intégré dans le noyau). Par exemple, pour
réserver l'<acronym class="acronym">IRQ</acronym> 5, donnez cet argument au module
isa-pnp (ou au noyau) : isapnp_reserve_irq=5. Voir le <a class="ulink" href="http://www.traduc.org/docs/howto/lecture/BootPrompt-HOWTO.html" target="_top">Guide
pratique sur l'invite de démarrage
(<span class="foreignphrase"><em class="foreignphrase">BootPrompt-HOWTO</em></span>)</a>. Au lieu de
..._irq, il existe aussi _io, _dma et _mem.</p><p>Pour les périphériques <acronym class="acronym">PCI</acronym>, la plupart des pilotes
configureront <acronym class="acronym">PnP</acronym>. Malheureusement, un pilote peut récupérer
des ressources bus nécessaires à d'autres périphériques (mais non alloués à eux
par le noyau). Donc, un noyau Linux <acronym class="acronym">PnP</acronym> plus
perfectionné serait meilleur là où le noyau fait l'allocation pour toutes les
demandes envoyées. Voir <a class="xref" href="#how_linux_pnps" title="3.5. Comment Linux gère-t-il le PnP">Section 3.5, « Comment Linux gère-t-il le
<acronym class="acronym">PnP</acronym> »</a>.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="sys_" />5.3. /sys : interface de configuration pour
l'utilisateur</h3></div></div></div><p>Depuis le noyau 2.6, il existe une nouvelle façon pour que l'utilisateur
configure les ressources grâce au répertoire /sys. Mais, jusqu'à août 2004, il
ne peut pas être utilisé pour une configuration dans la plupart des cas. Voir
<a class="xref" href="#sys_dir" title="7.6. Le répertoire /sys">Section 7.6, « Le répertoire /sys »</a>.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="bios_conf" />5.4. Configuration du <acronym class="acronym">BIOS</acronym></h3></div></div></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N1095C" />5.4.1. Introduction à l'utilisation de la configuration
<acronym class="acronym">PnP</acronym> faite par le <acronym class="acronym">BIOS</acronym></h4></div></div></div><p>Si vous avez un <acronym class="acronym">BIOS</acronym> <acronym class="acronym">PnP</acronym>, il peut
configurer le matériel. Si le pilote ne peut pas le faire, le
<acronym class="acronym">BIOS</acronym> le peut probablement. Ceci veut dire que votre
<acronym class="acronym">BIOS</acronym> lit les besoins en ressources de tous les périphériques
et les configure (en leur allouant les ressources bus). C'est un substitut pour
l'OS <acronym class="acronym">PnP</acronym> sauf que le <acronym class="acronym">BIOS</acronym> ne peut faire
correspondre les pilotes avec leur périphériques et ne peut pas non plus
indiquer aux pilotes la façon dont il a configuré les périphériques. Il devrait
normalement utiliser la configuration enregistrée dans sa mémoire non volatile
(ESCD). S'il trouve un nouveau périphérique ou s'il existe un conflit, le
<acronym class="acronym">BIOS</acronym> devra effectuer les changements nécessaires et pourrait
ne pas utiliser la même configuration que celle de l'ESCD. Dans ce cas, il
devra mettre à jour l'<acronym class="acronym">ESCD</acronym> pour refléter la situation.</p><p>Votre <acronym class="acronym">BIOS</acronym> doit gérer une telle
configuration, mais il existe des cas où il ne le fait pas correctement ou pas
complètement. Le <acronym class="acronym">BIOS</acronym> a aussi besoin de savoir via le menu
CMOS si le système d'exploitation est <acronym class="acronym">PnP</acronym>. Alors que la
plupart des pilotes de périphériques seront capables de détecter automatiquement
ce que le <acronym class="acronym">BIOS</acronym> a fait, dans certains cas, vous aurez besoin
de le déterminer (ce qui n'est pas toujours facile). Voir <a class="xref" href="#current_config" title="7. Comment puis-je trouver les périphériques et comment sont-ils configurés ?">Section 7, « Comment puis-je trouver les périphériques et
comment sont-ils configurés ? »</a>. Un avantage possible à laisser le
<acronym class="acronym">BIOS</acronym> faire cette configuration est qu'il fait son boulot
avant de lancer Linux, donc c'est fait très tôt dans le processus de démarrage.
</p><p>La plupart des <acronym class="acronym">BIOS</acronym> créés après 1996 ?? peuvent
configurer les
ressources des bus <acronym class="acronym">PCI</acronym> et <acronym class="acronym">ISA</acronym>. Mais, il a
été dit que certains anciens <acronym class="acronym">BIOS</acronym>
peuvent uniquement s'occuper du <acronym class="acronym">PCI</acronym>. Pour essayer d'en savoir
plus sur votre
<acronym class="acronym">BIOS</acronym>, cherchez sur le web. Merci de ne pas me demander car je
n'ai pas toutes les données là-dessus. Les détails du <acronym class="acronym">BIOS</acronym>
que vous souhaitez connaître peuvent être difficiles à trouver. Certains
<acronym class="acronym">BIOS</acronym> pourraient avoir des capacités <acronym class="acronym">PnP</acronym>
minimales et attendre que le système d'exploitation fasse la configuration
<acronym class="acronym">PnP</acronym>. Si cela arrive, vous devrez soit trouver une autre
méthode soit essayer d'enregistrer les informations dans la base de données
<acronym class="acronym">ESCD</acronym>
si le <acronym class="acronym">BIOS</acronym> en a une. Voir la prochaine section.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="escd_" />5.4.2. La base de données <acronym class="acronym">ESCD</acronym> du
<acronym class="acronym">BIOS</acronym></h4></div></div></div><p>Le <acronym class="acronym">BIOS</acronym> maintient une base de données non volatile
contenant la configuration <acronym class="acronym">PnP</acronym> qu'il essaiera d'utiliser (si
vous aviez indiqué qu'il ne s'agit pas d'un système d'exploitation
<acronym class="acronym">PnP</acronym>). Elle s'appelle l'<acronym class="acronym">ESCD</acronym> (acronyme pour
Extended System
Configuration Data, soit Données pour une Configuration Étendue du Système).
Encore une fois, l'<acronym class="acronym">ESCD</acronym> est optionnel mais la plupart des
<acronym class="acronym">BIOS</acronym> <acronym class="acronym">PnP</acronym> en disposent.
L'<acronym class="acronym">ESCD</acronym> enregistre
non seulement la configuration des ressources pour les périphériques
<acronym class="acronym">PnP</acronym> mais aussi celle des périphériques non
<acronym class="acronym">PnP</acronym> (et les indique en tant que tels) pour éviter les
conflits. Les données de l'<acronym class="acronym">ESCD</acronym> sont habituellement
enregistrées sur un
composant et restent intactes lorsque la machine est arrêtée, mais c'est parfois
stocké sur un disque dur ??</p><p>L'<acronym class="acronym">ESCD</acronym> a pour but de conserver la dernière
configuration utilisée. Mais
comme Linux peut modifier la configuration des périphériques (en incluant
l'utilisateur avec les outils <acronym class="acronym">PCI</acronym> ou isapnp),
l'<acronym class="acronym">ESCD</acronym> ne sera pas au courant 
de cette modification et ne sauvegardera pas cette configuration. Un bon système
d'exploitation <acronym class="acronym">PnP</acronym> devrait mettre à jour l'ESCD, pour que les
informations qui y sont stockées puissent être utilisées par un système
d'exploitation non <acronym class="acronym">PnP</acronym> (comme un Linux standard). MS Windows
9x ne le fait que dans certains précis. Voir <a class="xref" href="#W9x_ESCD" title="5.4.3. Utiliser Windows pour configurer l'ESCD">Section 5.4.3, « Utiliser Windows pour configurer l'ESCD »</a>. À
partir du noyau 2.6, Linux est capable de modifier l'<acronym class="acronym">ESCD</acronym>
mais cela n'est pas encore utilisé (août 2004).</p><p>Pour utiliser ce qui a été enregistré dans l'ESCD, assurez-vous d'avoir
bien spécifié que l'OS n'est pas <acronym class="acronym">PnP</acronym> dans le
<acronym class="acronym">CMOS</acronym> du
<acronym class="acronym">BIOS</acronym>. Par la suite, à chaque fois que le
<acronym class="acronym">BIOS</acronym> démarre (avant que l'OS Linux ne soit chargé), il devrait
tout configurer de cette façon. Si le <acronym class="acronym">BIOS</acronym> détecte une
nouvelle carte <acronym class="acronym">PnP</acronym> non indiquée dans l'ESCD, alors il
allouera des ressources bus à la carte et mettra à jour l'ESCD. Il pourrait
même changer les ressources bus assignées aux cartes <acronym class="acronym">PnP</acronym>
existantes et modifier l'<acronym class="acronym">ESCD</acronym> de manière concordante.</p><p>Un programme vous permet de visualiser le contenu de l'ESCD. Il affiche
les <acronym class="acronym">IRQ</acronym>, les adresses d'entrées/sorties, et cætera mais les noms de
périphériques
manquent (seulement les numéros d'identifiant des périphériques EISA). Il est
disponible sur l'<a class="ulink" href="http://home.t-online.de/home/gunther.mayer/lsescd/" target="_top">index de
/home/gunther.mayer/lsescd</a>.</p><p>Si chaque périphérique sauvegardait sa dernière configuration au niveau
du matériel, la configuration matérielle ne serait pas nécessaire à chaque
démarrage du PC. Mais cela ne fonctionne pas ainsi. Donc, toutes les données de
l'<acronym class="acronym">ESCD</acronym> ont besoin d'être actualisées si vous utilisez le
<acronym class="acronym">BIOS</acronym>
pour <acronym class="acronym">PnP</acronym>. Il existe des <acronym class="acronym">BIOS</acronym> ne disposant
pas d'<acronym class="acronym">ESCD</acronym> mais ayant une mémoire non volatile pour stocker
des informations
concernant l'attribution des ressources bus aux cartes non
<acronym class="acronym">PnP</acronym>. Beaucoup de <acronym class="acronym">BIOS</acronym> disposent des deux.
</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="W9x_ESCD" />5.4.3. Utiliser Windows pour configurer l'ESCD</h4></div></div></div><p>Éventuellement, Linux pourrait initialiser l'ESCD. Depuis Linux 2.6, une
fonction du nouveau code pourrait le faire si le noyau a été compilé avec
PNPBIOS. Mais elle reste pour l'instant inutilisée.</p><p>Si le <acronym class="acronym">BIOS</acronym> ne configure pas l'<acronym class="acronym">ESCD</acronym>
de la façon
souhaitée (ou de la bonne façon), alors il serait bien de disposer d'un
utilitaire Linux pour le faire. Donc, vous pourriez vouloir
utiliser Windows (si vous l'avez sur le même PC) pour faire cela.</p><p>Il existe trois façons d'utiliser Windows pour tenter de modifier
l'ESCD. La première est d'utiliser l'utilitaire ICU pour DOS ou Windows 3.x. Il
devrait aussi fonctionner pour Windows 9x/2k ?? Une autre façon est 
de
configurer les périphériques manuellement (« <span class="quote">en forçant</span> ») sous
Windows 9x/2k de
façon à ce que Windows enregistre les informations dans
l'<acronym class="acronym">ESCD</acronym> lorsque Windows
est arrêté normalement. La troisième façon est possible uniquement pour les
périphériques non <acronym class="acronym">PnP</acronym>. Si Windows connaît quelque chose sur
eux, notamment quelles ressources bus ils utilisent, alors Windows enregistrera
cette information dans l'ESCD.</p><p>Si les périphériques <acronym class="acronym">PnP</acronym> sont configurés
automatiquement par Windows sans que l'utilisateur ait besoin de forcer cette
reconnaissance, alors ces paramétrages ne se trouveront probablement pas dans
l'ESCD. Bien sûr, Windows pourrait bien décider de lui-même de configurer ce qui
est enregistré dans l'ESCD, ce qui pourrait aboutir au même par coïncidence.
</p><p>Windows 9x est un système d'exploitation <acronym class="acronym">PnP</acronym> et
configure automatiquement via <acronym class="acronym">PnP</acronym> les périphériques. Il
maintient leur propre base de données <acronym class="acronym">PnP</acronym> dans la base de
registre (fichiers binaires de Windows). Beaucoup d'autres données de
configuration résident dans la base de registre en plus des ressources bus
<acronym class="acronym">PnP</acronym>. Il y a à la fois une configuration des ressources
<acronym class="acronym">PnP</acronym> actuelles et une autre (peut-être la même) enregistrée sur
le disque dur. Pour voir ça avec Windows 98, ou pour forcer l'enregistrement
des modifications, utilisez le gestionnaire des périphériques.</p><p>Dans Windows 98, il existe deux façons d'arriver au gestionnaire des
périphériques :
<div class="itemizedlist"><ul><li><p>1. Poste de travail --&gt; Panneau de configuration --&gt;
    Système --&gt; Gestionnaire de périphériques</p></li><li><p>2. (clic droit) Poste de travail --&gt; Propriétés --&gt;
    Gestionnaire de périphériques.</p></li></ul></div>
Ensuite, dans ce gestionnaire, vous sélectionnez un périphérique (parfois un
processus en plusieurs étapes s'il existe plusieurs périphériques de la même
classe). Ensuite, cliquez sur « <span class="quote">Propriétés</span> » puis
« <span class="quote">Ressources</span> ». Pour essayer de modifier la configuration des
ressources manuellement, décochez « <span class="quote">Utilisez la configuration
automatique</span> » puis cliquez sur « <span class="quote">Changer la configuration</span> ».
Maintenant, essayez de modifier les paramétrages. Il peut ne pas vous
laisser les modifier. S'il vous le permet, vous avez « <span class="quote">forcé</span> » un
changement. Du coup, un message devrait vous avertir que vous avez forcé cette
modification. Si vous souhaitez garder le paramétrage existant affiché par
Windows, mais que vous voulez forcer, alors vous devrez forcer un autre
changement et de nouveau forcer sa modification en sa valeur précédente.</p><p>Pour voir ce qui a été forcé sous Windows 98, regardez la liste des
matériels « <span class="quote">forcés</span> » : Démarrer --&gt; Programme --&gt; Accessoires
--&gt; Outils
système --&gt; Information système --&gt; Ressources matérielles --&gt; Matériel
forcé. Lorsque vous « <span class="quote">forcez</span> » un changement des ressources bus dans
Windows,
il devrait enregistrer votre modification dans l'<acronym class="acronym">ESCD</acronym> (à
condition que
vous ayez quitté Windows normalement). À partir de la fenêtre
« <span class="quote">Informations
système</span> », vous pouvez aussi voir comment les <acronym class="acronym">IRQ</acronym> et
les
ports d'entrées/sorties ont été alloués par Windows.</p><p>Même si Windows ne montre aucun conflit des ressources bus, il peut
exister un conflit sous Linux. Ceci est dû au fait que Windows peut affecter
des ressources bus différentes de celles de l'ESCD. Dans le cas rare où les
périphériques sous Windows sont soit non <acronym class="acronym">PnP</acronym> soit
« <span class="quote">forcés</span> », alors la configuration Windows et celle de l'ESCD
devraient être
les mêmes.
</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N10A96" />5.4.4. Ajouter un nouveau périphérique (sous Linux ou Windows)</h4></div></div></div><p>Si vous ajoutez un nouveau périphérique <acronym class="acronym">PnP</acronym> et avez
configuré le <acronym class="acronym">BIOS</acronym> à « <span class="quote">pas un système d'exploitation
<acronym class="acronym">PnP</acronym></span> »,
alors le <acronym class="acronym">BIOS</acronym> devrait automatiquement le configurer et
enregistrer la configuration dans l'ESCD. S'il ne s'agit pas d'un périphérique
non <acronym class="acronym">PnP</acronym> (ou un utilisant les cavaliers), alors il existe
quelques options pour le gérer.</p><p>Vous pouvez indiquer directement au <acronym class="acronym">BIOS</acronym> (via le menu
de configuration <acronym class="acronym">CMOS</acronym>) que certaines ressources bus qu'il
utilise sont réservées et ne peuvent pas être allouées avec
<acronym class="acronym">PnP</acronym>. Ceci ne met pas cette information dans l'ESCD. Il existe
un menu de sélection du <acronym class="acronym">BIOS</acronym> permettant d'indiquer si les
choix <acronym class="acronym">CMOS</acronym> supplantent ceux de l'<acronym class="acronym">ESCD</acronym> en
cas de conflit. Une autre méthode revient à lancer ICU sous DOS/Windows. Encore
une autre permet de l'installer manuellement sous Windows 9x/2k puis de
s'assurer que cette configuration est « <span class="quote">forcée</span> » (voir la section
précédente). Si elle l'est, Windows devrait mettre à jour
l'<acronym class="acronym">ESCD</acronym> à l'arrêt du PC.</p></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="disable_pnp" />5.5. <acronym class="acronym">ISA</acronym> seulement :
Désactiver <acronym class="acronym">PnP</acronym> ?</h3></div></div></div><p>Les périphériques <acronym class="acronym">PCI</acronym> sont <acronym class="acronym">PnP</acronym> à la
base donc cela ne peut pas être désactivé. Mais quelques périphériques
<acronym class="acronym">ISA</acronym> ont des options pour désactiver <acronym class="acronym">PnP</acronym>
par l'intermédiaire de cavaliers ou en lançant un programme Windows fourni
avec le périphérique (configuration logicielle). Si le pilote du périphérique
ne peut pas le configurer, ceci évitera la tâche probablement compliquée de la
configuration <acronym class="acronym">PnP</acronym>. N'oubliez pas de dire au
<acronym class="acronym">BIOS</acronym> que ces ressources bus sont réservées. Mais comme le
support de Linux pour le <acronym class="acronym">PnP</acronym> a été amélioré, vous ne voulez
généralement pas
désactiver <acronym class="acronym">PnP</acronym>. Voici quelques arguments pour lesquels vous
ne voudrez pas
désactiver <acronym class="acronym">PnP</acronym> :
<div class="itemizedlist"><ul><li><p>Si vous avez Windows sur la même machine, alors vous pouvez
    permettre à <acronym class="acronym">PnP</acronym> de configurer les périphériques
    différemment entre Windows et Linux.</p></li><li><p>L'ensemble des choix pour les numéros d'<acronym class="acronym">IRQ</acronym>
    (ou ports d'adresse) peut être assez limité sauf si vous utilisez
    <acronym class="acronym">PnP</acronym>.</p></li><li><p>Vous pourriez avoir un pilote de périphérique Linux utilisant
    des méthodes <acronym class="acronym">PnP</acronym> pour rechercher le périphérique qu'il
    contrôle.</p></li><li><p>Si vous avez besoin de modifier la configuration plus tard,
    il serait plus facile de faire ceci avec <acronym class="acronym">PnP</acronym> (sans
    utiliser de cavaliers ou d'avoir à lancer un programme Dos/Windows).
    </p></li></ul></div>
</p><p>Une fois vos périphériques configurés sans <acronym class="acronym">PnP</acronym>, 
ils ne peuvent plus être configurés par un logiciel 
<acronym class="acronym">PnP</acronym> ou par un <acronym class="acronym">BIOS</acronym> 
<acronym class="acronym">PnP</acronym> (jusqu'à ce que vous changiez les cavaliers ou 
utilisiez le logiciel de configuration Dos/Windows).</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="isapnp_" />5.6. Bus <acronym class="acronym">ISA</acronym> : Isapnp (outil
faisant partie d'isapnptools)</h3></div></div></div><p>Le programme <span class="command"><strong>isapnp</strong></span> est utilisé uniquement pour les
périphériques <acronym class="acronym">PnP</acronym> du bus <acronym class="acronym">ISA</acronym> (donc non
<acronym class="acronym">PCI</acronym>). Il était vraiment nécessaire avant les noyaux 2.4.
Avec le noyau 2.4, qui a apporté des fonctionnalités permettant aux pilotes de
gérer le <acronym class="acronym">PnP</acronym> sur le bus <acronym class="acronym">ISA</acronym>, le programme
<span class="command"><strong>isapnp</strong></span> devient moins important. De plus, le
<acronym class="acronym">BIOS</acronym> pourrait
configurer <acronym class="acronym">ISA</acronym> <acronym class="acronym">PnP</acronym> de manière
satisfaisante. Mais, le module isa-pnp (ou
l'équivalent intégré au noyau) est déjà très satisfaisant car de nombreux
pilotes de périphériques <acronym class="acronym">ISA</acronym> l'appellent pour configurer les
ressources du bus.
Avant le noyau 2.6, cela résultait en un « <span class="quote">fichier</span> »
<code class="filename">/proc/isapnp</code> pouvant être utilisé pour configurer
manuellement (voir isapnp.txt dans la documentation du noyau).</p><p>Dans certains cas, les distributions Linux ont été configurées pour
lancer <span class="command"><strong>isapnp</strong></span> automatiquement au démarrage. Il est
toujours utilisé en 2004 mais il n'est pas réellement nécessaire si les
pilotes de périphériques fonctionnent bien. Si vous avez besoin de le
configurer vous-même, la grande partie de la documentation d'isapnp est 
difficile à comprendre sauf si vous possédez des notions de base de 
<acronym class="acronym">PnP</acronym>. Ce guide pratique devrait vous aider à le 
comprendre, ainsi que la FAQ qui accompagne <span class="command"><strong>isapnp</strong></span>. 
Lancer le programme <span class="command"><strong>isapnp</strong></span> au démarrage vous 
permettra de configurer ces périphériques suivant les valeurs spécifiées 
dans <code class="filename">/etc/isapnp.conf</code>. Il est possible de créer ce 
fichier de configuration automatiquement mais vous devrez alors l'éditer 
manuellement pour choisir entre les différentes options. Puis pour que 
le pilote connaisse ces ressources, vous avez souvent besoin de les 
spécifier en tant que paramètres pour les modules appropriés (pilotes). 
Ceci se fait avec des fichiers de configuration, généralement dans le 
répertoire <code class="filename">/etc</code>. Cherchez-y des 
fichiers nommés <code class="filename">mod*</code>, et cætera. Si le pilote est intégré 
au noyau, alors ils pourraient parfois être donnés comme paramètre du 
noyau. Voir le <a class="ulink" href="http://www.traduc.org/docs/howto/lecture//BootPrompt-HOWTO.html" target="_top">guide pratique 
des options de démarrage</a>.</p><p>Avec <span class="command"><strong>isapnp</strong></span>, il existait un risque qu'un pilote de
périphérique, intégré au noyau, soit lancé trop tôt, avant
qu'<span class="command"><strong>isapnp</strong></span> n'ait pu configurer les adresses, et cætera 
au niveau matériel. En conséquence, le pilote de 
périphérique ne serait plus capable de trouver le périphérique. Le pilote 
essaie la bonne adresse mais cette adresse n'est pas configurée au 
niveau matériel. Cela est-il toujours un problème ??</p><p>Si votre distribution Linux a automatiquement installé
<span class="command"><strong>isapnptools</strong></span>, <span class="command"><strong>isapnp</strong></span> est
probablement lancé au démarrage. Dans ce cas, il ne vous reste qu'à éditer
<code class="filename">/etc/isapnp.conf</code> suivant <strong class="userinput"><code>man
isapnp.conf</code></strong>. Notez que cela revient à configurer manuellement
<acronym class="acronym">PnP</acronym> car vous prendrez les décisions sur la façon de configurer
lors de l'édition du fichier de configuration.</p><p>Si le fichier de configuration est mauvais ou n'existe pas, vous pouvez
utiliser le programme <span class="command"><strong>pnpdump</strong></span> pour vous aider à créer le
fichier de configuration. Il crée pour vous un fichier de configuration mais
vous devrez l'éditer avec intelligence avant de l'utiliser. Il contient
quelques commentaires pour vous aider. Alors que le <acronym class="acronym">BIOS</acronym>
pourrait aussi avoir configuré les périphériques <acronym class="acronym">ISA</acronym> (si
vous lui avez dit que vous ne disposez pas de système d'exploitation
<acronym class="acronym">PnP</acronym>), <span class="command"><strong>isapnp</strong></span> le refera.</p><p>La terminologie utilisée dans le fichier
<code class="filename">/etc/isapnp.conf</code> peut sembler étrange au début. Par
exemple, pour une adresse d'entrée/sortie 0x3e8, vous pourriez voir « <span class="quote">(IO 0
(BASE 0x3e8))</span> » à la place. « <span class="quote">IO 0</span> » veut dire qu'il s'agit de
la première plage
d'adresses que ce périphérique utilise. Une autre façon d'exprimer ceci
serait :
« <span class="quote">IO[0] = 0x3e8</span> » mais <span class="command"><strong>isapnp</strong></span> ne le fait pas de
cette façon.
« <span class="quote">IO 1</span> » voudrait dire qu'il s'agit de la deuxième plage d'adresse
utilisée par
ce périphérique, et cætera. « <span class="quote">INT 0</span> » a une signification similaire
mais 
pour les <acronym class="acronym">IRQ</acronym> (interruptions). Une carte simple peut 
contenir plusieurs périphériques physiques mais l'explication ci-dessus 
était seulement pour un des périphériques.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="pciutils_" />5.7. Les utilitaires <acronym class="acronym">PCI</acronym></h3></div></div></div><p>Le paquetage des utilitaires <acronym class="acronym">PCI</acronym>
(<span class="command"><strong>pciutils</strong></span>, quelque fois appelé
« <span class="quote">pcitools</span> ») vous permet de configurer manuellement via
<acronym class="acronym">PnP</acronym> le bus <acronym class="acronym">PCI</acronym> (avec difficulté).
<span class="command"><strong>lspci</strong></span> ou <span class="command"><strong>scanpci</strong></span> liste les ressources bus
alors que <span class="command"><strong>setpci</strong></span> enregistre les allocations des ressources
(sauf les <acronym class="acronym">IRQ</acronym>) dans les périphériques
physiques. Il semble que <span class="command"><strong>setpci</strong></span> soit principalement utilisé
dans des scripts et en fait, vous aurez besoin de comprendre le détail des
registres de configuration du <acronym class="acronym">PCI</acronym> pour pouvoir l'utiliser. Ce
thème n'est pas expliqué ici, et pas plus dans la page de manuel de
<span class="command"><strong>setpci</strong></span>.</p><p>Les gens l'ont utilisé pour configurer les périphériques
<acronym class="acronym">PCI</acronym> dont le pilote a échoué dans cette action. Un exemple
est disponible dans le guide pratique sur les modems et le guide pratique sur
les ports séries dans la sous-section « <span class="quote"><acronym class="acronym">PCI</acronym> :
Activer un port
désactivé</span> ». Néanmoins, activer un périphérique n'est d'aucune utilité si
vous
n'avez pas de pilote fonctionnel pour ce périphérique.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="windows_conf" />5.8. Configuration de Windows</h3></div></div></div><p>Cette méthode utilise MS Windows pour configurer et devrait être utilisée
seulement si tout le reste échoue. Si vous avez Windows 9x (ou 2k) sur le même
PC, alors lancez simplement Windows et laissez-le configurer
<acronym class="acronym">PnP</acronym>. Puis lancez Linux à partir de Windows (ou DOS) en
utilisant, par exemple, <span class="command"><strong>loadlin.exe</strong></span>. Il peut y avoir un
problème avec les <acronym class="acronym">IRQ</acronym> pour les périphériques
<acronym class="acronym">PCI</acronym>. Quand Windows s'arrête (sans messages) pour laisser la
place à Linux, il pourrait écraser l'<acronym class="acronym">IRQ</acronym> (en y mettant 0) qui
est stocké dans un des registres de configuration du périphérique
<acronym class="acronym">PCI</acronym>. Linux se plaindra de trouver une <acronym class="acronym">IRQ</acronym>
0.</p><p>Ce qu'on vient d'aborder arrive lorsque vous lancez Linux en utilisant un
raccourci (fichier PIF). Mais un moyen de contourner ce problème est connu si
vous utilisez toujours le raccourci PIF. Un raccourci est en quelque sorte
l'équivalent du lien symbolique sous Linux, mais il est en fait plus que ça car
il est paramétrable. Pour lancer Linux, à partir de DOS, vous créez un fichier
batch (script) qui lance Linux. (Le programme qui lance Linux est dans le
paquet appelé <span class="application">loadlin</span>.) Ensuite, créez un raccourci
PIF vers ce fichier batch et allez dans la fenêtre des propriétés du raccourci.
Sélectionnez « <span class="quote">Avancé</span> », puis vérifiez que le « <span class="quote">mode
MS-DOS</span> » est bien coché.</p><p>Maintenant, voici une astuce empêchant de mettre à zéro les
<acronym class="acronym">IRQ</acronym> <acronym class="acronym">PCI</acronym>. Cochez « <span class="quote">Spécifier une
nouvelle
configuration MS-DOS</span> ». Ensuite, soit vous acceptez la configuration par
défaut
qui vous est proposée soit vous cliquez sur « <span class="quote">Configuration</span> » pour la
modifier.
Maintenant, lorsque vous lancerez Linux en cliquant sur le raccourci, des
nouveaux fichiers de configurations (<code class="filename">config.sys</code> et
<code class="filename">autoexec.bat</code>) seront créés pour votre nouvelle
configuration.</p><p>Les anciens fichiers sont enregistrés comme
<code class="filename">Config.wos</code> et <code class="filename">Autoexec.wos</code>. Une fois
que vous avez terminé d'utiliser Linux et que vous avez arrêté votre PC, vous
aurez encore besoin de ces fichiers pour pouvoir lancer DIS la prochaine fois
que vous démarrerez votre PC. Vous devez vous assurer que les noms redeviennent
<code class="filename">*.sys</code> et <code class="filename">*.bat</code>. Lorsque vous quittez
Windows/DOS pour aller sous Linux, Windows s'attend que, une fois que vous avez
fini avec Linux, vous retourniez à Windows pour que celui-ci puisse restaurer
ces fichiers avec leur noms originaux. Mais ceci n'arrivera pas car lorsque
vous quitterez Linux, vous éteindrez votre PC et ne retournerez pas sous
Windows. Donc, comment renommer ces fichiers ? C'est facile, placez ces
commandes dans votre fichier batch de lancement de Linux pour qu'il renomme les
fichiers. Mettez ces commandes de renommage dans votre fichier batch juste
avant la ligne qui charge Linux.</p><p>De la même façon, il a été rapporté que vous devez cliquer sur l'onglet
« <span class="quote">Général</span> » (de la fenêtre « <span class="quote">Propriétés</span> » de votre
raccourci) et cochez « <span class="quote">Lecture
seule</span> ». Sinon, Windows pourrait remettre à zéro les « <span class="quote">Paramétrages
avancées</span> » en
« <span class="quote">Utilisez la configuration MS-DOS courante</span> » et les
<acronym class="acronym">IRQ</acronym>
<acronym class="acronym">PCI</acronym> se retrouveraient à zéro. Comme Windows efface les
<acronym class="acronym">IRQ</acronym> lorsque vous utilisez la configuration MS-DOS courante
mais il n'efface pas une nouvelle configuration (qui peut configurer tout de
manière identique à l'ancienne configuration). Windows ne semble pas très
cohérent.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="sw_and_docs" />5.9. Documents/Logiciels
<acronym class="acronym">PnP</acronym></h3></div></div></div><p>
<div class="itemizedlist"><ul><li><p><a class="ulink" href="http://www.roestock.demon.co.uk/isapnptools/" target="_top">Page
    d'accueil d'<span class="command"><strong>Isapnptools</strong></span></a> ;
    </p></li><li><p><a class="ulink" href="http://www.astarte.free-online.co.uk" target="_top">Proposition
    pour un gestionnaire de configuration pour Linux</a> 1999 (n'a jamais
   fait partie du noyau) ;</p></li><li><p><a class="ulink" href="http://www.microsoft.com/hwdev/tech/pnp/default.asp" target="_top">
    Spécifications <acronym class="acronym">PnP</acronym> de Microsoft</a> ;
    </p></li><li><p>Livre : <acronym class="acronym">PCI</acronym> System Architecture,
quatrième
    édition par Tom Shanley +, MindShare 1999.  Couvre les fonctionnalités
    <acronym class="acronym">PnP</acronym> du bus
    <acronym class="acronym">PCI</acronym> ;</p></li><li><p><a id="pnp_book" />Livre : Plug and Play System
    Architecture, par Tom Shanley, Mind Share 1999. Détails sur
    <acronym class="acronym">PnP</acronym> pour le bus <acronym class="acronym">ISA</acronym>. Une vue de
    <acronym class="acronym">PnP</acronym> avec le bus
    <acronym class="acronym">PCI</acronym> ;</p></li><li><p>Livre : Programming Plug and Play, par James Kelsey, Sams
1995.
    Détails sur la programmation pour communiquer avec un
    <acronym class="acronym">BIOS</acronym> <acronym class="acronym">PnP</acronym>. Couvre les bus
    <acronym class="acronym">ISA</acronym>, <acronym class="acronym">PCI</acronym> et PCMCIA.</p></li></ul></div>
</p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="tell_driver_config" />6. Indiquer au pilote la
configuration ??</h2></div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N10CB1" />6.1. Introduction</h3></div></div></div><p>Un pilote moderne trouvera pour un périphérique la configuration des
ressources bus sans que vous ayez besoin de lui dire quoi que ce soit. Il
pourrait même enregistrer les ressources bus au niveau matériel en utilisant
des méthodes <acronym class="acronym">PnP</acronym>. Certains périphériques ont plus d'une
façon pour trouver comment leur périphérique physique est configuré. Dans le
pire des cas, vous devez coder en dur les ressources bus dans le noyau (ou un
module) et recompiler.</p><p>En un juste milieu, il existe des cas tels que le lancement d'un
programme pour donner les informations des ressources bus au pilote ou pour
mettre les informations dans un fichier de configuration. Dans certains cas,
le pilote peut chercher le périphérique aux adresses où il suppose qu'il réside
(mais il ne trouvera jamais un périphérique <acronym class="acronym">PnP</acronym> s'il n'a
pas été activé par des méthodes <acronym class="acronym">PnP</acronym>). Il peut même essayer
de tester différentes <acronym class="acronym">IRQ</acronym> pour voir laquelle fonctionne.
Il peut, ou non, le faire automatiquement.</p><p>Dans d'autres cas, le pilote peut utiliser des méthodes
<acronym class="acronym">PnP</acronym> pour trouver le périphérique et la façon dont les
ressources bus ont été configurées par le <acronym class="acronym">BIOS</acronym>, et cætera
mais ne les modifiera pas. Il peut aussi regarder dans certains des
« <span class="quote">fichiers</span> » du répertoire <code class="filename">/proc</code>.</p><p>

Il peut aussi dire « <span class="quote">manuellement</span> » au pilote les ressources 
bus qu'il doit utiliser. Vous donnez ces ressources bus en tant que 
paramètre au noyau ou à un module. Si le pilote est intégré au noyau, 
vous passez les paramètres au noyau via l'invite du démarrage. Voir le 
<a class="ulink" href="http://www.traduc.org/docs/howto/lecture/BootPrompt-HOWTO.html" target="_top">Guide pratique sur l'invite de 
démarrage (<span class="foreignphrase"><em class="foreignphrase">BootPrompt-HOWTO</em></span>)</a> pour 
la description de quelques ressources bus et autres paramètres. Une fois 
que vous savez quels paramètres donner au noyau, vous pouvez les 
enregistrer dans un fichier de configuration du chargeur. Par exemple, 
mettez <strong class="userinput"><code>append="…"</code></strong> dans le fichier 
<code class="filename">lilo.conf</code> puis lancez lilo pour qu'il mette à jour 
les informations de lancement.

</p><p>

Si le pilote est chargé comme module, dans plusieurs cas, le module 
trouvera les ressources bus nécessaires et les enregistrera dans le 
périphérique. Dans les autres cas (généralement pour les anciens PC), 
vous pouvez avoir besoin de donner les ressources bus comme paramètres 
du module. Les paramètres d'un module peuvent être spécifiés dans 
<code class="filename">/etc/modules.conf</code>. Ce sont généralement des outils 
utilisé pour modifier ce fichier et qui sont dépendant de la 
distribution. Les commentaires inclus dans ce fichier devraient vous 
aider sur la façon de le modifier. De même, tout module que vous placez 
dans <code class="filename">/etc/modules</code> se verra charger avec ses 
paramètres.

</p><p>Bien qu'il ait une grande hétérogénéité sur la façon dont les pilotes
trouvent leur ressources bus, le but final est le même. Si vous avez des
problèmes avec un pilote, vous pouvez avoir besoin de regarder la documentation
du pilote (vérifier la documentation du noyau). Quelques exemples brefs de
pilotes sont présentés dans les sections suivantes :</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N10CF4" />6.2. Exemple de pilote de port série</h3></div></div></div><p>Pour les ports séries <acronym class="acronym">PCI</acronym> (et pour les ports série
<acronym class="acronym">ISA</acronym> <acronym class="acronym">PnP</acronym> après le noyau 2.4), le pilote série détecte le type de port
série et le configure via <acronym class="acronym">PnP</acronym>. Malheureusement, quelques
ports série <acronym class="acronym">PCI</acronym> ne sont pas encore gérés.</p><p>Pour le pilote du port série <acronym class="acronym">ISA</acronym> standard avec les
anciennes versions du noyau et pour le pilote série (ne faisant pas partie des
cartes multiports), le pilote travaille sur deux adresses standards pour les
ports série. Il ne cherche pas d'IRQ mais il affecte l'IRQ « <span class="quote">standard</span> »
aux deux premiers ports séries. Ceci peut être mauvais.</p><p>Pour tout autre chose dans le fichier de configuration, le programme
<span class="command"><strong>setserial</strong></span> doit être modifié manuellement. Voir le <a class="ulink" href="http://www.traduc.org/docs/howto/lecture/Serial-Programming-HOWTO.html" target="_top">Guide pratique sur la programmation
des ports série</a> pour plus de détails. Vous utilisez
<span class="command"><strong>setserial</strong></span> pour informer le pilote de l'adresse
d'entrée/sortie et <span class="command"><strong>setserial</strong></span> est souvent exécuté à partir
d'un fichier de démarrage. Dans les versions récentes, il existe un fichier
<code class="filename">/etc/serial.conf</code> (ou
<code class="filename">/var/lib/setserial/autoconfig</code>) que vous « <span class="quote">éditez</span> »
en lançant simplement la commande <strong class="userinput"><code>setserial</code></strong> de façon
ordinaire et ce que vous configurez avec <span class="command"><strong>setserial</strong></span> est
sauvegardé dans le fichier de configuration <code class="filename">serial.conf</code>.
Le fichier <code class="filename">serial.conf</code> devrait être consulté lorsque la
commande <span class="command"><strong>setserial</strong></span> est lancée à partir d'un fichier de
démarrage. Votre distribution peut, ou non, avoir configuré ceci pour
vous.</p><p>Il existe deux façons d'utiliser <span class="command"><strong>setserial</strong></span> suivant les
options que vous lui donnez. Une possibilité est de dire manuellement au pilote
la configuration. L'autre méthode est de tester une adresse donnée et d'indiquer
si un port série existe à cet endroit. Il peut aussi tester cette adresse et
essayer de détecter l'<acronym class="acronym">IRQ</acronym> utilisée par ce port.</p><p>Même avec des noyaux modernes, <span class="command"><strong>setserial</strong></span> est quelque
fois nécessaire si le pilote échoue lors de la détection du port série ou si
vous avez un très ancien matériel.</p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="current_config" />7. Comment puis-je trouver les périphériques et
comment sont-ils configurés ?</h2></div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N10D54" />7.1. La recherche des périphériques et la découverte de la
configuration sont liés</h3></div></div></div><p>Une fois que vous avez trouvé votre matériel, le même programme qui l'a
trouvé vous indique normalement comment il est configuré. Donc, trouver
comment un matériel est configuré revient habituellement à trouver le matériel.
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N10D59" />7.2. Les périphériques pourraient avoir deux « <span class="quote">configurations</span> »</h3></div></div></div><p>Ici, « <span class="quote">configuration</span> » correspond à l'assignation des
ressources
bus <acronym class="acronym">PnP</acronym> (adresses, <acronym class="acronym">IRQ</acronym> et
<acronym class="acronym">DMA</acronym>). Pour chaque périphérique, il existe deux parties à
cette question de configuration :
<div class="itemizedlist"><ul><li><p>Que croit le pilote en ce qui concerne la configuration
    matérielle ?</p></li><li><p>Quelle configuration (s'il y en a une) est réellement
    enregistrée au niveau du matériel ?</p></li></ul></div>
Chaque partie devrait avoir la même réponse (la même configuration). La
configuration du périphérique physique et de son pilote devrait être évidemment
la même (elle l'est habituellement). Mais les choses ne fonctionnent
pas toujours bien et c'est pourquoi il existe une différence. Ceci veut dire
que le pilote dispose d'une mauvaise information sur la configuration actuelle
du matériel. Les problèmes arrivent. Si le logiciel que vous utilisez ne vous
dit pas exactement ce qui ne va pas (ou ne configure pas automatiquement
correctement), alors vous avez besoin de chercher comment vos périphériques
physiques et vos pilotes sont configurés. Alors que les pilotes de
périphériques Linux devraient tout vous dire, dans certains cas, il n'est pas
facile de déterminer ce qui a été enregistré au niveau matériel.</p><p>Un autre problème est que lors de la visualisation des messages de
configuration à l'écran, vous devez savoir si la configuration
affichée est celle du pilote, du périphérique physique ou des deux. Si le
pilote de périphérique a soit enregistré la configuration soit vérifié le
matériel, alors le pilote devrait avoir les bonnes informations.</p><p>Mais, quelquefois, le pilote a obtenu des ressources incorrectes par un
script ou un fichier de configuration, par des paramètres de ressources
incorrectes données à un module, ou peut-être même que la configuration ne lui a
pas été fournie complètement et qu'il essaie d'utiliser par défaut des ressources
incorrectes. Par exemple, quelqu'un peut utiliser <span class="command"><strong>setserial</strong></span>
pour indiquer au pilote de périphérique une configuration incorrecte des
ressources et le pilote les acceptera sans broncher. Mais le port série ne
fonctionne pas bien (s'il fonctionne tout court).</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N10D7C" />7.3. Trouver le matériel</h3></div></div></div><p>Un problème habituel est que le logiciel ne détecte pas votre 
périphérique ou ne détermine pas le bon pilote pour celui-ci. Pour les 
périphériques <acronym class="acronym">PnP</acronym>, les détecter est facile avec un 
logiciel <acronym class="acronym">PnP</acronym> sauf pour le cas inhabituel où le 
matériel a été désactivé. Le <acronym class="acronym">BIOS</acronym> peut parfois être 
initialisé pour désactiver les périphériques <acronym class="acronym">PnP</acronym> ou 
un cavalier/interrupteur sur le périphérique physique lui-même pourrait 
le désactiver. Dans ce cas, le matériel ne peut pas être détecté du tout 
jusqu'à ce que vous re-configuriez le <acronym class="acronym">BIOS</acronym> ou que 
vous changiez le cavalier/interrupteur.</p><p>Comme le bus <acronym class="acronym">PCI</acronym> est intrinsèquement
<acronym class="acronym">PnP</acronym>, il n'y a pas de périphériques
cachés. Même si les périphériques <acronym class="acronym">PnP</acronym> sont faciles à trouver
avec les méthodes
PnP, si le pilote n'utilise pas les méthodes <acronym class="acronym">PnP</acronym> mais utilise
l'ancienne méthode
de recherche aux adresses supposées, ils pourraient ne pas être trouvés. Ceci
est dû au fait que, avant que les ressources bus aient été initialisées (par le
<acronym class="acronym">BIOS</acronym> ou Linux), le périphérique pourrait ne pas avoir
d'adresses du tout, donc
parcourir les adresses habituelles n'apportera rien. Pour l'ancien bus
<acronym class="acronym">ISA</acronym>,
quelques-uns des périphériques pourraient être non <acronym class="acronym">PnP</acronym> et, de
ce fait, les
anciennes méthodes pourraient fonctionner. Donc, de nombreux pilotes continuent
à parcourir les adresses habituelles en plus d'utiliser les méthodes
<acronym class="acronym">PnP</acronym>
(parcours <acronym class="acronym">PnP</acronym>, quelquefois appelé simplement
parcours).</p><p>Façons de détecter des périphériques matériels (et leur configurations)
 : (suivre le lien pour plus de détails)
<div class="itemizedlist"><ul><li><p>Vérifier le <acronym class="acronym">BIOS</acronym> pour vous assurer qu'ils
    ne sont pas désactivés ;</p></li><li><p>Regarder les messages de démarrage à l'écran (voir <a class="link" href="#boot_time_msgs" title="7.4. Messages de démarrage">les messages au démarrage</a>) ;
    </p></li><li><p>Regarder dans <a class="xref" href="#proc_dir" title="7.5. Le répertoire /proc">Section 7.5, « Le répertoire /proc »</a> ;
    </p></li><li><p><a class="link" href="#hw_detect" title="7.15. Outils pour détecter ou configurer le matériel">Outils pour détecter et 
  configurer tout le matériel</a>... lsdev, hwinfo, discover,
    kudzu ;</p></li><li><p><a class="link" href="#hw_detect_one_type" title="7.16. Outils pour détecter et configurer un type de matériel">Outils pour 
  détecter ou
    configurer un type de matériel</a> ;</p></li><li><p><acronym class="acronym">PCI</acronym> : <a class="xref" href="#pci_" title="7.7. Inspection du bus PCI">Section 7.7, « Inspection du bus <acronym class="acronym">PCI</acronym> »</a> 
    </p></li><li><p>Bus <acronym class="acronym">ISA</acronym> : <a class="xref" href="#isa_bus" title="7.8. Introduction au bus ISA">Section 7.8, « Introduction au bus <acronym class="acronym">ISA</acronym> »</a>
    </p></li><li><p>Bus <acronym class="acronym">ISA</acronym> : <a class="xref" href="#isa_pnp" title="7.9. Cartes ISA PnP">Section 7.9, « Cartes <acronym class="acronym">ISA</acronym>
<acronym class="acronym">PnP</acronym> »</a>
    </p></li><li><p>Bus <acronym class="acronym">ISA</acronym> : <a class="xref" href="#non_pnp" title="7.12. Cartes non PnP">Section 7.12, « Cartes non <acronym class="acronym">PnP</acronym> »</a>
    </p></li><li><p>Bus <acronym class="acronym">ISA</acronym> : <a class="xref" href="#jumpers_" title="7.13. Cartes non PnP avec cavaliers">Section 7.13, « Cartes non <acronym class="acronym">PnP</acronym> avec
cavaliers »</a>
    </p></li><li><p>Bus <acronym class="acronym">ISA</acronym> : <a class="xref" href="#neither_" title="7.14. Cartes non PnP et sans cavaliers">Section 7.14, « Cartes non <acronym class="acronym">PnP</acronym> et sans
cavaliers »</a>
    </p></li><li><p>Et <a class="xref" href="#check_ms" title="7.17. Utilisez MS Windows">Section 7.17, « Utilisez MS Windows »</a>
    </p></li></ul></div>
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="boot_time_msgs" />7.4. Messages de démarrage</h3></div></div></div><p>Des informations significatives sur la configuration peuvent être obtenues
en lisant
les messages affichés par le <acronym class="acronym">BIOS</acronym> et par Linux lors du
démarrage de l'ordinateur. Ces messages disparaissent souvent trop rapidement
pour être lus mais, une fois le défilement terminé, tapez
<span class="keycap"><strong>Majuscule</strong></span>+<span class="keycap"><strong>Page Suivante</strong></span>
plusieurs
fois pour revenir en arrière. Pour aller en avant, faites
<span class="keycap"><strong>Majuscule</strong></span>+<span class="keycap"><strong>Page Précédente</strong></span>.
Utilisez
<span class="command"><strong>dmesg</strong></span> à la console à n'importe quel moment pour afficher
seulement les messages du noyau. Vous ne verrez pas certains messages les plus
importants provenant généralement du <acronym class="acronym">BIOS</acronym>. Les messages
affichés par Linux peuvent parfois n'afficher que ce que le pilote de
périphérique croit être configuré, peut-être à cause d'un mauvais fichier de
configuration. Vérifier les fichiers de traces dans <code class="filename">/var/log</code> peut être utile.</p><p>Pour le bus <acronym class="acronym">PCI</acronym>, la notation 00:1a:0 signifie le
bus <acronym class="acronym">PCI</acronym> 00 (le bus <acronym class="acronym">PCI</acronym> principal), la
carte <acronym class="acronym">PCI</acronym> (ou le composant) 1a et la fonction 0 (le premier
périphérique) sur la carte ou le composant. Le deuxième périphérique sur la
carte (ou sur le composant) devrait être 00:08:1.</p><p>Les messages du <acronym class="acronym">BIOS</acronym> s'affichent en premier et
montrent la configuration du matériel à ce moment, mais
<span class="command"><strong>isapnp</strong></span>, ou les utilitaires <acronym class="acronym">PCI</acronym>, voire les
pilotes de
périphériques peuvent le changer plus tard. Dans certains cas, il n'affiche pas
les périphériques que le <acronym class="acronym">BIOS</acronym> n'a pas configuré.</p><p><a id="pause_" />Si les messages du <acronym class="acronym">BIOS</acronym> ne s'affichent pas
en revenant au
début des messages du <acronym class="acronym">BIOS</acronym> avec
<span class="keycap"><strong>Majuscule</strong></span>+<span class="keycap"><strong>Page Suivante</strong></span>,
essayez de mettre en pause lorsqu'ils apparaissent, en utilisant la touche
<span class="keycap"><strong>Pause</strong></span> dès que les premiers mots
apparaissent. Appuyez sur n'importe quelle touche pour continuer. Il est souvent
difficile d'appuyer sur <span class="keycap"><strong>Pause</strong></span> exactement
au bon moment. Assurez-vous d'appuyer continuellement sur la touche
<span class="keycap"><strong>Shift</strong></span> avant d'appuyer sur
<span class="keycap"><strong>Pause</strong></span> car
<span class="keycap"><strong>Pause</strong></span>
est une touche nécessitant l'utilisation de
<span class="keycap"><strong>Shift</strong></span>.
Si vous n'avez pas réussi, appuyez sur
<span class="keycap"><strong>Ctrl</strong></span>+<span class="keycap"><strong>Alt</strong></span>+<span class="keycap"><strong>Del</strong></span>
au lancement de Linux pour le relancer et essayer de nouveau. Une fois que les
messages de Linux commencent à être visibles, il est trop tard pour utiliser
<span class="keycap"><strong>Pause</strong></span> car cela ne gèlera pas les messages
de Linux.</p><p>Pour initialiser des éléments du <acronym class="acronym">BIOS</acronym> comme les
<acronym class="acronym">IRQ</acronym> réservés au matériel
propriétaire, aux adresses des ports série, et cætera vous aurez besoin d'entrer dans
les menus de configuration du <acronym class="acronym">BIOS</acronym> (CMOS) au lancement.
Chaque marque de <acronym class="acronym">BIOS</acronym> a
différentes touches pour ce faire. Il existe des listes sur Internet. Parfois
en gelant l'affichage des messages du <acronym class="acronym">BIOS</acronym> ou en
regardant l'écran, la
touche que vous devez appuyer sera indiquée dans un message tel que
« <span class="quote">Press DEL for setup</span> » (« <span class="quote">Appuyez sur DEL pour la
configuration</span> »). Mais il pourrait disparaître si rapidement que vous ne
le
verrez pas. Bien sûr, vous ne modifiez rien dans le <acronym class="acronym">BIOS</acronym> que
vous ne comprenez
pas. Le cas contraire, votre PC pourrait être désactivé.</p><p>Les messages du <acronym class="acronym">BIOS</acronym> au démarrage vous indiquent
ce que fut la configuration du matériel. La configuration actuelle 
pourrait toujours être la même que ce qu'a fait le 
<acronym class="acronym">BIOS</acronym> et que Linux devrait accepté si c'est bon. Les 
messages de Linux pourraient provenir des pilotes utilisant les 
fonctions <acronym class="acronym">PnP</acronym> du noyau pour inspecter ou configurer 
les ressources bus. Cela devrait être correct mais attention aux 
messages qui affichent seulement ce que le pilote a lu de son fichier de 
configuration. Cela pourrait être faux. Bien sûr, si le périphérique 
fonctionne bien, alors il est configuré probablement de la même façon 
par le pilote.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="proc_dir" />7.5. Le répertoire /proc</h3></div></div></div><p>Depuis le noyau 2.6, il existe aussi un répertoire <code class="filename">/sys</code> en plus du répertoire <code class="filename">/proc</code>. Ces répertoires sont utiles pour récupérer
les configurations des ressources et périphériques. Les fichiers qu'ils
contiennent représentent des données provenant de la mémoire du noyau et
n'existent pas du tout sur votre disque dur. Les programmes comme
<code class="filename">lspci</code> récupèrent leurs informations du répertoire
<code class="filename">/proc</code> et ils doivent les afficher
d'une façon plus lisible qu'en lisant directement le contenu des fichiers
de ce répertoire. Voici quatre fichiers provenant de <code class="filename">/proc</code> qui montrent les ressources enregistrées
dans le noyau par les pilotes de périphériques.</p><p>Comme le Plug-And-Play de Linux fonctionne en laissant les pilotes de
périphériques alloués les ressources pour leur périphérique, il pourrait ne
pas y avoir de ressources utilisées par certains de vos matériels si le pilote
n'a pas encore réclamé que ces ressources lui soient réservées. Pour les cas
des modules du noyau (pilotes de périphérique chargeables), si le module n'est
pas encore chargé, le noyau ne connaît pas les ressources dont le module a
besoin. Quelque fois, le module se charge seulement quand vous lancez une
application qui en a besoin. Donc, si un certain matériel est manquant parmi
les fichiers de <code class="filename">/proc</code>, cela pourrait
signifier que le matériel n'a pas encore été utilisé. Par exemple, même si votre
lecteur de disquette dispose d'une disquette et est prêt à être utilisé, son
interruption n'apparaîtra tant que le lecteur n'est pas utilisé.</p><p><code class="filename">/pts</code> affiche les adresses d'entrée/sortie. S'il y a
une erreur (mauvaise adresse), cela pose problème car le périphérique n'obtiendra
pas les octets qui lui sont envoyés. <code class="filename">/proc/iomem</code> affiche
les adresses mémoires d'entrée/sortie qui sont réservées.
<code class="filename">/proc/interrupts</code> affiche les interruptions en cours
d'utilisation. <code class="filename">/proc/dma</code> affiche les allocations de canaux
DMA pour le bus ISA.</p><p>Dans le passé, l'auteur a observé une liste d'interruptions qui
n'existaient pas. Dans certains cas, cela montrait que quelques interruptions
étaient vraiment envoyées. Ceci peut être dû à des matériels défectueux envoyant
des interruptions erronées.</p><p><code class="filename">/proc/bus/</code> contient les
sous-répertoires <code class="filename">/input/</code>, <code class="filename">/pci/</code> et <code class="filename">/isapnp/</code>. Le format de la plupart des fichiers
dans ce répertoire est vraiment cryptique, souvent une simple copie des octets de
l'espace de configuration. Donc, utilisez-les seulement en dernier ressort. Le
sous-répertoire <code class="filename">input/</code> a des informations
sur les périphériques en entrée comme le clavier ou la souris. Elles ne sont pas
aussi complexes que les autres répertoires sous <code class="filename">/proc/bus</code> et pourraient fournir des informations
utiles sur les périphériques d'entrées qui sont sur les ports <acronym class="acronym">PS2</acronym>
ou sur le bus <acronym class="acronym">LPC</acronym> (voir <a class="xref" href="#lpc_" title="7.10. Bus LPC">Section 7.10, « Bus <acronym class="acronym">LPC</acronym> »</a>).
Malheureusement, ce que j'ai vu ne dit pas que c'est sur le bus
<acronym class="acronym">LPC</acronym> où il est probablement. Dans
<code class="filename">/pci/00/</code> se trouve un fichier binaire pour
chaque périphérique <acronym class="acronym">PCI</acronym> où les noms des fichiers sont les
numéros des emplacements <acronym class="acronym">PCI</acronym>. Le 00 signifie le bus
<acronym class="acronym">PCI</acronym> 0.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="sys_dir" />7.6. Le répertoire /sys</h3></div></div></div><p>À partir du noyau 2.6, il existe un nouveau répertoire /sys pour la
configuration de <acronym class="acronym">PnP</acronym>. Il s'agit d'un système de fichiers de
type sysfs et c'est un équivalent du système de fichiers /proc car les
« <span class="quote">fichiers</span> » représentent une information de la mémoire du noyau et
non pas un vrai fichier de votre disque dur. Cependant, il n'est pas aussi utile
que le système de fichiers /proc. Au début (pour les noyaux 2.5), il s'appelait
le « <span class="quote">système de fichiers des pilotes</span> » et avait comme type
« <span class="quote">driverfs</span> ».</p><p>Dans ce système de fichiers, chaque périphérique existant sur votre
système a son propre répertoire contenant des fichiers spécifiant les
ressources qui lui sont affectées. Ces répertoires ont des noms comme
<code class="filename">0000:00:12.0@</code> ou <code class="filename">00:06@</code>. Quels sont
ces périphériques ? Le premier est une carte <acronym class="acronym">PCI</acronym> dans
l'emplacement 12 de votre PC. L'emplacement pourrait être appelé
<acronym class="acronym">PCI</acronym>2 dans votre PC (2 au lieu de 12) tout simplement parce
que les emplacements ayant des numéros fiables sont utilisés par les
emplacements intégrés à la carte mère et n'utilisent pas les emplacements
physiques. Dans cet exemple, les emplacements 1 à 10 seraient intégrés alors que
les emplacements 11 à 14 seraient appelés de 1 à 4. En exécutant
<span class="command"><strong>lspci</strong></span>, vous connaîtrez la correspondance entre les numéros
(comme 0000:00:12.0) et les noms (identique à l'interface IDE). Exécutez
la commande <span class="command"><strong>lspci -vv</strong></span>, ou <span class="command"><strong>lspci -vv</strong></span> si
vous voulez en voir plus.</p><p>Alors, qu'est-ce que <code class="filename">00:06</code> ? C'est une carte
<acronym class="acronym">ISA</acronym> (ou un périphérique intégré) mais ce n'est pas
l'emplacement 6 du bus <acronym class="acronym">ISA</acronym> (contrairement au numérotage
<acronym class="acronym">PCI</acronym>). Quand une recherche est faite pour les périphériques
<acronym class="acronym">PnP</acronym> <acronym class="acronym">ISA</acronym>, il a été le sixième découvert.
Plus précisément, il était le septième trouvé car il existe un périphérique
numéroté 00:00. Donc, comment les identifier ? Vous pouvez lancer
« <span class="quote">cat */*</span> » et afficher tous les fichiers pour tous les périphériques
mais même à ce moment-là vous ne verrez pas les noms des périphériques (mais
vous verrez l'information qui vous permettra de l'identifier). Ce problème sera
corrigé dans le futur.</p><p>Non seulement ces fichiers apportent des informations sur la
configuration des ressources du bus (d'une manière un peu cryptée) et sur les
pilotes (dans les répertoires « <span class="quote">drivers</span> ») mais, dans le futur, vous
devriez être capable de les utiliser pour modifier la configuration des
ressources. Actuellement (août 2004), vous ne pouvez pas configurer le bus
<acronym class="acronym">PCI</acronym> avec cela. Une sérieuse limitation est qu'avec le
« <span class="quote">modèle de pilote</span> » actuel, vous ne pouvez pas changer la ressource
d'un périphérique qui a été affecté à un pilote, ce qui signifie généralement
que vous aurez besoin de décharger le module du pilote pour pouvoir l'utiliser.
Si le pilote est intégré, il n'y a aucun espoir. Ces sérieuses limitations
seront éliminées dans le futur avec un peu de chance. Dans la documentation du
noyau se trouve un fichier <code class="filename">pnp.txt</code> indiquant comment
réaliser la configuration. En août 2004, il était obsolète mais
l'auteur travaille sur une mise à jour. Utiliser le répertoire <code class="filename">/sys</code> pour configurer les ressources est connue
comme l'« <span class="quote">interface utilisateur pour le Plug and Play de
Linux</span> ».</p><p>L'autre partie de « <span class="quote">Linux Plug and Play</span> » est l'interface noyau
utilisée par les pilotes de périphériques. Elle a beaucoup changé depuis le
début du noyau 2.6 mais la plupart des pilotes utilisent toujours l'ancienne
interface (août 2004). Il est aussi possible pour les pilotes (ou vous)
d'utiliser l'interface utilisateur qui a besoin d'améliorations.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="pci_" />7.7. Inspection du bus <acronym class="acronym">PCI</acronym></h3></div></div></div><p>Il est facile de trouver quelles ressources bus ont été assignées 
aux périphériques du bus <acronym class="acronym">PCI</acronym> avec les commandes 
<span class="command"><strong>lspci</strong></span> et <span class="command"><strong>scanpci</strong></span>. Les options -v 
et -vv vous donneront plus de détails. Dans certains cas, 
<span class="command"><strong>scanpci</strong></span> trouvera un périphérique que 
<span class="command"><strong>lspci</strong></span> ne peut pas trouver. Ceci est dû au fait que 
<span class="command"><strong>scanpci</strong></span> recherche les périphériques directement sur 
le bus <acronym class="acronym">PCI</acronym> (via l'espace de configuration) et 
n'utilise pas les données obtenues par le noyau (qui pourraient être 
fausses à cause d'un bogue du noyau — je viens de trouver un tel 
cas).</p><p>Cette information d'un format crypté est disponible dans les
« <span class="quote">fichiers</span> » situés dans les répertoires <code class="filename">/sys</code> et <code class="filename">/proc</code>.
Dans <code class="filename">/sys/bus/pci/devices</code>, le fichier
<code class="filename">vendor</code> contiendra le numéro d'identifiant du vendeur, comme
0x4B8C, et cætera. Dans un format encore moins compréhensible, il se trouve dans
<code class="filename">/proc/bus/pci</code>. De telles informations dans
les anciens noyaux (avant le 2.6) se trouvaient dans <code class="filename">/proc/pci</code> (compréhensible malgré que les
<acronym class="acronym">IRQ</acronym> soient en hexadécimal) ou dans <code class="filename">/proc/buspci/devices</code> (affichage non compréhensible).
</p><p>Dans la plupart des cas pour le <acronym class="acronym">PCI</acronym>, vous verrez
seulement comment le matériel est maintenant configuré et pas quelles
ressources sont nécessaires. Dans certains cas, vous verrez seulement l'adresse
de base (le début des plages d'adresses) mais pas celle de fin. Si vous
disposez de l'espace complet, alors vous pourrez déterminer combien d'octets de
ressources sont nécessaires.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="isa_bus" />7.8. Introduction au bus <acronym class="acronym">ISA</acronym></h3></div></div></div><p>Pour les cartes du bus <acronym class="acronym">ISA</acronym>, ce n'est pas aussi simple
que pour le bus <acronym class="acronym">PCI</acronym> qui est conçu pour le
<acronym class="acronym">PnP</acronym>. Les cartes <acronym class="acronym">ISA</acronym> récentes étaient
<acronym class="acronym">PnP</acronym> contrairement aux anciennes. De même, certaines cartes
<acronym class="acronym">PnP</acronym> ont leur partie <acronym class="acronym">PnP</acronym> désactivée par
des logiciels spéciaux ne fonctionnant que sous MS Windows. Les cartes non
<acronym class="acronym">PnP</acronym> sont configurées avec des cavaliers sur la carte ou par
des logiciels sous MS Windows.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="isa_pnp" />7.9. Cartes <acronym class="acronym">ISA</acronym>
<acronym class="acronym">PnP</acronym></h3></div></div></div><p>Si c'est une carte <acronym class="acronym">PnP</acronym>, vous pouvez essayer
<strong class="userinput"><code>pnpdump --dumpregs</code></strong> mais ce n'est pas une certitude. Le
résultat peut sembler crypté mais il peut être déchiffré. Ne confondez pas les
adresses de port de lecture que <span class="command"><strong>pnpdump</strong></span> utilise pour
communiquer avec les cartes <acronym class="acronym">PnP</acronym> avec l'adresse
d'entrées/sorties du périphérique trouvé. Elles ne sont pas identiques.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="lpc_" />7.10. Bus <acronym class="acronym">LPC</acronym></h3></div></div></div><p><acronym class="acronym">LPC</acronym> (acronyme de <span class="foreignphrase"><em class="foreignphrase">Low Pin
Count</em></span>, soit petit nombre de connecteurs) est une interface
type bus souvent utilisée sur les portables et de plus en plus utilisée sur
les machines de bureau. Pour savoir si vous disposez d'un bus
<acronym class="acronym">LPC</acronym>, saisissez la commande <span class="command"><strong>lspci</strong></span> et
cherchez quelque chose comme « <span class="quote">LPC</span> ». Il y a d'autres mots prêt de
« <span class="quote">LPC</span> » comme « <span class="quote">ISA Bridge ... LPC Interface Controller</span> »
ou « <span class="quote">LPC Bridge</span> », et cætera. <acronym class="acronym">LPC</acronym> n'est pas réellement
de l'<acronym class="acronym">ISA</acronym> mais il se substitue à un bus
<acronym class="acronym">ISA</acronym>.</p><p>L'ancien bus ISA était lent et les périphériques qui avaient besoin de
plus de rapidité étaient placés sur le nouveau bus PCI. Mais les périphériques
qui n'avaient pas besoin d'une grande vitesse étaient souvent implémentés par
des composants sur la carte mère et restaient sur le bus ISA même s'il n'y
avait aucun emplacement pour des cartes ISA. Puis le bus LPC est arrivé pour
remplacer les cartes ISA restantes. LPC est bien plus petit que l'ISA et aussi
rapide car son horloge est quatre fois plus rapide que celle du bus ISA. Son
bus multiplexé pour les données/adresses et le contrôle est composé de quatre
fils. Envoyer un octet requiert la séparation de l'octet en deux demi-octets
et leur réassemblage après. Cela explique la signification de l'acronyme
LPC : Low Pin Count (petit nombre de broches). Il y a aussi quelques lignes
sur le bus.</p><p>Cette petite interface LPC est utilisé pour les périphériques propriétaires
lents comme les ports séries, les ports parallèles et les lecteurs de disquette.
Donc, un ordinateur utilisant le bus LPC aura tous ces périphériques rapides sur
le bus PCI, et cætera et les périphériques lents sur le bus LPC. Tous les périphériques
LPC seront sur la carte : il n'existe pas d'emplacement pour carte LPC.</p><p>Un composant majeur du bus <acronym class="acronym">LPC</acronym> est le composant
superio, contenant des périphériques d'entrées/sorties propriétaires :
ports série et parallèle, lecteur de disquette, contrôleur de clavier, et cætera. Le
<acronym class="acronym">BIOS</acronym> pourrait même se trouver sur le bus
<acronym class="acronym">LPC</acronym>. Le clavier et la souris (périphériques en entrée)
devraient être listés dans <code class="filename">/proc/bus/input/devices</code> mais,
au lieu de voir « <span class="quote">lpc</span> », il semble afficher
« <span class="quote">isa0060/serio0</span> », et cætera même s'ils se trouvent sur le bus LPC, et
non pas sur le bus ISA.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N1105B" />7.11. X-bus</h3></div></div></div><p>Avant que le bus LPC devienne populaire, il existait un bus X (pas
couvert dans ce guide pratique) qui a servi dans le même but que le bus
LPC mais qui n'était pas aussi compact que le bus LPC. Certains PC
disposent des deux bus.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="non_pnp" />7.12. Cartes non <acronym class="acronym">PnP</acronym></h3></div></div></div><p>En contraste avec les cartes <acronym class="acronym">PnP</acronym>, les cartes non
<acronym class="acronym">PnP</acronym> ont toujours leurs ressources configurées au niveau
matériel. C'est-à-dire qu'elles ont toujours une adresse et une
<acronym class="acronym">IRQ</acronym> sauf s'il
existe une configuration par cavalier, et cætera pour désactiver le périphérique.
Quelquefois, le pilote du périphérique, ou un autre logiciel, peut trouver les
ressources utilisées simplement en cherchant sur chaque adresse. Par exemple,
<span class="command"><strong>scanport</strong></span> (Debian uniquement ?) cherche sur la plupart
des adresses d'entrées/sorties et peut trouver des périphériques
<acronym class="acronym">ISA</acronym>. Mais, attention, cela peut bloquer votre PC. Quelque
fois, il échouera dans sa recherche du matériel disponible (car le matériel a
0xff dans ses registres). Même s'il trouve le matériel, il n'affichera pas
l'<acronym class="acronym">IRQ</acronym> ou n'identifiera pas positivement le matériel.</p><p>Donc, une façon de trouver ce matériel est de lancer un pilote, qui
pourrait chercher un tel matériel. En regardant dans les messages du démarrage,
vous pourriez voir un pilote se lancer et découvrir le matériel. Sinon, vous
pourriez avoir besoin de trouver un pilote et de le lancer (par exemple, en le
chargeant comme un module).</p><p>Trouver le bon pilote peut être difficile. Quelquefois, il n'existe tout
simplement pas de pilote car certains périphériques ne sont pas (encore) gérés
par Linux. Pour déterminer le pilote dont vous avez besoin, jetez un œil
sur
toute documentation pouvant vous permettre d'identifier la carte. Si ceci
échoue, jetez un œil à la carte elle-même, avec les noms/numéros
importants
inscrits sur les composants. Mais l'identification du module de pilote dont vous
avez besoin pourrait n'être pas disponible sur la carte. Vous pouvez trouver
l'identifiant FCC sur la carte, puis chercher sur Internet avec ce numéro pour
essayer de trouver plus d'informations sur la carte (ou sur les composants en
faisant partie).</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="jumpers_" />7.13. Cartes non <acronym class="acronym">PnP</acronym> avec
cavaliers</h3></div></div></div><p>Si la carte dispose de cavaliers pour configurer les ressources, alors
vous pouvez regarder la façon dont ils sont installés. Il existe des cartes qui
ont à la fois le support de <acronym class="acronym">PnP</acronym> et des cavaliers. Elles
fonctionnent comme des cartes à cavalier si <acronym class="acronym">PnP</acronym> a été
désactivé d'une façon ou d'une autre. Vous pourriez avoir besoin de la
documentation (soit imprimée soit sur disquette) venant avec la carte. Peut-être
pourrez-vous la trouver sur Internet.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="neither_" />7.14. Cartes non <acronym class="acronym">PnP</acronym> et sans
cavaliers</h3></div></div></div><p>Un des cas les plus difficiles est quand du logiciel fonctionnant sous MS
Windows a été utilisé pour configurer une carte non <acronym class="acronym">PnP</acronym> ou
une carte <acronym class="acronym">PnP</acronym> où la partie <acronym class="acronym">PnP</acronym> a été
désactivée. Donc, vous ne pouvez la configurer par <acronym class="acronym">PnP</acronym> ou par
des cavaliers. Dans ce cas, votre seul espoir est de chercher les adresses comme
décrit dans <a class="xref" href="#non_pnp" title="7.12. Cartes non PnP">Section 7.12, « Cartes non <acronym class="acronym">PnP</acronym> »</a>. Ou essayez de trouver le logiciel MS qui
l'a configuré.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="hw_detect" />7.15. Outils pour détecter ou configurer le matériel</h3></div></div></div><p>Dans un effort dupliqué, plusieurs distributions majeures de Linux 
ont développé leur propre outil de détection et de configuration du 
matériel. Ils configurent généralement bien plus que les ressources 
Plug-and-Play. C'est une configuration générale qui est bien au-delà du 
domaine couvert par ce guide pratique.</p><p>Puis, d'autres distributions, comme Debian, pouvaient obtenir des copies
des outils et les offrir à leurs utilisateurs comme option ou comme outil en
cas de problème. Ces outils utilisent généralement les outils Linux standard
pour détecter le matériel, comme par exemple <span class="command"><strong>lspci</strong></span>. Dans la
liste d'outils qui suit, le nom de la distribution qui l'a conçu est entre
parenthèses mais l'outil est certainement disponible aussi pour les autres
distributions.</p><div class="itemizedlist"><ul><li><p><span class="command"><strong>hardinfo</strong></span> ;</p></li><li><p><span class="command"><strong>hwinfo</strong></span> (SuSE) détecte plus de choses que
    <span class="command"><strong>discover</strong></span> ;</p></li><li><p><span class="command"><strong>discover</strong></span> (Progeny, utilisé par
    Debian) ;</p></li><li><p><span class="command"><strong>Kudzu</strong></span> (RedHat) détecte et
    configure ;</p></li><li><p><span class="command"><strong>lsdev</strong></span> (commande Linux
    standard) ;</p></li><li><p><span class="command"><strong>hwsetup-knoppix</strong></span> (Knoppix, basé sur
    Kudzu).</p></li></ul></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="hw_detect_one_type" />7.16. Outils pour détecter et configurer un type de matériel</h3></div></div></div><p>Il existe différents outils disponibles pour trouver et, quelque fois,
configurer différents types de périphériques. Cette configuration est
généraliste et n'est pas couverte dans ce guide pratique.</p><div class="itemizedlist"><ul><li><p><span class="command"><strong>read-edid</strong></span> (<span class="command"><strong>get-edid</strong></span>) :
    récupère les paramètres des moniteurs <acronym class="acronym">VESA</acronym> (à part les
    très anciens) ;</p></li><li><p><span class="command"><strong>sndconfig</strong></span> : pour les cartes
    son ;</p></li><li><p><span class="command"><strong>printtool</strong></span> : imprimantes (X-window doit
    être en cours d'exécution) ;</p></li><li><p><span class="command"><strong>pconf-detect</strong></span> : ports
    parallèles ;</p></li><li><p><span class="command"><strong>gpm-mouse-test</strong></span> : détecte et teste les
    souris</p></li><li><p><span class="command"><strong>mdetect</strong></span> : détecte et configure les
    souris. Connaît-il les souris sur
    <code class="filename">/dev/input/</code> ?</p></li><li><p><span class="command"><strong>nictools-pci</strong></span> (et <span class="command"><strong>nictools-nopci</strong></span>)
    pour les cartes ethernet ;</p></li><li><p><span class="command"><strong>hdparm</strong></span> : configure les disques
    durs ;</p></li><li><p><span class="command"><strong>hotplug</strong></span> : utilisé par le
    noyau ;</p></li><li><p><span class="command"><strong>xvidtune</strong></span> : configure la vidéo avec
    Xwindows (voir XFree86-Video-Timings-HOWTO).</p></li></ul></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="check_ms" />7.17. Utilisez MS Windows</h3></div></div></div><p>Quelques personnes ont essayé d'utiliser Windows pour voir comment 
les ressources bus étaient configurées. Malheureusement, comme le 
matériel <acronym class="acronym">PnP</acronym> oublie sa configuration de ressources 
bus à l'arrêt, la configuration peut ne pas être identique lors du 
redémarrage sous Linux pour le matériel non <acronym class="acronym">PnP</acronym> (ou 
lorsque quelqu'un a désactivé <acronym class="acronym">PnP</acronym> dans le 
périphérique soit par des cavaliers soit en utilisant des logiciels 
Windows). Même pour <acronym class="acronym">PnP</acronym>, cela peut être le cas parce 
que dans beaucoup de cas, Windows et Linux acceptent simplement ce que 
le <acronym class="acronym">BIOS</acronym> a fait. Mais là où Windows et Linux font une 
configuration, ils peuvent le faire différemment. Donc ne comptez pas à 
ce que les périphériques soient configurés de la même manière. </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="pci_int" />8. Interruptions PCI</h2></div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N11146" />8.1. Introduction</h3></div></div></div><p>Chaque périphérique PCI qui a besoin d'une interruption vient avec une
interruption PCI fixe qui ne peut pas être modifié. Elle est désigné par un
numéro de slot et une lettre (A, B, C ou D), par exemple 3:B. Mais, cette
interruption PCI est redirigée vers un numéro d'interruption ISA, comme par
exemple 21 pour un composant sur la carte mère.</p><p>Ce routage est réalisé par un routeur programmable d'interruptions
(<acronym class="acronym">PIR</acronym>, acronyme de <span class="foreignphrase"><em class="foreignphrase">programmable interrupt
router</em></span>). Autrement, une ligne d'interruption pourrait être
routée directement (sans aucun PIR). Si un PIR est présent, il peut être
programmé par le BIOS ou par Linux. Donc, l'interruption d'un periphérique
PCI peut quelque fois être modifiée, non pas en envoyant l'interruption sur
un fil différent, mais en modifiant le routage d'un envoi sur ce film en
programmant le PIR. Quand le routage est modifié, l'interruption fournie
par ce nouveau routage est écrit dans un registre de configuration situé
dans le composant du périphérique.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N11153" />8.2. Historique : des interruptions ISA aux PCI</h3></div></div></div><p>Avant l'arrivée du bus PCI, les PC utilisaient le bus ISA. Ensuite, lors
de la transition vers le nouveau bus PCI, les PC utilisaient les bus ISA et PCI.
Le bus ISA est fait de telle façon que toutes les lignes d'interruption arrivent
sur chaque carte, donc toute carte peut modifier son numéro d'IRQ tout simplement
en envoyant son signal d'interruption sur la ligne souhaitée. Tous les signaux
d'interruption étaient envoyés au contrôleur d'interruption qui envoyait
ensuite un signal au processeur pour lui indiquer de stopper temporairement son
travail et de lancer le code du pilote pour répondre à l'interruption.</p><p>Quand le PCI est apparu, la solution simple était d'établir une
correspondance entre les interruptions PCI et les interruptions ISA qui
n'étaient pas utilisées. Ceci nécessite l'utilisation du PIR, routeur
programmable d'interruptions. Ce routeur réalise la correspondance. Comme
il n'y avait que 15 interruptions, il était commun de placer plusieurs
périphériques PCI sur les quelques interruptions disponibles. Résoudre ce
problème est simple : proposer un nouveau matériel pour augmenter le
nombre d'interruptions. Le résultat est l'APIC. Son adoption a été lente car
la capacité du bus PCI à partager les interruptions a diminué le problème.
En fait, l'APIC a été principalement utilisé avec les machines bi-processeurs.
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N1115A" />8.3. Contrôleur avancé d'interruptions programmées
  (<acronym class="acronym">APIC</acronym>, acronyme de <span class="foreignphrase"><em class="foreignphrase">Advanced Programmable
  Interrupt Controller</em></span>)</h3></div></div></div><p>Un APIC peut fournir (suivant le modèle) 16, 24, 32 ou 64
interruptions, etc. Il peut aussi gérer le routage d'interruptions d'un
processeur vers un autre. Voir le fichier « IO-APIC » dans le répertoire
i386 de la documentation du noyau et le guide pratique sur l'ACPI.
Ne confondez pas APIC avec ACPI (Configuration avancée et interface pour la
gestion d'énergie) qui peut être utilisé par le noyau pour configurer l'APIC.
</p><p>Le contrôleur APIC actuel qui est connecté sur les lignes d'interruptions
est un APIC I/O (ou IO-APIC ou IOAPIC). En utilisant plus d'un IO-APIC, on
peut obtenir plus d'interruptions et elles sont numérotées de façon à être
uniques. Par exemple, le premier contrôleur peut les numéroter de 0 à 23 et le
second les appelera de 24 à 47, ce qui donne 48 interruptions numérotées de 0
à 47. Mais certaines personnes ont des numéros d'interruptions hauts. Se
pourrait-il que le deuxième IO-APIC commence la numérotation avec un numéro de
base haut, laissant ainsi beaucoup d'IRQ inexistants. ?</p><p>En plus des IO-APIC, il existe des APIC locaux (LAPIC) qui font partie de
chaque processeur. L'IO-APIC travaille en communiquant avec les LAPIC compris
dans les processeurs.</p><p>Quand APIC a été introduit, les anciens PIC ISA étaient aussi conservés
en laissant le choix d'utiliser ou non l'APIC ou le PIC ISA (qui est quelque fois
appelé PIC ou XT-PIC dans <span class="emphasis"><em>/proc/interrupts</em></span> ; le
XT vient du PC XT d'IBM qui était le second modèle de PC d'IBM en 1983).
Il est possible de dire au noyau (sur la ligne de commande du noyau) de ne pas
utiliser APIC auquel cas il utilisera le vieux XT-PIC s'il est disponible. Comme
l'APIC peut avoir plus d'interruptions que les 15 fournies par XT-PIC, il pourrait
y avoir des problèmes ??</p><p>Pour savoir si vous utilisez PIC ou APIC, regardez dans <span class="emphasis"><em>/proc/interrupts</em></span>.
Si vous voyez <span class="emphasis"><em>XT-PIC</em></span> pour l'IRQ 2 seule et
<span class="emphasis"><em>IO-APIC</em></span> pour les autres, cela pourrait signifier que vous
avez l'ancien XT-PIC mais qu'il n'est pas actuellement utilisé. En fait, l'IRQ
2 est utilisé pour la communication entre les deux anciens XT-PIC juste au cas
où vous en auriez besoin après avoir désactiver l'APIC. Deux XT-PIC sont
nécessaires car chacun supportent seulement huit interruptions.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N11179" />8.4. Interruptions signalées par message (MSI)</h3></div></div></div><p>Un autre nouveau développement concerne les interruptions signalées par
message (MSI, acronyme de <span class="foreignphrase"><em class="foreignphrase">Message Signalled
Interrupts</em></span> (MSI) où l'interruption est juste un message
envoyé à une adresse spéciale sur le bus principal de l'ordinateur (pas
de ligne d'interruption nécessaire). Mais le périphérique qui envoie un
tel message doit tout d'abord obtenir le contrôle du bus principal de
façon à ce qu'il puisse envoyer le message d'interruption. Un tel
message contient plus d'informations que « <span class="quote">J'envoie une
interruption</span> ». Il contient un index pour l'adresse du programme qui
a besoin d'être exécuté pour remplir la mission de l'IRQ. Ce nombre, par
exemple 3, signifie que le processeur trouve l'adresse à laquelle il doit
se rendre dans le troisième élément d'une table spéciale connue du
processeur.</p><p>Comme le matériel du périphérique doit connaître MSI pour que le
périphérique utilise MSI, il est fréquent que certains périphériques
utilisent MSI alors que d'autres utilisent les interruptions traditionnelles.
Since for a device to use MSI the device hardware must support MSI,
Les méthodes conventionnelles du support matériel des interruptions (appelées
INTx) seront donc certainement présentes pendant longtemps encore. Les MSI
ont des numéros d'interruption comme les interruptions INTx mais ces nombres
sont souvent trop grands pour éviter toute réutilisation des nombres des
interruptions INTx.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N11186" />8.5. Partage des interruptions PCI</h3></div></div></div><p>Les interruptions PCI peuvent être partagées, signifiant que deux
périphériques voire plus utilisent la même IRQ. C'est faisable, il est
généralement préférable de ne pas les partager. Le partage ne fonctionne pas
bien pour les très anciens matériels PCI (avant 1995 ?) et pour les
matériels PCI défectueux dès l'usine (ils ont été créés ainsi). Par exemple,
si un périphérique PCI sur l'IRQ 9 réclamait par erreur que toute IRQ 9
était pour lui, alors les autres périphériques utilisant l'IRQ 9 verraient
toutes leurs demandes d'interruption ignorées. Sans partage, ce problème est
évité.</p><p>Pour un exemple de partage d'une même IRQ entre deux périphériques 
PCI, voir <a class="link" href="#pci_irq_share">Partage d'interruption 
PCI</a>. Cette capacité de partage est intégrée au matériel et tous 
les pilotes de périphériques sont supposés la supporter. Notez que vous 
ne pouvez pas habituellement partager la même interruption entre le bus 
PCI et le bus ISA. </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N11191" />8.6. Recherche dans les tables de routage</h3></div></div></div><p>Certaines informations sont fournies par les messages au démarrage. Elles
sont visibles grâce à l'outil « <span class="quote">dmesg</span> ». Les façons de rechercher les
tables impliquent du logiciel que vous pourriez ne pas avoir (ou qui n'existe
pas encore). Pour vérifier le routage qu'effectue PCI vers les 16 interruptions
ISA, utiliser « <span class="quote">pirtool</span> » qui affiche la table de routage $PIR. Si
vous avez un APIC avec un routage en dur (pas de PIR), utiliser
« <span class="quote">mptable</span> » pour rechercher dans la table MP. Pour un APIC routable,
des méthodes ACPI _PRT sont utilisables pour accéder à une table (mais je ne sais
pas si un outil en ligne de commande existe pour cela ?)</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N1119F" />8.7. Pour plus d'informations</h3></div></div></div><p>Des informations techniques détaillées sur les interruptions sont
disponibles, par exemple « <a class="ulink" href="http://people.freebsd.org/~jhb/papers/bsdcan/2007/article/article.html" target="_top">Les
interruptions PCI pour les machines x86 sous FreeBSD</a>. Microsoft a
un document intitulé « <a class="ulink" href="http://www.microsoft.com/whdc/system/sysperf/apic.mspx" target="_top">L'importance de
l'implémentation des sous-systèmes d'interruptions basées sur APIC sur les PC
mono-processeur"</a> ».</p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="N111AD" />9. Lier les interruptions PCI</h2></div></div></div><p>Voici quelques détails sur le système d'interruptions PCI. Chaque carte
PCI (et les périphériques montés sur la carte-mère) a quatre interruptions
possibles : INTA#, INTB#, INTC#, INTD#. À partir de maintenant, nous les
appelerons simplement A, B, C et D. Chacune a sa propre broche sur le connecteur
d'une carte PCI. Donc, pour un système comprenant sept emplacements (pour sept
cartes), il pourrait y avoir 28 (7 x 4) différentes lignes d'interruption pour
ces cartes. Les périphériques intégrés à la carte-mère ont aussi des
interruptions supplémentaires. Mais les spécifications permettent un nombre plus
réduit de lignes d'interruption, donc certains bus PCI semblent n'avoir que
quatre ou huit lignes d'interruption. Ceci n'est pas trop restrictif car les
interruptions pourraient être partagées. Pour une ligne à quatre interruptions
(LNKA, LNKB, LNKC, LNKD), il y a un composant appelé « <span class="quote">routeur programmable
d'interruptions</span> » qui redirige LNKA, LNKB, LNKC, LNKD vers les IRQ
sélectionnées. Ce routage peut être modifié par le BIOS ou par Linux. Par
exemple, LNKA peut être routé vers l'IRQ 5. Supposons que nous désignons
l'interruption B de l'emplacement 3 comme l'interruption 3B. Les interruptions
3B et 2A pourraient être connectées de façon permanente à LNKA qui est routé
vers l'IRQ 5. Ces deux interruptions, 3B et 2A, sont partagées en permanence
par le cablage sur la carte-mère.</p><p>Saisir <span class="command"><strong>dmesg</strong></span> sur la ligne de commande permet
de voir comment les lignes d'interruption style LNKA sont redirigées (ou
routées) vers les IRQ (*5 signifie que c'est lié à l'IRQ 5). Recherchez
<span class="foreignphrase"><em class="foreignphrase">PCI Interrupt Link</em></span>. Notez que « <span class="quote">link</span> »
est utilisé ici avec deux significations : 1. le lien (routage) des lignes
d'interruptions PCI vers les les IRQ, 2. le label d'une ligne d'interruption
comme LNKB (lien B). Les labels de la ligne d'interruption semblent être fournis
par le BIOS (??) et pourraient avoir des noms différents comme : LNKC,
LNK2, APCF, LUBA, LIDE, et cætera. Question : quand un grand nombre de lignes
d'interruption sont affichées comme étant désactivées, existent-elles toutes
physiquement sur la carte-mère ? ou existent-elles seulement dans la partie
ACPI du BIOS pour que ce dernier puisse fonctionner avec les cartes-mères qui
ont un grand nombre de lignes d'interruption ?</p><p>Connecter toutes les interruptions A (INTA#) à la ligne LNKA, toutes les
B à la ligne LNKB, et cætera. est une méthode simple pour connecter en dur ces
lignes des périphériques PCI (comme le 3B) aux interruptions LNKA, et cætera.
Cette méthode a été utilisée une fois plusieurs années auparavarant mais
ce n'est pas la bonne solution. Voici pourquoi. Si une carte a seulement besoin
d'une interruption, elle doit utiliser A. Si elle a besoin de deux interruptions,
elle doit utiliser A et B. Du coup, INTA# est utilisé bien plus fréquemment que
INTD#. Donc, on va se trouver avec un nombre excessif d'interruptions
partageant la première ligne (LNKA connecté à toutes les INTA#). Pour dépasser
ce problème, il vaut mieux les connecter de façon aléatoire pour que chacune
des quatre lignes d'interruptions (LNKA, LNKB, LNKC, LNKD) partagent à peu près
le même nombre d'interruptions PCI.</p><p>Une façon de le faire est de lier en dur LNKA avec les interruptions
1A, 2B, 3C, 4D, 5A, 6B, 7C. Ceci se fait en connectant physiquement le fil W
aux fils 1A, 2B, et cætera. De la même façon, le fil LNKB pourrait être connecté aux
fils 1B, 2C, 3D, 4A, 5B, 6C, 7D, et cætera. Puis, au démarrage, le BIOS dirige les LNKB,
LNKA, LNKC, LNKD aux IRQ. Après cela, il écrit l'IRQ que chaque périphérique
utilise dans un registre de configuration du matériel dans chaque périphérique.
À partir de maintenant, tout programme interrogeant ce registre peut savoir l'IRQ
utilisée par le périphérique. Notez qu'écrire simplement l'IRQ dans un registre
sur une carte PCI ne configure en aucun cas l'IRQ pour ce périphérique.</p><p>Une utilisation pratique de cette information est qu'en dernier ressort,
une personne pourrait modifier les IRQ d'une carte PCI en l'insérant dans un
emplacement différent. Dans l'exemple ci-dessus, INTA# d'une carte PCI sera
connecté au fil LNKA si la carte est insérée dans l'emplacement 1 (1A correspond
à LNKA) mais INTA# sera connecté au fil LNKB si elle est insérée dans
l'emplacement 4 (4A correspond à LNKB).</p><p>Une carte dans un emplacement pourrait avoir jusqu'à huit périphériques
mais il n'y a que quatre interruptions PCI pour elle (A, B, C, D). Cela suffit
car les interruptions pourraient être partagées pour que chacun des huit
périphériques (s'ils existent) puisse avoir une interruption partagée. La lettre de
l'interruption PCI d'un périphérique est souvent fixée et codée en dur dans le
périphérique. L'affectation des interruptions est réalisée par soit le BIOS ou
par Linux, établissant une correspondance entre les interruptions PCI et les
interruptions ISA comme mentionné ci-dessus.</p><p>S'il n'existe que quatre lignes (LNKA, LNKB, LNKC, and LNKD) comme dans
l'exemple ci-dessus, les choix de correspondance pour le BIOS sont limités.
Certaines cartes-mère peuvent utiliser plus de lignes et ont donc plus de choix.
Par exemple, de LNKA à LNKH (8 lignes). Les messages au démarrage
(<span class="command"><strong>dmesg</strong></span>) peuvent les afficher et indiquer leur
correspondance. Le BIOS sait comment elles sont câblées.</p><p>Sur le bus PCI, le BIOS (ou Linux) affecte des IRQ (interruptions) de
façon à éviter les conflits avec les IRQ qu'il sait affectés au bus ISA.
Quelque fois, le menu du CMOS du BIOS peut vous autoriser à affecter des IRQ
aux cartes PCI ou indiquer au BIOS les IRQ réservées aux périphériques ISA.
Les affectations sont connues sous le nom d'une table de routage. Sous MS
WIndows, c'est appelé <span class="foreignphrase"><em class="foreignphrase">IRQ steering</em></span> mais cela
couvre aussi le cas d'un routage dynamique des IRQ après le démarrage. Le
BIOS peut supporter son propre <span class="foreignphrase"><em class="foreignphrase">IRQ steering</em></span>.
</p><p>Si votre PC utilise les interruptions PCI qui sont renvoyées vers des
interruptions ISA, vous auriez le droit de penser que les interruptions seront
lentes étant donné que le bus ISA était lent. Pas vraiment. Le
composant de contrôle des interruptions ISA a un fil d'interruption direct le
reliant au CPU pour qu'il obtienne une attention immédiate. Bien que les signaux
sur les bus d'adresses et de données de l'ancien ISA sont lents pour arriver au
CPU, les signaux d'interruptions y arrivent rapidement.</p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="N111D9" />10. <acronym class="acronym">PnP</acronym> pour les périphériques externes et
ajoutés</h2></div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N111DE" />10.1. Bus <acronym class="acronym">USB</acronym></h3></div></div></div><p>L'USB (<span class="foreignphrase"><em class="foreignphrase">Universal Serial Bus</em></span>, c'est-à-dire
Bus Universel Série) est un bus à grande vitesse sur un câble externe qui se
connecte au PC. Le bus externe a ses propres protocoles de communication et
n'utilise pas les <acronym class="acronym">IRQ</acronym>, adresses d'entrées/sorties (ou tout
autre ressource bus) sur les câbles bus externes. La communication se fait par
paquets comme sur Internet, seulement sur des allocations de tranches de temps,
ce qui empêche un périphérique de manger le bus si d'autres périphériques en ont
besoin. Il existe des tranches de temps libre qui permettent à tout périphérique
d'envoyer un message court au contrôleur de bus sans avoir besoin des
<acronym class="acronym">IRQ</acronym> sur le bus.</p><p>Néanmoins, le contrôleur de bus <acronym class="acronym">USB</acronym> intégré au PC a une
<acronym class="acronym">IRQ</acronym> et une adresse sur le bus <acronym class="acronym">PCI</acronym> (ou
<acronym class="acronym">ISA</acronym>), utilisées pour la communication entre le CPU et tous
les périphériques <acronym class="acronym">USB</acronym>. Donc, il n'y a pas d'allocations de
ressources nécessaires pour les périphériques individuels sur le bus
<acronym class="acronym">USB</acronym>. Vous pouvez aussi imaginer que tous les périphériques
sur le bus <acronym class="acronym">USB</acronym> partagent la même interruption et la même
adresse. Si un périphérique est sur l'USB, il a besoin d'un pilote qui
comprenne l'USB.</p><p>Mais, chaque périphérique <acronym class="acronym">USB</acronym> a un identifiant, comme
les cartes du bus <acronym class="acronym">PCI</acronym>. Linux maintient donc une table des
identifiants de façon
à ce que les pilotes de périphérique puissent les vérifier et trouver ainsi leur
périphérique. L'USB supporte aussi le « <span class="quote">hot plug</span> ». Pour trouver ce
qui est placé sur le bus <acronym class="acronym">USB</acronym>, vous pouvez utiliser un outil
généraliste de détection de matériel comme <span class="command"><strong>discover</strong></span> ou
<span class="command"><strong>hwinfo</strong></span>.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N1121B" />10.2. Hot Plug</h3></div></div></div><p>« <span class="quote">Hot plug</span> » correspond à la connexion d'un périphérique sur un
PC (habituellement avec un câble) et à sa détection immédiate. Si nécessaire, il
est configuré avec les ressources bus. Son pilote est aussi lancé, peut-être en
chargeant le module correspondant. Pour que ceci fonctionne, le matériel utilisé
doit être conçu de façon approprié. Vous pouvez utiliser cette fonctionnalité
avec certaines cartes <acronym class="acronym">PCI</acronym> (Cardbus), périphériques
<acronym class="acronym">USB</acronym> et <acronym class="acronym">IEEE</acronym> 1394 (Firewire).</p><p>Lorsqu'un nouveau périphérique est détecté, ses registres sont lus de
façon à récupérer un numéro d'identifiant du périphérique. Pour trouver un
pilote, Linux doit maintenir une table réalisant la correspondance entre numéro
de périphérique et pilote. Cette table existe dans le noyau depuis la version
2.4. Elle est nommée MODULE_DEVICE_TABLE.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N1122D" />10.3. Hot Swap</h3></div></div></div><p>« <span class="quote">Hot Swap</span> » vous permet de remplacer un ancien périphérique
en l'enlevant et en branchant le nouveau. Vous avez donc interverti
(<span class="foreignphrase"><em class="foreignphrase">swapped</em></span>) les périphériques. Maintenant, en plus
d'être capable de détecter le branchement d'un nouveau périphérique, la
suppression d'un ancien périphérique doit aussi être détectée.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N11237" />10.4. <acronym class="acronym">PnP</acronym> détecte les périphériques connectés aux
ports séries</h3></div></div></div><p>Les périphériques externes connectés par le port série via un câble (comme
les modems externes) sont aussi appelé Plug-and-Play. Comme seul le port série a
besoin de ressources bus (une <acronym class="acronym">IRQ</acronym> et une adresse
d'entrées/sorties), il n'y a pas de ressources bus à allouer pour ces
périphériques. Dans ce cas, <acronym class="acronym">PnP</acronym> est utilisé uniquement pour
l'identification du modem (lire le numéro/code du modèle). Ceci est important
dans le cas où ce modem est un modem logiciel (linmodem) et requiert un pilote
spécifique. Il existe une spécification <acronym class="acronym">PnP</acronym> pour de tels
périphériques séries externes (quelque chose connecté au port série).</p><p>Linux ne supporte pas encore ceci ? Pour un modem matériel, le pilote
série
ordinaire suffira, donc il n'y a pas besoin de chercher un pilote avec
<span class="command"><strong>serialpnp</strong></span>. Vous devez toujours indiquer au programme de
communication sur quel port se trouve le modem. Avec <acronym class="acronym">PnP</acronym>,
vous n'auriez même pas besoin de faire ça. Avec l'arrivée des modems logiciels
disposant de pilotes Linux (linmodem), il serait bien que les pilotes appropriés
s'installent automatiquement via <acronym class="acronym">PnP</acronym>.</p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="N11253" />11. Messages d'erreurs</h2></div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N11256" />11.1. Unexpected Interrupt (Interruption inattendue)</h3></div></div></div><p>Ceci signifie qu'une interruption est survenue alors qu'aucun pilote ne
l'attendait. Il est improbable que le matériel ait généré une interruption par
erreur. Il est plus probable que le logiciel comporte un petit bogue et n'a pas
réalisé qu'un logiciel a fait quelque chose qui a généré cette interruption.
Dans la plupart des cas, vous pouvez ignorer ce message en toute sécurité,
et tout particulièrement si cela n'est arrivé qu'une ou deux fois lors du
démarrage. Pour les messages du démarrage, regardez les messages qui lui sont
proches pour trouver une indication sur ce qui s'est passé. Par exemple, si
une recherche était en cours, il est possible que cela ait activé un
périphérique physique qui en retour a généré une interruption, interruption que
le pilote n'attendait pas. Le pilote n'écoutait peut-être pas le bon numéro
d'<acronym class="acronym">IRQ</acronym>.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N1125E" />11.2. Erreur de configuration Plug and Play (<acronym class="acronym">BIOS</acronym>
Dell)</h3></div></div></div><p>Le <acronym class="acronym">BIOS</acronym> a été incapable de configurer les ressources
bus. Il peut exister un conflit d'interruptions qui ne peut être évité. Dell
vous suggère que vous enleviez certaines des cartes non essentielles pour voir
si le problème disparaît. Dans un cas, le problème était dû à une carte mère
défectueuse.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N11269" />11.3. isapnp: Write Data Register 0xa79 already used (à partir des
journaux)</h3></div></div></div><p>Si vous utilisez isa-pnp, l'adresse d'entrées/sorties 0xa79 ne doit jamais
être utilisée par un périphérique, quel qu'il soit. Donc, si un autre matériel
utilise 0xa79 lorsque vous essayez de charger le module isa-pnp, vous obtiendrez
ce message dans vos journaux de trace et isa-pnp quittera. Une façon de corriger
cela est de charger le module isa-pnp bien plus tôt avant que tout autre
matériel ne soit initialisé. Pour le PCMCIA, ceci impose de charger isa-pnp
avant de lancer les modules cb et le service associé.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N1126E" />11.4. Impossible d'allouer la région (<acronym class="acronym">PCI</acronym>)</h3></div></div></div><p>Ici, « <span class="quote">région</span> » signifie un ensemble d'adresses. Un
périphérique <acronym class="acronym">PCI</acronym> qui a besoin de deux régions aura la
région 0 comme première adresse et la région 1 pour deuxième adresse. Utilisez
la commande <span class="command"><strong>lspci --v</strong></span> pour voir les différentes régions
de ressources (souvent appelé régions) et si l'adresse est de type
entrée/sortie ou mémoire. Dans le jargon <acronym class="acronym">PCI</acronym>, la région 2
est l'« <span class="quote">adresse de base 2</span> » (ou « <span class="quote">registre d'adresse de base
2</span> »), et cætera.</p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="N11289" />12. Partage et conflit d'interruption</h2></div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N1128C" />12.1. Introduction</h3></div></div></div><p>Quand deux périphériques ou plus utilisent la même ligne d'interruption,
(et le même numéro d'IRQ), il s'agit soit d'un « <span class="quote">partage
d'interruption</span> » soit d'un « <span class="quote">conflit d'interruption</span> ».
Le bus PCI autorise tous les périphériques PCI à partager des interruptions
avec les autres, ce qui est appelé le partage. Mais si un périphérique ISA
(ou un périphérique LPC ??) utilise la même interruption
(IRQ) qu'un autre périphérique (PCI, ISA ou LPC ??), il y habituellement
un conflit d'interruption.</p><p>Il existe des exceptions. Certains périphériques PCI très anciens
(pré-1995) ne permettent pas le partage d'interruption. À contrario, quelques
périphériques ISA ont été conçus pour partager les interruptions (entre deux
périphériques ISA ?) mais ces deux périphériques ISA doivent être conçus
de cette façon et être pilotés par du logiciel au courant du partage des
interruptions. La carte-mère doit aussi le supporter. La discussion suivante
se rapporte aux PC qui ont un bus ISA.</p><p>Un conflit signifie que, quand une interruption survient, aucun pilote de
périphérique (ou le mauvais) ne sera appelé. Cela peut aboutir à de mauvaises
actions comme des dépassements de tampon (perte de données). Un périphérique
peut presque immobiliser sa ligne d'interruption quand il n'envoie pas son
interruption, et de ce fait empêcher tout autre dispositif d'employer cette
ligne d'interruption. Cela ne pose pas de problème seulement si seul ce
périphérique utilise cette interruption mais si un deuxième périphérique essaie
d'utiliser la même ligne d'interruption, il ne pourra plus le faire. Si ce
second périphérique immobilise aussi la ligne lorsqu'il n'envoyait pas
d'interruption, alors aucun des deux périphériques ne peut utiliser
l'interruption. Linux et les deux périphériques sont inconscients de ce conflit
et continuent à envoyer les interruptions qui vont nul part et sont donc
perdus.</p><p>Les conflits d'interruptions étaient communs quand les IRQ étaient
configurées grâce à des cavaliers sur les cartes (bus ISA), souvent parce que
le noyau ne connaissait pas la configuration de ces cavaliers. Le Plug-and-Play
ISA (aucun cavalier) a beaucoup aidé car le logiciel pouvait modifier les
IRQ. L'abandon d'ISA en faveur du PCI a pratiquement éliminé les conflits
IRQ. Malgré tout, votre PC peut toujours avoir des périphériques sur la
carte-mère (pas sur une carte fille) sur un bus ISA, LPC ou X. Mais le BIOS et
le noyau devraient savoir comment les configurer et donc éviter de les utiliser
pour les périphériques PCI, évitant ainsi les conflits d'interruption.
Mais il existe toujours un problème avec PCI car il peut manquer d'interruptions
disponibles, tout spécialement sur les anciens PC qui ont seulement 16
interruptions.</p><p>Mais, bien qu'ayant éliminé le problème des conflits, le partage d'IRQ
sur le bus PCI a introduit un nouveau problème qui est moins sérieux, le problème d'équilibre des
IRQ. Si des périphériques utilisant beaucoup les interruptions partagent la
même IRQ, cela pourrait amener des délais dans la récupération des IRQ et
pourrait même amener à des dépassements de tampon et d'autres erreurs. Ceci
n'est pas dû à la façon dont le logiciel détermine le périphérique qui a
lancé cette interruption.</p><p>Il existe deux types de conflits d'interruptions. Le premier est un
vrai conflit, celui décrit ci-dessus. Dans ce cas, les interruptions ne
fonctionnent plus et le pilote de périphérique continue d'essayer de contrôler
son périphérique et ne sait pas que les interruptions ne fonctionnent pas. Le
second type de conflit d'interruption arrive quand un pilote de périphérique
est lancé mais découvre que l'interruption dont il a besoin est déjà utilisé.
Il affiche un message d'erreur et quitte. Le message indique quelque chose
comme « ressource en cours d'utilisation » (« ressource busy ») mais ne
précise pas clairement qu'il s'agit d'un problème d'interruption.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N112A1" />12.2. Vrai conflit d'interruption</h3></div></div></div><p>Le BIOS et le noyau ne vont pas permettre un conflit d'interruptions en
connaissance de cause. Alors comment cela peut-il arriver ? Une façon
d'y parvenir arrive quand quelqu'un a indiqué un mauvais IRQ dans un fichier
de configuration, par exemple en donnant un paramètre « irq=9 » à un module.
Dans cet exemple, supposons que l'IRQ du périphérique est réellement le 5.
Quand un autre pilote de périphérique se lance et trouve son périphérique à
l'IRQ 5, vous avez deux vrai périphériques utilisant la même IRQ, ce qui
aboutit à un vrai conflit. Le noyau a approuvé l'utilisation de l'IRQ 5 par
le second périphérique car il a été trompé et pensait que le premier
périphérique était sur l'IRQ 9.</p><p>Il existe d'autres cas où le noyau ne sait pas qu'une IRQ est utilisée.
Par exemple quand une ancienne carte ISA est configuré par un cavalier mais
que son pilote n'est pas encore lancé (il peut même ne pas voir de pilote).
Un autre cas, le BIOS configure un IRQ au niveau matériel mais aucun pilote
Linux n'est lancé pour ce matériel. Linux ne connaîtra donc pas cette IRQ.
Ceci peut même arriver pour une carte PCI, celle-ci s'affichera avec la
commande <span class="emphasis"><em>lspci -v</em></span> mais ne sera pas disponible dans le
répertoire <span class="emphasis"><em>/proc/interrupts</em></span> et n'est donc pas connue par
le noyau. Est-ce un bogue du noyau ?</p><p>Quels sont les symptômes d'un conflit d'interruption ?
On pourrait penser que les périphériques ne fonctionnent pas du tout mais
comme les adresses sont connues, le pilote peut communiquer. Les interruptions
sont souvent utilisées pour contrôler le flux de données provenant et allant
au périphérique. Sans les interruptions, le flux n'est pas contrôlé, ce qui
signifie des dépassements de tampon, voire même pas de flux du tout, les
interruptions pouvant aussi être utilisées pour initier le flux. Pour un modem
série, le résultat est un flux extrêmement lent avec de longues pauses et des
erreurs fréquentes. Pour une carte son, cela pourrait signifier qu'un mot ou
deux sont entendus, puis plus rien.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N112B0" />12.3. Aucune interruption disponible</h3></div></div></div><p>Ceci arrive quand un pilote de périphérique est lancé mais quitte
immédiatement pour éviter un conflit d'interruption. Généralement, il
affiche un message d'erreur comme « ressource en cours d'utilisation » ou
l'enregistre dans un journal de trace.</p><p>Un cas où un périphérique ISA est activé et ne peut se voir 
affecté une interruption (IRQ) car aucune n'est disponible. Ou une 
interruption pourrait être disponible mais ne peut pas être utilisée car 
le matériel du périphérique qui a besoin de cette interruption ne sait 
pas gérer le numéro disponible ou la carte mère ne le supporte pas non 
plus à cause de problèmes de routage (voir <a class="link" href="#pci_int" title="8. Interruptions PCI">PCI 
Interrupts</a>). Si les périphériques ISA utilisent toutes les 
interruptions, alors une ou plusieurs cartes PCI pourraient être en 
conflit car elles ne peuvent pas obtenir d'IRQ.</p><p>Normalement, le <acronym class="acronym">BIOS</acronym> affectera des interruptions et ne
créera pas de conflits.  Mais il pourrait être forcé de créer des conflits
s'il tombe à court d'<acronym class="acronym">IRQ</acronym>. Ceci peut survenir si quelqu'un a
configuré le <acronym class="acronym">BIOS</acronym> pour réserver certaines <acronym class="acronym">IRQ</acronym>
pour les périphériques <acronym class="acronym">ISA</acronym> qui ne sont pas
<acronym class="acronym">PnP</acronym>. Ces paramétrages pourraient être mauvais et devraient
être vérifiés, tout spécialement si vous avez des problèmes. Par exemple,
quelqu'un pourrait avoir réservé une <acronym class="acronym">IRQ</acronym> pour une carte
<acronym class="acronym">ISA</acronym> qui a été enlevé du PC depuis longtemps. Si vous récupérez
cette <acronym class="acronym">IRQ</acronym>, alors elle est disponible et un conflit disparaît.
</p><p>Quelque fois, le <acronym class="acronym">BIOS</acronym> résoudra le problème du manque
d'<acronym class="acronym">IRQ</acronym> en utilisant ce qu'il appelle l'<acronym class="acronym">IRQ</acronym>
0. Elle n'existe pas car la vrai <acronym class="acronym">IRQ</acronym> 0 est affectée en
permanence à l'horloge de l'ordinateur mais signifie que le pilote devrait
utiliser la demande au lieu des
<acronym class="acronym">IRQ</acronym>. Ceci signifie que le pilote devra vérifier fréquemment
le périphérique (lui demander) pour voir si le périphérique a besoin d'un service
de la routine d'interruptions. Bien sûr, cela gâche du temps processeur et il y
a plus de risques d'un dépassement de tampon du périphérique
car il pourrait ne pas être servi assez rapidement par le pilote.</p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="N112E9" />13. Annexe</h2></div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="UPnP_" />13.1. Universal Plug and Play
(<acronym class="acronym">UPnP</acronym>)</h3></div></div></div><p>C'est en quelque sorte un réseau Plug-and-Play développé par Microsoft
mais utilisable sous Linux. Vous connectez quelque chose sur un réseau et ce
quelque chose n'a pas besoin d'être configuré mais ne va communiquer qu'avec des
périphériques <acronym class="acronym">UPnP</acronym> du réseau. Ici, « <span class="quote">configurer</span> »
est utilisé
dans le sens large et ne signifie pas simplement configurer les ressources bus.
Un des objectifs est de permettre au gens connaissant peu de choses sur les
réseaux ou sur la configuration et l'installation d'un routeur, d'une
passerelle, d'une imprimante réseau, et cætera de le faire. Une 
utilisation majeure de <acronym class="acronym">UPnP</acronym> serait dans les réseaux 
sans-fil.</p><p><acronym class="acronym">UPnP</acronym> utilise :
<div class="itemizedlist"><ul><li><p>un protocole de découverte des services (<span class="foreignphrase"><em class="foreignphrase">Simple
Service
    Discovery Protocol</em></span>) pour trouver les
périphériques,</p></li><li><p>une architecture de notification générale d'événements
    (<span class="foreignphrase"><em class="foreignphrase">General Event Notification
Architecture</em></span>),</p></li><li><p>un protocole d'accès aux objets (<span class="foreignphrase"><em class="foreignphrase">Simple Object
Access
    Protocol</em></span>) pour assurer le contrôle des
périphériques.</p></li></ul></div>
</p><p>

Ce guide pratique ne couvre pas U<acronym class="acronym">PnP</acronym>.
<acronym class="acronym">UPnP</acronym> pour Linux est supporté par Intel qui a
développé un logiciel spécifique. Il existe d'autres programmes qui font
à peu près la même chose que <acronym class="acronym">UPnP</acronym>. Une comparaison de
ceux-ci est disponible sur <a class="ulink" href="http://www.cs.umbc.edu/~dchakr1/papers/mcommerce.html" target="_top">http://www.cs.umbc.edu/~dchakr1/papers/mcommerce.html</a>. Un projet
U<acronym class="acronym">PnP</acronym> pour Linux se trouve sur Sourceforge : <a class="ulink" href="http://sourceforge.net/projects/upnp/" target="_top">Kit U<acronym class="acronym">PnP</acronym> pour
Linux</a>

</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="address_details" />13.2. Détails des adresses</h3></div></div></div><p>Il existe trois types d'adresses : adresses en mémoire principale,
adresses
d'entrées/sorties (ports) et adresses de configuration. Sur le bus
<acronym class="acronym">PCI</acronym>, les adresses de configuration constituent une plage
d'adresses séparée un peu comme les adresses d'entrées/sorties. Sauf dans le
cas compliqué des adresses de configuration <acronym class="acronym">ISA</acronym>, qu'une
adresse sur le bus soit ou non une adresse en mémoire principale, une adresse
d'entrées/sorties ou une adresse de configuration dépend seulement du voltage
sur certains fils du bus. Pour plus de détails sur les adresses de configuration
du bus
<acronym class="acronym">ISA</acronym>, voir <a class="xref" href="#isa_conf_addresses" title="13.3. Adresses de configuration du bus ISA (Port de lecture et cætera)">Section 13.3, « Adresses de configuration du bus
<acronym class="acronym">ISA</acronym> (Port de lecture et cætera) »</a>.</p><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N11340" />13.2.1. Plages d'adresses</h4></div></div></div><p>Le terme « <span class="quote">adresse</span> » est quelque fois utilisé dans ce document
pour
signifier un ensemble contigu d'adresses. Les adresses sont en unité d'octets.
Donc, par exemple, un port série sur l'espace d'adressage 3F8-3FF sera souvent
juste référencé par son adresse de base, 3F8. 3F8 est l'emplacement du premier
octet de la plage (espace d'adressage). Pour visualiser les espaces d'adressage,
jetez un œil à <code class="filename">/proc/iomem</code> et
<code class="filename">/proc/ioports</code>.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N11350" />13.2.2. Plage d'adresses</h4></div></div></div><p>Pour accéder à la fois aux espaces d'adresses mémoire principale et
d'entrées/sorties, le même bus d'adresses est utilisé (les fils utilisés pour
l'adresse sont partagés). Comment le périphérique sait-il si l'adresse
apparaissant sur le bus est une adresse mémoire ou d'entrées/sorties ?
En fait, pour l'<acronym class="acronym">ISA</acronym> (pour le <acronym class="acronym">PCI</acronym>, lisez
aussi ceci), il existe quatre fils dédiés sur le bus
qui amènent ce type d'informations. Si un de ces quatre fils est
« <span class="quote">activé</span> », cela indique que le <acronym class="acronym">CPU</acronym> veut lire une
adresse
d'entrées/sorties et la mémoire principale ignore l'adresse sur le bus. En tout,
les fils de lecture et écriture existent à la fois pour les adresses de mémoire
principale et pour les adresses d'entrées/sorties (quatre fils en tout).</p><p>Pour le bus <acronym class="acronym">PCI</acronym>, il s'agit de la même idée de 
base (utilisant aussi quatre fils) mais réalisée un peu différemment. Au 
lieu d'avoir un seul des quatre fils activé, un nombre binaire est placé 
sur les fils (d'où 16 possibilités différentes). Donc, il est possible 
de véhiculer plus d'informations sur ces quatres fils. Quatre de ces 16 
nombres sont utilisés pour les espaces en mémoire principale et 
d'entrées/sorties comme indiqué dans le paragraphe ci-dessus. En plus, 
il existe aussi un espace d'adressage de configuration qui utilise plus 
de deux chiffres supplémentaires. Cela laisse dix autres nombres 
disponibles pour d'autres utilisations.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N11366" />13.2.3. Espace d'adresses pour la configuration
<acronym class="acronym">PCI</acronym></h4></div></div></div><p>Ceci est différent des espaces d'adresses mémoire et d'entrées/sorties
parce que l'espace d'adresses de configuration est « <span class="quote">géographique</span> ».
Chaque emplacement d'une carte a un numéro d'emplacement faisant parti de
l'adresse. De cette façon, Linux (ou le <acronym class="acronym">BIOS</acronym>) peut
adresser un certain emplacement et trouver le type de carte fiché dans
cet emplacement. Chaque périphérique a des registres standards de 64 bits
et quelques uns d'entre eux contiennent des numéros qui peuvent identifier
de façon non ambiguë le périphérique. Comme le nombre d'emplacements est limité
comme le sont le nombre de périphériques <acronym class="acronym">PCI</acronym> construit
dans la carte mère, Linux (ou le <acronym class="acronym">BIOS</acronym>) a besoin de
vérifier un nombre limité d'adresses pour trouver tous les périphériques
<acronym class="acronym">PCI</acronym>. S'il ne lit que des uns (0xFF en hexadécimal) à partir
du premier registre d'un périphérique, alors cela signifie qu'aucun périphérique
n'est présent. Comme il n'y a aucune carte ou périphérique fournissant tous les
numéros un (0xFF), le « <span class="quote">host bridge</span> » <acronym class="acronym">PCI</acronym> sur la
carte mère fournit ce numéro pour tous les périphériques inexistants.</p><p>Le numéro d'emplacement <acronym class="acronym">PCI</acronym> est appelé (dans le jargon
<acronym class="acronym">PCI</acronym> le numéro de périphérique et comme une carte peut avoir
au plus huit périphériques sur elle, un numéro de fonction (allant de 0 à 7)
identifie le périphérique qui se trouve sur une carte <acronym class="acronym">PCI</acronym>.
Ces numéros font partie de l'adresse géographique. Les développeurs Linux
l'appellent <span class="foreignphrase"><em class="foreignphrase">pci-slot-name</em></span>. Du coup, ce que
Linux appelle un périphérique est en fait une fonction dans le jargon
<acronym class="acronym">PCI</acronym>. Le numéro du bus <acronym class="acronym">PCI</acronym> (souvent 00)
devient aussi une partie de l'adresse géographique. Par exemple,
0000:00:0d.2 correspond au bus <acronym class="acronym">PCI</acronym> 0, emplacement 0, fonction
2. Pour l'adresse géographique complète, vous devez inclure le numéro sur deux
mots des registres de configuration du périphérique auquel on veut l'accès. Les
0000 en tête (en 1999) étaient réservés pour une utilisation future.</p><p>Comment le processeur désigne-t-il qu'une lecture ou une écriture doit
se faire dans l'espace de configuration <acronym class="acronym">PCI</acronym> ? Il ne le
fait pas, en tout cas pas directement. À la place lorsque l'accès à l'espace de
configuration est désiré, il fait une écriture sur 32 bits (un mot double) pour
écrire 0cf8-0cfb en espace d'entrées/sorties et écrit l'adresse géographique
complète ici. Le <span class="foreignphrase"><em class="foreignphrase">host bridge</em></span> <acronym class="acronym">PCI</acronym>
écoute à cette adresse et nous assure que la prochaine écriture de données sera
0cfc-0cff. C'est enregistré dans des registres de configuration du périphérique
spécifié. Le pont fait les deux en envoyant un signal spécial à la carte
<acronym class="acronym">PCI</acronym> spécifiée (ou ce qui y ressemble) sur un fil dédié qui va
seulement à l'emplacement où la carte est connectée. Il place aussi des bits sur
le bus de contrôle indiquant que ce qui est sur le bus d'adresse maintenant est
une adresse géographique de l'espace de configuration.</p><p>Pourquoi ne pas faire simple et demander simplement au processeur de
placer les
bits sur le bus de contrôle pour indiquer que l'adresse sur le bus principal est
une adresse géographique pour la configuration du <acronym class="acronym">PCI</acronym> ?
Et bien, la plupart des processeurs ne sont pas capables de le faire donc le
« <span class="quote">host bridge</span> » <acronym class="acronym">PCI</acronym> le fait à la place.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N113B3" />13.2.4. Vérification de la plage (test <acronym class="acronym">ISA</acronym> pour les
conflits d'adresses d'entrées/sorties)</h4></div></div></div><p>Sur le bus <acronym class="acronym">ISA</acronym>, il existe une méthode intégrée dans
chaque carte <acronym class="acronym">PnP</acronym> pour vérifier qu'aucune autre carte n'utilise
la même adresse d'entrées/sorties. Si deux cartes ou plus utilisent la même
adresse d'entrées/sorties, les cartes ont peu de chance de fonctionner
correctement (voire de fonctionner tout court). Un bon logiciel
<acronym class="acronym">PnP</acronym> devrait allouer les ressources bus de manière à éviter
ce conflit, mais même dans ce cas, une carte non <acronym class="acronym">PnP</acronym>
pourrait avoir la même adresse.</p><p>Le test fonctionne par une carte plaçant un nombre de test connu dans ses
propres registres d'entrées/sorties. Puis, le logiciel <acronym class="acronym">PnP</acronym>
le lit et vérifie que ce qu'il lit correspond bien au numéro de test connu. Il
répète le même test avec un autre numéro. Comme il vérifie l'ensemble des adresses
d'entrées/sorties allouées à la carte, il est appelé un vérificateur de plage.
Il pourrait être appelé plus logiquement un testeur de conflit d'adresses. Si un
conflit est détecté, vous obtenez un message d'erreur.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N113CC" />13.2.5. Communiquer directement via la mémoire</h4></div></div></div><p>Traditionnellement, la plupart des périphériques d'entrées/sorties
utilisent seulement la mémoire d'entrées/sorties pour communiquer avec le
processeur (<acronym class="acronym">CPU</acronym>). Le pilote de périphérique, exécuté sur le
processeur lira et écrira des données de/vers l'espace d'adressage des
entrées/sorties et la mémoire principale. Malheureusement, cela nécessite deux
étapes. Par exemple, 1. lire les données à partir d'un périphérique (en espace
d'adressage) et les stocker temporairement dans le CPU ; 2. écrire ces données
en mémoire principale. Une façon plus rapide serait que le périphérique place
lui-même les données directement en mémoire principale. Une façon de faire ceci
est d'utiliser <a class="xref" href="#dma_" title="2.7. DMA (accès direct à la mémoire) ou maîtrise du bus">Section 2.7, « <acronym class="acronym">DMA</acronym> (accès direct à la
mémoire) ou maîtrise du bus »</a> <acronym class="acronym">ISA</acronym> ou la maîtrise
du bus <acronym class="acronym">PCI</acronym>. Le périphérique physique peut aussi détenir un
peu de mémoire principale (aux adresses supérieures pour éviter
les conflits avec les adresses des composants de la mémoire principale). De
cette façon, le périphérique lit et écrit directement dans son espace mémoire
interne sans avoir à s'embêter avec le <acronym class="acronym">DMA</acronym> ou la maîtrise
du bus. De tels périphériques pourraient aussi utiliser des adresses
d'entrées/sorties.</p></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="isa_conf_addresses" />13.3. Adresses de configuration du bus
<acronym class="acronym">ISA</acronym> (Port de lecture et cætera)</h3></div></div></div><p>Ces adresses sont aussi connues comme les « <span class="quote">ports
d'auto-configuration</span> ».
Pour le bus <acronym class="acronym">ISA</acronym>, il n'existe pas techniquement de plage
d'adresses de configuration, mais le <acronym class="acronym">CPU</acronym> utilise une façon
spéciale d'accéder aux registres de configuration <acronym class="acronym">PnP</acronym> sur
les cartes <acronym class="acronym">PnP</acronym>. Dans ce but, trois adresses
d'entrées/sorties sont allouées et chacune adresse un seul octet (il n'y a pas
à proprement parler d'espace ou de plage). Il ne s'agit pas de trois adresses
pour chaque carte mais de trois adresses partagées par toutes les cartes
<acronym class="acronym">ISA</acronym>-<acronym class="acronym">PnP</acronym>.</p><p>Ces trois adresses sont nommées port de lecture
(<span class="foreignphrase"><em class="foreignphrase">read-port</em></span>), port d'écriture
(<span class="foreignphrase"><em class="foreignphrase">write-port</em></span>) et port d'adresse
(<span class="foreignphrase"><em class="foreignphrase">address-port</em></span>). Chaque port a une taille
d'un octet. Chaque carte <acronym class="acronym">PnP</acronym> dispose d'un grand
nombre de registres de configuration, donc même les trois adresses ne
sont pas suffisantes pour les registres de configuration d'une seule
carte. Pour résoudre ce problème, chaque carte se voit affecter un
numéro de carte en utilisant une technique appelée
« <span class="quote">isolation</span> ». Voir <a class="xref" href="#isolation_" title="13.6. Isolation ISA">Section 13.6, « Isolation <acronym class="acronym">ISA</acronym> »</a> pour des
détails plus complexes.</p><p>Ensuite, pour configurer une certaine carte, son numéro de carte est
envoyé via l'adresse du port d'écriture pour indiquer à cette carte qu'elle doit
écouter sur son port d'adresse. Toutes les autres cartes notent que ce n'est pas
leur numéro de carte et donc n'écoutent pas. Ensuite, l'adresse d'un registre de
configuration est envoyé sur le port d'adresse (à toutes les cartes, mais une
seule écoute). Enfin, le transfert de données prend place avec ce registre de
configuration sur cette carte soit en faisant une lecture sur le port de lecture
soit en faisant une écriture sur le port d'écriture.</p><p>Le port d'écriture est toujours A79 et le port d'adresse est toujours 279
(en hexadécimal). Le port de lecture n'est pas fixe mais dépend du logiciel de
configuration (tout en restant dans la plage 203-3FF) qui avec un peu de chance
n'entrera pas en conflit avec les autres cartes <acronym class="acronym">ISA</acronym>. Si un
conflit se déclare, il changera l'adresse. Toutes les cartes
<acronym class="acronym">PnP</acronym> sont « <span class="quote">programmées</span> » avec cette adresse. Donc,
si vous
utilisez <span class="command"><strong>isapnp</strong></span> pour enregistrer ou connaître la
configuration, celui-ci doit d'abord déterminer l'adresse du port de lecture.
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="interrupt_detail" />13.4. Détails sur les interruptions</h3></div></div></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N11427" />13.4.1. Interruptions sérialisées</h4></div></div></div><p>Il a été dit précédemment qu'il existe un fil pour chaque interruption.
Mais l'interruption sérialisée (ou interruption série) est une exception. Un
seul fil est utilisé pour toutes les interruptions qui sont multiplexées sur
ce fil. Chaque interruption a un créneau horaire sur la ligne d'interruption.
Il est utilisé sur le bus LPC mais aussi sur le bus PCI bien que cela soit plus
rare pour ce dernier ?</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N1142C" />13.4.2. <acronym class="acronym">DMA</acronym></h4></div></div></div><p>Avant de se plonger dans le détail des interruptions, il existe
une autre façon pour que les périphériques initient la communication en
dehors de l'envoi d'une interruption. Cette méthode est une requête
<acronym class="acronym">DMA</acronym>
(<span class="foreignphrase"><em class="foreignphrase">Direct Memory Access</em></span>) pour prendre le contrôle
de l'ordinateur à partir du CPU pour un temps limité. Sur le bus
<acronym class="acronym">PCI</acronym>, il
n'utilise aucune ressource. Tous les périphériques ne sont pas capables de
faire du <acronym class="acronym">DMA</acronym>. Voir <a class="xref" href="#dma_" title="2.7. DMA (accès direct à la mémoire) ou maîtrise du bus">Section 2.7, « <acronym class="acronym">DMA</acronym> (accès direct à la
mémoire) ou maîtrise du bus »</a>.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N11441" />13.4.3. Interruptions logicielles</h4></div></div></div><p>Il existe aussi un autre type d'interruption nommée « <span class="quote">interruption
logicielle</span> », non couverte par ce guide pratique et n'utilisant pas de
ressources. Alors qu'une interruption matérielle est générée par le matériel,
une interruption logicielle est initiée par le logiciel. Il existe plusieurs
façons pour ce faire. Une façon est que le logiciel dise au processeur
d'exécuter une interruption (une instruction d'interruption). Une autre façon
consiste, pour le logiciel, à envoyer des messages aux autres processus pour
les interrompre même s'il n'est pas clair qu'on puisse appeler ça une
interruption. Le processus ksoftirq process, que vous pouvez trouver dans la
liste des processus sur un PC Linux, est un programme qui lance ce type
d'interruption pour gérer les pilotes de périphériques. Le pilote de
périphérique commence à s'exécuter à cause d'une interruption matérielle mais,
plus tard, des interruptions logicielles sont utilisées pour la deuxième moitié
de la routine d'interruption du pilote. Donc, le processus ksoftirq est aussi
connu comme la « <span class="quote">seconde moitié</span> ». Pour plus de détails, voir la
documentation du noyau.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N1144C" />13.4.4. Interruptions matérielles</h4></div></div></div><p>Les interruptions amènent beaucoup d'informations mais seulement
indirectement. Le signal de demande d'interruption (un voltage sur un fil)
envoyé par un matériel
indique seulement au composant, appelé le contrôleur d'interruption, qu'un
certain périphérique demande l'attention. Le contrôleur d'interruption envoie
le signal au <acronym class="acronym">CPU</acronym>. Le <acronym class="acronym">CPU</acronym> s'interrompt
dans ce qu'il faisait, trouve le pilote de ce périphérique et exécute une
partie de celui-ci nommée « <span class="quote">routine d'interruption</span> » (ou
« <span class="quote">gestionnaire
d'interruption</span> »). Cette « <span class="quote">routine</span> » essaie de trouver ce qui
est arrivé et gère
ensuite le problème. Par exemple, le périphérique peut avoir besoin
d'envoyer/recevoir des octets. Ce programme (cette routine) peut
facilement comprendre ce qui s'est passé car le périphérique dispose de
registres disponibles sur des adresses connues par le pilote (à condition que
le numéro d'<acronym class="acronym">IRQ</acronym> et que les adresses d'entrées/sorties
soient correctement configurés). Ces registres contiennent l'état du
périphérique. Le logiciel lit le contenu de ces registres et en inspectant le
contenu, trouve ce qui est arrivé et réalise l'action appropriée.</p><p><a id="pci_irq_share" />Donc, chaque pilote de périphérique a besoin de savoir
le numéro d'interruption (<acronym class="acronym">IRQ</acronym>) où écouter. Sur le bus
<acronym class="acronym">PCI</acronym> (et dans certains cas spéciaux, sur le bus
<acronym class="acronym">ISA</acronym>), il est possible que deux (voire plus) périphériques
partagent le même numéro d'<acronym class="acronym">IRQ</acronym>. Notez que vous ne pouvez pas
partager une interruption <acronym class="acronym">PCI</acronym> avec une interruption
<acronym class="acronym">ISA</acronym> (y a-t'il des exceptions ?). Quand une interruption
partagée est lancée, le processeur exécute toutes les routines du service
d'interruption séquentiellement pour tous les périphériques utilisant cette
interruption. La première action qu'entreprend la première routine lancée est
de vérifier les registres du périphérique pour voir si une interruption a été
générée par son périphérique. S'il se trouve que ce n'est pas le cas (fausse
alarme), il s'arrêtera immédiatement et la prochaine routine commence pour le
deuxième périphérique qui utilise cette même interruption, et cætera. Il vérifie le
périphérique comme décrit ci-dessus. Cette séquence est répétée jusqu'à la
découverte du périphérique qui a lancé cette interruption. Toutes les routines
d'interruption pour une interruption constituent une chaîne. Donc, la chaîne
est traversée jusqu'à ce qu'une routine de la chaîne réclame l'interruption en
disant : cette interruption est pour moi. Après avoir géré l'interruption,
les routines suivantes du service d'interruption ne sont pas exécutées.</p><p>Mettre un certain voltage sur une ligne <acronym class="acronym">IRQ</acronym> revient
seulement à demander que le <acronym class="acronym">CPU</acronym> s'interrompe de façon à
exécuter la routine du pilote du périphérique. Dans pratiquement tous les cas,
le <acronym class="acronym">CPU</acronym> est interrompu par la requête. Mais les interruptions
du CPU peuvent être temporairement désactivées ou « <span class="quote">faire la queue</span> », et
donc, dans de rares cas, une interruption peut ne pas être gérée (ou peut subir
un certain délai). Donc, ce qui a été auparavant appelé une interruption est plus
précisément une « <span class="quote">demande d'interruption</span> », ce qui explique
l'acronyme d'<acronym class="acronym">IRQ</acronym> (« <span class="quote">Interrupt ReQuest</span> »,
c'est-à-dire ReQuête d'Interruption).</p></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N1148F" />13.5. Comment le pilote de périphérique récupère son
interruption</h3></div></div></div><p>L'indication précédente, à savoir que les pilotes de périphérique
écoutent leur interruption, était une explication très simplifiée.
En fait, il s'agit d'un composant (ou d'une partie d'un composant) embarqué
sur la carte-mère, appelé le contrôleur d'interruptions. Il va écouter toutes
les interruptions. Quand le contrôleur récupère une interruption, il envoie
un signal au CPU pour lancer la routine du service d'interruption du pilote
de périphérique approprié pour gérer cette interruption.</p><p>Il existe différents types de contrôleurs d'interruptions. L'un d'entre
eux est l'APIC (acronyme de Advanced Programmable Interrupt Controller) qui a
habituellement des broches en entrée pour un grand nombre d'interruptions, y compris les interruptions
PCI. Les anciens contrôleurs ont seulement des broches pour les interruptions
ISA mais ils peuvent toujours gérer les interruptions PCI car il s'agit d'un
routeur programmable d'interruptions qui convertit les interruptions PCI en
interruptions ISA et les envoie vers certaines broches (c'est-à-dire vers
certaines IRQ).</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="isolation_" />13.6. Isolation <acronym class="acronym">ISA</acronym></h3></div></div></div><p>C'est uniquement pour l'ancien bus <acronym class="acronym">ISA</acronym>. L'isolation est
une méthode complexe d'affectation d'un point temporaire (numéro
d'identifiant ou <acronym class="acronym">CSN</acronym>, <span class="foreignphrase"><em class="foreignphrase">Card Select
Number</em></span>) à chaque périphérique <acronym class="acronym">PnP</acronym> du bus
<acronym class="acronym">ISA</acronym>. Comme il existe des moyens plus efficaces (mais plus
complexes) de le faire, certains pourraient dire qu'il s'agit d'une méthode
simple. Seule une adresse d'écriture est utilisée pour les écritures
<acronym class="acronym">PnP</acronym> vers tous les périphériques pour que toutes les
écritures vers cette adresse aillent sur tous les périphériques
<acronym class="acronym">PnP</acronym>. Cette adresse d'écriture est utilisé pour envoyer
(affecter) un numéro de carte unique à chaque périphérique
<acronym class="acronym">PnP</acronym>. Pour
être assigné, ce numéro de carte nécessite qu'un seul périphérique soit en
écoute
lorsque le numéro de carte est envoyé (écrit) à cette adresse commune. Tous les
périphériques <acronym class="acronym">PnP</acronym> ont un numéro de série unique qu'ils
utilisent lors du processus d'isolation. Faire l'isolation est comme un jeu.
Cela se fait en utilisant l'équivalent d'un bus commun de fils connectant tous
les périphériques <acronym class="acronym">PnP</acronym> au programme d'isolation.</p><p>Pour le premier tour du « <span class="quote">jeu</span> », tous les périphériques
<acronym class="acronym">PnP</acronym> écoutent sur ce fil et envoient simultanément une
séquence de bits sur le fil. Les bits autorisés sont soit un 1 (voltage positif)
soit un « <span class="quote">0 ouvert</span> » sans voltage (circuit ouvert ou trois-états).
Pour cela,
chaque périphérique <acronym class="acronym">PnP</acronym> commence à envoyer séquentiellement
son numéro de série sur ce fil, voltage (circuit ouvert ou trois-états). Pour
faire cela, chaque périphérique <acronym class="acronym">PnP</acronym> lance simplement son
numéro de série sur les fils, bit à bit, en commençant par le plus haut. Si
un périphérique envoie un 1, un 1 sera entendu par tous les autres
périphériques. Si tous les périphériques envoient un « <span class="quote">0 ouvert</span> »,
rien ne sera
entendu sur le fil. Le but est d'éliminer (à la fin du premier tour) tous les
périphériques sauf celui possédant le numéro de série le plus important.
« <span class="quote">Éliminer</span> » signifie enlever de ce tour du jeu et donc cesser 
temporairement d'écouter tout ce qui passe sur le fil. (Notez que tous 
les numéros de série ont la même taille.) Quand il ne reste qu'un seul 
périphérique en écoute, un numéro de carte lui est donné.</p><p>Tout d'abord, considérez seulement le bit le plus haut du numéro de
série qui est placé sur le fil par tous les périphériques qui n'ont pas encore
de numéro de carte. Si un périphérique <acronym class="acronym">PnP</acronym> envoie un 0 (0
ouvert)
mais entend un 1, cela signifie qu'un ou plusieurs autres périphériques
<acronym class="acronym">PnP</acronym> a un numéro de série plus important, donc il se supprime
temporairement pour ce tour. Maintenant, les périphériques restant en jeu (pour
ce tour) ont tous le même bit de haut niveau (un 1), donc nous pouvons
supprimer ce bit et continuer avec le « <span class="quote">reste du numéro de série</span> »
pour la suite
du tour. Ensuite, recommencez depuis le début de ce paragraphe et répétez
jusqu'à ce que le numéro de série soit examiné en entier pour chaque
périphérique (voir plus bas pour les cas « <span class="quote">tous à 0</span> »).</p><p>Donc, il est clair que seules les cartes avec un petit numéro de série
sont éliminées lors d'un tour. Mais qu'arrive-t-il si tous les périphériques
du jeu envoient un 0 comme leur bit de haut niveau ? Dans ce cas, un
« <span class="quote">0 ouvert</span> »
est envoyé sur la ligne et tous les participants restent en lice. S'ils ont
tous un 0 au début, alors les 0 sont supprimés comme les 1 du paragraphe
ci-dessus. Le jeu continue alors avec le bit suivant du numéro de série).</p><p>A la fin du tour (après que le dernier bit ait été envoyé), seul un
périphérique <acronym class="acronym">PnP</acronym>, celui possédant le plus haut numéro de
série, reste en jeu. Il se voit attribuer un numéro de carte et quitte le jeu
définitivement. Ensuite, tous les autres périphériques du tour précédent (qui
n'ont donc pas de numéro de carte) reviennent dans le jeu et un nouveau tour
commence,
avec un participant en moins. Éventuellement, tous les périphériques
<acronym class="acronym">PnP</acronym> se voient assigner un numéro de carte. Il est facile de
prouver
que cet algorithme fonctionne. L'algorithme actuel est un peu plus complexe
que celui présenté ci-dessus car chaque étape est répétée deux fois pour
s'assurer, et ces répétitions sont faites d'une façon un peu différente (mais
en utilisant la même idée de base).</p><p>Une fois tous les numéros de carte assignés, ils sont utilisés pour
s'adresser à
chaque périphérique <acronym class="acronym">PnP</acronym> pour envoyer/lire des données de
configuration. Notez que ces numéros de carte sont seulement utilisés pour la
configuration <acronym class="acronym">PnP</acronym> et ne sont pas utilisés pour les
communications normales avec le périphérique <acronym class="acronym">PnP</acronym>. Lorsque
l'ordinateur démarre, un <acronym class="acronym">BIOS</acronym> <acronym class="acronym">PnP</acronym> fera
l'isolation puis s'occupera de la configuration <acronym class="acronym">PnP</acronym>. Après
ça, tous les numéros de carte sont « <span class="quote">perdus</span> » d'une telle façon que
si quelqu'un veut
changer (ou inspecter) la configuration une nouvelle fois, l'isolation devra
être refaite intégralement.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N11505" />13.7. Maîtrise du bus et ressources <acronym class="acronym">DMA</acronym></h3></div></div></div><p>Si un bus dispose d'une fonctionnalité de maîtrise du bus, il est peu
probable que des ressources seront nécessaires pour le <acronym class="acronym">DMA</acronym>
sur ce bus. Par exemple, le bus <acronym class="acronym">PCI</acronym> n'a pas besoin des
ressources <acronym class="acronym">DMA</acronym> car il dispose de cette fonctionnalité.
Néanmoins, la « <span class="quote">maîtrise du bus</span> » est souvent appelée
<acronym class="acronym">DMA</acronym>. Mais, comme il ne s'agit pas strictement de
<acronym class="acronym">DMA</acronym>, il ne nécessite aucune ressource <acronym class="acronym">DMA</acronym>.
Les bus locaux <acronym class="acronym">ISA</acronym> et VESA n'ont pas de maîtrise du bus. Les
anciens bus MCU et E<acronym class="acronym">ISA</acronym> l'avaient.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N11527" />13.8. Historique et obsolescence</h3></div></div></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N1152A" />13.8.1. Pilote son OSS-Lite</h4></div></div></div><p>Vous devez donner l'adresse d'entrée/sortie, l'<acronym class="acronym">IRQ</acronym> et
le canal <acronym class="acronym">DMA</acronym> comme paramètres au module ou les compiler dans
le noyau. Mais certaines cartes <acronym class="acronym">PCI</acronym> seront automatiquement
détectées. RedHat fournit un programme <span class="command"><strong>sndconfig</strong></span> qui détecte
les cartes <acronym class="acronym">ISA</acronym> <acronym class="acronym">PnP</acronym> et configure
automatiquement les modules en chargeant les ressources bus détectées.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N11542" />13.8.2. ALSA (Architecture son avancée pour Linux) en l'an 2000</h4></div></div></div><p>Ceci détectera la carte par des méthodes <acronym class="acronym">PnP</acronym>, puis
sélectionnera le pilote et le chargera. Il configurera aussi les ressources
bus sur les cartes <acronym class="acronym">ISA</acronym>-<acronym class="acronym">PnP</acronym> et sur les
cartes <acronym class="acronym">PCI</acronym>. Il remplace <acronym class="acronym">OSS</acronym> (Open Sound
System), auparavant populaire.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="N11556" />13.8.3. Notes sur MS Windows Notes</h4></div></div></div><p>Windows NT4 ne supportait pas <acronym class="acronym">ISAPNP</acronym> mais dispose d'
un programme <acronym class="acronym">PNPISA</acronym> que vous pouvez utiliser « <span class="quote">à vos
risques et périls</span> ». Pour NT4, les utilisateurs se sont vus conseiller de
ne pas configurer le <acronym class="acronym">BIOS</acronym> avec l'indication que le système
d'exploitation est <acronym class="acronym">PnP</acronym> de façon à ce que le
<acronym class="acronym">BIOS</acronym> s'occupe de la configuration des ressources. Du coup,
MS Windows et Linux étaient auparavant dépendants de la configuration du
<acronym class="acronym">BIOS</acronym> (et le sont toujours).</p></div></div></div><div class="appendix" lang="fr"><h2 class="title"><a id="N11570" />A. Adaptation française</h2><div class="section" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="N11573" />1. Traduction</h2></div></div></div><p>

La traduction française de ce document a été réalisée par Guillaume 
Lelarge

<code class="email">&lt;<a class="email" href="mailto:gleu CHEZ wanadoo POINT fr">gleu CHEZ wanadoo POINT fr</a>&gt;</code>.

</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="N1157B" />2. Préparation de la publication</h2></div></div></div><p>

La publication de ce document a été préparée par Jean-Philippe Guérard 

<code class="email">&lt;<a class="email" href="mailto:fevrier CHEZ tigreraye POINT org">fevrier CHEZ tigreraye POINT org</a>&gt;</code>.

</p></div></div></div></body></html>