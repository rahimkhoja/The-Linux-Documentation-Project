<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.21">
 <TITLE>Mini-HOWTO Linux de XFree vers XInside </TITLE>
</HEAD>
<BODY>
<H1>Mini-HOWTO Linux de XFree vers XInside </H1>

<H2>par Marco Melgazzi, <CODE>marco@techie.com</CODE><BR>
Traducteur: 
<A HREF="http://www.lifl.fr/~blondeel">Sébastien Blondeel</A>
(
<A HREF="mailto:sebastien.blondeel@lifl.fr">sebastien.blondeel@lifl.fr</A>)<BR></H2>version 1.3 / septembre 1997
<HR>
<EM>Comment convertir une ligne de mode vidéo XFree86 en ligne de mode vidéo XInside/XiGraphics</EM>
<HR>
<H2><A NAME="s1">1. Introduction</A></H2>

<P>Au printemps 1996, j'ai lu dans comp.os.linux.x (groupe de discussion
consacré à la partie graphique du système d'exploitation Linux)
beaucoup d'articles demandant comment convertir les modes vidéo entre
XFree86 et une de ses alternatives commerciales: XInside (désormais appelé
XiGraphics, mais vous remarquerez que dans ce document j'utiliserai
l'ancien nom de produit, puisque je me réfère principalement à cette
version-là).</P>
<P>J'avais déjà évalué le produit auparavant et j'avais encore sur mon disque
dur cette version d'évaluation: comme j'aime résoudre des problèmes, j'ai
décidé de m'y mettre et, après quelques heures de tâtonnements et de calculs,
j'ai rédigé un article censé être intéressant, qui fut rapidement posté.</P>
<P>Les discussions parlant de la conversion prirent subitement fin et j'ai
reçu 1 (un) courrier électronique me remerciant pour l'article de telle
sorte que, puisque quelqu'un d'autre risque de se poser ces questions à
l'avenir, j'ai décidé de transformer cet article en ce mini HOWTO.</P>
<P>Mettons tout de suite les choses au clair: je ne travaille PAS pour XInside
et je n'ai eu accès qu'à leur version d'évaluation 1.2 pour Linux. Je sais
que maintenant (en mai 1997) AccelX a atteint le numéro de version 3.1,
mais je pense que l'information contenue dans ce document est toujours
utilisable, au prix peut-être de quelques modifications mineures.</P>
<P>Puisque ce HOWTO a été mis au point à l'aide d'une version de XInside assez
vieille, il se peut que certaines données présentées ici ne soient
pas tout à fait exactes. Comme vous le lirez plus loin, grâce à l'avènement
de XFree 3.2, je n'ai pas acheté ce serveur commercial. Aussi, si vous
l'avez acheté, et que vous remarquez des erreurs, veuillez prendre le temps
de me les communiquer par courrier électronique.</P>
<P>Attention, bidouiller les réglages d'un moniteur est assez dangereux et,
pour cette raison, je ne garantis rien du tout. Si cela fonctionne pour
votre ordinateur, tant mieux. Si vous le faites exploser, ne m'en tenez
pas pour responsable.</P>



<H2><A NAME="s2">2. En ai-je vraiment besoin?</A></H2>


<P>Je ne comprends absolument pas le choix de XInside de ne pas proposer
d'utilitaire pour régler vos modes vidéo (comme xvidtune) et/ou pour
importer vos modes vidéo de XFree dans la version d'évaluation (qui est,
pour autant que je sache, commerciale).
J'ai passé environ trois heures à mettre tout ceci au point (indice: j'ai
comparé l'entrée concernant le VESA 1024x768 à 70Hz dans les deux formats
(et je suis presque ingénieur en électronique ;-)) alors qu'un programmeur
de chez XInside aurait pu écrire un article comparatif en bien moins de
temps... </P>
<P>Je n'ai pas téléchargé les versions d'évaluation à partir de la 1.3 et
j'espère vraiment qu'ils ont réglé cela. Et si c'est le cas, on peut
penser que ce mini HOWTO est devenu inutile mais puisque vous le lisez,
espérons qu'il vous aidera à mieux comprendre comment tout cela
fonctionne... </P>

<H2><A NAME="s3">3. Allons-y</A></H2>

<P>Supposons que vous ayez votre mode XFree86 bien aimé et que vous vouliez
évaluer XInside dans les mêmes conditions: suivez les étapes présentées
ci-dessous et vous devriez pouvoir le faire; nous allons utiliser à titre
d'exemple vécu mon mode vidéo par défaut et je vais vous expliquer ce que
vous devrez faire pour le convertir.</P>
<P>Une entrée de XFree86 ressemble à ceci:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
Modeline "blabla" DOTCLK  A B C D  a b c d
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Chacun des nombres de A à D et de a à d a une signification précise: si
vous le voulez, vous pouvez faire des recherches dans le "Guide du Rootard
pour les modes vidéo sous X386/XFree86"  
(/usr/lib/X11/doc/VideoModes.doc) mais vous n'avez pas besoin de connaître
toute la théorie sous-jacente pour réaliser une conversion couronnée de
succès...</P>
<P>Mon entrée dans /usr/lib/X11/XF86Config est:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
Modeline "1168x876" 105  1168 1256 1544 1640  876 877 891 900
                     |     |    |    |    |    |   |   |   |
                  DOT_CLK  A    B    C    D    a   b   c   d
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Sous XInside, il vous faut ajouter une entrée dans le fichier Xtimings, qui
devrait se trouver dans etc/ (à partir de maintenant, nous supposerons que
vous vous trouvez dans le répertoire racine de Xaccel, qui devrait être
quelque chose comme /usr/X11/lib/X11/AcceleratedX).</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
!    Quelque part dans le fichier, mettez ici le nom désiré

[MODE_PRÉAJUSTÉ]
    NomDuModePréajusté = "1168x876 @ 72Hz";

!
!    Les quatre lignes suivantes sont évidentes... pour qui parle anglais
!
    HorPixel          = 1168;         // pixels
    VerPixel          = 876;          // lignes
    PixelWidthRatio   = 4;            // taux de largeur des pixels
    PixelHeightRatio  = 3;            // taux de hauteur des pixels

!
!   hsync: DOT_CLK / D * 1000 [KHz]
!
!   hsync = 105 / 1640 * 1000 = 64.024 KHz
!
!   vsync: ( 1 / (( D / DOT_CLK ) * d) ) * 1,000,000 [Hz]
!
!   vsync: ( 1 / (( 1640 / 105 ) * 900) ) * 1,000,000
!           ( 1 / 14057.1428571 ) * 1,000,000 = 71.138 Hz
!

    HorFrequency      = 64.180;        // kHz
    VerFrequency      = 71.138;        // Hz

!   Type de balayage

    ScanType          = NONINTERLACED;

!
!   Mettez ici les options de XFree86 +/-hsync et +/-vsync
!
    HorSyncPolarity   = POSITIVE;
    VerSyncPolarity   = POSITIVE;

!   Cela ne devrait pas changer

    CharacterWidth    = 8;             // largeur des caractères, en pixels

!   ici, c'est DOT_CLK

    PixelClock        = 105.000;       // MHz
!
!
!   section des réglages horizontaux: [usec, ou microsecondes]
!
    HorTotalTime  = D / DOT_CLK                  = 15.619;
    HorAddrTime   = A / DOT_CLK                  = 11.124;
    HorBlankStart = A / DOT_CLK                  = 11.124;
    HorBlankTime  = HorTotalTime - HorBlankStart =  4.495;
    HorSyncStart  = B / DOT_CLK                  = 11.962;
    HorSyncTime   = C / DOT_CLK - HorSyncStart   =  2.743;

 !
 !  section des réglages verticaux:    [msec, ou millisecondes]
 !

    VerTotalTime  = ( HorTotalTime * d ) / 1000  = 14.057;
    VerAddrTime   = ( HorTotalTime * a ) / 1000  = 13.682;
    VerBlankStart = ( HorTotalTime * a ) / 1000  = 13.682;
    VerBlankTime  = VerTotalTime - VerBlankStart =  0.375;
    VerSyncStart  = ( HorTotalTime * b ) / 1000  = 13.698;
    VerSyncTime   = ( HorTotalTime * ( c - b ) ) / 1000
                                                 = 0.219

 ! C'est tout !
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Il vous faut maintenant positionner ce mode vidéo nouvellement créé dans
les fichiers indiqués dans la section suivante, au bon endroit.</P>

<H2><A NAME="s4">4. Mettre les choses au point</A></H2>

<P>Dans les extraits ci-dessous, le signe -&gt; vous indique ce qui a été
modifié: ne l'incluez PAS dans vos fichiers!</P>
<P>Entrée du moniteur (la mienne est monitors/mfreq/mfreq64.vda)</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    [MODES_ÉTABLIS]
        "640x480 @ 60Hz",
        "640x480 @ 72Hz",
        "640x480 @ 75Hz",
        "800x600 @ 56Hz",
        "800x600 @ 60Hz",
        "800x600 @ 72Hz",
        "800x600 @ 75Hz",
        "1024x768 Interlaced",
        "1024x768 @ 60Hz",
        "1024x768 @ 70Hz",
        "1024x768 @ 75Hz",
    "1152x900 Interlaced",
        "1152x900 @ 60Hz",
        "1152x900 @ 67Hz",
->      "1168x876 @ 72Hz",
        "1280x1024 Interlaced",
        "1280x1024 @ 60Hz",
    "1600x1200 Interlaced";
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Dans le fichier d'informations propre à la carte (la mienne est 
(boards/s3/764-2.xqa, je me demande pourquoi ils ont presque toutes les
cartes Hercules sauf la mienne: Terminator 64/Dram).</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
    [VISUEL]
    BitsPerPixel   = 8;
    MemoryModel    = Packed;
    ColorModel     = Indexed;
    BitsRGB        = 6;
    NumberOfColors = 256;

    [RÉSOLUTIONS]
    640x480,
    800x600,
    1024x768,
->  1168x876,
    1152x900,
    1280x1024

    [BUREAUX]
    640x480,
    800x600,
    1024x768,
    1152x900,
->  1168x876,
    1280x1024,
    1600x1200
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Si la carte le permet (ce qui n'est PAS le cas pour ma carte) vous pouvez
même mettre cette entrée dans les sections 16bpp et 32bpp (bpp: bit par
pixel).</P>
<P>Le fichier etc/Xaccel.ini ressemblera à ce qui suit: </P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
--------------------------------------------------------------
    Board   = "s3/764-2.xqa";
    Monitor = "mfreq/mfreq64.vda";
    Depth   = 8;
->  Desktop = 1168x876;

    [RÉSOLUTIONS]
->      1168x876,
        1024x768;
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>L'entrée du mode correspondant pour XInside dans etc/Xtimings:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
--------------------------------------------------------------
[MODE_PRÉAJUSTÉ]
    NomDuModePréajusté = "1168x876 @ 72Hz";

    HorPixel          = 1168;          // pixels
    VerPixel          = 876;           // lignes
    PixelWidthRatio   = 4;
    PixelHeightRatio  = 3;
    HorFrequency      = 64.024;        // kHz
    VerFrequency      = 71.138;        // Hz
    ScanType          = NONINTERLACED;
    HorSyncPolarity   = POSITIVE;
    VerSyncPolarity   = POSITIVE;
    CharacterWidth    = 8;             // pixels
    PixelClock        = 105.000;       // MHz
    HorTotalTime      = 15.619;        // (usec) =  205 caractères
    HorAddrTime       = 11.124;        // (usec) =  146 caractères
    HorBlankStart     = 11.124;        // (usec) =  146 caractères
    HorBlankTime      =  4.495;        // (usec) =   59 caractères
    HorSyncStart      = 11.962;        // (usec) =  157 caractères
    HorSyncTime       =  2.743;        // (usec) =   36 caractères
    VerTotalTime      = 14.057;        // (msec) =  900 lignes
    VerAddrTime       = 13.682;        // (msec) =  876 lignes
    VerBlankStart     = 13.682;        // (msec) =  876 lignes
    VerBlankTime      =  0.375;        // (msec) =   24 lignes
    VerSyncStart      = 13.698;        // (msec) =  877 lignes
    VerSyncTime       =  0.219;        // (msec) =   14 lignes
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Vous pouvez vérifier votre conversion en lançant le programme vgaset sans
paramètres alors que le serveur XInside tourne: cela produira une ligne à
la XFree et, si tout s'est bien passé, cette ligne sera la même que celle
de laquelle vous étiez parti (sauf si b et c sont égaux, je n'ai pas réussi
à reproduire cette situation dans XInside: le meilleur cas qui s'est produit
étant c=b+1).</P>

<H2><A NAME="s5">5. La fin...</A></H2>

<P>C'est tout pour cette fois-ci ! J'espère que cela vous sera utile. Je ne
pense pas acheter le serveur XiGraphics dans un futur proche pour une
raison simple: la sortie de XFree86 3.2 a résolu tous les problèmes de
vitesse que je rencontrais avec mon humble carte vidéo Trio 64 ;)</P>
<P>Il semble toutefois que le serveur XiGraphics reconnaît un ensemble de
puces et de cartes vidéo bien plus large que XFree, aussi est-il possible
que l' "alternative commerciale" soit la seule disponible pour vous. Si
c'est le cas, et si vous avez acheté le serveur XiGraphics, j'aimerais
vraiment avoir de vos nouvelles afin de savoir si l'information présentée
ici vous a été utile, si vous l'avez trouvée trop compliquée, ou quoi que
ce soit.</P>

<H2><A NAME="s6">6. Rendre le processus automatique</A></H2>

<P>Le petit script qui suit automatise la plupart du travail. Faites très
attention au ScanType (type de balayage) et aux deux lignes Polarity
(polarité): le script ne les positionne pas et, si vous avez la paresse de
ne pas les corriger, les risques d'endommager votre moniteur augmentent en
flèche. </P>
<P>Remarquez que je ne sais pas si le drapeau "Doublescan" (balayage double) a
une signification quelconque dans XInside: si vous tentez de convertir un
mode de double balayage de faible résolution FAITES ATTENTION, vous pouvez
assez facilement casser votre moniteur puisque le taux de rafraîchissement 
que vous obtenez sera doublé (en fait mon 400x300 à 72Hz est devenu un 
400x300 à 144Hz!).</P>

<P>
<BLOCKQUOTE><CODE>
<PRE>
#!/bin/sh
##########################################################################
# XF2XInside
#
# Ce script convertit les lignes de mode vidéo du format XF86Config au
# format XInside pour remplir les besoins du fichier etc/Xtimings.
#
# C'est une bidouille vite programmée, n'en attendez pas des vérifications
# d'erreurs fines (et ne parlons pas de l'interface utilisateur).
#
# Si vous l'appelez sans argument, il devrait vous dire quoi faire.
#
#                               (juillet 1996, hcz@tazlwurm.bb.bawue.de)
#
# Au fait: Les nouveaux modes créés comme expliqués dans ce HOWTO
# fonctionnent, mais n'apparaissent pas dans le menu de Xsetup. Quelqu'un
# sait-il pourquoi ?
#
##########################################################################
#----------------------------------------------- On y va:
# Modifiez ceci si votre fichier de lignes de modes vidéo est ailleurs:
XF=/usr/X11/lib/X11/XF86Config
if [ $# -ne 1 ] ; then
  echo "utilisation: ${0##*/} &lt;mode>"
  echo " exemple: ${0##*/} 1024x764"
  echo -e " rôle: convertit une entrée de ligne de mode vidéo de $XF au\nformat XInside (stdout, ou la sortie standard)"
  exit 1
fi
egrep -i "^[\t ]*modeline.+\"$1\""  /usr/X11/lib/X11/XF86Config |
gawk '
NF &lt; 11  { print "! mauvaise ligne:\n! " $0 "\n!"; next }
{
  print "//", $0  ":"
  name = $2
  DOT_CLK = $3;
  A = $4;
  B = $5;
  C = $6;
  D = $7;
  a = $8;
  b = $9;
  c = $10;
  d = $11;
  VerFrequency =  1000000 / ((D / DOT_CLK) * d)
  print "[MODE_PRÉAJUSTÉ]"
  printf "  NomDuModePréajusté = \"%dx%d @ %.0dHz\";\n", A, a, VerFrequency
  print "  HorPixel\t\t= " A ";"
  print "  VerPixel\t\t= " a ";"
  print "  PixelWidthRatio\t= 4;\n  PixelHeightRatio\t= 3;"
  print "  HorFrequency\t\t= " DOT_CLK / D * 1000 ";\t// kHz"
  print "  VerFrequency\t\t= " VerFrequency  ";\t// Hz"
  print "  ScanType\t\t= NONINTERLACED;\t\t// *VÉRIFIEZ*"
  print "  HorSyncPolarity\t= NEGATIVE;\t\t\t// *VÉRIFIEZ*"
  print "  VerSyncPolarity\t= NEGATIVE;\t\t\t// *VÉRIFIEZ*"
  print "  CharacterWidth\t= 8;"
  print "  PixelClock\t\t= " DOT_CLK ";"
  HorTotalTime = D / DOT_CLK
  print "  HorTotalTime\t\t= " HorTotalTime ";"
  print "  HorAddrTime \t\t= " A / DOT_CLK ";"
  print "  HorBlankStart\t\t= " A / DOT_CLK ";"
  print "  HorBlankTime\t\t= " D / DOT_CLK - A / DOT_CLK ";"
  print "  HorSyncStart\t\t= " B / DOT_CLK ";"
  print "  HorSyncTime\t\t= " C / DOT_CLK - B / DOT_CLK ";"
  VerTotalTime  = ( HorTotalTime * d ) / 1000
  print "  VerTotalTime\t\t= " VerTotalTime ";"
  print "  VerAddrTime\t\t= " ( HorTotalTime * a ) / 1000 ";"
  VerBlankStart = ( HorTotalTime * a ) / 1000
  print "  VerBlankStart\t\t= " VerBlankStart ";"
  print "  VerBlankTime\t\t= " VerTotalTime - VerBlankStart ";"
  print "  VerSyncStart\t\t= " ( HorTotalTime * b ) / 1000 ";"
  print "  VerSyncTime\t\t= " ( HorTotalTime * ( c - b ) ) / 1000
  print ""
}'
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H2><A NAME="s7">7. Merci à</A></H2>

<P>
<UL>
<LI>Heike Claudia Zimmerer 
<A HREF="mailto:hcz@tazlwurm.bb.bawue.de">hcz@tazlwurm.bb.bawue.de</A> pour m'avoir fait remarquer une petite
contradiction et pour m'avoir envoyé un script qui automatise une grande
partie du travail.</LI>
<LI>Bartosz Maruszewski 
<A HREF="mailto:B.Maruszewski@zsmeie.torun.pl">B.Maruszewski@zsmeie.torun.pl</A> pour avoir traduit ce mini HOWTO en
polonais et pour m'avoir fait remarquer une petite faute de frappe.</LI>
</UL>
</P>

<H2><A NAME="s8">8. Copyright/point de vue légal</A></H2>

<P>(c)opyright 1996-7 par Marco Melgazzi (marco@techie.com) -
couvert par la GPL (licence publique de GNU). Pour obtenir une copie de
cette licence, écrivez à la Fondation pour un Logiciel Libre, à l'adresse:
Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</P>
<P>Les marques déposées appartiennent à leurs propriétaires. Aucune garantie
ne couvre la justesse ou l'utilité de l'information que vous trouverez dans
ce document. </P>

</BODY>
</HTML>
