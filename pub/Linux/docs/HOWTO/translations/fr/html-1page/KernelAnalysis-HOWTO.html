<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2//EN">
<html>
<head>
<meta name="generator" content=
"HTML Tidy for Linux (vers 7 December 2008), see www.w3.org">
<meta name="GENERATOR" content="LinuxDoc-Tools 0.9.65">
<title>Guide pratique d'analyse du noyau (version fran&ccedil;aise
du KernelAnalysis HOWTO)</title>
</head>
<body>
<h1>Guide pratique d'analyse du noyau (version fran&ccedil;aise du
<em>KernelAnalysis HOWTO</em>)</h1>
<h2>Roberto Arcomano berto_CHEZ_bertolinux_POINT_com</h2>
Version&nbsp;: 0.7.fr.1.0 du 28&nbsp;juin 2004
<hr>
<em>Ce document essaye d'expliquer quelques choses au sujet du
noyau de Linux, tel que les composants les plus importants, comment
ils fonctionnent, etc... Ce guide pratique devrait aider le lecteur
&agrave; &eacute;viter de devoir passer en revue tous les fichiers
source du noyau pour rechercher la "bonne fonction",
d&eacute;claration, et d&eacute;finition, et puis les lier les unes
les autres. Vous pouvez trouver la derni&egrave;re version
originale de ce document &agrave; <a href=
"http://www.bertolinux.com">http://www.bertolinux.com</a>. Si vous
avez des suggestions pour am&eacute;liorer ce document, veuillez
soumettre vos id&eacute;es en anglais &agrave; mon adresse:
<a href="mailto:berto%20CHEZ%20bertolinux%20POINT%20com">berto CHEZ
bertolinux POINT com</a>. La derni&egrave;re version
fran&ccedil;aise: <a href=
"http://www.traduc.org">http://www.traduc.org</a>. Les corrections
de la version fran&ccedil;aise sont les bienvenues, veuillez en
informer l'auteur sur son site ou sur <a href=
"http://www.traduc.org">http://www.traduc.org</a>.</em>
<hr>
<h2><a name="s1">1. Introduction</a></h2>
<h2><a name="ss1.1">1.1 Version fran&ccedil;aise</a></h2>
<p>La version fran&ccedil;aise de ce guide pratique a
&eacute;t&eacute; r&eacute;alis&eacute;e le 28&nbsp;juin 2004 par
Patrick Trauquesegue.</p>
<h2><a name="ss1.2">1.2 Introduction</a></h2>
<p>Ce guide pratique essaye de d&eacute;finir comment les parties
du Noyau Linux fonctionnent, ce que sont les principales fonctions
et structures de donn&eacute;es utilis&eacute;es, et comment la
"roue tourne". Vous pouvez trouver la derni&egrave;re version de ce
document &agrave; <a href=
"http://www.bertolinux.com">http://www.bertolinux.com</a>. Si vous
avez des suggestions pour am&eacute;liorer ce document, veuillez
soumettre vos id&eacute;es en anglais &agrave; mon adresse:
<a href="mailto:berto%20CHEZ%20bertolinux%20POINT%20com">berto CHEZ
bertolinux POINT com</a>. Le code utilis&eacute; dans ce document
se rapporte &agrave; la version 2.4.x de noyau de Linux, qui est la
derni&egrave;re version stable du noyau au moment d'&eacute;crire
ce guide pratique.</p>
<h2><a name="ss1.3">1.3 Copyright</a></h2>
<p>Copyright (C) 2000,2001,2002 Roberto Arcomano, traduction
Patrick Trauquesegues. Ce document est libre; vous pouvez le
redistribuer et/ou le modifier selon les termes de la Licence
Publique G&eacute;n&eacute;rale GNU telle que publi&eacute;e par la
Free Software Foundation (fondation pour le logiciel libre);
licence version 2, ou (&agrave; votre choix) toute version
post&eacute;rieure. Ce document est distribu&eacute; dans l'espoir
qu'il sera utile, mais SANS AUCUNE GARANTIE; sans m&ecirc;me de
garantie implicite de VALEUR MARCHANDE ou d'UTILISATION POUR UN BUT
PARTICULIER. Voyez la Licence Publique G&eacute;n&eacute;rale GNU
pour plus de d&eacute;tails. Vous pouvez obtenir une copie de la
GNU GPL <a href="http://www.gnu.org/copyleft/gpl.html">ici</a>.</p>
<h2><a name="ss1.4">1.4 Traductions</a></h2>
<p>Si vous voulez traduire ce document vous &ecirc;tes libre de le
faire. Cependant, vous aurez besoin de ce qui suit:</p>
<ol>
<li>V&eacute;rifiez qu'une autre version du document n'existe pas
d&eacute;j&agrave; &agrave; votre LDP local</li>
<li>Maintenez toutes les sections 'Introduction' (y compris
'Introduction', 'copyright', 'Traductions', 'Remerciements')</li>
</ol>
<p>Avertissement! Vous ne devez pas traduire de fichier TXT ou
HTML, vous devez modifier le dossier de LYX (Ndt: ou SGML), de
sorte qu'il soit possible de le convertir dans tous autres formats
(TXT, HTML, RIFF (RTF?), etc...): pour le faire vous pouvez
utiliser l'application "LyX" &agrave; t&eacute;l&eacute;chargez sur
<a href="http://www.lyx.org">http://www.lyx.org</a>.</p>
<p>Aucun besoin de me demander de traduire! Vous juste devez me
faire conna&icirc;tre (si vous voulez) votre traduction.</p>
<p>Merci de votre traduction!</p>
<h2><a name="ss1.5">1.5 Remerciements</a></h2>
<p>Merci &agrave; <a href="http://www.tldp.org">Linux Documentation
Project</a> pour publier et t&eacute;l&eacute;charger rapidement
mon document.</p>
<p>Merci &agrave; Klaas de Waal pour ses suggestions.</p>
<h2><a name="s2">2. Syntaxe utilis&eacute;e</a></h2>
<h2><a name="ss2.1">2.1 Syntaxe de Fonction</a></h2>
<p>Quand nous parlons d'une fonction, nous &eacute;crivons:</p>
<pre>
"nom_de_function  [ fichier emplacement . extension ]"
</pre>
<p>Par exemple:</p>
<pre>
"schedule [kernel/sched.c]" 
</pre>
<p>nous dit que nous parlons de</p>
<p>"schedule"</p>
<p>function accessible depuis le fichier</p>
<p>[ kernel/sched.c ]</p>
<p>Note: Nous supposons /usr/src/linux comme racine du dossier.</p>
<h2><a name="ss2.2">2.2 Indentation</a></h2>
<p>L'indentation du code source est de 3 caract&egrave;res
blancs.</p>
<h2><a name="ss2.3">2.3 Analyse d'InterCallings</a></h2>
<h3>Vue d'ensemble</h3>
<p>Nous utilisons l'analyse d'"InterCallings" (ICA) pour voir (de
mani&egrave;re indent&eacute;e) comment les fonctions du noyau
s'appellent les unes les autres.</p>
<p>Par exemple, la commande de sleep_on est d&eacute;crite ainsi
dans ICA:</p>
<pre>
|sleep_on
|init_waitqueue_entry      --
|__add_wait_queue            |   enqueuing request  
   |list_add                 |
      |__list_add          -- 
   |schedule              ---     waiting for request to be executed
      |__remove_wait_queue --   
      |list_del              |   dequeuing request
         |__list_del       -- 
 
                          sleep_on ICA

</pre>
<p>L'ICA indent&eacute; est suivi par les fonctions
d'emplacement:</p>
<ul>
<li>sleep_on [kernel/sched.c]</li>
<li>init_waitqueue_entry [include/linux/wait.h]</li>
<li>__add_wait_queue</li>
<li>list_add [include/linux/list.h]</li>
<li>__list_add</li>
<li>schedule [kernel/sched.c]</li>
<li>__remove_wait_queue [include/linux/wait.h]</li>
<li>list_del [include/linux/list.h]</li>
<li>__list_del</li>
</ul>
<p>Note: Nous n'indiquons plus l'emplacement du dossier, s'il est
indiqu&eacute; juste avant.</p>
<h3>D&eacute;tails</h3>
<p>Dans un ICA une telle ligne ressemble &agrave; ce qui suit</p>
<pre>
 function1 -&gt; function2
</pre>
<p>signifie que &lt; function1 &gt; est un pointeur
g&eacute;n&eacute;rique vers une autre fonction. Dans ce cas &lt;
function1 &gt; pointe vers &lt; function2 &gt;.</p>
<p>Quand nous &eacute;crivons:</p>
<pre>
  function:
</pre>
<p>&ccedil;a signifie que &lt; fonction &gt; n'est pas une vraie
fonction. C'est une &eacute;tiquette/un label (typiquement
&eacute;tiquette/label d'assembleur).</p>
<p>Dans beaucoup de sections nous pouvons reporter un code ''C'' ou
un ''pseudo-code''. Dans de vrais fichiers source, vous pourriez
utiliser code ''assembleur'' ou ''non structur&eacute; de ''. Cette
diff&eacute;rence est &agrave; but d'&eacute;tude.</p>
<h3>POUR l'usage d'ICA</h3>
<p>Les avantages d'utiliser ICA (Analyse d'InterCallings) sont
nombreux:</p>
<ul>
<li>Vous obtenez une vue d'ensemble de ce qui se produit quand vous
appelez une fonction du noyau.</li>
<li>L'emplacement des Fonctions est indiqu&eacute; apr&egrave;s la
fonction, ainsi ICA pourrait aussi un peu &ecirc;tre appel&eacute;
"r&eacute;f&eacute;rence des fonctions"</li>
<li>L'analyse d'InterCallings (ICA) est utile dans des
m&eacute;canismes de sleep/awake (sommeil/&eacute;veill&eacute;),
o&ugrave; nous pouvons voir ce que nous faisons avant le sommeil,
l'action propre au sommeil, et ce que nous feront apr&egrave;s
r&eacute;veil (apr&egrave;s programme).</li>
</ul>
<h3>CONTRE l'usage d'ICA</h3>
<ul>
<li>Certains des inconv&eacute;nients d'utiliser ICA sont
&eacute;num&eacute;r&eacute;s ci-dessous: Some of the disadvantages
of using ICA are listed below:</li>
</ul>
<p>Comme tous les mod&egrave;les th&eacute;oriques, nous
simplifions la r&eacute;alit&eacute; &eacute;vitant beaucoup de
d&eacute;tails, comme le vrai code source et les conditions
sp&eacute;ciales.</p>
<ul>
<li>Additional diagrams should be added to better represent stack
conditions, data values, etc.. Des diagrammes additionnels
devraient &ecirc;tre ajout&eacute;s pour mieux repr&eacute;senter
les &eacute;tats de pile, valeurs de donn&eacute;es, etc...</li>
</ul>
<h2><a name="s3">3. Fondamentaux</a></h2>
<h2><a name="ss3.1">3.1 Qu'est-ce que noyau?</a></h2>
<p>Le noyau est le "coeur" de n'importe quel syst&egrave;me
informatique: c'est le "logiciel" qui permet aux utilisateurs de
partager des ressources de informatique.</p>
<p>On peut penser le noyau comme le logiciel principal du SE
(Syst&egrave;me d'Exploitation ou OS pour Operating System en
anglais), qui peut &eacute;galement inclure la gestion de
graphiques.</p>
<p>Par exemple, sous Linux (comme d'autres Unix), l'environnement
de XWindow n'appartient pas au noyau, parce qu'il contr&ocirc;le
seulement des op&eacute;rations graphiques (il utilise l' E/S du
Mode Utilisateur pour acc&eacute;der &agrave; la carte
vid&eacute;o).</p>
<p>Par contre, les environnements de Windows (Win9x, WinME, WinNT,
Win2K, WinXP, etc...) sont un m&eacute;lange entre environnement
graphique et noyau.</p>
<h2><a name="ss3.2">3.2 Quelle est la diff&eacute;rence entre Mode
Utilisateur et Mode Noyau?</a></h2>
<h3>Vue d'ensemble</h3>
<p>Il y a quelques ann&eacute;es, quand les ordinateurs
&eacute;taient aussi grands qu'une pi&egrave;ce, les applications
utilisateur tournaient avec beaucoup de difficult&eacute; et,
parfois, faisaient planter l'ordinateur.</p>
<h3>Modes Op&eacute;rationnel</h3>
<p>Pour &eacute;viter d'avoir des applications qui plantent
constamment, les nouveaux SE ont &eacute;t&eacute; con&ccedil;us
avec 2 modes op&eacute;rationnels:</p>
<ol>
<li>Mode Noyau: la machine fonctionne avec une structure de
donn&eacute;es critique, mat&eacute;riel direct
(entr&eacute;e/sortie ou m&eacute;moire trac&eacute;e),
m&eacute;moire directe, IRQ, DMA, etc...</li>
<li>Mode Utilisateur: les utilisateurs peuvent faire tourner des
applications.</li>
</ol>
<pre>
                      
               |          Applications           /|\
               |         ______________           |
               |         | User Mode  |           |  
               |         ______________           | 
               |               |                  |  
Implementation |        _______ _______           |   Abstraction
    Detail     |        | Kernel Mode |           |
               |        _______________           |
               |               |                  |
               |               |                  | 
               |               |                  |
              \|/          Hardware               |
</pre>
<p>Le Mode Noyau "emp&ecirc;che" les applications de Mode
Utilisateur d'endommager le syst&egrave;me ou ses dispositifs.</p>
<p>Les microprocesseurs modernes impl&eacute;mentent dans le
mat&eacute;riel au moins 2 &eacute;tats diff&eacute;rents. Par
exemple sous Intel, 4 &eacute;tats d&eacute;terminent le PL (niveau
de privil&egrave;ge). Il est possible d'utiliser 0.1.2.3
&eacute;tats, avec 0 utilis&eacute; pour le Mode Noyau.</p>
<p>Le SE Unix requiert seulement 2 niveaux de privil&egrave;ge, et
nous utiliserons un tel paradigme comme point de
r&eacute;f&eacute;rence.</p>
<h2><a name="ss3.3">3.3 Commutation du Mode Utilisateur au Mode
Noyau</a></h2>
<h3>Quand commutons-nous?</h3>
<p>Une fois que nous avons compris qu'il y a 2 modes
diff&eacute;rents, nous devons savoir quand nous passons de l'un
&agrave; l'autre.</p>
<p>Typiquement, il y a 2 points de commutation:</p>
<ol>
<li>Quand on appelle un Appel Syst&egrave;me: apr&egrave;s avoir
appel&eacute; un Appel Syst&egrave;me, la T&acirc;che appelle
volontairement des des bouts de code r&eacute;sidant en Mode
Noyau.</li>
<li>Quand une IRQ (ou exception) arrive: apr&egrave;s l'IRQ un
gestionnaire d'IRQ (ou gestionnaire d'exception) est appel&eacute;,
alors le contr&ocirc;le revient &agrave; la T&acirc;che qui a
&eacute;t&eacute; interrompue comme si rien ne s'&eacute;tait
pass&eacute;.</li>
</ol>
<h3>Appels Syst&egrave;me</h3>
<p>Les Appels Syst&egrave;me sont comme des fonctions
sp&eacute;ciales qui g&egrave;rent les routines du SE qui
r&eacute;sident en Mode Noyau.</p>
<p>Un Appel Syst&egrave;me peut &ecirc;tre appel&eacute; quand
nous:</p>
<ul>
<li>acc&eacute;dons &agrave; une unit&eacute; d'E/S ou &agrave; un
fichier (comme lecture ou &eacute;criture)</li>
<li>devons acc&eacute;der &agrave; une information
privil&eacute;gi&eacute;e (comme le pid, en changeant la politique
de programmation (changing scheduling policy) ou une autre
information)</li>
<li>devons changer le contexte d'ex&eacute;cution (comme bifurquer
ou ex&eacute;cuter une autre application)</li>
<li>devons ex&eacute;cuter une commande particuli&egrave;re (comme
''chdir'', ''kill", ''brk'', ou ''signal'')</li>
</ul>
<pre>
                                 |                |
                         -------&gt;| System Call i  | (Accessing Devices)
|                |       |       |  [sys_read()]  |
| ...            |       |       |                |
| system_call(i) |--------       |                |
|   [read()]     |               |                |
| ...            |               |                |
| system_call(j) |--------       |                |  
|   [get_pid()]  |       |       |                |
| ...            |       -------&gt;| System Call j  | (Accessing kernel data structures)
|                |               |  [sys_getpid()]|
                                 |                | 
 
    USER MODE                        KERNEL MODE
 
  
                        Unix System Calls Working 
</pre>
<p>Les Appels Syst&egrave;me sont presque la seule interface
utilis&eacute;e par le Mode Utilisateur pour dialoguer avec des
ressources de bas niveau (mat&eacute;riel). La seule exception
&agrave; cette r&egrave;gle est quand un processus utilise l'Appel
Syst&egrave;me ''ioperm''. Dans ce cas le processus en Mode
Utilisateur peut acc&eacute;der directement &agrave; un
p&eacute;riph&eacute;rique (les IRQs ne peuvent pas &ecirc;tre
utilis&eacute;es).</p>
<p>NOTE: Toutes les fonctions ''C'' ne sont pas des Appels
Syst&egrave;me, seulement certaines d'entre-elles.</p>
<p>Ci-dessous une liste d'Appels Syst&egrave;me du noyau 2,4,17 de
Linux, de [ arch/i386/kernel/entry.S ]</p>
<pre>
        .long SYMBOL_NAME(sys_ni_syscall)       /* 0  -  old "setup()" system call*/
        .long SYMBOL_NAME(sys_exit)
        .long SYMBOL_NAME(sys_fork)
        .long SYMBOL_NAME(sys_read)
        .long SYMBOL_NAME(sys_write)
        .long SYMBOL_NAME(sys_open)             /* 5 */
        .long SYMBOL_NAME(sys_close)
        .long SYMBOL_NAME(sys_waitpid)
        .long SYMBOL_NAME(sys_creat)
        .long SYMBOL_NAME(sys_link)
        .long SYMBOL_NAME(sys_unlink)           /* 10 */
        .long SYMBOL_NAME(sys_execve)
        .long SYMBOL_NAME(sys_chdir)
        .long SYMBOL_NAME(sys_time)
        .long SYMBOL_NAME(sys_mknod)
        .long SYMBOL_NAME(sys_chmod)            /* 15 */
        .long SYMBOL_NAME(sys_lchown16)
        .long SYMBOL_NAME(sys_ni_syscall)                               /* old break syscall holder */
        .long SYMBOL_NAME(sys_stat)
        .long SYMBOL_NAME(sys_lseek)
        .long SYMBOL_NAME(sys_getpid)           /* 20 */
        .long SYMBOL_NAME(sys_mount)
        .long SYMBOL_NAME(sys_oldumount)
        .long SYMBOL_NAME(sys_setuid16)
        .long SYMBOL_NAME(sys_getuid16)
        .long SYMBOL_NAME(sys_stime)            /* 25 */
        .long SYMBOL_NAME(sys_ptrace)
        .long SYMBOL_NAME(sys_alarm)
        .long SYMBOL_NAME(sys_fstat)
        .long SYMBOL_NAME(sys_pause)
        .long SYMBOL_NAME(sys_utime)            /* 30 */
        .long SYMBOL_NAME(sys_ni_syscall)                               /* old stty syscall holder */
        .long SYMBOL_NAME(sys_ni_syscall)                               /* old gtty syscall holder */
        .long SYMBOL_NAME(sys_access)
        .long SYMBOL_NAME(sys_nice)
        .long SYMBOL_NAME(sys_ni_syscall)       /* 35 */                /* old ftime syscall holder */
        .long SYMBOL_NAME(sys_sync)
        .long SYMBOL_NAME(sys_kill)
        .long SYMBOL_NAME(sys_rename)
        .long SYMBOL_NAME(sys_mkdir)
        .long SYMBOL_NAME(sys_rmdir)            /* 40 */
        .long SYMBOL_NAME(sys_dup)
        .long SYMBOL_NAME(sys_pipe)
        .long SYMBOL_NAME(sys_times)
        .long SYMBOL_NAME(sys_ni_syscall)                               /* old prof syscall holder */
        .long SYMBOL_NAME(sys_brk)              /* 45 */
        .long SYMBOL_NAME(sys_setgid16)
        .long SYMBOL_NAME(sys_getgid16)
        .long SYMBOL_NAME(sys_signal)
        .long SYMBOL_NAME(sys_geteuid16)
        .long SYMBOL_NAME(sys_getegid16)        /* 50 */
        .long SYMBOL_NAME(sys_acct)
        .long SYMBOL_NAME(sys_umount)                                   /* recycled never used phys() */
        .long SYMBOL_NAME(sys_ni_syscall)                               /* old lock syscall holder */
        .long SYMBOL_NAME(sys_ioctl)
        .long SYMBOL_NAME(sys_fcntl)            /* 55 */
        .long SYMBOL_NAME(sys_ni_syscall)                               /* old mpx syscall holder */
        .long SYMBOL_NAME(sys_setpgid)
        .long SYMBOL_NAME(sys_ni_syscall)                               /* old ulimit syscall holder */
        .long SYMBOL_NAME(sys_olduname)
        .long SYMBOL_NAME(sys_umask)            /* 60 */
        .long SYMBOL_NAME(sys_chroot)
        .long SYMBOL_NAME(sys_ustat)
        .long SYMBOL_NAME(sys_dup2)
        .long SYMBOL_NAME(sys_getppid)
        .long SYMBOL_NAME(sys_getpgrp)          /* 65 */
        .long SYMBOL_NAME(sys_setsid)
        .long SYMBOL_NAME(sys_sigaction)
        .long SYMBOL_NAME(sys_sgetmask)
        .long SYMBOL_NAME(sys_ssetmask)
        .long SYMBOL_NAME(sys_setreuid16)       /* 70 */
        .long SYMBOL_NAME(sys_setregid16)
        .long SYMBOL_NAME(sys_sigsuspend)
        .long SYMBOL_NAME(sys_sigpending)
        .long SYMBOL_NAME(sys_sethostname)
        .long SYMBOL_NAME(sys_setrlimit)        /* 75 */
        .long SYMBOL_NAME(sys_old_getrlimit)
        .long SYMBOL_NAME(sys_getrusage)
        .long SYMBOL_NAME(sys_gettimeofday)
        .long SYMBOL_NAME(sys_settimeofday)
        .long SYMBOL_NAME(sys_getgroups16)      /* 80 */
        .long SYMBOL_NAME(sys_setgroups16)
        .long SYMBOL_NAME(old_select)
        .long SYMBOL_NAME(sys_symlink)
        .long SYMBOL_NAME(sys_lstat)
        .long SYMBOL_NAME(sys_readlink)         /* 85 */
        .long SYMBOL_NAME(sys_uselib)
        .long SYMBOL_NAME(sys_swapon)
        .long SYMBOL_NAME(sys_reboot)
        .long SYMBOL_NAME(old_readdir)
        .long SYMBOL_NAME(old_mmap)             /* 90 */
        .long SYMBOL_NAME(sys_munmap)
        .long SYMBOL_NAME(sys_truncate)
        .long SYMBOL_NAME(sys_ftruncate)
        .long SYMBOL_NAME(sys_fchmod)
        .long SYMBOL_NAME(sys_fchown16)         /* 95 */
        .long SYMBOL_NAME(sys_getpriority)
        .long SYMBOL_NAME(sys_setpriority)
        .long SYMBOL_NAME(sys_ni_syscall)                               /* old profil syscall holder */
        .long SYMBOL_NAME(sys_statfs)
        .long SYMBOL_NAME(sys_fstatfs)          /* 100 */
        .long SYMBOL_NAME(sys_ioperm)
        .long SYMBOL_NAME(sys_socketcall)
        .long SYMBOL_NAME(sys_syslog)
        .long SYMBOL_NAME(sys_setitimer)
        .long SYMBOL_NAME(sys_getitimer)        /* 105 */
        .long SYMBOL_NAME(sys_newstat)
        .long SYMBOL_NAME(sys_newlstat)
        .long SYMBOL_NAME(sys_newfstat)
        .long SYMBOL_NAME(sys_uname)
        .long SYMBOL_NAME(sys_iopl)             /* 110 */
        .long SYMBOL_NAME(sys_vhangup)
        .long SYMBOL_NAME(sys_ni_syscall)       /* old "idle" system call */
        .long SYMBOL_NAME(sys_vm86old)
        .long SYMBOL_NAME(sys_wait4)
        .long SYMBOL_NAME(sys_swapoff)          /* 115 */
        .long SYMBOL_NAME(sys_sysinfo)
        .long SYMBOL_NAME(sys_ipc)
        .long SYMBOL_NAME(sys_fsync)
        .long SYMBOL_NAME(sys_sigreturn)
        .long SYMBOL_NAME(sys_clone)            /* 120 */
        .long SYMBOL_NAME(sys_setdomainname)
        .long SYMBOL_NAME(sys_newuname)
        .long SYMBOL_NAME(sys_modify_ldt)
        .long SYMBOL_NAME(sys_adjtimex)
        .long SYMBOL_NAME(sys_mprotect)         /* 125 */
        .long SYMBOL_NAME(sys_sigprocmask)
        .long SYMBOL_NAME(sys_create_module)
        .long SYMBOL_NAME(sys_init_module)
        .long SYMBOL_NAME(sys_delete_module)
        .long SYMBOL_NAME(sys_get_kernel_syms)  /* 130 */
        .long SYMBOL_NAME(sys_quotactl)
        .long SYMBOL_NAME(sys_getpgid)
        .long SYMBOL_NAME(sys_fchdir)
        .long SYMBOL_NAME(sys_bdflush)
        .long SYMBOL_NAME(sys_sysfs)            /* 135 */
        .long SYMBOL_NAME(sys_personality)
        .long SYMBOL_NAME(sys_ni_syscall)       /* for afs_syscall */
        .long SYMBOL_NAME(sys_setfsuid16)
        .long SYMBOL_NAME(sys_setfsgid16)
        .long SYMBOL_NAME(sys_llseek)           /* 140 */
        .long SYMBOL_NAME(sys_getdents)
        .long SYMBOL_NAME(sys_select)
        .long SYMBOL_NAME(sys_flock)
        .long SYMBOL_NAME(sys_msync)
        .long SYMBOL_NAME(sys_readv)            /* 145 */
        .long SYMBOL_NAME(sys_writev)
        .long SYMBOL_NAME(sys_getsid)
        .long SYMBOL_NAME(sys_fdatasync)
        .long SYMBOL_NAME(sys_sysctl)
        .long SYMBOL_NAME(sys_mlock)            /* 150 */
        .long SYMBOL_NAME(sys_munlock)
        .long SYMBOL_NAME(sys_mlockall)
        .long SYMBOL_NAME(sys_munlockall)
        .long SYMBOL_NAME(sys_sched_setparam)
        .long SYMBOL_NAME(sys_sched_getparam)   /* 155 */
        .long SYMBOL_NAME(sys_sched_setscheduler)
        .long SYMBOL_NAME(sys_sched_getscheduler)
        .long SYMBOL_NAME(sys_sched_yield)
        .long SYMBOL_NAME(sys_sched_get_priority_max)
        .long SYMBOL_NAME(sys_sched_get_priority_min)  /* 160 */
        .long SYMBOL_NAME(sys_sched_rr_get_interval)
        .long SYMBOL_NAME(sys_nanosleep)
        .long SYMBOL_NAME(sys_mremap)
        .long SYMBOL_NAME(sys_setresuid16)
        .long SYMBOL_NAME(sys_getresuid16)      /* 165 */
        .long SYMBOL_NAME(sys_vm86)
        .long SYMBOL_NAME(sys_query_module)
        .long SYMBOL_NAME(sys_poll)
        .long SYMBOL_NAME(sys_nfsservctl)
        .long SYMBOL_NAME(sys_setresgid16)      /* 170 */
        .long SYMBOL_NAME(sys_getresgid16)
        .long SYMBOL_NAME(sys_prctl)
        .long SYMBOL_NAME(sys_rt_sigreturn)
        .long SYMBOL_NAME(sys_rt_sigaction)
        .long SYMBOL_NAME(sys_rt_sigprocmask)   /* 175 */
        .long SYMBOL_NAME(sys_rt_sigpending)
        .long SYMBOL_NAME(sys_rt_sigtimedwait)
        .long SYMBOL_NAME(sys_rt_sigqueueinfo)
        .long SYMBOL_NAME(sys_rt_sigsuspend)
        .long SYMBOL_NAME(sys_pread)            /* 180 */
        .long SYMBOL_NAME(sys_pwrite)
        .long SYMBOL_NAME(sys_chown16)
        .long SYMBOL_NAME(sys_getcwd)
        .long SYMBOL_NAME(sys_capget)
        .long SYMBOL_NAME(sys_capset)           /* 185 */
        .long SYMBOL_NAME(sys_sigaltstack)
        .long SYMBOL_NAME(sys_sendfile)
        .long SYMBOL_NAME(sys_ni_syscall)               /* streams1 */
        .long SYMBOL_NAME(sys_ni_syscall)               /* streams2 */
        .long SYMBOL_NAME(sys_vfork)            /* 190 */
        .long SYMBOL_NAME(sys_getrlimit)
        .long SYMBOL_NAME(sys_mmap2)
        .long SYMBOL_NAME(sys_truncate64)
        .long SYMBOL_NAME(sys_ftruncate64)
        .long SYMBOL_NAME(sys_stat64)           /* 195 */
        .long SYMBOL_NAME(sys_lstat64)
        .long SYMBOL_NAME(sys_fstat64)
        .long SYMBOL_NAME(sys_lchown)
        .long SYMBOL_NAME(sys_getuid)
        .long SYMBOL_NAME(sys_getgid)           /* 200 */
        .long SYMBOL_NAME(sys_geteuid)
        .long SYMBOL_NAME(sys_getegid)
        .long SYMBOL_NAME(sys_setreuid)
        .long SYMBOL_NAME(sys_setregid)
        .long SYMBOL_NAME(sys_getgroups)        /* 205 */
        .long SYMBOL_NAME(sys_setgroups)
        .long SYMBOL_NAME(sys_fchown)
        .long SYMBOL_NAME(sys_setresuid)
        .long SYMBOL_NAME(sys_getresuid)
        .long SYMBOL_NAME(sys_setresgid)        /* 210 */
        .long SYMBOL_NAME(sys_getresgid)
        .long SYMBOL_NAME(sys_chown)
        .long SYMBOL_NAME(sys_setuid)
        .long SYMBOL_NAME(sys_setgid)
        .long SYMBOL_NAME(sys_setfsuid)         /* 215 */
        .long SYMBOL_NAME(sys_setfsgid)
        .long SYMBOL_NAME(sys_pivot_root)
        .long SYMBOL_NAME(sys_mincore)
        .long SYMBOL_NAME(sys_madvise)
        .long SYMBOL_NAME(sys_getdents64)       /* 220 */
        .long SYMBOL_NAME(sys_fcntl64)
        .long SYMBOL_NAME(sys_ni_syscall)       /* reserved for TUX */
        .long SYMBOL_NAME(sys_ni_syscall)       /* Reserved for Security */
        .long SYMBOL_NAME(sys_gettid)
        .long SYMBOL_NAME(sys_readahead)        /* 225 */


</pre>
<h3>Ev&egrave;nement IRQ</h3>
<p>Quand arrive une IRQ, la T&acirc;che qui tourne est interrompue
pour servir (in order to service) le gestionnaire d'IRQ.</p>
<p>Apr&egrave;s que l'IRQ soit g&eacute;r&eacute;e, le
contr&ocirc;le retourne exactement au point de l'interruption,
comme si rien ne s'&eacute;tait pass&eacute;.</p>
<pre>

           
              Running Task 
             |-----------|          (3)
NORMAL       |   |       | [break execution] IRQ Handler
EXECUTION (1)|   |       |     -------------&gt;|---------| 
             |  \|/      |     |             |  does   |         
 IRQ (2)----&gt;| ..        |-----&gt;             |  some   |      
             |   |       |&lt;-----             |  work   |       
BACK TO      |   |       |     |             |  ..(4). |
NORMAL    (6)|  \|/      |     &lt;-------------|_________|
EXECUTION    |___________|  [return to code]
                                    (5)
               USER MODE                     KERNEL MODE

         Transition Mode Utilisateur-&gt;Noyau caus&eacute;e par un &eacute;v&egrave;nement IRQ
     
</pre>
<p>Les pas &eacute;num&eacute;r&eacute;s plus bas se
r&eacute;f&egrave;rent &agrave; la s&eacute;quence des
&eacute;v&egrave;nements dans le diagramme au-dessus/</p>
<ol>
<li>Le processus est ex&eacute;cut&eacute;</li>
<li>l'IRQ arrive alors que la T&acirc;che tourne.</li>
<li>La T&acirc;che est interrompue pour appeler un "gestionnaire
d'Interruption".</li>
<li>Le code du "gestionnaire d'Interruption" est
ex&eacute;cut&eacute;.</li>
<li>Le contr&ocirc;le revient &agrave; la T&acirc;che en mode
utilisateur (comme si rien ne s'&eacute;tait pass&eacute;)</li>
<li>Le processus revient &agrave; une ex&eacute;cution normale</li>
</ol>
<p>Un point sp&eacute;cialement int&eacute;ressant, l'IRQ Timer,
qui se produit &agrave; chaque TIMER ms pour g&eacute;rer:</p>
<ol>
<li>Alarmes</li>
<li>Compteurs syst&egrave;mes and T&acirc;ches (utilis&eacute; par
un programmes pour d&eacute;cider quand arr&ecirc;ter un processus
ou pour comptage (for accounting))</li>
<li>Le mutiT&acirc;che bas&eacute; sur un m&eacute;canisme
d'&eacute;veil apr&egrave;s un temps TIMESLICE.</li>
</ol>
<h2><a name="ss3.4">3.4 Multitache</a></h2>
<h3>M&eacute;canisme</h3>
<p>Le point central d'un SE moderne est la "T&acirc;che". La
T&acirc;che est une application qui tourne en m&eacute;moire en
partageant toutes ressources (y compris CPU =processeur et
m&eacute;moire) avec les autres T&acirc;ches.</p>
<p>Cette "ressource partag&eacute;e" est g&eacute;r&eacute;e par le
"M&eacute;canisme MultiT&acirc;che". Le M&eacute;canisme
MultiT&acirc;che passe d'une T&acirc;che &agrave; une autre
apr&egrave;s un "timeslice" (temps de glissement). Les utilisateurs
ont l'"illusion" qu'ils poss&egrave;dent toutes les ressources. On
peut aussi imaginer un sc&eacute;nario simple utilisateur, quand un
utilisateur paut avoir l'"illusion" de faire tourner plusieurs
T&acirc;ches en m&ecirc;me temps.</p>
<p>Pour impl&eacute;menter ce multit&acirc;che, la T&acirc;che
utilise la variable d'"&eacute;tat" ("the state" variable), qui
peut &ecirc;tre:</p>
<ol>
<li>READY, pr&ecirc;t pour ex&eacute;cution</li>
<li>BLOCKED, en attente d'une ressource</li>
</ol>
<p>L'&eacute;tat de la T&acirc;che est g&eacute;r&eacute; par sa
pr&eacute;sence dans une liste relative: liste READY et liste
BLOCKED.</p>
<h3>Changement de T&acirc;che</h3>
<p>Le mouvement d'une T&acirc;che &agrave; l'autre est
appel&eacute; ''Task Switching'' (Changement de T&acirc;che).
plusieurs ordinateurs ont une instruction mat&eacute;rielle qui
r&eacute;alise automatiquement cette op&eacute;ration. Le
Changement de T&acirc;che se produit dans les cas suivants:</p>
<ol>
<li>Apr&egrave;s la fin d'un Timeslice: nous devons programmer une
T&acirc;che "Pr&ecirc;te &agrave; ex&eacute;cution" et lui donner
acc&egrave;s (schedule a "Ready for execution" task and give it
access).</li>
<li>Quand une T&acirc;che doit attendre un
p&eacute;riph&eacute;rique: nous devons programmer une nouvelle
T&acirc;che et l'y brancher *</li>
</ol>
<p>* Nous programmons une autre T&acirc;che pour &eacute;viter
"Busy Form Waiting" (forme occup&eacute;e en attente), qui se
produit quand nous attendons un p&eacute;riph&eacute;rique au lieu
de r&eacute;aliser un autre travail.</p>
<p>Le Changement de T&acirc;che est g&eacute;r&eacute; par
l'entit&eacute; "Schedule" (Programme).</p>
<pre>
 
Timer    |           |
 IRQ     |           |                            Schedule
  |      |           |                     ________________________
  |-----&gt;|   Task 1  |&lt;------------------&gt;|(1)Chooses a Ready Task |
  |      |           |                    |(2)Task Switching       |
  |      |___________|                    |________________________|   
  |      |           |                               /|\
  |      |           |                                | 
  |      |           |                                |
  |      |           |                                |
  |      |           |                                |      
  |-----&gt;|   Task 2  |&lt;-------------------------------|
  |      |           |                                |
  |      |___________|                                |
  .      .     .     .                                .
  .      .     .     .                                .
  .      .     .     .                                .
  |      |           |                                |
  |      |           |                                |
  ------&gt;|   Task N  |&lt;--------------------------------
         |           |
         |___________| 
    
            Changement de T&acirc;che bas&eacute; sur un glissement de temps (TimeSlice)
 
</pre>
<p>Un Glissement de temps typique pour linux est environ 10ms.</p>
<pre>

 

 |           |            
 |           | Resource    _____________________________
 |   Task 1  |-----------&gt;|(1) Enqueue Resource request |
 |           |  Access    |(2)  Mark Task as blocked    |
 |           |            |(3)  Choose a Ready Task     |
 |___________|            |(4)    Task Switching        |
                          |_____________________________|
                                       |
                                       |
 |           |                         |
 |           |                         |
 |   Task 2  |&lt;-------------------------
 |           |  
 |           |
 |___________|
 
     Changement de T&acirc;che bas&eacute; sur l'Attente d'une Ressource
 
</pre>
<h2><a name="ss3.5">3.5 Micronoyau vs SE Monolithique</a></h2>
<h3>Vue d'ensemble</h3>
<p>Jusqu'&agrave; maintenant nous avons vus le SE appel&eacute;
Monolithique, mais il y a aussi une autre sorte de SE:
''Micronoyau''.</p>
<p>Un Micronoyau utilise des T&acirc;ches, pas seulement pour les
processus en mode utilisateur, mais aussi comme un vrai
gestionnaire de noyau, comme T&acirc;che-Disquette, T&acirc;che-DD,
T&acirc;che-R&eacute;seau etc. Quelques exemples sont Amoeba, et
Mach.</p>
<h3>POURS et CONTRES le SE Micronoyau</h3>
<p>POURS:</p>
<ul>
<li>Le SE est plus simple &agrave; maintenir parce que chaque
T&acirc;che g&egrave;re un seul type d'op&eacute;ration. Aussi si
vous voulez modifier le r&eacute;seau, vous modifiez
T&acirc;che-R&eacute;seau (id&eacute;alement, si une mise &agrave;
jour structurelle n'est pas n&eacute;cessaire).</li>
</ul>
<p>CONTRES:</p>
<ul>
<li>Les performances sont pires que pour un SE Monolithique, parce
que vous devez ajouter 2*TASK_SWITCH temps ou temps de changement
(le premier pour entrer dans la T&acirc;che sp&eacute;cifique, le
second pour en sortir)</li>
</ul>
<p>Mon opinion personnelle est que, les Micronoyaux sont un bon
exemple didactique (comme Minix) mais ils ne sont pas "optimums",
aussi ils ne sont pas r&eacute;ellement convenables. Linux utilise
quelques T&acirc;ches, appel&eacute;es "Fils Noyau" pour
impl&eacute;menter une petite structure Micronoyau (comme kswapd,
qui est utilis&eacute; pour r&eacute;cup&eacute;rer les pages
m&eacute;moire du stockage de masse). Dans ce cas il n'y a aucun
probl&egrave;me de performance parce que le glissement (swapping)
est un travail tr&egrave;s lent.</p>
<h2><a name="ss3.6">3.6 R&eacute;seau</a></h2>
<h3>Niveaux ISO OSI</h3>
<p>Le standard ISO-OSI d&eacute;crit une architecture r&eacute;seau
avec les niveaux suivants:</p>
<ol>
<li>Niveau physique (exemples: PPP et Ethernet)</li>
<li>Niveau lien-donn&eacute;e (Data-link) (exemples: PPP et
Ethernet)</li>
<li>Niveau r&eacute;seau (Network) (exemples: IP, et X.25)</li>
<li>Niveau transport (exemples: TCP, UDP)</li>
<li>Niveau session (SSL)</li>
<li>Niveau pr&eacute;sentation (FTP cod&eacute; binaire-ascii)</li>
<li>Niveau application (applications comme Netscape)</li>
</ol>
<p>Les 2 premiers niveaux lit&eacute;s ci-dessus sont souvent
impl&eacute;ment&eacute;s dans le mat&eacute;riel. Les niveaux
suivants sont dans le logiciel (ou firmware (mat&eacute;riel
sp&eacute;cifiques?) pour les routeurs).</p>
<p>Plusieurs protocoles sont utilis&eacute;s par un SE: un d'eux
est TCP/IP (le plus important qui r&eacute;side aux niveaux
3-4).</p>
<h3>Que fait le noyau?</h3>
<p>Le noyau ne sait rien faire des 2 premiers niveaux de
ISO-OSI.</p>
<p>Au RX il:</p>
<ol>
<li>Il g&egrave;re (handshake) les p&eacute;riph&eacute;riques de
bas niveau (comme carte ethernet ou modem) en recevant des "cadres"
(frames) de leur part.</li>
<li>Il construit des "paquets" TCP/IP &agrave; partir des "cadres"
(comme ceux d'Ethernet ou de PPP).</li>
<li>Convertit des ''paquets'' dans des ''connexions'' en les
passant &agrave; la bonne application (gr&acirc;ce au num&eacute;ro
de port) ou</li>
<li>Transmet des paquets &agrave; la bonne queue</li>
</ol>
<pre>
(cadres)       (paquets)            (connexions)
frames         packets              sockets
NIC ---------&gt; Kernel ----------&gt; Application
                 (Noyau)
                  |    packets
                  --------------&gt; Forward
                        - RX -       (Transmission)
</pre>
<p>Au stage TX il:</p>
<ol>
<li>Convertit des connexions ou</li>
<li>Des donn&eacute;es de queues (Queues datas) dans des
''paquets'' TCP/IP</li>
<li>Partage des ''packets" en "cadres" (comme ceux d'Ethernet ou de
PPP)</li>
<li>Envoie des ''cadres'' en utilisant des pilotes HW</li>
</ol>
<pre>
(connexion)   (paquets)                   (cadres)
sockets       packets                     frames
Application ---------&gt; Kernel ----------&gt; NIC
              packets     /|\    
Forward  -------------------
(Transmission)          - TX -  


</pre>
<h2><a name="ss3.7">3.7 M&eacute;moire virtuelle</a></h2>
<h3>Segmentation</h3>
<p>La segmentation est la premi&egrave;re m&eacute;thode pour
r&eacute;soudre les probl&egrave;mes d'allocation m&eacute;moire:
il vous permet de compiler du code source sans se soucier
d'o&ugrave; l'application sera plac&eacute;e dans la
m&eacute;moire. En fait, cette caract&eacute;ristique aide les
d&eacute;veloppeurs d'application &agrave; d&eacute;velopper de
fa&ccedil;on ind&eacute;pendante du SE et aussi du
mat&eacute;riel.</p>
<pre>
     
            |       Stack        |
            |          |         |
            |         \|/        |
            |        Free        | 
            |         /|\        |     Segment &lt;---&gt; Process    
            |          |         |
            |        Heap        |
            | Data uninitialized |
            |  Data initialized  |
            |       Code         |
            |____________________|  
 
                   Segment  

</pre>
<p>Nous pouvons dire qu'un segment est l'entit&eacute; logique
d'une application, ou l'image de l'application en
m&eacute;moire.</p>
<p>Quand on programme, on ne se soucie pas de o&ugrave; nos
donn&eacute;es sont mises en m&eacute;moire, on ne
s'int&eacute;resse qu'&agrave; l'offset &agrave; l'int&eacute;rieur
de notre segment (notre application). (the offset inside our
segment (our application))</p>
<p>On a l'habitude d'assigner un Segment &agrave; chaque processus
et vice-versa. Avec Linux ce n'est pas vrai. Linux utilise
seulement 4 segments pour chaque Noyau et tous les Processus.</p>
<h3>Probl&egrave;me de Segmentation</h3>
<pre>
 
                                 ____________________
                          -----&gt;|                    |-----&gt;
                          | IN  |     Segment A      | OUT
 ____________________     |     |____________________|   
|                    |____|     |                    |   
|     Segment B      |          |     Segment B      |
|                    |____      |                    |   
|____________________|    |     |____________________|   
                          |     |     Segment C      |   
                          |     |____________________|
                          -----&gt;|     Segment D      |-----&gt; 
                            IN  |____________________| OUT 
 
                     Segmentation problem


</pre>
<p>Dans le diagramme au-dessus, nous voulons sortir des processus A
et D et entrer dans le processus B. Comme on peut voir il y a assez
d'espace pour B, mais nous ne pouvons pas le partager en 2
morceaux, aussi nous NE POUVONS PAS le charger (plus de
m&eacute;moire).</p>
<p>La raison de ce probl&egrave;me est les purs segments sont des
zones continues (parce que ce sont des zones logiques) et ne
peuvent pas &ecirc;tre partag&eacute;es.</p>
<h3>Pagination</h3>
<pre>
 
             ____________________
            |     Page 1         |
            |____________________|
            |     Page 2         |
            |____________________| 
            |      ..            |     Segment &lt;---&gt; Process    
            |____________________|
            |     Page n         |
            |____________________|
            |                    |
            |____________________|
            |                    |
            |____________________|  
 
                   Segment  
 
</pre>
<p>La Pagination partage la m&eacute;moire en "n" morceaux, chacun
d'eux avec une longueur fix&eacute;e.</p>
<p>Un processus peut &ecirc;tre charg&eacute; en une ou plusieurs
pages. Quand la m&eacute;moire est lib&eacute;r&eacute;e, toutes
les pages sont lib&eacute;r&eacute;es (voir Probl&egrave;me de
Segmentation, avant).</p>
<p>La Pagination est aussi utilis&eacute;e dans un autre but
important, le "Swapping" (glissement). Si une page n'est pas
pr&eacute;sente dans la m&eacute;moire physique, il
g&eacute;n&egrave;re une EXCEPTION, qui poussera le Noyau &agrave;
chercher une nouvelle page dans la m&eacute;moire de stockage. Ce
m&eacute;canisme permet au SE de charger plus d'applications que
celles permises seulement par la m&eacute;moire physique.</p>
<h3>Probl&egrave;me de Pagination</h3>
<pre>
             ____________________
   Page   X |     Process Y      |
            |____________________|
            |                    |
            |       WASTE        |
            |       SPACE        |
            |____________________|  
   
            Probl&egrave;me de Pagination
 
</pre>
<p>Dans le diagramme qu-dessus, nous pouvons voir ce qui ne va pas
dans la politique de pagination: quand un Processus Y se charge
dans la Page X, TOUT l'espace m&eacute;moire de la Page est
allou&eacute;, aussi l'espace restant &agrave; la fin de la page
est perdu.</p>
<h3>Segmentation et Pagination</h3>
<p>Comment peut-on r&eacute;soudre les probl&egrave;mes de
segmentation et de pagination? En utilisant les 2 politiques.</p>
<pre>
 
                                  |      ..            |
                                  |____________________|
                            -----&gt;|      Page 1        |
                            |     |____________________|
                            |     |      ..            |
 ____________________       |     |____________________|
|                    |      |----&gt;|      Page 2        |
|      Segment X     |  ----|     |____________________|
|                    |      |     |       ..           |
|____________________|      |     |____________________|
                            |     |       ..           |
                            |     |____________________|
                            |----&gt;|      Page 3        |
                                  |____________________|
                                  |       ..           |
 
</pre>
<p>Le Processus X, identifi&eacute; par le Segment X, est
partag&eacute; en 3 morceaux et chacun d'eux est charg&eacute; dans
une page.</p>
<p>Nous n'avons pas de:</p>
<ol>
<li>Probl&egrave;me de Segmentation: nous allouons par Pages, ainsi
nous lib&eacute;rons aussi les Pages, et nous g&eacute;rons
l'espace libre de fa&ccedil;on optimis&eacute;e.</li>
<li>Probl&egrave;me de Pagination: seule la derni&egrave;re page
perd de l'espace, mais nous pouvons d&eacute;cider d'utiliser de
tr&egrave;s petites pages, par exemple 4096 octets de long (perdant
au maximum 4096*N_T&acirc;ches octets) et g&eacute;rer une
pagination hierarchis&eacute;e (manage hierarchical paging) (en
utilisant 2 ou 3 niveaux de pagination)</li>
</ol>
<pre>
 
 

                          |         |           |         |
                          |         |   Offset2 |  Value  |
                          |         |        /|\|         |
                  Offset1 |         |-----    | |         |
                      /|\ |         |    |    | |         |
                       |  |         |    |   \|/|         | 
                       |  |         |    ------&gt;|         |
                      \|/ |         |           |         |
 Base Paging Address ----&gt;|         |           |         |
                          | ....... |           | ....... |
                          |         |           |         |    
 
                     Hierarchical Paging
</pre>
<h2><a name="s4">4. D&eacute;marrage De Linux</a></h2>
<p>Nous d&eacute;marrons le noyau Linux par du code de C
ex&eacute;cut&eacute; &agrave; partir de l'&eacute;tiquette asm
''startup_32:</p>
<pre>
|startup_32:
   |start_kernel
      |lock_kernel
      |trap_init
      |init_IRQ
      |sched_init
      |softirq_init
      |time_init
      |console_init 
      |#ifdef CONFIG_MODULES 
         |init_modules 
      |#endif 
      |kmem_cache_init 
      |sti 
      |calibrate_delay 
      |mem_init
      |kmem_cache_sizes_init
      |pgtable_cache_init
      |fork_init
      |proc_caches_init 
      |vfs_caches_init
      |buffer_init
      |page_cache_init
      |signals_init 
      |#ifdef CONFIG_PROC_FS 
        |proc_root_init 
      |#endif 
      |#if defined(CONFIG_SYSVIPC) 
         |ipc_init
      |#endif 
      |check_bugs      
      |smp_init
      |rest_init
         |kernel_thread
         |unlock_kernel
         |cpu_idle
</pre>
<ul>
<li>startup_32 [arch/i386/kernel/head.S]</li>
<li>start_kernel [init/main.c]</li>
<li>lock_kernel [include/asm/smplock.h]</li>
<li>trap_init [arch/i386/kernel/traps.c]</li>
<li>init_IRQ [arch/i386/kernel/i8259.c]</li>
<li>sched_init [kernel/sched.c]</li>
<li>softirq_init [kernel/softirq.c]</li>
<li>time_init [arch/i386/kernel/time.c]</li>
<li>console_init [drivers/char/tty_io.c]</li>
<li>init_modules [kernel/module.c]</li>
<li>kmem_cache_init [mm/slab.c]</li>
<li>sti [include/asm/system.h]</li>
<li>calibrate_delay [init/main.c]</li>
<li>mem_init [arch/i386/mm/init.c]</li>
<li>kmem_cache_sizes_init [mm/slab.c]</li>
<li>pgtable_cache_init [arch/i386/mm/init.c]</li>
<li>fork_init [kernel/fork.c]</li>
<li>proc_caches_init</li>
<li>vfs_caches_init [fs/dcache.c]</li>
<li>buffer_init [fs/buffer.c]</li>
<li>page_cache_init [mm/filemap.c]</li>
<li>signals_init [kernel/signal.c]</li>
<li>proc_root_init [fs/proc/root.c]</li>
<li>ipc_init [ipc/util.c]</li>
<li>check_bugs [include/asm/bugs.h]</li>
<li>smp_init [init/main.c]</li>
<li>rest_init</li>
<li>kernel_thread [arch/i386/kernel/process.c]</li>
<li>unlock_kernel [include/asm/smplock.h]</li>
<li>cpu_idle [arch/i386/kernel/process.c]</li>
</ul>
<p>La derni&egrave;re fonction ''rest_init'' fait ceci:</p>
<ol>
<li>lance le fil ''init'' du noyau</li>
<li>appelle unlock_kernel</li>
<li>fait tourner la routine de cpu_idle par le noyau, celle sera la
boucle &agrave; vide s'ex&eacute;cutant quand rien n'est
programm&eacute;</li>
</ol>
<p>En fait la proc&eacute;dure start_kernel ne finit jamais. Elle
ex&eacute;cutera la routine de cpu_idle sans fin.</p>
<p>Suit la description de ''d'init'', qui est le premier fil du
noyau:</p>
<pre>
|init
   |lock_kernel
   |do_basic_setup
      |mtrr_init
      |sysctl_init
      |pci_init
      |sock_init
      |start_context_thread
      |do_init_calls
         |(*call())-&gt; kswapd_init
   |prepare_namespace
   |free_initmem
   |unlock_kernel
   |execve
</pre>
<h2><a name="s5">5. Particularit&eacute;s De Linux</a></h2>
<h2><a name="ss5.1">5.1 Vue d'ensemble</a></h2>
<p>Linux a quelques particularit&eacute;s qui le distinguent
d'autre SE. Ces particularit&eacute;s incluent:</p>
<ol>
<li>Paginations seules</li>
<li>Softirq</li>
<li>Fils du noyau</li>
<li>Modules du noyau</li>
<li>Dossier ''Proc''</li>
</ol>
<h3>El&eacute;ments De Flexibilit&eacute;</h3>
<p>Les points 4 et 5 donnent une &eacute;norme flexibilit&eacute;
aux administrateurs syst&egrave;me sur la configuration
syst&egrave;me du Mode Utilisateur leur permettant de
r&eacute;soudre &eacute;galement des erreurs de noyau critiques ou
des probl&egrave;mes sp&eacute;cifiques sans relancer la machine.
Par exemple, si vous devez changer quelque chose sur un gros
serveur et vous ne voulez pas faire une r&eacute;initialisation,
vous pourriez pr&eacute;parer le noyau &agrave; dialoguer avec un
module, que vous &eacute;crirez.</p>
<h2><a name="ss5.2">5.2 Paginations seules</a></h2>
<p>Linux n'utilise pas la segmentation pour distinguer les
T&acirc;ches les unes des autres; il utilise la pagination.
(seulement 2 segments sont utilis&eacute;s pour tous les
T&acirc;ches, CODE et DATA/stack)</p>
<p>Nous pouvons &eacute;galement dire qu'un d&eacute;faut de page
interTask ne se produit jamais, parce que chaque T&acirc;che
utilise un ensemble de Tables de Page diff&eacute;rents pour chaque
T&acirc;che. Il y a quelques cas o&ugrave; des T&acirc;ches
diff&eacute;rentes pointent vers les m&ecirc;mes Tables de page,
comme les biblioth&egrave;ques partag&eacute;es: c'est
n&eacute;cessaire pour r&eacute;duire l'utilisation de la
m&eacute;moire; rappelez-vous que les biblioth&egrave;ques
partag&eacute;es sont seulement du CODE parce que toutes les
donn&eacute;es sont stock&eacute;es dans la pile actuelle de la
T&acirc;che.</p>
<h3>Segments de Linux</h3>
<p>Sous le noyau Linux seulement 4 segments existent:</p>
<ol>
<li>Kernel Code [0x10] (Code Noyau)</li>
<li>Kernel Data / Stack [0x18] (Donn&eacute;es Noyau / Pile)</li>
<li>User Code [0x23] (Code Utilisateur)</li>
<li>User Data / Stack [0x2b] (Donn&eacute;es D'Utilisateur /
Pile)</li>
</ol>
<p>[ la syntaxe est ''But [Segment]'']</p>
<p>Sous architecture Intel, les registres de segment
utilis&eacute;s sont:</p>
<ul>
<li>CS pour Code Segment</li>
<li>DS pour Data Segment (Segment Donn&eacute;es)</li>
<li>SS pour Stack Segment (Segment Pile)</li>
<li>ES pour Alternative Segment (Segment Alternatif) (par exemple
utilis&eacute; pour faire une copie de m&eacute;moire entre 2
segments)</li>
</ul>
<p>Ainsi, chaque T&acirc;che utilise 0x23 pour le code et le 0x2b
pour donn&eacute;es/pile</p>
<h3>Pagination Linux</h3>
<p>Sous Linux 3 niveaux des pages sont utilis&eacute;s, selon
l'architecture. Sous Intel seulement 2 niveaux sont
support&eacute;s. Linux supporte aussi la Copie sur
m&eacute;canismes Ecriture (voir Chap.10 pour plus
d'information).</p>
<h3>Pourquoi les conflits d'adresse interTasks n'existent-ils
pas?</h3>
<p>La r&eacute;ponse est tr&egrave;s tr&egrave;s simple: les
conflits d'adresse interTask ne peuvent pas exister parce qu'ils
sont impossibles. Le tra&ccedil;age lin&eacute;aire -&gt; physique
est fait par "Pagination", ainsi il a juste besoin d'assigner les
pages physiques de mani&egrave;re univoque.</p>
<h3>Avons-nous besoin de d&eacute;fragmenter la
m&eacute;moire?</h3>
<p>Le num&eacute;ro d'Assignement de page est un processus
dynamique. Nous avons besoin d'une seule page quand une T&acirc;che
le demande, ainsi nous la choisissons dans les pages libres de
mani&egrave;re ordonn&eacute;e. Quand nous voulons lib&eacute;rer
la page, nous devons seulement l'ajouter &agrave; la liste des
pages libres.</p>
<h3>Et au sujet des pages noyau?</h3>
<p>Les pages noyau ont un probl&egrave;me: elles peuvent &ecirc;tre
assign&eacute;es de fa&ccedil;on dynamique mais nous ne pouvons pas
avoir de garantie qu'elles sont dans une zone allou&eacute;e
continue, parce que l'espace lin&eacute;aire du noyau est
&eacute;quivalent &agrave; l'espace physique du noyau.</p>
<p>Pour le Segment Code il n'y a pas de probl&egrave;me. Le code de
d&eacute;marrage est assign&eacute; lors du d&eacute;marrage (aussi
nous avons une quantit&eacute; fixe de m&eacute;moire &agrave;
assigner), et sur les modules nous devons seulement allouer une
zone m&eacute;moire qui pourrait contenir le code du module.</p>
<p>Le vrai probl&egrave;me est le segment de pile parce que chaque
T&acirc;che utilise des pages de pile noyau. Les segments de pile
doivent &ecirc;tre contigus (selon la d&eacute;finition de pile),
ainsi nous devons &eacute;tablir une limite maximum pour la
dimension de pile de chaque T&acirc;che. Si nous d&eacute;passons
cette limite, de mauvaises choses se produisent. Nous recouvrons
des structures de donn&eacute;es de processus en Mode Noyau.</p>
<p>La structure du noyau nous aide, parce que les fonctions du
noyau ne sont jamais:</p>
<ul>
<li>recursives</li>
<li>intercalling plus de N fois.</li>
</ul>
<p>Une fois que nous connaissons N, et que nous connaissons la
moyenne des variables statiques pour toutes les fonctions noyau,
nous pouvons estimer une limite de pile.</p>
<p>Si vous voulez tester le probl&egrave;me, vous pouvez
cr&eacute;er un module avec une fonction qui s'appelle plusieurs
fois. Apr&egrave;s un nombre fix&eacute; de fois, le module du
noyau abandonnera en raison d'une faute du gestionnaire de page
d'exception (typiquement &eacute;crire &agrave; une page
lecture-seule).</p>
<h2><a name="ss5.3">5.3 Softirq</a></h2>
<p>Quand un IRQ arrive, la commutation de T&acirc;che est
report&eacute;e &agrave; plus tard pour obtenir de meilleures
performances. Quelques travaux de T&acirc;che (qui pourrait devoir
&ecirc;tre fait juste apr&eacute;s l'IRQ et qui pourraient prendre
beaucoup de processeur dans le temps d'interruption, comme
accumuler un paquet de TCP/IP) sont mis en queue (align&eacute;s)
et seront faits au temps programm&eacute; (une fois qu'un
temps-tranche (time-slice) finit).</p>
<p>Dans les noyaux r&eacute;cents (2.4.x) les m&eacute;canismes de
softirq sont pass&eacute;s &agrave; un kernel_thread (fil de
noyau): ''ksoftirqd_CPUn''. n repr&eacute;sente le nombre
processeur ex&eacute;cutant le kernel_thread (dans syst&egrave;me
monoprocessor ''ksoftirqd_CPU0'' utilise PID 3).</p>
<h3>Pr&eacute;paration De Softirq</h3>
<h3>Autoriser Softirq</h3>
<p>Le ''cpu_raise_softirq'' est une routine qui r&eacute;veille le
fil du noyau ''ksoftirqd_CPU0'', pour le laisser contr&ocirc;ler le
travail mis en file d'attente.</p>
<pre>
|cpu_raise_softirq
   |__cpu_raise_softirq
   |wakeup_softirqd
      |wake_up_process
</pre>
<ul>
<li>cpu_raise_softirq [kernel/softirq.c]</li>
<li>__cpu_raise_softirq [include/linux/interrupt.h]</li>
<li>wakeup_softirq [kernel/softirq.c]</li>
<li>wake_up_process [kernel/sched.c]</li>
</ul>
<p>la routine ''__de cpu_raise_softirq__'' placera le bon octet
dans le vecteur d&eacute;crivant le softirq en suspens.</p>
<p>''wakeup_softirq'' utilise le ''wakeup_process'' pour
r&eacute;veiller le fil du noyau ''ksoftirqd_CPU0''.</p>
<h3>Ex&eacute;cution De Softirq</h3>
<p>A FAIRE: d&eacute;crire les structures de donn&eacute;es
impliqu&eacute;es dans le m&eacute;canisme de softirq.</p>
<p>Quand le fil noyau ''ksoftirqd_CPU0'' a &eacute;t&eacute;
r&eacute;veill&eacute;, il ex&eacute;cute les travaux de la
file.</p>
<p>Le code de ''ksoftirqd_CPU0'' est (boucle principale sans
fin):</p>
<pre>
for (;;) {
   if (!softirq_pending(cpu)) 
      schedule();
      __set_current_state(TASK_RUNNING);
   while (softirq_pending(cpu)) { 
      do_softirq(); 
      if (current-&gt;need_resched) 
         schedule 
   }
   __set_current_state(TASK_INTERRUPTIBLE)
}
</pre>
<ul>
<li>ksoftirqd [kernel/softirq.c]</li>
</ul>
<h2><a name="ss5.4">5.4 Fils Du Kernel</a></h2>
<p>Quoique Linux soit un OS monolithique, quelques ''fils du
noyau'' existent pour faire le m&eacute;nage.</p>
<p>Ces T&acirc;ches n'utilisent pas la m&eacute;moire Utilisateur;
elles partagent la m&eacute;moire NOYAU. Elles op&egrave;rent
&eacute;galement avec le privil&egrave;ge le plus
&eacute;lev&eacute; (ANNEAU 0 sur une architecture i386) comme tout
autre bout de code Mode Noyau.</p>
<p>Des fils du noyau sont cr&eacute;&eacute;s par la fonction
''kernel_thread [ arch/i386/kernel/process ]'', qui appelle un
appel syst&egrave;me ''clone'' [ arch/i386/kernel/process.c ] de
l'assembleur (qui est ''une fourche'' comme l'appel
syst&egrave;me):</p>
<pre>
int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
{
        long retval, d0;
 
        __asm__ __volatile__(
                "movl %%esp,%%esi\n\t"
                "int $0x80\n\t"         /* Linux/i386 system call */
                "cmpl %%esp,%%esi\n\t"  /* child or parent? */
                "je 1f\n\t"             /* parent - jump */
                /* Load the argument into eax, and push it.  That way, it does
                 * not matter whether the called function is compiled with
                 * -mregparm or not.  */
                "movl %4,%%eax\n\t"
                "pushl %%eax\n\t"               
                "call *%5\n\t"          /* call fn */
                "movl %3,%0\n\t"        /* exit */
                "int $0x80\n"
                "1:\t"
                :"=&amp;a" (retval), "=&amp;S" (d0)
                :"0" (__NR_clone), "i" (__NR_exit),
                 "r" (arg), "r" (fn),
                 "b" (flags | CLONE_VM)
                : "memory");
        return retval;
}
</pre>
<p>Une fois appel&eacute;e, nous avons une nouvelle T&acirc;che
(habituellement avec un nombre tr&egrave;s bas de PID, comme 2.3,
etc...) attendant une ressource tr&egrave;s lente, comme un
&eacute;v&eacute;nement &eacute;change ou usb. Une ressource
tr&egrave;s lente est utilis&eacute;e parce qu'autrement nous
aurions une commutation de T&acirc;che co&ucirc;teuse
(overhead).</p>
<p>Au-dessous une liste de la plupart des fils du noyau courants
(avec ''ps x''):</p>
<pre>
PID      COMMAND
 1        init
 2        keventd
 3        kswapd
 4        kreclaimd
 5        bdflush
 6        kupdated
 7        kacpid
67        khubd

</pre>
<p>Le fil noyau ''init'' est le premier processus
cr&eacute;&eacute;, au d&eacute;marrage. Il appellera toutes autres
T&acirc;ches Mode Utilisateur (&agrave; partir du fichier
/etc/inittab) comme les d&eacute;mons console, les d&eacute;mons
tty et les d&eacute;mons r&eacute;seau (''rc'' scripts).</p>
<h3>Exemple de fils noyau: kswapd [ mm/vmscan.c ].</h3>
<p>''kswapd'' est cr&eacute;&eacute; par ''clone()
[arch/i386/kernel/process.c]''</p>
<p>Routines d'initialisation:</p>
<pre>
|do_initcalls
   |kswapd_init
      |kernel_thread
         |syscall fork (in assembler)
</pre>
<p>do_initcalls [init/main.c]</p>
<p>kswapd_init [mm/vmscan.c]</p>
<p>kernel_thread [arch/i386/kernel/process.c]</p>
<h2><a name="ss5.5">5.5 Modules Du Kernel</a></h2>
<h3>Vue d'ensemble</h3>
<p>Les modules du noyau Linux sont des bouts de code (exemples: fs,
net, et pilotes hw) fonctionnant en Mode Noyau que vous pouvez
ajouter &agrave; chaud.</p>
<p>Le coeur de Linux ne peut pas &ecirc;tre modularis&eacute;:
programmation et gestion d'interruption ou noyau du r&eacute;seau,
etc...</p>
<p>Sous "/lib/modules/KERNEL_VERSION/" vous pouvez trouver tous les
modules install&eacute;s sur votre syst&egrave;me.</p>
<h3>Chargement et d&eacute;chargement de module</h3>
<p>Pour charger un module, tapez ce qui suit:</p>
<pre>
insmod MODULE_NAME parameters

exemple: insmod ne io=0x300 irq=9
</pre>
<p>NOTE: Vous pouvez utiliser modprobe &agrave; la place d'insmod
si vous voulez que le noyau recherche automatiquement certains
param&egrave;tres (par exemple en utilisant le pilote de PCI, ou si
vous avez indiqu&eacute; un param&egrave;tre dans le fichier
/etc/conf.modules).</p>
<p>Pour d&eacute;charger un module, tapez ce qui suit:</p>
<pre>
 rmmod MODULE_NAME
</pre>
<h3>D&eacute;finition de module</h3>
<p>Un module contient toujours:</p>
<ol>
<li>fonction "init_module", ex&eacute;cut&eacute;e &agrave; la
commande d'insmod (ou modprobe)</li>
<li>fonction "cleanup_module", ex&eacute;cut&eacute;e &agrave; la
commande de rmmod</li>
</ol>
<p>Si ces fonctions ne sont pas dans le module, vous devez ajouter
2 macros pour indiquer quelles fonctions agiront en tant qu'init et
sortie du module:</p>
<ol>
<li>module_init(FUNCTION_NAME)</li>
<li>module_exit(FUNCTION_NAME)</li>
</ol>
<p>NOTE: un module peut "voir" une variable du noyau seulement si
elle a &eacute;t&eacute; export&eacute;e (avec la macro
EXPORT_symbol).</p>
<h3>Un truc utile pour ajouter de la flexibilit&eacute; &agrave;
votre noyau</h3>
<pre>
// kernel sources side
void (*foo_function_pointer)(void *);
 
if (foo_function_pointer)
  (foo_function_pointer)(parameter);
  
 


// module side
extern void (*foo_function_pointer)(void *);

void my_function(void *parameter) {
  //My code
}
 
int init_module() {
  foo_function_pointer = &amp;my_function;
}

int cleanup_module() {
  foo_function_pointer = NULL;
}
</pre>
<p>Cette simple astuce vous permet d'avoir une flexibilit&eacute;
tr&egrave;s &eacute;lev&eacute;e dans le noyau, parce que ne ferez
ex&eacute;cuter la routine "ma_fonction" que quand vous chargerez
le module. Cette routine fera tout ce que vous voulez faire: par
exemple le module ''rshaper'', qui commande le trafic
d'entr&eacute;e de bande passante du r&eacute;seau, fonctionne dans
ce cas de figure.</p>
<p>Notez que le m&eacute;canisme entier de module est possible
gr&acirc;ce &agrave; quelques variables globales export&eacute;es
vers les modules, telles qu'une liste ent&ecirc;te (vous permettant
d'&eacute;tendre la liste autant que vous voulez). Les exemples
typiques sont fs, pilotes g&eacute;n&eacute;riques
(caract&egrave;re, bloc, r&eacute;seau, t&eacute;l&eacute;phonie).
Vous devez pr&eacute;parer le noyau &agrave; accepter votre nouveau
module; dans certains cas vous devez cr&eacute;er une
infrastructure (comme celle de la t&eacute;l&eacute;phonie,
cr&eacute;&eacute;e r&eacute;cemment) pour &ecirc;tre aussi
standard que possible.</p>
<h2><a name="ss5.6">5.6 Le dossier Proc</a></h2>
<p>Proc fs (syst&egrave;me de fichiers) est situ&eacute; dans le
dossier /proc, qui est un dossier sp&eacute;cial vous permettant de
dialoguer directement avec le noyau.</p>
<p>Linux utilise le dossier ''proc'' pour supporter les
communications directes du noyau: c'est n&eacute;cessaire dans
plusieurs de cas, par exemple quand vous voulez voir les structures
de donn&eacute;es de processus principaux ou autoriser le
dispositif ''proxy-arp'' pour une interface et pas pour d'autres,
vous voulez changer le nombre maximum de fils, ou si vous voulez
corriger certains &eacute;tats de bus, comme ISA ou PCI, pour
savoir quelles cartes sont install&eacute;es et quelles adresses
E/S et IRQs leur sont assign&eacute;es.</p>
<pre>
|-- bus
|   |-- pci
|   |   |-- 00
|   |   |   |-- 00.0
|   |   |   |-- 01.0
|   |   |   |-- 07.0
|   |   |   |-- 07.1
|   |   |   |-- 07.2
|   |   |   |-- 07.3
|   |   |   |-- 07.4
|   |   |   |-- 07.5
|   |   |   |-- 09.0
|   |   |   |-- 0a.0
|   |   |   `-- 0f.0
|   |   |-- 01
|   |   |   `-- 00.0
|   |   `-- devices
|   `-- usb
|-- cmdline
|-- cpuinfo
|-- devices
|-- dma
|-- dri
|   `-- 0
|       |-- bufs
|       |-- clients
|       |-- mem
|       |-- name
|       |-- queues
|       |-- vm
|       `-- vma
|-- driver
|-- execdomains
|-- filesystems
|-- fs
|-- ide
|   |-- drivers
|   |-- hda -&gt; ide0/hda
|   |-- hdc -&gt; ide1/hdc
|   |-- ide0
|   |   |-- channel
|   |   |-- config
|   |   |-- hda
|   |   |   |-- cache
|   |   |   |-- capacity
|   |   |   |-- driver
|   |   |   |-- geometry
|   |   |   |-- identify
|   |   |   |-- media
|   |   |   |-- model
|   |   |   |-- settings
|   |   |   |-- smart_thresholds
|   |   |   `-- smart_values
|   |   |-- mate
|   |   `-- model
|   |-- ide1
|   |   |-- channel
|   |   |-- config
|   |   |-- hdc
|   |   |   |-- capacity
|   |   |   |-- driver
|   |   |   |-- identify
|   |   |   |-- media
|   |   |   |-- model
|   |   |   `-- settings
|   |   |-- mate
|   |   `-- model
|   `-- via
|-- interrupts
|-- iomem
|-- ioports
|-- irq
|   |-- 0
|   |-- 1
|   |-- 10
|   |-- 11
|   |-- 12
|   |-- 13
|   |-- 14
|   |-- 15
|   |-- 2
|   |-- 3
|   |-- 4
|   |-- 5
|   |-- 6
|   |-- 7
|   |-- 8
|   |-- 9
|   `-- prof_cpu_mask
|-- kcore
|-- kmsg
|-- ksyms
|-- loadavg
|-- locks
|-- meminfo
|-- misc
|-- modules
|-- mounts
|-- mtrr
|-- net
|   |-- arp
|   |-- dev
|   |-- dev_mcast
|   |-- ip_fwchains
|   |-- ip_fwnames
|   |-- ip_masquerade
|   |-- netlink
|   |-- netstat
|   |-- packet
|   |-- psched
|   |-- raw
|   |-- route
|   |-- rt_acct
|   |-- rt_cache
|   |-- rt_cache_stat
|   |-- snmp
|   |-- sockstat
|   |-- softnet_stat
|   |-- tcp
|   |-- udp
|   |-- unix
|   `-- wireless
|-- partitions
|-- pci
|-- scsi
|   |-- ide-scsi
|   |   `-- 0
|   `-- scsi
|-- self -&gt; 2069
|-- slabinfo
|-- stat
|-- swaps
|-- sys
|   |-- abi
|   |   |-- defhandler_coff
|   |   |-- defhandler_elf
|   |   |-- defhandler_lcall7
|   |   |-- defhandler_libcso
|   |   |-- fake_utsname
|   |   `-- trace
|   |-- debug
|   |-- dev
|   |   |-- cdrom
|   |   |   |-- autoclose
|   |   |   |-- autoeject
|   |   |   |-- check_media
|   |   |   |-- debug
|   |   |   |-- info
|   |   |   `-- lock
|   |   `-- parport
|   |       |-- default
|   |       |   |-- spintime
|   |       |   `-- timeslice
|   |       `-- parport0
|   |           |-- autoprobe
|   |           |-- autoprobe0
|   |           |-- autoprobe1
|   |           |-- autoprobe2
|   |           |-- autoprobe3
|   |           |-- base-addr
|   |           |-- devices
|   |           |   |-- active
|   |           |   `-- lp
|   |           |       `-- timeslice
|   |           |-- dma
|   |           |-- irq
|   |           |-- modes
|   |           `-- spintime
|   |-- fs
|   |   |-- binfmt_misc
|   |   |-- dentry-state
|   |   |-- dir-notify-enable
|   |   |-- dquot-nr
|   |   |-- file-max
|   |   |-- file-nr
|   |   |-- inode-nr
|   |   |-- inode-state
|   |   |-- jbd-debug
|   |   |-- lease-break-time
|   |   |-- leases-enable
|   |   |-- overflowgid
|   |   `-- overflowuid
|   |-- kernel
|   |   |-- acct
|   |   |-- cad_pid
|   |   |-- cap-bound
|   |   |-- core_uses_pid
|   |   |-- ctrl-alt-del
|   |   |-- domainname
|   |   |-- hostname
|   |   |-- modprobe
|   |   |-- msgmax
|   |   |-- msgmnb
|   |   |-- msgmni
|   |   |-- osrelease
|   |   |-- ostype
|   |   |-- overflowgid
|   |   |-- overflowuid
|   |   |-- panic
|   |   |-- printk
|   |   |-- random
|   |   |   |-- boot_id
|   |   |   |-- entropy_avail
|   |   |   |-- poolsize
|   |   |   |-- read_wakeup_threshold
|   |   |   |-- uuid
|   |   |   `-- write_wakeup_threshold
|   |   |-- rtsig-max
|   |   |-- rtsig-nr
|   |   |-- sem
|   |   |-- shmall
|   |   |-- shmmax
|   |   |-- shmmni
|   |   |-- sysrq
|   |   |-- tainted
|   |   |-- threads-max
|   |   `-- version
|   |-- net
|   |   |-- 802
|   |   |-- core
|   |   |   |-- hot_list_length
|   |   |   |-- lo_cong
|   |   |   |-- message_burst
|   |   |   |-- message_cost
|   |   |   |-- mod_cong
|   |   |   |-- netdev_max_backlog
|   |   |   |-- no_cong
|   |   |   |-- no_cong_thresh
|   |   |   |-- optmem_max
|   |   |   |-- rmem_default
|   |   |   |-- rmem_max
|   |   |   |-- wmem_default
|   |   |   `-- wmem_max
|   |   |-- ethernet
|   |   |-- ipv4
|   |   |   |-- conf
|   |   |   |   |-- all
|   |   |   |   |   |-- accept_redirects
|   |   |   |   |   |-- accept_source_route
|   |   |   |   |   |-- arp_filter
|   |   |   |   |   |-- bootp_relay
|   |   |   |   |   |-- forwarding
|   |   |   |   |   |-- log_martians
|   |   |   |   |   |-- mc_forwarding
|   |   |   |   |   |-- proxy_arp
|   |   |   |   |   |-- rp_filter
|   |   |   |   |   |-- secure_redirects
|   |   |   |   |   |-- send_redirects
|   |   |   |   |   |-- shared_media
|   |   |   |   |   `-- tag
|   |   |   |   |-- default
|   |   |   |   |   |-- accept_redirects
|   |   |   |   |   |-- accept_source_route
|   |   |   |   |   |-- arp_filter
|   |   |   |   |   |-- bootp_relay
|   |   |   |   |   |-- forwarding
|   |   |   |   |   |-- log_martians
|   |   |   |   |   |-- mc_forwarding
|   |   |   |   |   |-- proxy_arp
|   |   |   |   |   |-- rp_filter
|   |   |   |   |   |-- secure_redirects
|   |   |   |   |   |-- send_redirects
|   |   |   |   |   |-- shared_media
|   |   |   |   |   `-- tag
|   |   |   |   |-- eth0
|   |   |   |   |   |-- accept_redirects
|   |   |   |   |   |-- accept_source_route
|   |   |   |   |   |-- arp_filter
|   |   |   |   |   |-- bootp_relay
|   |   |   |   |   |-- forwarding
|   |   |   |   |   |-- log_martians
|   |   |   |   |   |-- mc_forwarding
|   |   |   |   |   |-- proxy_arp
|   |   |   |   |   |-- rp_filter
|   |   |   |   |   |-- secure_redirects
|   |   |   |   |   |-- send_redirects
|   |   |   |   |   |-- shared_media
|   |   |   |   |   `-- tag
|   |   |   |   |-- eth1
|   |   |   |   |   |-- accept_redirects
|   |   |   |   |   |-- accept_source_route
|   |   |   |   |   |-- arp_filter
|   |   |   |   |   |-- bootp_relay
|   |   |   |   |   |-- forwarding
|   |   |   |   |   |-- log_martians
|   |   |   |   |   |-- mc_forwarding
|   |   |   |   |   |-- proxy_arp
|   |   |   |   |   |-- rp_filter
|   |   |   |   |   |-- secure_redirects
|   |   |   |   |   |-- send_redirects
|   |   |   |   |   |-- shared_media
|   |   |   |   |   `-- tag
|   |   |   |   `-- lo
|   |   |   |       |-- accept_redirects
|   |   |   |       |-- accept_source_route
|   |   |   |       |-- arp_filter
|   |   |   |       |-- bootp_relay
|   |   |   |       |-- forwarding
|   |   |   |       |-- log_martians
|   |   |   |       |-- mc_forwarding
|   |   |   |       |-- proxy_arp
|   |   |   |       |-- rp_filter
|   |   |   |       |-- secure_redirects
|   |   |   |       |-- send_redirects
|   |   |   |       |-- shared_media
|   |   |   |       `-- tag
|   |   |   |-- icmp_echo_ignore_all
|   |   |   |-- icmp_echo_ignore_broadcasts
|   |   |   |-- icmp_ignore_bogus_error_responses
|   |   |   |-- icmp_ratelimit
|   |   |   |-- icmp_ratemask
|   |   |   |-- inet_peer_gc_maxtime
|   |   |   |-- inet_peer_gc_mintime
|   |   |   |-- inet_peer_maxttl
|   |   |   |-- inet_peer_minttl
|   |   |   |-- inet_peer_threshold
|   |   |   |-- ip_autoconfig
|   |   |   |-- ip_conntrack_max
|   |   |   |-- ip_default_ttl
|   |   |   |-- ip_dynaddr
|   |   |   |-- ip_forward
|   |   |   |-- ip_local_port_range
|   |   |   |-- ip_no_pmtu_disc
|   |   |   |-- ip_nonlocal_bind
|   |   |   |-- ipfrag_high_thresh
|   |   |   |-- ipfrag_low_thresh
|   |   |   |-- ipfrag_time
|   |   |   |-- neigh
|   |   |   |   |-- default
|   |   |   |   |   |-- anycast_delay
|   |   |   |   |   |-- app_solicit
|   |   |   |   |   |-- base_reachable_time
|   |   |   |   |   |-- delay_first_probe_time
|   |   |   |   |   |-- gc_interval
|   |   |   |   |   |-- gc_stale_time
|   |   |   |   |   |-- gc_thresh1
|   |   |   |   |   |-- gc_thresh2
|   |   |   |   |   |-- gc_thresh3
|   |   |   |   |   |-- locktime
|   |   |   |   |   |-- mcast_solicit
|   |   |   |   |   |-- proxy_delay
|   |   |   |   |   |-- proxy_qlen
|   |   |   |   |   |-- retrans_time
|   |   |   |   |   |-- ucast_solicit
|   |   |   |   |   `-- unres_qlen
|   |   |   |   |-- eth0
|   |   |   |   |   |-- anycast_delay
|   |   |   |   |   |-- app_solicit
|   |   |   |   |   |-- base_reachable_time
|   |   |   |   |   |-- delay_first_probe_time
|   |   |   |   |   |-- gc_stale_time
|   |   |   |   |   |-- locktime
|   |   |   |   |   |-- mcast_solicit
|   |   |   |   |   |-- proxy_delay
|   |   |   |   |   |-- proxy_qlen
|   |   |   |   |   |-- retrans_time
|   |   |   |   |   |-- ucast_solicit
|   |   |   |   |   `-- unres_qlen
|   |   |   |   |-- eth1
|   |   |   |   |   |-- anycast_delay
|   |   |   |   |   |-- app_solicit
|   |   |   |   |   |-- base_reachable_time
|   |   |   |   |   |-- delay_first_probe_time
|   |   |   |   |   |-- gc_stale_time
|   |   |   |   |   |-- locktime
|   |   |   |   |   |-- mcast_solicit
|   |   |   |   |   |-- proxy_delay
|   |   |   |   |   |-- proxy_qlen
|   |   |   |   |   |-- retrans_time
|   |   |   |   |   |-- ucast_solicit
|   |   |   |   |   `-- unres_qlen
|   |   |   |   `-- lo
|   |   |   |       |-- anycast_delay
|   |   |   |       |-- app_solicit
|   |   |   |       |-- base_reachable_time
|   |   |   |       |-- delay_first_probe_time
|   |   |   |       |-- gc_stale_time
|   |   |   |       |-- locktime
|   |   |   |       |-- mcast_solicit
|   |   |   |       |-- proxy_delay
|   |   |   |       |-- proxy_qlen
|   |   |   |       |-- retrans_time
|   |   |   |       |-- ucast_solicit
|   |   |   |       `-- unres_qlen
|   |   |   |-- route
|   |   |   |   |-- error_burst
|   |   |   |   |-- error_cost
|   |   |   |   |-- flush
|   |   |   |   |-- gc_elasticity
|   |   |   |   |-- gc_interval
|   |   |   |   |-- gc_min_interval
|   |   |   |   |-- gc_thresh
|   |   |   |   |-- gc_timeout
|   |   |   |   |-- max_delay
|   |   |   |   |-- max_size
|   |   |   |   |-- min_adv_mss
|   |   |   |   |-- min_delay
|   |   |   |   |-- min_pmtu
|   |   |   |   |-- mtu_expires
|   |   |   |   |-- redirect_load
|   |   |   |   |-- redirect_number
|   |   |   |   `-- redirect_silence
|   |   |   |-- tcp_abort_on_overflow
|   |   |   |-- tcp_adv_win_scale
|   |   |   |-- tcp_app_win
|   |   |   |-- tcp_dsack
|   |   |   |-- tcp_ecn
|   |   |   |-- tcp_fack
|   |   |   |-- tcp_fin_timeout
|   |   |   |-- tcp_keepalive_intvl
|   |   |   |-- tcp_keepalive_probes
|   |   |   |-- tcp_keepalive_time
|   |   |   |-- tcp_max_orphans
|   |   |   |-- tcp_max_syn_backlog
|   |   |   |-- tcp_max_tw_buckets
|   |   |   |-- tcp_mem
|   |   |   |-- tcp_orphan_retries
|   |   |   |-- tcp_reordering
|   |   |   |-- tcp_retrans_collapse
|   |   |   |-- tcp_retries1
|   |   |   |-- tcp_retries2
|   |   |   |-- tcp_rfc1337
|   |   |   |-- tcp_rmem
|   |   |   |-- tcp_sack
|   |   |   |-- tcp_stdurg
|   |   |   |-- tcp_syn_retries
|   |   |   |-- tcp_synack_retries
|   |   |   |-- tcp_syncookies
|   |   |   |-- tcp_timestamps
|   |   |   |-- tcp_tw_recycle
|   |   |   |-- tcp_window_scaling
|   |   |   `-- tcp_wmem
|   |   `-- unix
|   |       `-- max_dgram_qlen
|   |-- proc
|   `-- vm
|       |-- bdflush
|       |-- kswapd
|       |-- max-readahead
|       |-- min-readahead
|       |-- overcommit_memory
|       |-- page-cluster
|       `-- pagetable_cache
|-- sysvipc
|   |-- msg
|   |-- sem
|   `-- shm
|-- tty
|   |-- driver
|   |   `-- serial
|   |-- drivers
|   |-- ldisc
|   `-- ldiscs
|-- uptime
`-- version

</pre>
<p>Dans ce dossier il y a aussi les T&acirc;ches qui utilisent le
PID comme nom de fichier (vous avez acc&egrave;s &agrave; toutes
les informations sur les T&acirc;ches, comme le chemin du fichier
binaire, la m&eacute;moire utilis&eacute;e, etc...).</p>
<p>Ce qui est int&eacute;ressant c'est que non seulement vous
pouvez voir les valeurs du noyau (par exemple, voir l'information
sur toute T&acirc;che ou sur les options actives du r&eacute;seau
de votre pile TCP/IP) mais vous pouvez aussi en modifier certaines,
typiquement ceux qui sont dans le dossier /proc/sys:</p>
<pre>
/proc/sys/ 
          acpi
          dev
          debug
          fs
          proc
          net
          vm
          kernel
</pre>
<h3>/proc/sys/kernel</h3>
<p>Suivent des valeurs du noyau tr&egrave;s importantes et bien
connues, pr&ecirc;tes &agrave; &ecirc;tre modifi&eacute;es:</p>
<pre>
overflowgid
overflowuid
random
threads-max // Nombre maximum de fils, typiquement 16384
sysrq // hachage noyau: vous pouvez voir les valeurs du registre istant (istant) et plus
sem
msgmnb
msgmni
msgmax
shmmni
shmall
shmmax
rtsig-max
rtsig-nr
modprobe // emplacement fichier modprobe
printk
ctrl-alt-del
cap-bound
panic
domainname // nom de domaine de votre poste Linux
hostname // nom d'h&ocirc;te de votre poste Linux
version // informations sur la date de compilation de votre noyau
osrelease // version du noyau (i.e. 2.4.5)
ostype // Linux!
</pre>
<h3>/proc/sys/net</h3>
<p>Il peut &ecirc;tre consid&eacute;r&eacute; comme le sous-dossier
le plus utile de proc. Il vous parmet de changer des
param&egrave;tres tr&egrave;s importants de la configuration
r&eacute;seau de votre noyau.</p>
<pre>
core
ipv4
ipv6
unix
ethernet
802
</pre>
<h3>/proc/sys/net/core</h3>
<p>La liste suivante est la configuration g&eacute;n&eacute;rale du
r&eacute;seau, comme netdev_max_backlog" (typiquement 300), la
longueur de tous les paquets r&eacute;seau. Cette valeur peut
limiter la bande passante du r&eacute;seau quand il re&ccedil;oit
des paquets. Linux doit attendre pour programmer le temps de vider
les tampons (du aux m&eacute;canismes de la moiti&eacute; d'en
bas), envirn 1000/HZ ms (Listed below are general net settings,
like "netdev_max_backlog" (typically 300), the length of all your
network packets. This value can limit your network bandwidth when
receiving packets, Linux has to wait up to scheduling time to flush
buffers (due to bottom half mechanism), about 1000/HZ ms)</p>
<pre>
  300    *        100             =     30 000
packets     HZ(Timeslice freq)         packets/s
 
30 000   *       1000             =      30 M
packets     average (Bytes/packet)   throughput Bytes/s
</pre>
<p>Si vous voulez un plus gros d&eacute;bit, vous pouvez augmenter
netdev_max_backlog,en tapant:</p>
<pre>
echo 4000 &gt; /proc/sys/net/core/netdev_max_backlog
</pre>
<p>Note: Attention &agrave; certaines valeurs HZ: sous certaines
architectures (comme alpha ou arm-tbox) c'est 1000, aussi vous
pouvez avoir un d&eacute;bit moyen de 300 Mo/s.</p>
<h3>/proc/sys/net/ipv4</h3>
<p>"ip_forward", active ou d&eacute;sactive la
r&eacute;exp&eacute;dition ou transmission ip (ip forwarding) dans
votre poste Linux. C'est une configuration g&eacute;n&eacute;rique
pour tous les p&eacute;riph&eacute;riques, que vous pouvez
sp&eacute;cifier pour chaque p&eacute;riph&eacute;rique que vous
choisissez.</p>
<h3>/proc/sys/net/ipv4/conf/interface</h3>
<p>Je pense que c'est l'entr&eacute;e de /proc la plus utile, parce
qu'elle permet de modifier la configuration r&eacute;seau pour
supporter les r&eacute;seaux sans fils (voir <a href=
"http://www.bertolinux.com">Wireless-HOWTO</a> pour plus
d'informations, ou le guide pratique officiel Wireless-HOWTO).</p>
<p>Quelques exemples o&ugrave; vous pouvez utiliser ces
r&eacute;glages:</p>
<ul>
<li>"forwarding", pour activer la r&eacute;exp&eacute;dition ip
pour votre interface</li>
<li>"proxy_arp", pour activer les &eacute;l&eacute;ments arp
interpos&eacute;s (proxy arp feature). Pour en savoir plus voir
Proxy arp HOWTO sur <a href="http://www.tldp.org">Linux
Documentation Project</a> et <a href=
"http://www.bertolinux.com">Wireless-HOWTO</a> ou le guide pratique
officiel, pour les Proxy arp qui utilisent les r&eacute;seaux sans
fils.</li>
<li>"send_redirects" pour &eacute;viter que l'interface envoie
ICMP_REDIRECT (voir comme avant <a href=
"http://www.bertolinux.com">Wireless-HOWTO</a> ou le guide pratique
officiel pour en savoir plus).</li>
</ul>
<h2><a name="s6">6. Traitement MultiT&acirc;che Linux</a></h2>
<h2><a name="ss6.1">6.1 Vue d'ensemble</a></h2>
<p>Cette section va analyser les structures de donn&eacute;es -- le
m&eacute;canisme utilis&eacute; pour contr&ocirc;ler
l'environnement de traitement multit&acirc;che sous Linux.</p>
<h3>&Eacute;tats de T&acirc;che</h3>
<p>Une T&acirc;che Linux peut avoir (can be) un des &eacute;tats
suivants (selon [ include/linux.h ]):</p>
<ol>
<li>TASK_RUNNING, signifie qu'elle est dans "la liste pr&ecirc;te"
("Ready List")</li>
<li>TASK_INTERRUPTIBLE, T&acirc;che attendant un signal ou une
ressource (sommeil)</li>
<li>TASK_UNINTERRUPTIBLE, T&acirc;che attendant une ressource
(sommeil), elle est dans la m&ecirc;me "file d'attente
d'attente"</li>
<li>TASK_ZOMBIE, enfant de T&acirc;che sans p&egrave;re</li>
<li>TASK_STOPPED, T&acirc;che &agrave; corriger (task being
debugged)</li>
</ol>
<h3>Interaction Graphique</h3>
<pre>
       ______________     CPU Disponible    ______________
      |              |  ----------------&gt;  |              |
      | TASK_RUNNING |                     | Real Running |  
      |______________|  &lt;----------------  |______________|
                           CPU Occup&eacute;e
            |   /|\       
  Attend     |    | Ressource  
 Ressource   |    | Disponible            
           \|/   |      
    ______________________                     
   |                      |
   | TASK_INTERRUPTIBLE / |
   | TASK-UNINTERRUPTIBLE |
   |______________________|
 
                     Flot Multit&acirc;che Principal
</pre>
<h2><a name="ss6.2">6.2 Timeslice (glissement de temps)</a></h2>
<h3>Programmation PIT 8253</h3>
<p>Toutes les 10ms (selon la valeur de HZ) un IRQ0 se produit, qui
nous aide en environnement multit&acirc;che. Ce signal vient de PIC
8259 (en arch 386+) qui est reli&eacute; &agrave; PIT 8253 avec une
horloge de 1,19318 m&eacute;gahertz.</p>
<pre>
    _____         ______        ______        
   | CPU |&lt;------| 8259 |------| 8253 |
   |_____| IRQ0  |______|      |___/|\|
                                    |_____ CLK 1.193.180 MHz
          
// From include/asm/param.h
#ifndef HZ 
#define HZ 100 
#endif
 
// From include/asm/timex.h
#define CLOCK_TICK_RATE 1193180 /* Underlying HZ */
 
// From include/linux/timex.h
#define LATCH ((CLOCK_TICK_RATE + HZ/2) / HZ) /* For divider */
 
// From arch/i386/kernel/i8259.c
outb_p(0x34,0x43); /* binary, mode 2, LSB/MSB, ch 0 */ 
outb_p(LATCH &amp; 0xff , 0x40); /* LSB */
outb(LATCH &gt;&gt; 8 , 0x40); /* MSB */
 
</pre>
<p>Ainsi nous programmons 8253 (PIT, Programmable Interval Timer ou
Compteur &agrave; intervalle programmable) avec LATCH (VERROU) =
(1193180/hz) = 11931,8 quand HZ=100 (d&eacute;faut). LATCH indique
le facteur divisant la fr&eacute;quence.</p>
<p>LATCH = 11931,8 donne &agrave; 8253 (en sortie) une
fr&eacute;quence de 1193180/11931,8 = 100 Hz, ainsi la
p&eacute;riode = 10ms</p>
<p>Ainsi Timeslice = 1/hz.</p>
<p>Avec chaque Timeslice nous interrompons temporairement
l'ex&eacute;cution du processus courant (sans commutation de
T&acirc;che), et nous faisons du m&eacute;nage, apr&egrave;s quoi
nous retournerons de nouveau &agrave; notre processus
pr&eacute;c&eacute;dent.</p>
<h3>Linux Timer (Compteur) IRQ ICA</h3>
<pre>
Linux Timer IRQ
IRQ 0 [Timer]
 |  
\|/
|IRQ0x00_interrupt        //   wrapper IRQ handler
   |SAVE_ALL              ---   
      |do_IRQ                |   wrapper routines
         |handle_IRQ_event  ---
            |handler() -&gt; timer_interrupt  // registered IRQ 0 handler
               |do_timer_interrupt
                  |do_timer  
                     |jiffies++;
                     |update_process_times  
                     |if (--counter &lt;= 0) { // if time slice ended then
                        |counter = 0;        //   reset counter           
                        |need_resched = 1;   //   prepare to reschedule
                     |}
         |do_softirq
         |while (need_resched) { // if necessary
            |schedule             //   reschedule
            |handle_softirq
         |}
   |RESTORE_ALL
 
</pre>
<p>Des fonctions peuvent &ecirc;tre trouv&eacute;es sous:</p>
<ul>
<li>IRQ0x00_interrupt, SAVE_ALL [include/asm/hw_irq.h]</li>
<li>do_IRQ, handle_IRQ_event [arch/i386/kernel/irq.c]</li>
<li>timer_interrupt, do_timer_interrupt
[arch/i386/kernel/time.c]</li>
<li>do_timer, update_process_times [kernel/timer.c]</li>
<li>do_softirq [kernel/soft_irq.c]</li>
<li>RESTORE_ALL, while loop [arch/i386/kernel/entry.S]</li>
</ul>
<p>Notes:</p>
<ol>
<li>La fonction "IRQ0x00_interrupt" (comme d'autres
IRQ0xXY_interrupt) est directement dirig&eacute;e par IDT
(Interrupt Descriptor Table ou Tableau de descripteur
d'interruption, semblable au Real Mode Interrupt Vector Table, voir
chap 11), ainsi CHAQUE interruption arrivant au processeur est
contr&ocirc;l&eacute;e par la routine "IRQ0x#NR_interrupt",
o&ugrave; #NR est le num&eacute;ro d'interruption. Nous nous
r&eacute;f&eacute;rons &agrave; elle en tant que "gestionnaire
d'irq d'emballage" ("wrapper irq handler").</li>
<li>des routines d'emballage sont ex&eacute;cut&eacute;es, comme
"do_IRQ","handle_IRQ_event" [arch/i386/kernel/irq.c].</li>
<li>Apr&egrave;s ceci, la main est pass&eacute;e &agrave; la
routine IRQ officielle (point&eacute;e par "handler()"),
pr&eacute;c&eacute;demment enregistr&eacute; avec "request_irq"
[arch/i386/kernel/irq.c], dans ce cas "timer_interrupt"
[arch/i386/kernel/time.c].</li>
<li>la routine "timer_interrupt" [arch/i386/kernel/time.c] est
ex&eacute;cut&eacute;e, et quand elle se termine,</li>
<li>le contr&ocirc;le revient &agrave; des routines assembleur
[arch/i386/kernel/entry.S].</li>
</ol>
<p>Description:</p>
<p>Pour g&eacute;rer le Multit&acirc;che, Linux (comme chaque autre
Unix) utilise un ''compteur'' variable pour suivre combien de CPU
(processeur) a &eacute;t&eacute; utilis&eacute;e par la
T&acirc;che. Ainsi, &agrave; chaque IRQ 0, le compteur est
d&eacute;cr&eacute;ment&eacute; (point 4) et, quand il atteint 0,
nous devons commuter la T&acirc;che de g&eacute;rer le temps
partag&eacute; (point 4 la variable "need_resched" est mise
&agrave; 1, puis, au point 5 les routines assembleur
contr&ocirc;lent "need_resched" et appellent, si besoin, "le
programme" [kernel/sched.c]).</p>
<h2><a name="ss6.3">6.3 Programmateur</a></h2>
<p>Le programmateur est le bout de code qui choisit quelle
T&acirc;che doit &ecirc;tre ex&eacute;cut&eacute;e &agrave; un
moment donn&eacute; (chooses what Task has to be executed at a
given time).</p>
<p>A chaque fois que vous devez changer la T&acirc;che courante,
choisissez un candidat. Ci-dessous il y a la fonction ''programme
[kernel/sched.c]''.</p>
<pre>
|schedule
   |do_softirq // manages post-IRQ work
   |for each task
      |calculate counter
   |prepare_to__switch // does anything
   |switch_mm // change Memory context (change CR3 value)
   |switch_to (assembler)
      |SAVE ESP
      |RESTORE future_ESP
      |SAVE EIP
      |push future_EIP *** push parameter as we did a call 
         |jmp __switch_to (it does some TSS work) 
         |__switch_to()
          ..
         |ret *** ret from call using future_EIP in place of call address
      new_task

</pre>
<h2><a name="ss6.4">6.4 Moiti&eacute; inf&eacute;rieure, files
d'attente de T&acirc;che et Tasklets</a></h2>
<h3>Vue d'ensemble</h3>
<p>En Unix classique, quand un IRQ se produit (par un
p&eacute;riph&eacute;rique), Unix fait la "commutation de
T&acirc;che" pour interroger la T&acirc;che qui a demand&eacute; le
p&eacute;riph&eacute;rique.</p>
<p>Pour am&eacute;liorer les performances, Linux peut remettre le
travail non urgent &agrave; plus tard, pour mieux g&eacute;rer la
grande vitesse des &eacute;v&egrave;nements.</p>
<p>Ce dispositif est g&eacute;r&eacute; depuis le noyau 1.x par "la
moiti&eacute; inf&eacute;rieure" (BH pour Bottom Half). Le
gestionnaire d'irq "marque" une moiti&eacute; inf&eacute;rieure,
pour &ecirc;tre ex&eacute;cut&eacute; plus tard, le temps de
programm&eacute; (scheduling time).</p>
<p>Dans les derniers noyaus il y a une "queue de t&acirc;che" qui
est plus dynamique que BH et il y a aussi une petite t&acirc;che
("tasklet") pour g&eacute;rer les environnements
multiprocesseur.</p>
<p>Le sch&eacute;ma BH est:</p>
<ol>
<li>D&eacute;claration</li>
<li>Marque</li>
<li>Ex&eacute;cution</li>
</ol>
<h3>D&eacute;claration</h3>
<pre>
#define DECLARE_TASK_QUEUE(q) LIST_HEAD(q)
#define LIST_HEAD(name) \
   struct list_head name = LIST_HEAD_INIT(name) 
struct list_head { 
   struct list_head *next, *prev; 
};
#define LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) } 
 
      ''DECLARE_TASK_QUEUE'' [include/linux/tqueue.h, include/linux/list.h] 
</pre>
<p>La macro "DECLARE_TASK_QUEUE(q)" est utilis&eacute;e pour
d&eacute;clarer une structure appel&eacute;e file d'attente de
t&acirc;che qui g&egrave;re "q" (managing task queue).</p>
<h3>Marque</h3>
<p>Voici le sch&eacute;ma Ica pour la fonction "mark_bh"
[include/linux/interrupt.h]:</p>
<pre>
|mark_bh(NUMBER)
   |tasklet_hi_schedule(bh_task_vec + NUMBER)
      |insert into tasklet_hi_vec
         |__cpu_raise_softirq(HI_SOFTIRQ) 
            |soft_active |= (1 &lt;&lt; HI_SOFTIRQ)
 
                   ''mark_bh''[include/linux/interrupt.h]
</pre>
<p>Par exemple, quand un gestionnaire d'IRQ veut "remettre" du
travail, il ferait "mark_bh(NOMBRE)", o&ugrave; NOMBRE est un BH
d&eacute;clar&eacute; (voir la section
pr&eacute;c&eacute;dente).</p>
<h3>Ex&eacute;cution</h3>
<p>Nous pouvons voir ceci appel&eacute; par la fonction "do_IRQ"
[arch/i386/kernel/irq.c]:</p>
<pre>
|do_softirq
   |h-&gt;action(h)-&gt; softirq_vec[TASKLET_SOFTIRQ]-&gt;action -&gt; tasklet_action
      |tasklet_vec[0].list-&gt;func
         

</pre>
<p>"h-&gt;action(h);" est la fonction qui a &eacute;t&eacute;
pr&eacute;c&eacute;demment align&eacute;e.</p>
<h2><a name="ss6.5">6.5 Routines de tr&egrave;s bas niveau</a></h2>
<p>set_intr_gate</p>
<p>set_trap_gate</p>
<p>set_task_gate (non utilis&eacute;).</p>
<p>(*interrupt)[NR_IRQS](void) = { IRQ0x00_interrupt,
IRQ0x01_interrupt, ..}</p>
<p>NR_IRQS = 224 [kernel 2.4.2]</p>
<h2><a name="ss6.6">6.6 Commutation de T&acirc;che</a></h2>
<h3>Quand la commutation de T&acirc;che se passe-t-elle?</h3>
<p>Maintenant nous allons voir comment le noyau de Linux permute
d'une T&acirc;che &agrave; l'autre.</p>
<p>La permutation de T&acirc;che est n&eacute;cessaire dans
beaucoup de cas, comme le suivant:</p>
<ul>
<li>quand TimeSlice finit, nous devons donner acc&egrave;s &agrave;
d'autres T&acirc;ches</li>
<li>quand une T&acirc;che d&eacute;cide d'acc&eacute;der &agrave;
une ressource, elle dort en l'attendant, ainsi nous devons choisir
une autre t&acirc;che</li>
<li>quand une T&acirc;che attend une tube, nous devons donner
acc&egrave;s &agrave; une autre T&acirc;che, qui &eacute;crirait
dans la tube</li>
</ul>
<h3>Commutation de T&acirc;che</h3>
<pre>
                           TASK SWITCHING TRICK
#define switch_to(prev,next,last) do {                                  \
        asm volatile("pushl %%esi\n\t"                                  \
                     "pushl %%edi\n\t"                                  \
                     "pushl %%ebp\n\t"                                  \
                     "movl %%esp,%0\n\t"        /* save ESP */          \
                     "movl %3,%%esp\n\t"        /* restore ESP */       \
                     "movl $1f,%1\n\t"          /* save EIP */          \
                     "pushl %4\n\t"             /* restore EIP */       \
                     "jmp __switch_to\n"                                \
                     "1:\t"                                             \
                     "popl %%ebp\n\t"                                   \
                     "popl %%edi\n\t"                                   \
                     "popl %%esi\n\t"                                   \
                     :"=m" (prev-&gt;thread.esp),"=m" (prev-&gt;thread.eip),  \
                      "=b" (last)                                       \
                     :"m" (next-&gt;thread.esp),"m" (next-&gt;thread.eip),    \
                      "a" (prev), "d" (next),                           \
                      "b" (prev));                                      \
} while (0)
</pre>
<p>L'astuce c'est:</p>
<ol>
<li>''pushl %4'' qui met future_EIP dans la pile</li>
<li>''jmp __switch_to'' qui ex&eacute;cute la
fonction''__switch_to'', mais au contraire de ''call'' nous
reviendrons &agrave; la valeur suivante (to valued pushed in point
1) du poiint 1 (donc une nouvelle t&acirc;che!)</li>
</ol>
<pre>
      U S E R   M O D E                 K E R N E L     M O D E

 |          |     |          |       |          |     |          |
 |          |     |          | Timer |          |     |          |
 |          |     |  Normal  |  IRQ  |          |     |          |
 |          |     |   Exec   |------&gt;|Timer_Int.|     |          |
 |          |     |     |    |       | ..       |     |          |
 |          |     |    \|/   |       |schedule()|     | Task1 Ret|
 |          |     |          |       |_switch_to|&lt;--  |  Address |
 |__________|     |__________|       |          |  |  |          |
                                     |          |  |S |          | 
Task1 Data/Stack   Task1 Code        |          |  |w |          |
                                     |          | T|i |          |
                                     |          | a|t |          |
 |          |     |          |       |          | s|c |          |
 |          |     |          | Timer |          | k|h |          |
 |          |     |  Normal  |  IRQ  |          |  |i |          | 
 |          |     |   Exec   |------&gt;|Timer_Int.|  |n |          |
 |          |     |     |    |       | ..       |  |g |          |
 |          |     |    \|/   |       |schedule()|  |  | Task2 Ret|
 |          |     |          |       |_switch_to|&lt;--  |  Address |
 |__________|     |__________|       |__________|     |__________|
 
Task2 Data/Stack   Task2 Code        Kernel Code  Kernel Data/Stack
</pre>
<h2><a name="ss6.7">6.7 Fourche</a></h2>
<h3>Vue d'ensemble</h3>
<p>La fourche est utilis&eacute;e pour cr&eacute;er une autre
T&acirc;che. Nous commen&ccedil;ons par une T&acirc;che Parent, et
nous copions plusieurs structures de donn&eacute;es vers l'Enfant
de la T&acirc;che.</p>
<pre>
 
                               |         |
                               | ..      |
         Task Parent           |         |
         |         |           |         |
         |  fork   |----------&gt;|  CREATE |   
         |         |          /|   NEW   |
         |_________|         / |   TASK  |
                            /  |         |
             ---           /   |         |
             ---          /    | ..      |
                         /     |         |
         Task Child     / 
         |         |   /
         |  fork   |&lt;-/
         |         |
         |_________|
              
                       Fork SysCall
</pre>
<h3>Ce qui n'est pas copi&eacute;</h3>
<p>La nouvelle T&acirc;che juste cr&eacute;&eacute;e (''Enfant de
T&acirc;che '') est presque &eacute;gale au parent (''Parent de
T&acirc;che''), il y a seulement quelques diff&eacute;rences:</p>
<ol>
<li>&eacute;videmment le PID</li>
<li>l'enfant ''fork()'' renverra 0, alors que le parent ''fork()
''renverra le PID de la T&acirc;che Enfant, pour les distinguer en
Mode Utilisateur</li>
<li>Toutes les pages de donn&eacute;es de l'enfant sont
marqu&eacute;es ''LECTURE + EX&Eacute;CUTION'', aucune
"&Eacute;CRITURE'' (tandis que le parent a droit d'&Eacute;CRITURE
sur ses propres pages) ainsi, quand une demande d'&eacute;criture
se produit, une exception de ''Faute de page'' est
g&eacute;n&eacute;r&eacute;e qui cr&eacute;era une nouvelle page
ind&eacute;pendante: ce m&eacute;canisme s'appelle ''Copy on
Write'' (copie sur &eacute;criture) (voir Chap.10).</li>
</ol>
<h3>Fourche ICA</h3>
<pre>
|sys_fork 
   |do_fork
      |alloc_task_struct 
         |__get_free_pages
       |p-&gt;state = TASK_UNINTERRUPTIBLE
       |copy_flags
       |p-&gt;pid = get_pid    
       |copy_files
       |copy_fs
       |copy_sighand
       |copy_mm // should manage CopyOnWrite (I part)
          |allocate_mm
          |mm_init
             |pgd_alloc -&gt; get_pgd_fast
                |get_pgd_slow
          |dup_mmap
             |copy_page_range
                |ptep_set_wrprotect
                   |clear_bit // set page to read-only              
          |copy_segments // For LDT
       |copy_thread
          |childregs-&gt;eax = 0  
          |p-&gt;thread.esp = childregs // child fork returns 0
          |p-&gt;thread.eip = ret_from_fork // child starts from fork exit
       |retval = p-&gt;pid // parent fork returns child pid
       |SET_LINKS // insertion of task into the list pointers
       |nr_threads++ // Global variable
       |wake_up_process(p) // Now we can wake up just created child
       |return retval
              
               fork ICA
 
</pre>
<ul>
<li>sys_fork [arch/i386/kernel/process.c]</li>
<li>do_fork [kernel/fork.c]</li>
<li>alloc_task_struct [include/asm/processor.c]</li>
<li>__get_free_pages [mm/page_alloc.c]</li>
<li>get_pid [kernel/fork.c]</li>
<li>copy_files</li>
<li>copy_fs</li>
<li>copy_sighand</li>
<li>copy_mm</li>
<li>allocate_mm</li>
<li>mm_init</li>
<li>pgd_alloc -&gt; get_pgd_fast [include/asm/pgalloc.h]</li>
<li>get_pgd_slow</li>
<li>dup_mmap [kernel/fork.c]</li>
<li>copy_page_range [mm/memory.c]</li>
<li>ptep_set_wrprotect [include/asm/pgtable.h]</li>
<li>clear_bit [include/asm/bitops.h]</li>
<li>copy_segments [arch/i386/kernel/process.c]</li>
<li>copy_thread</li>
<li>SET_LINKS [include/linux/sched.h]</li>
<li>wake_up_process [kernel/sched.c]</li>
</ul>
<h3>Copy on Write (Copie sur Ecriture)</h3>
<p>Pour impl&eacute;menter la Copie sur Ecriture pour Linux:</p>
<ol>
<li>Marquez toutes les pages copi&eacute;es en lecture-seule,
entra&icirc;nant une Faute de Page quand une T&acirc;che essaye d'y
&eacute;crire.</li>
<li>Le gestionnaire de Faute de page cr&eacute; une nouvelle
page.</li>
</ol>
<pre>
 
 | Page 
 | Fault 
 | Exception
 |
 |
 -----------&gt; |do_page_fault
                 |handle_mm_fault
                    |handle_pte_fault 
                       |do_wp_page        
                          |alloc_page      // Alloue une nouvelle page
                          |break_cow
                             |copy_cow_page // Copie l'ancienne page vers une nouvelle
                             |establish_pte // reconfigure les pointeurs de la Table de Page
                                |set_pte
                            
              Page Fault ICA
 
</pre>
<ul>
<li>do_page_fault [arch/i386/mm/fault.c]</li>
<li>handle_mm_fault [mm/memory.c]</li>
<li>handle_pte_fault</li>
<li>do_wp_page</li>
<li>alloc_page [include/linux/mm.h]</li>
<li>break_cow [mm/memory.c]</li>
<li>copy_cow_page</li>
<li>establish_pte</li>
<li>set_pte [include/asm/pgtable-3level.h]</li>
</ul>
<h2><a name="s7">7. Gestion de M&eacute;moire de Linux</a></h2>
<h2><a name="ss7.1">7.1 Vue d'ensemble</a></h2>
<p>Linux utilise segmentation + pagination, ce qui simplifie la
notation.</p>
<h3>Segments</h3>
<p>Linux utilise seulement 4 segments:</p>
<ul>
<li>2 segments (code and data/stack ou code et donn&eacute;e/pile)
pour l'ESPACE NOYAU de [0xC000 0000] (3 Go) &agrave; [0xFFFF FFFF]
(4 Go)</li>
<li>2 segments (code et donn&eacute;e/pile) pour l'ESPACE
UTILISATEUR de [0] (0 Go) &agrave; [0xBFFF FFFF] (3 Go)</li>
</ul>
<pre>
                               __
   4 Go---&gt;|                |    |
           |     Noyau      |    |  Espace Noyau (Code + Donn&eacute;e/Pile)
           |                |  __|
   3 Go---&gt;|----------------|  __
           |                |    |
           |                |    |
   2 Go---&gt;|                |    |
           |     T&acirc;che      |    |  Espace Utilisateur (Code + Donn&eacute;e/Pile)
           |                |    |
   1 Go---&gt;|                |    |
           |                |    |
           |________________|  __| 
 0x00000000
          Adresses Lin&eacute;aires Noyau/Utilisateur
 
</pre>
<h2><a name="ss7.2">7.2 Impl&eacute;mentation i386
sp&eacute;cifique</a></h2>
<p>A nouveau, Linux impl&eacute;mente la Pagination en utilisant 3
Niveaux de Pagination, mais dans l'architecture i386 seulement 2
d'entre elles sont vraiment utilis&eacute;es:</p>
<pre>
 
   ------------------------------------------------------------------
     A   D   R   E   S   S   E       L   I   N   E   A   I   R   E
   ------------------------------------------------------------------
        \___/                 \___/                     \_____/ 
 
     PD offset              PF offset                 Frame offset 
     [10 bits]              [10 bits]                 [12 bits]       
          |                     |                          |
          |                     |     -----------          |        
          |                     |     |  Value  |----------|---------
          |     |         |     |     |---------|   /|\    |        |
          |     |         |     |     |         |    |     |        |
          |     |         |     |     |         |    | Frame offset |
          |     |         |     |     |         |   \|/             |
          |     |         |     |     |---------|&lt;------            |
          |     |         |     |     |         |      |            |
          |     |         |     |     |         |      | x 4096     |
          |     |         |  PF offset|_________|-------            |
          |     |         |       /|\ |         |                   |
      PD offset |_________|-----   |  |         |          _________|
            /|\ |         |    |   |  |         |          | 
             |  |         |    |  \|/ |         |         \|/
 _____       |  |         |    ------&gt;|_________|   PHYSICAL ADDRESS 
|     |     \|/ |         |    x 4096 |         |
| CR3 |--------&gt;|         |           |         |
|_____|         | ....... |           | ....... |
                |         |           |         |    
 
               Dossier Page           Fichier Page

                       Pagination Linux i386
 


</pre>
<h2><a name="ss7.3">7.3 Tra&ccedil;age M&eacute;moire</a></h2>
<p>Linux g&egrave;re le Contr&ocirc;le d'Acc&egrave;s seulement
avec des paginations, ainsi les diff&eacute;rentes T&acirc;ches
auront les m&ecirc;mes adresses de segment, mais un CR3
diff&eacute;rent (registre utilis&eacute; pour stocker l'Adresse de
Page du Dossier), pointant vers une Page diff&eacute;rente.</p>
<p>En Mode Utilisateur une T&acirc;che ne peut pas d&eacute;passer
la limite de 3 Go (0 x C0 00 00 00), ainsi seulement les 768
premi&egrave;res entr&eacute;es de r&eacute;pertoire de page sont
significative (768*4mb = 3Go).</p>
<p>Quand une T&acirc;che passe en Mode Noyau (par Appel System ou
par IRQ) d'autres entr&eacute;es de r&eacute;pertoire de 256 pages
deviennent importantes, et elles pointent vers les m&ecirc;mes
fichiers de page que toutes autres T&acirc;ches (qui sont les
m&ecirc;me que le noyau).</p>
<p>Notez que l'Espace Lin&eacute;aire du Noyau (et seulement du
noyau) est &eacute;gal &agrave; l'Espace Physique du Noyau,
ainsi:</p>
<pre>
 
            ________________ _____                    
           |Other KernelData|___  |  |                |
           |----------------|   | |__|                |
           |     Kernel     |\  |____|   Real Other   |
  3 GB ---&gt;|----------------| \      |   Kernel Data  |
           |                |\ \     |                |
           |              __|_\_\____|__   Real       |
           |      Tasks     |  \ \   |     Tasks      |
           |              __|___\_\__|__   Space      |
           |                |    \ \ |                |
           |                |     \ \|----------------|
           |                |      \ |Real KernelSpace|
           |________________|       \|________________|
      
           Adresses Logiques          Adresses Physiques
 
</pre>
<p>L'Espace Lin&eacute;aire du Noyau correspond &agrave; l'Espace
Physique du Noyau transf&eacute;r&eacute; 3 Go plus bas (translated
3GB down) (en fait les tables de page sont quelque chose comme {
"00000000", "00000001" }, ainsi elles n'effectuent aucune
virtualisation, elles reportent seulement des adresses physiques
qu'elles prennent des lin&eacute;aires).</p>
<p>Notez que vous n'aurez pas un "conflit d'adresses" entre les
espaces Noyau et Utilisateur parce que nous pouvons g&eacute;rer
des adresses physiques avec les Tableaux de Page.</p>
<h2><a name="ss7.4">7.4 Attribution de m&eacute;moire de bas
niveau</a></h2>
<h3>Initialisation du D&eacute;marrage</h3>
<p>Nous commen&ccedil;ons &agrave; partir du kmem_cache_init
(lanc&eacute; par start_kernel [ init/main.c ] au
d&eacute;marrage).</p>
<pre>
|kmem_cache_init
   |kmem_cache_estimate

</pre>
<p>kmem_cache_init [mm/slab.c]</p>
<p>kmem_cache_estimate</p>
<p>Maintenant nous continuons avec mem_init (&eacute;galement
lanc&eacute; par start_kernel[init/main.c ])</p>
<pre>
|mem_init
   |free_all_bootmem
      |free_all_bootmem_core
</pre>
<p>mem_init [arch/i386/mm/init.c]</p>
<p>free_all_bootmem [mm/bootmem.c]</p>
<p>free_all_bootmem_core</p>
<h3>Allocation du temps d'ex&eacute;cution</h3>
<p>Sous Linux, quand nous voulons allouer de la m&eacute;moire, par
exemple pendant le m&eacute;canisme "copy_on_write" (voir Chap.10),
nous appelons:</p>
<pre>
|copy_mm 
   |allocate_mm = kmem_cache_alloc
      |__kmem_cache_alloc
         |kmem_cache_alloc_one
            |alloc_new_slab
               |kmem_cache_grow
                  |kmem_getpages
                     |__get_free_pages
                        |alloc_pages
                           |alloc_pages_pgdat
                              |__alloc_pages
                                 |rmqueue   
                                 |reclaim_pages

</pre>
<p>Les fonctions peuvent &ecirc;tre trouv&eacute;es ci-dessous:</p>
<ul>
<li>copy_mm [kernel/fork.c]</li>
<li>allocate_mm [kernel/fork.c]</li>
<li>kmem_cache_alloc [mm/slab.c]</li>
<li>__kmem_cache_alloc</li>
<li>kmem_cache_alloc_one</li>
<li>alloc_new_slab</li>
<li>kmem_cache_grow</li>
<li>kmem_getpages</li>
<li>__get_free_pages [mm/page_alloc.c]</li>
<li>alloc_pages [mm/numa.c]</li>
<li>alloc_pages_pgdat</li>
<li>__alloc_pages [mm/page_alloc.c]</li>
<li>rm_queue</li>
<li>reclaim_pages [mm/vmscan.c]</li>
</ul>
<p>TODO: Comprendre les Zones</p>
<h2><a name="ss7.5">7.5 &Eacute;change (Swap ou
glissement)</a></h2>
<h3>Vue d'ensemble</h3>
<p>L'&eacute;change est g&eacute;r&eacute; par le service kswapd
(fil du noyau).</p>
<h3>kswapd</h3>
<p>Comme d'autres fils du noyau, le kswapd a une boucle principale
qui attend de se r&eacute;veiller.</p>
<pre>
|kswapd
   |// initialization routines
   |for (;;) { // Main loop
      |do_try_to_free_pages
      |recalculate_vm_stats
      |refill_inactive_scan
      |run_task_queue
      |interruptible_sleep_on_timeout // on dort en attendant une nouvelle demande d'&eacute;change
   |}
</pre>
<ul>
<li>kswapd [mm/vmscan.c]</li>
<li>do_try_to_free_pages</li>
<li>recalculate_vm_stats [mm/swap.c]</li>
<li>refill_inactive_scan [mm/vmswap.c]</li>
<li>run_task_queue [kernel/softirq.c]</li>
<li>interruptible_sleep_on_timeout [kernel/sched.c]</li>
</ul>
<h3>Quand avons-nous besoin d'&eacute;changer?</h3>
<p>L'&eacute;change est n&eacute;cessaire quand nous devons
acc&eacute;der &agrave; une page qui n'est pas en m&eacute;moire
physique.</p>
<p>Linux utilise le fil du noyau ''kswapd'' pour ce faire. Quand la
T&acirc;che re&ccedil;oit une faute d'exception de page nous
faisons ce qui suit:</p>
<pre>
 
 | Faute d'Execption de Page
 | caus&eacute;e par toutes ces conditions: 
 |   a-) Page Utilisateur
 |   b-) Acc&egrave;s lecture ou &eacute;criture
 |   c-) Page non pr&eacute;sente
 |
 |
 -----------&gt; |do_page_fault
                 |handle_mm_fault
                    |pte_alloc 
                       |pte_alloc_one
                          |__get_free_page = __get_free_pages
                             |alloc_pages
                                |alloc_pages_pgdat
                                   |__alloc_pages
                                      |wakeup_kswapd // Nous r&eacute;veillons le fil de noyau kswapd
   
                   Page Fault ICA
 
</pre>
<ul>
<li>do_page_fault [arch/i386/mm/fault.c]</li>
<li>handle_mm_fault [mm/memory.c]</li>
<li>pte_alloc</li>
<li>pte_alloc_one [include/asm/pgalloc.h]</li>
<li>__get_free_page [include/linux/mm.h]</li>
<li>__get_free_pages [mm/page_alloc.c]</li>
<li>alloc_pages [mm/numa.c]</li>
<li>alloc_pages_pgdat</li>
<li>__alloc_pages</li>
<li>wakeup_kswapd [mm/vmscan.c]</li>
</ul>
<h2><a name="s8">8. R&eacute;seau Linux Linux Networking</a></h2>
<h2><a name="ss8.1">8.1 Comment le r&eacute;seau Linux est-il
g&eacute;r&eacute;?</a></h2>
<p>Il existe un pilote de p&eacute;riph&eacute;rique pour chaque
type de NIC. De l'int&eacute;rieur, Linux appellera TOUJOURS une
routine standard de haut niveau: "netif_rx [net/core/dev.c]", qui
contr&ocirc;lera &agrave; quel protocole de niveau 3 le cadre
appartient, et il appellera la bonne fonction de niveau 3 (ainsi
nous utiliserons un pointeur vers la fonction pour
d&eacute;terminer laquelle est la bonne). (There exists a device
driver for each kind of NIC. Inside it, Linux will ALWAYS call a
standard high level routing: "netif_rx [net/core/dev.c]", which
will controls what 3 level protocol the frame belong to, and it
will call the right 3 level function (so we'll use a pointer to the
function to determine which is right).</p>
<h2><a name="ss8.2">8.2 Exemple TCP</a></h2>
<p>Nous allons voir maintenant un exemple de ce qui se produit
quand nous envoyons un paquet TCP &agrave; Linux, &agrave; partir
de l'appel ''netif_rx [net/core/dev.c] ''.</p>
<h3>Gestion d'interruption: "netif_rx"</h3>
<pre>
|netif_rx
   |__skb_queue_tail
      |qlen++
      |* simple pointer insertion *    
   |cpu_raise_softirq
      |softirq_active(cpu) |= (1 &lt;&lt; NET_RX_SOFTIRQ) // met l'octet NET_RX_SOFTIRQ dans le vecteur BH
 
</pre>
<p>Fonctions:</p>
<ul>
<li>__skb_queue_tail [include/linux/skbuff.h]</li>
<li>cpu_raise_softirq [kernel/softirq.c]</li>
</ul>
<h3>Gestion de Post Interruption: "net_rx_action"</h3>
<p>Une fois que l'interaction d'IRQ est finie, nous devons suivre
la prochaine partie de la vie du cadre et examiner ce que fait
NET_RX_SOFTIRQ.</p>
<p>Nous appellerons ensuite ''net_rx_action [net/core/dev.c]''
selon "net_dev_init [net/core/dev.c]".</p>
<pre>
|net_rx_action
   |skb = __skb_dequeue (the exact opposite of __skb_queue_tail)
   |for (ptype = first_protocol; ptype &lt; max_protocol; ptype++) // Determine 
      |if (skb-&gt;protocol == ptype)                               // what is the network protocol
         |ptype-&gt;func -&gt; ip_rcv // according to ''struct ip_packet_type [net/ipv4/ip_output.c]''
 
    **** MAINTENANT NOUS SAVONS QUEL PAQUET EST IP ****
         |ip_rcv
            |NF_HOOK (ip_rcv_finish)
               |ip_route_input // cherche dans la table de routage pour d&eacute;terminer la fonction &agrave; appeler
                  |skb-&gt;dst-&gt;input -&gt; ip_local_deliver // selon la pr&eacute;c&eacute;dente v&eacute;rification de la table de routage, la destination est la machine locale
                     |ip_defrag // rassemble les fragments IP
                        |NF_HOOK (ip_local_deliver_finish)
                           |ipprot-&gt;handler -&gt; tcp_v4_rcv // selon ''tcp_protocol [include/net/protocol.c]''
 
     **** MAINTENANT NOUS SAVONS QUEL PAQUET EST TCP ****
                           |tcp_v4_rcv   
                              |sk = __tcp_v4_lookup 
                              |tcp_v4_do_rcv
                                 |switch(sk-&gt;state) 

     *** Le paquet peut &ecirc;tre envoy&eacute; &agrave; la t&acirc;che qui utilise une connexion (socket) relative ***
                                 |case TCP_ESTABLISHED:
                                    |tcp_rcv_established
                                       |__skb_queue_tail // enfile le packet vers la connexion
                                       |sk-&gt;data_ready -&gt; sock_def_readable 
                                          |wake_up_interruptible
                                

     *** Le packet est toujours pris en main par le 3-way TCP handshake ***
                                 |case TCP_LISTEN:
                                    |tcp_v4_hnd_req
                                       |tcp_v4_search_req
                                       |tcp_check_req
                                          |syn_recv_sock -&gt; tcp_v4_syn_recv_sock
                                       |__tcp_v4_lookup_established
                                 |tcp_rcv_state_process

                    *** 3-Way TCP Handshake ***
                                    |switch(sk-&gt;state)
                                    |case TCP_LISTEN: // We received SYN
                                       |conn_request -&gt; tcp_v4_conn_request
                                          |tcp_v4_send_synack // Send SYN + ACK
                                             |tcp_v4_synq_add // set SYN state
                                    |case TCP_SYN_SENT: // we received SYN + ACK
                                       |tcp_rcv_synsent_state_process
                                          tcp_set_state(TCP_ESTABLISHED)
                                             |tcp_send_ack
                                                |tcp_transmit_skb
                                                   |queue_xmit -&gt; ip_queue_xmit
                                                      |ip_queue_xmit2
                                                         |skb-&gt;dst-&gt;output
                                    |case TCP_SYN_RECV: // We received ACK
                                       |if (ACK)
                                          |tcp_set_state(TCP_ESTABLISHED)
                              
</pre>
<p>Fonctions ci-dessous:</p>
<ul>
<li>net_rx_action [net/core/dev.c]</li>
<li>__skb_dequeue [include/linux/skbuff.h]</li>
<li>ip_rcv [net/ipv4/ip_input.c]</li>
<li>NF_HOOK -&gt; nf_hook_slow [net/core/netfilter.c]</li>
<li>ip_rcv_finish [net/ipv4/ip_input.c]</li>
<li>ip_route_input [net/ipv4/route.c]</li>
<li>ip_local_deliver [net/ipv4/ip_input.c]</li>
<li>ip_defrag [net/ipv4/ip_fragment.c]</li>
<li>ip_local_deliver_finish [net/ipv4/ip_input.c]</li>
<li>tcp_v4_rcv [net/ipv4/tcp_ipv4.c]</li>
<li>__tcp_v4_lookup</li>
<li>tcp_v4_do_rcv</li>
<li>tcp_rcv_established [net/ipv4/tcp_input.c]</li>
<li>__skb_queue_tail [include/linux/skbuff.h]</li>
<li>sock_def_readable [net/core/sock.c]</li>
<li>wake_up_interruptible [include/linux/sched.h]</li>
<li>tcp_v4_hnd_req [net/ipv4/tcp_ipv4.c]</li>
<li>tcp_v4_search_req</li>
<li>tcp_check_req</li>
<li>tcp_v4_syn_recv_sock</li>
<li>__tcp_v4_lookup_established</li>
<li>tcp_rcv_state_process [net/ipv4/tcp_input.c]</li>
<li>tcp_v4_conn_request [net/ipv4/tcp_ipv4.c]</li>
<li>tcp_v4_send_synack</li>
<li>tcp_v4_synq_add</li>
<li>tcp_rcv_synsent_state_process [net/ipv4/tcp_input.c]</li>
<li>tcp_set_state [include/net/tcp.h]</li>
<li>tcp_send_ack [net/ipv4/tcp_output.c]</li>
</ul>
<p>Description:</p>
<ul>
<li>D'abord nous d&eacute;terminons le type de protocole (IP, puis
TCP)</li>
<li>NF_hook (fonction) est une routine d'emballage (wrapper) qui
g&egrave;re d'abord le filtre r&eacute;seau (par exemple mur de
feu), puis lui appelle la ''fonction''.</li>
<li>Apr&egrave;s que nous contr&ocirc;lions 3-way TCP Handshake qui
se compose de:</li>
</ul>
<pre>
SERVEUR (ECOUTE)                          CLIENT (CONNECTING)
                           SYN 
                   &lt;-------------------
 
 
                        SYN + ACK
                   -------------------&gt;

 
                           ACK 
                   &lt;-------------------

                    3-Way TCP handshake

</pre>
<ul>
<li>&Agrave; la fin que nous devons seulement lancer
"tcp_rcv_established [net/ipv4/tcp_input.c]" qui donne le paquet
&agrave; la connexion utilisateur et le r&eacute;veille.</li>
</ul>
<h2><a name="s9">9. Syst&egrave;me de fichier Linux</a></h2>
<p>TODO</p>
<h2><a name="s10">10. Trucs utiles</a></h2>
<h2><a name="ss10.1">10.1 Pile et tas (Stack and Heap)</a></h2>
<h3>Vue d'ensemble</h3>
<p>Ici nous regardons comment la "pile" et le "tas" sont
allou&eacute;s en m&eacute;moire</p>
<h3>Allocation m&eacute;moire</h3>
<pre>

FF..        |                 | &lt;-- bas de la pile
       /|\  |                 |   | 
 valeurs|   |                 |   |   pile
 &eacute;lev&eacute;es|   |                 |  \|/  grandit
            |                 |
XX..        |                 | &lt;-- haut de la pile [Pointeur de pile]
            |                 |
            |                 |
            |                 |
00..        |_________________| &lt;-- fin de pile [Segment de pile]
                 
                   Pile

</pre>
<p>Les valeurs d'adresse de m&eacute;moire commencent &agrave; 00.
(qui est aussi l&agrave; o&ugrave; le Segment de Pile commence) et
ils vont jusqu'&agrave; la valeur FF..</p>
<p>XX.. est la valeur r&eacute;elle du pointeur de pile.</p>
<p>La pile est utilis&eacute;e par les fonctions pour:</p>
<ol>
<li>les variables globales</li>
<li>les variables locales</li>
<li>l'adresse de retour</li>
</ol>
<p>Par exemple, pour une fonction classique:</p>
<pre>

 |int foo_function (parameter_1, parameter_2, ..., parameter_n) {
    |variable_1 declaration;
    |variable_2 declaration;
      ..
    |variable_n declaration;
   
    |// Body function
    |dynamic variable_1 declaration;
    |dynamic variable_2 declaration;
     ..
    |dynamic variable_n declaration;
   
    |// Le code est &agrave; l'int&eacute;rieur du Segment Code, pas le segment Donn&eacute;e/Pile!
    
    |return (ret-type) value; // souvent c'est &agrave; l'int&eacute;rieur d'un registre, pour l'i386 le registre eax est utilis&eacute;.
 |}
nous avons

          |                       |
          | 1. parameter_1 pushed | \
    P     | 2. parameter_2 pushed |  | Avant  
    I     | ...................   |  | l'appel
    L     | n. parameter_n pushed | /
    E     | ** Return address **  | -- Appel
          | 1. local variable_1   | \ 
          | 2. local variable_2   |  | Apr&egrave;s
          | .................     |  | l'appel
          | n. local variable_n   | /
          |                       | 
         ...                     ...   Pile
         ...                     ...   libre
          |                       |
    T     | n. dynamic variable_n | \
    A     | ...................   |  | Allou&eacute; par
    S     | 2. dynamic variable_2 |  | malloc &amp; kmalloc
          | 1. dynamic variable_1 | /
          |_______________________|
        
           Usage typique de la pile
 
Note: l'ordre des variables peut &ecirc;tre diff&eacute;rent selon l'architecture du mat&eacute;riel. 
</pre>
<h2><a name="ss10.2">10.2 Application vs Processus</a></h2>
<h3>D&eacute;finition basse</h3>
<p>Nous devons distinguer 2 concepts:</p>
<ul>
<li>Application: c'est le code utile que nous voulons
ex&eacute;cuter</li>
<li>Processus: c'est l'IMAGE en m&eacute;moire de l'application
(elle d&eacute;pend de la strat&eacute;gie m&eacute;moire
utilis&eacute;e, de la segmentation et/ou de la Pagination).</li>
</ul>
<p>Souvent le Processus s'appelle &eacute;galement T&acirc;che ou
Fil.</p>
<h2><a name="ss10.3">10.3 Bloquages (Locks)</a></h2>
<h3>Vue d'ensemble</h3>
<p>2 genre de serrures:</p>
<ol>
<li>intraCPU</li>
<li>interCPU</li>
</ol>
<h2><a name="ss10.4">10.4 Copy_on_write</a></h2>
<p>Copy_on_write est un m&eacute;canisme utilis&eacute; pour
r&eacute;duire l'utilisation de m&eacute;moire. Il remet
l'allocation m&eacute;moire &agrave; plus tard de m&eacute;moire
jusqu'&agrave; ce que la m&eacute;moire soit vraiment
n&eacute;cessaire.</p>
<p>Par exemple, quand une T&acirc;che ex&eacute;cute l'Appel
Syst&egrave;me "fork()" (pour cr&eacute;er une autre T&acirc;che),
nous utilisons toujours les m&ecirc;mes pages de m&eacute;moire que
le parent, en mode lecture seule. Quand une T&acirc;che
&Eacute;CRIT dans la page, elle cause une exception et la page est
copi&eacute;e et marqu&eacute;e "rw" (lecture,
&eacute;criture).</p>
<pre>
 
1-) la page X est partag&eacute;e entre la T&acirc;che parent et la T&acirc;che enfant
 T&acirc;che Parent
 |         | Acc&egrave;s RO   ______
 |         |----------&gt;|Page X|    
 |_________|           |______|
                          /|\
                           |
 T&ecirc;che Enfant              | 
 |         | Acc&egrave;s RO      |  
 |         |----------------                
 |_________| 
 
 
2-) Write request
 Task Parent
 |         | Acc&egrave;s RO   ______
 |         |----------&gt;|Page X|    Trying to write
 |_________|           |______|
                          /|\
                           |
 Task Child                | 
 |         | Acc&egrave;s RO      |  
 |         |----------------                
 |_________| 
 
 
3-) Final Configuration: Either Task Parent and Task Child have an independent copy of the Page, X and Y
 Task Parent
 |         | Acc&egrave;s RW   ______
 |         |----------&gt;|Page X|    
 |_________|           |______|
              
              
 Task Child
 |         | Acc&egrave;s RW   ______
 |         |----------&gt;|Page Y|    
 |_________|           |______|
</pre>
<h2><a name="s11">11. D&eacute;tails sp&eacute;cifiques
80386</a></h2>
<h2><a name="ss11.1">11.1 Proc&eacute;dure de
d&eacute;marrage</a></h2>
<pre>
bbootsect.s [arch/i386/boot]
setup.S (+video.S) 
head.S (+misc.c) [arch/i386/boot/compressed]
start_kernel [init/main.c]
</pre>
<h2><a name="ss11.2">11.2 Descripteurs 80386 (et plus)</a></h2>
<h3>Vue d'ensemble</h3>
<p>Les descripteurs sont des structure de donn&eacute;es
utilis&eacute;es par le microprocesseur Intel i386+ pour rendre la
m&eacute;moire virtuelle.</p>
<h3>Types de descripteurs</h3>
<ul>
<li>GDT (Table Globale de Descripteur)</li>
<li>LDT (Table Locale de Descripteur)</li>
<li>IDT (Table de Descripteur d'Interruption)</li>
</ul>
<h2><a name="s12">12. IRQ</a></h2>
<h2><a name="ss12.1">12.1 Vue d'ensemble</a></h2>
<p>IRQ est un signal asyncrone envoy&eacute; au microprocesseur
pour annoncer qu'une requ&ecirc;te est compl&eacute;t&eacute;e</p>
<h2><a name="ss12.2">12.2 Sch&eacute;ma d'interaction</a></h2>
<pre>
                                 |&lt;--&gt;  IRQ(0) [Timer]
                                 |&lt;--&gt;  IRQ(1) [Device 1]
                                 | ..
                                 |&lt;--&gt;  IRQ(n) [Device n]
    _____________________________| 
     /|\      /|\          /|\
      |        |            |
     \|/      \|/          \|/
 
    T&acirc;che(1)  T&acirc;che(2) ..   T&acirc;che(N)
              
             
             IRQ - Sch&eacute;ma d'Interaction de T&acirc;ches
  

</pre>
<h3>Que se produit?</h3>
<p>Un SE typique utilise beaucoup de signaux IRQ pour interrompre
l'ex&eacute;cution normale de processus et fait le m&eacute;nage.
Ainsi:</p>
<ol>
<li>IRQ (i) se produit et T&acirc;che(j) est interrompue</li>
<li>IRQ(i)_handler est ex&eacute;cut&eacute;</li>
<li>le contr&ocirc;le revient &agrave; la T&acirc;che(j)
interrompue</li>
</ol>
<p>Sous Linux, quand un IRQ survient, d'abord la routine
d'emballage IRQ (appel&eacute;e "interrupt0x??") est
appell&eacute;e, puis l'IRQ(i)_handler "officiel" est
ex&eacute;cut&eacute;. Ceci permet certains droits comme la
pr&eacute;emption de timeslice.</p>
<h2><a name="s13">13. Fonctions utilitaires</a></h2>
<h2><a name="ss13.1">13.1 list_entry
[include/linux/list.h]</a></h2>
<p>Definition:</p>
<pre>
#define list_entry(ptr, type, member) \
((type *)((char *)(ptr)-(unsigned long)(&amp;((type *)0)-&gt;member)))
</pre>
<p>Signification:</p>
<p>La macro "list_entry" est utilis&eacute;e pour retrouver un
pointeur de struct parent, en utilisant seulement un pointeur de
struct interne.</p>
<p>Exemple:</p>
<pre>
struct __wait_queue {
   unsigned int flags; 
   struct task_struct * task; 
   struct list_head task_list;
};
struct list_head { 
   struct list_head *next, *prev; 
};

// et avec la d&eacute;finition type:
typedef struct __wait_queue wait_queue_t;

// nous aurons
wait_queue_t *out list_entry(tmp, wait_queue_t, task_list);

// o&ugrave; tmp pointe vers list_head
</pre>
<p>Ainsi, dans ce cas, au moyen du pointeur *tmp [list_head] nous
retrouvons le pointeur *out [wait_queue_t].</p>
<pre>

 ____________ &lt;---- *out [nous calculons que]
|flags       |             /|\
|task *--&gt;   |              |
|task_list   |&lt;----    list_entry
|  prev * --&gt;|    |         |
|  next * --&gt;|    |         |
|____________|    ----- *tmp [nous avons &ccedil;a]
 
</pre>
<h2><a name="ss13.2">13.2 Sommeil</a></h2>
<h3>Code de sommeil</h3>
<p>Fichiers:</p>
<ul>
<li>kernel/sched.c</li>
<li>include/linux/sched.h</li>
<li>include/linux/wait.h</li>
<li>include/linux/list.h</li>
</ul>
<p>Fonctions:</p>
<ul>
<li>interruptible_sleep_on</li>
<li>interruptible_sleep_on_timeout</li>
<li>sleep_on</li>
<li>sleep_on_timeout</li>
</ul>
<p>Fonctions appel&eacute;es:</p>
<ul>
<li>init_waitqueue_entry</li>
<li>__add_wait_queue</li>
<li>list_add</li>
<li>__list_add</li>
<li>__remove_wait_queue</li>
</ul>
<p>Analyse D'InterCallings:</p>
<pre>
|sleep_on
   |init_waitqueue_entry  --
   |__add_wait_queue        |   enqueuing request to resource list
      |list_add              |
         |__list_add        -- 
   |schedule              ---     waiting for request to be executed
      |__remove_wait_queue --   
      |list_del              |   dequeuing request from resource list
         |__list_del        -- 
 

</pre>
<p>Description:</p>
<p>Sous Linux chaque ressource (id&eacute;alement un objet
partag&eacute; par plusieurs utilisateurs et plusieurs processus),
a une file pour g&eacute;rer TOUTES les T&acirc;ches qui la
demandant.</p>
<p>Cette file s'appelle l"file d'attente" et elle consiste en
plusieurs &eacute;l&eacute;ments que nous appellerons
l"&eacute;l&eacute;ment de file d'attente":</p>
<pre>
***   structure de file d'attente [include/linux/wait.h]  ***


struct __wait_queue {
   unsigned int flags; 
   struct task_struct * task; 
   struct list_head task_list;
}
struct list_head { 
   struct list_head *next, *prev; 
};
</pre>
<p>Fonctionnement de graphique:</p>
<pre>
        ***  &eacute;l&eacute;ment de file d'attente  ***

                             /|\
                              |
       &lt;--[pr&eacute;c *, drapeau, t&acirc;chesk *, suiv *]--&gt;
 
                     


                 ***  liste de file d'attente ***  
 
          /|\           /|\           /|\                /|\
           |             |             |                  |
--&gt; &lt;--[t&acirc;ch1]--&gt; &lt;--[t&acirc;ch2]--&gt; &lt;--[t&acirc;che3]--&gt; .... &lt;--[t&acirc;cheN]--&gt; &lt;--
|                                                                  |
|__________________________________________________________________|
          

           
              ***   t&ecirc;te de file d'attente ***

       t&acirc;che1 &lt;--[pr&eacute;c *, blocage, suiv *]--&gt; t&acirc;cheN
   
 
</pre>
<p>"t&ecirc;te de file d'attente d'attente" pointe vers premier
(avec suiv *) et dernier (avec pr&eacute;c *)
&eacute;l&eacute;ments de la "liste de file d'attente".</p>
<p>Quand un nouvel &eacute;l&eacute;ment doit &ecirc;tre
ajout&eacute;, "__add_wait_queue" [include/linux/wait.h] est
appell&eacute;, apr&egrave;s quoi la routine
g&eacute;n&eacute;rique "list_add" [include/linux/wait.h], est
ex&eacute;cut&eacute;e:</p>
<pre>
***   function list_add [include/linux/list.h]  ***

// classic double link list insert
static __inline__ void __list_add (struct list_head * new,  \
                                   struct list_head * prev, \
                                   struct list_head * next) { 
   next-&gt;prev = new; 
   new-&gt;next = next; 
   new-&gt;prev = prev; 
   prev-&gt;next = new; 
}
</pre>
<p>Pour compl&eacute;ter la description, nous voyons aussi la
fonction "__list_del" [include/linux/list.h] appel&eacute;e par
"list_del" [include/linux/list.h] dans "remove_wait_queue"
[include/linux/wait.h]:</p>
<pre>
***   fonction list_del [include/linux/list.h]  ***


// classic double link list delete
static __inline__ void __list_del (struct list_head * prev, struct list_head * next) { 
   next-&gt;prev = prev; 
   prev-&gt;next = next; 
}
</pre>
<h3>Consideration sur la pile</h3>
<p>Une liste type (ou la file) est habituellement
g&eacute;r&eacute;e en l'allouant dans le Tas (voir le Chap.10 pour
la d&eacute;finition de Tas et Pile au sujet et voir o&ugrave; les
variables sont assign&eacute;es). Autrement ici, nous allouons
statiquement les donn&eacute;es File d'Attente dans une variable
locale (Pile), puis la fonction est interrompue par le programme,
&agrave; la fin, (retournant du programme (returning from
scheduling)) effacera la variable locale.</p>
<pre>
  new task &lt;----|          task1 &lt;------|          task2 &lt;------|
                |                       |                       |
                |                       |                       | 
|..........|    |       |..........|    |       |..........|    | 
|wait.flags|    |       |wait.flags|    |       |wait.flags|    |
|wait.task_|____|       |wait.task_|____|       |wait.task_|____|   
|wait.prev |--&gt;         |wait.prev |--&gt;         |wait.prev |--&gt;
|wait.next |--&gt;         |wait.next |--&gt;         |wait.next |--&gt;   
|..        |            |..        |            |..        |    
|schedule()|            |schedule()|            |schedule()|     
|..........|            |..........|            |..........|    
|__________|            |__________|            |__________|     
 
   Stack                   Stack                   Stack
</pre>
<h2><a name="s14">14. Variables statiques</a></h2>
<h2><a name="ss14.1">14.1 Vue d'ensemble</a></h2>
<p>Linux est &eacute;crit en ''langue C'', et toutes les
applications ont:</p>
<ol>
<li>Des variables locales</li>
<li>Des modules variables (dans le fichier source et relatif
seulement &agrave; ce module)</li>
<li>Des variables Globales/Statiques pr&eacute;sentent dans
seulement 1 copie (la m&ecirc;me pour tous les modules)</li>
</ol>
<p>Quand une variable statique est modifi&eacute;e par un module,
tous autres modules voient la nouvelle valeur.</p>
<p>Les variables statiques sous Linux sont tr&egrave;s importantes,
parce qu'elles sont la seule fa&ccedil;on d'ajouter un nouveau
support au noyau: elles sont typiquement des pointeurs en
t&ecirc;te d'une liste d'&eacute;l&eacute;ments enregistr&eacute;s,
qui peuvent &ecirc;tre:</p>
<ul>
<li>ajout&eacute;</li>
<li>supprim&eacute;</li>
<li>peut-&ecirc;tre modifi&eacute;</li>
</ul>
<pre>
                           _______      _______      _______
Variable globale  -------&gt; |Item(1)| -&gt; |Item(2)| -&gt; |Item(3)|  ..
                          |_______|    |_______|    |_______|
</pre>
<h2><a name="ss14.2">14.2 Variables principales</a></h2>
<h3>Current (Courant)</h3>
<pre>
                           ________________
Current ----------------&gt; | Actual process |
                          |________________|
</pre>
<p>Current pointe vers la structure ''task_struct'' , qui contient
toutes les donn&eacute;es sur un processus:</p>
<ul>
<li>pid, name, state, counter, policy of scheduling (pid, nom,
&eacute;tat, compteur, politique de programmation)</li>
<li>les pointeurs vers plusieurs structures de donn&eacute;es
comme: fichiers, vfs, autres processus, signaux...</li>
</ul>
<p>Current n'est pas une vraie variable, c'est</p>
<pre>
static inline struct task_struct * get_current(void) { 
   struct task_struct *current; 
   __asm__("andl %%esp,%0; ":"=r" (current) : "0" (~8191UL)); 
   return current; 
}
#define current get_current()
</pre>
<p>Les lignes au-dessus prennent juste la valeur du registre
''esp'' (pointeur de pile) et le rendent disponible comme une
variable, de laquelle nous pouvons pointer vers la structure
task_struct.</p>
<p>De l'&eacute;l&eacute;ment ''curent'' nous pouvons
acc&eacute;der directement &agrave; n'importe quel autre processus
(pr&ecirc;t, arr&ecirc;t&eacute; ou dans tout autre &eacute;tat) de
la structure de donn&eacute;es noyau, par exemple en changeant
l'ETAT (comme un pilote E/S le ferait), le PID, la pr&eacute;sence
dans la liste pr&ecirc;t ou la liste bloqu&eacute;, etc...</p>
<h3>Syst&egrave;mes de fichiers enregistr&eacute;s</h3>
<pre>
                       ______      _______      ______
file_systems  ------&gt; | ext2 | -&gt; | msdos | -&gt; | ntfs |
 [fs/super.c]         |______|    |_______|    |______|
</pre>
<p>Quand vous utilisez une commande comme ''modprobe un_fs'' vous
ajoutez une nouvelle entr&eacute;e &agrave; la liste des
syst&egrave;mes de fichiers, d&egrave;s que vous l'enlevez (avec
''rmmod'') il est supprim&eacute;.</p>
<h3>Syst&egrave;mes de fichiers mont&eacute;s</h3>
<pre>
                        ______      _______      ______
mount_hash_table  ----&gt;|   /  | -&gt; | /usr  | -&gt; | /var |
[fs/namespace.c]       |______|    |_______|    |______|
</pre>
<p>Quand vous utilisez la commande ''mount'' pour ajouter un fs, la
nouvelle entr&eacute;e est ins&eacute;r&eacute;e dans la liste,
jusqu'&agrave; ce que la commande ''umount'' supprime
l'entr&eacute;e.</p>
<h3>Type de Paquet R&eacute;seau Enregistr&eacute;</h3>
<pre>
                        ______      _______      ______ 
     ptype_all  ------&gt;|  ip  | -&gt; |  x25  | -&gt; | ipv6 |
[net/core/dev.c]       |______|    |_______|    |______|
</pre>
<p>Par exemple, si vous ajoutez le support IPv6 (en chargeant le
module relatif) une nouvelle entr&eacute;e est ajout&eacute;e
&agrave; la liste.</p>
<h3>Protocole de R&eacute;seau Internet Enregistr&eacute;</h3>
<pre>
                          ______      _______      _______ 
inet_protocol_base -----&gt;| icmp | -&gt; |  tcp  | -&gt; |  udp  |
[net/ipv4/protocol.c]    |______|    |_______|    |_______|
</pre>
<p>Aussi d'autres types de paquet ont plusieurs protocoles internes
dans chaque liste (comme IPv6).</p>
<pre>
                          ______      _______      _______ 
inet6_protos -----------&gt;|icmpv6| -&gt; | tcpv6 | -&gt; | udpv6 |
[net/ipv6/protocol.c]    |______|    |_______|    |_______|
</pre>
<h3>P&eacute;riph&eacute;rique R&eacute;seau Enregistr&eacute;</h3>
<pre>
                          ______      _______      _______ 
dev_base ---------------&gt;|  lo  | -&gt; |  eth0 | -&gt; |  ppp0 |
[drivers/core/Space.c]   |______|    |_______|    |_______|
</pre>
<h3>P&eacute;riph&eacute;rique Caract&egrave;re (Char)
Enregistr&eacute;</h3>
<pre>
                          ______      _______      ________ 
chrdevs ----------------&gt;|  lp  | -&gt; | keyb  | -&gt; | serial |
[fs/devices.c]           |______|    |_______|    |________|
</pre>
<p>''chrdevs'' n'est pas un pointeur vers une vraie liste, mais
c'est un vecteur standard.</p>
<h3>P&eacute;riph&eacute;rique Bloc Enregistr&eacute;</h3>
<pre>
                          ______      ______      ________ 
bdev_hashtable ---------&gt;|  fd  | -&gt; |  hd  | -&gt; |  scsi  |
[fs/block_dev.c]         |______|    |______|    |________|
</pre>
<p>''bdev_hashtable'' est un vecteur de hachage.</p>
<h2><a name="s15">15. Glossaire</a></h2>
<h2><a name="s16">16. Liens</a></h2>
<p><a href="http://www.kernel.org">Site de
t&eacute;l&eacute;chargemet du Noyau Linux Officiel et de
patches</a></p>
<p><a href=
"http://jungla.dit.upm.es/~jmseyas/linux/kernel/hackers-docs.html">Grosse
documentation sur le Noyau Linux</a></p>
<p><a href=
"http://www.uwsg.indiana.edu/hypermail/linux/kernel/index.html">Liste
de diffusion Officielle du Noyau</a></p>
<p><a href="http://www.tldp.org/guides.html">Guides du Project de
Documentation Linux</a></p>
</body>
</html>
