<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.21">
 <TITLE>The Linux Keyboard HOWTO</TITLE>
</HEAD>
<BODY>
<H1>The Linux Keyboard HOWTO</H1>

<H2>Andries Brouwer, <CODE>aeb@cwi.nl</CODE></H2>v2.1, 8 Novembre 1995 - version fran&ccedil;aise Bruno Viaris
<HR>
<EM>Ce document traite de l'utilisation du clavier, de la console et de
 caract&egrave;res non ASCII sous Linux.</EM>
<HR>
<H2><A NAME="s1">1. Programmes utiles</A></H2>


<P>Les paquetages suivants contiennent des programmes en rapport avec le
clavier ou la console.</P>
<P><CODE>kbd-0.90.tar.gz</CODE> contient <CODE>loadkeys</CODE>, <CODE>dumpkeys</CODE>, <CODE>showkey</CODE>,
<CODE>setmetamode</CODE>, <CODE>setleds</CODE>, <CODE>setfont</CODE>, <CODE>showfont</CODE>, <CODE>mapscrn</CODE>,
<CODE>kbd_mode</CODE>, <CODE>chvt</CODE>, <CODE>resizecons</CODE>, <CODE>disalloc</CODE>,
<CODE>getkeycodes</CODE>, <CODE>setkeycodes</CODE>.</P>
<P><CODE>util-linux-2.5</CODE> contient <CODE>setterm</CODE>, <CODE>kbdrate</CODE>.</P>
<P><CODE>shellutils-1.8</CODE> (ou <CODE>stty.tar.gz</CODE>) contient <CODE>stty</CODE>.</P>
<P><CODE>open-1.1.tgz</CODE> contient <CODE>open</CODE>. (Voir aussi <CODE>dynamic-vc-1.1.tar.gz</CODE>.)</P>
<P><CODE>SVGATextMode-0.9.tar.gz</CODE> contient <CODE>SVGATextMode</CODE>.</P>
<P>La distribution standard de X contient <CODE>xmodmap</CODE>, <CODE>xset</CODE>, <CODE>kbd_mode</CODE>.
(Voir aussi X386keybd(1).)</P>

<H2><A NAME="s2">2. Le clavier - g&eacute;n&eacute;ralit&eacute;s</A></H2>


<P>Quand on appuie sur une touche, le contr&ocirc;leur clavier envoie des
scancodes au pilote clavier du noyau. Certains claviers sont
programmables, mais en g&eacute;n&eacute;ral les scancodes sont fixes.
Quand le pilote clavier est en <EM>mode scancode</EM> (dit aussi
<EM>mode raw</EM>), le noyau se contente 
de transmettre les codes tels quels &agrave; l'application, c'est ce qui se
passe sous <CODE>X</CODE>. Sinon le flux de scancodes est d&eacute;compos&eacute; en
keycodes correspondant &agrave; l'appui ou au rel&acirc;chement d'une touche. (Le
simple fait d'appuyer sur une touche peut produire jusqu'&agrave; 6
scancodes, r&eacute;duits ici en un seul keycode.) Si le pilote clavier est
en <EM>mode keycode</EM> (ou
<EM>mode mediumraw</EM>),
l'application re&ccedil;oit les keycodes (ce mode est utilis&eacute;, par exemple,
par <CODE>showkey</CODE>).
Sinon, les keycodes sont traduits d'apr&egrave;s une table (keymap), ensuite,
soit un caract&egrave;re (ou un cha&icirc;ne) est envoy&eacute; &agrave; l'application, soit une
action est d&eacute;clench&eacute;e.
(Exemple: si on appuie et rel&acirc;che la touche <CODE>q</CODE>, le clavier envoie
les scancodes 0x1E et 0x9E, ce qui est converti en keycodes 30 et
158, puis en la valeur 113, qui est le code ASCII ou Latin-1 de <CODE>q</CODE>
(avec un clavier Azerty et une keymap adapt&eacute;e).
Si on appuie et rel&acirc;che la touche <CODE>Suppr</CODE>, le clavier envoie les
scancodes 0xE0 0x53 0xE0 0xD3, convertis en keycodes 111 et 239, ce
qui donne finalement la s&eacute;quence ESC <CODE>[ 3 ~</CODE>. Ctrl-Alt-Suppr
est une combinaison de touches qui d&eacute;clenche une action.)</P>
<P>La conversion de scancodes exotiques en keycodes peut &ecirc;tre programm&eacute;e
avec l'utilitaire <CODE>setkeycodes</CODE>, mais peu de gens ont besoin.
La table de traduction des keycodes en caract&egrave;res, cha&icirc;nes ou
actions, i.e. la keymap, se manipule gr&acirc;ce &agrave; <CODE>loadkeys</CODE>.
Pour plus de d&eacute;tails, voir getkeycodes(8), setkeycodes(8), dumpkeys(1), loadkeys(1).</P>
<P>Dans ce paragraphe, le terme `envoy&eacute; &agrave; l'application' signifie en
fait `transmis au pilote du terminal'. Le texte est ensuite trait&eacute; de
la m&ecirc;me fa&ccedil;on que s'il venait d'une ligne s&eacute;rie. Les d&eacute;tails de ce
traitement sont ajust&eacute;s par le programme <CODE>stty</CODE>. </P>

<H2><A NAME="s3">3. La console - g&eacute;n&eacute;ralit&eacute;s</A></H2>


<P>A l'inverse, quand on envoie des caract&egrave;res &agrave; la console, ils
subissent un traitement standard (r&eacute;gl&eacute; par <CODE>stty</CODE>), puis sont
envoy&eacute;s au pilote de la console.
Le pilote de la console &eacute;mule un terminal VT100, et scrute les donn&eacute;es
re&ccedil;ues pour intercepter les s&eacute;quences escape (du genre d&eacute;placement du
curseur, effacement de l'&eacute;cran, etc.). Les autres octets sont,
apr&egrave;s une &eacute;ventuelle conversion par la table de conversion de la
console, &eacute;crits dans la m&eacute;moire vid&eacute;o. La carte vid&eacute;o affiche ces
caract&egrave;rs en utilisant une police stock&eacute;e dans sa m&eacute;moire. On peut
changer cette police en utilisant <CODE>setfont</CODE>, et la table de
conversion de la console peut &ecirc;tre modifi&eacute;e avec <CODE>mapscrn</CODE>.
Pour plus de d&eacute;tails, voir plus bas.</P>


<H2><A NAME="s4">4. R&eacute;initialiser le terminal</A></H2>


<P>L'&eacute;cran est plein de cochonneries, tout ce qu'on tape appara&icirc;t sous
forme de petits dessins. Que faire ?</P>
<P>De nombreux programmes retracent l'&eacute;cran quand on tape ^L, ce qui peut
&ecirc;tre utile en cas de modem bruit&eacute; ou de messages intempestifs &agrave;
l'&eacute;cran. La commande <CODE>clear</CODE> efface l'&eacute;cran.</P>
<P>La commande <CODE>reset</CODE> r&eacute;initialise le pilote de la console. Elle est
bien utile quand l'&eacute;cran est plein de ces jolis caract&egrave;res graphiques
illisibles, ou quand l'affichage est r&eacute;duit &agrave; la ligne du bas.
Si vous ne disposez pas de cette commande, ou si elle fait autre
chose, voici le rem&egrave;de: mettez ces deux lignes dans un fichier
ex&eacute;cutable <CODE>reset</CODE> quelque part dans votre PATH:
<BLOCKQUOTE><CODE>
<PRE>
#!/bin/sh
echo -e \\033c
</PRE>
</CODE></BLOCKQUOTE>

ce qui envoie la s&eacute;quence ESC c &agrave; la console.
Si vous avez charg&eacute; une police bizarre et que vous voulez revenir &agrave; la
police par d&eacute;faut,
<BLOCKQUOTE><CODE>
<PRE>
% setfont
</PRE>
</CODE></BLOCKQUOTE>

fera l'affaire (&agrave; condition que la police par d&eacute;faut soit &agrave; sa place).
Sur de vieux terminaux, l'utilisation de tabs peut demander un d&eacute;lai,
ex&eacute;cuter alors
<BLOCKQUOTE><CODE>
<PRE>
% stty tab3
</PRE>
</CODE></BLOCKQUOTE>

(voir stty(1)). Pour changer de mode vid&eacute;o, utiliser <CODE>resizecons</CODE> ou
<CODE>SVGATextMode</CODE>.
Ceci r&egrave;gle g&eacute;n&eacute;ralement la partie affichage.
C&ocirc;t&eacute; clavier, il peut y avoir encore pas mal de probl&egrave;mes. Si <CODE>X</CODE>,
<CODE>DOOM</CODE> ou tout autre programme travaillant en mode raw (ou
mediumraw) se plante, le clavier peut rester dans ce mode et il est
alors difficile d'ex&eacute;cuter la moindre commande. (Voir "Comment sortir
du mode raw" plus loin.)</P>

<H2><A NAME="ss4.1">4.1 Keyboard hardware reset</A>
</H2>


<P>Le probl&egrave;me peut parfois se situer &agrave; un niveau encore plus bas.
Il y a au moins deux niveaux (le clavier et le contr&ocirc;leur clavier) o&ugrave;
l'on peut envoyer la commande "d&eacute;sactiver le clavier" au mat&eacute;riel.
De plus les claviers ont souvent trois tables de scancodes utilisables
au choix.</P>
<P>Je n'ai cependant jamais entendu parler de cas o&ugrave; cela ait pos&eacute; un
probl&egrave;me.</P>
<P>Certains claviers ont une fonction de reprogrammation des touches.
Stormy Henderson (<CODE>
<A HREF="mailto:stromy@Ghost.Net">stormy@Ghost.Net</A></CODE>) &eacute;crit:
<BLOCKQUOTE>
`Si votre clavier a &eacute;t&eacute; accidentellement reprogramm&eacute;, vous pouvez
(avec un clavier Gateway AnyKey) appuyer sur control-alt-suspend_macro
pour remettre les choses en place.'
</BLOCKQUOTE>
</P>
<H2><A NAME="s5">5. Delete et Backspace</A></H2>



<H2><A NAME="ss5.1">5.1 Comment choisir le caract&egrave;re &agrave; utiliser pour effacer le dernier caract&egrave;re tap&eacute;</A>
</H2>


<P>
<BLOCKQUOTE><CODE>
<PRE>
% stty erase ^?
</PRE>
</CODE></BLOCKQUOTE>

Si le caract&egrave;re est effac&eacute;, mais d'une mani&egrave;re bizarre, c'est que les
param&egrave;tres du terminal sont mauvais. Si <CODE>echoprt</CODE> est activ&eacute;, les
caract&egrave;res effac&eacute;s s'affichent entre <CODE>\</CODE> et <CODE>/</CODE>.
Si <CODE>echoe</CODE> est d&eacute;sactiv&eacute;, les caract&egrave;res ne sont plus effac&eacute;s &agrave;
l'&eacute;cran, mais leur effacement est signal&eacute; par l'affichage du caract&egrave;re
d'effacement, exemple: <CODE>Libux###nux</CODE> (avec # comme
caract&egrave;re d'effacement).</P>
<P>On utilisera donc g&eacute;n&eacute;ralement <CODE>stty echoe -echoprt</CODE>. La commande
<CODE>stty sane</CODE> activera ces param&egrave;tres et bien d'autres. La commande
<CODE>stty -a</CODE> affiche les param&egrave;tres actuels. Pourquoi ces param&egrave;tres ne
sont pas activ&eacute;s par d&eacute;faut ? Il suffit d'utiliser le bon <CODE>getty</CODE>.</P>
<P>Il est &agrave; noter que beaucoup de programmes (comme <CODE>bash</CODE>, <CODE>emacs</CODE>
etc.) ont leur propres assignations de touches (d&eacute;finis dans
<CODE>~/.inputrc</CODE>, <CODE>~/.emacs</CODE>, etc.) et ne tiennent pas compte
de ces param&egrave;tres de terminal.</P>

<H3>`Getty comprenait bien DEL et BS, mais plus maintenant ?'</H3>


<P>Jadis, la console traduisait DEL (<CODE>\177</CODE>) en BS Espace BS
(<CODE>\010\040\010</CODE>).</P>
<P>Les DEL sont d&eacute;sormais ignor&eacute;s (comme le devrait toute &eacute;mulation vt100
fid&egrave;le). Choisissez un meilleur getty, i.e., qui n'affiche pas les DEL.</P>

<H3>`Login ne fait pas la m&ecirc;me chose au premier et au deuxi&egrave;me essai?'</H3>


<P>Au premier essai, on parle &agrave; <CODE>getty</CODE>, au deuxi&egrave;me &agrave;
<CODE>login</CODE>, deux programmes distincts qui peuvent se comporter diff&eacute;remment.</P>

<H2><A NAME="ss5.2">5.2 Comment dire &agrave; Linux quel code g&eacute;n&eacute;rer &agrave; l'appui sur une touche</A>
</H2>


<P>Quand on utilise la console, ou plus pr&eacute;cis&eacute;ment, quand le clavier
n'est pas en mode (medium)raw, il faut utiliser:
<BLOCKQUOTE><CODE>
<PRE>
% loadkeys monclavier.map
</PRE>
</CODE></BLOCKQUOTE>

Sous X, utiliser:
<BLOCKQUOTE><CODE>
<PRE>
% xmodmap monclavier.xmap
</PRE>
</CODE></BLOCKQUOTE>

Remarque: depuis XFree86-2.1, X initialise son clavier &agrave; partir de la
configuration du clavier de la console. Bien que les deux syst&egrave;mes ne
soient pas 100% compatibles, cette technique rend g&eacute;n&eacute;ralement
l'utilisation de <CODE>xmodmap</CODE> superflue.</P>
<P>Si, par exemple, si vous voulez que la touche Backspace g&eacute;n&egrave;re le code
BackSpace (^H), au lieu du code par d&eacute;faut (Delete), faites:
<BLOCKQUOTE><CODE>
<PRE>
% loadkeys
keycode 14 = BackSpace
%
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H3>`Pourquoi la touche BackSpace ne g&eacute;n&egrave;re pas BackSpace par d&eacute;faut ?'</H3>


<P>(i) Parce que les terminaux VT100 ont une touche Delete au dessus de
la touche Entr&eacute;e.</P>
<P>(ii) Parce que Linus en a d&eacute;cid&eacute; ainsi.</P>

<H2><A NAME="ss5.3">5.3 Comment dire &agrave; X d'&eacute;changer Delete et Backspace</A>
</H2>


<P>
<BLOCKQUOTE><CODE>
<PRE>
% xmodmap -e "keysym BackSpace = Delete" -e "keysym Delete = BackSpace"
</PRE>
</CODE></BLOCKQUOTE>

Ou, si vous voulez juste que Backspace g&eacute;n&egrave;re le code BackSpace:
<BLOCKQUOTE><CODE>
<PRE>
% xmodmap -e "keycode 22 = BackSpace"
</PRE>
</CODE></BLOCKQUOTE>

Ou, si vous voulez juste que Delete g&eacute;n&egrave;re le code Delete:
<BLOCKQUOTE><CODE>
<PRE>
% xmodmap -e "keycode 107 = Delete"
</PRE>
</CODE></BLOCKQUOTE>

(mais g&eacute;n&eacute;ralement c'est d&eacute;j&agrave; la disposition par d&eacute;faut).</P>

<H2><A NAME="ss5.4">5.4 Comment dire &agrave; emacs ce qu'il doit faire des codes Delete et Backspace</A>
</H2>


<P>Mettez dans votre <CODE>.emacs</CODE> les lignes:
<BLOCKQUOTE><CODE>
<PRE>
  (global-set-key "\?" 'delete-backward-char)
  (global-set-key "\C-h" 'help-command)
</PRE>
</CODE></BLOCKQUOTE>

Bien s&ucirc;r, vous pouvez associer d'autres commandes &agrave; d'autres touches
de la m&ecirc;me mani&egrave;re.</P>

<H2><A NAME="ss5.5">5.5 Comment dire &agrave; emacs de permuter Delete et Backspace</A>
</H2>


<P>Mettez dans votre <CODE>.emacs</CODE> les lignes:
<BLOCKQUOTE><CODE>
<PRE>
  (setq keyboard-translate-table (make-string 128 0))
  (let ((i 0))
  (while (&lt; i 128)
      (aset keyboard-translate-table i i)
      (setq i (1+ i))))
  (aset keyboard-translate-table ?\b ?\^?)
  (aset keyboard-translate-table ?\^? ?\b)
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H2><A NAME="ss5.6">5.6 Comment dire &agrave; kermit d'&eacute;changer Delete et Backspace</A>
</H2>


<P>Mettez dans votre <CODE>.kermrc</CODE> les lignes:
<BLOCKQUOTE><CODE>
<PRE>
  set key \127 \8
  set key \8 \127
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H2><A NAME="ss5.7">5.7 Comment r&eacute;gler xterm selon vos modes de terminal pr&eacute;f&eacute;r&eacute;s</A>
</H2>


<P>Normalement xterm h&eacute;rite des modes de terminal du processus qui l'appelle.
Pour <CODE>xdm</CODE>, les caract&egrave;res erase et kill sont <CODE>#</CODE> et <CODE>@</CODE>,
comme sur les bons vieux Unix Version 6.
Si &ccedil;a ne vous pla&icirc;t pas, vous pouvez mettre
<BLOCKQUOTE><CODE>
<PRE>
  XTerm*ttymodes: erase ^? kill ^U intr ^C quit ^\ eof ^D susp ^Z start ^Q stop ^S eol ^@
</PRE>
</CODE></BLOCKQUOTE>

dans <CODE>/usr/lib/X11/app-defaults/XTerm</CODE> ou dans
<CODE>$HOME/.Xresources</CODE>, &agrave; condition d'ex&eacute;cuter la commande
<BLOCKQUOTE><CODE>
<PRE>
  xrdb $HOME/.Xresources
</PRE>
</CODE></BLOCKQUOTE>

dans votre <CODE>$HOME/.xinitrc</CODE>.</P>

<H2><A NAME="ss5.8">5.8 Comment dire &agrave; xmosaic que la touche Backspace g&eacute;n&egrave;re une DEL</A>
</H2>


<P>Mettre
<BLOCKQUOTE><CODE>
<PRE>
  *XmText.translations: #override\n\
         &lt;Key>osfDelete: delete-previous-character()
  *XmTextField.translations: #override\n\
          &lt;Key>osfDelete: delete-previous-character()
</PRE>
</CODE></BLOCKQUOTE>

dans votre <CODE>$HOME/.Xresources</CODE> devrait faire l'affaire.</P>
<P>Cependant, la FAQ de netscape dit:
<PRE>
        Pourquoi ma touche Backspace ne marche pas dans les boites texte ?
        Par d&eacute;faut, Linux et XFree86 ont leur touches Backspace et Delete
        mal configur&eacute;es. Tous les programmes Motif (y compris Netscape
        Navigator) auront les m&ecirc;mes probl&egrave;mes.

        Les sp&eacute;cifications Motif disent que Backspace doit effacer le
        caract&egrave;re pr&eacute;c&eacute;dent et Delete le caract&egrave;re suivant. Par d&eacute;faut sous
        Linux et XFree86 Backspace et Delete g&eacute;n&egrave;rent le code DEL.

        Le probl&egrave;me peut &ecirc;tre r&eacute;solu en utilisant un programme tel que 
        xmodmap, xkeycaps, ou loadkeys pour que la touche Backspace
        g&eacute;n&egrave;re le code BackSpace au lieu de Delete.

        Une autre solution consiste &agrave; avoir un fichier .motifbind;
        voir la page de manuel de VirtualBindings(3).

        Note: n'utilisez pas les ressources *XmText.translations ou
        *XmTextField.translations pour essayer de r&eacute;soudre ce probl&egrave;me.
        Si vous le faites, vous annulez toutes les autres programmations
        de touches dans les boites textes de Netscape Navigator.
</PRE>
</P>

<H2><A NAME="ss5.9">5.9 Et les fichier termcap et terminfo?</A>
</H2>


<P>Les gens qui ont des probl&egrave;mes avec backspace ont tendance &agrave; aller
voir dans leur fichier termcap (ou terminfo), et effectivement la
ressource <CODE>kb</CODE> (ou <CODE>kbs</CODE>) d&eacute;crit le code g&eacute;n&eacute;r&eacute; par la touche
Backspace. Cependant peu de programmes utilisent ces bases de donn&eacute;es
pour rechercher le code envoy&eacute; par backspace, donc,
&agrave; moins de n'avoir des probl&egrave;mes qu'avec certains programmes, il faut
en g&eacute;n&eacute;ral chercher ailleurs.
Cela dit, il vaut mieux de toute fa&ccedil;on avoir un termcap (ou terminfo)
correct. Voir aussi "La variable TERM" plus loin.</P>

<H2><A NAME="s6">6. Les tables de caract&egrave;res de la console</A></H2>


<P>Le noyau a quatre tables de conversion des octets en symboles &eacute;cran:
a) Latin1 -&gt; PC,  b) VT100 graphique -&gt; PC,
c) PC -&gt; PC, d) utilisateur.</P>
<P>Il y a deux tables de caract&egrave;res, appel&eacute;es G0 et G1, dont l'une est la
table courante. (Initialement G0.)
Taper ^N fait passer &agrave; la table G1, ^O &agrave; la table G0.</P>
<P>Ces variables G0 et G1 pointent sur des tables de conversion et
peuvent &ecirc;tres chang&eacute;es par l'utilisateur. Initialement, elles pointent
respectivement sur les tables a) et b).
Les s&eacute;quences ESC ( B , ESC ( 0 , ESC ( U et ESC ( K font
respectivement pointer G0 sur les tables de conversion a), b), c) et d).
Les s&eacute;quences ESC ) B , ESC ) 0 , ESC ) U et ESC ) K font
respectivement pointer G0 sur les tables de conversion a), b), c) et d).</P>
<P>La s&eacute;quence ESC c provoque une r&eacute;initialisation compl&egrave;te du terminal,
ce qui peut &ecirc;tre n&eacute;cessaire si l'&eacute;cran est tout brouill&eacute;. La commande
<CODE>echo ^V^O</CODE>, souvent conseill&eacute;e, ne fera que rappeler la table G0,
mais rien ne garantit que G0 pointe sur la table a).
Certaines distributions ont un programme reset(1) qui fait juste un 
<CODE>echo ^[c</CODE>.
Si votre termcap pour la console est correcte (et a une entr&eacute;e
<CODE>:rs=\Ec:</CODE>), alors vous pouvez utiliser <CODE>setterm -reset</CODE>.</P>
<P>La table de conversion d) peut &ecirc;tre d&eacute;finie par mapscrn(8).
Le r&eacute;sultat est que si un symbole c est affich&eacute;, c'est le
symbole <CODE>s = map[c]</CODE> qui est mis dans la m&eacute;moire vid&eacute;o.
L'image du caract&egrave;re <CODE>s</CODE> se trouve dans la m&eacute;moire de la carte
vid&eacute;o et peut &ecirc;tre modifi&eacute;e avec setfont(8).</P>

<H2><A NAME="s7">7. Changer de console</A></H2>


<P>Par d&eacute;faut, le changement de console se fait par Alt-Fn ou Ctrl-Alt-Fn.
Sous <CODE>X</CODE> (ou les versions r&eacute;centes de <CODE>dosemu</CODE>), seule la
combinaison Ctrl-Alt-Fn marche.</P>
<P>XFree86 1.3 ne sait pas que la touche Alt est enfonc&eacute;e quand on
rappelle la fen&ecirc;tre X. Il faut donc rel&acirc;cher Alt avant de pouvoir
rechanger de console.
Pourtant, &ccedil;a pourrait marcher: le noyau m&eacute;morise toujours l'&eacute;tat
appuy&eacute;/rel&acirc;ch&eacute; des touches. (Autant que faire se peut: certains
clavier n'&eacute;mettent pas de scancode quand on appuie dessus (ex: les
touches PFn d'un FOCUS 9000) ou quand on les rel&acirc;che (ex: la touche
Pause de la plupart des claviers).)</P>
<P>XFree86 1.3 sauve les polices charg&eacute;es sur la carte vid&eacute;o quand il est
d&eacute;marr&eacute;, et les restaure lors d'un changement de console. Donc le
r&eacute;sultat d'un <CODE>setfont</CODE> sur une console virtuelle est annul&eacute; par un
aller retour dans la fen&ecirc;tre X.
L'utilisation de <CODE>setfont</CODE> sous X donne des r&eacute;sultats bizarres...</P>
<P>Le changement de console par programme est possible gr&acirc;ce &agrave; la
commande <CODE>chvt</CODE>.</P>

<H2><A NAME="ss7.1">7.1 Changer le nombre de Consoles Virtuelles</A>
</H2>


<P>Cette question est toujours pos&eacute;e de temps en temps, mais la r&eacute;ponse
est: il y en a d&eacute;j&agrave; suffisament.
Depuis la version 1.1.54 du noyau, il y a entre 1 et 63 consoles
virtuelles. Une nouvelle console est cr&eacute;&eacute;e d&egrave;s qu'elle est ouverte.
Elle peut &ecirc;tre supprim&eacute;e avec <CODE>disalloc</CODE> (mais il faut que plus
aucun processus ne lui soit associ&eacute;).</P>
<P>Pour les vieux noyaux, changer la ligne
<BLOCKQUOTE><CODE>
<PRE>
#define NR_CONSOLES     8
</PRE>
</CODE></BLOCKQUOTE>

dans <CODE>include/linux/tty.h</CODE> (ne pas d&eacute;passer 63),
et recompiler. Il est possible que vous ayez &agrave; cr&eacute;er le p&eacute;riph&eacute;rique correspondant
avec <CODE>MAKEDEV</CODE> ou <CODE>mknod tty</CODE>N <CODE>c 4</CODE> N o&ugrave; N est le num&eacute;ro du terminal.
Si vous voulez avoir des <CODE>getty</CODE> sur ces nouvelles consoles,
ajoutez des lignes dans <CODE>/etc/inittab</CODE>.</P>
<P>Quand les consoles sont allou&eacute;es dynamiquement, il est g&eacute;n&eacute;ralement
plus simple de n'avoir qu'un ou deux <CODE>getty</CODE>. D'autres consoles
sont ouvertes par 
<CODE>open -l -s bash</CODE>. Les consoles inutilis&eacute;es (sans processus
associ&eacute;) sont d&eacute;sallou&eacute;es par <CODE>disalloc</CODE>.</P>
<P>Si vous disposez de <CODE>spawn_login</CODE> (inclus dans
<CODE>kbd-0.90.tar.gz</CODE>) et que vous mettez
<BLOCKQUOTE><CODE>
<PRE>
        loadkeys &lt;&lt; EOF
        alt keycode 103 = Spawn_Console
        EOF
        spawn_login &amp;
</PRE>
</CODE></BLOCKQUOTE>

dans <CODE>/etc/rc.local</CODE>, taper Alt-Fl&egrave;cheHaute cr&eacute;era (et
affichera) une nouvelle console avec un <CODE>login</CODE>. Voir aussi
<CODE>open-1.3.tgz</CODE>. </P>
<P>Vous ne pouvez vous loger sous "root" que sur les terminaux list&eacute;s dans
<CODE>/etc/securetty</CODE>.</P>

<H2><A NAME="s8">8. Ctrl-Alt-Del et autres combinaisons sp&eacute;ciales</A></H2>



<H2><A NAME="ss8.1">8.1 Ctrl-Alt-Del (Boot)</A>
</H2>

<P>Quand on appuie sur Ctrl-Alt-Del (ou toute autre combinaison &agrave;
laquelle loadkeys associe le keycode Boot), soit la machine reboote
imm&eacute;diatement (sans sync), soit le signal SIGINT est envoy&eacute; &agrave;
<CODE>init</CODE> (ce qui est le comportement par d&eacute;faut, changeable par
l'appel syst&egrave;me reboot(), voir ctrlaltdel(8)).
Certains <CODE>init</CODE> changent le d&eacute;faut. Ce qui se produit quand
<CODE>init</CODE> re&ccedil;oit SIGINT d&eacute;pend de la version du <CODE>init</CODE> utilis&eacute;e et
est souvent d&eacute;termin&eacute; par le ligne <CODE>pf</CODE> du fichier
<CODE>/etc/inittab</CODE> (on peut dans ce cas lancer n'importe quel programme).
Dans les versions actuelles du noyau Ctrl-AltGr-Del n'est plus assign&eacute;
par d&eacute;faut &agrave; Boot.</P>

<H2><A NAME="ss8.2">8.2 Autres combinaisons</A>
</H2>

<P>Combinaisons par d&eacute;faut avant utilisation de loadkeys, donc en qwerty.
<PRE>
Nom du keycode  Combinaison
-------------------------------
Show_Memory     Shift-Scrollock         
Show_Registers  AltGr-ScrollLock        
Show_State      Ctrl-ScrollLock         
Console_n       Alt-Fn and Ctrl-Alt-Fn  (1 &lt;= n &lt;= 12)
Console_{n+12}  AltGr-Fn                (1 &lt;= n &lt;= 12)
Incr_Console    Alt-Fl&egrave;cheDroite
Decr_Console    Alt-Fl&egrave;cheGauche
Last_Console    Alt[Gr]-ImprEcran
Scroll_Backward Shift-PgPrec
Scroll_Forward  Shift-PgSuiv
Compose         Ctrl-.          (Ctrl-: sur clavier azerty)
Caps_On         &lt;pas d&eacute;fini>  (Par d&eacute;faut CapsLock est un va-et-vient,
Caps_Shift      &lt;pas defini> ces Keycodes servent &agrave; recr&eacute;er le d&eacute;sagr&eacute;able
                                comportement MS-Keyb Fr)
</PRE>
</P>

<H2><A NAME="ss8.3">8.3 Combinaisons sous X</A>
</H2>

<P>
<PRE>
Ctrl-Alt-Fn             Affiche la console virtuelle n
Ctrl-Alt-KP+            R&eacute;solution suivante
Ctrl-Alt-KP-            R&eacute;solution pr&eacute;c&eacute;dente
Ctrl-Alt-Backspace      Tue le serveur X
</PRE>

Sur certaines cartes-m&egrave;res, Ctrl-Alt-KP- et Ctrl-Alt-KP+ &eacute;mulent le
bouton Turbo. Ces s&eacute;quences produisent les scancodes
1d 38 4a ca b8 9d et 1d 38 4e ce b8 9d, et toutes deux changent la vitesse
de Turbo (&gt;= 25MHz) &agrave; non-Turbo (8 or 12 MHz) et vice-versa.
(souvent ce comportement peut &ecirc;tre d&eacute;sactiv&eacute; par un cavalier sur la
carte-m&egrave;re.)</P>
<P>Perry F Nguyen (<CODE>
<A HREF="mailto:pfnguyen@netcom22.netcom.com">pfnguyen@netcom22.netcom.com</A></CODE>) &eacute;crit:
<BLOCKQUOTE>
Les BIOS AMI permettent de bloquer le clavier et de faire clignoter
les LEDs quand on appuie sur Ctrl-Alt-Backspace et qu'un mot de passe
BIOS est d&eacute;fini, et ce jusqu'&agrave; ce que celui-ci soit tap&eacute;.
</BLOCKQUOTE>
</P>

<H2><A NAME="ss8.4">8.4 Combinaisons sous Dosemu</A>
</H2>

<P>
<PRE>
Ctrl-Alt-Fn     Rappelle la console n (versions &gt;0.50; avant Alt-Fn)
Ctrl-Alt-PgDn   Tue dosemu (quand le calvier est en mode RAW)
(et bien d'autres, voir la documentation de dosemu)
</PRE>
</P>

<H2><A NAME="ss8.5">8.5 Composition de symboles</A>
</H2>


<P>Un symbole peut &ecirc;tre construit en utilisant plusieurs frappes.
<UL>
<LI>En mode Ascii, taper un code Ascii en d&eacute;cimal sur le pav&eacute; num&eacute;rique,
tout en maintenant la touche Alt enfonc&eacute;e, produit le caract&egrave;re en
question quand on rel&acirc;che Alt. (En mode Unicode, il faut taper le
code hexad&eacute;cimal &agrave; 4 chiffres du symbole)</LI>
<LI>L'appui sur un accent mort puis sur une lettre produit cette lettre
accentu&eacute;e (si possible, sinon l'accent suivi de la lettre).
Les touche mortes sont d&eacute;finissables par l'utilisateur (gr&acirc;ce &agrave;
loadkeys(1)). Il y a cinq possibilit&eacute;s:
<PRE>
accent                  keycode mort            keycode normal
------------------------------------------------------
accent grave            dead_grave              grave
accent aigu             dead_acute              apostrophe
accent circonflexe      dead_circumflex         asciicircum
tilde                   dead_tilde              asciitilde
tr&eacute;ma                    dead_diaeresis          diaeresis
</PRE>

Par d&eacute;faut aucune touche du clavier n'est morte.
Le r&eacute;sultat est celui de Compose + accent + lettre (et est donc
red&eacute;finissable, cf plus bas).

<BLOCKQUOTE>
NDT: pour des francophones utilisant un clavier Azerty, il vaut
g&eacute;n&eacute;ralement mieux se contenter de d&eacute;finir comme touches mortes
l'accent circonflexe et le tr&eacute;ma de la touche &agrave; droite du `P'. Il est
sinon fastidieux voire parfois impossible (en particulier sous X) de
taper les symboles tilde et apostrophe, bien utiles sous Unix.
Or les tables standard pour clavier Latin-1 activent en g&eacute;n&eacute;ral toutes les
touches mortes possibles. Il faut donc pour ressusciter ces touches,
remplacer le keycode mort par le keycode normal dans la table charg&eacute;e au
d&eacute;marrage par loadkeys. 
</BLOCKQUOTE>

</LI>
<LI>Compose suivi de deux symboles produit une combinaison des deux. Cette
combinaison est red&eacute;finissable. Il y a &agrave; ce jour 68 combinaisons par
d&eacute;faut qui peuvent &ecirc;tre affich&eacute;es par <CODE>dumpkeys | grep compose</CODE>.</LI>
<LI>Depuis la version 1.3.33 du noyau, il est possible d'avoir des touches
"collantes" (plus ou moins comme Escape) gr&acirc;ce aux codes SControl et
SAlt. Par exemple, on peut taper ^C par Scontrol puis C et
Ctrl-Alt-BackSpace  par SControl puis SAlt puis BackSpace.</LI>
</UL>
</P>
<P>Il est &agrave; noter qu'il existe au moins trois m&eacute;canismes de composition
distincts:
<OL>
<LI>Le pilote clavier de Linux, configur&eacute; par loadkeys.</LI>
<LI>Le m&eacute;canisme de X - voir X386keybd(1), ou XFree86kbd(1). <BR>
Sous X11R6 : &eacute;diter <CODE>/usr/X11R6/lib/X11/locale/iso8859-1/Compose</CODE>.</LI>
<LI>Le m&eacute;canisme d'emacs, activ&eacute; en chargeant <CODE>iso-insert.el</CODE>.</LI>
</OL>

Pour X, l'ordre des deux symboles n'a pas d'importance: Compose-,-c et
Compose-c-, donnent tous deux un c-c&eacute;dille; pour Linux et emacs, seule
la premi&egrave;re combinaison est correcte. Les combinaisons de X sont
fixes, celles de Linux et emacs sont reconfigurables.
Les trois listes par d&eacute;faut sont assez similaires, mais il y a
quelques diff&eacute;rences.</P>

<H2><A NAME="s9">9. Diverses propri&eacute;t&eacute;s de la console</A></H2>


<P>Voir loadkeys(1), setleds(1), setmetamode(1) pour les codes g&eacute;n&eacute;r&eacute;s
par les diverses touches et l'utilisation des leds quand on n'est pas
sous X. Sous X, voir xmodmap(1).</P>
<P>Voir setterm(1), kbdrate(8) pour les propri&eacute;t&eacute;s telles que les
couleurs de l'&eacute;criture et du fond, l'&eacute;conomiseur d'&eacute;cran et la vitesse
de r&eacute;p&eacute;tition des touches quand on n'est pas sous X.
Sous X, voir xset(1), qui s'occupe aussi du clic des touches et du
volume des bips.</P>
<P>Le fichier <CODE>/etc/termcap</CODE> d&eacute;finit les s&eacute;quences escape
utilis&eacute;es par de nombreux programmes utilisant la console (ou tout
autre terminal). Une version plus moderne se trouve dans
<CODE>/usr/lib/terminfo</CODE>. (voir terminfo(5). Les fichiers terminfo
sont cr&eacute;&eacute;s par le compilateur terminfo <CODE>/usr/lib/terminfo/tic</CODE>,
voir tic(1).)</P>
<P>(Sur ma machine) <CODE>/dev/console</CODE> est lien symbolique sur
<CODE>/dev/tty0</CODE>, et le noyau consid&egrave;re <CODE>/dev/tty0</CODE> comme un
synonyme de la console virtuelle courante.
XFree86 1.3 change le propri&eacute;taire de <CODE>/dev/tty0</CODE>, mais ne le
restaure qu'&agrave; la sortie. Or dumpkeys risque de ne pas marcher si quelqu'un
d'autre est propri&eacute;taire de <CODE>/dev/console</CODE>; dans ce cas, lancer
X et en sortir peut arranger les choses.</P>

<H2><A NAME="s10">10. Comment sortir du mode RAW</A></H2>


<P>Si un programme utilisant le mode <CODE>K_RAW</CODE> du clavier se termine sans
remettre le calvier en mode <CODE>K_XLATE</CODE>, alors il est tr&egrave;s difficile de
faire quoi que ce soit - m&ecirc;me  Ctrl-Alt-Del. Cependant il est parfois
possible d'&eacute;viter d'appuyer sur Reset (et m&ecirc;me souhaitable: vos
utilisateurs risquent de ne pas appr&eacute;cier qu'on leur tue leur Nethack,
et surtout il est possible d'endommager le syst&egrave;me de fichiers).
Les solutions simples consistent &agrave; se loger &agrave; partir d'un autre
terminal ou une autre machine et faire <CODE>kbd_mode -a</CODE>.
La proc&eacute;dure suivante suppose que X ne tourne pas, que l'&eacute;cran est en
mode texte, que vous &ecirc;tes &agrave; un prompt shell, que Ctrl-C est le
caract&egrave;re d'interruption et que vous n'avez pas un clavier trop
exotique (i.e. la touche `=' est 2 touches &agrave; droite de `0').</P>
<P>1&egrave;re &eacute;tape: Lancer X.
Appuyez sur la combinaison 2-F12-= : appuyez sur 2 puis F12 (sans
l&acirc;cher 2) et puis = (sans l&acirc;cher les deux autres), le tout assez
rapidement! &Ccedil;a lance X.
(Explication: si l'appui sur une touche produit le keycode K, alors
son rel&acirc;chement produit K+128. Votre shell risque de na pas appr&eacute;cier
ces caract&egrave;res, donc on &eacute;vite de les lui envoyer en ne l&acirc;chant pas les
touches. `2' produit un ^C qui annule tout ce qui a &eacute;t&eacute; tap&eacute;
avant. F12 produit un X et `=' le code entr&eacute;e. Et tout &ccedil;a vite fait
avant que la r&eacute;p&eacute;tition des touches ne commence...)</P>
<P>Votre &eacute;cran est alors probablement gris, puisqu'aucun <CODE>.xinitrc</CODE>
n'a &eacute;t&eacute; sp&eacute;cifi&eacute;. Cependant Ctrl-Alt-Fn marche, et vous pouvez appeler
une autre console. (Ctrl-Alt-Backspace marche aussi, mais &ccedil;a restaure
l'&eacute;tat initial du clavier qui justement n'est pas bon.)</P>
<P>2&egrave;me &eacute;tape: Programmer le changement de mode du clavier.
(Par exemple, avec <CODE>sleep 5; kbd_mode -a</CODE>.)</P>
<P>3&egrave;me &eacute;tape: Quitter X.
Alt-Fx (souvent Alt-F7) retourne sous X, ensuite Ctrl-Alt-Backspace
tue X. Dans les 5 secondes le clavier redevient utilisable.</P>
<P>Si vous voulez vous pr&eacute;parer pour cette occasion, faites de
<CODE>\215A\301</CODE> (3 symboles) un alias de <CODE>kbd_mode -a</CODE>.
D&eacute;sormais, l'appui sur F7 en mode RAW remettra tout en ordre.</P>

<H2><A NAME="s11">11. La variable TERM </A></H2>


<P>De nombreux programmes utilisent la variable <CODE>TERM</CODE> et la base de
donn&eacute;es <CODE>/etc/termcap</CODE> ou <CODE>/usr/lib/terminfo/*</CODE> pour
trouver quelle cha&icirc;ne de commande efface l'&eacute;cran, d&eacute;place le curseur,
etc., et parfois pour savoir quelle cha&icirc;ne est envoy&eacute;e par la touche
backspace, ou les touches de fonction, etc. Cette variable est d'abord
d&eacute;finie par le noyau (pour la console). G&eacute;n&eacute;ralement elle est
red&eacute;finie par <CODE>getty</CODE>, en utilisant <CODE>/etc/ttytype</CODE> ou
l'argument sp&eacute;cifi&eacute; dans <CODE>/etc/inittab</CODE>.
Parfois elle est encore chang&eacute;e par <CODE>/etc/profile</CODE>.</P>
<P>Les anciens syst&egrave;mes utilisent <CODE>TERM=console</CODE> ou
<CODE>TERM=con80x25</CODE>. Les plus r&eacute;cents (avec ncurses 1.8.6) utilisent la
valeur plus sp&eacute;cifique <CODE>TERM=linux</CODE> ou <CODE>TERM=linux-80x25</CODE>.
Cependant, les vieilles versions de <CODE>setterm</CODE> cherchent une valeur
du type <CODE>TERM=con*</CODE> et ne marchent donc pas avec <CODE>TERM=linux</CODE>.</P>
<P>Depuis la version 1.3.2 du noyau, la valeur par d&eacute;faut est <CODE>TERM=linux</CODE>.</P>
<P>Si votre termcap n'a pas d'entr&eacute;e `linux', il suffit d'ajouter l'alias
linux dans la description de `console':
<BLOCKQUOTE><CODE>
<PRE>
        console|con80x25|linux:\
</PRE>
</CODE></BLOCKQUOTE>

et de copier (ou faire un lien symbolique)
<CODE>/usr/lib/terminfo/c/console</CODE> en <CODE>/usr/lib/terminfo/l/linux</CODE>.</P>


<H2><A NAME="ss11.1">11.1 Terminfo</A>
</H2>


<P>Il manque, dans le fichier terminfo de la console linux fourni avec
ncurses 1.8.6, la ligne:
<CODE>kich1=\E[2~</CODE>, n&eacute;cessaire &agrave; certains programmes.
Editez ce fichier et compilez-le avec <CODE>tic</CODE>.</P>

<H2><A NAME="s12">12. Comment faire pour que d'autres programmes acceptent les caract&egrave;res non-ASCII</A></H2>


<P>C'&eacute;tait jadis un v&eacute;ritable calvaire. Il fallait convaincre
individuellement chaque programme de travailler en 8 bits.
Les choses ne sont pas encore id&eacute;ales, mais r&eacute;cemment de nombreux
utilitaires GNU ont appris &agrave; reconna&icirc;tre les variables
<CODE>LC_CTYPE=iso_8859_1</CODE> ou <CODE>LC_CTYPE=iso-8859-1</CODE>.
Essayez d'abord &ccedil;a, et si &ccedil;a ne suffit pas essayez les trucs ci-dessous.</P>

<P>Tout d'abord, le huiti&egrave;me bit doit survivre au processus d'entr&eacute;e du
noyau, assurez-vous-en donc avec <CODE>stty cs8 -istrip -parenb</CODE>.</P>
<P>A. Pour <CODE>emacs</CODE>, mettez les lignes
<BLOCKQUOTE><CODE>
<PRE>
        (standard-display-european t)
        (set-input-mode nil nil 1)
        (require 'iso-syntax)
</PRE>
</CODE></BLOCKQUOTE>

et peut-&ecirc;tre aussi
<BLOCKQUOTE><CODE>
<PRE>
        (load-library "iso-insert.el")
        (define-key global-map [?\C-.] 8859-1-map)
</PRE>
</CODE></BLOCKQUOTE>

dans votre <CODE>$HOME/.emacs</CODE>.
(Cette derni&egrave;re ligne marche dans un <CODE>xterm</CODE>, en utilisant <CODE>emacs -nw</CODE>,
mais il faut alors mettre
<BLOCKQUOTE><CODE>
<PRE>
        XTerm*VT100.Translations:       #override\n\
        Ctrl &lt;KeyPress> . : string("\0308")
</PRE>
</CODE></BLOCKQUOTE>
 
dans votre <CODE>.Xresources</CODE>.)
NDT: fichiers pour clavier Qwerty, &agrave; v&eacute;rifier pour azerty.</P>
<P>B. Pour <CODE>less</CODE>, mettez <CODE>LESSCHARSET=latin1</CODE> dans l'environment.</P>
<P>C. Pour <CODE>ls</CODE>, mettez l'option <CODE>-N</CODE>. (A priori en faisant un alias.)</P>
<P>D. Pour <CODE>bash</CODE> (version 1.13.*), mettez
<BLOCKQUOTE><CODE>
<PRE>
        set meta-flag on
        set convert-meta off
</PRE>
</CODE></BLOCKQUOTE>

et, selon le Danish-HOWTO,
<BLOCKQUOTE><CODE>
<PRE>
        set output-meta on
</PRE>
</CODE></BLOCKQUOTE>

dans votre <CODE>$HOME/.inputrc</CODE>.</P>
<P>E. Pour <CODE>tcsh</CODE>, d&eacute;finissez les variables:
<BLOCKQUOTE><CODE>
<PRE>
        setenv LANG     fr_FR   (ou fr_CA, fr_CH, fr_BE...)
        setenv LC_CTYPE iso_8859_1
</PRE>
</CODE></BLOCKQUOTE>

Si <CODE>nls</CODE> est install&eacute;, les routines correspondantes sont utilis&eacute;es.
Sinon <CODE>tcsh</CODE> agit en iso_8859_1, quelle que soit les valeurs donn&eacute;es &agrave; 
LANG et LC_CTYPE. voir la section NATIVE LANGUAGE SYSTEM de tcsh(1).
(d'apr&egrave;s le Danish-HOWTO: <CODE>setenv LC_CTYPE ISO-8859-1; stty pass8</CODE>)</P>
<P>F. Pour <CODE>flex</CODE>, donnez l'option <CODE>-8</CODE> si l'analyseur g&eacute;n&eacute;r&eacute; doit
accepter les entr&eacute;es 8-bits. (Bien sur qu'il doit le faire !)</P>
<P>G. Pour <CODE>elm</CODE>, mettez <CODE>displaycharset</CODE> &agrave; <CODE>ISO-8859-1</CODE>.
(Danish HOWTO: <CODE>LANG=C</CODE> et <CODE>LC_CTYPE=ISO-8859-1</CODE>)</P>
<P>H. Pour les programmes utilisant curses (comme <CODE>lynx</CODE>) David Sibley dit:
<BLOCKQUOTE>
La version standard de curses utilise le huiti&egrave;me bit pour la vid&eacute;o
invers&eacute;e (voir le flag _STANDOUT d&eacute;fini dans
<CODE>/usr/include/curses.h</CODE>).  Cependant <CODE>ncurses</CODE> semble
fonctionner en 8-bits et affiche le iso-latin-8859-1 correctement.
</BLOCKQUOTE>
</P>
<P>I. Pour les programmes utilisant <CODE>groff</CODE> (comme <CODE>man</CODE>), utilisez
le <CODE>-Tlatin1</CODE> au lieu de <CODE>-Tascii</CODE>. Les vieilles versions de <CODE>man</CODE>
utilisent aussi <CODE>col</CODE>, et le point suivant s'applique aussi.</P>
<P>J. Pout <CODE>col</CODE>, assurez-vous 1) qu'il a &eacute;t&eacute; corrig&eacute; et fait un
<CODE>setlocale(LC_CTYPE,"");</CODE> et 2) de d&eacute;finir
<CODE>LC_CTYPE=ISO-8859-1</CODE> dans l'environment.</P>
<P>K. Pour <CODE>rlogin</CODE>, utilisez l'option <CODE>-8</CODE>.</P>
<P>L. Pour <CODE>joe</CODE>,
<CODE>sunsite.unc.edu:/pub/Linux/apps/editors/joe-1.0.8-linux.tar.gz</CODE>
devrait marcher apr&egrave;s &eacute;dition du fichier de configuration. J'ai aussi lu:
<CODE>joe</CODE>: mettez l'option <CODE>-asis</CODE> dans <CODE>/usr/lib/joerc</CODE> en
premi&egrave;re colonne.</P>
<P>M. Pour LaTeX: <CODE>\documentstyle[isolatin]{article}</CODE>.<BR>
Pour LaTeX2e: <CODE>\documentclass{article}\usepackage{isolatin}</CODE>
ou <CODE>isolatin.sty</CODE> est disponible &agrave; 
<CODE>
<A HREF="ftp://ftp.vlsivie.tuwien.ac.at/pub/8bit">ftp://ftp.vlsivie.tuwien.ac.at/pub/8bit</A></CODE>.</P>
<P>Une belle discussion sur le th&egrave;me de l'ISO-8859-1 et sur comment
manipuler les caract&egrave;res 8-bits est disponible dans
<CODE>
<A HREF="ftp://grasp.insa-lyon.fr/pub/faq/fr/accents">ftp://grasp.insa-lyon.fr/pub/faq/fr/accents</A></CODE> (en fran&ccedil;ais).
Une autre, en anglais, peut &ecirc;tre trouv&eacute;e &agrave;
<CODE>
<A HREF="ftp://rtfm.mit.edu/pub/usenet-by-group/comp.answers/character-sets/iso-8859-1-faq">ftp://rtfm.mit.edu/pub/usenet-by-group/comp.answers/character-sets/iso-8859-1-faq</A></CODE>.
Encore une autre(?):<CODE>
<A HREF="ftp://ftp.vlsivie.tuwien.ac.at/pub/8bit/FAQ-ISO-8859-1">ftp://ftp.vlsivie.tuwien.ac.at/pub/8bit/FAQ-ISO-8859-1</A></CODE>.</P>

<H2><A NAME="s13">13. Que fait exactement XFree86-2.1 &agrave; l'initialisation de sa keymap?</A></H2>

<P> </P>
<P>Depuis la version 2.1, XFree86 initialise sa keymap d'apr&egrave;s celle de
Linux, dans les limites du possible. Linux a 16 entr&eacute;es par touches
(une pour chaque combinaison de Shift, AltGr, Ctrl, Alt; en fait il en
a m&ecirc;me 256), alors que X n'en a que 4 (une pour chaque combinaison de
Shift et Mod), il y a donc forc&eacute;ment des informations perdues.</P>
<P>D'abord <CODE>X</CODE> lit le fichier <CODE>Xconfig</CODE>, o&ugrave; il trouve les
correspondances entre les touches Control, Alt et ScrollLock avec les
codes X Meta, ModeShift, Compose, ModeLock et ScrollLock - voir
X386keybd(1), ou XFree86kbd(1).</P>
<P>Par d&eacute;faut, c'est la colonne LeftAlt qui sert pour Mod, sauf si
CtlDroit est d&eacute;fini comme ModeShift ou ModeLock, dans ce cas ce sont
les entr&eacute;es RightCtl qui servent pour Mod. (Sauf si AltGr est d&eacute;fini
comme Mod dans Xconfig, auquel cas c'est la colonne RightAlt qui sert.)
Ceci d&eacute;termine comment les 4 entr&eacute;es de XFree86 sont choisies parmi
les 16 de Linux. Notons que par d&eacute;faut Linux ne fait pas la diff&eacute;rence
entre les deux touche Control ou Shift. <CODE>X</CODE> fait la duff&eacute;rence.</P>
<P>Les touches "action" Show_Memory, Show_State,
Show_Registers, Last_Console, Console_n, Scroll_Backward, Scroll_Forward,
Caps_On et Boot sont ignor&eacute;es, de m&ecirc;me pour les touches mortes,
NumLock, ScrollLock et Alt+code-ASCII.</P>
<P>Ensuite, les d&eacute;finitions de <CODE>Xconfig</CODE> sont utilis&eacute;es. (Donc une
d&eacute;finition de Compose dans <CODE>Xconfig</CODE> annulera celle trouv&eacute;e dans la
keymap du noyau.)</P>
<P>Que deviennent les cha&icirc;nes associ&eacute;es aux touches des fonctions ? Rien,
ce concept n'existe pas sous X. (Mais il est possible de d&eacute;finir des
cha&icirc;nes associ&eacute;es aux touches de fonction dans <CODE>xterm</CODE> - mais elles
ne doivent pas &ecirc;tre intercept&eacute;es par le gestionnaire de fen&ecirc;tres.)</P>
<P>Je ne sais pas comment convaincre <CODE>xterm</CODE> qu'il devrait utiliser la
keymap de X quand Alt est enfonc&eacute;. Il semble qu'il ne r&eacute;agisse qu'en
fonction de sa ressource <CODE>eightBitInput</CODE>, et selon qu'elle est &agrave;
vrai ou faux, soit il met &agrave; 1 le huiti&egrave;me bit, soit il g&eacute;n&egrave;re un
caract&egrave;re escape devant le caract&egrave;re (comme le fait setmetamode(1)
pour la console).</P>

<H2><A NAME="s14">14. Touches et claviers particuliers</A></H2>


<P>Les deux touches ImprEcran/Syst et Pause/Attn sont sp&eacute;ciales car elles
ont deux keycodes: la premi&egrave;re produit le keycode 84 quand Alt est
enfonc&eacute; et 99 sinon; la seconde 101 si Ctrl est enfonc&eacute;, 119 sinon.
(Il est donc inutile d'assigner des fonctions &agrave; Alt-Keycode99 ou
Ctrl-Keycode119.)</P>
<P>Si votre clavier a des touches &eacute;tranges qui ne g&eacute;n&egrave;rent aucun code
sous Linux (ou g&eacute;n&egrave;rent des messages du genre "unrecognized
scancode"), vous pouvez, &agrave; partir du noyau 1.1.63, utiliser
setkeycodes(1) pour dire au noyau quel keycode assigner &agrave; ces
touches. (Leur utilisation sous X sera cependant impossible.)
Une fois qu'elles ont un keycode gr&acirc;ce &agrave; <CODE>setkeycodes</CODE>, on peut
leur associer une fonction avec <CODE>loadkeys</CODE>.</P>

<H2><A NAME="s15">15. Exemples d'utilisation de loadkeys and xmodmap</A></H2>


<P>Permuter ScrollLock et Control (en suposant que vous utilisez les
keymaps 0-15; v&eacute;rifiez avec <CODE>dumpkeys | head -1</CODE>)
<BLOCKQUOTE><CODE>
<PRE>
  % loadkeys
  keymaps 0-15
  keycode 58 = Control
  keycode 29 = Caps_Lock
  %
</PRE>
</CODE></BLOCKQUOTE>

Les permuter sous X seulement:
<BLOCKQUOTE><CODE>
<PRE>
  % xmodmap .xmodmaprc
</PRE>
</CODE></BLOCKQUOTE>

o&ugrave; <CODE>.xmodmaprc</CODE> contient les lignes
<BLOCKQUOTE><CODE>
<PRE>
  remove Lock = Caps_Lock
  remove Control =  Control_L
  keysym  Control_L  =  Caps_Lock
  keysym  Caps_Lock  = Control_L
  add Lock = Caps_Lock
  add Control = Control_L
</PRE>
</CODE></BLOCKQUOTE>

Qu'en est-il de la num&eacute;rotation des touches? Backspace a le num&eacute;ro 14
sous Linux et 22 sous X... En fait, la num&eacute;rotation est plus ou moins
arbitraire. Le num&eacute;ro sous Linux peut &ecirc;tre visualis&eacute; avec showkey(1), et le
num&eacute;ro sous X avec xev(1). Souvent le num&eacute;ro sous X est 8 de plus que
le num&eacute;ro sous Linux.</P>

<H2><A NAME="ss15.1">15.1 `Je ne peux taper qu'avec un seul doigt'</A>
</H2>


<P>Les touches Shift, Ctrl et Alt peuvent-elles &ecirc;tre des commutateurs
stables ?
Oui, en faisant:
<BLOCKQUOTE><CODE>
<PRE>
% loadkeys
keycode 29 = Control_Lock
keycode 42 = Shift_Lock
keycode 56 = Alt_Lock
%
</PRE>
</CODE></BLOCKQUOTE>

les Control, Shift et Alt de gauche deviennent stables.
Les num&eacute;ros &agrave; utiliser sont donn&eacute;s par showkey
(et sont g&eacute;n&eacute;ralement 29 et 97 (Control), 42 et 54 (Shift), 56 et 100 (Alt))
et les fonctions possibles sont Control_Lock, Shift_Lock, Alt_Lock,
ALtGr_Lock. </P>
<P>Et le touches `collantes'?
Il n'y a pas encore eu de nouvelle version du paquetage kbd depuis
leur introduction dans le noyau 1.3.33, il faut donc utiliser leurs
codes hexa, par example:
<BLOCKQUOTE><CODE>
<PRE>
% loadkeys
keymaps 0-15
keycode 54 = 0x0c00
keycode 97 = 0x0c02
keycode 100 = 0x0c03
%
</PRE>
</CODE></BLOCKQUOTE>

rend les Shift, Ctrl et Alt de droite collantes.</P>

<H2><A NAME="s16">16. Changer le mode vid&eacute;o</A></H2>


<P>Pour autant que je sache, il y a 6 mani&egrave;res de changer de mode r&eacute;solution:</P>
<P>1. A la compilation: changer la ligne
<BLOCKQUOTE><CODE>
<PRE>
        SVGA_MODE=      -DSVGA_MODE=NORMAL_VGA
</PRE>
</CODE></BLOCKQUOTE>

dans <CODE>/usr/src/linux/Makefile</CODE>.</P>
<P>1A. Apr&egrave;s la compilation: utiliser <CODE>rdev -v</CODE> - une affreuse
magouille, mais bon, &ccedil;a marche.</P>
<P>2. Au d&eacute;marrage: mettre <CODE>vga=ask</CODE> dans le fichier de config de
lilo, qui demandera au boot le mode voulu. Une fois d&eacute;cid&eacute;, remplacer
par <CODE>vga=</CODE>LePlusJoliMode.</P>
<P>3. En cours de route:
A. Utiliser la commande <CODE>resizecons</CODE>. (C'est un programme tr&egrave;s
primitif utilisant l'ioctl VT_RESIZE.)
B. Utiliser <CODE>SVGATextMode</CODE>. (C'est une version moins primitive)</P>
<P>4. Pas "sur la console":
Sous <CODE>dosemu</CODE>, ou avec svgalib etc. on peut changer le mode vid&eacute;o
de la carte &eacute;cran sans que le pilote de la console s'en
aper&ccedil;oive. C'est parfois utile pour configurer <CODE>resizecons</CODE> ou
<CODE>SVGATextMode</CODE>:sous <CODE>dosemu</CODE> se mettre dans le mode vid&eacute;o voulu
gr&acirc;ce &agrave; un programme DOS utilisant ce mode, puis dans une autre
console, r&eacute;cup&eacute;rer les param&egrave;tres de ce mode. Il ne reste plus qu'&agrave;
utiliser ces donn&eacute;es pour l'initialisation de <CODE>resizecons</CODE> et
<CODE>SVGATextMode</CODE>. Dans certains cas la carte vid&eacute;o se retrouve dans
un mode inutilisable, le moyen le plus simple pour se sortir de l&agrave; est
de lancer <CODE>dosemu</CODE>, laisser le BIOS mettre un mode vid&eacute;o correct,
puis tuer <CODE>dosemu</CODE> (avec <CODE>kill -9</CODE>).</P>

<H2><A NAME="ss16.1">16.1 Instructions pour l'utilisation de resizecons</A>
</H2>


<P>R&eacute;cup&eacute;rer svgalib et compiler le programme <CODE>restoretextmode</CODE>.
Booter la machine dans tous les modes vid&eacute;o possibles
(en mettant <CODE>vga=ask</CODE> dans le fichier config de lilo), et
sauvegarder les registres vid&eacute;o dans des fichiers CxL
(C=Colonnes, L=Lignes), par exemple 80x25, 132x44, etc.
Placer ces fichiers dans <CODE>/usr/lib/kbd/videomodes</CODE>.
D&eacute;sormais <CODE>resizecons 132x44</CODE> changera le mode vid&eacute;o
(et enverra le signal SIGWINCH &agrave; tous les processus qui ont besoin de
savoir que la r&eacute;solution a chang&eacute;, et chargera une nouvelle police si
n&eacute;cessaire). </P>
<P>A pr&eacute;sent, <CODE>resizecons</CODE> ne change de mode que s'il y a assez de
m&eacute;moire pour contenir &agrave; la fois l'ancienne et la nouvelle console.</P>

<H2><A NAME="s17">17. Changer la vitesse de r&eacute;p&eacute;tition du clavier</A></H2>


<P>Au d&eacute;marrage, le noyau met la vitesse de r&eacute;p&eacute;tition &agrave; sa valeur
maximale. Pour la plupart des claviers c'est raisonnable, mais sur
certains il devient quasiment impossible d'effleurer une touche sans
avoir trois fois le m&ecirc;me caract&egrave;re. Dans ce cas utiliser le programme
kbdrate(8) pour changer la vitesse de r&eacute;p&eacute;tition ou si &ccedil;a ne suffit pas
supprimer la section:
<HR>
<PRE>
     ! set the keyboard repeat rate to the max

         mov     ax,#0x0305
         xor     bx,bx           ! clear bx
         int     0x16
</PRE>
<HR>

de <CODE>/usr/src/linux/[arch/i386/]boot/setup.S</CODE>.</P>

<H2><A NAME="s18">18. Economiseur d'&eacute;cran</A></H2>


<P><CODE>setterm -blank</CODE> <I>nn</I> r&egrave;gle le d&eacute;lai d'extinction de l'&eacute;cran
&agrave;  <I>nn</I> minutes d'inactivit&eacute;. (Avec <I>nn</I> = 0, l'&eacute;conomiseur
d'&eacute;cran est d&eacute;sactiv&eacute;.)</P>
<P>L'option <CODE>s</CODE> de xset(1) r&egrave;gle les param&egrave;tres de l'&eacute;conomiseur
d'&eacute;cran de X.</P>
<P>Les modes d'&eacute;conomie d'&eacute;nergie du moniteur peuvent &ecirc;tre
activ&eacute;s/d&eacute;sactiv&eacute;s par le programme <CODE>setvesablank</CODE> donn&eacute; dans les
commentaires au d&eacute;but du fichier
<CODE>/usr/src/linux/drivers/char/vesa_blank.c</CODE>.</P>

<H2><A NAME="s19">19. Quelques propri&eacute;t&eacute;s du VT100 - mode application</A></H2>


<P>: Parfois les touches de curseur produisent des codes bizarres?</P>
<P>Quand le terminal est en <CODE>mode application</CODE>, les touches de curseur
produisent les codes Esc O x et sinon Esc [ x, avec x = A,B,C ou D.
Certains programmes mettent le termnial en mode application et si
on les tue avec un <CODE>kill -9</CODE>, ou s'il se plantent, le terminal
restera dans ce mode.
<PRE>
        % echo -e '\033c'  
</PRE>

r&eacute;initialise les propri&eacute;t&eacute;s du terminal courant. 
Si on veut passer en mode application:
<PRE>
        % echo -e '\033[?1h' 
</PRE>

et si on veut en sortir:
<PRE>
        % echo -e '\033[?1l' 
</PRE>
</P>

<H2><A NAME="s20">20. Incompatibilit&eacute; mat&eacute;rielle</A></H2>


<P>Quelques personnes ont not&eacute; des pertes de caract&egrave;res tap&eacute;s lors
d'un acc&egrave;s disquette. Il semblerait que ce soit un probl&egrave;me avec les
cartes m&egrave;res Uni-486WB. (SVP envoyez moi un mail pour confirmer
[Oui, j'ai le m&ecirc;me probl&egrave;me], infirmer
[Non, tout va bien avec ma carte Uni-486WB], ou modifier
[Ma machine Xyzzy a le m&ecirc;me probl&egrave;me].)</P>
<P>Certaines personnes ont eu des blocages al&eacute;atoires du clavier -
parfois associ&eacute;s &agrave; une activit&eacute; disque dur ou une autre entr&eacute;e/sortie.</P>
<P>
<A HREF="mailto:ulf@rio70.bln.sni.de">ulf@rio70.bln.sni.de</A>
(Ulf Tietz) &eacute;crit:
<BLOCKQUOTE>
`J'avais ce genre de probl&egrave;mes quand ma carte m&egrave;re avait des r&eacute;glages
trop rapides. En remettant les d&eacute;lais (CLK, wait-states, etc.) &agrave; des
valeurs plus raisonnables, tout est rentr&eacute; dans l'ordre.'
</BLOCKQUOTE>
</P>
<P>
<A HREF="mailto:bhogan@crl.com">bhogan@crl.com</A> (Bill Hogan) &eacute;crit:
<BLOCKQUOTE>
`Si vous avez un BIOS AMI, vous pouvez essayer de mettre le param&egrave;tre
Gate A20 emulation sur 'chipset' (si cette option existe). Quand cette
option &eacute;tait sur n'importe quoi d'autre ('fast', 'both', 'disabled')
j'avais souvent des blocages du clavier.'
</BLOCKQUOTE>

--------------------------------------------------------------------</P>
<P>Additions et corrections sont les bienvenues.</P>
<P>Andries Brouwer - 
<A HREF="mailto:aeb@cwi.nl">aeb@cwi.nl</A></P>
<P>(Bruno Viaris - Viaris@Yoko.ENS-Cachan.Fr pour la traduction)</P>
</BODY>
</HTML>
