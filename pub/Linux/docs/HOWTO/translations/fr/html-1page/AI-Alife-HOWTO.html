<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Guide pratique sur l'intelligence artificielle et la vie
    artificielle sous GNU/linux</title><link href="style.css" rel="stylesheet" type="text/css" /><meta content="DocBook XSL Stylesheets V1.70.1" name="generator" /><meta name="description" content="Ce guide contient principalement des informations et des liens relatifs à diverses applications, bibliothèques, etc. sur l'IA qui fonctionnent sur la plate-forme GNU/Linux. Tout ceci est libre dans le cadre d'un usage personnel (ou davantage). La page la plus à jour de ce document se trouve à l'adresse http://zhar.net/gnu-linux/howto/" /></head><body><div class="article" lang="fr"><div class="titlepage"><div><div><h1 class="title"><a id="N10001" />Guide pratique sur l'intelligence artificielle et la vie
    artificielle sous GNU/linux</h1></div><div><h3 class="subtitle"><i>Version française du <span class="foreignphrase"><em class="foreignphrase">GNU/Linux AI and Alife
    HOWTO</em></span></i></h3></div><div><div class="author"><h3 class="author"><span class="firstname">John</span> <span class="surname">Eikenberry</span></h3><div class="affiliation"><div class="address"><p><span style="white-space: pre;">
           <code class="email">&lt;<a href="mailto:jae@zhar.net">jae@zhar.net</a>&gt;</code>
        </span></p></div></div></div></div><div><p class="othercredit"><span class="firstname">Pierre-Yves</span> <span class="surname">Aimon</span></p></div><div><p class="othercredit"><span class="firstname">Laurent</span> <span class="surname">Fallet</span></p></div><div><p class="othercredit"><span class="firstname">Laurent</span> <span class="surname">Morretton</span></p></div><div><p class="othercredit"><span class="firstname">Yvon</span> <span class="surname">Benoist</span></p></div><div><p class="releaseinfo">Version : 2.3.fr.1.0</p></div><div><div class="revhistory"><table summary="Revision history" width="100%" border="1"><tr><th colspan="3" valign="top" align="left"><b>Historique des versions</b></th></tr><tr><td align="left">Version 2.3.fr.1.0</td><td align="left">2006-10-01</td><td align="left">LF</td></tr><tr><td colspan="3" align="left">Mise à jour de la traduction française</td></tr><tr><td align="left">Version 1.9.fr.1.0</td><td align="left">2004-01-15</td><td align="left">LM, LF, PYM</td></tr><tr><td colspan="3" align="left">Première traduction française</td></tr><tr><td align="left">Version originale</td><td align="left">2006-08-21</td><td align="left">JE</td></tr><tr><td colspan="3" align="left">Version 2.3. Consulter la section "Quoi de neuf" pour les
        révisions antérieures.</td></tr></table></div></div><div><div class="abstract"><p class="title"><b>Résumé</b></p><p>Ce guide contient principalement des informations et des liens
      relatifs à diverses applications, bibliothèques, etc. sur l'IA qui
      fonctionnent sur la plate-forme GNU/Linux. Tout ceci est libre dans le
      cadre d'un usage personnel (ou davantage). La page la plus à jour de ce
      document se trouve à l'adresse <a href="http://zhar.net/gnu-linux/howto/">http://zhar.net/gnu-linux/howto/</a></p></div></div></div><hr /></div><div class="toc"><p><b>Table des matières</b></p><dl><dt><span class="section"><a href="#N10061">Introduction</a></span></dt><dd><dl><dt><span class="section"><a href="#N10064">But</a></span></dt><dt><span class="section"><a href="#N1006B">Quoi de neuf ?</a></span></dt><dt><span class="section"><a href="#N10097">Où trouver les logiciels ?</a></span></dt><dt><span class="section"><a href="#N100A0">Mises à jour et commentaires</a></span></dt><dt><span class="section"><a href="#N100B1">Copyright/Licence</a></span></dt></dl></dd><dt><span class="section"><a href="#N100DF">Intelligence Artificielle traditionnelle</a></span></dt><dd><dl><dt><span class="section"><a href="#N100E4">Bibliothèques de classes/code d'IA</a></span></dt><dt><span class="section"><a href="#N1028A">Kits logiciels d'IA, applications, etc.</a></span></dt></dl></dd><dt><span class="section"><a href="#N1044A">Connexionnisme</a></span></dt><dd><dl><dt><span class="section"><a href="#N1044F">Bibliothèques de classe/code sur le connexionnisme</a></span></dt><dt><span class="section"><a href="#N105A1">A venir</a></span></dt></dl></dd><dt><span class="section"><a href="#N105A6">Informatique évolutive</a></span></dt><dt><span class="section"><a href="#N105AD">A venir</a></span></dt><dt><span class="section"><a href="#N105B2">Les agents</a></span></dt><dt><span class="section"><a href="#N10915">Les langages de programmation</a></span></dt><dt><span class="section"><a href="#N10ACD">Manquant et Inactif</a></span></dt><dd><dl><dt><span class="section"><a href="#N10AD2">MIA — Projets ne disposant pas de liens.</a></span></dt><dt><span class="section"><a href="#N10B07">Projets inactifs.</a></span></dt></dl></dd></dl></div><div class="section" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="N10061" />Introduction</h2></div></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N10064" />But</h3></div></div></div><p>Le système d'exploitation GNU/Linux a évolué depuis ses origines
      de système pirate jusqu'à devenir un système UNIX complet, capable de
      rivaliser avec n'importe quel UNIX commercial. Il est maintenant une
      base peu onéreuse pour la construction de bonnes stations de travail. Il
      s'est libéré de ses problèmes de compatibilité matérielle en ayant été
      porté sur des stations DEC Alpha, Sparcs, Power PC et bien d'autres. Son
      potentiel de croissance rapide ainsi que son support réseau le rend
      idéal pour le partage du temps de travail entre plusieurs ordinateurs.
      En tant que station de travail, il permet toutes sortes de recherches et
      de développements, y compris les travaux sur l'intelligence artificielle
      et la vie artificielle.</p><p>Le but de ce HOW-TO est de fournir une base permettant de trouver
      différents logiciels, bibliothèques de code, et tout ce qui peut aider à
      démarrer (et trouver les ressources) dans le monde de l'intelligence
      artificielle, de la vie artificielle, etc. Tout cela dans l'optique
      GNU/Linux.</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N1006B" />Quoi de neuf ?</h3></div></div></div><p><div class="itemizedlist"><ul><li><p>
            v2.4 (en développement) — Nouvelles entrées : Eprover,
            Player et Robodeb. J'ai divisé la section Agents en deux
            sous-sections, à savoir Agents Logiciels et Simulateurs et
            Robotique. Je crains d'être allé un peu vite quand à la
            répartition, mais c'est une amélioration. MIA trouvé! Cellular, le
            système d'automate programmable cellulaire.
          </p></li><li><p>
            v2.3 — Nouvelles entrées : Yamp, pygene, Push, ANNEvolve,
            dgpf, Golly, IBAL, 3APL, OSCAR, and RobocodeNG. Mise à jour des
            entrées Yale, Joone, Drone, Biome, ECLiPSe, Xtoys, GECO, Creatures
            Docking Station et d'autres. J'ai également renommé la section MIA
            en Manquants et Inactifs qui regroupe maintenant les liens morts
            ou erronés pour lesquels je ne trouve de remplacement et les
            projets qui ne sont plus actifs.
          </p></li><li><p>
            v2.2 — Quelques liens cassés ont été réparés et quelques
            nouvelles entrées ont du être déplacées dans la section MIA
            (manquante). J'ai également supprimé une entrée dupliquée.
            Nouvelles entrées : MASON, spyse, AntWars, OpenSteer, Pyro,
            Robocode, Trend and Open BEAGLE.
          </p></li><li><p>
            v2.1 — Nouvelles entrées : NLTK, NEURObjects, KANREN, Neural
            Networks at your Fingertips, SimWorld, SimAgent, Fuzzy sets for
            Ada, maxent, Evo, breve and AJA
          </p></li><li><p>
            v2.0 — Un vérificateur de liens m'a permis de supprimer les
            liens erronés ou de les remplacer. Voir la liste des entrées
            supprimées dans la section MIA (me contacter si vous connaissez le
            nouveau lien). Nouvelles entrées : Yale, DIET Agents, JASA, Jason,
            Noble Ape, Maude, ECLiPSe, lush, and pygp
          </p></li><li><p>
            v1.9 — Ajout d'une nouvelle entrée (Bond) et réparation du
            lien donné plus bas, qui pointe vers la liste dynamique.
          </p></li><li><p>
            v1.8 — Nettoyage de liens erronés, recherche de nouveaux
            liens lorsque cela était possible et suppression de ceux qui
            semblent avoir disparus. Quelques nouvelles entrées ajoutées
            également : Torch, Aleph, AI Kernel, OpenCyc, HTK, FFLL, JCK,
            Joone, scnANNlib, GAUL, Cougaar, and RoboTournament
          </p></li><li><p>
            v1.7 — 9 autres nouvelles entrées ajoutées, une série de
            liens réparés, quelques éléments enlevés qui ont disparus du net.
            Nouvelles entrées : SPASS, CNNs, JCASim, Genetic, CAGE,
            AgentFarms, MATREM, OAA, et UTCS Neural Nets Research Group
            Software
          </p></li><li><p>
            v1.6 — Ajout de 9 nouvelles entrées, deux liens réparés et
            un élément redondant enlevé.
          </p></li><li><p>
            v1.5 — 26 nouvelles entrées, ainsi que deux ou trois
            réparations de liens.
          </p></li><li><p>
            v1.4 — 10 mises à jour effectuées et réparation de liens en
            rapport avec LISP.
          </p></li><li><p>
            v1.3 — Pour rattraper le retard, j'ai ajouté plus de 30
            nouvelles entrées aujourd'hui et je l'ai soumis au LDP.
          </p></li><li><p>
            Pas d'enregistrements sur les versions précédentes :(
          </p></li></ul></div></p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N10097" />Où trouver les logiciels ?</h3></div></div></div><p>Tous les programmes devraient être disponibles sur Internet (ftp
      ou http). Les liens vers ces ressources sont fournis dans la description
      de chaque logiciel. Il y a également une pléthore de logiciels non
      traités dans ces pages (qui sont généralement indépendants de la
      plate-forme), situés sur une des ressources listées dans la <a href="http://zhar.net/mlp/ai/"> section lien </a> du site principal
      (donné plus haut).</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N100A0" />Mises à jour et commentaires</h3></div></div></div><p>Si vous trouvez des erreurs, que vous êtes au courant des mises à
      jour de l'un des outils décrit plus loin, ou que vous rencontrez des
      problèmes pour compiler l'une des applications, écrivez-moi à <a href="mailto:jae@NOSPAM-zhar.net"> jae@zhar.net </a> et je verrai ce
      que je peux faire.</p><p>Si vous connaissez des applications sur l'IA/VA, des bibliothèques
      de classe, etc, envoyez-moi <a href="mailto:jae@NOSPAM-zhar.net">un
      email</a> au sujet de celles-ci. Mentionnez votre nom, l'adresse ftp
      ou http où l'on peut trouver ces applications, ainsi qu'un bref
      résumé/commentaire sur le logiciel (ces informations devraient me rendre
      les choses beaucoup plus faciles... mais ne vous sentez pas obligés de
      le faire ;) ).</p><p>Je sais que garder cette liste à jour et l'augmenter demande pas
      mal de travail. Alors s'il vous plait, soyez patient (j'ai aussi
      d'autres projets en cours). J'espère que vous trouverez ce document
      utile.</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N100B1" />Copyright/Licence</h3></div></div></div><p>Copyright (c) 1996-2006 John A. Eikenberry</p><p>LICENCE</p><p>Ce document peut être reproduit et distribué entièrement ou en
      partie, sur n'importe quel média, qu'il soit physique ou électronique, à
      condition que cette licence apparaisse sur la reproduction. La
      redistribution commerciale est autorisée et encouragée. Un préavis de 30
      jours, par courriel à l'auteur, de la redistribution serait appréciée,
      afin de donner à l'auteur le temps de fournir des documents à
      jour.</p><p>A. CONDITIONS REQUISES POUR LES MODIFICATIONS</p><p>Tout document modifié, y compris les traductions, anthologies, ou
      documents partiels, doit se conformer aux conditions suivantes :</p><p><div class="itemizedlist"><ul><li><p>
            Ces versions doivent être identifiées comme étant des
            versions modifiées
          </p></li><li><p>
            Le nom de la personne réalisant ces modifications doit être
            indiqué.
          </p></li><li><p>
            Il est nécessaire de mentionner le nom de l'auteur
            original.
          </p></li><li><p>
            L'emplacement du document original non modifié doit être
            indiqué.
          </p></li><li><p>
            Le ou les noms des auteurs ne doivent pas êtres utilisés
            pour revendiquer ou impliquer leur approbation du document qui
            résulte de ces modifications sans l'accord de l'auteur
            original.
          </p></li></ul></div></p><p>De plus, il est recommandé (mais pas obligatoire) de respecter ces
      consignes :</p><p><div class="itemizedlist"><ul><li><p>
            Les modifications, y compris les suppressions, doivent êtres
            signalées.
          </p></li><li><p>
            L'auteur doit être prévenu de toute modification avant la
            redistribution par courriel, si une adresse électronique est
            fournie dans le document.
          </p></li></ul></div></p><p>Une exception cependant : les anthologies de documents LDP peuvent
      n'inclure qu'une copie des termes de cette licence de manière visible, à
      l'intérieur du recueil, et peut remplacer les autres copies de cette
      licence par une référence à la seule copie de la licence, sans
      considérer le document comme "modifié" pour le besoin de cette
      section.</p><p>Le simple regroupement de documents LDP avec d'autres documents ou
      programmes sur le même médium ne doit pas impliquer que la licence porte
      également sur ces autres travaux.</p><p>Toute traduction, document dérivé, ou document modifié qui
      incorporerait ce document n'est pas soumis à des termes de licence plus
      restrictifs que ceux là, à l'exception du fait que vous pouvez demander
      aux distributeurs de mettre à disposition le document en question sous
      le format source.</p></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="N100DF" />Intelligence Artificielle traditionnelle</h2></div></div></div><p>L'IA traditionnelle se fonde sur tout ce qui tourne autour de la
    logique, des systèmes de règles, de la linguistique, et du concept de
    rationalité. Ses racines sont les langages de programmation comme Lisp et
    Prolog. Les systèmes experts sont les plus grands exemples de réussite de
    ce paradigme. Un système expert consiste en une base de connaissances
    détaillée et un système complexe de règles pour l'utiliser. De tels
    systèmes ont été utilisés comme support de diagnostiques médicaux et
    systèmes de vérification de solvabilité.</p><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N100E4" />Bibliothèques de classes/code d'IA</h3></div></div></div><p>Ce sont des bibliothèques de classes ou code à utiliser lorsque
      vous programmez dans le domaine de l'intelligence artificielle. Elles ne
      sont pas destinées à devenir des applications à part entière, mais
      plutôt comme des outils afin de créer vos propres applications.</p><div class="glosslist"><dl><dt>ACL2</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web : <a href="http://www.cliki.net/ACL2">
                  www.cliki.net/ACL2</a>
                </p></li></ul></div></p><p>ACL2 (A Computational Logic for Applicative Common Lisp)
            permet de démonter les théorèmes pour des applications
            industrielles. C'est à la fois de la logique mathématique et un
            système d'outils pour construire des preuves dans la logique. ACL2
            marche avec GCL (GNU Common Lisp).</p></dd><dt>AI Kernel</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site Web : <a href="http://aikernel.sourceforge.net">
                  aikernel.sourceforge.net</a>
                </p></li><li><p>
                  Site Web Sourceforge : <a href="http://sourceforge.net/projects/aikernel">
                  sourceforge.net/projects/aikernel</a>
                </p></li></ul></div></p><p>AI Kernel (noyau d'IA) est un moteur d'intelligence
            artificielle réutilisable qui utilise le traitement du langage
            naturel et un modèle Activateur/Contexte afin de permettre le
            multi-tâche entre les cellules installées.</p></dd><dt>AI Search II</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site Web : <a href="http://www.bell-labs.com/topic/books/ooai-book/ ">
                  www.bell-labs.com/topic/books/ooai-book/</a>
                </p></li></ul></div></p><p>En gros, cette bibliothèque offre au programmeur une série
            d'algorithmes de recherche qui peuvent être utilisés pour résoudre
            toutes sortes de problèmes différents. L'idée est que lorsqu'il
            développe un logiciel de résolution de problème, le programmeur
            devrait pouvoir se concentrer sur la représentation du problème à
            résoudre, sans avoir à se soucier de l'implémentation du moteur de
            recherche qui serait précisément utilisé pour mener la recherche.
            Cette idée a été appliquée grâce à l'implémentation d'une série de
            classes de recherche qui peuvent être incorporées dans d'autres
            logiciels à travers des spécifications de dérivation ou d'héritage
            du C++. Les algorithmes de recherche suivants ont été mis en
            œuvre :</p><p><div class="itemizedlist"><ul><li><p>
                  Recherche en profondeur (deep-first) dans un arbre ou
                  un graphe.
                </p></li><li><p>
                  Recherche horizontale (breadth-first) dans un arbre ou
                  un graphe.
                </p></li><li><p>
                  Recherche par coûts uniformes dans un arbre ou un
                  graphe.
                </p></li><li><p>
                  Recherche du meilleur en priorité (best-first).
                </p></li><li><p>
                  Recherche bidirectionnelle en profondeur
                  (bidirectional depth-first) dans un arbre ou un
                  graphe.
                </p></li><li><p>
                  Recherche bidirectionnelle horizontale (bidirectional
                  breadth-first) dans un arbre ou un graphe.
                </p></li><li><p>
                  Recherche ET/OU en profondeur dans un arbre.
                </p></li><li><p>
                  Recherche ET/OU horizontale dans un arbre.
                </p></li></ul></div></p><p>Il existe un livre qui correspond à cette bibliothèque,
            <a href="http://www.bell-labs.com/topic/books/ooai-book/">"Object-Oriented
            Artificial Instelligence, Using C++"</a>.</p></dd><dt>Aleph</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site Web : <a href="http://web.comlab.ox.ac.uk/oucl/research/areas/machlearn/Aleph/">
                  web.comlab.ox.ac.uk/oucl/research/areas/machlearn/Aleph/</a>
                </p></li></ul></div></p><p>Ce document fournit des informations de référence sur "A
            Learning Engine for Proposing Hypotheses" (Aleph : un moteur
            d'apprentissage pour proposer des hypothèses). Aleph est système
            de programmation par logique inductive (Inductive Logic
            Programming, ILP). La fonction d'Aleph est celle de prototype pour
            explorer des idées. Aleph est un algorithme ILP mis en œuvre en
            Prolog par le Dr Ashwin Srinivasav au laboratoire informatique de
            l'université d'Oxford, et a été écrit spécifiquement pour la
            compilation avec le compilateur Prolog YAP.</p></dd><dt>Chess In Lisp (CIL : les échecs en Lisp)</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site Web : *fait partie de l'archive CLOCC <a href="http://clocc.sourceforge.net">
                  clocc.sourceforge.net</a>
                </p></li></ul></div></p><p>La fondation CIL (les échecs en Lisp) est une implémentation
            "Common Lisp" de toutes les fonctions principales nécessaires au
            développement d'applications sur les jeux d'échecs. Le but
            principal du projet CIL est d'amener les chercheurs en IA
            intéressés par l'emploi de Lisp à travailler sur le domaine des
            échecs.</p></dd><dt>DAI</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site Web : <a href="http://starship.python.net/crew/gandalf/DNET/AI/">
                  starship.python.net/crew/gandalf/DNET/AI/</a>
                </p></li></ul></div></p><p>C'est une bibliothèque pour le langage de programmation
            Python qui fournit une interface orientée objet à l'outil système
            expert CLIPS. Il inclut une interface pour COOL (CLIPS Object
            Oriented Langage : Langage orienté objet CLIPS) qui permet de
            :</p><p><div class="itemizedlist"><ul><li><p>
                  Examiner, étudier les classes COOL
                </p></li><li><p>
                  Créer et manipuler des instances COOL
                </p></li><li><p>
                  Manipuler les gestionnaires de messages COOL
                </p></li><li><p>
                  Manipuler les modules
                </p></li></ul></div></p></dd><dt>FFLL</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site Web : <a href="http://ffll.sourceforge.net">
                  ffll.sourceforge.net</a>
                </p></li></ul></div></p><p>La bibliothèque gratuite de logique floue (FFLL : Free Fuzzy
            Logic Library) est une bibliothèque de classe et une API libres de
            logique floue qui est optimisée pour des applications dont la
            rapidité est importante, comme les jeux vidéos. FFLL est capable
            de charger des fichiers conformes au standard IEC 61131-7.</p></dd><dt>Fuzzy sets for Ada</dt><dd><p><div class="itemizedlist"><ul><li><p>
                
                  Site Web : <a href="http://www.dmitry-kazakov.de/ada/fuzzy.htm">http://www.dmitry-kazakov.de/ada/fuzzy.htm</a>
                  
                  </p><p>
                  
                  Freshmeat : <a href="http://freshmeat.net/projects/fuzzy/">http://freshmeat.net/projects/fuzzy/</a>
                  
                </p></li></ul></div></p><p>Les ensembles flous pour Ada (Fuzzy sets for Ada) est une
            librairie fournissant des implémentations de facteurs de confiance
            pour les opérateurs NOT, AND, OR, XOR, + et *, les ensembles flous
            classiques avec les opérations sur la théorie des ensembles, les
            opérations sur la théorie des possibles, les opérations sur les
            ensembles intuitifs, la logique floue basée sur la théorie des
            possibles et les ensembles flous intuitifs ; les nombres flous, à
            la fois entier et à virgule flottante avec leurs opérations
            arithmétiques classiques, les variables linguistiques et les
            ensembles de variables linguistiques avec les opérations les
            concernant. Les entrées/sorties à base de chaînes de caractères
            sont supportées.</p></dd><dt>HTK</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site Web : <a href="http://htk.eng.cam.ac.uk">
                  htk.eng.cam.ac.uk</a>
                </p></li></ul></div></p><p>La boîte à outils du modèle de Markov masqué (HTK : Hidden
            Markov Model ToolKit) est une boîte à outils portable pour créer
            et manipuler des modèles de Markov masqué. HTK consiste en une
            série de modules de bibliothèques et d'outils disponibles sous la
            forme de sources en C. Ces outils founissent des solutions
            sophistiquées pour l'analyse vocale, la formation HMM, les tests
            et l'analyse de résultats. L'application supporte les HMM en
            utilisant à la fois les fonctions gaussiennes sur les mélanges à
            densité constante et les distributions discrètes et peut être
            utilisée pour créer des systèmes HMM complexes. Le logiciel HTK
            contient une grande quantité d'informations et d'exemples.</p></dd><dt>JCK</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site Web : <a href="http://www.pms.informatik.uni-muenchen.de/software/jack/">
                  www.pms.informatik.uni-muenchen.de/software/jack/</a>
                </p></li></ul></div></p><p>JCK est une nouvelle bibliothèque pour la programmation et
            la recherche par contraintes pour Java.</p><p><div class="itemizedlist"><ul><li><p>
                  JCK est constitué de trois composants :
                </p></li><li><p>
                  - JCHR : Java Constraint Handling Rules (règles de
                  manipulation de contraintes Java). Langage de haut niveau
                  pour écrire des résolveurs de contraintes.
                </p></li><li><p>
                  - JASE : Java Abstract Search Engine (moteur de
                  recherche abstrait Java). Moteur de recherche générique pour
                  JCHR afin de résoudre les problèmes de contraintes.
                </p></li><li><p>
                  - VisualCHR : outil interactif pour visualiser les
                  calculs JCHR.
                </p></li></ul></div></p><p>Les sources et la documentation sont disponibles à partir du
            lien ci-dessus.</p></dd><dt>KANREN</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site Web : <a href="http://kanren.sourceforge.net">http://kanren.sourceforge.net</a>
                </p></li></ul></div></p><p>KANREN est un système de programmation par logique
            déclarative avec des relations de premier ordre, inclus dans un
            sous-ensemble fonctionnel pur de Scheme. Le système est constitué
            de sémantiques de la théorie des ensembles, de relations vraies,
            de relations de premier ordre, de variables logiques à portée
            lexicale, de stratégies en profondeur (deep-first) et itératif en
            profondeur (iterative deepening). Le système atteint de hautes
            expressivités et performances sans élimination.</p></dd><dt>LK</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site Web : <a href="http://www.cs.utoronto.ca/~neto/research/lk/">
                  www.cs.utoronto.ca/~neto/research/lk/</a>
                </p></li></ul></div></p><p>LK est une implémentation de l'heuristique de Lin-Kernighan
            pour le problème du commercial démarcheur et pour le problème de
            la correspondance parfaite de pondération minimum. Il est
            spécialement adapté aux figures géométriques en 2D, et a été
            appliqué dans certains exemples jusqu'à un million de villes. Il
            comprend aussi des générateurs d'exemples et des scripts Perl pour
            manipuler les exemples TSPLIB.</p><p>Cette implémentation introduit la "compensation groupée
            efficace", une technique algorithmique expérimentale dont le but
            est de rendre l'heuristique de Lin-Kernighan plus robuste dans le
            cas de données groupées.</p></dd><dt>maxent</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Version Python / C++ : <a href="http://homepages.inf.ed.ac.uk/s0450736/maxent_toolkit.html">
                  homepages.inf.ed.ac.uk/s0450736/maxent_toolkit.html</a>
                </p></li><li><p>
                  Version Java : <a href="http://maxent.sourceforge.net">
                  maxent.sourceforge.net</a>
                </p></li></ul></div></p><p>La boîte à outils entropie maximum fournit un ensemble
            d'outils et une librairie pour construire des modèles d'entropie
            maximum (maxent) en Python ou C++. Il contient des modèles
            d'entropie maximum conditionnels, une estimation des paramètres
            GIS et L-BFGS, un lissage Gaussien, une API C++, un module
            d'extension Python, un utilitaire en ligne de commande et une
            bonne documentation. Une version Java est également
            disponible.</p></dd><dt>Nyquist</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site Web : <a href="http://www-2.cs.cmu.edu/~music/nyquist/">
                  www-2.cs.cmu.edu/~music/nyquist/</a>
                </p></li></ul></div></p><p>Le projet de musique informatisée (Computer Music Project)
            au CMU développe la technologie de la musique informatisée, et de
            la performance interactive pour améliorer l'expérience et la
            créativité musicale de l'homme. Cet effort interdisciplinaire
            puise dans la théorie de la musique, dans les sciences cognitives,
            l'intelligence artificielle, l'apprentissage des machines,
            l'interaction homme-machine, les systèmes temps réelles, les
            graphismes et animations informatiques, le multimédia, les
            langages de programmation, le traitement du signal. Un exemple
            paradigmatique de ces efforts interdisciplinaires est la création
            de la performance interactive qui lie l'improvisation musicale de
            l'homme aux agents informatiques intelligents en temps
            réel.</p></dd><dt>OpenCyc</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site Web : <a href="http://www.opencyc.org">
                  www.opencyc.org </a>
                </p></li><li><p>
                  Site Web alternatif : <a href="http://sourceforge.net/projects/opencyc/">
                  sourceforge.net/projects/opencyc/</a>
                </p></li></ul></div></p><p>OpenCyc est la version libre de Cyc, la plus grande et la
            plus complète des bases de connaissance générale ainsi que le plus
            grand moteur de raisonnement de sens communs. Une ontologie basée
            sur 6000 concepts en relation avec 60000 affirmations.</p></dd><dt>Module de logique floue Python</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site FTP : <a href="ftp://ftp.csh.rit.edu/pub/members/retrev/">
                  ftp://ftp.csh.rit.edu/pub/members/retrev/</a>
                </p></li></ul></div></p><p>C'est un simple module python pour la logique floue. Le
            fichier est 'fuz.tar.gz' dans ce répertoire. L'auteur ambitionne
            également d'écrire un algorithme de génétique simple de même
            qu'une bibliothèque sur les réseaux neuronaux. Regarder le fichier
            '00_index' dans ce répertoire pour obtenir des informations sur la
            version.</p></dd><dt>Screamer</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site Web :<a href="http://www.cis.upenn.edu/~screamer-tools/home.html">
                  www.cis.upenn.edu/~screamer-tools/home.html</a>
                </p></li><li><p>
                  La version la plus récente fait partie de CLOCC :
                  <a href="http://clocc.sourceforge.net">
                  clocc.sourceforge.net</a>
                </p></li></ul></div></p><p>Screamer est une extension de Common Lisp qui ajoute un
            support pour la programmation non déterministe. Screamer comprend
            deux niveaux. Le niveau non déterministe basique ajoute un support
            pour la journalisation et les effets de coté irréalisables. En
            plus de cet aspect non deterministe, Screamer fournit un langage
            complet de programmation sous contraintes dans lequel on peut
            formuler et résoudre un mélange de systèmes sous contraintes
            numériques ou symboliques. Ensembles, ces deux niveaux étendent
            Common Lisp avec pratiquement toutes les fonctionnalités de Prolog
            et des languages de programmation logiques sous contraintes comme
            CHiP ou CLP(R). En outre, Screamer est complètement compatible
            avec Common Lisp. Les programmes de Screamer peuvent coexister et
            interopérer avec d'autres extensions de Common Lisp comme CLOS,
            CLIM et Iterate.</p></dd><dt>SPASS</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site Web :<a href="http://spass.mpi-sb.mpg.de">
                  spass.mpi-sb.mpg.de</a>
                </p></li></ul></div></p><p>SPASS : Démontreur de théorèmes automatisé pour des logiques
            de premier ordre avec égalité.</p><p>Si vous êtes intéressés par les démonstrations de théorèmes
            de logique du premier ordre, l'analyse formelle de programmes,
            systèmes, protocoles, les approches formelles de projets sur l'IA,
            les procédures de décisions, la démonstration de théorèmes à
            logique modale, SPASS peut vous offrir les bonnes
            fonctionnalités.</p></dd><dt>ThoughtTreasure</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site Web :<a href="http://www.signiform.com/tt/htm/tt.htm">
                  www.signiform.com/tt/htm/tt.htm</a>
                </p></li></ul></div></p><p>ThoughtTreasure est un projet pour créer une base de données
            de règles de sens communs à utiliser dans n'importe quelle
            application. Il consiste en une base de donnnées d'un peu plus de
            100 000 règles et d'une API C pour l'intégrer dans vos
            applications. Les emballeurs Python, Perl, Java et TCL sont déjà
            disponibles.</p></dd><dt>Torch</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site Web :<a href="http://www.torch.ch">
                  www.torch.ch</a>
                </p></li></ul></div></p><p>Torch est une bibliothèque d'apprentissage écrit en C++. Son
            but est de fournir l'état de l'art des meilleurs algorithmes. Il
            est, et sera toujours en développement.</p><p><div class="itemizedlist"><ul><li><p>
                  Plusieurs méthodes basées sur les gradients, y compris
                  des perceptions de niveau multiple, fonctions sur des bases
                  radiales et un mélange de compétences. Plusieurs petits
                  modules (modules linéaires, modules Tanh, modules SoftMax,
                  ...) peuvent être reliés ensembles.
                </p></li><li><p>
                  Machine de vecteur de support, pour la classification
                  et la regression.
                </p></li><li><p>
                  Distributions logicielles, comprenant Kmeans, des
                  modèles de mélanges Gaussiens, des modèles de Markov
                  Masqués, des classificateurs de Baye, et des classes pour la
                  reconnaissance vocale avec entrainement incorporé.
                </p></li><li><p>
                  Modèles ensemblistes tels que Bagging et
                  Adaboost.
                </p></li><li><p>
                  Modèles non paramétriques comme les k plus proches
                  voisins, la regression de Parzen et l'estimateur de densité
                  de Parzen.
                </p></li></ul></div></p><p>Torch est une bibliothèque libre dont les auteurs
            encouragent tout le monde à développer de nouveaux logiciels qui
            seront inclus dans les versions futures sur le site
            officiel.</p></dd></dl></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N1028A" />Kits logiciels d'IA, applications, etc.</h3></div></div></div><p>Voici plusieurs applications, kits logiciels, etc. ayant pour but
      la recherche dans le domaine de l'intelligence artificielle. Leur
      facilité d'utilisation peut varier, dans la mesure où ils ont été conçus
      pour satisfaire des intérêts de recherche particuliers, plus que comme
      un logiciel commercial sorti de l'étagère.</p><div class="glosslist"><dl><dt>ASA — Adaptive Simulated Annealing</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://www.ingber.com/#ASA-CODE">
                  www.ingber.com/#ASA-CODE</a>
                </p></li><li><p>
                  Site FTP :<a href="ftp://ftp.ingber.com">
                  ftp.ingber.com</a>
                </p></li></ul></div></p><p>ASA (Adaptive Simulated Annealing : Recuit simulé adaptatif)
            est un puissant algorithme en code C d'optimisation globale
            particulièrement pratique pour les systèmes non linéaires et/ou
            stochastiques.</p><p>ASA est développé pour trouver statistiquement le meilleur
            ajustement global d'une fonction coût non linéaire et non convexe
            sur un espace de dimension D. Cet algorithme permet un schéma de
            refroidissement du recuit pour une température T exponentiellement
            décroissante dans le temps recuit k, T=T_0 exp(-c k^1/D).
            L'introduction du renouvellement de recuit permet également une
            adaptation aux changements de sensibilités dans un espace
            paramétrique multi-dimensionnel. Cet schéma de refroidissement de
            recuit est plus rapide que le recuit de Cauchy rapide, où T =
            T_0/k, et encore plus rapide que le recuit de Boltzmann, où T =
            T_0/ln k.</p></dd><dt>Babylon</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site FTP :<a href="ftp://ftp.gmd.de/gmd/ai-research/Software/Babylon/">
                  ftp.gmd.de/gmd/ai-research/Software/Babylon/</a>
                </p></li></ul></div></p><p>BABYLON est un environnement modulaire, configurable et
            hybride pour le développement de systèmes experts. Ses
            caractéristiques comprennent les objets, les règles avec chaînage
            avant et arrière, la logique (Prolog) et les contraintes. BABYLON
            est codé et incorporé en Common Lisp.</p></dd><dt>cfengine</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://www.iu.hio.no/cfengine/">
                  www.iu.hio.no/cfengine/</a>
                </p></li></ul></div></p><p>Cfengine, ou "moteur de configuration" est un langage de
            très haut niveau pour la construction de systèmes experts qui
            administrent et configurent de grands réseaux informatiques.
            Cfengine utilise l'idée de classes et une forme primitive
            d'intelligence pour définir et automatiser la configuration de
            grands systèmes de façon la plus économique possible. Cfengine est
            conçu pour être une part des systèmes immunisés
            informatiques.</p></dd><dt>CLEARS</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web : ????? (Quelqu'un sait-il encore où trouver
                  le site ?)
                </p></li></ul></div></p><p>Le système CLEARS est un environnement graphique interactif
            pour les sémantiques de calcul. L'outil permet l'exploration et la
            comparaison de différents formalismes sémantiques ainsi que de
            leur interaction avec la syntaxe. Cela permet à l'utilisateur
            d'obtenir une idée de l'étendue des possibilités en matière de
            construction sémantique, ainsi qu'où se trouve la convergence
            réelle entre les théories.</p></dd><dt>CLIPS</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://www.ghg.net/clips/CLIPS.html">
                  www.ghg.net/clips/CLIPS.html</a>
                </p></li></ul></div></p><p>CLIPS est un outil productif de système expert de
            développement et de livraison qui fournit un environnement complet
            pour la construction de systèmes experts basés sur des règles ou
            des objets.</p><p>CLIPS fournit un outil cohésif pour la gestion d'une grande
            variété de connaissances compatible avec trois différents
            paradigmes de programmation : basé règles, orienté objet et
            procédural. La programmation basée sur les règles permet de
            représenter les connaissances comme des heuristiques, ou règles
            empiriques, qui spécifient une série d'actions à entreprendre pour
            une situation donnée. La programmation orientée objet permet à des
            sytèmes complexes d'être modelés comme composants modulaires (qui
            peuvent être facilement réutilisés pour modeler d'autres systèmes
            ou pour créer de nouveaux composants). Les capacités de
            programmation procédurale fournies par CLIPS sont similaires à
            celles trouvées dans les langages comme le C, le Pascal, l'Ada et
            le Lisp.</p></dd><dt>Eprover</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web : <a href="http://www.eprover.org/">http://www.eprover.org/</a>
                </p></li><li><p>
                  Site web : <a href="http://www4.informatik.tu-muenchen.de/~schulz/WORK/eprover.html">http://www4.informatik.tu-muenchen.de/~schulz/WORK/eprover.html</a>
                </p></li></ul></div></p><p>:TODO:</p></dd><dt>FOOL et FOX</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://rhaug.de/fool/">
                  rhaug.de/fool/</a>
                </p></li><li><p>
                  Site FTP :<a href="ftp://ftp.informatik.uni-oldenburg.de/pub/fool/">
                  ftp.informatik.uni-oldenburg.de/pub/fool</a>
                </p></li></ul></div></p><p>FOOL signifie organisateur flou Oldenburg [Fuzzy Organizer
            OLdenburg]. C'est le résultat d'un projet de l'Université
            d'Oldenburg. FOOL est une interface utilisateur graphique pour
            développer les règles de base floues. FOOL va vous aider à
            inventer et maintenir une base de données qui spécifie le
            comportement d'un contrôleur flou ou quelque chose de
            similaire.</p><p>FOX est un petit mais puissant moteur flou qui lit la base
            de données, lit des valeurs d'entrée et calcule la nouvelle valeur
            de contrôle.</p></dd><dt>FUF et SURGE</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://www.cs.bgu.ac.il/research/projects/surge/index.htm">
                  www.cs.bgu.ac.il/research/projects/surge/index.htm</a>
                </p></li><li><p>
                  Site FTP :<a href="ftp://ftp.cs.bgu.ac.il/pub/fuf/">
                  ftp.cs.bgu.ac.il/pub/fuf</a>
                </p></li></ul></div></p><p>FUF est une implémentation étendue du formalisme des
            grammaires d'unification fonctionnelles (FUGs : functional
            unification grammars) introduit par Martin Kay, spécialisé dans la
            tâche de génération de langage naturel. Il ajoute les
            fonctionnalités suivantes au formalisme de base :</p><p><div class="itemizedlist"><ul><li><p>
                  Types et héritage.
                </p></li><li><p>
                  Installation de contrôle étendu (maintient de
                  l'objectif, recherche inverse intelligente).
                </p></li><li><p>
                  Syntaxe modulaire.
                </p></li></ul></div></p><p>Ces extensions permettent le développement de grandes
            grammaires qui peuvent être traitées efficacement et peuvent être
            maintenues à jour et comprises plus facilement. SURGE est une
            grande grammaire syntaxique de réalisations de l'anglais, écrite
            en FUF. SURGE est développée pour servir de composant de
            génération syntaxique de boîte noire dans un système de génération
            plus grand qui encapsule une connaissance riche de la syntaxe
            anglaise. SURGE peut aussi être utilisé comme plate-forme pour
            l'exploration de l'écriture de la grammaire dans une perspective
            de génération.</p></dd><dt>The Grammar Workbench</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web : ???<a href="http://www.cs.kun.nl/agfl/">
                  www.cs.kun.nl/agfl</a>
                </p></li></ul></div></p><p>Semble être obsolète ??? N'est plus sur le site, bien que le
            projet parent se poursuive toujours.</p><p>The Grammar Workbench (L'atelier de grammaire), ou GWB en
            abrégé, est un environnement pour le développement aisé de
            grammaires Affix dans le formalisme AGFL. Ses buts sont :</p><p><div class="itemizedlist"><ul><li><p>
                  de permettre à l'utilisateur d'introduire, inspecter
                  et modifier une grammaire ;
                </p></li><li><p>
                  d'effectuer des vérifications de cohérence sur la
                  grammaire ;
                </p></li><li><p>
                  de calculer des propriétés de la grammaire ;
                </p></li><li><p>
                  de générer des phrases d'exemple ;
                </p></li><li><p>
                  d'aider à effectuer des transformations sur la
                  grammaire.
                </p></li></ul></div></p></dd><dt>GSM Suite</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://www.ibiblio.org/pub/Linux/apps/graphics/draw/">
                  www.ibiblio.org/pub/Linux/apps/graphics/draw/</a>
                </p></li></ul></div></p><p>The GSM Suite (la suite GSM) est une série de programmes
            pour l'utilisation des machines à état fini en mode graphique.
            Cette suite consiste en des programmes qui éditent, compilent, et
            impriment des machines d'état. La suite comprend un programme
            d'édition, gsmedit, un compilateur, gsm2cc, qui produit une
            implémentation C++ d'une machine d'état, un générateur PostScript,
            gsm2ps, et deux autres programmes mineurs. GSM est sous licence
            publique GNU et est donc libre d'utilisation selon les termes de
            cette licence.</p></dd><dt>Isabelle</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://isabelle.in.tum.de">
                  isabelle.in.tum.de</a>
                </p></li></ul></div></p><p>Isabelle est un démontreur de théorème générique populaire
            développé à l'Université de Cambridge et au TU Munich. Les
            logiques existantes comme Isabelle/HOL fournissent un
            environnement de démontreur de théorème prêt à être utilisé pour
            d'assez grandes applications. Isabelle peut également servir comme
            châssis pour un prototypage rapide de systèmes déductifs. Il est
            présenté avec une grande bibliothèque comprenant Isabelle/HOL
            (logique classique d'ordre supérieur), Isabelle/HOLCF (Logique de
            Scott pour des fonctions calculatoire avec HOL), Isabelle/FOL
            (logique du premier ordre classique et intuitive), et Isabelle/ZF
            (ensemble de théories de Zermelo-Fraenkel au dessus de
            FOL).</p></dd><dt>Jess, the Java Expert System Shell</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://herzberg.ca.sandia.gov/jess/">
                  herzberg.ca.sandia.gov/jess/</a>
                </p></li></ul></div></p><p>Jess (le shell système expert Java) est un clone du
            populaire shell de système expert CLIPS, entièrement écrit en
            Java. Avec Jess, vous pouvez à votre convenance donner à vos
            applets l'habilité à raisonner. Jess est compatible avec toutes
            les versions de Java, à partir de la version 1.0.2. Jess
            implémente les constructeurs suivants de CLIPS : defrules,
            deffunctions, defglobals, deffacts, et deftemplates.</p></dd><dt>learn</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web : <a href="http://www.ibiblio.org/pub/Linux/apps/cai/">
                  www.ibiblio.org/pub/Linux/apps/cai/</a>
                </p></li></ul></div></p><p>Learn (apprendre) est programme d'apprentissage vocal avec
            un modèle de mémoire.</p></dd><dt>LISA</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web : <a href="http://lisa.sourceforge.net">
                  lisa.sourceforge.net</a>
                </p></li></ul></div></p><p>LISA (Lisp-based Intelligent Software Agents : agents
            logiciels intelligents basés sur Lisp) est un système de règles de
            production lourdement influencé par JESS (Java Expert System
            Shell). Il a en son squelette un moteur de raisonnement basé sur
            l'algorithme de filtrage de Rete. LISA fournit également
            l'habilité à raisonner sur d'ordinaires objets CLOS.</p></dd><dt>NICOLE</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web : <a href="http://nicole.sourceforge.net">
                  nicole.sourceforge.net</a>
                </p></li></ul></div></p><p>NICOLE (Nearly Intelligent Computer Operated Language
            Examiner) est une théorie ou une expérimentation qui, si on donne
            à un ordinateur suffisamment de combinaisons sur la manière dont
            les mots, groupes de mots ou phrases sont liés les uns aux autres,
            peut vous répondre. C'est un essai pour simuler une conversation
            en apprenant comment les mots se rapportent à d'autres mots. Un
            humain communique avec NICOLE via le clavier et NICOLE répond avec
            ses propres phrases qui sont automatiquement générées, basées sur
            ce que NICOLE a stocké dans sa base de données. Chaque nouvelle
            phrase qui a été écrite et que NICOLE ne connaît pas est ajoutée à
            la base de donnée de NICOLE, ce qui étend la base de connaissances
            de NICOLE.</p></dd><dt>NLTK</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web : <a href="http://nltk.sourceforge.net">nltk.sourceforge.net</a>
                </p></li></ul></div></p><p>NLTK, la boîte à outils de langage naturel (the Natural
            Language Toolkit), est une suite de librairies et de programmes en
            Python pour le traitement statistique et symbolique du langage
            naturel. NLTK contient des démonstrations graphiques et des
            échantillons de données. Il est accompagné d'une documentation
            fournie, y compris des tutoriels explicant les concepts
            sous-jacents des tâches de traitement du langage réalisées par
            l'outil.</p><p>NLTK convient parfaitement aux étudiants qui apprennent le
            traitement du langage naturel, ou qui réalisent une recherche dans
            le TLN ou un domaine approchant, tels que la linguistique, les
            sciences cognitives, l'intelligence artificielle, l'extraction de
            données, et l'apprentissage par machines. NLTK a été utilisé avec
            succès comme outil d'apprentissage, outil d'étude individuel, et
            comme une plateforme de prototypage et de construction de systèmes
            de recherche.</p></dd><dt>Otter : Système de déduction automatisé (An Automated
          Deduction System)</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://www-unix.mcs.anl.gov/AR/otter/">
                  www-unix.mcs.anl.gov/AR/otter/</a>
                </p></li></ul></div></p><p>Notre système de déduction automatisé actuel Otter est conçu
            pour démontrer les théorèmes de logique du premier ordre avec une
            égalité. Les règles d'inférence d'Otter sont basées sur la
            résolution et la paramodulation, et il comprend des procédures
            pour la réécriture de termes, l'ordonnancement de termes, la
            complétion Knut-Bendix, le pesage, et les stratégies pour diriger
            et restreindre les recherches de preuves. Otter peut aussi être
            utilisé comme un calculateur symbolique et a un système de
            programmation équationnelle incorporé.</p></dd><dt>PVS</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://pvs.csl.sri.com/">pvs.csl.sri.com</a>
                </p></li></ul></div></p><p>PVS est un système de vérification : c'est à dire un langage
            de spécification intégré à des outils de support et à un
            démontreur de théorème. Il est prévu pour capturer la plus
            sophistiquée des méthodes formelles mécanisées et pour être
            suffisamment robuste pour pouvoir être utilisé pour des
            applications significatives. PVS est un prototype de recherche :
            il évolue et s'améliore au fur et à mesure que nous développons ou
            appliquons de nouvelles capacités, et lorsque la charge en
            utilisation réelle expose de nouveaux besoins.</p></dd><dt>SNePS</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://www.cse.buffalo.edu/sneps/">
                  www.cse.buffalo.edu/sneps</a>
                </p></li><li><p>
                  Site FTP :<a href="ftp://ftp.cse.buffalo.edu/pub/sneps/">
                  ftp.cse.buffalo.edu/pub/sneps</a>
                </p></li></ul></div></p><p>Le but à long terme du groupe de recherche SNePS est la
            conception et la construction d'un langage naturel utilisant un
            agent cognitif informatisé, et d'effectuer la recherche dans
            l'intelligence artificielle, les linguistiques calculatoires, et
            la science cognitive nécessaire pour cette entreprise. Les trois
            parties sur lesquelles le groupe met l'accent sont la
            représentation du savoir, le raisonnement, et la compréhension et
            la génération du langage naturel. Le groupe est largement connu
            pour son développement du système de représentation/raisonnement
            du savoir SNePS, et pour Cassie, son agent cognitif
            informatisé.</p></dd><dt>Soar</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://sitemaker.umich.edu/soar">
                  sitemaker.umich.edu/soar</a>
                </p></li></ul></div></p><p>Soar a été développé pour être une architecture cognitive
            générale. Nous avons l'ultime intention de permettre à
            l'architecture Soar de :</p><p><div class="itemizedlist"><ul><li><p>
                  travailler sur l'ensemble des taches attendues d'un
                  agent intelligent, des routines jusqu'aux problèmes
                  extrêmement difficiles avec réponse ouverte ;
                </p></li><li><p>
                  représenter et utiliser les formes appropriées du
                  savoir, comme les formes procédurales, déclaratives,
                  épisodiques et possiblement iconiques ;
                </p></li><li><p>
                  se servir de tout l'éventail des méthodes de
                  résolution de problèmes ;
                </p></li><li><p>
                  interagir avec le monde extérieur et
                </p></li><li><p>
                  apprendre tous les aspects des tâches et leurs
                  performances sur celles-ci.
                </p></li></ul></div></p><p>En d'autres termes, notre intention est de donner à Soar
            toutes les compétences requises d'un agent globalement
            intelligent.</p></dd><dt>TCM</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web : <a href="http://wwwhome.cs.utwente.nl/~tcm/">
                  wwwhome.cs.utwente.nl/~tcm/</a>
                </p></li><li><p>
                  Site FTP : <a href="ftp://ftp.cs.utwente.nl/pub/tcm/">
                  ftp.cs.utwente.nl/pub/tcm/</a>
                </p></li></ul></div></p><p>TCM (Toolkit for Conceptual Modeling : boîte à outil pour la
            modélisation conceptuelle) est notre suite d'éditeurs graphiques.
            TCM contient des éditeurs graphiques pour des diagrammes
            entité-relation, des diagrammes classe-relation, des diagrammes de
            flux de données et d'évènements, des diagrammes de transition
            d'état, des diagrammes de structure de procédé de Jackson et des
            diagrammes de réseau systèmes, d'arbres de décomposition de
            fonction et d'éditeurs de tables variés, tels qu'un éditeur de
            table fonction-entité ou un éditeur de table de décomposition de
            fonction. TCM est facile d'accès et procède à de nombreuses
            vérifications de consistance, dont certaines sont effectuées
            immédiatement, d'autre pendant la requête.</p></dd><dt>Yale</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web : <a href="http://yale.cs.uni-dortmund.de/index.html">
                  yale.cs.uni-dortmund.de/index.html</a>
                </p></li></ul></div></p><p>Yale (Yet Another Learning Environment : Encore un autre
            environnement d'apprentissage) est un environnement pour les
            expériences d'apprentissage des machines. Les expériences peuvent
            être faites d'un grand nombre d'opérateurs emboîtés les uns dans
            les autres de manière arbitraire et leur installation est décrite
            par des fichiers XML qui peuvent être aisément créés à l'aide de
            l'interface graphique. Les applications de YALE couvrent à la fois
            les tâches d'apprentissage de recherche et du monde réel.</p></dd><dt>WEKA</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web : <a href="http://lucy.cs.waikato.ac.nz/~ml/">
                  lucy.cs.waikato.ac.nz/~ml</a>
                </p></li></ul></div></p><p>WEKA (Waikato Environnement for Knowledge Analysis :
            Environnement Waikato pour l'analyse de connaissance) est la
            pointe de la technologie de l'application des techniques
            d'apprentissage de machines à des problèmes pratiques. C'est un
            banc d'essai logiciel complet qui permet d'analyser les données du
            monde réel. Il intègre différents outils d'apprentissage machine
            avec un squelette identique et une interface utilisateur uniforme.
            Il a été conçu selon la méthode de "plus c'est simple, mieux
            c'est" qui permet à l'utilisateur d'expérimenter de façon
            interactive avec un outil d'apprentissage machine simple avant de
            se tourner vers des solutions plus complexes.</p></dd></dl></div></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="N1044A" />Connexionnisme</h2></div></div></div><p>Le connexionnisme est un terme technique pour un groupe de
    techniques liées. Ces techniques comprennent des notions comme les Réseaux
    de Neurones Artificiels, des Réseaux Sémantiques et quelques autres idées
    similaires. Dans cette section je me concentre essentiellement sur les
    réseaux de neurones (bien que je cherche aussi des ressources sur les
    autres techniques). Les réseaux neuronaux sont des programmes conçus pour
    simuler le fonctionnement du cerveau. Ils consistent en un réseau de
    petits nœuds basés sur les mathématiques, qui fonctionnent ensemble afin
    de former des schémas d'information. Ils ont un potentiel énorme et
    semblent actuellement rencontrer un grand succès dans le traitement de
    l'image et le contrôle de robots.</p><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N1044F" />Bibliothèques de classe/code sur le connexionnisme</h3></div></div></div><p>Ce sont des bibliothèques de code ou de classes à utiliser dans la
      programmation dans le domaine du connexionnisme. Elles ne sont pas
      destinés à être des applications autonomes, mais plus des applications
      pour construire vos propres applications.</p><div class="glosslist"><dl><dt>Logiciel de modélisation Bayésienne flexible</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://www.cs.utoronto.ca/~radford/fbm.software.html">
                  www.cs.utoronto.ca/~radford/fbm.software.html</a>
                </p></li></ul></div></p><p>Ce logiciel implémente les modèles Bayésiens flexibles pour
            des applications de régression et de classification qui sont basés
            sur les réseaux neuronaux à perception multi-couche ou sur les
            transformations Gaussiennes. L'implémentation utilise les méthodes
            de Monte Carlo de chaîne de Markov. Les modules logiciels qui sont
            compatibles avec l'échantillonnage des chaînes de Markov sont
            incluses dans la distribution, et peuvent être utiles à d'autres
            applications.</p></dd><dt>BELIEF</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/reasonng/probabl/belief/">
                  www.cs.cmu.edu/afs/cs/project/ai-repository/ai/areas/reasonng/probabl/belief/</a>
                </p></li></ul></div></p><p>BELIEF (croyance) est une implémentation Common Lisp de la
            fusion et de l'algorithme de propagation de Dempster et Kong pour
            des Modèles de Fonction de Croyances Graphique et l'algorithme de
            Lauritzen et Spiegelhalter pour des Modèles Probabilistes
            Graphiques. Il comprend du code pour manipuler les modèles de
            Croyance graphiques comme les réseaux Bayésiens et les diagrammes
            de Relevance (un sous-ensemble des diagrammes d'Influence) en
            utilisant à la fois les fonctions de croyance et les probabilités
            comme des représentations basiques de l'incertitude. Il utilise la
            version de Shenoy et de Shafer de cet algorithme, donc l'une de
            ses caractéristiques uniques est le fait qu'il supporte à la fois
            les distributions de probabilité et les fonctions de croyance. Il
            possède aussi un support limité des modèles de second ordre
            (distributions de probabilité sur les paramètres).</p></dd><dt>bpnn.py</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://arctrix.com/nas/python/bpnn.py">
                  arctrix.com/nas/python/bpnn.py</a>
                </p></li></ul></div></p><p>Un simple ANN à propagation arrière en Python.</p></dd><dt>CNNs</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://www.isi.ee.ethz.ch/~haenggi/CNNsim.html">
                  www.isi.ee.ethz.ch/~haenggi/CNNsim.html</a>
                </p></li><li><p>
                  Un site plus récent : <a href="http://www.isi.ee.ethz.ch/~haenggi/CNNsim_adv_manual.html">
                  www.isi.ee.ethz.ch/~haenggi/CNNsim_adv_manual.html</a>
                </p></li><li><p>
                  Version Java :<a href="http://www.ce.unipr.it/research/pardis/CNN/cnn.html">
                  www.ce.unipr.it/research/pardis/CNN/cnn.html</a>
                </p></li></ul></div></p><p>Réseaux neuronaux cellulaires (CNN : Cellular Neural
            Networks) est un paradigme d'informatique parallèle massive défini
            dans des espaces discrets de dimension N.</p></dd><dt>CONICAL</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://strout.net/conical/">
                  strout.net/conical/</a>
                </p></li></ul></div></p><p>CONICAL est une bibliothèque de class en C++ pour construire
            des simulations communes à la neuroscience informatique.
            Actuellement, elles se concentrent sur la modélisation
            compartimentale, avec des caractéristiques proches de GENESIS et
            NEURON. Un modèle de NEURON est fait de compartiments, souvent
            avec une forme cylindrique. Quand ils sont assez petits, ces
            cylindres à possibilité d'extension peuvent approximer quasiment
            toutes les géométries. Les classes futures pourront accepter les
            cinématiques de réaction-diffusion et bien plus. Une
            caractéristique clef de CONICAL est sa compatibilité à travers les
            plates-formes, il a été entièrement codéveloppé et testé sous
            Unix, DOS et Mac OS.</p></dd><dt>L'architecture neuronale de Jet</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://www.voltar-confed.org/jneural/">
                  www.voltar-confed.org/jneural/</a>
                </p></li></ul></div></p><p>L'architecture neuronale de Jet est un châssis C++ pour
            faire des projets de réseau neuronaux. Le but de ce projet était
            de faire une architecture neuronale rapide et flexible qui n'est
            pas limité à une sorte de réseau, et de s'assurer que
            l'utilisateur final pourra facilement écrire des applications
            utiles. De même, toute la documentation est facile d'accès.</p></dd><dt>Joone</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://joone.sourceforge.net">
                  joone.sourceforge.net</a>
                </p></li></ul></div></p><p>Joone est un châssis de réseau neuronal pour créer,
            entraîner et tester des réseaux neuronaux. Le but est de créer un
            environnement distribué pour des utilisateurs enthousiastes ou
            professionnels, basé à la fois sur JavaSpaces et sur les dernières
            technologies Java. Joone est composé d'un moteur central qui est
            le fulscrum de toute application qui existe déjà ou qui va être
            développé. Le moteur neuronal est modulaire, de taille réglable,
            multi-tâches et robuste. Tout le monde peut écrire de nouveaux
            modules pour implémenter de nouveaux algorithmes ou de nouvelles
            architectures à partir des simples composants distribués avec le
            moteur central. L'idée principale est de créer les bases pour
            promouvoir un million d'applications sur l'IA qui résolveront les
            problèmes autour du cœur de la structure.</p></dd><dt>Classe Matrice</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site FTP :<a href="http://ftp.cs.ucla.edu/pub/">
                  ftp.cs.ucla.edu/pub/</a>
                </p></li></ul></div></p><p>Une classe Matrice C++ simple, rapide et efficace conçue
            pour les scientifiques et les ingénieurs. La classe Matrice est
            tout à fait adaptée à des applications avec des algorithmes
            mathématiques complexes. A titre d'exemple de l'utilité la classe
            Matrice, elle a été utilisé pour implémenter l'algorithme de
            rétropropagation de l'erreur pour un réseau neuronal artificiel à
            réaction positive multi-couche.</p></dd><dt>Neural Networks at your Fingertips (Réseaux Neuronaux sur
          le bout des doigts)</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web : <a href="http://www.neural-networks-at-your-fingertips.com/">http://www.neural-networks-at-your-fingertips.com/</a>
                </p></li></ul></div></p><p>:TODO:</p></dd><dt>NEURObjects</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web : <a href="http://www.disi.unige.it/person/ValentiniG/NEURObjects/">http://www.disi.unige.it/person/ValentiniG/NEURObjects/</a>
                </p></li></ul></div></p><p>:TODO:</p></dd><dt>Pulcinella</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://iridia.ulb.ac.be/pulcinella/Welcome.html">
                  iridia.ulb.ac.be/pulcinella/Welcome.html</a>
                </p></li></ul></div></p><p>Pulcinella est écrit en Common Lisp, et semble être une
            bibliothèque de fonctions Lisp pour la créer, modifier et évaluer
            des systèmes valués. Alternativement, l'utilisateur peut choisir
            d'interagir avec Pulcinella via une interface graphique
            (disponible uniquement dans le CL Allegro). Pulcinella fournit les
            primitives pour construire et évaluer des modèles incertains en
            accord avec plusieurs calculs incertains, comprenant la théorie de
            la probabilité, la théorie de la possibilité, et la théorie des
            fonctions de croyance de Dempster-Shafer, et la théorie de la
            possibilité par Zadeh, Dubois et Prade. Un manuel est disponible
            sur demande.</p></dd><dt>ScnANNlib</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://www.sentinelchicken.org/projects/scnANNlib/">
                  www.sentinelchicken.org/projects/scnANNlib/</a>
                </p></li></ul></div></p><p>SCN Artificial Neural Network Library (Bibliothèque de
            réseau neuronal artificiel SCN) fournit un programmateur avec une
            API simple orientée objet pour construire des ANNs. Actuellement,
            la bibliothèque est compatible avec les réseaux non récursifs avec
            un nombre de couches arbitraires, chacune avec un nombre de nœuds
            arbitraires. Des installations existent pour s'entraîner
            avidement, et il existe des plans pour étendre gracieusement les
            fonctionnalités de la bibliothèque dans ses versions
            futures.</p></dd><dt>Applications du UTCS Neural Nets Research
          Group</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://www.cs.utexas.edu/users/nn/pages/software/software.html">
                  www.cs.utexas.edu/users/nn/pages/software/software.html</a>
                </p></li></ul></div></p><p>Cette entrée, un peu différemment des autres, est une
            référence à une collection de logiciels plutôt qu'à une seule
            application. Elle a été développée par le <a href="http://www.cs.utexas.edu/users/nn/pages/"> UTCS Neural Net
            Research Group</a> (Groupe de recherche sur les réseaux
            neuronaux UTCS). Voici un résumé des logiciels disponibles
            :</p><p><div class="itemizedlist"><ul><li><p>
                  Traitement du langage naturel <div class="itemizedlist"><ul><li><p>
                        MIR — Prototypage rapide basé sur TCL/TK pour le
                        traitement des phrases
                      </p></li><li><p>
                        SPEC — Analyse grammaticale des phrases
                        complexes
                      </p></li><li><p>
                        DISCERN — Traitement d'histoires basées sur les
                        scripts, comprenant :<div class="itemizedlist"><ul><li><p>
                              PROC — Analyse grammaticale, génération,
                              réponse à des questions
                            </p></li><li><p>
                              HFM — Organisation de la mémoire
                              épisodique
                            </p></li><li><p>
                              DISLEX — Traitement lexical
                            </p></li><li><p>
                              DISCERN — Le modèle intégré complet
                            </p></li></ul></div>
                      </p></li><li><p>
                        FGREPNET — Apprentissage des représentations
                        distribuées
                      </p></li></ul></div>
                </p></li><li><p>
                  Auto-organisation <div class="itemizedlist"><ul><li><p>
                        LISSOM — Carte auto-organisante avec des
                        connections latérales.
                      </p></li><li><p>
                        FM — Cartes auto-organisantes génériques
                      </p></li></ul></div>
                </p></li><li><p>
                  Neuroévolution <div class="itemizedlist"><ul><li><p>
                        Sous-populations disciplinées (ESP : Enforced
                        Sub-Populations) pour les taches de décision
                        séquentielle.<div class="itemizedlist"><ul><li><p>
                              Equilibrage de pôle double non
                              markoviens.
                            </p></li></ul></div>
                      </p></li><li><p>
                        Neuroévolution adaptive et symbiotique (SANE :
                        Symbiotic, Adaptive NeuroEvolution, prédécesseur
                        d'ESP)<div class="itemizedlist"><ul><li><p>
                              JavaSANE — Application Java pour appliquer
                              SANE à de nouvelles tâches.
                            </p></li><li><p>
                              SANE-C — Version C, prédécesseur de
                              JavaSANE.
                            </p></li><li><p>
                              Equilibrage de pôles — SANE de niveau neuronal
                              sur la tâche d'équilibrage de pôle.
                            </p></li></ul></div>
                      </p></li><li><p>
                        Programme de neuroévolution d'augmentation de
                        topologies (NEAT : NeuroEvolution of Augmenting
                        Topologies) pour l'évolution de réseau neuronaux
                        utilisant une structure.
                      </p></li></ul></div>
                </p></li></ul></div></p></dd><dt>Divers réseaux neuronaux (C++)</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://www.dontveter.com/nnsoft/nnsoft.html">
                  www.dontveter.com/nnsoft/nnsoft.html</a>
                </p></li></ul></div></p><p>Exemples de codes de réseaux neuronaux tirés du livre <a href="http://www.dontveter.com/basisofai/basisofai.html"> The
            Pattern Recognition Basics of AI</a>. Ce sont des exemples
            simples de codes de ces divers réseaux neuronaux. Ils fonctionnent
            correctement comme un bon point de départ pour des
            expérimentations simples et pour apprendre à quoi ressemble le
            code derrière les simulateurs. Les types de réseaux disponibles
            sur le site (codés en C++) sont :</p><p><div class="itemizedlist"><ul><li><p>
                  le paquetage Backprop
                </p></li><li><p>
                  Les algorithmes du plus proche voisin
                </p></li><li><p>
                  L'algorithme d'activation interactive
                </p></li><li><p>
                  Les algorithmes des machines de Hopfield et de
                  Boltzman
                </p></li><li><p>
                  Le classificateur de schéma linéaire
                </p></li><li><p>
                  ART I
                </p></li><li><p>
                  La mémoire associative bi-directionnelle
                </p></li><li><p>
                  Le réseau à rétropropagation et à réaction
                  positive.
                </p></li></ul></div></p></dd></dl></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N105A1" />A venir</h3></div></div></div><p>:TODO:</p></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="N105A6" />Informatique évolutive</h2></div></div></div><p>L'informatique évolutive est en réalité un terme général pour un
    grand nombre de techniques de programmation, y compris des algorithmes
    génétiques, systèmes adaptatifs complexes, programmation évolutive, etc.
    L'initiative principale de toutes ces techniques est l'idée d'évolution.
    L'idée qu'un programme pouvant évoluer vers un certain objectif puisse
    être écrit. Cet objectif peut être n'importe où entre la résolution d'un
    problème scientifique et la victoire dans un jeu.</p><p>:TODO:</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="N105AD" />A venir</h2></div></div></div><p>:TODO:</p></div><div class="section" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="N105B2" />Les agents</h2></div></div></div><p>Aussi connus sous le nom d'agents intelligents ou simplement agents,
    ce domaine de recherche en IA traite de petites applications destinées à
    aider l'utilisateur(trice) dans son travail. Ils peuvent être mobiles
    (capables de stopper leur exécution sur une machine et de la relancer sur
    une autre) ou statiques (en demeurant dans une seule machine). Ils sont le
    plus souvent spécifiques à une tâche (donc relativement simples) et conçus
    pour aider l'utilisateur à la manière d'un assistant. Jusqu'à présent,
    l'utilisation la plus courante (c'est à dire la plus largement répandue)
    de ce type d'application concerne les robots d'indexation, que beaucoup de
    moteurs de recherche utilisent (ex.: webcrawler).</p><div class="glosslist"><dl><dt>Agent</dt><dd><div class="itemizedlist"><ul><li><p>
              Site FTP : <a href="ftp://www.cpan.org/modules/by-category/23_Miscellaneous_Modules/Agent/">
              www.cpan.org/modules/by-category/23_Miscellaneous_Modules/Agent/</a>
            </p></li></ul></div><p>Agent est le prototype d'un système "Information Agent". Il
          est à la fois multiplateforme et multilangue, car il stocke les
          informations récoltées dans de simples chaînes de caractères
          condensées. Il peut être condensé et transporté à travers le réseau
          dans n'importe quel format, car l'agent peut s'autobloquer dans son
          état initial.</p></dd><dt>agentTool</dt><dd><div class="itemizedlist"><ul><li><p>
              Site Web : <a href="http://en.afit.af.mil/ai/agentool.htm">en.afit.af.mil/ai/agentool.htm</a>
            </p></li><li><p>
              Site de téléchargement : <a href="http://en.afit.af.mil/ai/registration.htm">en.afit.af.mil/ai/registration.htm</a>
            </p></li></ul></div><p>Autre cadre de développement d'agent conçu en Java. Il est
          assez unique dans le fait qu'il s'appuie sur l'utilisation d'une
          interface graphique pour concevoir le système qui va "synthétiser
          semi-automatiquement des systèmes multiagents pour répondre à ces
          exigences". Il vous faut un navigateur compatible java pour pouvoir
          télécharger le logiciel. :P</p></dd><dt>Aglets Workbench</dt><dd><div class="itemizedlist"><ul><li><p>
              Site Web : <a href="http://www.trl.ibm.com/aglets/index_e.htm">www.trl.ibm.com/aglets/index_e.htm</a>
            </p></li></ul></div><p>Un aglet est un objet Java qui peut se déplacer d'un hôte à un
          autre sur Internet. Cela veut dire qu'un aglet s'exécutant sur une
          machine peut brusquement arrêter son exécution, s'expédier sur une
          machine distante, et reprendre son déroulement sur son nouvel hôte.
          Quand l'aglet se déplace, il emporte aussi bien son code source que
          son état (ses données). Un mécanisme de sécurité intégré sécurise
          l'accueil d'aglets d'origine incertaine pour l'hôte. L'API d'Aglet
          Java (J-AAPI) est un standard proposé au public pour interfacer les
          aglets et leur environnement. J-AAPI contient des fonctions pour
          initialiser les aglets, gérer les messages et expédier, retirer,
          activer ou désactiver, cloner, ou se débarrasser de l'aglet. J-AAPI
          est simple, souple, et stable. Les développeurs d'applications
          peuvent coder des aglets multiplateformes en considérant qu'ils
          peuvent fonctionner sur n'importe quelle machine supportant
          J-AAPI.</p></dd><dt>A.L.I.C.E.</dt><dd><div class="itemizedlist"><ul><li><p>
              Site Web : <a href="http://www.alicebot.org">www.alicebot.org</a>
            </p></li></ul></div><p>Le logiciel ALICE implémente l'AIML (Artificial Intelligence
          Markup Language), un langage à balise non standard en évolution,
          permettant de créer des robots de "chat". La caractéristique de base
          de sa conception est minimaliste. Comparé à d'autres langages de
          robot de "chat", l'AIML est peut-être le plus simple. Le langage de
          filtrage est très simple, ne permettant par exemple qu'un seul
          caractère joker ('*') de comparaison par filtre. L'AIML est un
          langage XML, ce qui implique qu'il obéit à certaines méta-règles
          grammaticales. Le choix d'une syntaxe XML rend possible
          l'intégration avec d'autres outils tels que des éditeurs XML. Une
          autre motivation du choix du XML est son apparence familière,
          particulièrement pour les personnes expérimentée en HTML.</p></dd><dt>Ara</dt><dd><div class="itemizedlist"><ul><li><p>
              Site Web : <a href="http://wwwagss.informatik.uni-kl.de/Projekte/Ara/index_e.html">wwwagss.informatik.uni-kl.de/Projekte/Ara/index_e.html</a>
            </p></li></ul></div><p>Ara est une plateforme d'exécution sûre et portable d'agents
          mobiles dans les réseaux hétérogènes. Dans ce contexte, les agents
          mobiles sont des programmes ayant la capacité de changer de machine
          hôte pendant leur exécution tout en préservant leur état interne.
          Cela leur permet de gérer des opérations localement, plutôt que de
          devoir les effectuer à distance. Par rapport aux plateformes du même
          type, le but précis d'Ara est de fournir des fonctionnalités
          complètes d'agent mobile, tout en maintenant autant que possible des
          modèles et langages de programmation établis.</p></dd><dt>BattleBots</dt><dd><div class="itemizedlist"><ul><li><p>
              Site Web : <a href="http://www.bluefire.nu/droidbattles/">www.bluefire.nu/droidbattles/</a>
            </p></li></ul></div><p>Jeu de programmation d'IA où l'on conçoit un robot en
          choisissant du matériel et en programmant son unité centrale, puis
          en faisant des compétitions avec d'autres robots. Les compétitions
          peuvent engager des équipes et des règles spéciales pour un
          jeu.</p><p>Le matériel disponible pour concevoir votre robot comprend des
          armes, un moteur, des scanners, un microprocesseur, etc. Le langage
          de programmation dépend du type de votre CPU et est similaire à un
          langage d'assemblage.</p></dd><dt>Bee-gent</dt><dd><div class="itemizedlist"><ul><li><p>
              Site Web : <a href="http://www2.toshiba.co.jp/beegent/index.htm">www2.toshiba.co.jp/beegent/index.htm</a>
            </p></li></ul></div><p>Bee-gent est un nouveau type de cadre de développement car
          c'est un système d'agent à 100%. Par opposition à d'autres systèmes
          qui ne font qu'une utilisation partielle des agents, Bee-gent
          "agentifie" complètement la communication qui a lieu entre les
          applications logicielles. Les applications deviennent des agents, et
          tous les messages sont transportés par les agents. Ainsi, Bee-gent
          permet aux développeurs de construire des systèmes ouverts,
          distribués et souples, qui permettent une utilisation optimale des
          applications existantes.</p></dd><dt>Bond</dt><dd><div class="itemizedlist"><ul><li><p>
              Site Web : <a href="http://bond.cs.ucf.edu/">bond.cs.ucf.edu/</a>
            </p></li></ul></div><p>Encore un autre système d'agent en Java...</p><p>Bond est un système d'objets distribués conçu en Java et un
          cadre d'agent. Il met en application un logiciel médian basé sur des
          messages et des services associés tels qu'un annuaire, la
          persistance, la surveillance et la sécurité. Bond permet de
          construire facilement des applications réparties multiagents. Une
          autre application future de Bond est le Laboratoire Virtuel
          supportant l'annotation d'informations et l'informatique répartie à
          grande échelle.</p></dd><dt>Cadaver</dt><dd><div class="itemizedlist"><ul><li><p>
              Site Web : <a href="http://www.erikyyy.de/cadaver/">www.erikyyy.de/cadaver/</a>
            </p></li></ul></div><p>Cadaver simule en temps réel des cyborgs et la nature. Le
          champ de bataille est constitué de forêts, de blé, d'eau, d'herbe,
          de carcasses (bien sûr) et de plein d'autres choses. Le serveur de
          jeu contrôle le jeu et les règles. Vous démarrez le serveur et
          connectez quelques clients. Les clients communiquent avec le serveur
          en utilisant un protocole très primitif. Ils peuvent donner l'ordre
          aux cyborgs de moissonner le blé, d'attaquer des ennemis ou de
          couper du bois. Le jeu n'est pas destiné à être joué par des
          humains! Il y a beaucoup trop de choses à contrôler. Réservé aux
          experts : vous pouvez uniquement vous connecter au serveur par
          telnet et entrer les commandes manuellement. Mais l'idée est plutôt
          que vous écriviez des clients dotés d'une intelligence artificielle
          pour battre les autres intelligences artificielles. Vous pouvez
          sélectionner un langage (et un système d'exploitation) de votre
          choix pour effectuer cette tâche. Il n'y a qu'à écrire un programme
          qui communique sur les canaux d'entrée et de sortie standard. Puis
          vous pouvez employer des programmes tels que "socket" pour connecter
          vos clients au serveur. Il n'est PAS nécessaire d'écrire du code
          TCP/IP, bien que je l'ai fait :) La bataille ne sera pas ennuyeuse,
          donc vous disposez du client appelé "spyboss" qui affiche
          graphiquement l'action à l'écran.</p></dd><dt>Cougaar</dt><dd><div class="itemizedlist"><ul><li><p>
              Site Web : <a href="http://www.cougaar.org/">www.cougaar.org/</a>
            </p></li></ul></div><p>Cougaar est une architecture Java pour la construction
          d'applications à base d'agents distribués à grande échelle. C'est le
          produit de plusieurs années de recherche dans le cadre du projet
          DARPA sur les systèmes d'agents à grande échelle, et il inclut non
          seulement l'architecture du noyau mais aussi un ensemble de
          composants de démonstration, de visualisation et d'administration
          pour simplifier le développement d'applications complexes et
          distribuées. [Encore un autre système d'agents conçu en Java —
          ed.]</p></dd><dt>D'Agent (anciennement AGENT TCL)</dt><dd><div class="itemizedlist"><ul><li><p>
              Site Web : <a href="http://agent.cs.dartmouth.edu/software/agent2.0/">agent.cs.dartmouth.edu/software/agent2.0/</a>
            </p></li><li><p>
              Site FTP : <a href="ftp://agent.cs.dartmouth.edu/pub/agents/">agent.cs.dartmouth.edu/pub/agents/</a>
            </p></li></ul></div><p>Un agent transportable est un programme qui peut migrer d'une
          machine à une autre dans un réseau hétérogène. Le programme choisit
          où et quand il va migrer. Il peut suspendre son exécution à un
          certain point, se déplacer sur une autre machine et reprendre
          l'exécution sur la nouvelle machine. Par exemple, un agent
          transportant un courrier électronique migre d'abord vers le routeur
          et ensuite vers la boîte mail du destinataire. L'agent peut
          effectuer arbitrairement un traitement complexe sur chaque machine
          afin de s'assurer que le message atteint le bon destinataire.</p></dd><dt>Dunce</dt><dd><div class="itemizedlist"><ul><li><p>
              Site Web : <a href="http://www.boswa.com/misc/dunce/">www.boswa.com/misc/dunce/</a>
            </p></li></ul></div><p>Dunce est un simple robot de "chat" (IA conversationnelle) et
          un langage pour programmer ce type de robots. Il emploie un filtrage
          d'expressions rationnelles de base et un mécanisme semi-neuronal de
          lancement de règles et de réponses (avec des cycles accélération /
          ralentissement d'activité).</p></dd><dt>FIPA-OS</dt><dd><div class="itemizedlist"><ul><li><p>
              Site Web : <a href="http://fipa-os.sourceforge.net/">fipa-os.sourceforge.net/</a>
            </p></li><li><p>
              Site Web secondaire : <a href="http://www.nortelnetworks.com/products/announcements/fipa/">www.nortelnetworks.com/products/announcements/fipa/</a>
            </p></li></ul></div><p>FIPA-OS est l'implémentation "open source" des éléments
          obligatoires contenus dans la spécification FIPA nécessaires à
          l'interopérabilité des agents. En plus d'être compatible avec le
          concept d'interopérabilité de FIPA, FIPA-OS fournit également une
          architecture basée sur des composants permettant le développement
          d'agents spécifiques à un domaine, pouvant utiliser les services des
          agents de la plateforme FIPA. Il est implémenté en Java.</p></dd><dt>FishMarket</dt><dd><div class="itemizedlist"><ul><li><p>
              Site Web : <a href="http://www.iiia.csic.es/Projects/fishmarket/newindex.html">www.iiia.csic.es/Projects/fishmarket/newindex.html</a>
            </p></li></ul></div><p>FM — Le projet FishMarket mené par l' "Artificial Intelligence
          Research Institute" (IIIA-CSIC) tente d'apporter sa contribution
          dans cette direction en développant FM, une maison de ventes aux
          enchères électronique gérée par des agents, qui a été transformée en
          banc d'essai pour les marchés d'enchères électroniques. Le cadre,
          conçu et mis en application comme extension de FM96.5 (une version
          Java de la maison de ventes de Fishmarket), permet de définir des
          scénarii de transactions basés sur les enchères à la criée (enchères
          hollandaises). FM fournit un cadre où les concepteurs d'agent
          peuvent réaliser des expériences contrôlées de telle manière qu'une
          multitude de scénarii de marchés expérimentaux — que nous
          considérons comme scénarii de compétition du fait de la nature
          concurrentielle du domaine — d'un réalisme et d'une complexité plus
          ou moins forts peuvent être établis, activés, et enregistrés ; et de
          telle manière que les agents hétérogènes (humains et logiciels)
          d'échange (acheteur et vendeur) peuvent être comparés, accordés et
          évalués.</p></dd><dt>GNU Robots</dt><dd><div class="itemizedlist"><ul><li><p>
              Site Web : <a href="http://www.gnu.org/software/robots/robots.html">www.gnu.org/software/robots/robots.html</a>
            </p></li></ul></div><p>GNU Robots est un jeu / divertissement où il vous faut
          construire un programme pour un petit robot, puis le regarder
          explorer un monde. Le monde en question est rempli de méchants qui
          peuvent vous blesser, d'objets dans lesquels vous pouvez frapper, et
          de nourriture que vous pouvez manger. Le but de ce jeu est de
          collecter autant de prix que possible avant d'être tué par un ennemi
          ou d'être à court d'énergie. Les robots peuvent être écrits en
          script "Guile" ou en utilisant une interface graphique.</p></dd><dt>Grasshopper</dt><dd><div class="itemizedlist"><ul><li><p>
              Site Web : <a href="http://www.grasshopper.de/">www.grasshopper.de/</a>
            </p></li></ul></div><p>Autre système d'agent en Java. Possède de nombreuses
          fonctionnalités et est activement développé. Commercial mais libre.
          Orienté à l'origine vers les systèmes embarqués.</p></dd><dt>Hive</dt><dd><div class="itemizedlist"><ul><li><p>
              Site Web : <a href="http://hive.sourceforge.net/">hive.sourceforge.net/</a>
            </p></li></ul></div><p>Hive est une plateforme logicielle en Java pour créer des
          applications réparties. En utilisant Hive, les programmeurs peuvent
          facilement créer des systèmes qui se connectent et utilisent des
          données provenant d'internet. Au fond, Hive est un environnement
          d'évolution pour les agents distribués, qui communiquent et se
          déplacent pour accomplir des tâches. Nous essayons de rendre
          Internet vivant.</p></dd><dt>ICM</dt><dd><div class="itemizedlist"><ul><li><p>
              Site Web : <a href="http://www.nar.fujitsulabs.com/">www.nar.fujitsulabs.com/</a>
            </p></li><li><p>
              Site sur SourceForge : <a href="http://sourceforge.net/projects/networkagent/">sourceforge.net/projects/networkagent/</a>
            </p></li></ul></div><p>Inter-Agent Communication Model (ICM, Modèle de Communication
          Inter-agents) est un mécanisme de communication pouvant être utilisé
          pour envoyer des messages entre agents en mode asynchrone. Son
          domaine d'application prévu est le mécanisme de transport pour les
          langages de communication d'agent (ACLs), comme KQML et ACL de
          FIPA.</p></dd><dt>Jacomma</dt><dd><div class="itemizedlist"><ul><li><p>
              Site Web : <a href="http://jacomma.sourceforge.net/">jacomma.sourceforge.net/</a>
            </p></li><li><p>
              Site sur SourceForge : <a href="http://sourceforge.net/projects/jacomma/">sourceforge.net/projects/jacomma/</a>
            </p></li></ul></div><p>Jacomma est une plateforme / un cadre de développement pour
          développer des agents d'information distribués, mobiles et réactifs,
          avec des capacités de communication hétérogène, en Java et
          Jpython.</p><p>Jacomma fournit un cadre de développement et un environnement
          d'exécution, qui repose sur l'infrastructure "Inter-Agent
          Communication Model". ICM définit un protocole de communication, une
          architecture de stockage et d'expédition de messages, et une
          infrastructure de communication bas niveau pour l'échange de
          messages. La communication est réellement asynchrone, basée sur des
          sockets TCP.</p><p>Il y a une rubrique sur ICM dans ce guide, vous pouvez
          également le trouver via un lien à partir de ce site.</p></dd><dt>Jade</dt><dd><div class="itemizedlist"><ul><li><p>
              Site Web : <a href="http://sharon.cselt.it/projects/jade/">sharon.cselt.it/projects/jade/</a>
            </p></li></ul></div><p>JADE (Java Agent DEvelopment Framework) est un cadre de
          développement logiciel complètement implémenté en langage Java. Cela
          simplifie l'implémentation de systèmes multiagents à travers un
          logiciel médian dont on est assuré qu'il est conforme aux
          spécifications de la FIPA, et à travers un ensemble d'outils
          permettant le débuggage et la phase de déploiement. La plateforme
          d'agents peut être distribuée entre diverses machines (qui n'ont
          même pas besoin de partager le même système d'exploitation) et sa
          configuration peut être réalisée au moyen d'une interface graphique
          distante. La configuration peut même être changée au cours de
          l'exécution, en déplaçant les agents d'une machine à une autre, au
          fur et à mesure que cela est nécessaire.</p></dd><dt>JAM Agent</dt><dd><div class="itemizedlist"><ul><li><p>
              Site Web : <a href="http://www.marcush.net/IRS/irs_downloads.html">www.marcush.net/IRS/irs_downloads.html</a>
            </p></li></ul></div><p>JAM accepte aussi bien les modes de raisonnement descendant (à
          base de buts à atteindre) que les modes de raisonnement ascendant (à
          partir des données). JAM choisit ses objectifs et plans selon la
          priorité maximale si le raisonnement métaniveau n'est pas utilisé,
          ou sur les plans de raisonnement métaniveau développés par
          l'utilisateur si ceux-ci existent. Pour JAM, la conceptualisation
          des objectifs et l'accomplissement des objectifs est définie plus
          classiquement (UMPRS est plus basé sur les performances
          comportementales que véritablement sur les objectifs) et fait la
          distinction entre les plans pour atteindre un objectif et les plans
          qui encodent simplement les comportements. Les objectifs-type
          implémentés incluent la réalisation (atteindre un état donné du
          système), la maintenance (atteindre de nouveau cet état donné du
          système), et la performance. L'exécution simultanée d'objectifs
          multiples est possible, avec une capacité de suspension et de
          reprise pour chaque processus d'objectif (c-à-d d'intention). Les
          plans de JAM ont des propriétés explicites de condition à priori et
          de fonctionnement qui restreignent leur applicabilité, une propriété
          de condition à posteriori et une section des propriétés du plan sont
          utilisées pour définir des caractéristiques spécifiques à un plan ou
          un domaine. Les constructions de plan disponibles incluent :
          l'ordonnancement, l'itération, les objectifs partiels, les segments
          de plan atomiques (c-à-d non-interruptible), l'exécution
          conditionnelle non déterministe et déterministe à n-branche,
          l'exécution parallèle de segments de plan multiples, la
          synchronisation basée sur l'état donné du système ou les objectifs,
          une section de manipulation des défaillances explicite, et la
          définition de primitives de fonction Java au moyen de sa
          construction dans JAM aussi bien que l'invocation de membres de
          classe prédéfinies (c-à-d propriétaire) via les capacités de
          réflexion de Java, sans avoir à le construire dans JAM.</p></dd><dt>JATLite</dt><dd><div class="itemizedlist"><ul><li><p>
              Site Web : <a href="http://java.stanford.edu/">java.stanford.edu/</a>
            </p></li></ul></div><p>JATLite fournit un ensemble de paquetages Java qui facilite la
          conception de systèmes multiagents en Java. JATLite fournit
          seulement un ensemble petit et léger de paquetages, de sorte que les
          développeurs puissent se débrouiller avec tous les paquetages avec
          un minimum d'efforts. Pour plus de souplesse, JATLite fournit quatre
          couches différentes, d'une implémentation abstraite à une
          implémentation "Router". Un utilisateur peut accéder à n'importe
          quelle couche fournie. Chaque couche est basée sur un ensemble de
          postulats différents. L'utilisateur peut choisir la couche
          appropriée selon les postulats de la couche et de l'application de
          l'utilisateur. La page d'introduction présente les fonctionnalités
          de JATLite et l'ensemble des postulats de chaque couche.</p></dd><dt>JATLiteBeans</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://waitaki.otago.ac.nz/JATLiteBean/">waitaki.otago.ac.nz/JATLiteBean/</a>

               
            </p></li></ul></div><div class="itemizedlist"><ul><li><p>Interface de JATLite améliorée et maniabilité accrue,
              comprenant l'envoi, la réception et l'analyse lexicale des
              messages KQML</p></li><li><p>
               Architecture extensible pour la gestion des messages et l'administration "thread of control" (NdT : unité d'exécution) des agents 
            </p></li><li><p>
               Fonctions utiles pour l'analyse lexicale du contenu de messages KQML simples 
            </p></li><li><p>
              JATLiteBean permet la transmission automatique aux agents
              animateurs de l'information sur les capacités des agents
            </p></li><li><p>
               Gestion automatique, facultative de la directive "forward" 
            </p></li><li><p>
               Analyseur lexical des fichiers génériques de configuration 
            </p></li><li><p>
               Vérificateur syntaxique de KQML 
            </p></li></ul></div></dd><dt>Java(tm) Agent Template</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www-cdr.stanford.edu/ABE/JavaAgent.html">www-cdr.stanford.edu/ABE/JavaAgent.html</a>

               
            </p></li></ul></div><p>Le JAT fournit un modèle pleinement fonctionnel, écrit
          entièrement en langage Java, qui permet de construire des agents
          logiciels qui communiquent en poste-à-poste ("peer-to-peer") avec
          une communauté d'autres agents répartis sur Internet. Bien que des
          portions du code utilisé dans chaque agent soient portables, les
          agents JAT ne sont pas mobiles mais restent statiques sur une seule
          machine. Ce comportement est en opposition à beaucoup d'autres
          technologies "agent". (Cependant, en utilisant le RMI Java, les
          agents JAT pourraient se déplacer dynamiquement sur une machine
          extérieure par l'intermédiaire d'un agent résidant sur cette seconde
          machine). Actuellement, tous les messages d'agent emploient KQML
          comme protocole de haut niveau ou comme emballeur de message. Le JAT
          possède une fonctionnalité pour échanger dynamiquement les
          "Ressources", qui peuvent inclure des classes Java (ex.: nouveaux
          langages ou interpréteurs, services distants, etc.), des fichiers de
          données et des informations intégrés dans les messages KQML.</p></dd><dt>Khepera Simulator</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://diwww.epfl.ch/lami/team/michel/khep-sim/index.html">diwww.epfl.ch/lami/team/michel/khep-sim/index.html</a>

               
            </p></li></ul></div><p>Khepera Simulator est un paquetage logiciel du domaine public
          écrit par <a href="http://diwww.epfl.ch/lami/team/michel/">Olivier MICHEL</a>
          pendant la préparation de son doctorat, au Laboratoire I3S, URA 1376
          du CNRS et de l'Université de Nice-Sophia Antipolis, en France. Il
          permet d'écrire son propre contrôleur en langage C ou C++ pour le
          robot mobile Khepera, de le tester dans un environnement simulé, et
          comporte une belle interface graphique X11 colorée. De plus, si vous
          possédez un robot Khepera, le simulateur peut commander le vrai
          robot en utilisant le même algorithme de contrôle. Il est
          principalement destiné aux chercheurs étudiant les agents
          autonomes.</p></dd><dt>Lyntin</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://lyntin.sourceforge.net/">lyntin.sourceforge.net/</a>

               
            </p></li></ul></div><p>Lyntin est un client "Mud" (Multi-User Dialog, dialogue
          multi-utilisateur) extensible et un cadre de développement d'agents
          autonomes, ou de robots, aussi bien que tout ce qui approche le
          "mudding" en général. Lyntin est basé sur du Python, langage de
          programmation amusant, dynamique et orienté objet, basé sur
          TinTin++, un beau client "mud".</p></dd><dt>Mole</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://mole.informatik.uni-stuttgart.de/">mole.informatik.uni-stuttgart.de/</a>

               
            </p></li></ul></div><p>Mole est un système d'agent compatible avec les agents mobiles
          programmés en Java. Les agents de Mole sont un regroupement
          d'objets, qui n'ont pas de référence vers l'extérieur, et qui dans
          l'ensemble travaillent sur des tâches données par l'utilisateur ou
          par d'autres agents. Ils ont la capacité d'évoluer sur un réseau
          d'"emplacements" de façon autonome. Ces "emplacements" sont une
          abstraction de nœuds réels, qui existent dans le réseau
          sous-jacent. Ils peuvent accéder à des ressources de nature locale,
          en communiquant avec les agents dédiés représentant ces services.
          Les agents sont capables d'utiliser les services fournis par
          d'autres agents et de fournir également des services.</p></dd><dt>Narval</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.logilab.fr/narval.html">www.logilab.fr/narval.html</a>

               et 

              <a href="http://www.logilab.org/projects/narval">www.logilab.org/projects/narval</a>

               
            </p></li></ul></div><p>Narval signifie Assistant Réseau pour la Visualisation de
          Ressources et Langage d'Agent ("Network Assistant for Ressources
          Visualization and Agent Language"). C'est un assistant personnel en
          réseau basé sur l'intelligence artificielle et les technologies
          d'agent. Il exécute des recettes (séquences d'actions) pour
          effectuer ses tâches. Il est très facile de définir une nouvelle
          action grâce à du XML et de l'implémenter en utilisant Python. Les
          recettes peuvent être codées et déboguées au moyen d'une interface
          graphique.</p></dd><dt>NeL</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.nevrax.org/">www.nevrax.org/</a>

               
            </p></li></ul></div><p>NeL est en fait une bibliothèque de développement de jeux
          (pour les jeux multijoueurs massifs), mais je le signale ici car il
          devrait inclure une bibliothèque d'IA assez considérable. Voici une
          notice tirée du livre blanc :</p><p>Le but de cette bibliothèque d'IA est de fournir une approche
          pragmatique pour créer une plateforme d'agents distribués. Elle est
          centrée sur les agents ; des entités individuelles communiquant
          indépendamment de l'endroit, en utilisant un modèle
          action-réaction.</p></dd><dt>OAA</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.ai.sri.com/~oaa/">www.ai.sri.com/~oaa/</a>

               
            </p></li></ul></div><p>"Open Agent Architecture" (Architecture Ouverte d'Agents) est
          un cadre dans lequel une communauté d'agents logiciels s'exécutant
          sur des machines distribuées peuvent travailler ensemble sur des
          tâches assignées par des participants de la communauté, humains ou
          non. La coopération distribuée et la communication haut-niveau sont
          deux idées centrales à l'origine d'OAA.</p><p>Il définit un langage de communication inter-agent et est
          compatible avec de multiples plateformes et langages de
          programmation.</p></dd><dt>PAI</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://utenti.quipo.it/claudioscordino/pai.html">utenti.quipo.it/claudioscordino/pai.html</a>

               
            </p></li></ul></div><p>PAI ("Programmable Artificial Intelligence", Intelligence
          Artificielle Programmable) est un programme capable de soutenir une
          conversation dans sa langue maternelle, l'anglais. Ecrit en
          C++.</p></dd><dt>Penguin!</dt><dd><div class="itemizedlist"><ul><li><p>
               Site FTP : 

              <a href="ftp://www.cpan.org/modules/by-category/23_Miscellaneous_Modules/Penguin/FSG/">www.cpan.org/modules/by-category/23_Miscellaneous_Modules/Penguin/FSG/</a>

               
            </p></li></ul></div><p>Penguin est un module Perl version 5. Il vous fournira un
          ensemble de fonctions qui vous permettront de : <div class="itemizedlist"><ul><li><p>
                 envoyer du code Perl crypté, avec signature numérique vers une machine distante où il sera exécuté. 
              </p></li><li><p>
                 recevoir du code et, selon le signataire du message, l'exécuter dans un compartiment arbitrairement sécurisé et limité. 
              </p></li></ul></div> La combinaison de ces fonctions permet le codage
          direct en Perl d'algorithmes qui permettent un commerce électronique
          sûr, des agents mobiles de récupération d'information, des
          applications d'aide à la navigation en contenu temps réel sur
          Internet ("live content"), le calcul distribué à répartition de
          charge, la mise à jour de logiciel à distance, l'administration de
          machines distantes, la propagation d'information basée sur le
          contenu, les applications de données partagées à travers Internet,
          les générateurs d'applications réseau, et ainsi de suite.</p></dd><dt>Ps-i</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://ps-i.sourceforge.net/">ps-i.sourceforge.net/</a>

               
            </p></li></ul></div><p>Ps-i est un environnement permettant d'effectuer des
          simulations basées sur des agents. Il est multiplateforme, et un
          exécutable est disponible pour Win32. Ses fonctionnalités sont :
          <div class="itemizedlist"><ul><li><p>
                 langage déclaratif pour la spécification des modèles 
              </p></li><li><p>
                 langage de script Tcl/Tk conforme aux normes industrielles avec optimisation intégrée des sous-programmes, évaluation spéculative, de plus les utilisateurs du compilateur JIT xf86 pourront créer des modèles complexes sans dégradation de performance 
              </p></li><li><p>
                 interface conviviale 
              </p></li><li><p>
                 sauvegarde et restauration du déroulement du programme 
              </p></li><li><p>
                 changement des paramètres du modèle à la volée 
              </p></li><li><p>
                 visualisation des données : affichage d'agent par champs avec de multiples formes et couleurs, fenêtre de statistiques, visionneur d'agents, explorateur de sous-programmes et outil de mise en surbrillance d'agents 
              </p></li></ul></div></p></dd><dt>RealTimeBattle</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.lysator.liu.se/realtimebattle/">www.lysator.liu.se/realtimebattle/</a>

               
            </p></li></ul></div><p>RealTimeBattle (Bataille Temps Réel) est un jeu de
          programmation dans lequel les robots, contrôlés par des programmes,
          se battent les uns contre les autres. L'objectif est de détruire ses
          ennemis, à l'aide du radar pour observer les alentours et du canon
          pour tirer. <div class="itemizedlist"><ul><li><p>
                 Le jeu se déroule en temps réel, le programme du robot s'exécutant en tant que processus fils de RealTimeBattle. 
              </p></li><li><p>
                 Les robots communiquent avec le programme principal via l'entrée et la sortie standard. 
              </p></li><li><p>
                 Les robots peuvent être construits dans presque n'importe quel langage de programmation. 
              </p></li><li><p>
                 Autant de robots que voulu peuvent concourir simultanément si le système d'exploitation le permet. 
              </p></li><li><p>
                 Un langage de transmission de messages simple est utilisé pour communiquer, ce qui facilite le début de la construction de robots. 
              </p></li><li><p>
                 Les robots se comportent comme des objets physiques réels. 
              </p></li><li><p>
                 Vous pouvez créer vos propres arènes. 
              </p></li><li><p>
                 Hautement configurable. 
              </p></li></ul></div></p></dd><dt>Remembrance Agents</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.remem.org/">www.remem.org/</a>

               
            </p></li></ul></div><p>Remembrance Agents (les Agents du Souvenir) sont un ensemble
          d'applications qui veillent sur l'utilisateur et suggèrent des
          informations concernant la situation actuelle. Tandis que les moyens
          mnémoniques basés sur des requêtes aident à la remémoration directe,
          les agents de souvenir sont une mémoire associative étendue. Par
          exemple, la version du traitement de texte de RA met continuellement
          à jour une liste de documents en rapport avec ce qui est saisi ou lu
          dans un tampon d'emacs. Ces documents suggérés peuvent être
          n'importe quel fichier texte qui pourrait être en rapport avec ce
          que vous êtres en train d'écrire ou de lire. Ils pourraient être de
          vieux courriers électroniques liés au courrier que vous êtes en
          train de lire, ou des résumés de la recherche et des articles de
          journaux qui traitent du même sujet que ce que vous écrivez.</p></dd><dt>RoboTournament</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://robotournament.sourceforge.net/">robotournament.sourceforge.net/</a>

               
            </p></li></ul></div><p>RoboTournament est un jeu inspiré de RoboRally où les joueurs
          programment leurs robots pour vaincre leurs adversaires. Les
          fonctionnalités de RoboTournament sont : types de jeu multiples :
          match à mort, rallye et capture de drapeau. Multijoueurs via TCP/IP,
          six armes y compris le BFG, un éditeur de cartes, et une grande
          variété d'éléments de tableau de bord.</p></dd><dt>SimRobot</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.informatik.uni-bremen.de/simrobot/index_e.htm">www.informatik.uni-bremen.de/simrobot/index_e.htm</a>

               
            </p></li><li><p>
               Site FTP : 

              <a href="ftp://ftp.uni-bremen.de/pub/ZKW/INFORM/simrobot/">ftp.uni-bremen.de/pub/ZKW/INFORM/simrobot/</a>

               
            </p></li></ul></div><p>SimRobot est un programme de simulation de robots avec
          capteurs dans un environnement 3D. Ecrit en C++, il fonctionne sous
          Unix et X11 et requiert la boîte à outils graphique Xview.
          <div class="itemizedlist"><ul><li><p>
                 Simulation de la cinématique du robot 
              </p></li><li><p>
                 Définition de scène construite hiérarchiquement par l'intermédiaire d'une langue de définition simple 
              </p></li><li><p>
                 Divers capteurs intégrés : appareil photo, œil à facettes, mesure de distances, capteur de luminosité, etc. 
              </p></li><li><p>
                 Les objets sont définis comme des polyèdres 
              </p></li><li><p>
                 Emetteur défini abstraitement : peut être interprété par exemple comme lumière ou bruit 
              </p></li><li><p>
                 Images d'appareil-photo calculées selon les algorithmes de raytracing ou de Z-buffer que l'on connaît par l'infographie 
              </p></li><li><p>
                 Interface logicielle de capteur/moteur spécifique pour communiquer avec la simulation 
              </p></li><li><p>
                 Mappage de textures sur les surfaces de l'objet : bitmaps dans divers formats 
              </p></li><li><p>
                 Visualisation complète de la scène : rendu en fil de fer sans lignes cachées, ni valeurs de capteur ou d'acteur 
              </p></li><li><p>
                 Le contrôle des agents et l'opération dans l'environnement sont aussi bien interactifs que traités par lots 
              </p></li><li><p>
                 Détection des collisions 
              </p></li><li><p>
                 Capacité d'extension grâce à des types d'objet définis par l'utilisateur 
              </p></li><li><p>
                 Communication par socket possible vers, par exemple, le logiciel de traitement d'image Khoros 
              </p></li></ul></div></p></dd><dt>Sulawesi</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://wearables.essex.ac.uk/sulawesi/">wearables.essex.ac.uk/sulawesi/</a>

               
            </p></li></ul></div><p>Un cadre de développement appelé Sulawesi a été conçu et
          implémenté pour aborder ce qui est considéré comme des défis
          importants dans les interfaces utilisateur tout usage [NdT : en
          anglais le terme wearable est utilisé, pour exprimer la possibilité
          d'un système que l'on peut emporter sur soi, intégré ou non aux
          vêtements] : la capacité d'accepter une entrée venant de n'importe
          quel nombre de modalités, et d'effectuer au besoin une traduction
          vers n'importe quel nombre de sorties modales. Cela est fait
          principalement au moyen d'un ensemble d'agents qui agissent par
          anticipation sur l'entrée.</p></dd><dt>TclRobots</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.nyx.net/~tpoindex/">www.nyx.net/~tpoindex/</a>

               
            </p></li></ul></div><p>TclRobots est un jeu de programmation, semblable à « Core War
          ». Pour jouer à TclRobots, vous devez écrire un programme en Tcl qui
          contrôle un robot. La mission du robot est de survivre à une
          bataille contre d'autres robots. Deux, trois ou quatre robots
          combattent pendant une bataille, chacun utilisant un programme
          différent (ou éventuellement le même programme dans différents
          robots). Chaque robot est équipé avec un radiomètre à balayage, un
          canon, et un mécanisme de déplacement. Un duel ne s'arrête que
          lorsqu'il ne reste qu'un seul robot opérationnel. Les robots peuvent
          combattre individuellement, ou par équipe. Un tournoi peut avoir
          lieu avec n'importe quel nombre de programmes de robot, chaque robot
          jouant contre tous les autres dans une poule, en face à face
          individuel. Un simulateur de bataille est disponible pour aider à la
          mise au point des programmes de robot.</p><p>Le programme TclRobots fournit un environnement physique,
          imposant certains paramètres de jeu auxquels tous les robots doivent
          adhérer. TclRobots fournit également une vue de la bataille, et une
          interface de contrôle pour l'utilisateur. Conditions pour utiliser
          TclRobots : un interpréteur "wish" conçu pour Tcl 7.4 et Tk
          4.0.</p></dd><dt>TKQML</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.csee.umbc.edu/tkqml/">www.csee.umbc.edu/tkqml/</a>

               
            </p></li></ul></div><p>TKQML est une application / un ajout KQML à Tcl/Tk, ce qui
          permet aux systèmes basés sur Tcl de communiquer facilement avec un
          puissant langage de communication d'agent.</p></dd><dt>The Tocoma Project</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.tacoma.cs.uit.no/">www.tacoma.cs.uit.no/</a>

               
            </p></li></ul></div><p>Un agent est un processus qui peut migrer à travers un réseau
          informatique dans le but de satisfaire des requêtes émises par des
          clients. Les agents sont une manière attrayante de décrire les
          calculs distribués sur tout le réseau.</p><p>Le projet TACOMA se concentre sur le support des systèmes
          d'exploitation pour les agents et sur la manière dont les agents
          peuvent être utilisés pour résoudre des problèmes traditionnellement
          destinés aux systèmes d'exploitation. Nous avons implémenté une
          série de systèmes prototypes pour accueillir des agents.</p><p>TACOMA version 1.2 est basé sur UNIX et TCP. Le système est
          compatible avec des agents écrits en C, Tcl/Tk, Perl, Python, et
          Scheme (Elk). Il est implémenté en C. Cette version de TACOMA a été
          rendue publique en Avril 1996.</p><p>Nous nous concentrons actuellement sur les problèmes
          d'hétérogénéité, de tolérance aux anomalies, de sécurité et de
          gestion. En outre, plusieurs applications de TACOMA sont en
          construction. Nous avons implémenté StormCast 4.0, un vaste système
          en réseau de surveillance météorologique sur Internet, en utilisant
          TACOMA et Java. Nous sommes actuellement en cours d'évaluation de
          l'application, et nous prévoyons de construire une nouvelle version
          de StormCast qui devrait être achevée en Juin 1997.</p></dd><dt>Ummon</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.advogato.org/proj/Ummon/">www.advogato.org/proj/Ummon/</a>

               
            </p></li></ul></div><p>Ummon est un robot conversationnel avancé et "open source". Le
          principe général du robot est qu'il ne possède aucune connaissance
          initiale en vocabulaire ou grammaire ; il apprend tout à la volée.
          De nombreuses techniques d'IA seront explorées au cours du
          développement d'Ummon pour arriver à une communication "humaine"
          réaliste avec le support de différentes personnalités
          paramétrables.</p></dd><dt>UMPRS Agent</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.marcush.net/IRS/">www.marcush.net/IRS/</a>

               
            </p></li></ul></div><p>UMPRS supporte le mode de raisonnement descendant, avec
          objectifs à atteindre et il choisit ses objectifs et plan selon la
          priorité maximale. L'exécution de plusieurs buts simultanément est
          possible, ainsi que la suspension et reprise pour chaque tâche de
          but (c-à-d d'intention). Les plans d'UMPRS ont un attribut intégré
          de précondition/moteur d'exécution qui restreint leur applicabilité.
          Les plans de construction disponibles comprennent :
          l'ordonnancement, l'itération, la définition de sous-objectifs, les
          blocs atomiques (c-à-d non-interruptible), l'exécution
          conditionnelle déterministe à n-branches, une section de gestion de
          pannes explicite, et la définition de fonction primitive en
          C++.</p></dd><dt>Virtual Secretary Project (ViSe)</dt><dd><p>(Tcl/Tk)</p><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.vise.cs.uit.no/vise/">www.vise.cs.uit.no/vise/</a>

               
            </p></li></ul></div><p>Ce qui motive le projet Secrétaire Virtuelle est la
          construction d'agents logiciels intelligents basés sur des modèles
          utilisateurs, qui pourraient dans la plupart des cas remplacer les
          hommes pour des tâches de secrétariat ; ces agents seraient basés
          sur l'informatique mobile moderne et les réseaux informatiques. Le
          projet comporte 2 différentes phases : la première phase (ViSe1) se
          concentre sur le filtrage des informations et la migration de
          processus, son but étant de créer un environnement sécurisé pour les
          agents logiciels en utilisant le concept des modèles utilisateur ;
          la seconde phase (ViSe2) est axée sur la coopération efficace et
          intelligente des agents dans un environnement distribué, son but
          étant de construire des agents coopératifs pour obtenir un niveau
          d'intelligence élevé. (codé en Tcl/TclX/Tix/Tk)</p></dd><dt>VWORLD</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://zhar.net/projects/vworld/">zhar.net/projects/vworld/</a>

               
            </p></li></ul></div><p>Vworld est un environnement simulé, écrit en prolog, pour la
          recherche avec des agents autonomes. Il est actuellement plus ou
          moins en version bêta. Il fonctionne bien avec SWI-prolog, et
          devrait fonctionner avec Quitnus-prolog, avec seulement quelques
          modifications. Il est destiné à être utilisé comme outil pédagogique
          pour des projets d'élèves traitant de prolog et des agents
          autonomes. Il est livré avec trois mondes ou environnements de
          démonstration, ainsi qu'avec des exemples d'agents qui leurs sont
          destinés. Il y a deux version maintenant. L'une d'elles est écrite
          pour SWI-prolog et l'autre pour LPA-prolog. Globalement, la
          documentation est faite (dans l'optique d'un cadre
          étudiant/professeur), et une interface graphique est prévue.</p></dd><dt>WebMate</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www-2.cs.cmu.edu/~softagents/webmate/">www-2.cs.cmu.edu/~softagents/webmate/</a>

               
            </p></li></ul></div><p>WebMate est un agent personnel pour la recherche et la
          navigation sur le World-Wide Web. Il vous accompagne quand vous
          surfez sur Internet et vous fournit ce que vous désirez. Ses
          fonctionnalités comprennent : <div class="itemizedlist"><ul><li><p>
                 Amélioration des recherches, dont la recherche parallèle, affinage des mots-clés de la recherche en utilisant notre technologie d'extraction de mots-clés appropriés, retour d'information pertinente, etc. 
              </p></li><li><p>
                 Assistant à la navigation, comprenant l'apprentissage de votre centre d'intérêt actuel, avec recommandation de nouveaux URLs selon votre profil et les ressources sélectionnées, gestion de vos signets de Netscape ou IE, envoie de la page actuellement affichée à vos amis, etc. 
              </p></li><li><p>
                 Navigation hors ligne, y compris le téléchargement des pages suivant la page affichée pour une navigation hors ligne. 
              </p></li><li><p>
                 Filtrage des en-têtes HTTP, comprenant l'enregistrement des en-têtes HTTP et de toutes les transactions effectuées entre le navigateur et les serveurs WWW, etc. 
              </p></li><li><p>
                 Vérification de la page HTML et détection des erreurs et liens morts, etc. 
              </p></li><li><p>
                 Programmation en Java, indépendant du système d'exploitation, fonctionnant en multiprocessus 
              </p></li></ul></div></p></dd><dt>Zeus</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://more.btexact.com/projects/agents/zeus/">more.btexact.com/projects/agents/zeus/</a>

               
            </p></li></ul></div><p>La construction de systèmes multiagents implique une longue
          période de développement et exige des solutions à quelques
          difficultés techniques considérables. C'est ce qui a motivé le
          développement de la boîte à outils ZEUS, qui fournit une
          bibliothèque de composants logiciels et des outils qui facilitent la
          conception, le développement et le déploiement rapide de systèmes
          d'agent.</p></dd></dl></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="N10915" />Les langages de programmation</h2></div></div></div><p>Bien que n'importe quel langage de programmation puisse être utilisé
    pour la recherche sur la vie ou l'intelligence artificielle, les langages
    de programmation décrits ci-dessous sont, si ils n'ont pas été
    spécifiquement créés pour cela, utilisés intensivement pour la
    programmation d'intelligence artificielle.</p><div class="glosslist"><dl><dt>Allegro CL</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.franz.com/">www.franz.com/</a>

               
            </p></li></ul></div><p>Version linux gratuite de l'environnement de développement
          Lisp de Franz Inc. Vous pouvez la télécharger ou ils vous
          expédieront un CD gratuitement (vous n'avez même pas à payer de
          frais d'expédition). Elle est généralement considérée comme l'une
          des meilleures plateformes Lisp.</p></dd><dt>APRIL</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://sourceforge.net/projects/networkagent/">sourceforge.net/projects/networkagent/</a>

               et 

              <a href="http://www.nar.fujitsulabs.com/april/index.html">www.nar.fujitsulabs.com/april/index.html</a>

               
            </p></li></ul></div><p>APRIL est un langage de programmation symbolique conçu pour le
          codage de systèmes basés sur des agents, mobiles et distribués dans
          l'environnement Internet. Il a des fonctionnalités avancées telles
          qu'un sous-langage de macro, l'envoi et la réception asynchrone de
          messages, la mobilité du code, le filtrage, des fonctions d'ordre
          supérieur et la déclaration typée de variables. Ce langage est
          compilé en pseudo-code binaire qui est ensuite interprété par le
          moteur d'exécution APRIL. APRIL a maintenant besoin qu'InterAgent
          Communications Model (ICM) soit installé avant de pouvoir être
          installé à son tour. [Ed. ICM est disponible sur le même site
          web]</p></dd><dt>Ciao Prolog</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.clip.dia.fi.upm.es/Software/Ciao/">www.clip.dia.fi.upm.es/Software/Ciao/</a>

               
            </p></li></ul></div><p>Ciao est un système complet Prolog englobant ISO-Prolog avec
          une nouvelle conception modulaire qui permet à la fois la
          restriction et l'extension du langage. Parmi les extensions de Ciao,
          on trouve actuellement les arguments nommés (enregistrements), les
          fonctions d'ordre supérieur, les contraintes, les objets, les
          prédicats persistants, une bonne base pour l'exécution distribuée
          (d'agents) et la concurrence. Les bibliothèques supportent aussi la
          programmation WWW, les sockets, et les interfaces externes (C, Java,
          Tcl/Tk, les bases de données relationnelles, etc.). Un environnement
          pour Emacs, un compilateur autonome, et un interpréteur de commandes
          haut niveau sont également fournis.</p></dd><dt>DHARMI</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://megazone.bigpanda.com/~wolf/DHARMI/">megazone.bigpanda.com/~wolf/DHARMI/</a>

               
            </p></li></ul></div><p>DHARMI est un langage spatial de haut niveau facile à utiliser
          dont les composants sont administrés de manière transparente par un
          processus en tâche de fond appelé "the Habitat". Comme son nom
          l'indique, ce langage a été conçu pour faire des prototypes de
          modélisation et la gestion des données actives. Les programmes
          peuvent être modifiés pendant leur exécution. Cela est rendu
          possible en estompant la distinction entre le code source, le
          programme et les données.</p></dd><dt>ECLiPSe</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://eclipse.crosscoreop.com/eclipse/">eclipse.crosscoreop.com/eclipse/</a>

               
            </p></li></ul></div><p>:TODO:</p></dd><dt>ECoLisp</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.di.unipi.it/~attardi/software.html">www.di.unipi.it/~attardi/software.html</a>

               
            </p></li></ul></div><p>ECoLisp ("Embeddable Common Lisp", Lisp Commun Embarquable)
          est une implémentation de "Common Lisp" conçue pour être insérable
          dans des applications écrites en C. ECL utilise des conventions
          d'appel C standard pour les fonctions Lisp compilées, ce qui permet
          aux programmes C d'appeler facilement des fonctions Lisp et vice
          versa. Aucune interface de fonctions externes n'est requise : les
          données peuvent être échangées entre le C et le Lisp sans besoin de
          conversion. ECL est basé sur un "Common Runtime Support (CRS)"
          (Appui d'Exécution Commun) qui fournit des fonctionnalités de base
          pour la gestion de la mémoire, le chargement et le vidage dynamique
          des images binaires, et le soutien de processus multiple
          d'exécution. Le CRS est intégré à une bibliothèque qui peut être
          liée au code de l'application. L'ECL est modulaire : les modules
          principaux sont les outils de développement du programme (niveau
          supérieur, débogueur, trace d'une exécution, exécution pas à pas),
          le compilateur, et CLOS. Une version native de CLOS est disponible
          dans ECL : on peut de configurer ECL avec ou sans CLOS. Une version
          d'exécution d'ECL peut être construite avec les modules requis par
          l'application seulement. Le compilateur ECL compile du Lisp vers le
          C, puis fait appel au compilateur GCC pour créer les
          binaires.</p></dd><dt>ESTEREL</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www-sop.inria.fr/esterel.org/">www-sop.inria.fr/esterel.org/</a>

               
            </p></li></ul></div><p>Esterel est à la fois un langage de programmation, dédié à la
          programmation de systèmes réactifs, et un compilateur qui traduit
          les programmes Esterel en machine à états finis. Il est
          particulièrement bien adapté à la programmation de systèmes
          réactifs, y compris les systèmes temps-réel et les automates de
          commande.</p><p>Seul l'exécutable est disponible pour le compilateur de
          langage. :P</p></dd><dt>Gödel</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.cs.bris.ac.uk/~bowers/goedel.html">www.cs.bris.ac.uk/~bowers/goedel.html</a>

               
            </p></li></ul></div><p>Gödel est un langage de programmation déclaratif à usage
          global, de la famille des langages de programmation de logique.
          C'est un langage fortement typé, le système de typage étant basé sur
          de la logique multitri avec du polymorphisme paramétrique. Il a un
          système de module. Gödel supporte les entiers à précision infinie,
          les nombres rationnels à précision infinie, et les réels à virgule
          flottante également. Il peut résoudre les contraintes sur des
          domaines finis d'entiers et également les contraintes rationnelles
          linéaires. Il supporte le traitement des ensembles finis. Il a
          également une règle de calcul flexible et un opérateur d'élagage qui
          généralise la validation des langages de programmation de logique
          concourante. Un accent considérable est mis sur l'infrastructure
          méta-logique de Gödel qui fournit un support significatif pour les
          méta-programmes qui font de l'analyse, de la transformation, de la
          compilation, de la vérification, du débogage, et ainsi de
          suite.</p></dd><dt>CLisp (Lisp)</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://clisp.sourceforge.net/">clisp.sourceforge.net/</a>

               
            </p></li><li><p>
               Site Web officiel : 

              <a href="http://clisp.cons.org/">clisp.cons.org/</a>

               
            </p></li></ul></div><p>CLisp est une implémentation de "Common Lisp" réalisée par
          Bruno Haible et Michael Stoll. Il supporte principalement le Lisp
          décrit par Common LISP: The Language (2nd edition) et le standard
          Common Lisp ANSI. CLisp comprend un interpréteur, un
          byte-compilateur, un grand sous ensemble de CLOS ("Object-Oriented
          Lisp", Lisp Orienté Objet), une interface de langage externe et,
          pour certaines machines, un éditeur d'écran.</p><p>On choisit la langue d'interface utilisateur (anglais,
          allemand, français) au moment de l'exécution. Les principaux
          paquetages qui fonctionnent dans CLisp incluent CLX et Garnet. CLisp
          ne requiert que 2 Mo de mémoire seulement.</p></dd><dt>CMU Common Lisp</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.cons.org/cmucl/">www.cons.org/cmucl/</a>

               
            </p></li><li><p>
               Site Web : 

              <a href="http://ww.telent.net/lisp/howto.html">ww.telent.net/lisp/howto.html</a>

               
            </p></li></ul></div><p>CMU Common Lisp est un environnement de programmation Common
          Lisp de "puissance industrielle" de domaine public. Une grande
          partie des changements de X3j13 ont été incorporés dans CMU CL.
          Partout où cela était possible, ceci a été fait afin de permettre de
          manière transparente l'utilisation soit du CLtL1, soit du CL ANSI
          proposé. Les nouvelles fonctionnalités les plus intéressantes pour
          les utilisateurs sont probablement les fonctions SETF, LOOP et la
          macro WITH-COMPILATION-UNIT.</p></dd><dt>GCL (Lisp)</dt><dd><div class="itemizedlist"><ul><li><p>
               Site FTP : 

              <a href="ftp://ftp.ma.utexas.edu/pub/gcl/">ftp.ma.utexas.edu/pub/gcl/</a>

               
            </p></li></ul></div><p>GNU Common Lisp (GCL) possède un compilateur et un
          interpréteur pour Common Lisp. Il était connu auparavant sous le nom
          de Kyoto Common Lisp. Il est très portable et extrêmement efficace
          sur une large gamme d'applications. Il soutient la comparaison au
          niveau performance avec les Lisps commerciaux sur un grand nombre de
          démontreurs de théorèmes et de systèmes d'algèbre symbolique. Il
          supporte la spécification CLtL1 mais évolue vers la définition
          proposée de norme ANSI. GCL compile vers du C et utilise ensuite les
          compilateurs C d'optimisation de code natif (ex.: GCC). Une fonction
          comportant un nombre fixe d'arguments et une valeur se transforme en
          une fonction C du même nombre d'arguments, renvoyant une valeur, GCL
          a donc une efficacité maximale sur de tels appels. Il a un garbage
          collector [NdT : ramasse-miettes] classique qui offre une grande
          liberté au compilateur C pour mettre les valeurs Lisp dans des
          registres arbitraires.</p><p>Il possède un débogueur Lisp niveau source pour le code
          interprété, avec affichage du code source dans une fenêtre Emacs.
          Son outil de profilage (basé sur les outils de profilage C) compte
          les appels de fonction et le temps passé dans chaque
          fonction.</p></dd><dt>GNU Prolog</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://pauillac.inria.fr/~diaz/gnu-prolog/">pauillac.inria.fr/~diaz/gnu-prolog/</a>

               
            </p></li><li><p>
               Site Web : 

              <a href="http://www.gnu.org/software/prolog/prolog.html">www.gnu.org/software/prolog/prolog.html</a>

               
            </p></li></ul></div><p>GNU Prolog est un compilateur Prolog gratuit, et résolveur de
          contraintes sur les domaines finis, développé par Daniel Diaz. GNU
          Prolog accepte des programmes en Prolog+contraintes et produit des
          exécutables natifs (comme gcc le fait à partir de code source C).
          L'exécutable obtenu est alors autonome. La taille de cet exécutable
          peut être relativement petite puisque GNU Prolog peut éviter de lier
          le code de la plupart des prédicats intégrés inutilisés. Les
          performances de GNU Prolog sont très encourageantes (comparables à
          celles des systèmes commerciaux).</p><p>En plus de la compilation en code exécutable natif, GNU Prolog
          offre un interpréteur interactif classique (haut niveau) avec un
          débogueur.</p><p>La partie Prolog se conforme aux standards ISO pour Prolog
          avec beaucoup d'extensions très utiles à l'usage (variables
          globales, interface système d'exploitation, sockets, ...).</p><p>GNU Prolog comprend également un efficace résolveur de
          contraintes sur Domaines Finis (FD), ce qui ouvre la programmation
          logique par contraintes à l'utilisateur, en combinant la puissance
          de la programmation par contraintes à la déclarativité de la
          programmation logique.</p></dd><dt>IBAL</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.eecs.harvard.edu/~avi/IBAL/">www.eecs.harvard.edu/~avi/IBAL/</a>

               
            </p></li></ul></div><p>:TODO:</p></dd><dt>lush</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://lush.sourceforge.net/">lush.sourceforge.net/</a>

               
            </p></li></ul></div><p>:TODO:</p></dd><dt>Maude</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://maude.cs.uiuc.edu/">maude.cs.uiuc.edu/</a>

               
            </p></li></ul></div><p>:TODO:</p></dd><dt>Mercury</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.cs.mu.oz.au/research/mercury/">www.cs.mu.oz.au/research/mercury/</a>

               
            </p></li></ul></div><p>Mercury est un nouveau langage de programmation logique,
          purement déclaratif. Tout comme Prolog et d'autres langages de
          programmation logique existants, c'est un langage très haut niveau
          qui permet aux programmeurs de se concentrer sur le problème plutôt
          que sur les détails bas niveau tels que la gestion de la mémoire.
          Contrairement à Prolog, qui est orienté vers la programmation
          exploratoire, Mercury est conçu pour la construction de grands
          systèmes logiciels fiables et efficaces par des équipes de
          programmeurs. Par conséquent, programmer en Mercury apporte une
          touche différente par rapport à la programmation en Prolog.</p></dd><dt>Mozart</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.mozart-oz.org/">www.mozart-oz.org/</a>

               
            </p></li></ul></div><p>Le système Mozart fournit un support de pointe dans 2 domaines
          : le calcul distribué ouvert et l'inférence basée sur les
          contraintes. Mozart implémente Oz, un langage concourant orienté
          objet avec synchronisation des flux de données. Oz combine la
          programmation distribuée et concourante avec l'inférence logique
          basée sur les contraintes, ce qui en fait un choix excellent pour le
          développement des systèmes multiagents. Mozart est une plateforme
          idéale aussi bien pour les applications distribuées polyvalentes que
          pour les problèmes difficiles nécessitant une optimisation
          sophistiquée et des capacités d'inférence. Nous avons développé des
          applications de planification et de gestion du temps, de placement
          et de configuration, de représentation du langage naturel et des
          connaissances, de systèmes multiagent et d'outils de collaboration
          sophistiqués.</p></dd><dt>SWI Prolog</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.swi-prolog.org/">www.swi-prolog.org/</a>

               
            </p></li></ul></div><p>SWI est une version gratuite de Prolog dans la famille Prolog
          Edinburgh (la rendant de ce fait très similaire à Quintus et à
          beaucoup d'autres versions), qui contient : une grande bibliothèque
          de prédicats intégrés, un système de modules, un garbage collector,
          une interface bidirectionnelle avec le langage C, et beaucoup
          d'autres dispositifs encore. Il est censé être un langage éducatif,
          donc son code compilé n'est pas le plus rapide. Bien que sa
          similarité avec Quintus permette un portage facile.</p><p>XPCE est librement et gratuitement disponible en exécutable
          pour la version Linux de SWI-Prolog. XPCE est un
          paquetage/environnement de développement d'interface graphique (GUI)
          X-window orienté objet.</p></dd><dt>Push</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://hampshire.edu/lspector/push.html">hampshire.edu/lspector/push.html</a>

               
            </p></li></ul></div><p>:TODO:</p></dd><dt>Kali Scheme</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.neci.nj.nec.com/PLS/Kali.html">www.neci.nj.nec.com/PLS/Kali.html</a>

               
            </p></li></ul></div><p>Kali Scheme est une implémentation distribuée de Scheme qui
          permet une transmission efficace d'objets d'ordre supérieur tels que
          les fermetures et continuations. L'intégration d'équipements de
          communication distribuée dans un langage de programmation évolué
          engendre un certain nombre d'abstractions et de paradigmes nouveaux
          pour l'informatique distribuée. Parmi ces derniers nous avons les
          politiques de migration des processus et l'équilibrage de charge,
          personnalisés par l'utilisateur, les calculs distribués liés
          incrémentalement, les agents, et les applications client-serveur
          paramétrées. Kali Scheme supporte la simultanéité et la
          communication, grâce aux procédures et continuations de première
          classe. Il intègre les procédures et continuations dans un cadre
          distribué basé sur des messages qui permet à n'importe quel objet
          Scheme (y compris les vecteurs de code) d'être envoyé et reçu dans
          un message.</p></dd><dt>RScheme</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.rscheme.org/">www.rscheme.org/</a>

               
            </p></li><li><p>
               Site FTP : 

              <a href="ftp://ftp.rscheme.org/pub/rscheme/">ftp.rscheme.org/pub/rscheme/</a>

               
            </p></li></ul></div><p>RScheme est une version orientée objet étendue du dialecte
          Scheme de Lisp. RScheme est librement redistribuable, et il offre
          des performances raisonnables en dépit de son extraordinaire
          portabilité. RScheme peut être compilé en C, et le C peut ensuite
          être compilé avec un compilateur C habituel pour générer du code
          machine. Cependant, par défaut, RScheme compile en code objet qui
          est interprété par une machine virtuelle (un moteur d'exécution).
          Cela assure une compilation rapide et permet de conserver un code de
          taille réduite. En général, nous recommandons l'utilisation du
          système de génération de code objet (activé par défaut), et de ne
          compiler en code machine que vos programmes dont le temps
          d'exécution est critique. Cela permet un bon compromis taille
          mémoire/temps d'exécution. (voir le site web pour plus de
          détails)</p></dd><dt>Scheme 48</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://s48.org/">s48.org</a>

               
            </p></li></ul></div><p>Scheme 48 est une implémentation de Scheme basée sur une
          architecture de machine virtuelle. Scheme 48 est conçu pour être
          simple, souple, fiable, et rapide. Il devrait être facilement
          portable vers des machines 32 bits qui ont POSIX et le support du C
          ANSI. En plus de l'environnement de développement et des procédures
          usuelles intégrées de Scheme, les logiciels de bibliothèques
          incluent le support des macros hygiéniques (comme cela est décrit
          dans le rapport Scheme Revised^4), du multitâche, des
          enregistrements, de la gestion des exceptions, des tables de
          hachage, des tableaux, des pointeurs nuls, et du FORMAT. Scheme 48
          implémente et exploite un système expérimental de modules vaguement
          dérivé de Standard ML et de Scheme Xerox. L'environnement de
          développement supporte les changements interactifs de modules et
          d'interfaces.</p></dd><dt>SCM (Scheme)</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://swissnet.ai.mit.edu/~jaffer/SCM.html">swissnet.ai.mit.edu/~jaffer/SCM.html</a>

               
            </p></li></ul></div><p>SCM est conforme à la révision 5 du rapport sur l'Algorithmic
          Language Scheme (le langage algorithmique Scheme) et à la
          spécification IEEE P1178. SCM est écrit en C. Il utilise les
          utilitaires suivants (tous disponibles sur le site ftp) :
          <div class="itemizedlist"><ul><li><p>
                 SLIB (Standard Scheme Library) est une bibliothèque Scheme portable qui est prévue pour fournir des fonctions de compatibilité et des utilitaires pour toutes les implémentations Scheme standard, y compris SCM, Chez, Elk, Gambit, MacScheme, MITScheme, scheme-&gt;C, Scheme 48, T3.1, et VSCM, et est disponible sous le nom de fichier slib2c0.tar.gz. Ecrit par Aubrey Jaffer ; 
              </p></li><li><p>
                 JACAL est un système symbolique de mathématiques écrit en Scheme, et est disponible sous le nom de fichier jacal1a7.tar.gz ; 
              </p></li><li><p>
                 Des interfaces vers les bibliothèques standards comprenant un filtrage d'expressions régulières de chaînes de caractères REGEX et le paquetage de gestion d'écran CURSES ; 
              </p></li><li><p>
                 Sont disponibles pour être ajoutés des paquetages parmi lesquels un débogueur interactif, une base de données, des composants X-window, des traitements graphiques BGI, Motif, et des paquetages Open-Windows ; 
              </p></li><li><p>
                 Un compilateur (HOBBIT, disponible séparément) et la liaison dynamique des modules compilés. 
              </p></li></ul></div></p></dd><dt>Shift</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.path.berkeley.edu/shift/">www.path.berkeley.edu/shift/</a>

               
            </p></li></ul></div><p>Shift est un langage de programmation permettant de décrire
          les réseaux dynamiques d'automates hybrides. De tels systèmes sont
          constitués de composants qui peuvent être créés, interconnectés et
          détruits au fur et à mesure que le système évolue. Les composants
          montrent un comportement hybride, constitué de phases continues
          séparées par des transitions à événements discrets. Les composants
          peuvent évoluer indépendamment, ou ils peuvent interagir par leurs
          entrées, leurs sorties et les événements exportés. Le réseau
          d'interaction lui-même peut évoluer.</p></dd><dt>YAP Prolog</dt><dd><div class="itemizedlist"><ul><li><p>
               Site Web : 

              <a href="http://www.ncc.up.pt/~vsc/Yap/">www.ncc.up.pt/~vsc/Yap/</a>

               
            </p></li></ul></div><p>YAP est un compilateur Prolog à haute performance développé
          par LIACC/Universidade do Porto. Son moteur Prolog est basé sur WAM
          (Warren Abstract Machine, Machine Abstraite Warren), avec plusieurs
          optimisations pour de meilleures performances. YAP suit la tradition
          d'Edinburgh, et est en grande partie compatible avec Prolog DEC-10,
          Quintus Prolog, et particulièrement avec le C-Prolog. Le travail sur
          la version la plus récente de YAP tends vers plusieurs objectifs :
          <div class="itemizedlist"><ul><li><p>
                 la portabilité : le système tout entier est maintenant écrit en C. YAP compile sur les machines 32 bits les plus courantes, tels que les Sun et les PC sous Linux, et sur les machines 64 bits, les Alphas sur lesquelles tournent OSF Unix et Linux. 
              </p></li><li><p>
                 la performance : nous avons optimisé l'émulateur pour obtenir des performances comparables voire meilleures que celles des systèmes Prolog les plus connus. En réalité, la version actuelle de YAP est plus puissante que l'originale, écrite en assembleur. 
              </p></li><li><p>
                 la robustesse : nous avons testé le système avec un grand échantillonnage d'applications Prolog. 
              </p></li><li><p>
                 l'extensibilité : YAP a dès l'origine été conçu structurellement pour encapsuler la manipulation de termes. Ces principes étaient utilisés, par exemple, pour implémenter une interface C simple et puissante. La nouvelle version de YAP étend ces principes pour adapter les extensions à l'algorithme d'unification, qui, selon nous, sera utile pour l'implémentation d'extensions telles que la programmation de contraintes. 
              </p></li><li><p>
                 la complétude : YAP fournit depuis longtemps la plupart des installations intégrées que l'on attend d'une implémentation Prolog Edinburgh. Celles-ci comprennent les fonctionnalités d'entrées/sorties, les opérations de bases de données, et les modules. Le travail sur YAP a maintenant pour objectif d'être compatible avec le standard Prolog. 
              </p></li><li><p>
                 l'ouverture : nous voudrions faire en sorte que les nouveaux développements de YAP soient ouverts à la communauté des utilisateurs. 
              </p></li><li><p>
                 la recherche : YAP est un projet moteur pour la recherche dans et en dehors de notre groupe. Actuellement la recherche continue sur le parallélisme et la tabulation, et nous avons commencé à travailler sur la prise en compte de la manipulation des contraintes. 
              </p></li></ul></div></p></dd></dl></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="N10ACD" />Manquant et Inactif</h2></div></div></div><p>Ceci est l'espace pour les entrées anciennes ou erronées. Le
    chapitre MIA est destinée aux entrées pour lesquelles je n'ai plus de page
    d'accueil valide. Si vous avez la moindre information sur l'emplacement
    actuel de ces logiciels, merci de me le faire savoir. La section Inactifs
    est destinée aux projets qui ne semblent plus maintenus. Les déplacer ici
    me permet de conserver les chapitres principaux propres ; les parties
    intéressées peuvent malgré tout me corriger, auquel cas je les déplacerai
    à nouveau.</p><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N10AD2" />MIA — Projets ne disposant pas de liens.</h3></div></div></div><p>:TODO:</p><div class="glosslist"><dl><dt>IDEAL</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://yoda.cis.temple.edu:8080/ideal/">
                  yoda.cis.temple.edu:8080/ideal/</a>
                </p></li></ul></div></p><p>IDEAL est un banc d'essai pour le travail sur les diagrammes
            d'infuence et les réseaux Bayésiens. Il comprend des algorithmes
            d'inférence variés pour les réseaux de croyance et des algorithmes
            d'évaluation pour les diagrammes d'inluence. Il contient des
            installations pour créer et éditer les diagrammes d'influence et
            les réseaux de croyance.</p><p>IDEAL est écrit purement en Common Lisp et ainsi il tournera
            en Common Lisp sur n'importe quelle plate-forme. L'accent dans
            l'écriture d'IDEAL a été mis sur la clarté du code et sur la
            fourniture d'abstractions de programmation de haut niveau. Il est
            ainsi tout à fait adapté aux implémentations expérimentales qui
            nécessitent ou étendent la technologie de réseau de
            croyance.</p><p>Au plus haut niveau, IDEAL peut être utilisé comme une
            bibliothèque de sous-routine qui fournit l'évaluation du diagramme
            d'inférence et d'influence du réseau de croyance dans un paquetage
            logiciel. Le code est documenté dans un manuel détaillé et ainsi
            il est aussi possible de travailler à un niveau inférieur sur les
            extensions des méthodes du réseau de croyance.</p><p>IDEAL est fourni avec une interface graphique optionnelle
            écrite en CLIM. Si votre Common Lisp possède aussi CLIM, vous
            pouvez lancer l'interface graphique.</p></dd><dt>Symbolic Probabilistic Inference (SPI)</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site FTP :<a href="http://ftp.engr.orst.edu/pub/dambrosi/spi/">
                  ftp.engr.orst.edu/pub/dambrosi/spi/</a>
                </p></li><li><p>
                  Paper (ijar-94.ps) :<a href="http://ftp.engr.orst.edu/pub/dambrosi/">
                  ftp.engr.orst.edu/pub/dambrosi/</a>
                </p></li></ul></div></p><p>Contient des bibliothèques de fonction Common Lisp pour
            implémenter des réseaux bayésiens de type SPI. La documentation
            est très limitée. Caractéristiques :</p><div class="itemizedlist"><ul><li><p>
                Probabilités, Utilitaires du langage d'expression
                locale, explications, modèles dynamiques, et une GUI basée sur
                TCL/TK.
              </p></li></ul></div></dd></dl></div></div><div class="section" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="N10B07" />Projets inactifs.</h3></div></div></div><div class="glosslist"><dl><dt>EMA-XPS — A Hybrid Graphic Expert System
          Shell</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site web :<a href="http://www.iai.uni-wuppertal.de/EMA-XPS/">
                  www.iai.uni-wuppertal.de/EMA-XPS</a>
                </p></li></ul></div></p><p>EMA-XPS est un interpréteur de commande [shell] de système
            expert graphique hybride basé sur le shell orienté ASCII Babylon
            2.3 du Centre National Allemand de Recherche pour les Sciences
            Informatiques (GMD). En plus de la puissance d'IA de Babylon
            (représentation de données orientées objet, règles de chaînage
            avant et arrière — regroupables en séries, en clauses de Horn, et
            en réseaux de contraintes), une interface graphique basée sur le
            système X11 Window System et la OSF/Motif Widget Library ont été
            fournies.</p></dd><dt>PDKB</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site Web : <a href="http://lynx.eaze.net/~pdkb/web/">
                  lynx.eaze.net/~pdkb/web/</a>
                </p></li><li><p>
                  Site SourceForge : <a href="http://sourceforge.net/projects/pdkb/">
                  sourceforge.net/projects/pdkb/</a>
                </p></li></ul></div></p><p>La banque de connaissances sur le domaine publique (PDKB :
            Public Domain Knowledge Bank) est une banque de connaissances sur
            l'intelligence artificielle des lois et règles de sens commun.
            Elle est basée sur l'ontologie de niveau supérieur de Cyc (CUO :
            Cyc Upper Ontology) et le langage MELD.</p></dd><dt>QUANT1</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site Web : <a href="http://linux.irk.ru/projects/QUANT/">
                  linux.irk.ru/projects/QUANT/</a>
                </p></li></ul></div></p><p>Quant/1 signifie QUANTifieur de type 1. Son but est d'être
            une alternative pour les systèmes semblables à Prolog (ou
            résolutionnaux). Les principales caractéristiques comprennent la
            non-nécéssité d'éliminer les quantifieurs, la scolémisation, la
            facilité de compréhension, les opérations sur des formules de
            grande échelle, l'acceptation de fomules 'nonHorn',
            l'approfondissement iterratif. La bibliothèque réelle implémentée
            dans ce projet est appelée ATPPCF (Automatic Theorem Prover in
            calculus of Positively Constructed Formulae : preuve automatique
            du théoreme dans le calcul de formules construites
            positivement)</p><p>ATPPCF deviendra une bibliothèque (moteur d'inférence) et
            une extension du langage de calculs de prédiction comme un nouveau
            langage logique. Cette bibliothèque sera incorporable dans
            d'autres programmes, comme TCL, Python, Perl. La méthode
            d'inférance primaire du moteur sera la "recherche d'inférances
            dans le langage des formules construites positivement (PCF :
            Positively Constructed Formulas)" (comme un sous-ensemble de
            calculs de prédicats bien traduits dans les deux sens). Le langage
            sera utilisé comme langage de script pour le moteur. Mais il y
            aura la possibilité de le remplacer par des extension de langage
            du programme principal.</p></dd><dt>TresBel</dt><dd><p><div class="itemizedlist"><ul><li><p>
                  Site FTP :<a href="http://iridia.ulb.ac.be/pub/hongxu/software/">
                  iridia.ulb.ac.be/pub/hongxu/software/</a>
                </p></li></ul></div></p><p>Bibliothèques comprenant du code Common Lisp (Allegro) pour
            les fonctions de croyance (c-à-d le raisonnement probant de
            Dempster-Shafer) comme la représentation de l'incertain.
            Documentation pauvre. Possède une GUI limitée.</p></dd></dl></div></div></div></div></body></html>