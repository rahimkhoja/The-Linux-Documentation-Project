<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.21">
 <TITLE>Le HOWTO du noyau Linux (Kernel HOWTO)</TITLE>
</HEAD>
<BODY>
<H1>Le HOWTO du noyau Linux (Kernel HOWTO)</H1>

<H2>par Brian Ward, <CODE>ward@blah.tu-graz.ac.at</CODE> </H2>Version 1.0, 5 juin 1999
<HR>
<EM>(5 juillet 1999. Adaptation française par Eric Dumas
<CODE>dumas@freenix.fr</CODE> jusqu'à la version 0.80, Christophe Deleuze
<CODE>christophe.deleuze@lip6.fr</CODE> à partir de la version 1.0).
Il s'agit d'un guide détaillé sur la configuration du noyau, sa compilation
et ses mises à jour pour les plates-formes x86.</EM>
<HR>
<H2><A NAME="s1">1. Introduction</A></H2>


<P>Faut-il que vous lisiez ce document ? Oui, si vous avez les 
symptômes suivants :</P>
<P>
<UL>
<LI> "Arg ! Cette archive TrucBidule-46.5.6 nécessite la version du
noyau 2.8.193 et je n'ai que la version 1.0.9 ! "</LI>
<LI> Il y a un pilote de périphérique dont vous avez besoin 
dans l'un des nouveaux noyaux.</LI>
<LI> Vous n'avez aucune idée de la manière dont il faut s'y prendre 
pour recompiler le noyau.</LI>
<LI> "Est-ce que ce truc dans le fichier <I>README</I> décrit toute 
la marche à suivre ?"</LI>
<LI> Vous avez essayé, ça ne marche pas !</LI>
<LI> Vous devez donner un conseil à une personne qui a certains
problèmes.</LI>
</UL>
</P>

<H2><A NAME="ss1.1">1.1 Lisez ceci en premier (enfin bon, c'est un conseil) !</A>
</H2>


<P>Certains exemples présentés dans ce document présupposent que vous possédez
les programmes GNU <CODE>tar</CODE>, <CODE>find</CODE> et <CODE>xargs</CODE>.  Ils sont
assez standards, et ne devraient pas vous poser trop de problèmes.  On
suppose également que vous connaissez la structure de votre disque
(partitions). Si vous ne le savez pas, il est impératif que vous gardiez une
copie sur papier du résultat de l'exécution de la commande <CODE>mount</CODE>
(ou bien une copie du fichier <CODE>/etc/fstab</CODE>, si vous savez le lire).
Cette information est importante, et ne change pas à moins que vous ne
repartitionniez votre disque, en ajoutiez un nouveau, réinstalliez votre
système, ou quelque chose de similaire.</P>
<P>La dernière version stable du noyau au moment où j'écris ces mots est la
2.2.9, ce qui signifie que les références et les exemples donnés
correspondent à cette version. Même si j'ai essayé de faire en sorte que ce
document soit aussi indépendant que possible des versions, le noyau est en
perpétuel développement, donc si vous récupérez une nouvelle version, il
risque d'y avoir quelques différences. Cela ne devrait pas poser trop de
problèmes mais risque de semer un peu la confusion.</P>
<P>Il existe deux versions des sources du noyau : une version dite
"stable" et une version de développement. Les version stables ont des
numéros de version pairs : 1.2.x, 2.0.x sont des versions stables... tout
comme la 2.2.x. Ces noyaux sont considérés comme étant les plus stables et
sans erreurs. Les noyaux de développement (1.3.x, 2.1.x, etc) sont des
noyaux de test, pour les développeurs, les testeurs... mais ces noyaux
peuvent être très bogués. Vous êtes prévenus.</P>

<H2><A NAME="ss1.2">1.2 Un mot sur le style</A>
</H2>


<P><CODE>Un texte qui ressemble à celui-ci</CODE> est soit un message qui apparaît
sur votre écran, soit un fichier, soit quelque chose qui peut être
directement saisi, comme une commande ou des options pour une commande (si
vous possédez une version texte de ce document, il n'y a pas de différence).</P>


<H2><A NAME="s2">2. Quelques questions... avec leurs réponses</A></H2>



<H2><A NAME="ss2.1">2.1 Mais quel est le rôle du noyau ?</A>
</H2>


<P>Le noyau Unix joue le rôle d'intermédiaire entre vos programmes et
votre matériel.  Premièrement, il gère la mémoire pour tous les programmes
en cours d'exécution (processus), et s'assure qu'ils occupent tous une part
équitable (ou non) du temps processeur.  En plus, il fournit une interface
(simple à utiliser) aux programmes pour communiquer avec votre matériel
(appels système).</P>
<P>Bien sûr c'est un petit peu plus compliqué que ça, mais ces fonctions de
bases sont les plus importantes à connaître.</P>

<H2><A NAME="ss2.2">2.2 Pourquoi voudrais-je mettre à jour mon noyau ?</A>
</H2>


<P>Les nouveaux noyaux offrent plus de facilité pour communiquer avec plus de
matériels (c'est-à-dire qu'ils gèrent plus de périphériques...), ils peuvent
avoir une meilleure gestion des processus, tourner plus rapidement que les
anciennes versions, être plus stables et ils corrigent les erreurs stupides
des versions précédentes.  Beaucoup de gens mettent à jour leurs noyaux car
ils veulent avoir les nouveaux pilotes de périphériques et les corrections
d'erreurs.</P>

<H2><A NAME="ss2.3">2.3 Quel genre de matériel supportent les nouveaux noyaux ? </A>
</H2>


<P>Jetez un coup d'oeil sur le Hardware-HOWTO. Vous pouvez aussi regarder le
fichier "<CODE>config.in</CODE>" dans les sources de <B>Linux</B>, ou
juste essayer "<CODE>make config</CODE>", ce qui vous permet de voir tous
les matériels supportés par le noyau standard, mais pas tout ce que
<B>Linux</B> supporte. En effet, beaucoup de périphériques assez utiles
(tels les périphériques PCMCIA, et quelques lecteurs de cartouches) sont des
modules chargeables maintenus et distribués séparément.</P>

<H2><A NAME="ss2.4">2.4 Quelle version de gcc ou de libc utiliser ? </A>
</H2>


<P>Linus recommande une version de gcc dans le fichier <CODE>README</CODE> fourni
avec le code source.  Si vous ne possédez pas cette version, la
documentation dans la version recommandée de gcc devrait vous indiquer si
vous avez besoin de mettre à jour votre libc.  Ce n'est pas une opération
compliquée, mais il est important de suivre les instructions.</P>

<H2><A NAME="ss2.5">2.5 Que sont les modules chargeables (loadable modules) ?</A>
</H2>


<P>Ce sont des parties du noyau (pilotes de périphériques généralement) qui ne
sont pas compilées dans celui-ci. On peut les compiler séparément, les
insérer et les retirer du noyau à n'importe quel moment. En raison de cette
souplesse, c'est devenu la méthode préférée pour coder certaines
fonctionnalités du noyau.  Bon nombre de pilotes de périphériques tels que
PCMCIA et les gestionnaires de cartouches QIC-80/40 sont des modules
chargeables.</P>

<H2><A NAME="ss2.6">2.6 De combien d'espace disque ai-je besoin ? </A>
</H2>


<P>Cela dépend de la configuration de votre système. Tout d'abord, le code
source compressé de <B>Linux</B> fait presque 16 Mo pour la version 2.2.9.
Vous voulez généralement le garder dans un coin après l'avoir
décompressé. Décompressé et compilé avec une configuration moyenne, il
occupe 67 Mo de plus.</P>

<H2><A NAME="ss2.7">2.7 Combien de temps ça prend ? </A>
</H2>


<P>Sur les machines récentes la compilation demande beaucoup beaucoup moins de
temps que sur les anciennes. Un AMD K6-2/300 avec un disque rapide peut
compiler un noyau 2.2.x en à peu près quatre minutes. Avec de vieux Pentium,
486 ou 386 soyez prêts à patienter, éventuellement des heures, jours...</P>
<P>Si cela vous pose problème et que vous avez accès à une machine rapide, vous
pouvez compiler sur celle-ci (fournissez les bons paramètres, assurez-vous
que vos utilitaires sont à jour, etc.) et transférer l'image du noyau sur la
machine lente.</P>


<H2><A NAME="s3">3. Comment configurer le noyau ?</A></H2>



<H2><A NAME="ss3.1">3.1 Récupérer les sources </A>
</H2>


<P>Vous pouvez récupérer les sources via ftp depuis <CODE>ftp.kernel.org</CODE>
dans le répertoire <CODE>/pub/linux/kernel/vx.y</CODE>, où <CODE>x.y</CODE> est la
version (par ex. 2.2). Comme expliqué plus haut les versions se terminant par
un chiffre impair sont les versions de développement et peuvent être
instables. Le fichier est typiquement <CODE>linux-x.y.z.tar.gz</CODE>, où
<CODE>x.y.z</CODE> est le numéro de version. Une version avec suffixe en
<CODE>.bz2</CODE> (compressé avec bzip2) est aussi généralement disponible (la
compression bzip2 est plus performante donc le transfert sera plus rapide).</P>
<P>Il vaut mieux utiliser <CODE>ftp.xx.kernel.org</CODE> où <CODE>xx</CODE> est votre
code de pays, par exemple <CODE>ftp.fr.kernel.org</CODE> pour la France,
<CODE>ftp.be.kernel.org</CODE> pour la Belgique.</P>

<H2><A NAME="ss3.2">3.2 Installer les sources</A>
</H2>


<P>Faites un <CODE>su</CODE> (super utilisateur) ou bien loggez-vous en tant que
"<CODE>root</CODE>", et allez dans le répertoire <CODE>/usr/src</CODE>.  Si
vous avez déjà installé les sources du noyau, il y aura déjà un répertoire
appelé "<CODE>linux</CODE>", contenant l'ensemble des sources du noyau.
Si vous avez de la place disque et que vous voulez jouer la carte sécurité,
il est préférable de conserver ce répertoire intact.  Un système assez
pratique consiste à renommer votre répertoire en fonction du numéro de la
version. La commande "<CODE>uname -r</CODE>" vous indiquera le numéro de
la version du noyau actuellement en fonction.</P>
<P>Par exemple, si "<CODE>uname -r</CODE>" donne "<CODE>1.0.9</CODE>,"
vous pourrez déplacer votre répertoire (avec <CODE>mv</CODE>)
"<CODE>linux</CODE>" en "<CODE>linux-1.0.9</CODE>".  Si vous êtes du
genre téméraire, détruisez le répertoire. Dans tous les cas, soyez sûr qu'il
n'y ait aucun répertoire "<CODE>linux</CODE>" dans <CODE>/usr/src</CODE>
avant de décompresser et d'installer les sources.</P>
<P>Dans <CODE>/usr/src</CODE>, installez les sources en faisant "<CODE>tar zxpvf
linux-x.y.z.tar.gz</CODE>" (si vous avez uniquement un fichier
<CODE>.tar</CODE>, sans de <CODE>.gz</CODE> à la fin,"<CODE>tar xpvf
linux.x.y.z.tar</CODE>" marchera sans problème).  Vous verrez la liste
des fichiers se dérouler sous vos yeux.  Lorsque c'est terminé, il y aura un
nouveau répertoire "<CODE>linux</CODE>".  Allez dans <B>linux</B> et
jetez un coup d'oeil au fichier <CODE>README</CODE>.  Il y a une section
"<CODE>INSTALLING the kernel</CODE>".  Suivez les instructions lorsque
nécessaire - prenez garde à ce que les liens soient en place et que les
fichiers <CODE>.o</CODE> soient détruits, etc.</P>
<P>Si votre fichier est en <CODE>.bz2</CODE>, il vous faudra utiliser le programme
bzip2 (voir 
<A HREF="http://www.muraroa.demon.co.uk/">http://www.muraroa.demon.co.uk/</A>). Faites:</P>
<P>
<PRE>
     bz2cat linux-x.y.z.tar.bz2 | tar xvf -
</PRE>
</P>

<H2><A NAME="ss3.3">3.3 Configurer le noyau</A>
</H2>


<P>Note : il s'agit d'une répétition, clarification de la section
correspondante dans le fichier <CODE>README</CODE> de Linus.</P>
<P>La commande "<CODE>make config</CODE>" lance un script qui va vous 
poser un certain nombre de questions. Il a besoin de bash, donc 
vérifiez que vous possédez bien <CODE>/bin/bash</CODE>, <CODE>/bin/sh</CODE>, 
ou <CODE>$BASH</CODE>.</P>
<P>Il existe un certain nombre de possibilités autres que <CODE>make config</CODE>
et il est possible que vous les trouviez plus simples à utiliser. Pour ceux
qui utilisent X, vous pouvez essayer <CODE>make xconfig</CODE> si vous avez au
préalable installé Tk (<EM>click-o-rama</EM> - Nat).  <CODE>make
menuconfig</CODE> est destiné à ceux qui ont installé (n)curses et qui
préfèrent utiliser un menu en mode texte.  Ces interfaces ont un avantage :
si vous vous trompez lors de la configuration, vous pouvez facilement
corriger l'erreur sans devoir tout relancer.</P>
<P>Avec <CODE>make menuconfig</CODE> et <CODE>make xconfig</CODE> les options de
configuration apparaîtront hiérarchisées.</P>
<P>Vous êtes alors prêt à répondre aux questions, la plupart du temps par
"<CODE>y</CODE>" ou par "<CODE>n</CODE>". Les pilotes de périphériques
acceptent aussi généralement "<CODE>m</CODE>", pour "module". Le
pilote sera compilé non pas directement dans le noyau mais en tant que
module chargeable. Une interprétation plus amusante est que le
"<CODE>m</CODE>" est pour "maybe" (peut-être). Certaines options
non critiques ou évidentes ne seront pas décrites ici. Consultez le
paragraphe "Autres options de configuration" pour une courte
descriptions de quelques options non détaillées ici. Avec <CODE>make
menuconfig</CODE> vous pouvez utiliser la barre d'espace.</P>
<P>À partir des versions 2.0.x, une option "?" est présente : elle
permet d'obtenir une aide pour l'option désirée qui correspond sûrement aux
informations les plus à jour. Voici une liste décrivant brièvement les
options les plus importantes avec leur place dans la hiérarchie (NdT : et la
traduction de l'intitulé).</P>

<H3>Kernel math emulation (Precessor type and features)</H3>


<P><I>(Émulation du coprocesseur Arithmétique)</I> Si vous ne possédez pas de
coprocesseur arithmétique (autrement dit, vous ne disposez que d'un 386 ou
d'un 486SX), répondez "<CODE>y</CODE>".  Si vous en avez un et que vous
répondez "<CODE>y</CODE>", ce n'est pas grave : le coprocesseur sera
utilisé et l'émulation ignorée. Pour toute machine pas trop vieille, la
réponse sera non.</P>

<H3>Enhanced (MFM/RLL) disk and IDE disk/cdrom support (Block Devices)</H3>


<P><I>(Gestion améliorée des disques durs)</I>
Vous devez à peu près toujours répondre oui à cette question. Cela signifie 
que le  noyau pourra gérer les disques standards des PC comme IDE, que 
bon nombre de gens possèdent. Ceci n'inclut pas les disques SCSI : ils 
sont sélectionnables plus tard dans la configuration.</P>
<P>Une question porte sur les gestionnaires de périphériques "old
disk-only" et "new IDE". Vous devez choisir l'un des deux.  La
principale différence est que le vieux gestionnaire de périphérique ne
supporte qu'au plus deux disques sur une seule interface. Le nouveau
gestionnaire gère une deuxième interface IDE et les disques CD-ROM IDE/ATAPI
, et il est plus gros de 4 ko que l'ancien. Il est supposé "amélioré"
ce qui signifie qu'à part avoir un nombre différent de bogues il peut
améliorer les performances de votre disque, notamment si vous possédez du
matériel récent (comme de l'EIDE).</P>

<H3>Networking support (General Setup)</H3>


<P><I>(Gestion du Réseau)</I> En principe, vous ne devriez répondre
"<CODE>y</CODE>" que si votre machine se trouve sur un réseau tel
qu'Internet ou si vous voulez utiliser SLIP, PPP, term, etc. pour
communiquer avec un accès Internet externe.  Toutefois, bon nombre de
paquetages (tels que le système X Window) ont besoin de ce support réseau
même si votre machine n'y est pas reliée ; dans ce cas, répondez
"<CODE>y</CODE>".  Plus tard, on vous demandera si vous voulez avoir le
support TCP/IP. De même, répondez "<CODE>y</CODE>", à moins que vous ne
soyez sûr de ce que vous faites.</P>

<H3>System V IPC (General Setup)</H3>

<P> </P>
<P>L'une des meilleures définition des IPC (communication inter-processus) se
trouve dans le glossaire du livre de Perl. Ces mécanismes sont utilisés par
certains développeurs Perl et quelques autres paquetages (comme par exemple
DOOM), donc ce n'est pas vraiment une bonne idée de répondre
"<CODE>n</CODE>" à cette question à moins que vous ne sachiez exactement
ce que vous faites.</P>

<H3>Processor family (Processor type and features)</H3>


<P><I>(Famille de processeur)</I> Dans les anciens noyaux, il s'agissait de
l'option Use -m486 flag for 486-specific optimizations.</P>
<P>Cette option sélectionnait certaines optimisations pour un type de processeur, le
noyau fonctionnant normalement avec les autres processeurs. Le noyau généré
avait toutefois une taille légèrement supérieure. Dans les nouveaux noyaux,
cette différence de taille n'est plus d'actualité donc vous pouvez indiquer
le processeur que vous allez utiliser avec le nouveau noyau. Un noyau
"386" fonctionnera avec toutes les machines.</P>

<H3>SCSI support</H3>


<P><I> (Gestion SCSI)</I> Si vous avez au moins un périphérique SCSI,
répondez "<CODE>y</CODE>".  On vous demandera alors de plus amples
renseignements sur la gestion des CD-ROM, des disques, et quel type de
contrôleur SCSI vous possédez. Consultez le SCSI-HOWTO pour plus de détails.</P>

<H3>Network device support</H3>


<P><I>(Gestion de périphériques réseau)</I> Si vous avez une carte réseau, ou
si vous voulez utiliser SLIP, PPP, ou un adaptateur sur port parallèle, répondez
"<CODE>y</CODE>".  Le script de configuration vous demandera alors quel
type de carte vous possédez et quels protocoles vous voulez inclure.</P>

<H3>Filesystems</H3>


<P><I>(Systèmes de fichiers)</I> On vous demandera quels types de systèmes de
fichiers vous souhaitez gérer :</P>
<P>Standard (minix) - Les distributions récentes ne créent pas de systèmes de
fichiers de type minix, et bon nombre de personnes ne s'en servent pas, mais
cela peut être malgré tout une bonne idée de le configurer. Quelques
programmes de "sauvetage de disques" l'utilisent, et encore
aujourd'hui, un bon nombre de disquettes risquent d'avoir ce système de
fichiers, car il est assez pratique pour les disquettes.</P>
<P>Second extended - C'est le système de fichiers standard de Linux. Vous en
aurez très certainement besoin, donc "<CODE>y</CODE>".
(NdT : et puis c'est un Français qui l'a fait alors... !)</P>
<P>msdos - Si vous voulez utiliser les partitions de votre disque MS-DOS,
ou monter des disquettes au format MS-DOS, répondez "<CODE>y</CODE>".</P>
<P>Des systèmes de fichiers originaires d'autres systèmes d'exploitation sont
également disponibles.</P>
<P>/proc - Un des systèmes de fichiers les plus puissants (idée effrontément
chipée aux Laboratoires Bell, je pense). Ça n'a rien à voir avec vos
partitions disques, mais c'est une interface sous forme de système de fichiers
avec le noyau et les processus. Un grand nombre d'outils de visualisation de
processus (comme "<CODE>ps</CODE>") l'utilisent. Si vous l'avez installé,
essayez "<CODE>cat /proc/meminfo</CODE>" ou "<CODE>cat
/proc/devices</CODE>".  Quelques shells (comme rc) utilisent
<CODE>/proc/self/fd</CODE> (connu comme <CODE>/dev/fd</CODE> sur d'autres systèmes)
pour les entrées/sorties.  Vous devriez répondre "<CODE>y</CODE>" à ceci
: de nombreux programmes Linux standards en ont besoin.</P>
<P>NFS - Si vous êtes en réseau et que vous voulez utiliser des volumes
présents sur d'autres machines, répondez "<CODE>y</CODE>".</P>
<P>ISO9660 - Format rencontré sur la plupart des CD-ROM. Si vous possédez un
CD-ROM et que vous comptez vous en servir sous Linux, répondez
"<CODE>y</CODE>".</P>

<H3>Mais je ne sais pas de quels systèmes de fichiers j'ai besoin !</H3>


<P>Bon, tapez "<CODE>mount</CODE>", cela va vous afficher un truc comme ça :</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        blah# mount
        /dev/hda1 on / type ext2 (defaults)
        /dev/hda3 on /usr type ext2 (defaults)
        none on /proc type proc (defaults)
        /dev/fd0 on /mnt type msdos (defaults)
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Observez chacune des lignes. Le mot à côté de "<CODE>type</CODE>" est le
type du système de fichiers. Dans cet exemple, mes partitions <CODE>/</CODE> et
<CODE>/usr</CODE> sont du type ext2fs, j'utilise <CODE>/proc</CODE>, et il y a une
disquette montée avec le système de fichiers MS-DOS (beuurrrk !).</P>
<P>Essayez "<CODE>cat /proc/filesystems</CODE>" si vous avez
<CODE>/proc</CODE>. Cela vous donnera la liste des systèmes de fichiers que
votre noyau gère.</P>
<P>Le support de systèmes de fichiers rarement utilisés et qui ne sont pas
absolument nécessaires peut augmenter la taille du noyau. Voir la section
sur les modules chargeables pour résoudre ce problème, ainsi que la section
sur les pièges.</P>

<H3>Character devices</H3>


<P><I>(Périphériques caractère)</I> Vous trouverez ici les pilotes pour gérer
votre imprimante parallèle, souris bus, souris PS/2 (beaucoup de portables
utilisent une souris constructeur de type PS/2), quelques lecteurs de bande
et d'autres périphériques de type "caractère". Répondez en
conséquence.</P>
<P>Note : "gpm" est un programme qui vous permet d'utiliser la souris à
l'extérieur de X Window pour effectuer des opérations de copier-coller entre
les consoles virtuelles. C'est assez utile si vous avez une souris série,
car cela coexiste bien avec X Window, mais vous devrez faire quelques trucs
pour que cela fonctionne avec les autres.</P>

<H3>Sound</H3>


<P><I>(Son)</I> Si vous tenez à entendre <CODE>biff</CODE> aboyer, répondez
"<CODE>y</CODE>", puis donnez au programme de configuration tout ce qu'il
veut savoir sur votre carte son. À propos : lorsqu'il vous demande si vous
voulez installer la version entière du pilote, vous pouvez répondre
`<CODE>n</CODE>' et donc économiser de la mémoire en insérant uniquement les
caractéristiques dont vous avez besoin.</P>
<P>Si vous vous intéressez de près au support des cartes son, jetez un oeil sur
les pilotes libres à 
<A HREF="http://www.linux.org.uk/OSS/">http://www.linux.org.uk/OSS/</A> et au Open
Sound System (commercial) à 
<A HREF="http://www.opensound.com/">http://www.opensound.com/</A>.</P>

<H3>Autres options de configuration</H3>


<P>Toutes les options de configuration ne sont pas détaillées dans ce
document car elles changent trop souvent ou bien sont vraiment évidentes
(par exemple, le support de la carte 3Com 3C509 permet la compilation du
pilote de cette carte). L'aide en ligne fournit une liste assez complète de
ces options (plus une manière de les insérer dans le script
<CODE>Configure</CODE>) mise à jour par Axel Boldt
(<CODE>boldt@math.ucsb.edu</CODE>). La liste est dans le fichier
<CODE>Documentation/Configure.help</CODE> des sources du noyau depuis la version
2.0.</P>

<H3>Kernel hacking </H3>


<P>Extrait du README de Linus :</P>
<P>La configuration "kernel hacking" provoque généralement un noyau
plus gros ou plus lent (ou les deux), et peut même rendre le noyau 
moins stable en configurant quelques routines pour essayer de 
chercher les défauts du code, pour trouver les problèmes du noyau
(kmalloc()). Donc, vous devrez répondre "n" à cette question si
vous créez un noyau pour un système sûr.</P>

<H2><A NAME="ss3.4">3.4 Garçon, la suite ! (Le Makefile) </A>
</H2>


<P>Quand la configuration est terminée, un message vous indique que le noyau
est configuré, et qu'il faut "regarder le Makefile général pour des
configurations supplémentaires", etc.</P>
<P>Donc, jetez un coup d'oeil au Makefile. Vous ne changerez probablement rien,
mais ça ne peut pas vous faire de mal ! Vous pourrez également changer les
options avec la commande "<CODE>rdev</CODE>" quand le noyau sera prêt. Si
vous ne comprenez rien à ce fichier, passez à la suite.</P>


<H2><A NAME="s4">4. Compiler le noyau </A></H2>



<H2><A NAME="ss4.1">4.1 Nettoyer et chercher les dépendances</A>
</H2>


<P>Lorsque le script de configuration va se terminer, il vous demandera de
faire un "<CODE>make dep</CODE>" et (peut-être) "<CODE>make
clean</CODE>". "<CODE>make dep</CODE>" assure que toutes les
dépendances, comme les fichiers d'en-têtes (include) sont en place, et ne prend pas trop
de temps à moins que vous n'ayez une machine très lente. Pour les anciennes
versions, lorsque c'est terminé faites un "<CODE>make clean</CODE>".
Cela détruit tous les fichiers objets et d'autres fichiers que les anciennes
versions laissent trainer. <I>N'oubliez pas</I> cette étape avant de
recompiler un noyau.</P>

<H2><A NAME="ss4.2">4.2 La compilation </A>
</H2>


<P>Après avoir cherché les dépendances et nettoyé l'arborescence, vous pouvez
lancer la compilation par "<CODE>make bzImage</CODE>" ou "<CODE>make
bzdisk</CODE>" (c'est cette partie qui prend du temps).  "<CODE>make
bzImage</CODE>" va compiler le noyau, et créer le fichier
"<CODE>bzImage</CODE>" dans le répertoire <CODE>arch/i386/boot</CODE> qui
correspond au nouveau noyau compressé.  "<CODE>make bzdisk</CODE>" fait
la même chose, mais copie le noyau sur une disquette que vous aurez insérée
dans le lecteur "A:".</P>
<P>"<CODE>bzdisk</CODE>" est assez commode pour tester de nouveaux noyaux ;
s'il ne fonctionne pas, enlevez juste la disquette et relancez la machine
avec votre ancien noyau. C'est également une méthode pratique si vous avez
détruit accidentellement votre noyau (ou quelque chose de ce genre). Vous
pouvez également vous en servir pour installer de nouveaux systèmes, en
copiant directement le contenu d'un disque sur un autre ("tout ça ? ouah
!").</P>
<P>Tous les noyaux assez récents sont compressés, comme l'indique le
"<CODE>bz</CODE>" au début des noms. Un noyau compressé est
automatiquement décompacté lors de l'exécution.</P>
<P>Pour les noyaux plus anciens, <CODE>bzImage</CODE> n'existait pas et on
utilisait <CODE>zImage</CODE>. Cette possibilité est toujours disponible mais
vue la taille des noyaux récents il est à peu près obligatoire d'utiliser
<CODE>bzImage</CODE> car l'ancienne méthode ne peut gérer que des noyaux de
taille limitée.</P>

<H2><A NAME="ss4.3">4.3 Les autres options du "make"</A>
</H2>


<P>"<CODE>make mrproper</CODE>" est un "<CODE>make clean</CODE>" plus
puissant. Cela est parfois nécessaire, vous devriez le faire à chaque
patch. Il efface également votre fichier de configuration donc il faudra
éventuellement en faire une copie avant (<CODE>.config</CODE>).</P>
<P>"<CODE>make oldconfig</CODE>" essaiera de configurer le noyau à partir
d'un vieux fichier de configation, il choisira toutes les options de
"<CODE>make config</CODE>" pour vous. Si c'est la première fois que vous
compilez un noyau ou si vous n'avez pas un ancien fichier de configuration
n'utilisez pas ceci, vous devrez sans doute changer la configuration par
défaut.</P>
<P>Regardez la section sur les modules à propos du "<CODE>make
modules</CODE>".</P>

<H2><A NAME="ss4.4">4.4 Installer le noyau </A>
</H2>


<P>Une fois que vous avez un nouveau noyau qui semble fonctionner comme vous le
voulez, il est grand temps de l'installer. La plupart des gens utilisent
LILO (LInux LOader).  "<CODE>make zlilo</CODE>" installera votre noyau,
lancera LILO, et laissera votre machine prête à rebooter, mais SEULEMENT si
lilo est configuré de la manière suivante : le noyau s'appelle
<CODE>/vmlinuz</CODE>, lilo se trouve dans <CODE>/sbin</CODE>, et votre fichier de
configuration pour LILO (<CODE>/etc/lilo.conf</CODE>) correspond à ces données.</P>
<P>Sinon, vous devrez utiliser LILO directement.  C'est un produit assez facile
à installer, mais dont le fichier de configuration peut être
déroutant. Regardez le fichier de configuration (<CODE>/etc/lilo/config</CODE>
pour les versions les plus anciennes, <CODE>/etc/lilo.conf</CODE> pour les
récentes), et regardez son contenu.  Le fichier de configuration doit
ressembler à ceci :</P>
<P>
<PRE>
    image = /vmlinux
        label = Linux
        root = /dev/hda1
        ...
</PRE>
</P>
<P>La ligne "<CODE>image =</CODE>" sert à indiquer le nom du noyau utilisé.
Beaucoup de gens utilisent <CODE>/vmlinuz</CODE>.  "<CODE>label</CODE>"
servira à indiquer à LILO sur quel noyau ou sur quel système d'exploitation
vous allez booter (nom logique), et "<CODE>root</CODE>" est la partition
racine de ce système d'expoitation.  Faites une sauvegarde de votre vieux
noyau (quel que soit son nom), et copiez le nouveau noyau (bzImage) à sa
place : "<CODE>cp bzImage /vmlinuz</CODE>" si vous utilisez
"<CODE>/vmlinuz</CODE>", puis relancez lilo. Sur les systèmes récents,
vous pouvez simplement lancer "<CODE>lilo</CODE>", mais sur de plus
anciens, vous devez faire un <CODE>/etc/lilo/install</CODE> ou
<CODE>/etc/lilo/lilo -C /etc/lilo/config</CODE>.</P>
<P>Si vous désirez en savoir plus sur la configuration de LILO, ou si vous voulez
avoir LILO, récupérez la dernière version sur votre site FTP favori et 
suivez les instructions.</P>
<P>Pour booter sur l'un de vos anciens noyaux situés sur votre disque dur (une
autre méthode de secours quand le noyau plante), copiez les lignes suivantes
"<CODE>image = xxx</CODE>" à la fin du fichier de configuration LILO, et
changez "<CODE>image = xxx</CODE>" par "<CODE>image = yyy</CODE>", où
"<CODE>yyy</CODE>" est le chemin complet du noyau de secours. Puis
changez "<CODE>label = zzz</CODE>" en "<CODE>label =
linux-sauvegarde</CODE>" et relancez <CODE>lilo</CODE>.  Si elle n'y est pas,
vous devrez rajouter une ligne dans le fichier de configuration indiquant
"<CODE>delay=x</CODE>", où x est le temps en dixième de secondes qui
indique à LILO le temps qu'il doit attendre avant d'amorcer la machine.
Vous pouvez l'interrompre (avec la touche shift par exemple), et taper le
label de l'image du noyau de sauvegarde (au cas où un problème se produit).</P>


<H2><A NAME="s5">5. Mettre à jour le noyau </A></H2>



<H2><A NAME="ss5.1">5.1 Appliquer un patch </A>
</H2>


<P>Les nouvelles versions du noyau sont distribuées sous la forme de patches.
Par exemple, si vous possédez la version 1.1.45, et que vous remarquez qu'il
existe un "<CODE>patch46.gz</CODE>", cela signifie que vous pouvez passer
à la version 1.1.46 en appliquant ce patch. Vous devriez faire avant une
sauvegarde de votre arborescence des sources du noyau ("<CODE>make
clean</CODE>" puis "<CODE>cd /usr/src; tar zcf old-tree.tar.gz
linux</CODE>" va produire une archive compressée).</P>
<P>Poursuivons avec cet exemple et supposons que vous ayez mis le fichier
"<CODE>patch46.gz</CODE>" dans <CODE>/usr/src</CODE>. Allez dans
<CODE>/usr/src</CODE> et faites un "<CODE>zcat patch46.gz | patch -p0</CODE>"
(ou "<CODE>patch -p0 &lt; patch46</CODE>" si le patch n'est pas
compressé).  Vous verrez alors une liste de messages vous indiquant les
essais de modifications. Cela marche ou pas (en principe oui !).
Généralement, cela va trop vite pour lire, et on ne sait pas trop si ça a
marché. Vous pouvez utiliser l'option <CODE>-s</CODE> de <CODE>patch</CODE> qui lui
indique qu'il ne doit afficher que les erreurs (vous n'avez pas grand chose
à faire des "héhé, mon ordinateur est en train de faire quelque
chose...!").  Pour vérifier que tout s'est passé sans encombre, allez
dans <CODE>/usr/src/linux</CODE> et cherchez les fichiers ayant pour extension
<CODE>.rej</CODE>. Quelques versions de patch (vieilles versions) utilisent
<CODE>#</CODE> pour les fichiers rejetés. Vous pouvez utiliser
"<CODE>find</CODE>" pour les trouver :
<PRE>
        find .  -name '*.rej' -print
</PRE>

vous en donnera la liste avec le chemin pour y accéder.</P>
<P>Si tout a marché, faites un "<CODE>make clean</CODE>",
"<CODE>config</CODE>," et "<CODE>dep</CODE>" comme décrit dans les
sections 3 et 4.</P>
<P>La commande <CODE>patch</CODE> possède quelques options.  Comme indiqué
ci-dessus, <CODE>patch -s</CODE> supprime tous les messages sauf les erreurs. Si
vous stockez les sources de votre noyau dans un autre répertoire que
<CODE>/usr/src/linux</CODE>, un <CODE>patch -p1</CODE> dans ce répertoire fera les
choses proprement. Les autres options sont bien documentées dans les pages
de manuel.</P>

<H2><A NAME="ss5.2">5.2 Si quelque chose ne fonctionne pas</A>
</H2>


<P>(Note : cette section traite plutôt des noyaux assez anciens)</P>
<P>Le problème le plus fréquent qui se présentait était lorsqu'un patch
modifiait le fichier "<CODE>config.in</CODE>" et que vous aviez changé
les options pour mieux coller à votre machine.  En principe, ça ne devrait
plus trop se produire, mais avec les anciennes versions... Pour résoudre ce
problème, jetez un coup d'oeil au fichier <CODE>config.in.rej</CODE> et regardez
son contenu.  Le changement sera indiqué par "<CODE>+</CODE>" et
"<CODE>-</CODE>" au début d'une ligne. Regardez ces lignes et retenez si
elles sont marquées "<CODE>y</CODE>" ou "<CODE>n</CODE>". Maintenant,
éditez <CODE>config.in</CODE>, et changez les "<CODE>y</CODE>" en
"<CODE>n</CODE>" et les "<CODE>n</CODE>" en "<CODE>y</CODE>"
lorsque cela est nécessaire. Faites un
<PRE>
        patch -p0 &lt; config.in.rej
</PRE>

et si cela fonctionne ("<CODE>no fails</CODE>"), alors vous pouvez
continuer avec la configuration et la compilation. Le fichier
<CODE>config.in.rej</CODE> restera, mais vous pouvez le détruire.</P>
<P>Si vous avez d'autres problèmes, vous avez peut-être installé un patch
défectueux.  Si la commande patch indique "<CODE>previously applied patch
detected: Assume -R?</CODE>", vous êtes probablement en train d'appliquer
un patch déjà appliqué.  Si vous répondez "<CODE>y</CODE>", cela risque
de détruire votre source et il vous faudra récupérer un source complet (vous
auriez peut-être dû commencer par là).</P>
<P>Pour revenir en arrière (dépatcher), faites un "<CODE>patch -R</CODE>"
sur le patch original.</P>
<P>La meilleure chose à faire lorsqu'un patch détruit tout est de repartir d'un
noyau initial tout neuf ! (par exemple, à partir du fichier
<CODE>linux-x.y.z.tar.gz</CODE>).</P>

<H2><A NAME="ss5.3">5.3 Comment se débarasser des fichiers .orig ?</A>
</H2>

<P> </P>
<P>Après avoir appliqué quelques patches, les fichiers <CODE>.orig</CODE>  
vont commencer à s'empiler. Par exemple, j'en étais à la version
1.1.51 et la dernière fois que j'avais fait le ménage, c'était avec la version
1.1.48 (je crois...). Détruire les fichiers .orig a permis de récupérer
plus d'un demi Méga octets. 
<PRE>
        find .  -name '*.orig' -exec rm -f {} ';'
</PRE>

fera cela pour vous. Quelques versions de <CODE>patch</CODE> qui utilisent 
<CODE>#</CODE> pour les rejets utilisent un tilde à la place 
de <CODE>.orig</CODE>.</P>
<P>Il y a d'autres manières (meilleures ?) pour se débarrasser des fichiers
.orig en utilisant le programme GNU <CODE>xargs</CODE> :
<PRE>
        find .  -name '*.orig' | xargs rm
</PRE>

ou la méthode sûre mais un peu plus verbeuse :
<PRE>
        find . -name '*.orig' -print0 | xargs --null rm --
</PRE>
</P>

<H2><A NAME="ss5.4">5.4 Autres patches</A>
</H2>


<P>Il y a d'autres patches (je les appellerai "non-standards") que
ceux distribués par Linus. Si vous les appliquez, les patches Linus risquent de
ne plus marcher correctement et vous serez obligé soit de les enlever, soit
d'adapter les patches. C'est généralement un travail assez pénible pour les
novices, aussi revenir aux anciennes sources avant d'appliquer les patches de
<B>Linux</B> semble être une bonne solution. Après, vous pouvez regarder
si les patches non standards fonctionnent. S'ils ne fonctionnent pas, vous
pouvez revenir à l'ancienne version, ou essayer de modifier le patch pour le
faire fonctionner, ou encore attendre qu'un nouveau patch arrive.</P>
<P>Vous entendrez probablement parler de ces patches non standards. J'utilisais
le patch "noblink" car j'ai horreur des curseurs qui clignotent (ce
patch est (ou bien était) mis à jour fréquemment pour les nouveaux
noyaux). Les pilotes de périphériques étant de plus développés sous la forme
de modules chargeables, le nombre de patches "non standards" décroît.</P>


<H2><A NAME="s6">6. Paquetages supplémentaires</A></H2>


<P>Votre noyau Linux a bon nombre de caractéristiques qui ne sont pas
expliquées dans le noyau lui-même ; elles sont typiquement utilisées par des
paquetages externes.  Une liste des plus utiles est donnée ici.</P>

<H2><A NAME="ss6.1">6.1 kbd</A>
</H2>


<P>La console de Linux possède de nombreuses caractéristiques. Elle peut
changer les polices de caractères, remapper le clavier, permuter les modes
vidéos (dans les noyaux les plus récents), etc. Le package kbd possède des
programmes qui permettent à l'utilisateur de faire tout cela, plus une tonne
de fontes et de types de claviers. (NdT : fr.map pour le clavier
français). Il est disponible sur les mêmes sites qui proposent les sources
du noyau.</P>

<H2><A NAME="ss6.2">6.2 util-linux</A>
</H2>


<P>Rik Faith (<CODE>faith@cs.unc.edu</CODE>) a rassemblé une grande quantité
d'outils Linux dans le paquetage util-linux. Ils est désormais maintenu par
Andries Brouwer (<CODE>util-linux@math.uio.no</CODE>). Disponible via ftp
anonyme sur sunsite.unc.edu dans <CODE>/pub/Linux/system/misc</CODE>, il
contient des programmes tels que <CODE>setterm</CODE>, <CODE>rdev</CODE>, et
<CODE>ctrlaltdel</CODE>, qui concernent le noyau. Comme le dit Rik,
<I>n'installez pas sans réfléchir</I>, vous n'avez pas besoin de tout
installer dans la distribution, et cela pourrait vous causer de graves
ennuis.</P>

<H2><A NAME="ss6.3">6.3 hdparm</A>
</H2>


<P>Comme beaucoup de paquetages, c'était au départ un patch pour le noyau et un
ensemble de programmes. Le patch a été intégré dans le noyau standard et les
programmes pour optimiser et jouer avec vos disques sont distribués
séparément.</P>

<H2><A NAME="ss6.4">6.4 gpm</A>
</H2>

<P> </P>
<P>gpm est un gestionnaire de souris. Ce programme vous permet
d'effectuer du couper-coller en mode texte entre les consoles virtuelles
ainsi que d'autres opérations avec un grand nombre de types de souris.</P>


<H2><A NAME="s7">7. Quelques pièges</A></H2>



<H2><A NAME="ss7.1">7.1 make clean </A>
</H2>


<P>Si votre noyau a un comportement surnaturel (ça m'est arrivé !), il y a des
chances pour que vous ayez oublié de faire un "make clean".  Les
symptômes peuvent être un plantage de votre système, des problèmes
d'entrées-sorties étranges, une chute des performances, des reboot
aléatoires... Vérifiez que vous avez également fait un <CODE>make dep</CODE>.</P>

<H2><A NAME="ss7.2">7.2 Noyaux énormes ou lents</A>
</H2>


<P>Si votre noyau consomme beaucoup de mémoire, ou s'il est réellement gros, ou
bien s'il faut une éternité pour le compiler même lorsque vous utilisez
votre nouveau 986DX6/440, c'est que vous avez configuré un tas de choses
(pilotes de périphériques, systèmes de fichiers) dont vous n'avez pas
besoin.  Si vous ne les utilisez pas, ne les configurez pas car cela prend
beaucoup de place en mémoire.  Le symptôme le plus visible est
l'augmentation sensible du fonctionnement du swap. Si votre disque fait
beaucoup de bruit, et qu'il ne s'agit pas d'un de ces vieux disques Fujitsu
Eagles qui font le bruit d'un avion lors de son atterrissage lorsque vous
l'éteignez, jetez un coup d'oeil à votre configuration.</P>
<P>Vous pouvez calculer la taille mémoire que le noyau utilise en prenant
la mémoire totale de votre machine et en soustrayant la valeur
de la mémoire totale ("total mem") dans  <CODE>/proc/meminfo</CODE>  
ou bien avec la commande "<CODE>free</CODE>".</P>

<H2><A NAME="ss7.3">7.3 Le port parallèle ne fonctionne pas/mon imprimante ne fonctionne</A>
pas</H2>


<P>Les options de configuration pour les PC sont : premièrement, dans la
catégorie "General Setup" sélectionnez "Parallel port support"
et "PC-style hardware". Puis dans "Character devices",
sélectionnez "Parallel printer support".</P>
<P>Il y a ensuite le problème des noms de périphérique des imprimantes qui ont
changé dans Linux 2.2. Si vous aviez une imprimante <CODE>lp1</CODE> avec votre
noyau précédent, elle s'appelle probablement <CODE>lp0</CODE>
maintenant. Utilisez "<CODE>dmesg</CODE>" ou cherchez dans les logs dans
<CODE>/var/log</CODE> pour le vérifier.</P>

<H2><A NAME="ss7.4">7.4 Le noyau ne compile pas</A>
</H2>


<P>Si cela ne compile pas, alors un patch a probablement échoué, ou bien vous
possédez des sources corrompus. Votre version de gcc peut également ne pas
être correcte, ou bien endommagée (par exemple les fichiers d'include
peuvent être faux). Soyez sûr que les liens que Linus décrit dans le fichier
README sont corrects. En général, si un noyau standard ne compile pas, c'est
qu'un truc ne tourne pas rond dans le système, et il est plus que probable
que certains outils doivent être reinstallés.</P>
<P>Dans des cas relativement rares, gcc peut échouer en raison de problèmes de
matériel. Le message d'erreur ressemble à un truc assez mystérieux "xxx
exited with signal 15".  Je n'en n'aurais probablement pas parlé si cela
ne m'était arrivé une fois.  J'avais un cache mémoire défectueux et le
compilateur fonctionnait de manière plutôt aléatoire. Essayez dans un
premier temps de reinstaller gcc si vous avez des problèmes. Si votre noyau
compile très bien avec les caches externes vidés ou une mémoire réduite,
alors vous pourrez commencer à soupçonner votre matériel.</P>
<P>Certaines personnes ont tendance à ne pas aimer que je mette en doute leur
matériel. Je n'invente rien. Il existe une FAQ dédiée à ce sujet : 
<A HREF="http://www.bitwizard.nl/sig11/">http://www.bitwizard.nl/sig11/</A> (NdT : traduite en français à 
<A HREF="http://www.linux-france.org/article/sig11-fr/sig11-fr.html">http://www.linux-france.org/article/sig11-fr/sig11-fr.html</A>).</P>

<H2><A NAME="ss7.5">7.5 La nouvelle version du noyau ne boote plus !</A>
</H2>


<P>Soit LILO ne fonctionne pas, soit il n'est pas configuré correctement.  Une
fois, un problème dans le fichier de configuration m'a posé pas mal de soucis :
j'avais mis "<CODE>boot = /dev/hda1</CODE>" à la place de "<CODE>boot =
/dev/hda</CODE>" (ce genre d'erreurs n'est pas facile à trouver, mais une
fois que vous avez un fichier de configuration qui fonctionne, il n'y a pas
de raison d'y toucher).</P>

<H2><A NAME="ss7.6">7.6 Vous avez oublié de lancer LILO, ou le système ne boote plus du</A>
tout</H2>


<P>Argh ! La meilleure chose à faire est de booter à partir d'une disquette et
de préparer une nouvelle disquette de boot ("<CODE>make zdisk</CODE>"
fait cela très bien).  Vous avez besoin de savoir o&ugrave; votre partition
racine (<CODE>/</CODE>) se trouve et quel est son type (ext2fs, minix,
etc). Dans l'exemple ci-dessous, vous aurez également besoin de connaître la
partition des sources du noyau (<CODE>/usr/src/linux</CODE>), et o&ugrave; elle
est montée.</P>
<P>Dans cet exemple,la racine <CODE>/</CODE> est <CODE>/dev/hda1</CODE>, la partition
qui supporte <CODE>/usr/src/linux</CODE> est <CODE>/dev/hda3</CODE>, normalement
montée sur <CODE>/usr</CODE>. Toutes les deux ont un système de fichiers de type
ext2fs. L'image du noyau se trouve dans
<CODE>/usr/src/linux/arch/i386/boot/</CODE> et elle s'appelle <CODE>bzImage</CODE>.</P>
<P>L'idée est que s'il existe un noyau <CODE>bzImage</CODE> qui fonctionne il est
possible de l'utiliser pour la nouvelle disquette.  Une autre possibilité
qui peut être meilleure ou pas est présentée après cet exemple (cela dépend
de la façon dont vous avez planté votre système).</P>
<P>Commencez par booter à partir d'une disquette d'installation (boot/root) ou
d'une disquette de secours et montez la partition o&ugrave; se trouve le
noyau en état de marche :</P>
<P>
<PRE>
        mkdir /mnt
        mount -t ext2 /dev/hda3 /mnt
</PRE>
</P>
<P>Si <CODE>mkdir</CODE> vous annonce que le répertoire existe, ignorez le message.
Maintenant, allez dans le répertoire où se trouve le noyau en état de marche.
Notez que  
<PRE>
/mnt + /usr/src/linux/arch/i386/boot - /usr = /mnt/src/linux/arch/i386/boot
</PRE>

Insérez une disquette formatée dans le lecteur "A:" (vérifiez qu'il
ne s'agit pas de la disquette boot ou root !), faites une copie de l'image
sur le disque et configurez votre partition racine : </P>
<P>
<PRE>
cd /mnt/src/linux/arch/i386/boot
dd if=bzImage of=/dev/fd0
rdev /dev/fd0 /dev/hda1
</PRE>
</P>
<P>Allez à la racine <CODE>/</CODE>, et démontez la partition <CODE>/usr</CODE> :
<PRE>
cd /
umount /mnt
</PRE>
</P>
<P>Maintenant, vous devriez être capable de rebooter votre système normalement
à partir de cette disquette. N'oubliez pas de lancer lilo (ou ce que vous
aviez oublié) avant de rebooter !</P>
<P>Comme mentionné ci-dessus, il y a une autre manière très pratique. S'il se
trouve que vous avez un noyau opérationnel dans <CODE>/</CODE>
(<CODE>/vmlinuz</CODE> par exemple), on peut s'en servir. Supposons que vous
remplissiez les conditions ci-dessus, et que votre noyau s'appelle
<CODE>/vmlinuz</CODE>, faites comme ci-dessus en changeant <CODE>/dev/hda3</CODE> en
<CODE>/dev/hda1</CODE> (la partition <CODE>/</CODE>), <CODE>/mnt/src/linux</CODE> en
<CODE>/mnt</CODE>, et <CODE>if=bzImage</CODE> en <CODE>if=vmlinuz</CODE>.  La petite
note expliquant comment aller dans <CODE>/mnt/src/linux</CODE> peut être
oubliée.</P>
<P>Utiliser LILO avec de gros disques (avec un nombre de cyclindres supérieur à
1024) peut poser des problèmes. Consultez le mini-Howto LILO ou la
documentation.</P>

<H2><A NAME="ss7.7">7.7 Il me dit "warning: bdflush not running" </A>
</H2>


<P>Cela peut être un problème assez grave. Avec les noyaux ayant une version
supérieure à 1.0 (aux alentours du 20 avril 1994), le programme
"<CODE>update</CODE>" qui vide périodiquement les tampons disque a été
remplacé par "<CODE>bdflush</CODE>". Récupérez les sources de
"<CODE>bdflush</CODE>" (vous pouvez les récupérer là o&ugrave; vous avez
trouvé votre noyau), et compilez-le (il vaut mieux fonctionner avec un
ancien noyau pendant la compilation et pendant l'installation). Il
s'installera tout seul comme "<CODE>update</CODE>" et le nouveau noyau
devrait ensuite fonctionner correctement.</P>

<H2><A NAME="ss7.8">7.8 Je n'arrive pas à faire marcher mon CD-ROM IDE/ATAPI</A>
</H2>


<P>Aussi étrange que cela puisse paraître, beaucoup de gens n'arrivent pas
à faire fonctionner leurs disques ATAPI, tout simplement 
parce qu'il y a un bon nombre de problèmes potentiels.</P>
<P>Si votre CD-ROM est le seul disque d'une interface IDE particulière il doit
être configuré en "maître (master)" ou "seul (single)". C'est
l'erreur la plus fréquemment rencontrée.</P>
<P>Creative Labs (par exemple) a mis des interfaces IDE sur ses cartes sons.
Toutefois, cela pose un problème pour les gens qui ont déjà deux interfaces
IDE sur leur carte mère (IRQ15 généralement). Une pratique commune est de
faire de l'interface soundblaster un troisième port IDE (IRQ11 je pense).</P>
<P>Cela pose un problème avec Linux car les versions 1.2.x ne supportent
pas une troisième interface IDE (cela est géré avec les versions 1.3.x mais 
ce sont des versions de développement, et la troisième interface n'est 
pas détectée automatiquement). Pour résoudre ce problème, vous avez
plusieurs possibilités.</P>
<P>Si avez déjà un deuxième port IDE, il y a des chances pour que vous ne
l'utilisiez pas ou qu'il n'ait pas deux périphériques connectés.  Désactivez
l'interface ATAPI de la carte son (vous économisez un IRQ) et connectez le
disque sur votre seconde interface.</P>
<P>Si vous n'avez pas une seconde interface, mettez interface IDE (pas la
partie son) de la carte son sur l'IRQ 15. Cela devrait fonctionner.</P>

<H2><A NAME="ss7.9">7.9 Le noyau me dit des insanités à propos de requêtes obsolètes !</A>
</H2>


<P>Récupérez des versions récentes du progamme <CODE>route</CODE> et de tous les
autres programmes manipulant les routes :
<CODE>/usr/include/linux/route.h</CODE> (qui est en fait un fichier dans
<CODE>/usr/src/linux</CODE>) a changé.</P>

<H2><A NAME="ss7.10">7.10 Le Firewall ne fonctionne pas dans la version 1.2.0</A>
</H2>


<P>Passez à la version 1.2.1.</P>

<H2><A NAME="ss7.11">7.11 Ce n'est pas une image noyau compressée !</A>
</H2>


<P>N'utilisez pas le fichier <CODE>vmlinux</CODE> créé dans <CODE>/usr/src/linux</CODE>
comme image de boot mais <CODE>[..]/arch/i386/boot/bzImage</CODE>.</P>

<H2><A NAME="ss7.12">7.12 Problèmes avec la console après mise à jour à la version 1.3.x</A>
</H2>


<P>Changez le mot <CODE>dumb</CODE> en <CODE>linux</CODE> dans l'entrée console du
fichier <CODE>/etc/termcap</CODE>. Il faudra peut-être aussi ajouter une entrée
<CODE>terminfo</CODE>.</P>

<H2><A NAME="ss7.13">7.13 Le noyau ne semble pas pouvoir compiler après une mise à jour</A>
</H2>


<P>Le source du noyau contient un certain nombre de fichiers d'en-têtes (les
fichiers se terminant par <CODE>.h</CODE>) qui se trouvent dans le répertoire
<CODE>/usr/include</CODE>.  Ils sont référencés ainsi (où <CODE>xyzzy.h</CODE> doit
être dans <CODE>/usr/include/linux</CODE>) :
<PRE>
    #include &lt;linux/xyzzy.h>
</PRE>

Normalement, il y a un lien appelé <CODE>linux</CODE> dans <CODE>/usr/include</CODE>
sur le répertoire <CODE>include/linux</CODE> de la racine des sources du noyau
(<CODE>/usr/src/linux/include/linux</CODE> dans un système standard).  Si ce
lien n'existe pas, ou bien pointe au mauvais endroit, bon nombre de
programmes ne compileront pas. Si vous décidez que les sources du noyau
prennent trop de place sur votre disque et que vous les détruisez, cela sera
un problème. Un autre problème qui peut arriver, c'est avec les permissions
d'accès aux fichiers. Si votre <CODE>root</CODE> a un umask qui n'autorise pas
les autres utilisateurs à voir ses fichiers par défaut, et que vous
désarchiviez les sources du noyau sans l'option <CODE>p</CODE> (conserve le
mode), les utilisateurs ne pourront pas utiliser le compilateur C. Vous
pouvez alors utiliser la commande <CODE>chmod</CODE> pour résoudre le problème
mais il est probablement plus facile de réinstaller les fichiers include.
Vous pouvez procéder de la même manière que lors de l'installation des
sources au début, en ajoutant un argument pour n'extraire que les includes :
<PRE>
    blah# tar zxvpf linux.x.y.z.tar.gz linux/include
</PRE>

Notez que "<CODE>make config</CODE>" va recréer le lien
<CODE>/usr/src/linux</CODE> s'il n'existe pas.</P>

<H2><A NAME="ss7.14">7.14 Augmenter les limites</A>
</H2>


<P>Ces quelques <I>exemples</I> de commandes peuvent être assez utiles à ceux qui
se demandent comment augmenter certaines limites logicielles imposées par le
noyau :
<PRE>
 echo 4096 > /proc/sys/kernel/file-max
 echo 12288 > /proc/sys/kernel/inode-max
 echo 300 400 500 > /proc/sys/vm/freepages
</PRE>
</P>


<H2><A NAME="s8">8. Note concernant la mise à jour pour les noyaux 2.0.x, 2.2.x</A></H2>


<P>Les noyaux 2.0.x et 2.2.x ont introduit pas mal de modifications dans
l'installation du noyau. Le fichier <CODE>Documentation/Changes</CODE> situé
dans l'arborescence des sources 2.0.x contient des informations que vous
devez connaître lorsque vous effectuez la mise à jour de votre système. Il
est fort probable que vous deviez mettre à jour plusieurs paquetages tels
que gcc, libc et SysVInit ainsi que quelques fichiers systèmes. Mais ne
paniquez pas !</P>


<H2><A NAME="s9">9. Modules </A></H2>


<P>Les modules chargeables du noyau peuvent faire économiser de la mémoire et
faciliter la configuration. L'utilisation des modules s'est accrue jusqu'à
inclure les systèmes de fichiers, les pilotes de cartes ethernet, de
lecteurs de cartouches, d'imprimantes, etc.</P>

<H2><A NAME="ss9.1">9.1 Installer les utilitaires pour gérer les modules</A>
</H2>


<P>Ces utilitaires sont disponibles sur n'importe quel site o&ugrave; vous
avez récupéré les sources du noyau : <CODE>modutils-x.y.z.tar.gz</CODE>;
choisissez la dernière version <CODE>x.y.z</CODE> qui est égale ou inférieure à
votre version du noyau.  Installez-le avec `<CODE>tar zxvf
modutils-x.y.z.tar.gz</CODE>', <CODE>cd</CODE> dans le répertoire créé
(<CODE>modutils-x.y.z</CODE>), regardez le fichier <CODE>README</CODE>, et suivez
les instructions d'installation (qui sont en général très simples, du genre,
faites <CODE>make install</CODE>).  Vous devriez avoir maintenant les programmes
<CODE>insmod</CODE>, <CODE>rmmod</CODE>, <CODE>ksyms</CODE>, <CODE>lsmod</CODE>,
<CODE>genksyms</CODE>, <CODE>modprobe</CODE>, et <CODE>depmod</CODE> dans
<CODE>/sbin</CODE>. Vous pouvez les tester avec le pilote exemple "hw"
dans <CODE>insmod</CODE> ; regardez le fichier <CODE>INSTALL</CODE> dans ce
sous-répertoire pour les détails.</P>
<P><CODE>insmod</CODE> insère un module dans le noyau en cours d'exécution.  Les
modules ont généralement une extension <CODE>.o</CODE>.  Le pilote exemple est
appelé <CODE>drv_hello.o</CODE>, donc, pour l'insérer, <CODE>insmod
drv_hello.o</CODE>'. Pour voir les modules que le noyau utilise actuellement,
lancer <CODE>lsmod</CODE>.  Il devrait alors afficher :
<PRE>
blah# lsmod
Module:        #pages:  Used by:
drv_hello          1
</PRE>

`<CODE>drv_hello</CODE>' est le nom du module, il utilise une page mémoire (4ko),
et aucun autre module du noyau ne dépend actuellement de lui. Pour le
retirer, lancez `<CODE>rmmod drv_hello</CODE>'. Notez que <CODE>rmmod</CODE> prend
comme argument <I>le nom du module,</I> (celui donné par <CODE>lsmod</CODE>)
pas un nom de fichier. Les autres programmes de gestion des modules sont
documentés (pages de manuel).</P>

<H2><A NAME="ss9.2">9.2 Modules distribués avec le noyau</A>
</H2>


<P>Avec la version 2.0.30, presque tout est disponible sous forme de modules
chargeables. Pour les utiliser, soyez sûr que vous ne les insérez pas dans
la configuration du noyau. Pour cela, ne répondez pas <CODE>y</CODE> pendant le
`<CODE>make config</CODE>'.</P>
<P>Compilez un nouveau noyau et bootez avec. Puis, <CODE>cd</CODE> dans
<CODE>/usr/src/linux</CODE> à nouveau, et faites un `<CODE>make modules</CODE>'.
Cela va compiler tous les modules que vous n'avez pas spécifiés dans le
noyau et installer les liens dans <CODE>/usr/src/linux/modules</CODE>.  Vous
pouvez alors les utiliser depuis ce répertoire ou faire `<CODE>make
modules_install</CODE>' qui les installera dans <CODE>/lib/modules/x.y.z</CODE>,
ou <CODE>x.y.z</CODE> est le numéro de version du noyau.</P>
<P>Cela peut être particulièrement utile pour les systèmes de fichiers. Vous
n'utilisez peut-être pas fréquemment les systèmes de fichiers minix ou
msdos. Par exemple, si je rencontre une disquette msdos (beuh), je devrai
faire un <CODE>insmod /usr/src/linux/modules/msdos.o</CODE>, puis <CODE>rmmod
msdos</CODE> lorsque j'aurai terminé, Cette façon de procéder économise près
de 50 ko de RAM dans l'utilisation du noyau.  Remarque sur le système de
fichiers minix : il est très fortement conseillé de <I>toujours</I> le
configurer directement dans le noyau pour l'utilisation en disques de
secours.</P>


<H2><A NAME="s10">10. Trucs et astuces </A></H2>



<H2><A NAME="ss10.1">10.1 Rediriger la sortie standard des commandes make ou patch</A>
</H2>


<P>Si vous voulez voir ce que font les commandes "<CODE>make</CODE>" ou
"<CODE>patch</CODE>", vous pouvez rediriger les messages. Regardez
d'abord quel shell vous utilisez.  "<CODE>grep root /etc/passwd</CODE>"
et cherchez quelque chose comme "<CODE>/bin/csh</CODE>".</P>
<P>Si vous utilisez sh ou bash, 
<PRE>
        (commande) 2>&amp;1 | tee  (Fichier de sortie)
</PRE>

placera une copie de la sortie dans le fichier <CODE>(Fichier de sortie)</CODE>.</P>
<P>Pour csh ou tcsh, la syntaxe est :
<PRE>
(commande) |&amp; tee (Fichier de sortie).
</PRE>
</P>
<P>Pour rc (note : vous n'utilisez probablement pas rc) c'est :
<PRE>
        (commande) > [2=1]| tee (Fichier de sortie).
</PRE>
</P>

<H2><A NAME="ss10.2">10.2 Installations diverses du noyau </A>
</H2>


<P>En plus des disquettes, d'autres méthodes existent pour tester un nouveau
noyau sans détruire les précédents. À la différence d'autres systèmes Unix,
LILO est capable de booter sur un noyau situé n'importe o&ugrave; sur le
disque (si vous avez un gros disque (500 Mo ou plus) lisez la
documentation de LILO car cela risque de poser quelques problèmes). Donc,
ajoutez cela :
<PRE>
    image = /usr/src/linux/arch/i386/boot/bzImage
    label = nouveau_noyau
</PRE>
 </P>
<P>à la fin de votre fichier de configuration LILO, vous pouvez alors choisir
de booter sur le nouveau noyau sans avoir à détruire l'ancien
<CODE>/vmlinuz</CODE> (après avoir lancé <CODE>lilo</CODE>, bien sûr).  La manière
la plus simple d'indiquer à LILO qu'il doit booter sur un nouveau noyau est
de presser la touche shift au boot (lorsqu'il vous indique <CODE>LILO</CODE>) ce
qui vous donne un prompt.  À ce moment, tapez `<CODE>nouveau_noyau</CODE>' pour
qu'il boote sur le nouveau noyau.</P>
<P>Si vous désirez conserver plusieurs sources du noyau (cela peut prendre
<I>beaucoup</I> de place ; faites attention), la manière la plus simple
est de le nommer : <CODE>/usr/src/linux-x.y.z</CODE>, ou <CODE>x.y.z</CODE> est la
version du noyau.  Vous pouvez alors choisir le source à utiliser en faisant
un lien symbolique ; par exemple, `<CODE>ln -sf linux-1.2.2
/usr/src/linux</CODE>' indiquera la version 1.2.2 comme version
courante. Avant de créer ce type de lien symbolique, soyez certain que le
dernier argument de <CODE>ln</CODE> n'est pas un répertoire existant.  Le
résultat ne serait pas celui que vous espériez.</P>

<H2><A NAME="ss10.3">10.3 Mises à jour des noyaux</A>
</H2>


<P>Russell Nelson (<CODE>nelson@crynwr.com</CODE>) fait des résumés des changements
dans les nouvelles versions du noyau. Ils sont courts et vous devriez les
regarder avant de réaliser la mise à jour. Ils sont disponibles par ftp
anonyme à <CODE>ftp.emlist.com</CODE> dans <CODE>pub/kchanges</CODE> ou via WEB 
<A HREF="http://www.crynwr.com/kchanges">http://www.crynwr.com/kchanges</A>.</P>


<H2><A NAME="s11">11. D'autres HOWTO qui peuvent être utiles</A></H2>


<P>
<UL>
<LI> Sound-HOWTO : cartes sons et utilitaires</LI>
<LI> SCSI-HOWTO : tout sur les contrôleurs et périphériques SCSI</LI>
<LI> NET-2-HOWTO : réseaux</LI>
<LI> PPP-HOWTO : réseau avec PPP</LI>
<LI> PCMCIA-HOWTO : à propos des pilotes pour votre portable</LI>
<LI> ELF-HOWTO : ELF : qu'est-ce que c'est, installation, etc</LI>
<LI> Hardware-HOWTO : survol du matériel supporté</LI>
<LI> Module mini-HOWTO : plus de détails sur les modules du noyau</LI>
<LI> Kerneld mini-HOWTO : dédié à kerneld</LI>
<LI> BogoMips mini-HOWTO : pour information
</LI>
</UL>
</P>


<H2><A NAME="s12">12. Divers </A></H2>



<H2><A NAME="ss12.1">12.1 Auteur </A>
</H2>


<P>L'auteur du Kernel-HOWTO Linux est Brian Ward
(<CODE>bri@cs.uchicago.edu</CODE>). S'il vous plaît, envoyez-moi des
commentaires, corrections, rajouts. Les corrections sont en particulier très
importantes.</P>
<P>Vous pouvez jeter un coup d'oeil à ma page web 
<A HREF="http://www.math.psu.edu/bri/">ici</A> ou 
<A HREF="http://blah.math.tu-graz.ac.at/~bri/">là</A>.</P>
<P>Bien que j'essaye d'être attentif à mon courrier, rappelez-vous que j'en ai
<I>beaucoup</I> tous les jours, donc ça peut prendre un petit peu de temps
pour vous répondre. Si le mail est une question, essayez d'être le plus
clair et détaillé possible. Si vous m'écrivez à propos de matériel qui ne
fonctionne pas (ou quelques chose du genre), j'ai besoin de savoir quelle
est votre configuration matérielle. Si vous reportez une erreur, ne vous
limitez pas à "J'ai essayé ceci et ça n'a pas marché", j'ai besoin de
savoir quelle était l'erreur, et quelles versions du noyau, de gcc et de la
libc vous utilisez. Me donner le nom de la distribution n'est pas
suffisant. Ne craignez pas de poser des questions simples, si vous ne
demandez pas vous n'aurez pas de réponse ! Merci à tous ceux qui m'ont
envoyé des commentaires.</P>
<P>Si votre question ne concerne pas le noyau ou est écrite dans un langage que
je ne comprends pas, il se peut que je ne réponde pas.</P>
<P>Si vous m'écrivez et que vous n'obtenez aucune réponse dans un temps
raisonable (trois semaines ou plus), il y a des chances que j'ai
accidentellement détruit votre message (désolé). Rééssayez.</P>
<P>J'ai beaucoup de mail sur des problèmes et questions de matériel. Ce n'est
pas un problème mais merci de noter que que je ne suis pas familier avec
tout le matériel du monde. J'utilise des processeurs AMD, des controlleurs
SCSI Adaptec et Symbios et des disques SCSI IBM.</P>
<P>La version 0.1 de ce document a été écrite le 3 octobre 1994. Il est
disponible aux formats SGML, PostScript, TeX, roff et texte.</P>

<H2><A NAME="ss12.2">12.2 Reste à faire</A>
</H2>


<P>Le paragraphe "Trucs et astuces" est un peu court. J'espère l'étoffer
avec les suggestions venant d'autres personnes.  De même pour "Autres
paquetages". Des informations supplémentaires pour le
débogage/sauvetage lors de crash seraient les bienvenues.</P>

<H2><A NAME="ss12.3">12.3 Contributions </A>
</H2>


<P>Une petite partie du README de Linus (cf. option kernel hacking ) est incluse.
(Merci, Linus !)
<UL>
<LI><CODE>uc@brian.lunetix.de</CODE> (Ulrich Callmeier) : patch -s et xargs.
</LI>
<LI><CODE>quinlan@yggdrasil.com</CODE> (Daniel Quinlan) : corrections et
compléments dans un bon nombre de paragraphes.
</LI>
<LI><CODE>nat@nataa.frmug.eu.org</CODE> (Nat Makarévitch) : mrproper, tar -p,
et plein d'autres choses
</LI>
<LI><CODE>boldt@math.ucsb.edu</CODE> (Axel Boldt) : a rassemblé les descriptions
des options de configuration du noyau et m'a fourni la liste
</LI>
<LI><CODE>lembark@wrkhors.psyber.com</CODE> (Steve Lembark) : suggestion pour le 
boot multiple.
</LI>
<LI><CODE>kbriggs@earwax.pd.uwa.edu.au</CODE> (Keith Briggs) : quelques
corrections et suggestions
</LI>
<LI><CODE>rmcguire@freenet.columbus.oh.us </CODE>(Ryan McGuire): ajouts au
niveau des options de compilation
</LI>
<LI><CODE>Eric.Dumas@freenix.fr</CODE> (Eric Dumas) : traduction française
</LI>
<LI><CODE>simazaki@ab11.yamanashi.ac.jp</CODE> (Yasutada Shimazaki): traduction 
japonaise
</LI>
<LI><CODE>jjamor@lml.ls.fi.upm.es</CODE> (Juan Jose Amor Iglesias): traduction
espagnole
</LI>
<LI><CODE>mva@sbbs.se</CODE> (Martin Wahlen) : traduction suédoise
</LI>
<LI><CODE>jzp1218@stud.u-szeged.hu</CODE> (Zoltan Vamosi) : traduction hongroise
</LI>
<LI><CODE>bart@mat.uni.torun.pl</CODE> (Bartosz Maruszewski) : traduction
polonaise
</LI>
<LI><CODE>donahue@tiber.nist.gov</CODE> (Michael J Donahue) : typos, gagnant
de la "compétition du pain en tranches"
</LI>
<LI><CODE>rms@gnu.ai.mit.edu</CODE> (Richard Stallman) : notice de
distribution/concept de documentation libre
</LI>
<LI><CODE>dak@Pool.Informatik.RWTH-Aachen.DE</CODE> (David Kastrup) : NFS
</LI>
<LI><CODE>esr@snark.thyrsus.com</CODE> (Eric Raymond) : quelques trucs et
astuces
</LI>
</UL>
</P>
<P>Tous ceux qui m'ont envoyé des mails avec des questions et des problèmes ont
également été d'une aide précieuse.</P>

<H2><A NAME="ss12.4">12.4 Copyright, traduction, licence et autres</A>
</H2>


<P>Copyright &copy; Brian Ward, 1994-1999.</P>
<P>Version française Copyright &copy; Eric Dumas, 1995-1997
dumas@freenix.fr<BR>
&copy; Christophe Deleuze, 1999</P>
<P>Permission is granted to make and distribute copies of this manual provided
the copyright notice and this permission notice are preserved on all
copies.</P>
<P>Permission is granted to copy and distribute modified versions of this
manual under the conditions for verbatim copying, provided that the derived
work is distributed under the terms of a permission notice identical to
this one. Translations fall under the category of ``modified versions.''</P>
<P><I>(Vous avez le droit de faire et de distribuer des copies de ce document
à condition que l'avis de copyright et cet avis de permission soient
préservés sur toutes les copies. Vous pouvez copier et distribuer des
versions modifiées sous les mêmes conditions pourvu que le travail dérivé
soit distribué sous un avis de permission identique à celui-ci. Les
traductions sont des "versions modifiées").</I></P>
<P>Garantie : aucune.</P>
<P>Cette version française peut être trouvée sur ftp.lip6.fr  dans le répertoire
/pub/linux/french/HOWTO.</P>
<P>La distribution commerciale est autorisée et encouragée ; toutefois il est
fortement recommandé de contacter l'auteur avant la redistribution, dans
l'intérêt de la mise à jour des données (vous pourriez aussi m'envoyer un
exemplaire de ce que vous faites). Idem pour les versions traduites,
contactez le traducteur. Il est conseillé aux traducteurs de contacter
l'auteur avant de commencer la traduction. La version imprimée est bien plus
belle. Recyclez.</P>
</BODY>
</HTML>
