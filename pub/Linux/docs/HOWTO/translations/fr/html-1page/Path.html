<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.21">
 <TITLE>PATH Mini-HowTo</TITLE>
</HEAD>
<BODY>
<H1>PATH Mini-HowTo</H1>

<H2>Esa Turtiainen (<CODE>etu@dna.fi</CODE>)</H2>Version 0.4, 15 Novembre 1997
<HR>
<EM>L'objectif de ce HOWTO est de traiter l'utilisation des variables
d'environnement sous Unix, et en particulier de la variable PATH.
Adaptation fran&ccedil;aise par Mathieu Lafon
(<CODE>Mathieu.Lafon@insalien.org</CODE>),
r&eacute;alis&eacute;e le 22 Octobre 1998.</EM>
<HR>
<H2><A NAME="s1">1. Introduction</A></H2>


<P>Ce document aborde les astuces et les probl&egrave;mes relatifs aux
variables d'environnement
sous Unix/Linux, et plus sp&eacute;cialement &agrave; la variable PATH.
PATH est une liste de r&eacute;pertoires dans lesquels le
syst&egrave;me recherche les commandes &agrave; ex&eacute;cuter.
Ce document s'appuie sur la distribution Debian Linux 1.3.</P>
<P>Remarque: Ce document est en phase de d&eacute;veloppement (b&ecirc;ta).
Vous pouvez m'envoyer vos commentaires ou vos corrections.</P>
<P>Les commentaires sur la traduction sont &agrave; envoyer &agrave;
Mathieu Lafon (<CODE>Mathieu.Lafon@insalien.org</CODE>).</P>

<H2><A NAME="s2">2. Droits d'auteur</A></H2>


<P>Cette documentation est libre, vous pouvez la redistribuer et/ou la
modifier selon les termes de la Licence Publique G&eacute;n&eacute;rale
GNU publi&eacute;e par la Free Software Foundation (version 2 ou bien
toute autre version ult&eacute;rieure choisie par vous).</P>
<P>Cette documentation est distribu&eacute;e car potentiellement utile, mais
SANS AUCUNE GARANTIE, ni explicite ni implicite, y compris
les garanties de commercialisation ou d'adaptation dans
un but sp&eacute;cifique. Reportez-vous &agrave; la Licence Publique
G&eacute;n&eacute;rale GNU pour plus de d&eacute;tails.</P>
<P>Vous pouvez obtenir une copie de la Licence Publique
G&eacute;n&eacute;rale GNU en
&eacute;crivant &agrave; la Free Software Foundation,
Inc., 675 Mass Ave, Cambridge, MA 02139, Etats-Unis.</P>

<H2><A NAME="s3">3. G&eacute;n&eacute;ralit&eacute;s</A></H2>


<P>Tous les processus sous Unix poss&egrave;dent un <EM>environnement</EM>.
C'est une liste de variables contenant un nom et une valeur,
les deux sous la forme de cha&icirc;nes
(pouvant contenir la majorit&eacute; des caract&egrave;res).
Tous les processus Unix poss&egrave;dent un processus parent,
celui qui les a cr&eacute;&eacute;s. Les processus
fils h&eacute;ritent de l'environnement de leurs parents.
Ils peuvent ensuite y faire quelques modifications avant de le passer
&agrave; leurs propres processus fils.</P>
<P>Une variable importante de l'environnement est la variable PATH qui
se pr&eacute;sente sous la forme d'une liste de r&eacute;pertoires
s&eacute;par&eacute;s par le caract&egrave;re deux-points (':').
Ces r&eacute;pertoires sont parcourus pour rechercher les commandes.
Si vous essayez de lancer la commande <CODE>bidule</CODE>, tous les
r&eacute;pertoires contenus dans PATH seront 
examin&eacute;s (dans l'ordre), &agrave; la recherche de
l'ex&eacute;cutable <CODE>bidule</CODE> 
(un fichier avec le bit ex&eacute;cutable positionn&eacute;).
Si un tel fichier est trouv&eacute;, il sera ex&eacute;cut&eacute;.</P>
<P>Dans ce document, j'utilise le terme de <EM>commande</EM> pour un
programme ex&eacute;cutable qui est appel&eacute; sans indication de
son chemin, utilisant donc le m&eacute;canisme de PATH.</P>
<P>Sous Linux, m&ecirc;me les appels de bas niveau pour lancer des processus
(la famille des <CODE>exec</CODE>) se basent sur la variable PATH pour trouver
les ex&eacute;cutables&nbsp;: vous pouvez donc
utiliser le m&eacute;canisme de PATH n'importe o&ugrave;, o&ugrave;
vous voulez ex&eacute;cuter une commande.
Si un appel de <CODE>exec</CODE> re&ccedil;oit le nom d'un fichier qui ne contient
pas de '/', il cherchera dans la variable d'environnement PATH.
M&ecirc;me si cette variable
n'existe pas, les r&eacute;pertoires <CODE>/bin</CODE> et <CODE>/usr/bin</CODE>
seront examin&eacute;s &agrave; la recherche de cette commande.</P>
<P>Pour cr&eacute;er ou modifier l'environnement, on utilisera <CODE>export</CODE>
avec <CODE>sh</CODE> ou <CODE>setenv</CODE> avec <CODE>csh</CODE>. Par exemple&nbsp;:
<PRE>
 sh:
     export PATH=/usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games:.

 csh:
     setenv PATH /usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games:.
</PRE>

Les programmes C peuvent utiliser la fonction <CODE>setenv()</CODE> pour
modifier l'environnement. Perl, quand &agrave; lui, conserve
l'environnement dans le tableau associatif %ENV, 
et vous pouvez donc modifier PATH avec&nbsp;:
<PRE>
    $ENV{PATH}="/bin"
</PRE>

La commande <CODE>env</CODE> est le moyen le plus facile pour conna&icirc;tre
les variables de l'environnement courant. Elle peut &eacute;galement
&ecirc;tre utilis&eacute;e pour les modifier.</P>
<P>Pour trouver plus d'information sur les commandes d'acc&egrave;s &agrave;
l'environnement, vous pouvez regarder les pages de manuel de
<CODE>environ</CODE>, <CODE>execl</CODE>,
<CODE>setenv</CODE>, le fichier info <CODE>env</CODE>, ainsi que la
documentation des shells.</P>
<P>Quand Linux d&eacute;marre, le premier processus a &ecirc;tre lanc&eacute;
est <CODE>init</CODE>. C'est un processus particulier car il n'a pas de parent.
De plus, il s'agit de l'anc&ecirc;tre de tous les autres processus.
Son environnement restera celui des autres processus
tant qu'ils ne le modifieront pas. La plupart le modifieront.</P>
<P>Le programme init lance un groupe de processus sp&eacute;cifi&eacute;s
dans le fichier <CODE>/etc/inittab</CODE>. Ces processus
travaillent dans un environnement directement h&eacute;rit&eacute;
de <CODE>init</CODE>. Ce sont d'habitude
des processus comme <CODE>getty</CODE>, le programme qui &eacute;crit 'login:'
&agrave; l'&eacute;cran. Si vous lancez une connexion PPP ici, vous devez
savoir que vous travaillez avec l'environnement
de init. L'initialisation du syst&egrave;me est souvent effectu&eacute;e
par un script lanc&eacute; &agrave; cet endroit.
Dans le cas de la Debian 1.3, il s'agit de <CODE>/etc/init.d/rc</CODE> qui est
charg&eacute; de lancer &agrave; son tour, les scripts d'initialisation.</P>
<P>Le syst&egrave;me comprend plusieurs d&eacute;mons qui peuvent ou non
utiliser l'environnement par d&eacute;faut. La plupart de ceux-ci sont
lanc&eacute; par les
scripts d'initialisation et poss&egrave;dent donc l'environnement de init.</P>
<P>Quand un utilisateur se connecte, l'environnement est modifi&eacute; par les
param&egrave;tres contenus dans les programmes, les scripts d'initialisation
communs &agrave; tous, et ceux sp&eacute;cifiques &agrave; l'utilisateur.
C'est assez compliqu&eacute; et la
situation n'est pas compl&egrave;tement satisfaisante. En effet,
le comportement est totalement diff&eacute;rent
suivant que l'utilisateur se connecte &agrave; partir
du terminal texte, de <CODE>XDM</CODE> ou du r&eacute;seau.</P>

<H2><A NAME="s4">4. init</A></H2>


<P><CODE>init</CODE> est le processus parent de tous les autres processus
du syst&egrave;me. Ceux-ci h&eacute;ritent de son
environnement et m&ecirc;me de sa variable PATH dans
le rare cas o&ugrave; aucun autre PATH n'est indiqu&eacute;.</P>
<P>Le PATH de init est fix&eacute; dans le code source du programme.
Il s'agit de&nbsp;:
<PRE>
    /usr/local/sbin:/sbin:/bin:/usr/sbin:/usr/bin
</PRE>

Notez qu'il ne contient pas le r&eacute;pertoire <CODE>/usr/local/bin</CODE>.</P>
<P>Tous les programmes qui sont lanc&eacute;s &agrave; partir de
<CODE>/etc/inittab</CODE> travaillent avec l'environnement de <CODE>init</CODE>,
et en particulier les scripts d'initialisation
contenus dans <CODE>/etc/init.d</CODE> (dans le cas de la Debian 1.3).</P>
<P>Tout ce qui est lanc&eacute; par les scripts d'initialisation
poss&egrave;de par d&eacute;faut l'environnement de <CODE>init</CODE>.
Par exemple, <CODE>syslogd</CODE>, <CODE>kerneld</CODE>, <CODE>pppd</CODE> (lorsqu'il
est lanc&eacute; au d&eacute;marrage), <CODE>gpm</CODE>, et ce qui est le
plus important, <CODE>lpd</CODE> et <CODE>inetd</CODE> poss&egrave;dent
l'environnement de <CODE>init</CODE> et ne le modifient pas.</P>
<P>Un certain nombre de programmes sont lanc&eacute;s par les scripts de
d&eacute;marrage mais avec une variable PATH explicitement fix&eacute;e
dans le script. Les exemples de tels programmes sont <CODE>atd</CODE>,
<CODE>sendmail</CODE>, <CODE>apache</CODE> et <CODE>squid</CODE>.</P>
<P>D'autre programmes, par exemple <CODE>cron</CODE>, sont lanc&eacute;s
par les scripts mais modifient totalement la variable PATH.</P>

<H2><A NAME="s5">5. Connexion</A></H2>


<P>Sur un terminal texte, il y a le programme <CODE>getty</CODE> qui attend le
login de l'utilisateur. Il est charg&eacute; d'&eacute;crire 'login:'
et quelques autres messages.
Il travaille avec l'environnement de <CODE>init</CODE>. Lorsque l'utilisateur
commence &agrave; se connecter au moyen de <CODE>getty</CODE>, ce dernier
invoque le programme <CODE>login</CODE>.
Celui-ci installe alors l'environnement utilisateur et lance le shell.</P>
<P>Le programme login fixe le PATH comme d&eacute;fini dans le fichier
<CODE>/usr/include/paths.h</CODE>.</P>
<P>Il s'agit, pour les utilisateurs normaux (_PATH_DEFPATH) de&nbsp;:
<PRE>
    /usr/local/bin:/usr/bin:/bin:.
</PRE>

Et pour root (_PATH_DEFPATH_ROOT) de&nbsp;:
<PRE>
    /sbin:/bin:/usr/sbin:/usr/bin
</PRE>

Le PATH des utilisateurs normaux ne contient aucun r&eacute;pertoires
<CODE>sbin</CODE>. Cependant, il contient le r&eacute;pertoire
courant '.', qui est consid&eacute;r&eacute; comme dangereux pour
l'utilisateur root. M&ecirc;me <CODE>/usr/local/bin</CODE> n'est pas
disponible pour root.</P>
<P>Le PATH obtenu lors du login est souvent modifi&eacute; par
l'initialisation du shell.
Cependant, il est possible d'utiliser d'autres programmes que des shells 
dans <CODE>/etc/passwd</CODE>. Par exemple, j'utilise la ligne suivante
pour lancer PPP quand
je me connecte avec le nom d'utilisateur etu-ppp. Dans ce cas,
<CODE>pppd</CODE> poss&egrave;de exactement le PATH du login.
<PRE>
    etu-ppp:viYabVlxPwzDl:1000:1000:Esa Turtiainen, PPP:/:/usr/sbin/pppd
</PRE>
</P>

<H2><A NAME="s6">6. Shells</A></H2>


<P>Les processus utilisateurs sont souvent des processus fils du shell
indiqu&eacute; pour cet utilisateur dans le fichier <CODE>/etc/passwd</CODE>.
Les fichiers d'initialisation de ces shells modifient souvent la
variable PATH.</P>
<P>Lors de la connexion, le nom du shell est pr&eacute;c&eacute;d&eacute;
d'un '-'. Par exemple, dans le cas
de <CODE>bash</CODE>, on aura <CODE>-bash</CODE>. Cela indique au shell qu'il est
en pr&eacute;sence d'un login shell et qu'il doit dans
ce cas ex&eacute;cuter les fichiers d'initialisation
sp&eacute;cifiques &agrave; la connexion. Dans le cas contraire,
on aura une initialisation plus l&eacute;g&egrave;re.
De plus, le shell d&eacute;termine s'il est interactif ou non, c'est &agrave;
dire si les commandes viennent d'un terminal (tty) ou d'un fichier.
Cela modifie &eacute;galement l'importance de l'initialisation si bien
qu'un shell non interactif et qui n'est pas lanc&eacute; avec une
connexion effectue vraiment tr&egrave;s peu d'initialisation
(<CODE>bash</CODE> n'ex&eacute;cute aucune initialisation dans ce cas l&agrave;).</P>

<H2><A NAME="ss6.1">6.1 bash</A>
</H2>


<P>Pour un login shell normal, <CODE>bash</CODE> parcourt le fichier
<CODE>/etc/profile</CODE>, commun &agrave; tous,
o&ugrave; les variables d'environnement, dont PATH, peuvent &ecirc;tre
fix&eacute;es pour les utilisateurs de <CODE>bash</CODE>. Cependant, ce fichier
n'est pas relu lorsque le syst&egrave;me
se trouve face &agrave; un shell non interactif.
Le cas le plus important est <CODE>rsh</CODE>, o&ugrave; la commande est
ex&eacute;cut&eacute;e sur la machine voisine&nbsp;: le fichier
<CODE>/etc/profile</CODE> n'est pas lanc&eacute; et le PATH provient du
d&eacute;mon de <CODE>rsh</CODE>.</P>
<P><CODE>bash</CODE> accepte les arguments <CODE>-login</CODE> et <CODE>-i</CODE> qui
sont utilis&eacute;s pour obtenir
respectivement un login shell et/ou un shell interactif.</P>
<P>L'utilisateur peut red&eacute;finir les param&egrave;tres contenus dans
<CODE>/etc/profile</CODE> en cr&eacute;ant un fichier
<CODE>~/.bash_profile</CODE>, <CODE>~/.bash_login</CODE> ou
<CODE>~/.profile</CODE>. Il faut
noter que seul le premier fichier sera ex&eacute;cut&eacute; m&ecirc;me
si cela diff&egrave;re des habitudes de <CODE>csh</CODE>. En particulier,
<CODE>~/.bash_login</CODE> ne sera pas forcement
ex&eacute;cut&eacute; pour un login shell, car si
<CODE>~/.bash_profile</CODE> existe, ce dernier sera prioritaire.</P>
<P>Si <CODE>bash</CODE> est lanc&eacute; par <CODE>sh</CODE> (qui est un lien
symbolique sur <CODE>bash</CODE>),
il se comporte comme le Bourne shell original&nbsp;: il ne parcourt que les
fichiers <CODE>/etc/profile</CODE> et <CODE>~/.profile</CODE> et uniquement
dans le cas d'un login shell.</P>

<H2><A NAME="ss6.2">6.2 tcsh</A>
</H2>


<P>Pour un login shell, <CODE>tcsh</CODE> ex&eacute;cute dans l'ordre
les fichiers suivants&nbsp;:</P>
<P>
<UL>
<LI><CODE>/etc/csh.cshrc</CODE></LI>
<LI><CODE>/etc/csh.login</CODE></LI>
<LI><CODE>~/.tcshrc</CODE></LI>
<LI><CODE>~/.cshrc</CODE>    (si <CODE>~/.tcshrc</CODE> n'existe pas)</LI>
<LI><CODE>~/.history</CODE></LI>
<LI><CODE>~/.login</CODE></LI>
<LI><CODE>~/.cshdirs</CODE></LI>
</UL>
</P>
<P><B>Attention.</B> <CODE>tcsh</CODE> peut &ecirc;tre compil&eacute; pour
ex&eacute;cuter les scripts de
connexion (<CODE>login</CODE>) avant les scripts <CODE>cshrc</CODE>.</P>
<P>Les shells non interactifs n'ex&eacute;cutent que les scripts
<CODE>*cshrc</CODE>. Les scripts <CODE>*login</CODE> peuvent &ecirc;tre
utilis&eacute;s pour ne fixer le PATH que lors d'une connexion.</P>

<H2><A NAME="s7">7. Modifier l'identit&eacute; de l'utilisateur</A></H2>



<H2><A NAME="ss7.1">7.1 su</A>
</H2>


<P>La commande <CODE>su</CODE> sert &agrave; indiquer la nouvelle identit&eacute;
&agrave; utiliser (sous r&eacute;serve de conna&icirc;tre le mot de passe),
root &eacute;tant la valeur par d&eacute;faut.</P>
<P>Normalement, <CODE>su</CODE> lance un sous-shell avec la nouvelle
identit&eacute;. Avec l'argument '-' (plus r&eacute;cemment <CODE>-l</CODE> ou
<CODE>--login</CODE>), <CODE>su</CODE> lance le shell comme un login shell. Cependant,
il n'utilise pas le programme <CODE>login</CODE> pour cela mais encore un
autre PATH int&eacute;gr&eacute; au programme pour simuler le login
(termes employ&eacute;s dans le code source). Il s'agit de&nbsp;:</P>
<P>pour les utilisateurs normaux&nbsp;:
<PRE>
    /usr/local/bin:/usr/bin:/bin:/usr/bin/X11:.
</PRE>

pour l'utilisateur root&nbsp;:
<PRE>
    /sbin:/bin:/usr/sbin:/usr/bin:/usr/bin/X11:/usr/local/sbin:/usr/local/bin
</PRE>

<CODE>su</CODE> r&eacute;alise &eacute;galement quelques changements mineurs
dans l'environnement.</P>

<H2><A NAME="ss7.2">7.2 sudo</A>
</H2>


<P>Il y a un groupe de commandes qui permettent une utilisation plus s&ucirc;r
des commandes du super utilisateur. Elles permettent un meilleur suivi (au
sens o&ugrave; l'on garde une trace de chaque ex&eacute;cution - NdT), des
restrictions sur les utilisateurs et utilisent des mots de passe individuels.
La plus utilis&eacute;e est s&ucirc;rement <CODE>sudo</CODE>.
<PRE>
    $ sudo env
</PRE>

Cette commande ex&eacute;cute <CODE>env</CODE> en tant que super utilisateur
(si <CODE>sudo</CODE> est configur&eacute; pour le permettre).</P>
<P>La commande <CODE>sudo</CODE> a encore une autre approche en ce qui concerne
la gestion du PATH. Elle modifie les r&eacute;pertoires o&ugrave; chercher
la commande &agrave; ex&eacute;cuter pour que le r&eacute;pertoire courant
soit toujours le dernier. Cependant, elle ne modifie 
pas la variable PATH, seulement quelques variables comme SUDO_USER.</P>

<H2><A NAME="s8">8. Serveurs</A></H2>


<P>La majorit&eacute; des serveurs ne devrait pas lancer n'importe quelle
sorte de processus. Pour des raisons de s&eacute;curit&eacute;, leur
PATH doit donc &ecirc;tre minimal.</P>
<P>La plus grosse exception est l'ensemble des services qui autorisent
une connexion sur le syst&egrave;me &agrave; partir du r&eacute;seau.
Cette section d&eacute;crit comment se trouve l'environnement
dans ces cas pr&eacute;cis. En effet, une commande ex&eacute;cut&eacute;
&agrave; distance avec <CODE>rsh</CODE> aura
un PATH diff&eacute;rent d'une commande ex&eacute;cut&eacute; avec
<CODE>ssh</CODE>. De la m&ecirc;me fa&ccedil;on,
une connexion &agrave; l'aide de <CODE>rlogin</CODE>, <CODE>telnet</CODE>
ou <CODE>ssh</CODE> est diff&eacute;rente.</P>

<H2><A NAME="ss8.1">8.1 inetd</A>
</H2>


<P>La plupart des serveurs ne poss&egrave;dent pas de processus charg&eacute;
d'attendre en permanence l'arriv&eacute;e d'une requ&ecirc;te. Ce travail
est laiss&eacute; &agrave; un super serveur (Internet super server),
appel&eacute; <CODE>inetd</CODE>. Le programme <CODE>inetd</CODE> est &agrave;
l'&eacute;coute permanente du r&eacute;seau et lance le serveur
appropri&eacute; en fonction du port sur lequel arrive la requ&ecirc;te.
Son comportement est d&eacute;fini dans le fichier
<CODE>/etc/inetd.conf</CODE>.</P>
<P><CODE>inetd</CODE> est d&eacute;marr&eacute; par les scripts de d&eacute;marrage
du syst&egrave;me. Il h&eacute;rite donc du PATH de <CODE>init</CODE>.
Il ne le modifie pas et tous les serveurs lanc&eacute;s par <CODE>inetd</CODE>
poss&egrave;dent donc le PATH de <CODE>init</CODE>. Un exemple de tel serveur est
<CODE>imapd</CODE>, le serveur du protocole IMAP.</P>
<P>D'autre exemples de processus lanc&eacute;s par <CODE>inetd</CODE> sont
<CODE>telnetd</CODE>, <CODE>rlogind</CODE>, <CODE>talkd</CODE>, <CODE>ftp</CODE>,
<CODE>popd</CODE>, certains serveurs http, etc...</P>
<P>Souvent, l'utilisation de <CODE>inetd</CODE> est compliqu&eacute;e par
l'utilisation du programme tcpd, charg&eacute; de lancer le v&eacute;ritable
serveur. C'est un programme qui effectue quelques v&eacute;rifications du
point de vue s&eacute;curit&eacute; avant de lancer le v&eacute;ritable
serveur. Il ne touche pas au PATH (information non v&eacute;rifi&eacute;e).</P>

<H2><A NAME="ss8.2">8.2 rsh</A>
</H2>


<P>Le d&eacute;mon de <CODE>rsh</CODE> utilise le PATH d&eacute;fini par
_PATH_DEFPATH (<CODE>/usr/include/path.h</CODE>),
c'est &agrave; dire, le m&ecirc;me que celui utilis&eacute; par le
programme <CODE>login</CODE> pour connecter les utilisateurs normaux.
L'utilisateur root obtiendra le m&ecirc;me PATH que les autres.</P>
<P>En r&eacute;alit&eacute;, <CODE>rshd</CODE> ex&eacute;cute la commande
d&eacute;sir&eacute;e en se servant de la commande suivante&nbsp;:
<PRE>
    shell -c ligne_de_commande
</PRE>

O&ugrave; <CODE>shell</CODE> n'est pas un login shell. Il est
pr&eacute;f&eacute;rable que tous les shells mentionn&eacute;s dans
<CODE>/etc/passwd</CODE> prennent en compte l'option <CODE>-c</CODE> pour pouvoir
leur envoyer ce genre de ligne de commande.</P>

<H2><A NAME="ss8.3">8.3 rlogin</A>
</H2>


<P><CODE>rlogin</CODE> invoque login pour effectuer la proc&eacute;dure de connexion.
Si vous vous connectez avec <CODE>rlogin</CODE>, vous aurez le m&ecirc;me PATH
qu'avec <CODE>login</CODE>. La plupart des autres fa&ccedil;ons de se connecter
&agrave; un ordinateur sous Linux n'utilisent
pas <CODE>login</CODE>. Notez la diff&eacute;rence avec <CODE>rsh</CODE>.</P>
<P>La commande de <CODE>login</CODE> utilis&eacute;e est de la forme&nbsp;:
<PRE>
    login -p -h nom_de_l_hote nom_d_utilisateur
</PRE>

L'option <CODE>-p</CODE> conserve l'environnement &agrave; l'exception des
variables HOME, PATH, SHELL, TERM, MAIL et LOGNAME. L'option <CODE>-h</CODE>
indique le nom de l'ordinateur sur lequel doit se faire la connexion.</P>

<H2><A NAME="ss8.4">8.4 telnet</A>
</H2>


<P>Le programme <CODE>telnet</CODE> est similaire &agrave; <CODE>rlogin</CODE>&nbsp;:
il utilise le programme <CODE>login</CODE> et la ligne de commande
utilis&eacute;e est de la m&ecirc;me forme.</P>

<H2><A NAME="ss8.5">8.5 ssh</A>
</H2>


<P><CODE>ssh</CODE> poss&egrave;de sa propre variable PATH, &agrave; laquelle il
ajoute le r&eacute;pertoire o&ugrave; se trouve <CODE>ssh</CODE>. Cela implique
souvent que le r&eacute;pertoire <CODE>/usr/bin</CODE> se retrouve en double&nbsp;:
<PRE>
    /usr/local/bin:/usr/bin:/bin:.:/usr/bin
</PRE>

La variable PATH ne contient pas <CODE>/usr/bin/X11</CODE> et le shell
invoqu&eacute; par <CODE>ssh</CODE> n'est pas un login shell. Ainsi, la commande
<PRE>
    ssh hote_distant xterm
</PRE>

ne marchera pas et rien de ce qui est contenu dans <CODE>/etc/profile</CODE> ou
<CODE>/etc/csh.cshrc</CODE> ne pourra changer cela.
Vous devrez toujours utiliser des chemins absolus, par exemple
<CODE>/usr/bin/X11/xterm</CODE>.</P>
<P><CODE>ssh</CODE> cherche des variables d'environnement de la forme
VARIABLE=VALEUR dans le fichier <CODE>/etc/environment</CODE>.
Malheureusement, cela provoque des probl&egrave;mes avec XFree86.</P>

<H2><A NAME="s9">9. XFree86</A></H2>



<H2><A NAME="ss9.1">9.1 XDM</A>
</H2>


<P>XDM est la mani&egrave;re la plus courante pour se connecter &agrave;
partir d'un terminal graphique. M&ecirc;me s'il ressemble &agrave;
<CODE>login</CODE>, il se comporte, en interne, d'une mani&egrave;re
totalement diff&eacute;rente.</P>
<P>Les fichiers de configuration se trouvent dans le r&eacute;pertoire
<CODE>/etc/X11/xdm</CODE> et sont ex&eacute;cut&eacute;s pendant les
diff&eacute;rentes &eacute;tapes de la connexion. Xstartup
(et Xstartup_0 pour l'&eacute;cran 0) contient les commandes &agrave;
ex&eacute;cuter juste apr&egrave;s la connexion. Ces commandes sont
lanc&eacute;s en tant que root.</P>
<P>Le PATH qui est utilis&eacute; pour les utilisateurs se trouve dans
<CODE>/etc/X11/xdm/xdm-config</CODE>.
Ce sont les lignes&nbsp;:
<PRE>
DisplayManager*userPath: /usr/local/bin:/usr/bin:/bin:/usr/bin/X11:/usr/games
DisplayManager*systemPath: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/bin/X11
</PRE>

C'est le PATH par d&eacute;faut pour les utilisateurs normaux
(<CODE>userPath</CODE>), et pour l'utilisateur
root (<CODE>systemPath</CODE>) respectivement. Il est tr&egrave;s important
que le r&eacute;pertoire <CODE>/usr/bin/X11</CODE> soit accessible
pour les utilisateurs sous X. En effet, si un utilisateur se connecte
&agrave; une autre machine pour lancer une application X, il faut qu'il
aie <CODE>/usr/bin/X11</CODE> dans son PATH
car la machine h&ocirc;te ne saura pas qu'il dispose d'un terminal X.</P>
<P>Apr&egrave;s Xstartup, XDM lance <CODE>/etc/X11/Xsession</CODE> en tant
qu'utilisateur final. La configuration locale est contenue dans le fichier
<CODE>/etc/environment</CODE> qui est parcouru, s'il existe, par Xsession.
Xsession &eacute;tant ex&eacute;cut&eacute; par <CODE>/bin/sh</CODE>,
<CODE>/etc/environment</CODE> doit donc &ecirc;tre un script <CODE>sh</CODE>.
Cela interf&egrave;re avec <CODE>ssh</CODE> qui suppose que
<CODE>/etc/environment</CODE> est un fichier qui ne
contient que des lignes de la forme VARIABLE=VALEUR.</P>

<H2><A NAME="ss9.2">9.2 xterm -ls</A>
</H2>


<P>Par d&eacute;faut, le PATH de toutes les commandes lanc&eacute;s &agrave;
partir des menus du gestionnaire de fen&ecirc;tre est celui
h&eacute;rit&eacute; de XDM. Pour en utiliser
un autre, il faut le d&eacute;finir explicitement. Pour lancer un terminal X
avec un PATH "normal", on doit utiliser des options sp&eacute;ciales.
Pour <CODE>xterm</CODE>, l'option <CODE>-ls</CODE> (login shell) doit &ecirc;tre
utilis&eacute; pour obtenir un login shell avec le PATH d&eacute;fini dans
les fichiers d'initialisation du shell en question.</P>

<H2><A NAME="ss9.3">9.3 Menus et boutons du gestionnaire de fen&ecirc;tre</A>
</H2>


<P>Le gestionnaire de fen&ecirc;tre h&eacute;rite de l'environnement de XDM.
Tous les programmes lanc&eacute;s par lui h&eacute;ritent donc de cet
environnement.</P>
<P>L'environnement du shell de l'utilisateur n'affecte pas les programmes
qui sont lanc&eacute;s par les menus ou les boutons. Par exemple, si un
programme est lanc&eacute; par un <CODE>xterm</CODE> (<CODE>xterm -ls</CODE>),
il poss&egrave;de l'environnement par d&eacute;faut du login shell,
par contre s'il est lanc&eacute; par un menu, il aura l'environnement
du gestionnaire de fen&ecirc;tre.</P>

<H2><A NAME="s10">10. Commandes "&agrave; retardement" cron et at</A></H2>



<H2><A NAME="ss10.1">10.1 cron</A>
</H2>


<P>C'est le programme <CODE>cron</CODE> qui ex&eacute;cute p&eacute;riodiquement
les commandes sp&eacute;cifi&eacute;es
dans <CODE>/etc/crontab</CODE> et dans les crontabs des utilisateurs. La
Debian&nbsp;1.3 poss&egrave;de en plus un m&eacute;canisme pour
ex&eacute;cuter les commandes de <CODE>/etc/cron.daily</CODE>,
<CODE>/etc/cron.weekly</CODE> et <CODE>/etc/cron.monthly</CODE>, respectivement
tous les jours, toutes les semaines et tous les mois.</P>
<P><CODE>cron</CODE> est lanc&eacute; par les scripts de d&eacute;marrage mais
il change son PATH en une valeur assez &eacute;trange&nbsp;:
<PRE>
       /usr/bin:/binn:/sbin:/bin:/usr/sbin:/usr/bin
</PRE>

<B>IL S'AGIT SUREMENT D'UN BOGUE DANS CRON.</B> Il s'agit en fait du
PATH de init (<CODE>/usr/bin:/bin</CODE>) qui est copi&eacute; ici, mais sans
le 0 terminal (cha&icirc;ne en convention C - NdT)! Ce bogue n'existe pas
sur tous les syst&egrave;mes.</P>
<P>Dans la crontab, on peut d&eacute;finir un PATH sp&eacute;cifique pour
l'ex&eacute;cution des commandes.
Pour la Debian&nbsp;1.3, il s'agit de&nbsp;:
<PRE>
    PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin
</PRE>

De cette fa&ccedil;on, le PATH de <CODE>crond</CODE> n'est jamais
utilis&eacute; dans les programmes utilisateurs. Tous les scripts de
<CODE>/etc/cron.*</CODE> obtiennent par d&eacute;faut le PATH
de la crontab. Celui ci est utilis&eacute; m&ecirc;me si le programme n'est
pas ex&eacute;cut&eacute; en tant que root.</P>

<H2><A NAME="ss10.2">10.2 at</A>
</H2>


<P>La commande <CODE>at</CODE> est utilis&eacute;e pour lancer un programme
&agrave; une heure fix&eacute;e.</P>
<P>Le programme <CODE>atd</CODE> est lanc&eacute; avec le PATH de <CODE>init</CODE>.
Cependant, les programmes sont toujours lanc&eacute;s avec l'environnement
utilisateur gr&acirc;ce &agrave; <CODE>sh</CODE>.
Les sp&eacute;cificit&eacute;s de <CODE>sh</CODE> s'appliquent donc ici.
Reportez vous au chapitre sur <CODE>bash</CODE>.</P>

<H2><A NAME="s11">11. Quelques exemples</A></H2>



<H2><A NAME="ss11.1">11.1 magicfilter</A>
</H2>


<P><CODE>magicfilter</CODE> est un outil standard permettant de manipuler les
fichiers &agrave; destination de l'imprimante. Il analyse le type du
fichier &agrave; imprimer et lance un filtre appropri&eacute; pour l'imprimer
de la meilleure fa&ccedil;on. Les scripts utilis&eacute;s pour filtrer
sont lanc&eacute;s par <CODE>lpd</CODE>, lui m&ecirc;me lanc&eacute; par le
script <CODE>/etc/init.d/lpd</CODE> lanc&eacute; par <CODE>init</CODE>. Le PATH
est donc identique &agrave; celui de <CODE>init</CODE> et ne contient donc pas
<CODE>/usr/bin/X11</CODE>.</P>
<P>Si vous voulez envoyer des fichier PDF (Portable Data Format) &agrave;
<CODE>magicfilter</CODE>, vous pouvez utiliser <CODE>/usr/bin/X11/xpdf</CODE>.
Mais vous ne devez pas oublier d'indiquer le chemin absolu. Sinon,
<CODE>magicfilter</CODE> ne trouvera pas <CODE>xpdf</CODE>. La plupart
des programmes utilis&eacute;s avec <CODE>magicfilter</CODE>, ne
n&eacute;cessitent pas forcement un chemin explicite car ils se trouvent
souvent dans <CODE>/bin</CODE> ou <CODE>/usr/bin</CODE>.</P>

<H2><A NAME="ss11.2">11.2 Impression &agrave; partir d'applications X</A>
</H2>


<P>Au cas o&ugrave; vous utilisez la variable d'environnement PRINTER pour
s&eacute;lectionner l'imprimante &agrave; utiliser, vous devez savoir que
dans certains cas, certaines applications X risquent de ne pas la
conna&icirc;tre.</P>
<P>Vous vous souvenez s&ucirc;rement que si la session X a &eacute;t&eacute;
lanc&eacute; par XDM, le gestionnaire de fen&ecirc;tre ne se sert pas de
vos scripts de login. Toutes les applications X que vous lancez &agrave;
partir d'un <CODE>xterm</CODE> poss&egrave;dent donc la variable PRINTER.
Par contre, la m&ecirc;me application lanc&eacute;e &agrave; partir
d'un menu ou d'un bouton ne poss&eacute;dera pas cette variable.</P>
<P>Parfois, la variable PRINTER peut &ecirc;tre h&eacute;rit&eacute;e &agrave;
un niveau encore plus bas. Par exemple, une application auxiliaire
de Netscape pourra conna&icirc;tre votre
variable PRINTER m&ecirc;me si Netscape ne la conna&icirc;t pas.</P>

<H2><A NAME="s12">12. Questions de s&eacute;curit&eacute;</A></H2>


<P>Le m&eacute;canisme de PATH est souvent un gros probl&egrave;me du point
de vue s&eacute;curit&eacute;. Utiliser une erreur dans la d&eacute;finition
du PATH est une mani&egrave;re fr&eacute;quente
de pirater un syst&egrave;me. Il est facile pour un pirate de fabriquer
des chevaux de Troie, s'il arrive &agrave; forcer root ou un autre
utilisateur &agrave; ex&eacute;cuter ses propres programmes.</P>
<P>Une erreur fr&eacute;quente par le pass&eacute; (?) &eacute;tait de laisser
le r&eacute;pertoire courant '.' dans le PATH de l'utilisateur root.
Un pirate malveillant peut alors cr&eacute;er
son propre programme <CODE>'ls'</CODE> dans son r&eacute;pertoire.
Ensuite, si root fait&nbsp;:
<PRE>
    # cd ~pirate
    # ls
</PRE>

il ex&eacute;cute le programme du pirate...</P>
<P>De la m&ecirc;me fa&ccedil;on, cela s'applique &agrave; tous les programmes
ex&eacute;cut&eacute;s par root. Aucun important d&eacute;mon ne devrait
ex&eacute;cuter quoi que ce soit qui puisse
&ecirc;tre modifi&eacute; par un utilisateur. Dans certains syst&egrave;mes, 
<CODE>/usr/local/bin</CODE> peut contenir des programmes jug&eacute;s moins
s&ucirc;r, mais le r&eacute;pertoire est retir&eacute; du PATH de root.
Cependant, si on sait qu'un d&eacute;mon ex&eacute;cute <CODE>bidule</CODE>
avec 'PATH=/usr/local/bin:...', il est possible
de tromper le d&eacute;mon en lui faisant ex&eacute;cuter
<CODE>/usr/local/bin/bidule</CODE> &agrave; la place
de <CODE>/bin/bidule</CODE>. Dans ce cas, n'importe qui pouvant &eacute;crire dans
<CODE>/usr/local/bin</CODE> peut s&ucirc;rement pirater le syst&egrave;me.</P>
<P>Il est donc tr&egrave;s important de faire attention &agrave; l'ordre dans
lequel les r&eacute;pertoires sont plac&eacute;s dans le PATH.
Si <CODE>/usr/local/bin</CODE> se trouve avant <CODE>/bin</CODE>,
il y a un risque. Alors que s'il se trouve apr&egrave;s, il est impossible
de lancer la commande modifi&eacute;e <CODE>/usr/local/bin/bidule</CODE>
&agrave; la place de <CODE>/bin/bidule</CODE>.</P>
<P>Sous Linux, vous devez vous souvenir que la recherche dans le PATH est
fa&icirc;te dans tous les m&eacute;canismes d'appels du syst&egrave;me
d'exploitation. N'importe o&ugrave;, o&ugrave; le chemin d'un
ex&eacute;cutable est donn&eacute;, vous pouvez utiliser le nom de
la commande seul qui sera alors cherch&eacute;e au moins dans <CODE>/bin</CODE>
et <CODE>/usr/bin</CODE>, et vraisemblablement dans beaucoup d'autres endroits.</P>

<H2><A NAME="s13">13. Comment r&eacute;soudre les probl&egrave;mes&nbsp;?</A></H2>


<P>La commande la plus simple pour avoir acc&egrave;s &agrave; l'environnement
est <CODE>/usr/bin/env</CODE>.</P>
<P>Il est egalement possible d'utiliser le r&eacute;pertoire <CODE>/proc</CODE>
pour trouver le PATH de n'importe quel programme. Vous devez d'abord
conna&icirc;tre le num&eacute;ro de processus
du programme. Utilisez la commande <CODE>ps</CODE> pour l'obtenir. Par exemple,
si <CODE>xterm</CODE> est le processus num&eacute;ro 1088, vous pouvez voir
son environnement avec&nbsp;:
<PRE>
    # more /proc/1088/environ
</PRE>

Cela ne marche pas avec des processus comme <CODE>xdm</CODE>. Pour
acc&eacute;der &agrave; l'environnement d'un processus du syst&egrave;me
ou d'un autre utilisateur, vous devez &ecirc;tre root.</P>
<P>Pour deboguer Netscape, vous pouvez cr&eacute;er le script suivant&nbsp;:
<PRE>
    $ cat > /tmp/test
    #!/bin/sh
    /usr/bin/env > /tmp/env
    ^d
    $ chmod +x /tmp/test
</PRE>

Ensuite, arrangez vous pour que votre programme soit appel&eacute;
&agrave; la place d'une application auxiliaire, par exemple RealAudio
(<CODE>audio/x-pn-realaudio</CODE>). Lorsque vous essayerez d'acc&eacute;der
&agrave; un lien RealAudio (quelque chose comme
<CODE>http://www.realaudio.com/showcase</CODE>), Netscape lancera
votre programme factice et sauvera l'environnement dans <CODE>/tmp/env</CODE>.</P>

<H2><A NAME="s14">14. M&eacute;thodes pour que tous les utilisateurs aient le m&ecirc;me PATH</A></H2>


<P>Le r&eacute;glage le plus important est &agrave; faire dans les fichiers
commun d'initialisation des logins shells&nbsp;: <CODE>/etc/csh.login</CODE>
pour <CODE>tcsh</CODE> et <CODE>/etc/profile</CODE> pour <CODE>bash</CODE>.</P>
<P>Ceux qui n'obtiennent pas le bon PATH &agrave; partir de ces fichiers
sont&nbsp;: <CODE>rsh</CODE>, <CODE>ssh</CODE>, les &eacute;l&eacute;ments des
menus du gestionnaire de fen&ecirc;tres sous X ne lan&ccedil;ant pas
explicitement de login shell, les commandes lanc&eacute;s &agrave; partir
de <CODE>inittab</CODE>, les travaux de <CODE>cron</CODE>, les travaux des
d&eacute;mons comme <CODE>magicfilter</CODE> (lanc&eacute; par <CODE>lprd</CODE>),
les scripts CGI (WWW), etc...</P>
<P>Si le PATH est fix&eacute; dans <CODE>/etc/csh.cshrc</CODE>, il sera
utilis&eacute; si <CODE>rsh</CODE> ou <CODE>ssh</CODE> lance des commandes sur
une machine distante o&ugrave; l'utilisateur utilise
<CODE>tcsh/csh</CODE>. Par contre, il n'est pas possible de r&eacute;gler
le PATH si l'utilisateur utilise <CODE>bash/sh</CODE>. Voici une m&eacute;thode
pour ne garder le PATH que dans un seul fichier, par exemple
<CODE>/etc/environnement-commun</CODE>, dans lequel on &eacute;crit&nbsp;:
<PRE>
  ${EXPORT}PATH${EQ}/bin:/usr/bin:/sbin:/usr/sbin:/usr/bin/X11:/usr/local/bin:/usr/games:.
</PRE>

On peut ensuite l'utiliser &agrave; partir de <CODE>/etc/csh.login</CODE>
(pour <CODE>tcsh</CODE>
et <CODE>csh</CODE>)
<PRE>
  set EQ=" " set EXPORT="setenv "; source /etc/environnement-commun
</PRE>

A partir de <CODE>/etc/profile</CODE> (pour <CODE>bash</CODE>, mais pas pour le
vrai <CODE>sh</CODE>)
<PRE>
  EQ='=' EXPORT="export " . /etc/environnement-commun
</PRE>

Et &agrave; partir de <CODE>/etc/environment</CODE> (pour XDM)
<PRE>
  EQ='=' EXPORT="export " . /etc/environnement-commun
</PRE>
</P>
<P>Cette m&eacute;thode marchera la plupart du temps, sauf que <CODE>ssh</CODE>
se plaindra des lignes contenues dans <CODE>/etc/environment</CODE> (ainsi
que des variables EQ et EXPORT). De plus, <CODE>rsh</CODE> n'aura toujours
pas le bon PATH s'il passe par <CODE>bash</CODE>.</P>

<H2><A NAME="s15">15. Remerciements</A></H2>


<P>Une des raisons pour commencer l'&eacute;criture de ce document a
&eacute;t&eacute; la grosse frustration de Ari Mujunen. Juha Takala
m'a donn&eacute; de pr&eacute;cieux commentaires.</P>

</BODY>
</HTML>
