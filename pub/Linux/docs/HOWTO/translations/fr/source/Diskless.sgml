<!doctype linuxdoc system>

<article>

<title>Mini Howto Linux pour systèmes sans lecteur de disque(ttes)
<author>par Robert Nemkin <tt>buci@math.klte.hu</tt>&nl;
Traducteur: <url name="Sébastien Blondeel"
url="http://www.lifl.fr/~blondeel">
(<htmlurl url="mailto:sebastien.blondeel@lifl.fr"
name="sebastien.blondeel@lifl.fr">)&nl;
<date>v0.0.3 12 Sep 1996


<abstract>
Ce document décrit la manière de configurer un système sous 
Linux sans disque
dur ni lecteur de disquettes. Ses droits appartiennent à Robert Nemkin,
et il est placé sous les termes de la Publique Générale GNU. L'auteur
remercie Bela Kis &lt;bkis@cartan.math.klte.hu&gt; pour avoir traduit ce
document en anglais. Sébastien Blondeel,
&lt;Sebastien.Blondeel@lifl.fr&gt; a traduit ce document en français.
</abstract>

<toc>

<sect>Modifications<p>
<itemize>
<item>v0.0.3 12 Sep 1996: Quelques erreurs mineures ont été corrigées
</itemize>

<sect>Comment configurer un système sous Linux sans lecteur de disque(ttes)<p>
Ce document décrit la manière de configurer un système sous Linux sans
disque dur ni lecteur de disquette. Il peut parfois s'avérer nécessaire
de faire tourner Linux sur des ordinateurs personnels ("PC") qui ne
possèdent ni disque dur ni lecteur de disquettes.
Si on dispose d'un réseau, d'un autre système sous Unix avec bootp et
tftp, d'un serveur NFS et d'un brûleur d'EPROM, alors il est
possible de configurer et de faire tourner un système sous Linux sans
disque dur ni disquette.

<sect>Consulter également les documents suivants:<p>
<itemize>
<item>NFS-root Mini Howto
<item>Linux NET-2/3-HOWTO par
  Terry Dawson, <tt>94004531@postoffice.csu.edu.au</tt>
<item><tt>/usr/src/linux/README</tt> pour la configuration et la
compilation de nouveaux noyaux
</itemize>

<sect>Matériel<p>
Tout ce qui est décrit ici a été testé avec la configuration suivante:
<itemize>
<item>Sun-OS 4.1.3 comme serveur d'amorçage
<item>Slackware 2.3 + Linux 1.2.8 + la carte ethernet wd 8013
<item>Un réseau ethernet en état de fonctionnement
</itemize>

<sect>Idées fondamentales<p>
L'idée de base est la suivante: le PC va obtenir son adresse IP du
serveur d'amorçage par le protocole bootp, en utilisant 0.0.0.0 comme
adresse IP initiale et en obtenant son noyau par le protocole tftp.
<footnote>Un amorçage à travers des segments (via un routeur) n'est pas
un problème simple, aussi faut-il mettre à la fois le serveur et la
machine sans disque sur le même segment de réseau, 
ou configurer une adresse UDP
d'aide dans votre routeur pointant vers l'adresse du serveur.
Référez-vous au manuel de votre routeur pour de plus amples informations
sur le sujet.
</footnote>

Pour cela, suivez les étapes ci-dessous.

<sect1>Configurer le PC<p>
Obtenez le paquetage nfsboot (ce paquetage est disponible sur votre site
miroir de Linux préféré dans le répertoire 
<tt>/pub/Linux/system/Linux-boot</tt>). Il contient une image d'amorçage
pour l'EPROM de la carte wd8013 qui peut être brûlée telle quelle. <p>
Il y a d'autres manières de préparer le PC:
<itemize>
<item> si votre machine contient un petit disque ou un lecteur de
disquette, vous pouvez utiliser le petit programme sous DOS, ou
<item>l'image binaire pour disquette qui se trouve dans le même
paquetage.
</itemize> 
Si vous choisissez la deuxième option, il faut utiliser la commande dd
pour écrire l'image sur la disquette.<p>
Ces images contiennent un client bootp et un client tftp.
Vous devez également préparer un noyau pour linux, comportant l'option
NFS-root (amorçage par NFS).
<itemize>
<item>Si vous utilisez le dernier noyau stable, linux-1.2.13, alors il
faut corriger le noyau avec le fichier de correction contenu dans le
paquetage nfsboot
<footnote>Consulter patch(1)</footnote>
<item>Si vous utilisez le dernier noyau en date, instable, de la série
linux-1.3.x, il vous faut configurer l'option NFS-root.
</itemize>
Vous pouvez ou non choisir de configurer le support pour périphérique
en mode bloc (disque dur ou disquette), mais vous devez configurer le
support pour tcp/ip, pour la carte ethernet wd, et pour le système de
fichiers NFS. Puis recompilez le noyau de manière habituelle.

<sect1>Configurer un bootpd sur le serveur<p>
On peut le trouver dans le paquetage 
<tt>bootpd-2.4.tar.gz</tt>
(qui se trouve sur votre site miroir de Linux préféré dans le répertoire 
<tt>/pub/Linux/system/Network/boot.net</tt>). Chargez le paquetage,
compilez-le et installez-le. Si votre autre système sous Linux se trouve
être une distribution Slackware, vous pouvez passer à l'étape suivante
puisque les distributions standard comportent un bootpd. On peut
démarrer le démon, soit en tapant la commande 
<tscreen><code>
	bootpd -s

</code></tscreen>
soit en utilisant inetd. Dans ce dernier cas, il vous faut éditer: 
<itemize>
<item> /etc/inetd.conf pour ôter le signe dièse de mise en commentaire au 
début des lignes suivantes:

<tscreen><code>
# tftp   dgram   udp     wait    root    /usr/sbin/in.tftpd 	tftpd /export
# bootps dgram   udp     wait    root    /usr/sbin/in.bootpd	bootpd

</code></tscreen>

<item> insérer ou ôtez le signe de commentaire pour les deux lignes 
suivantes dans /etc/services:

<tscreen><code>
bootps          67/tcp          # serveur BOOTP
tftp            69/udp		# serveur TFTP

</code></tscreen>

<item>redémarrez inetd en tapant

<tscreen><code>
	kill -HUP <numéro d'identification du processus de inetd>.

</code></tscreen>
</itemize>

<sect1>Configurer le bootpd sur le serveur.<p>
Tout d'abord, bootpd possède un fichier de configuration qui s'appelle
bootptab et qui se trouve habituellement dans /etc. Vous devez le
modifier en indiquant les adresses IP de votre passerelle, de votre
serveur dns, et les adresses ethernet de votre ou vos machines sans
disques.
Voici un fichier /etc/bootptab d'exemple:
<tscreen><code>

global.prof:\
:sm=255.255.255.0:\
:ds=192.168.1.5:\
:gw=192.168.1.19:\
:ht=ethernet:\
:bf=linux:
machine1:hd=/export/root/machine1:tc=global.prof:ha=0000c0863d7a:ip=192.168.1.140:
machine2:hd=/export/root/machine2:tc=global.prof:ha=0800110244e1:ip=192.168.1.141:
machine3:hd=/export/root/machine3:tc=global.prof:ha=0800110244de:ip=192.168.1.142:
</code></tscreen>

global.prof est un patron général pour les entrées d'hôtes, où
<itemize>
<item>le champ sm contient le masque pour le sous-réseau
<item>le champ ds contient l'adresse du serveur de nom de domaine (DNS)
<item>le champ gw contient l'adresse de la passerelle par défaut
<item>le champ ht contient le type de carte réseau
<item>le champ bf contient le nom du fichier d'amorçage
</itemize>

Après cela, chaque machine doit posséder sa propre entrée sur une ligne:
<itemize>
<item>le premier champ contient le nom de l'hôte
<item>le champ hd contient le répertoire du fichier d'amorçage
<item>on peut inclure le patron global avec le champ tc
<item>le champ ha contient l'adresse matérielle de la carte ethernet 
<item>le champ ip contient l'adresse IP qui a été attribuée
</itemize>


<sect1>Comprendre tftp<p>
TFTP (<tt>Trivial File Transfer Protocol</tt>, ou protocole de transfert
de fichiers banal) est un protocole de transfert de fichiers, comme ftp,
mais il est beaucoup plus facile à programmer dans des mémoires de type
EPROM. On peut utiliser TFTP de deux manières:
<itemize>
<item> tftp simple: cela signifie que le client peut accéder à la
totalité de votre système de fichiers. C'est plus simple, mais cela
constitue un gros trou de sécurité (n'importe qui peut obtenir votre
fichier de mots de passe par tftp).
<item> tftp sécurisé: le serveur tftp utilise un appel système chroot.2
pour modifier son propre répertoire racine. Tout ce qui n'est pas dans
cette racine sera absolument inaccessible.
Comme le répertoire chroot devient le nouveau répertoire racine, le
champ hd listé dans le fichier bootptab doit prendre cette situation en
compte. Par exemple: lorsqu'on utilise tftp non sécurisé, le champ hd
contient le chemin complet menant au répertoire d'amorçage: 
<tt>/export/root/machine1</tt>.
Lorsqu'on utilise tftp sécurisé avec /export comme répertoire racine,
alors /export devient /  et le champ hd doit être <tt>/root/machine1</tt>.
</itemize>
Comme pratiquement toute installation Unix comporte un serveur tftp,
vous n'aurez probablement pas besoin d'installer la votre.

<sect1>Configurer un Linux minimal sur le serveur distant.<p>
Il vous faut pour cela, par exemple, les paquetages a, ap, n et x
de la distribution Slackware. Il est possible d'installer plus de
choses; ce pendant les paquetages ci-dessus suffiront à l'installation
d'un terminal X sans disque. Pour l'installation, il vous faut un
système sous Linux en état de marche. Trouvez un peu d'espace disque sur
la machine distante et exportez-le en lecture et en écriture. Montez le
répertoire exporté quelque part (par exemple sur /mnt) sur le système de
fichiers du système sous Linux. Démarrez Linux et modifiez l'option de
racine dans la configuration; remplacez / par /mnt. Puis configurez les
paquetages ci-dessus de manière habituelle. Si vous ne souhaitez faire
tourner qu'un seul Linux sans disque, il ne vous faut rien modifier
d'autre. D'un autre côté, si vous pensez utiliser plus d'une machine
sans disque, la configuration décrite ci-dessus ne fonctionnera pas
parce que certains fichiers et répertoires doivent être privés pour
chaque machine. 
On peut contourner ce problème on déplaçant le répertoire /usr (il ne
contient aucune donnée personnelle) et ensuite de créer un
sous-répertoire pour chaque machine sans disque. Par exemple, si
/export/linux/machine1 est monté sur /mnt alors la structure des
répertoires après la configuration initiale ressemblera à:
<tscreen><code>
/export/linux/machine1/bin
/export/linux/machine1/sbin
/export/linux/machine1/lib
/export/linux/machine1/etc
/export/linux/machine1/var
/export/linux/machine1/usr

</code></tscreen>
<p>Après les modifications vous obtiendrez
<tscreen><code>
/export/linux/machine1/bin
/export/linux/machine1/sbin
/export/linux/machine1/lib
/export/linux/machine1/etc
/export/linux/machine1/var
/export/linux/usr

</code></tscreen>

Maintenant créez les sous-répertoires pour les autres machines.
Supposons pour l'instant que vos machines sans disque s'appellent 
machine1, machine2, machine3, etc.;
vous pouvez alors utiliser le script bash qui suit pour configurer les
autres répertoires:
<tscreen><code>	
	cd /export/linux
	for x in machine2 machine3; do
		mkdir $x; cd $x
		(cd ../machine1; tar cf - *) | tar xvf -
	done

</code></tscreen>	

Puis exportez les répertoires qui suivent:
<itemize>
<item>/export/linux/usr 			en lecture seule pour 
tout le monde.
<item>/export/linux/machine1		uniquement sur machine1, en
lecture/écriture et avec les droits de root.
<item>/export/linux/machine2		idem, sur machine2.
<item>/export/linux/machine3		idem, sur machine3.
</itemize>
comme suit<footnote>le format de cet exemple est conforme à la syntaxe
des exportations de fichiers pour SunOS 4.1.3</footnote>:
<tscreen><code>	
# Ce fichier est /etc/export
# pour des terminaux sous le système Linux distants
# Écrit par Buci
# N'écrivez cette ligne qu'une fois
/export/root/usr             -access=linuxnet
# N'écrivez ces lignes qu'une fois pour chaque hôte
/export/root/machine1       rw=machine1,root=machine1
/export/root/machine2       rw=machine2,root=machine2
/export/root/machine3       rw=machine3,root=machine3

</code></tscreen>	
N'oubliez pas de lancer exportfs -a.

<sect1>Configurer le serveur tftp<p>

C'est maintenant le moment de configurer le serveur tftp. Si vous n'avez
pas besoin de tftp sécurisé alors tout est très simple puisque vos
clients peuvent être amorcés depuis le répertoire /export.

Si vous utilisez un tftp sécurisé vous pouvez soit mettre en place une
structure de répertoire /export/linux complète sous 
/tftpboot (en n'utilisant qu'un seul véritable noyau et des liens
symboliques pour les autres machines),
ou laisser le répertoire /export
jouer le rôle du répertoire d'amorçage pour le tftpd sécurisé. 
Ou encore, si vous disposez d'un répertoire tftpboot séparé, de façon
similaire, vous n'aurez besoin que d'un seul noyau dans la 
structure de répertoires d'origine, et de liens pour les autres. Vous
pouvez obtenir ce résultat en tapant ce qui suit:
<tscreen><code>
      mkdir -p /tftpboot/export/linux/machine1
      cd /tftpboot/export/linux/machine1
      cp /export/linux/machine1/<nom du noyau>.

</code></tscreen>

Puis tapez ce qui suit:

<tscreen><code>
      mkdir -p /tftpboot/export/linux/machine2
      cd ../machine2 
      ln -s ../machine2/<nom du noyau>

</code></tscreen>

<sect1>Derniers réglages<p>

Enfin, il vous faut insérer
<tscreen><code>
   /sbin/mount nfs_server:/export/linux/usr /usr

</code></tscreen>

à la première ligne de 

<tscreen><code>
   /export/linux/<machinex>/etc/rc.d/rc.S

</code></tscreen>
où &lt;machinex&gt; signifie machine1, machine2, etc.
 
<sect>Mémoire et espace disque requis; vitesse<p>. 
Je n'ai testé ceci que pour la distribution Slackware 2.3; pour d'autres
distributions ou versions les nombres qui suivent peuvent varier:
<itemize> Espace disque: 28Mo + 6.5Mo/machine
<item> RAM: J'utilise X avec 8Mo. Comme il ne faut que 8Mo 
de système
de pagination sur mémoire de masse, on peut les mettre en place, je
pense -- de façon séparée pour chacune des machines -- dans /tmp.
N'oubliez pas de lancer mkswap.
<item> Vitesse: Je n'ai pas eu de problèmes sur un 486 DX2/66 avec 8
Mégaoctets.
</itemize>

<sect>Erreurs possibles<p> 
<itemize>
<item>J'ai découvert une erreur étrange: dans le sous-répertoire /dev,
SunOS a corrompu les entrées de périphériques de telle sorte que j'ai dû
relancer MAKEDEV en montant le sous-répertoire sur un système sous Linux
avec disque.
(La raison de cela provient des différences entre le NFS de linux et le
NFS de SunOS: tous deux utilisent 32bits pour les numéros de
périphériques Mineur et Majeur, mais linux utilise des champs de
16bits
pour ces deux numéros, alors que SunOS utilise un champ de 14bits pour
le numéro de périphérique Majeur, et un champ de 18bits pour le numéro
de périphérique Mineur.)
<item> Quand on amorce un système sous Linux sans disque, la table de
routage au serveur tftp ne contient qu'un seul routage, et vous devez
configurer des tables de routage correctes. Vous avez pour cela deux
possibilités: 
<itemize>
<item> configurer le rc.S de chacune des machines à la main
<item> utiliser un paquetage de client bootp et rédiger un script de
configuration généralisé
</itemize>
</itemize>

<sect>Erreurs et développements possibles de ce document<p>
<itemize>
<item>Citer correctement les documents liés à tout ceci.
<item>SunOS est fondé sur BSD. Il faut inclure une configuration de
serveur fondée sur SVR4 (c'est-à-dire sur Solaris). 
<item>Même si Linux ressemble beaucoup à SunOS en tant que serveur
bootp/tftp, il peut être utile de fournir un exemple de serveur fondé
sur Linux.
<item> Mettre à jour ce document pour le paquetage etherboot en cours.
<item> Montrer les différences entre le noyau version 1.2.13 corrigé
pour la racine NFS et le dernier noyau 1.3.x, qui contient la correction
de racine par NFS.
<item> Besoin d'essayer d'autres cartes ethernet que la wd8013
<item> Inclure des renseignements de configuration pour bootpc, un
client bootp pour Linux qui sert à configurer des tables de routage
correctes.
<item>Fautes de frappe et autres: notifiez-les, s'il vous plaît, à 
<tt>buci@math.klte.hu</tt> ou à <tt>Sebastien.Blondeel@lifl.fr</tt> pour
la traduction française.
Merci.
</itemize>

</article>
