<?xml version="1.0" encoding="iso-8859-1"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
  "http://www.docbook.org/xml/4.3/docbookx.dtd" [
<!ENTITY howto      "http://www.traduc.org/docs/howto/lecture/">
<!ENTITY guide      "http://www.traduc.org/docs/guides/lecture/">
]>

<article lang="fr">

<articleinfo>

<title>Guide pratique de mise en &oelig;uvre d'un serveur WebDAV sous Apache avec LDAP et
SSL</title>

<subtitle>Version française du <foreignphrase>Apache based WebDAV Server
with LDAP and SSL</foreignphrase></subtitle>

<author>
 <firstname>Saqib</firstname>
 <surname>Ali</surname>
 <affiliation>
   <orgname>
     <ulink url="http://www.xml-dev.com">Développement XML/XHTML 
     distant</ulink>
   </orgname>
   <address><email>saqib CHEZ seagate POINT com</email></address>
 </affiliation>
</author>

<othercredit role="traduction" class="translator">
  <firstname>Denis</firstname>
  <surname>Berhaut</surname>
  <contrib>Adaptation française</contrib>
  <email>denis POINT berhaut CHEZ free POINT fr</email>
</othercredit>

<othercredit role="relecture" class="translator">
    <firstname>Vincent</firstname>
    <surname>Loupien</surname>
    <contrib>Relecture de la version française</contrib>
    <email>vincent POINT loupien CHEZ free POINT fr</email>
  </othercredit>

    <othercredit role="publication" class="copyeditor">
      <firstname>Jean-Philippe</firstname>
      <surname>Guérard</surname>
      <contrib>Préparation de la publication de la v.f.</contrib>
      <email>fevrier CHEZ tigreraye POINT org</email>
    </othercredit>

<releaseinfo>Version&nbsp;: 4.1.2.fr.1.1</releaseinfo>
<pubdate>30 janvier 2006</pubdate>

<revhistory>

<revision>
 <revnumber>4.1.2.fr.1.1</revnumber>
 <date>2006-01-30</date>
 <authorinitials>JPG</authorinitials>
 <revremark>
     Correction de mise en forme sur une suggestion de Bernard Siaud.
 </revremark>
</revision>

<revision>
 <revnumber>4.1.2.fr.1.0</revnumber>
 <date>2004-12-20</date>
 <authorinitials>DB, VL, JPG</authorinitials>
 <revremark>Première traduction française</revremark>
</revision>

<revision>
 <revnumber>4.1.2</revnumber>
 <date>2003-10-17</date>
 <authorinitials>SA</authorinitials>
 <revremark>Ajout de la section d'optimisation SSL</revremark>
</revision>

<revision>
 <revnumber>4.1.1</revnumber>
 <date>2003-09-29</date>
 <authorinitials>SA</authorinitials>
 <revremark>Mise à jour de la section SSL suite à des commentaires de lecteurs
 </revremark>
</revision>

<revision>
 <revnumber>4.1.0</revnumber>
 <date>2003-09-02</date>
 <authorinitials>SA</authorinitials>
 <revremark>Mise à jour de la section SSL suite à des commentaires de lecteurs
 </revremark>
</revision>

<revision>
 <revnumber>4.0.2</revnumber>
 <date>2003-08-01</date>
 <authorinitials>SA</authorinitials>
 <revremark>
     Mises à jour mineures de la ligne de commande de configuration 
     d'Apache /dev/random référencée dans la section SSL.
 </revremark>
</revision>

<revision>
 <revnumber>4.0.1</revnumber>
 <date>2003-07-27</date>
 <authorinitials>SA</authorinitials>
 <revremark>
    Ajout d'informations dans la section SSL
 </revremark>
</revision>

<revision>
 <revnumber>4.0</revnumber>
 <date>2003-06-29</date>
 <authorinitials>SA</authorinitials>
 <revremark>
 
     Mise à jour du guide pratique pour Apache 2.0. De plus, conversion du
     source en XML.

 </revremark>
</revision>

</revhistory>

<abstract> <para>

Ce document constitue le guide pratique de mise en &oelig;uvre d'un serveur
WebDAV Apache utilisant LDAP pour l'authentification et SSL pour le
chiffrement.

</para></abstract>

</articleinfo>

<sect1 id="intro">

<title>Introduction</title>

<para>

L'objectif de ce document est de configurer un serveur d'applications
Apache avec mySQL, PHP et WebDAV, qui utilise LDAP pour
l'authentification. La documentation fournira aussi des détails sur le
chiffrement des transactions LDAP.

</para>

<note><title>N.B.&nbsp;:</title>
  <para>

      Si vous rencontrez des problèmes en installant Apache ou un
      quelconque de ses modules n'hésitez pas à contacter l'auteur en
      anglais à
      
      <email>saqib CHEZ seagate POINT com</email>

  </para>
  
  <para>
  
      N'hésitez pas à faire parvenir tout commentaire relatif à la
      version française de ce document à
      
      <email>commentaires CHEZ traduc POINT org</email>
      
      en précisant le titre et la version du document.
      
  </para>
</note>

<sect2>

<title>À propos de ce document</title>

<para>

J'ai commencé à écrire ce document en 2001. Un grand nombre de mises à
jour et de rajouts ont été faits depuis. Je remercie tous ceux qui m'ont
soumis des mises à jour et des corrections.</para>

<para>

Le code source XML DocBook de la plus récente version française de ce
document à l'adresse&nbsp;: <ulink
url="ftp://ftp.traduc.org/pub/traduc.org/doc-vf/HOWTO/telechargement/sgml/Apache-WebDAV-LDAP-HOWTO.xml"/>.

</para>

<para>

Vous trouverez la plus récente version française de ce document à
l'adresse&nbsp;: <ulink url="&howto;Apache-WebDAV-LDAP-HOWTO.html"/>.

</para>

<para>

La code source au format XML de la version originale ce document est
disponible à <ulink
url="http://www.xml-dev.com/xml/Apache-WebDAV-LDAP-HOWTO.xml"/>.

</para>

<para>

La dernière version originale de ce document est disponible à <ulink
url="http://www.xml-dev.com:8080/tldp/http://cvsview.tldp.org/index.cgi/*checkout*/LDP/howto/docbook/Apache-WebDAV-LDAP-HOWTO.xml"/>.

</para>

</sect2>

<sect2>

<title>Contributions au document</title>

<para>

Si vous désirez contribuer à la version originale de ce guide pratique,
vous pouvez télécharger le code source XML de <ulink
url="http://www.xml-dev.com/xml/Apache-WebDAV-LDAP-HOWTO.xml" />, et
envoyer le fichier source modifié à

<email>saqib CHEZ seagate POINT com</email>

AVEC VOTRE NOM DANS LA LISTE D'AUTEURS ET DANS L'HISTORIQUE DES VERSIONS
:) Cela sera plus facile pour moi de contacter la personne en cas de
mises à jour ou de corrections. Je vous remercie.

</para>

</sect2>

<sect2>

<title>Qu'est-ce qu'Apache&nbsp;?</title>

<para>

Le serveur HTTP Apache est un serveur HTTP open-source pour systèmes
d'exploitation modernes comme UNIX et Windows NT. Il fournit des
services HTTP conformes aux standards HTTP actuels.

</para>

<para>

Le serveur Web Apache peut être téléchargé librement de <ulink
url="http://httpd.apache.org/" />

</para>

</sect2>

<sect2>

<title>Qu'est-ce que WebDAV&nbsp;?</title>

<para>

WebDAV signifie Web enabled Distributed Authoring and Versioning, c'est-à-dire gestion de publication et de configuration sur Internet. Il fournit un environnement partagé aux utilisateurs pour éditer/gérer leurs fichiers sur les serveurs Web. Techniquement, DAV est une extension du protocole http.

</para>

<para>

Voici une brève description des extensions fournies par DAV&nbsp;:

</para>

<para>

<emphasis role="bold">Protection contre l'écrasement&nbsp;:</emphasis>

mécanisme de verrouillage et de déverrouillage pour éviter les problèmes
de synchronisation de mises à jour. Le protocole DAV supporte les accès
exclusifs et partagés.

</para>

<para>

<emphasis role="bold">Propriétés&nbsp;:</emphasis>

méta-données (titre, sujet, créateur, et cætera)

</para>

<para>

<emphasis role="bold">Gestion des attributs de
fichiers&nbsp;:</emphasis>

copier, renommer, déplacer et supprimer des fichiers

</para>

<para>

<emphasis role="bold">Contrôle d'accès&nbsp;:</emphasis>

limitation d'accès à des ressources diverses. Généralement, DAV
considère qu'un contrôle d'accès est déjà en place, et ne fournit pas de
mécanisme d'authentification robuste.

</para>

<para>

<emphasis role="bold">Gestion des versions&nbsp;:</emphasis>

contrôle de versions des documents. Le contrôle des versions n'est pas
encore mis en &oelig;uvre.

</para>

</sect2>

<sect2>

<title>Qu'est-ce que PHP&nbsp;?</title>

<para>

PHP (acronyme récursif pour <foreignphrase>Processeur Hypertexte
PHP</foreignphrase>)&nbsp;: c'est un langage de scripts open source à
usage général qui est particulièrement adapté au développement Web et
qui peut être associé à du HTML.

</para>

<para>

On peut se procurer PHP de <ulink url="http://www.php.net" />

</para>

</sect2>

<sect2>

<title>Qu'est-ce que mySQL&nbsp;?</title>

<para>

MySQL, la base de données SQL open source la plus populaire, est
développée, distribuée, et maintenue par MySQL AB

</para>

<para>

On peut télécharger le moteur de base de données de MySQL de <ulink url="http://www-fr.mysql.com/">
http://www.mysql-fr.com/</ulink>

</para>

</sect2>

<sect2>

<title>Que nous faut-il&nbsp;?</title>

<para>

Les outils nécessaires sont&nbsp;:

</para>

<orderedlist numeration="lowerroman">

<listitem><para>

un compilateur C, c-à-d GCC

</para></listitem>

<listitem><para>

un serveur Web Apache 2

</para></listitem>

<listitem><para>

le module LDAP pour Apache

</para></listitem>

<listitem><para>

les fichiers de la bibliothèque iPlanet LDAP lib

</para></listitem>

<listitem><para>

le moteur SSL

</para></listitem>

<listitem><para>

PHP

</para></listitem>

<listitem><para>

Le moteur de base de données mySQL

</para></listitem>

</orderedlist>

<note><title>N.B.&nbsp;:</title>
<para>

tous ces paquets sont libres, téléchargeables sur Internet.

</para></note>

</sect2>

<sect2>

<title>Considérations</title>

<para>

Nous considérons que vous avez déjà installé les éléments suivants dans
votre système.

</para>

<orderedlist numeration="lowerroman">

<listitem><para>

gzip or gunzip &mdash; disponibles à <ulink
url="http://www.gnu.org/home.fr.html" />

</para></listitem>
<listitem><para>

gcc et GNU make &mdash; disponibles à <ulink
url="http://www.gnu.org/home.fr.html" />

</para></listitem>

</orderedlist>

</sect2>

</sect1>

<sect1>

<title>Pré-requis</title>

<para>

Il est nécessaire de télécharger et de compiler différent paquets. Ce
document expliquera le processus de compilation, mais vous êtes sensés
savoir installer à partir du code source.

</para>

<sect2>

<title>

Éléments essentiels</title>

<para>

Il vous faudra une machine sous Solaris ou Linux et un compilateur GCC.
Vous aurez aussi besoin de GNU gzip et de GNU tar.

</para>

</sect2>

<sect2>

<title>Apache 2.0.46</title>

<para>

Apache est le serveur HTTP, et on l'utilisera pour faire tourner le serveur Web applicatif. Téléchargez les sources d'Apache 2.0.46 depuis <ulink url="http://www.apache.org/dist/httpd/">
http://www.apache.org/dist/httpd/</ulink>.

</para>

</sect2>

<sect2>

<title>OpenSSL</title>

<para>

Il vous faudra télécharger OpenSSL de <ulink
url="http://www.openssl.org/source/" />. Téléchargez la dernière
version. L'installation d'OpenSSL sera utilisée pour compiler mod_ssl
avec Apache à l'aide des bibliothèques SSL, et pour gérer les
certificats SSL sur le serveur Web. Téléchargez les sources d'OpenSSL
compressées par gzip dans <filename
class="directory">/tmp/downloads</filename>

</para>

</sect2>

<sect2>

<title>La bibliothèque iPlanet LDAP</title>

<para>

Téléchargez le SDK de iPlanet LDAP de <ulink
url="http://wwws.sun.com/software/download/products/3ec28dbd.html" />.
Nous utiliserons le SDK d'iPlanet LDAP, parce qu'il comprend les
bibliothèques pour ldaps:// (LDAP over SSL)&nbsp;:

</para>

</sect2>

<sect2>

<title>mod_auth_ldap</title>

<para>

Nous utiliserons mod_auth_ldap pour compiler le support LDAP avec
Apache. Téléchargez mod_auth_ldap de <ulink
url="http://www.muquit.com/muquit/software/mod_auth_ldap/mod_auth_ldap_apache2.html"
/>

</para>

</sect2>

<sect2>

<title>Le moteur de base de données mySQL</title>

<para>

Téléchargez les exécutables mySQL pour votre plate-forme de <ulink
url="http://www-fr.mysql.com/downloads/index.html" />

</para>

</sect2>

<sect2>

<title>PHP</title>

<para>

Téléchargez les sources de PHP de <ulink
url="http://www.php.net/downloads.php" />

</para>

</sect2>

</sect1>

<sect1>

<title>Installation</title>

<para>

Nous nous occuperons d'abord des quelques pré-requis, puis nous
procéderons à l'installation principale.

</para>

<sect2>

<title>Pré-requis</title>

<para>

Pour installer le serveur d'application, nous avons besoin des
bibliothèques SSL et LDAP. Le moteur SSL est lui aussi nécessaire pour
gérer les certificats SSL dans Apache 2.x

</para>

<sect3>

<title>Le SDK iPlanet LDAP</title>

<para>

Devenez root à l'aide de la commande su&nbsp;:

</para>

<screen>
$ su -
</screen>

<para>

Créez le répertoire <filename
class="directory">/usr/local/iplanet-ldap-sdk.5</filename>. Copiez le
répertoire
<filename>ldapcsdk5.08-Linux2.2_x86_glibc_PTH_OPT.OBJ.tar.gz</filename>
de <filename class="directory">/tmp/downloads</filename> vers <filename
class="directory">/usr/local/iplanet-ldap-sdk.5</filename>.

</para>

<screen>
# mkdir /usr/local/iplanet-ldap-sdk.5
# cp /tmp/downloads/ldapcsdk5.08-Linux2.2_x86_glibc_PTH_OPT.OBJ.tar /usr/local/iplanet-ldap-sdk.5
# cd /usr/local/iplanet-ldap-sdk.5
# tar -xvf ldapcsdk5.08-Linux2.2_x86_glibc_PTH_OPT.OBJ.tar
</screen>

<para>

À présent, tous les fichiers de la bibliothèque iPlanet LDAP devraient
se trouver dans le bon répertoire.

</para>

</sect3>

<sect3>

<title>Le moteur OpenSSL</title>

<para>

Ensuite, il nous faut installer le moteur OpenSSL

</para>

<para>

OpenSSL est une mise en &oelig;uvre open source du protocole SSL/TLS. Il est
indispensable pour créer et gérer les certificats SSL sur le serveur
Web. Cette installation est aussi indispensable pour les fichiers et les
bibliothèques qui seront utilisés par le module SSL d'Apache.

</para>

<para>

Allez dans le répertoire où vous avez placé les fichiers du code source
openSSL

</para>

<screen>
# cd /tmp/download
# gzip -d openssl.x.x.tar.gz
# tar -xvf openssl.x.x.tar
# cd openssl.x.x
# make
# make test
# make install
</screen>

<para>

Après exécution complète de la commande <userinput>make
install</userinput> les exécutables openssl devraient se trouver dans le
répertoire <filename class="directory">/usr/local/ssl</filename>

</para>

</sect3>

</sect2>

<sect2>

<title>mySQL</title>

<para>

L'installation de mySQL est très simple. Les binaires téléchargés
doivent être placés dans le répertoire approprié.

</para>

<para>

Nous commençons par créer un utilisateur:groupe pour le démon mysql, et
copions les fichiers dans les répertoires appropriés.

</para>

<screen>
# groupadd mysql
# useradd -g mysql mysql
# cd /usr/local
# gunzip &lt; /path/to/mysql-VERSION-OS.tar.gz | tar xvf -
# ln -s full-path-to-mysql-VERSION-OS mysql
</screen>

<para>

Puis nous lançons le script install_db et changeons les permissions des
fichiers

</para>

<screen>
# cd mysql
# scripts/mysql_install_db
# chown -R mysql .
</screen>

<sect3>

<title>Démarrer mySQL</title>

<para>

Nous lançons maintenant le serveur mySQL pour vérifier l'installation

</para>

<screen>
# bin/mysqld_safe --user=mysql &amp;
</screen>

<para>

Vérifiez que le démon mySQL est lancé en utilisant la commande
<userinput>ps -ef</userinput>. Vous devriez voir s'afficher&nbsp;:

</para>

<screen>
# ps -ef | grep mysql
root  3237    1 0 May29 ? 00:00:00 /bin/sh bin/safe_mysqld
mysql 3256 3237 0 May29 ? 00:06:58 /usr/local/mysql/bin/mysqld --defaults-extra-file=/usr/local/mysql/data/my.cnf --basedir=/usr/local/mysql --datadir=/usr/local/mysql/data --user=mysql --pid-file=/usr/local/mysql/data/download
</screen>

</sect3>

<sect3>

<title>Arrêter mySQL</title>

<para>

Pour arrêter le serveur mySQL, suivez les instructions suivantes

</para>

<screen>
# cd /usr/local/mysql
# ./bin/mysqladmin -u root -p shutdown
</screen>

</sect3>

<sect3>

<title>Localiser le répertoire de données</title>

<para>

Le démon mySQL place toutes les informations dans un répertoire appelé
<quote>répertoire de données</quote>. Si vous avez suivi les
instructions d'installation ci-dessus, votre répertoire de données
devrait être situé sous <filename class="directory">
/use/local/mysql/data</filename>.

</para>
<para>

Pour trouver l'emplacement de votre répertoire de données, utilisez la
commande <command>mysqladmin</command> comme suit&nbsp;:

</para>

<screen>
# /usr/local/mysql/bin/mysqladmin variables -u root --password={votre_mot_de_passe} | grep datadir
</screen>

</sect3>

</sect2>

<sect2>

<title>Apache 2.0</title>

<para>

Commençons par rajouter quelques options de compilation

</para>

<screen>
# export LDFLAGS="-L/usr/local/iplanet-ldap-sdk.5/lib/ -R/usr/local/iplanet-ldap-sdk.5/lib/:/usr/local/lib"
# export CPPFLAGS="-I/usr/local/iplanet-ldap-sdk.5/include"
</screen>

<para>

Puis décompressez les sources d'Apache 2.0 avec UNTAR, et exécutez le
script de <filename> configuration</filename>.

</para>

<screen>
# cd /tmp/download
# gzip -d httpd-2.0.46.tar.gz
# tar -xvf httpd-2.0.46.tar
# cd httpd-2.0.46
#./configure --enable-so --with-ssl --enable-ssl --enable-rewrite --enable-dav
</screen>

<para>

Exécutez ensuite la commande <command>make</command>

</para>

<screen>
# make
# make install
</screen>

<sect3>

<title>Démarrer Apache</title>

<screen>
# /usr/local/apache2/bin/apachectl start
</screen>

</sect3>

<sect3>

<title>Arrêter Apache</title>

<screen>
# /usr/local/apache2/bin/apachectl stop
</screen>

</sect3>

</sect2>

<sect2>

<title>mod_auth_ldap</title>

<para>

Décompressez modauthldap_apache2.tar.gz avec Untar

</para>

<screen>
cd /tmp/download
# gzip -d modauthldap_apache2.tar.gz
# tar -xvf modauthldap_apache2.tar
# cd modauthldap_apache2
</screen>
<para>

À présent, configurez et installez mod_auth_ldap

</para>

<screen>
# ./configure --with-apxs=/usr/local/apache2/bin/apxs --with-ldap-dir=/usr/local/iplanet-ldap-sdk.5/
# make
# make install
</screen>

</sect2>

<sect2>

<title>CERT DB for LDAPS://</title>

<para>

Vous devrez aussi télécharger cert7.db and key7.db des sites <ulink
url="http://www.xml-dev.com/xml/key3.db" /> et <ulink
url="http://www.xml-dev.com/xml/cert7.db" /> et les placer dans le
répertoire <filename>/usr/local/ssl</filename>.

</para>

</sect2>

<sect2>

<title>PHP</title>

<para>

Décompressez les fichiers source de PHP avec Unzip

</para>

<screen>
gzip -d php-xxx.tar.gz
tar -xvf php-xxx.tar
</screen>

<para>

Exécutez les commandes configure puis make

</para>

<screen>
cd php-xxx
./configure --with-mysql --with-apxs=/usr/local/apache2/bin/apxs
</screen>

<para>

Compilez le code source

</para>

<screen>
# make
# make install
</screen>

<para>

Copiez le fichier php.ini dans le répertoire approprié

</para>

<screen>
cp php.ini-dist /usr/local/lib/php.ini
</screen>

</sect2>

</sect1>

<sect1 id="config-webdav">

<title>Configurer et installer les services WebDAV</title>

<para>

Et maintenant la partie la plus facile. Dans cette section, nous
rendrons un répertoire situé à la racine d'Apache disponible à WebDAV.

</para>

<sect2>

<title>

Modifications au fichier
<filename>/usr/local/apache/conf/httpd.conf</filename>

</title>

<para>

Vérifiez que la directive Apache suivante apparaît dans le fichier
<filename>/usr/local/apache/conf/httpd.conf</filename>&nbsp;:

</para>

<screen>
Addmodule mod_dav.c
</screen>

<para>

Si elle n'y est pas, ajoutez la. Cette directive informe Apache du support des
fonctionnalités de DAV. La directive doit être placée à l'extérieur des
conteneurs.

</para>

<para>

Ensuite nous devons déterminer où Apache stockera le fichier DAVLockDB.
DAVLockDB est une base de données de verrouillage pour WebDAV. le
processus httpd doit avoir les droits en écriture dans ce répertoire.

</para>

<para>

J'enregistre le fichier DAVLock sous
<filename>/usr/local/apache/var</filename>. J'utilise aussi ce
répertoire pour d'autres besoins. Ajoutez la ligne suivante dans votre
fichier <filename>/usr/local/apache/conf/httpd.conf</filename> pour
préciser que le fichier DAVLockDB est situé dans le répertoire
<filename>/usr/local/apache/var</filename>&nbsp;:

</para>

<screen>
DAVLockDB /usr/local/apache/var/DAVLock
</screen>

<para>

La directive doit être placée à l'extérieur des conteneurs.

</para>

</sect2>

<sect2>

<title>Créer un répertoire pour DAVLockDB</title>

<para>

Comme il est mentionné plus haut, il faut créer un répertoire pour
DAVLockDB auquel le processus du serveur Web doit pouvoir accéder en
écriture. D'habitude, le processus du serveur Web s'exécute sous
l'utilisateur <quote><literal>nobody</literal></quote>. Vérifiez-le sur
votre système en utilisant la commande&nbsp;:

</para>

<screen>
ps -ef | grep httpd
</screen>

<para>

à partir de <filename>/usr/local/apache</filename>. Créez le répertoire
et définissez ces permissions en utilisant les commandes
suivantes&nbsp;:

</para>

<screen>
# cd /usr/local/apache
# mkdir var
# chmod -R 755 var/
# chown -R nobody var/
# chgrp -R nobody var/
</screen>

</sect2>

<sect2>

<title>Donner l'accès à DAV</title>

<para>

Donner l'accès à DAV est une tâche insignifiante. Pour autoriser DAV à
accéder à un répertoire situé sous la racine d'Apache, ajoutez
simplement la directive suivante dans le conteneur de cette directive
particulière&nbsp;:

</para>

<screen>
DAV On
</screen>

<para>

Cette directive autorisera DAV à accéder au répertoire et à ses
sous-répertoires.

</para>

<para>

Ce qui suit est un exemple de configuration activant WebDAV et le
service d'authentification LDAP dans
<filename>/usr/local/apache/htdocs/DAVtest</filename>. Placez ceci dans
le fichier <filename>/usr/local/apache/conf/httpd.conf</filename>.

</para>

<screen>
DavLockDB /tmp/DavLock
&lt;Directory "/usr/local/apache2/htdocs/DAVtest"&gt;
  Options Indexes FollowSymLinks
  AllowOverride None
  order allow,deny 
  allow from all
  AuthName "SMA Development server"
  AuthType Basic
  LDAP_Debug On
  #LDAP_Protocol_Version 3
  #LDAP_Deref NEVER
  #LDAP_StartTLS On
  LDAP_Server you.ldap.server.com
  #LDAP_Port 389
  # If SSL is on, must specify the LDAP SSL port, usually 636
  LDAP_Port 636
  LDAP_CertDbDir /usr/local/apache2/sslcert
  Base_DN "o=SDS"
  UID_Attr uid
  DAV On
  #require valid-user
  require valid-user
  #require roomnumber "123 Center Building"
  #require filter "(&amp;(telephonenumber=1234)(roomnumber=123))"
  #require group cn=rcs,ou=Groups
&lt;/Directory&gt;
</screen>

</sect2>

<sect2>

<title>Créer un répertoire nommé DAVtest</title>

<para>

Comme il est mentionné dans une section précédente, le processus du
serveur Web doit avoir les droits en écriture dans tous les répertoires
DAV. Dans cet exemple nous considérons que le serveur Web s'exécute sous
l'utilisateur <quote><literal>nobody</literal></quote>. La plupart du
temps c'est le cas. Pour vérifier sous quel utilisateur httpd s'exécute,
saisissez&nbsp;:

</para>

<screen>
# ps -ef | grep httpd
</screen>

<para>

Créez un répertoire nommé <quote><filename>DAVtest</filename></quote>
dans le répertoire <filename>/usr/local/apache/htdocs</filename>&nbsp;:

</para>

<screen>
# mkdir /usr/local/apache/htdocs/DAVtest
</screen>

<para>

Changez les permissions du répertoire pour le rendre accessible au
processus httpd en lecture et écriture. Considérant que httpd s'exécute
sous l'utilisateur <quote><literal>nobody</literal></quote>, utilisez
les commandes suivantes&nbsp;:

</para>

<screen>
# cd /usr/local/apache/htdocs
# chmod -R 755 DAVtest/
# chown -R nobody DAVtest/
# chgrp -R nobody DAVtest/
</screen>

</sect2>

<sect2>

<title>Redémarrer Apache</title>

<para>

Pour finir, vous devez exécuter la routine du test de configuration
fournie avec Apache pour vérifier la syntaxe du fichier
<filename>httpd.conf</filename>&nbsp;:

</para>

<screen>
# /usr/local/apache/bin/apachectl configtest
</screen>

<para>

S'il y a des messages d'erreur, vérifiez que vous avez suivi
correctement toutes les étapes mentionnées ci-dessus. Si vous n'arrivez
pas à comprendre ce que signifie le message d'erreur, n'hésitez pas à
m'envoyer un courrier électronique (en anglais) avec le message d'erreur

(<email>saqib CHEZ seagate POINT com</email>).

</para>

<para>

Si le test de configuration a réussi, démarrez le serveur Web
Apache&nbsp;:

</para>

<screen>
# /usr/local/apache/bin/apachectl restart
</screen>

<para>

À présent, vous avez un serveur WebDAV Apache utilisant LDAP pour
l'authentification et SSL pour le chiffrement.

</para>

</sect2>

<sect2>

<title>Test de conformité au protocole du serveur WebDAV</title>

<para>

Il est très important que le serveur WebDAV que nous venons juste
d'installer soit totalement compatible avec le protocole WebDAV-2. S'il
n'est pas totalement compatible, les applications WebDAV côté client
pourront ne pas fonctionner correctement.

</para>

<para>

Pour tester la compatibilité nous utiliserons un outil nommé Litmus.
Litmus est une suite de tests de compatibilité avec le protocole d'un
serveur WebDAV, qui est destinée à tester si un serveur est compatible
avec le protocole WebDAV selon les spécifications de la norme RFC2518.

</para>

<para>

Téléchargez les sources de Litmus du site <ulink
url="http://www.webdav.org/neon/litmus/" /> et placez les dans le
répertoire /tmp/downloads

</para>

<para>

Puis utilisez gzip et tar pour extraire les fichiers&nbsp;:

</para>

<screen>
# cd /tmp/downloads
# gzip -d litmus-0.6.x.tar.gz
# tar -xvf litmus-0.6.x.tar
# cd litmus-0.6.x
</screen>

<para>

Il est facile de compiler et d'installer Litmus&nbsp;:

</para>

<screen>
# ./configure
# make
# make install
</screen>

<para>

<command>make install</command> installera les fichiers binaires de
Litmus dans les répertoires <filename>/usr/local/bin</filename> et les
fichiers d'aide dans <filename>/usr/local/man</filename>

</para>

<para>

Pour tester la compatibilité du serveur WebDAV que vous venez
d'installer, recourez à la commande suivante

</para>

<screen>
# /usr/local/bin/litmus http://you.dav.server/DAVtest userid passwd
</screen>

</sect2>

</sect1>

<sect1>

<title>Administration du serveur WebDAV</title>

<para>

Dans cette section, nous aborderons les différentes tâches
d'administration &mdash; par exemple l'utilisation de LDAP pour le
contrôle d'accès, et comment on travaille dans Apache avec DAV

</para>

<para>

La plupart des changements de configuration pour DAV devront être faits
dans le fichier <filename>httpd.conf</filename>. L'emplacement de ce
fichier est <filename>/usr/local/apache/conf/httpd.conf</filename>.

</para>

<para>

<filename>httpd.conf</filename> est un fichier texte qui est utilisé
pour la configuration d'Apache. Il peut être édité à l'aide de n'importe
quel éditeur de texte &mdash; je préfère vi. Faites une copie de
sauvegarde de ce fichier avant de le modifier.

</para>

<para> Après avoir effectué des modifications au fichier <filename>
httpd.conf</filename> le serveur Apache doit être redémarré avec la
commande <userinput>/usr/local/apache/bin/apachectl restart</userinput>. 
Cependant avant de le redémarrer, vous testerez la validité du fichier
<filename>httpd.conf</filename> en utilisant la commande
<userinput>/usr/local/apache/bin/apachectl configtest</userinput>.

</para>

<sect2>

<title>Limiter les accès aux partages de DAV</title>

<para>

Dans la section précédente, quand nous avons créé le partage DAVtest,
nous avons utilisé LDAP pour l'authentification. Cependant, n'importe
qui pouvant s'authentifier en utilisant son
compte_utilisateur/mot_de_passe pourra accéder à ce dossier.

</para>

<para>

En utilisant la directive <literal>require</literal> dans le fichier
httpd.conf, vous pouvez limiter l'accès à certains individus ou groupes
d'individus.

</para>

<para>

Si nous regardons la configuration de DAVtest de la précédente
section&nbsp;:

</para>

<screen>
&lt;Directory /usr/local/apache/htdocs/DAVtest&gt;

Dav On
#Options Indexes FollowSymLinks
AllowOverride None
order allow,deny
allow from all
AuthName "LDAP_userid_password_required"
AuthType Basic

&lt;Limit GET PUT POST DELETE PROPFIND PROPPATCH MKCOL COPY MOVE LOCK UNLOCK&gt;

Require valid-user

&lt;/Limit&gt;

LDAP_Server ldap.server.com
LDAP_Port 389
Base_DN "o=ROOT"
UID_Attr uid

&lt;/Directory&gt;
</screen>

<para>

nous voyons que la commande <literal>require</literal> a pour paramètre
<literal>valid-user</literal>. Ce qui signifie que n'importe quel
utilisateur authentifié peut accéder à ce dossier.

</para>

<sect3>

<title>Limitations d'accès basées sur les UID individuels</title>

<para>

Les UID de LDAP peuvent être utilisés pour limiter les accès au dossier DAV.

</para>

<para>

La directive require <literal>valid-user</literal> peut être remplacée 
par <literal>require user 334455 445566</literal>

</para>

<para>

Ceci limitera l'accès aux individus ayant pour UID 334455 et 445566.
Personne d'autre ne pourra accéder à ce dossier.

</para>

</sect3>

<sect3>

<title>Limitations d'accès basées sur des groupes d'individus</title>

<para>

La directive <literal>require</literal> peut aussi être utilisée pour
limiter les accès à des groupes d'individus. On peut le faire en
utilisant soit les groupes de LDAP, soit les filtres de LDAP. Le filtre
doit avoir une syntaxe de filtre LDAP valide.

</para>

</sect3>

</sect2>

<sect2>

<title>Limiter l'accès en écriture à des partages DAV</title>

<para>

On peut avoir besoin de limiter l'accès en écriture aux ressources des
partages DAV à une certaine personne, en laissant toutefois n'importe
qui voir les ressources. On peut le faire facilement en utilisant les
balises <literal>&lt;Limit&gt;</literal> dans le fichier httpd.conf

</para>

<screen>
&lt;Directory /usr/local/apache/htdocs/DAVtest&gt;
Dav On
#Options Indexes FollowSymLinks
AllowOverride None
order allow,deny
allow from all
AuthName "LDAP_userid_password_required"
AuthType Basic

&lt;Limit GET PUT POST DELETE PROPFIND PROPPATCH MKCOL COPY MOVE LOCK UNLOCK&gt;

Require valid-user

&lt;/Limit&gt;

LDAP_Server ldap.server.com
LDAP_Port 389
Base_DN "o=ROOT"
UID_Attr uid
&lt;/Directory&gt;
</screen>

<para>

Vous limiterez l'accès en écriture à certains utilisateurs en changeant
la balise <literal>&lt;limit&gt;</literal> en

</para>

<screen>
&lt;Limit PUT POST DELETE PROPPATCH MKCOL COPY MOVE LOCK UNLOCK&gt;

Require 334455

&lt;/Limit&gt;
</screen>

<para>

En fait, nous limitons les méthodes PUT POST DELETE PROPPATH MKCOL COPY
MOVE LOCK et UNLOCK à l'utilisateur qui a pour UID 334455. N'importe
qui d'autre pourra employer les méthodes GET et PROPFIND pour les
ressources, mais aucune autre méthode.

</para>

</sect2>

</sect1>

<sect1 id="ssl">

<title>

Mettre en &oelig;uvre et utiliser SSL pour protéger le trafic HTTP

</title>

<para>

De nos jours, la sécurité des données stockées sur un serveur de
fichiers est très importante. Des données compromises peuvent coûter des
milliers de dollars à une entreprise. Dans la dernière section, nous
avons compilé le module d'authentification LDAP dans Apache pour fournir
un mécanisme d'authentification. Cependant, le trafic http est très peu
sur, et toutes les données sont transférées en clair &mdash; ce qui
signifie que l'authentification LDAP (utilisateur/mot_de_passe) sera
transmise elle aussi en clair. Ceci pose un problème. N'importe qui peut
intercepter cet utilisateur/mot_de_passe et accéder aux dossiers de DAV.
Pour éviter ceci nous devrons chiffrer le trafic http, essentiellement
par HTTP + SSL ou HTTPS. Tout ce qui est transféré en HTTPS est chiffré,
ce qui fait que le couple utilisateur/mot_de_passe LDAP ne peut pas être
aisément déchiffré. HTTPS tourne sur le port 443. Les binaires
résultants étant compilés selon la dernière section, Apache pourra
écouter à la fois sur les ports 80 (HTTP normal) et 443 (HTTPS). Si vous
désirez utiliser ce serveur uniquement pour DAV, alors je vous suggère
fortement de fermer le port 80. Dans cette section du guide pratique, je
fournirai des informations sur SSL et comment l'administrer dans un
serveur http Apache.

</para>

<sect2>

<title>Introduction à SSL</title>

<para>

SSL (Secure Socket Layer) est une couche protocolaire qui se situe entre
la couche Réseau et la couche Application. Comme son nom le suggère, SSL
fournit un mécanisme de déchiffrement pour toutes sortes de
trafic&nbsp;: LDAP, POP, IMAP et plus important, HTTP.

</para>

<para>

Ce qui suit est une structure ultra simplifiée des couches impliquées
par SSL.

</para>

<screen>
+-------------------------------------------+
|   LDAP   |   HTTP   |    POP   |   IMAP   |
+-------------------------------------------+
|                    SSL                    | 
+-------------------------------------------+
|               Couche réseau               |
+-------------------------------------------+
</screen>

<sect3>

<title>Algorithmes de cryptographie utilisés par SSL</title>

<para>

SSL utilise trois sortes de techniques de cryptographie&nbsp;: les
systèmes de clés publiques-privées, de clés symétriques et de <link
linkend="digitsign">signatures numériques</link>.

</para>

<para>

<emphasis role="strong">Chiffrement par clés publiques-privées &mdash;
Initialisation d'une connexion SSL&nbsp;:</emphasis> dans cet
algorithme, le chiffrement et le déchiffrement sont effectués en
utilisant une paire de clés publiques et privées. Le serveur Web détient
la clé privée, et envoie la clé publique au client dans le certificat.

</para>

<orderedlist>

<listitem><para>

Le client demande un contenu au serveur Web en utilisant HTTPS.

</para></listitem>

<listitem><para>

Le serveur Web répond en envoyant un certificat numérique qui comprend
la clé publique du serveur.

</para></listitem>

<listitem><para>

Le client vérifie si le certificat est expiré.

</para></listitem>

<listitem><para>

Puis le client vérifie si l'autorité de certification qui a signé le
certificat est une autorité de confiance figurant dans la liste du
navigateur. Ceci explique pourquoi il est nécessaire d'obtenir un
certificat d'une autorité de certification de confiance.

</para></listitem>

<listitem><para>

Puis, le client vérifie si le nom de domaine pleinement qualifié (FQDN)
du serveur Web coïncide avec le Nom Commun (Common Name CN) du
certificat.

</para></listitem>

<listitem><para>

Si tout est correct, la connexion SSL est initialisée.

</para></listitem>

</orderedlist>

<note><title>N.B.&nbsp;:</title>
<para>

On ne peut déchiffrer ce qui a été chiffré avec une clé privée qu'avec
sa clé publique. De la même façon, on ne peut déchiffrer ce qui a été
chiffré avec une clé publique qu'avec sa clé privée. C'est une erreur
répandue de penser qu'une clé publique est utilisée pour le chiffrement
et que la clé privée est utilisée pour le déchiffrement. Ce n'est pas le
cas. On peut utiliser les deux clés pour chiffrer ou déchiffrer.
Cependant, si on utilise une clé pour chiffrer, alors l'autre clé devra
servir à déchiffrer. Par exemple On ne peut chiffrer un message puis le
déchiffrer en utilisant uniquement une clé publique.

</para>

<para>

<emphasis>L'utilisation d'une clé privée pour chiffrer et d'une clé
publique pour déchiffrer garantit l'identité de l'émetteur (qui est le
propriétaire de la clé publique) à ses destinataires. L'utilisation
d'une clé publique pour chiffrer et d'une clé privée pour déchiffrer
garantit que seul le destinataire (qui est le propriétaire de la clé
publique) accédera aux données.</emphasis> (c'est-à-dire que seul le
détenteur de la clé privée pourra déchiffrer le message).

</para></note>

<para>

<emphasis role="strong">Chiffrement symétrique &mdash; Transmission
effective des données</emphasis>&nbsp;: une fois la connexion SSL
établie, on utilise le chiffrement symétrique, qui est moins
consommateur en cycles de processeur. Avec le chiffrement symétrique, on
peut chiffrer et déchiffrer les données en utilisant la même clé. La clé
de chiffrement symétrique est échangée durant le processus
d'initialisation, en utilisant la clé de chiffrement publique.

</para>

<para>

<emphasis role="strong">Sommation de messages</emphasis> Le serveur
utilise des algorithmes de sommation de messages comme <link
linkend="hmac">HMAC</link>, <link linkend="sha1">SHA-1</link>, <link
linkend="md5">MD5</link> pour vérifier l'intégrité des données
transférées.

</para>

</sect3>

<sect3>

<title>Garantie d'authenticité et d'intégrité</title>

<para>Processus de chiffrement</para>
<screen>

           Clef privée              Clef publique
          de l'émetteur            du destinataire
          ,-.                     ,-.
         (   )..........         (   )..........
          `-' ''''|'|'||          `-' ''''''''||
                  | |                    |
                  | |                    |
   .----------.   | |    .----------.    |     .----------.
   |  Texte   |   V |    |   Texte  |    V     |   Texte  |
   |   en     |--------->|  chiffré |--------->|  chiffré |
   |  clair   | Étape1   |     1    | Étape2   |     2    |\
   `----------'     |    `----------'          `----------' \    __
         |          |                                        \   [_'
         |          |                                  Étape5 \   |
         |Étape3    |                                       __  --|--
         |          |                                  _.--'      |
         V          |                            _..-''          / \
    .---------.     |    .---------.       _..-''            Destinataire
    |  SHA 1  |     V    |Signature| _..-''
    |SomMessag|--------->|numérique|'
    `---------' Étape4   `---------' 
              _  ___ ___
        _    (_)/  _)  _)                                      _
   ____| |__  _ | |_| |_ ____ _____ _____  _____  _____ ____ _| |_
  / ___)  _ \| ||  _)  _) ___) ___ |  _  \|  _  \| ___ |  _ (_   _)
 ( (___  | | | || | | || |   | ____| || | | || | | ____| | | || |_
  \____)_| |_|_||_| |_||_|   |_____)_||_|_|_||_|_|_____)_| |_| \__)
</screen>

<itemizedlist mark='opencircle'>

<listitem><para>

Étape 1&nbsp;: le message original en clair est chiffré avec la clé
privée de l'émetteur, ce qui produit le texte chiffré 1. L'authenticité
de l'émetteur est garantie.

</para></listitem>

<listitem><para>

Étape 2&nbsp;: le <quote>texte chiffré 1</quote> est chiffré à l'aide de
la clé publique du destinataire, aboutissant au <quote>texte crypté
2</quote>. Celui-ci garantira l'authenticité du destinataire,
c'est-à-dire que seul le destinataire peut déchiffrer le message à
l'aide de sa clé privée.

</para></listitem>

<listitem><para>

Étape 3&nbsp;: la somme SHA1 du <quote>texte en clair</quote> est créée.

</para></listitem>

<listitem><para>

Étape 4&nbsp;: la somme SHA1 du message est ensuite chiffrée avec la clé
privée de l'émetteur, ce qui produit la signature numérique du
<quote>texte en clair</quote>. Le destinataire peut utiliser la
signature numérique pour s'assurer de l'intégrité du message et de
l'authenticité de l'émetteur.

</para></listitem>

<listitem><para>

Étape 5&nbsp;: la <quote>signature numérique</quote> et le <quote>texte
chiffré 2</quote> sont ensuite envoyés au destinataire.

</para></listitem>

</itemizedlist>
<para>

Processus de déchiffrement

</para>

<screen>
           Clef privée          Clef publique
         du destinataire        de l'émetteur
         ,-.                     ,-.
        (   )..........         (   )..........
         `-' ''''''''||          `-' '''''''|||
                |                      |    |
                |                      |    |
  .----------.  |       .----------.   |    | .----------.
  |  Texte   |  V       |  Texte   |   V    | |  Texte   |       .---No1---.
  | chiffré  |--------->| chiffré  |--------->|   en     |------>|  SHA 1  |
  |    2     | Étape1   |    1     | Étape2 | |  clair   |Étape3 |SomMessag|
  `----------'          `----------'        | `----------'       `---------'
                                            |                        ||
                                            |                        ||Étape5
                                            |                        ||
                                            |                        ||
                               .---------.  |                    .---------.
                               | Digital |  V                    |  SHA 1  |
                               |Signature|---------------------->|SomMessag|
                               `---------' Étape4                `---No2---'
     _    _              _  ___ ___
    | |  //        _    (_)/  _)  _)                                      _
  __| |_____  ____| |__  _ | |_| |_ ____ _____ _____  _____  _____ ____ _| |_
 / _  | ___ |/ ___)  _ \| ||  _)  _) ___) ___ |  _  \|  _  \| ___ |  _ (_   _)
( (_| | ____( (___  | | | || | | || |   | ____| || | | || | | ____| | | || |_
 \____|_____)\____)_| |_|_||_| |_||_|   |_____)_||_|_|_||_|_|_____)_| |_| \__)
</screen>

<itemizedlist mark='opencircle'>
<listitem><para>

Étape 1&nbsp;: le <quote>Texte chiffré 2</quote> est déchiffré avec la
clé privée du destinataire, ce qui produit le texte chiffré 1.

</para></listitem>

<listitem><para>

Étape 2&nbsp;: le <quote>texte chiffré 1</quote> est déchiffré à l'aide
de la clé publique de l'émetteur, ce qui produit le <quote>texte en
clair</quote>.

</para></listitem>

<listitem><para>

Étape 3&nbsp;: la somme SHA1 du <quote>texte en clair</quote> est créée.

</para></listitem>

<listitem><para>

Étape 4&nbsp;: la <quote>signature numérique</quote> est ensuite
déchiffrée à l'aide de la clé publique de l'émetteur, ce qui produit la
<quote>somme SHA 1 du message</quote>.

</para></listitem>

<listitem><para>

Étape 5&nbsp;: la <quote>somme SHA 1 du message numéro 1</quote> est
ensuite comparée à la <quote>somme SHA 1 du message numéro 2</quote>. Si
elles sont égales, cela signifie que les données n'ont pas été modifiées
durant la transmission, et que l'intégrité de l'original <quote>texte en
clair</quote> a été préservée.

</para></listitem>

</itemizedlist>

</sect3>

</sect2>

<sect2>

<title>Certificats de test</title>

<para>

Lorsque nous compilons Apache, nous créons un certificat de test. Nous
avons utilisé le makefile fourni par mod_ssl pour créer ce certificat
sur mesure. Nous avons utilisé la commande&nbsp;:

</para>

<screen>
# make certificate TYPE=custom
</screen>

<para>

Nous pourrons utiliser ce certificat à des fins de test.

</para>

</sect2>

<sect2>

<title>Certificats destinés à la production</title>

<para>

Il est nécessaire d'obtenir un certificat d'une Autorité de
Certification de confiance (nommée ci-après AC) pour une utilisation en
production. Les autorités de certification sont des vendeurs de
certificats, qui figurent dans la liste des AC de confiance de chaque
navigateur. Comme on l'a précisé dans la section des algorithmes de
cryptographie, si l'AC ne figure pas dans la liste des autorités de
confiance, un message d'alerte s'affichera quand l'utilisateur essayera
de se connecter à un site sécurisé.

</para>

<para>

Les certificats de test provoqueront eux aussi l'apparition d'un message
d'alerte dans le navigateur de l'utilisateur.

</para>

</sect2>

<sect2>

<title>Génération d'un CSR</title>

<para>

Pour être signée, une CSR (Certificate Signature Request: Demande de
Signature de Certificat) doit être envoyée à une AC de confiance. Cette
section montre comment on crée une CSR, et comment on l'envoie à l'AC de
son choix.

</para>

<screen>
# openssl req</screen>

<para>

Pour créer une CSR, on peut recourir à cette commande comme suit&nbsp;:

</para>

<screen>
# cd /usr/local/apache/conf/
# /usr/local/ssl/bin/openssl req -new -nodes -keyout private.key -out public.csr
Generating a 1024 bit RSA private key
............++++++
....++++++
writing new private key to 'private.key'
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter '.', the field will be left blank.
-----
Country Name (2 letter code) [AU]:US
State or Province Name (full name) [Some-State]:California
Locality Name (eg, city) []:San Jose
Organization Name (eg, company) [Internet Widgits Pty Ltd]:Seagate 
Organizational Unit Name (eg, section) []:Global Client Server
Common Name (eg, YOUR name) []:xml.seagate.com
Email Address []:saqib@seagate.com

Please enter the following 'extra' attributes
to be sent with your certificate request
A challenge password []:badpassword
An optional company name []:
</screen>

<note><title><quote>PRNG not seeded</quote></title>
<para>

Si le fichier <filename> /dev/random</filename> n'existe pas sur votre
système, le message d'erreur <quote><literal>PRNG not
seeded</literal></quote> s'affichera. Dans ce cas, vous pouvez utiliser
la commande suivante&nbsp;:

</para>

<screen>
# /usr/local/ssl/bin/openssl req -rand <filename>mon_fichier.ext</filename> -new -nodes -keyout private.key -out public.csr
</screen>

<para>

Remplacez le fichier mon_fichier.ext par le nom d'un fichier existant
dans votre système. Vous pouvez spécifier n'importe quel fichier.
Openssl utilisera ce fichier pour générer le noyau.

</para>

<para>

Sur Solaris 9 on trouve le fichier <filename>/dev/random</filename> .
Cependant, il est possible que vous ayez à installer le correctif <ulink
url="http://sunsolve.sun.com/pub-cgi/findPatch.pl?patchId=112438">
112438</ulink> pour accéder à /dev/random

</para></note>

<para>

Arrivé là, vous devrez répondre à plusieurs questions concernant votre
serveur pour générer la CSR.

</para>

<para>

N.B.&nbsp;: Votre Common Name (CN) est le nom DNS pleinement qualifié
(FQDN) de votre serveur web, c'est-à-dire dav.server.com . Si vous
saisissez quelque chose d'autre, ça ne marchera PAS. Mettez de côté le
mot de passe pour un usage ultérieur.

</para>

<para>

Une fois le processus achevé, un fichier
<filename>private.key</filename> et un fichier
<filename>public.csr</filename> seront présents dans votre arborescence.
Il vous faudra envoyer le fichier <filename> public.csr</filename> à
l'autorité de certification. À ce stade, le fichier public.key n'est pas
chiffré. pour le chiffrer, saisissez&nbsp;:

</para>

<screen>
# mv private.key private.key.unecrpyted
# /usr/local/ssl/bin/openssl rsa -in private.key.unecrpyted -des3 -out private.key
</screen>

</sect2>

<sect2 id="InstallingServerCert">

<title>Installation de la clé privée et du certificat du serveur</title>

<para>

une fois que l'autorité de certification aura traitée votre demande,
elle vous renverra un certificat codé (certificat numérique). Le
certificat numérique est au format défini par la norme X.509 v3. Les
lignes qui suivent montre la structure d'un certificat numérique
conforme à X509 v3 (version française entre parenthèses)

</para>

<itemizedlist mark='opencircle'>
<listitem><para>

Certificat

<itemizedlist mark='opencircle'>

<listitem><para>

Version (Version)

</para></listitem>

<listitem><para>

Serial Number (Numéro de série)

</para></listitem>

<listitem><para>

Algorithm ID (Identification de l'algorithme)

</para></listitem>

<listitem><para>

Issuer (Émetteur)

</para></listitem>

</itemizedlist>

<itemizedlist mark='opencircle'>

<listitem><para>

Validity (Validité)

</para></listitem>

<listitem>

<itemizedlist mark='opencircle'>

<listitem><para>

Not Before (pas avant)

</para></listitem>

<listitem><para>

Not After (pas après)

</para></listitem>

</itemizedlist>

</listitem>

</itemizedlist>

<itemizedlist mark='opencircle'>

<listitem><para>

Subject (sujet)

</para></listitem>

</itemizedlist>

<itemizedlist mark='opencircle'>
<listitem><para>

Subject Public Key Info (Info de sujet de clé publique)

</para></listitem>

<listitem>

<itemizedlist mark='opencircle'>

<listitem><para>

Public Key Algorithm (algorithme de clé publique)

</para></listitem>

<listitem><para>

RSA Public Key (clé publique RSA)

</para></listitem>

</itemizedlist>

</listitem>

</itemizedlist>

<itemizedlist mark='opencircle'>

<listitem><para>

Extensions (Extensions)

</para></listitem>

</itemizedlist>

</para></listitem>

<listitem><para>

Certificate Signature Algorithm (algorithme de signature du certificat)

</para></listitem>

<listitem><para>

Certificate Signature (signature du certificat)

</para></listitem>

</itemizedlist>

<sect3>

<title>Vérification d'un certificat numérique</title>

<para>

Pour vérifier un certificat X.509, utilisez la commande suivante&nbsp;:

</para>

<screen>
# openssl verify <filename>server.crt</filename>
server.crt: OK
</screen>

<para>

où <filename>server.crt</filename> est le nom du fichier qui contient le
certificat numérique.

</para>

</sect3>

<sect3 id="viewingdigitcertcontent">

<title>Vérification du contenu d'un certificat numérique</title>

<para>

On peut voir le contenu d'un certificat numérique en utilisant la
commande <userinput># openssl x509</userinput> comme suit&nbsp;:

</para>

<screen>
# openssl x509 -text -in <filename>server.crt</filename>
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 312312312 (0x0)
        Signature Algorithm: md5WithRSAEncryption
	Issuer: C=US, O=GTE Corporation, CN=GTE CyberTrust Root
        Validity
            Not Before: Feb  8 03:25:50 2000 GMT
            Not After : Feb  8 03:25:50 2001 GMT
	    Subject: C=US, ST=New York, L=Pelham, O=xml-dev, OU=web, CN=www.xml-dev.com/Email=saqib@xml-dev.com
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
            RSA Public Key: (1024 bit)
                Modulus (1024 bit):
		............
		............
                Exponent: 65537 (0x10001)
    Signature Algorithm: md5WithRSAEncryption
    	............
	............
</screen>

</sect3>

<sect3>

<title>

Installation des certificats&nbsp;: modification du fichier httpd.conf

</title>

<para>

Vous devrez placer ce certificat dans le serveur, et indiquer à Apache
où le trouver.

</para>

<para>

Dans cet exemple, la clé privée est située dans le répertoire <filename
class="directory">/usr/local/apache2/conf/ssl.key/</filename> et le
certificat du serveur est placé dans le répertoire <filename
class="directory">/usr/local/apache2/conf/ssl.crt/</filename>.

</para>

<para>

Copiez en le renommant le fichier reçu de l'autorité de certification en
<filename>server.crt</filename> dans le répertoire <filename
class="directory">/usr/local/apache2/conf/ssl.crt/</filename>.

</para>

<para>

et placez le fichier private.key généré à l'étape précédente dans le
répertoire <filename
class="directory">/usr/local/apache2/conf/ssl.key/</filename>

</para>

<para>

Puis modifiez le fichier <filename
class="directory">/usr/local/apache2/conf/ssl.key/</filename> pour qu'il
pointe correctement vers la clé privée et le certificat du
serveur&nbsp;:

</para>

<screen>
#   Server Certificate:
#   Point SSLCertificateFile at a PEM encoded certificate.  If
#   the certificate is encrypted, then you will be prompted for a
#   pass phrase.  Note that a kill -HUP will prompt again.  Keep
#   in mind that if you have both an RSA and a DSA certificate you
#   can configure both in parallel (to also allow the use of DSA
#   ciphers, etc.)
SSLCertificateFile /usr/local/apache2/conf/ssl.crt/server.crt
#SSLCertificateFile /usr/local/apache2/conf/ssl.crt/server-dsa.crt

#   Server Private Key:
#   If the key is not combined with the certificate, use this
#   directive to point at the key file.  Keep in mind that if
#   you've both a RSA and a DSA private key you can configure
#   both in parallel (to also allow the use of DSA ciphers, etc.)
SSLCertificateKeyFile /usr/local/apache2/conf/ssl.key/private.key
#SSLCertificateKeyFile /usr/local/apache2/conf/ssl.key/server-dsa.key
</screen>

</sect3>

</sect2>

<sect2>

<title>Annulation de la phrase de passe pour la clef privée RSA</title>

<para>

La clé privée RSA conservée sur le serveur Web est d'habitude chiffrée,
et il vous faut une phrase de passe pour parcourir le fichier. Voilà
pourquoi quand Apache est lancé avec modssl, une phrase de passe vous
est demandée&nbsp;:

</para>

<screen>
# apachectl startssl
Apache/1.3.23 mod_ssl/2.8.6 (Pass Phrase Dialog)
Some of your private key files are encrypted for security reasons.
In order to read them you have to provide us with the pass phrases.
Server your.server.dom:443 (RSA)
Enter pass phrase:
</screen>

<para>

Il est très important de chiffrer une clé privée RSA. Si un pirate
s'empare de votre clé privée RSA non chiffrée, il pourra facilement
emprunter l'identité de votre serveur Web. Si la clé est chiffrée, la
seule chose que pourra faire le pirate est de tenter une attaque en
force brute sur votre phrase de passe. L'utilisation d'une phrase de
passe robuste (c'est-à-dire longue) est encouragée.

</para>

<para>

Cependant, le fait de chiffrer la clé peut parfois être gênant, dans la
mesure où vous devrez saisir la phrase de passe à chaque démarrage du
serveur Web. En particulier si vous utilisez les scripts rc pour lancer
le serveur Web au démarrage, le processus de démarrage sera stoppé sur
l'invite de saisie d'une phrase de passe.

</para>

<para>

Vous pouvez facilement vous débarrasser de l'invite de saisie de la
phrase de passe en déchiffrant la clé. Cependant, assurez-vous que
personne ne pourra s'emparer de cette clé. Je ne saurais trop vous
recommander d'appliquer les lignes de conduite de durcissement et de
sécurisation du serveur avant de déchiffrer la clé du serveur Web.

</para>

<para>

Pour déchiffrer la clé&nbsp;:

</para>
<para>

tout d'abord, faites une copie de la clé chiffrée

</para>

<screen>
# cp server.key server.key.cryp
</screen>

<para>

Puis recréez la clé avec chiffrement. L'invite vous demandera la phrase
de passe de la clé chiffrée d'origine

</para>

<screen>
# /usr/local/ssl/bin/openssl rsa -in server.key.cryp -out server.key
read RSA key Enter PEM pass phrase: writing RSA key

</screen>

<para>

Une façon de sécuriser la clé privée non chiffrée est de limiter l'accès
en lecture à l'utilisateur root&nbsp;:

</para>

<screen>
# chmod 400 server.key
</screen>

</sect2>

<sect2>

<title>Réglage des performances SSL</title>

<sect3>

<title>Cache de session SSL inter-processus</title>

<para>

Le modèle de fonctionnement d'Apache est multi-processus&nbsp;; toutes
les requêtes ne seront PAS prises en charge par le même processus.
L'information sur la session SSL se perd donc quand un client effectue
de multiples requêtes. De multiples échanges de données SSL provoquent
une surcharge du système sur le serveur Web et le client. Pour éviter
cela, les informations de session SSL doivent être stockées dans un
cache de session inter-processus, pour permettre à tous les processus
d'accéder aux informations protocolaires. On peut spécifier
l'emplacement du cache de session SSL dans la directive SSLSessionCache
dans le
fichier<filename>/usr/local/apache2/conf/ssl.key/</filename>&nbsp;:

</para>

<screen>
SSLSessionCache         shmht:logs/ssl_scache(512000)
#SSLSessionCache        shmcb:logs/ssl_scache(512000)
#SSLSessionCache        dbm:logs/ssl_scache
SSLSessionCacheTimeout  300
</screen>

<para>

L'utilisation de dbm:logs/ssl_scache crée un cache de type fichier de
hachage DBM sur le disque local.

</para>

<para>

L'utilisation de shmht:logs/ssl_scache(512000) crée un cache dans un
segment de mémoire partagée

</para>

<note><title>shmht contre shmcb</title>

<para>

shmht&nbsp;: recoure à une table de hachage pour cacher les informations
du protocole SSL dans la mémoire partagée.

</para>

<para>

shmcb&nbsp;: recoure à un tampon cyclique pour cacher les informations
du protocole SSL dans la mémoire partagée.

</para>

</note>

<note><title>N.B.&nbsp;: </title>

<para>

tous les OS/plates-formes ne supportent pas de créer des tables de
hachage dans la mémoire partagée. Donc, il faut utiliser
dbm:logs/ssl_scache à la place.

</para></note>

</sect3>

<sect3>

<title>Vérification du cache de session SSL</title>

<para>

Pour vérifier si le cache de session SSL fonctionne correctement, vous
devez utiliser la commande <command>openssl</command> avec l'option
<option>-reconnect</option> comme suit&nbsp;:

</para>

<screen>
# openssl s_client -connect your.server.dom:443 -state -reconnect
CONNECTED(00000003)
.......
.......
Reused, TLSv1/SSLv3, Cipher is EDH-RSA-DES-CBC3-SHA
SSL-Session:
.....
Reused, TLSv1/SSLv3, Cipher is EDH-RSA-DES-CBC3-SHA
SSL-Session:
.....
Reused, TLSv1/SSLv3, Cipher is EDH-RSA-DES-CBC3-SHA
SSL-Session:
.....
Reused, TLSv1/SSLv3, Cipher is EDH-RSA-DES-CBC3-SHA
SSL-Session:
.....
Reused, TLSv1/SSLv3, Cipher is EDH-RSA-DES-CBC3-SHA
SSL-Session:
.....
</screen>

<para>

<option>-reconnect</option> oblige le s_client à se connecter au serveur
5 fois de suite en utilisant la même ID de session SSL. Comme vous le
voyez plus haut, vous devriez voir cinq tentatives de réutilisation de
la même ID de session.

</para>

</sect3>

</sect2>

</sect1>

<appendix>

<title>Outils d'évaluation de performances HTTP/HTTPS</title>

<para>

Vous trouverez ci-dessous une liste de quelques outils d'évaluation de
performances OpenSource pour serveurs Web

</para>

<orderedlist numeration="lowerroman">

<listitem><para>

<ulink url="http://distcache.sourceforge.net/">SSLswamp</ulink> &mdash;
pour un audit de performances lors de la connexion à un serveur SSL
autorisé

</para></listitem>

<listitem><para>

<ulink
url="http://www.hpl.hp.com/personal/David_Mosberger/httperf.html">HTTPERF</ulink>
&mdash; un outil pour mesurer les performances d'un serveur Web

</para></listitem>

<listitem><para>

<ulink
url="http://httpd.apache.org/docs-2.1/en/programs/ab.html">ab</ulink>
&mdash; outil d'évaluation d'un serveur HTTP Apache

</para></listitem>

</orderedlist>

</appendix>

<appendix>

<title>Solutions matérielles basées sur le chiffrement SSL</title>

<para>

Des solutions de chiffrement SSL matérielles sont présentées
ci-dessous&nbsp;:

</para>

<orderedlist numeration="lowerroman">

<listitem><para>

<ulink url="http://www.ncipher.com/international/fr/">CHIL
(Cryptographic Hardware Interface Library)</ulink> fabriqué par nCipher

</para></listitem>

<listitem><para>

<ulink
url="http://httpd.apache.org/docs-2.1/en/programs/ab.html">ab</ulink>
&mdash; outil d'évaluation d'un serveur HTTP Apache

</para></listitem>

</orderedlist>

</appendix>

<appendix>

<title>Autorités de certification</title>

<para>

La liste qui suit présente des autorités de certification acceptées par
les différents navigateurs&nbsp;:

</para>

<orderedlist numeration="lowerroman">

<listitem><para>

<ulink url="http://www.baltimore.com/">Baltimore</ulink>

</para></listitem>

<listitem><para>

<ulink url="http://www.entrust.com/">Entrust</ulink>

</para></listitem>

<listitem><para>

<ulink url="http://www.globalsign.net/">GeoTrust</ulink>

</para></listitem>

<listitem><para>

<ulink url="http://www.thawte.com">Thawte</ulink>

</para></listitem>

<listitem><para>

<ulink url="http://www.trustcenter.de/">TrustCenter</ulink>

</para></listitem>

</orderedlist>

</appendix>

<glossary id="glossary">

<title>Glossaire de termes PKI</title>

<glossdiv><title>A</title>

<glossentry id="asymmetric_crypt">
<glossterm>

Asymmetric Cryptography&nbsp;: Chiffrement asymétrique

</glossterm>
<glossdef><para>

Une paire de clés publiques et privées est utilisée dans ce type de
chiffrement. La clé privée est secrète et la clé publique est
distribuée à volonté.

</para></glossdef>

</glossentry>

</glossdiv>

<glossdiv>
<title>C</title>

<glossentry id="certificate">
<glossterm>

Certificat

</glossterm>
<glossdef><para>

Enregistrement contenant des informations conformes au format <link
linkend="InstallingServerCert"> format X.509.</link>.

</para></glossdef>
</glossentry>

<glossentry id="ca">

<glossterm>

Certificate Authority (CA)&nbsp;: Autorité de Certification

</glossterm>
<acronym>CA</acronym>

<glossdef><para>

Émetteur d'un certificat numérique. De plus, il valide l'identité de
l'entité finale propriétaire du certificat numérique.

</para></glossdef>
</glossentry>

<glossentry id="csr">
<glossterm>

Certificate Signing Request (CSR)&nbsp;: demande de signature de
certificat

</glossterm>
<acronym>CSR</acronym>

<glossdef><para>

Une demande de signature de certificat est ce que vous envoyez à une
autorité de certification (CA) pour vous inscrire. Une CSR contient la
clé publique de l'entité finale effectuant la demande de certificat
numérique.

</para></glossdef>

</glossentry>

<glossentry id="cn">

<glossterm>

Common Name (CN)&nbsp;: Nom Commun

</glossterm>
<acronym>CN</acronym>

<glossdef><para>

Le Common Name est le nom de l'entité finale c.-à-d. Saqib Ali. Si
l'entité finale est un serveur Web, le Common Name (CN) est le nom DNS
pleinement qualifié (FQDN) du serveur web.

</para></glossdef>
</glossentry>

</glossdiv>

<glossdiv>

<title>D</title>

<glossentry id="digitcert">

<glossterm>

Certificat numérique

</glossterm>
<glossdef><para>

Certificat qui relie une clé publique à un sujet (entité finale). Ce
certificat contient également d'autres informations (définies dans le
<link linkend="InstallingServerCert"> format X.509) sur le sujet.</link>
Il est signé par l'autorité de certification, à l'aide de la clé privée
de l'autorité de certification, c'est-à-dire à l'aide d'un <link
linkend="viewingdigitcertcontent"> certificat numérique</link>

</para></glossdef>

</glossentry>

<glossentry id="digitsign">

<glossterm>

Digital Signature&nbsp;: signature numérique

</glossterm>

<glossdef><para>

On crée une signature numérique en signant la somme du message (hachage
du message) à l'aide de la clé privée. Elle garantit l'identité de
l'émetteur et l'intégrité des données.

</para></glossdef>

</glossentry>

</glossdiv>

<glossdiv>
<title>E</title>

<glossentry id="end_entity">

<glossterm>

Entité finale

</glossterm>

<glossdef><para>

Entité protagoniste dans la PKI (infrastructure de clé publique). Il
s'agit normalement d'un serveur, d'un service ou d'une personne. Une
autorité de certification n'est pas une entité finale. Pour une autorité
de certification, l'auteur de la demande est une entité finale.

</para></glossdef>

</glossentry>

</glossdiv>

<glossdiv>

<title>H</title>

<glossentry id="hash">

<glossterm>

Hash: hachage

</glossterm>

<glossdef><para>

Un hachage est un nombre hexadécimal généré à partir d'une chaîne de texte,
de telle façon que deux chaînes différentes ne puissent produire le même
hachage.

</para></glossdef>

</glossentry>

<glossentry id="hmac">

<glossterm>

HMAC&nbsp;: (<foreignphrase>Keyed Hashing for Message
Authentication</foreignphrase>)&nbsp;: clé de hachage pour
l'authentification d'un message

</glossterm>
<acronym>HMAC</acronym>

<glossdef><para>

HMAC est une mise en &oelig;uvre de l'algorithme <quote>code
d'authentification de messages</quote> MAC.

</para></glossdef>

</glossentry>

</glossdiv>

<glossdiv>

<title>M</title>

<glossentry id="mac">
<glossterm>

Message Authentication Code&nbsp;: code d'authentification de messages

</glossterm>

<acronym>MAC</acronym>

<glossdef><para>

Analogue à une sommation de message (hachage/empreintes digitales), à ceci
près qu'on utilise la clé secrète partagée pour calculer le hachage. Étant
donné qu'une clé secrète partagée est utilisée, aucun attaquant ne peut
changer la somme du message. Cependant, une clé secrète partagée doit
tout d'abord être communiquée aux entités participantes, contrairement à
une signature numérique pour laquelle une somme de messages est signée à
l'aide de la clé privée. HMAC est un exemple d'un algorithme de code
d'authentification de messages.

</para></glossdef>


</glossentry>

<glossentry id="md5">

<glossterm>

Message Digest 5 &mdash; MD5&nbsp;: sommation de messages 5 &mdash; 
somme MD5

</glossterm>

<acronym>MD5</acronym>

<glossdef><para>

Message Digest 5 (MD5) est un ensemble de fonctions de hachage
unidirectionnelles à 128 bits

</para></glossdef>

</glossentry>

</glossdiv>

<glossdiv>

<title>P</title>

<glossentry id="private_key">

<glossterm>

Private Key&nbsp;: clé privée

</glossterm>

<glossdef><para>

En chiffrement asymétrique, la clé privée est celle qui est tenue
secrète par le propriétaire (entité finale). Elle peut être utilisée
pour le chiffrement ou le déchiffrement.

</para></glossdef>

</glossentry>

<glossentry id="public_key">

<glossterm>

Public Key&nbsp;: clé publique

</glossterm>

<glossdef><para>

En chiffrement asymétrique, la clé publique est celle qui distribuée
librement. Elle peut être utilisée pour le chiffrement ou le
déchiffrement.

</para></glossdef>

</glossentry>

<glossentry id="pki">

<glossterm>

Public Key Infrastructure (PKI)&nbsp;: infrastructure de clé
publique

</glossterm>

<acronym>PKI</acronym>

<glossdef><para>

Infrastructure de clé publique

</para></glossdef>

</glossentry>
</glossdiv>

<glossdiv>
<title>S</title>

<glossentry id="sha1">

<glossterm>

SHA-1 (Secure Hash Algorithm) algorithme de hachage sécurisé

</glossterm>

<acronym>MD5</acronym>

<glossdef><para>

Secure Hash Algorithm (SHA-1) est une fonction de hachage unidirectionnelle
à 160 bits. La taille maximum d'un message est de 2^64 bits.

</para></glossdef>

</glossentry>

<glossentry id="sslayer">

<glossterm>

Secure Socket Layer (SSL)

</glossterm>

<acronym>SSL</acronym>

<glossdef><para>

Secure Socket Layer (SSL) est un protocole de sécurité qui fournit des
services d'authentification (certificats numériques), de confidentialité
(chiffrement) et d'intégrité des données (sommation de messages &mdash; 
MD5, SHA, et cætera).

</para></glossdef>

</glossentry>

<glossentry id="symmetric_crypt">

<glossterm>

Chiffrement symétrique

</glossterm>

<glossdef><para>

Dans ce type de chiffrement, le message est chiffré et déchiffré par la
même clé. (((n^2-n))/2) clés sont nécessaires pour n utilisateurs
désirant utiliser ce système de chiffrement.

</para>
</glossdef>
</glossentry>
</glossdiv>
</glossary>
</article>

