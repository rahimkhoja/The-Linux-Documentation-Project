<!doctype linuxdoc system>

<article>

<title>HOWTO Comment migrer de VMS à Linux

<author>
Auteur~: <htmlurl url="mailto:guido@ibogeo.df.unibo.it" name="Guido Gonzato">
et <htmlurl url="mailto:miller5@uiuc.edu" name="Mike Miller"><newline>
Traducteur~:
<htmlurl url="mailto:dimitri.ara@wanadoo.fr" name="Dimitri Ara"><newline> 
</author>

<date>v1.1.3, 17 Septembre 1999

<abstract>

Ce HOWTO est destiné à toutes les personnes qui utilisent VMS et qui ont
maintenant besoin ou envie de passer à Linux, le clone libre d'Unix.
Nous effectuerons la transition --- je l'espère, sans douleur --- en
comparant les commandes et les outils disponibles sur ces
deux systèmes. 

</abstract>

<toc>

<sect> Introduction<label id="Introduction">

<sect1> Pourquoi Linux~?

<p>

Vous avez entendu dire qu'Unix est difficile et vous êtes hésitant à la
perspective d'abandonner VMS~?
Pas de panique. Linux, l'un des meilleurs clones d'Unix, n'est pas plus
difficile à utiliser que VMS. En fait, je le trouve même plus facile.
D'ailleurs, la plupart des gens trouve Linux beaucoup plus puissant et
versatile que VMS (évidemment les aficionados de VMS ne sont pas de cet avis).

Linux et VMS sont tous les deux de bons systèmes d'exploitation et
accomplissent essentiellement les mêmes taches. Cependant, les outils de
Linux sont à mon humble avis supérieurs. Leur syntaxe est souvent plus concise
et ils ont souvent les quelques fonctionnalités de plus qui font la différence
et  
permettent de gagner du temps (vous entendrez souvent que VMS et Unix ont
des philosophies différentes). De plus, Linux est disponible sur les
PC alors que ce n'est pas le cas de VMS (les derniers PC étant d'ailleurs
plus puissants que les VAX). Et, cerise sur le
gâteau, les excellentes performances des nouvelles cartes graphiques
transforment votre tite boîte Linux, grâce à X, en une puissante station
de travail graphique bien souvent plus rapide
qu'une machine spécialement prévue pour cette tâche.

J'ai plusieurs raisons de croire que la combinaison Pentium/Linux est
préférable à celle de VAX/VMS, mais ces préférences sont strictement
personnelles et vous ne serez peut-être pas d'accord. Vous en déciderez
de vous-même dans quelques mois.

Je prends en hypothèse que vous êtes une étudiant ou un chercheur à
l'université et que vous utilisez régulièrement VMS pour les tâches suivantes~:

<itemize>
<item> écrire des papiers avec TeX/LaTeX~;
<item> programmer en Fortran~;
<item> faire des graphiques~;
<item> utiliser Internet~;
<item> etc.
</itemize>

Dans la section suivante je vais vous expliquer comment faire ces tâches
sous Linux en utilisant votre expérience de VMS. Mais avant tout vérifiez que~:

<itemize>
<item> Linux et le <it/Système X Window/ sont correctement installés~;
<item> vous avez un administrateur système pour s'occuper des détails
techniques (s'il-vous-plaît, demandez de l'aide à eux, pas à moi :-)~;
<item> votre <it/shell/ --- l'équivalent de <tt/DCL/ --- est <tt/bash/ 
(demandez à votre administrateur). 
</itemize>

Notez que ce HOWTO n'est pas suffisant pour faire de vous un linuxien
pur et dur~: il contient seulement le strict
nécessaire pour vous permettre de commencer. Vous devriez
en apprendre plus sur Linux pour pouvoir en tirer le maximum (fonctionnalités
avancées de <tt/bash/, programmation, expressions régulières, etc.).

Les documents du <it/Linux Documentation Project/ (projet de documentation de
Linux), disponibles sur
<htmlurl url="ftp://metalab.unc.edu:/pub/Linux/docs/LDP"
name="metalab.unc.edu:/pub/Linux/docs/LDP">, sont une importante 
source d'informations. 

NDT~: je vous suggère également de lire le <it/Guide du rootard/ d'Éric Dumas
et plus généralement tout ce que l'on peut trouver sur
<tt><htmlurl url="http://www.freenix.fr/linux"
name="http://www.freenix.fr/linux"></tt> et
<tt><htmlurl url="http://www.traduc.org" name="http://www.traduc.org"></tt>.

Et maintenant, c'est parti~!

<sect1> Commandes et fichiers comparables

<p>

Ce tableau compare les commandes les plus utilisées sous VMS et Linux.
Gardez à l'esprit que leur syntaxe est souvent très différente~; pour
plus de détails allez faire un tour dans les sections suivantes.

<tscreen><verb>
VMS                           Linux                   Notes
-------------------------------------------------------------------------------
@COMMAND                      command                    (doit être exécutable)
COPY fichier1 fichier2        cp fichier1 fichier2
CREATE/DIR [.répertoire]      mkdir répertoire           (seulement un par un)
CREATE/DIR [.rép1.rép2]       mkdirhier rép/rép
DELETE fichier                rm fichier
DIFF fichier1 fichier2        diff -c fichier1 fichier2
DIRECTORY                     ls
DIRECTORY [...]fichier	      find . -name fichier
DIRECTORY/FULL                ls -al
EDIT fichier                  vi fichier,            (vous n'allez pas l'aimer)
                              emacs fichier,                   (compatible EDT)
                              jed fichier                (idem --- mon préféré)
FORTRAN prog.for              g77 prog.f,        (pas besoin de lier avec LINK)
                              f77 prog.f,
                              fort77 prog.f
HELP commande                 man commande     (la commande doit être précisée)
                              info commande
LATEX fichier.tex             latex fichier.tex
LOGIN.COM                     .bash_profile,                    (fichier caché)
                              .bashrc                                    (idem)
LOGOUT.COM                    .bash_logout                               (idem)
MAIL                          mail,                                (un peu cru)
                              elm,                             (beaucoup mieux)
                              pine                            (encore meilleur)
PRINT fichier.ps              lpr fichier.ps
PRINT/QUEUE=laser fichier.ps  lpr -Plaser fichier.ps
PHONE utilisateur             talk utilisateur
RENAME fichier1 fichier2      mv fichier1 fichier2      (ne marche pas avec des
                                                            fichiers multiples)
RUN progname                  programme
SEARCH fichier "motif"        grep motif fichier
SET DEFAULT [-]               cd ..
SET DEFAULT [.rép.rép]        cd rép/rép
SET HOST machine              telnet machine,            (pas exactement pareil)
                              rlogin machine 
SET FILE/OWNER_UIC=paul       chown paul fichier        (complètement différent)
SET NOBROADCAST               mesg
SET PASSWORD                  passwd
SET PROT=(perm) fichier       chmod perm fichier       (complètement différent)
SET TERMINAL                  export TERM=          (la syntaxe est différente)
SHOW DEFAULT                  pwd
SHOW DEVICE                   du, df
SHOW ENTRY                    lpq
SHOW PROCESS                  ps -ax
SHOW QUEUE                    lpq
SHOW SYSTEM                   top
SHOW TIME                     date
SHOW USERS                    w
STOP                          kill
STOP/QUEUE                    kill,                        (pour les processus)
                              lprm                   (pour supprimer un travail
                                                       de la file d'impression)
SUBMIT commande               commande &
SUBMIT/AFTER=durée commande   at durée commande
TEX fichier.tex               tex fichier.tex
TYPE/PAGE fichier             more fichier
                              less fichier                     (beaucoup mieux)

</verb></tscreen>

Bien sûr, les différences des deux systèmes ne se limitent pas aux noms des
commandes. Continuez donc à lire.

<sect> Petite introduction<label id="Petite introduction">

<p>

Voila ce que vous devez absolument savoir avant de vous loguer pour la première
fois. Détendez-vous, il y a relativement peu de chose.

<sect1> Fichiers

<p>

<itemize>

<item> Les noms des fichiers sous VMS on la forme
<tt/fichier.extension.version/. 
Sous Linux, le numéro de version n'existe pas (c'est une grosse limitation mais
on peut la compenser par d'astucieux moyens~: jetez un oeil à la section <ref
id="Numeros de version sous Linux" name="Numéros de version sous Linux">)~;
les noms des fichiers sont normalement limités à 255 caractères et peuvent
contenir autant de points que vous le désirez. Par exemple,
<tt/C_est.un.FICHIER.txt/ est un nom de fichier valide.

<item> Linux fait la distinction entre les majuscules et les minuscules. Ainsi,
<tt/FICHIER.txt/ et <tt/fichier.txt/ sont deux fichiers 
différents et <tt/ls/ est une commande alors que <tt/LS/ n'en est pas une.

<item> Un fichier dont le nom commence par un point est un fichier caché (ce
qui veut dire qu'il ne sera normalement pas affiché quand on listera les
fichiers du répertoire) alors qu'un fichier dont le nom finit par un tilde
(« <tt/&tilde/ ») représente une sauvegarde de fichier (ou
<it/backup/).

</itemize>

Maintenant, voici un tableau présentant les correspondances entre les commandes
de VMS et celle de Linux en ce qui concerne la gestion des fichiers.

<tscreen><verb>

VMS					Linux
---------------------------------------------------------------------

$ COPY fichier1.txt; fichier2.txt;      $ cp fichier1.txt fichier2.txt
$ COPY [.rép]fichier.txt;1 []           $ cp rép/fichier.txt .
$ COPY [.rép]fichier.txt;1 [-]          $ cp rép/fichier.txt ..
$ DELETE *.dat.*                        $ rm *dat
$ DIFF fichier1 fichier2                $ diff -c fichier1 fichier2
$ PRINT fichier                         $ lpr fichier
$ PRINT/queue=imprimante fichier        $ lpr -Pimprimante fichier
$ SEARCH *.tex.* "géologie"             $ grep géologie *tex
</verb></tscreen>

Regardez en plus loin dans le document pour avoir d'autres exemples.
Si vous voulez vous attaquer aux notions
de droits, de propriétaires et aux sujets avancés,
reportez vous à la section <ref id="Sujets avances" name="Sujets avancés">.

<sect1> Répertoires

<p>

<itemize> 

<item> Les noms des répertoires sous VMS sont de la forme
<tt/[père.rép.sousrép]/. L'équivalent sous Linux est~:
<tt>/père/rép/sousrép/</tt>. 
Le père de tous les répertoires est le répertoire racine appelé <tt>/</>~; il
contient d'autres répertoires comme <tt>/bin</>, <tt>/usr</tt>, <tt>/tmp</tt>,
<tt>/etc</tt>, et bien d'autres.

<item> Le répertoire <tt>/home</> contient les répertoires <it/home/ (NDT~:
« home » signifie « maison ») des
utilisateurs~: par exemple, <tt>/home/pierre</>, <tt>/home/paul</tt> et ainsi
de suite. Quand un utilisateur se logue, il commence dans son répertoire
<it/home/~;  c'est l'équivalent de <tt/SYS&dollar;LOGIN/. Il y a un raccourci
pour le 
répertoire <it/home/~: le tilde (« <tt/&tilde/ »). Ainsi, <tt>cd
&tilde;/tmp</> est équivalent à, disons, <tt>cd /home/paul/tmp</tt>.

<item> Les noms des répertoires sont soumis aux mêmes règles que ceux des
fichiers. En 
plus de cela, chaque répertoire a deux entrées spéciales~: l'une est <tt/./~:
elle représente le répertoire lui-même (comme <tt/[]/)~; l'autre, <tt/../,
représente le répertoire parent (comme <tt/[-]/).

</itemize>

Et maintenant quelques autres exemples~:

<tscreen><verb>

VMS                                     Linux
---------------------------------------------------------------------

$ CREATE/DIR [.répertoire]              $ mkdir répertoire
$ CREATE/DIR [.dir1.dir2.dir3]          $ mkdirhier rép1/rép2/rép3
   non/disponible                       $ rmdir répertoire
                                        (si le répertoire est vide)
                                        $ rm -R répertoire
$ DIRECTORY                             $ ls
$ DIRECTORY [...]fichier.*.*            $ find . -name "fichier*"
$ SET DEF SYS$LOGIN                     $ cd
$ SET DEF [-]                           $ cd ..
$ SET DEF [père.rép.sousrép]            $ cd /père/rép/sousrép
$ SET DEF [.rép.sousrép]                $ cd rép/sousrép
$ SHOW DEF                              $ pwd

</verb></tscreen>

Si vous voulez en savoir plus sur les
droits, les propriétaires, ou tout simplement en savoir plus tout court,
sautez à la section <ref id="Sujets avances" name="Sujets avancés">.

<sect1> Programmes

<p>

<itemize> 

<item> Les commandes, les programmes compilés et les scripts <it/shell/
(équivalent 
des fichiers de commandes de VMS) n'ont pas forcément une extension comme
<tt/.EXE/ or <tt/.COM/ et peuvent s'appeler comme bon vous semble. Les
fichiers exécutables sont marqués d'un astérisque (« <tt/*/ &raquo)
lorsque 
vous exécutez <tt/ls -F/.

<item> Pour lancer un fichier exécutable, il suffit de taper son nom (pas de
<tt/RUN/, ni de <tt/PROGRAM.EXE/, ni encore de <tt/@COMMAND/). Il est donc
nécessaire que le fichier soit situé dans un répertoire du <it/path/, qui est
une liste de répertoires. En général, le <it/path/ contient des répertoires
comme 
<tt>/bin</>, <tt>/usr/bin</>, <tt>/usr/X11R6/bin</>, etc. Si vous
écrivez vos propres programmes, placez-les dans un répertoire de votre
<it/path/ (pour savoir comment, reportez-vous à la section <ref id="Configurer"
name="Configurer">). Vous pouvez aussi lancer un programme en indiquant son
chemin complet, par exemple <tt>/home/paul/données/monprog</> ou
<tt>./monprog</> si le répertoire courant n'est pas dans le <it/path/.

<item> Les options des commandes sont passées sur la ligne de commande grâce à
<tt>OPTION=</> sous VMS et grâce à <tt/-/<it/une_option/ ou
<tt/--/<it/une_option/ sous Linux, <it/une_option/ étant une lettre, 
différentes lettres combinées ou un 
mot. En particulier, l'option <tt/-R/ (récursif) de plusieurs commandes de
Linux permet de faire la même chose que le <tt/[...]/ de VMS.

<item> Vous pouvez lancer plusieurs commandes sur la ligne de commande~:

<tscreen><verb>
$ commande1 ; commande2 ; ... ; commande
</verb></tscreen>

<item> Toute la flexibilité de Linux repose sur deux fonctionnalités (l'une
n'existe pas sous VMS, l'autre est mal implémentée)~:
la redirection des entrés/sorties et les
<it/pipes/. (Pour être sincère, j'ai entendu que les versions récentes de IDL
supportent la redirection et les <it/pipes/ mais je n'ai pas ces versions.) La
redirection sous VMS n'est qu'un effet de bord (souvenez vous de l'option
<tt>/OUTPUT=</tt>) ou une tâche fastidieuse comme

<tscreen><verb>
$ DEFINE /USER SYS$OUTPUT OUT 
$ DEFINE /USER SYS$INPUT IN
$ RUN PROG
</verb></tscreen>

dont l'équivalent sous Linux (Unix) est simplement~:

<tscreen><verb>
$ prog < in > out
</verb></tscreen>

Utiliser des <it/pipes/ est tout simplement impossible sous VMS mais ils jouent
un rôle clé sous Unix. En voici un exemple typique~:

<tscreen><verb>
$ monprog < données | filtre1 | filtre2 >> résultat.dat 2> erreurs.log &
</verb></tscreen>

Traduisons. Le programme <tt/monprog/ utilise le fichier <tt/données/ comme
entrée, sa sortie est canalisée (grâce à <tt/&verbar;/) vers le programme
<tt/filtre1/ qui l'utilise en tant qu'entrée et la traite. La sortie résultante
est canalisée (<it/pipée/) vers <tt/filtre2/ pour être encore une fois traitée.
La sortie finale 
est ajoutée (grâce à <tt/>>/) au fichier <tt/résultat.dat/, et les
messages d'erreurs sont redirigés (grâce à <tt/2>/) vers le fichier
<tt/errors.log/.
Tout ceci est exécuté en arrière-plan (grâce au <tt/&amp;/ à la fin de la ligne
de commande). Pour en savoir plus à ce sujet, reportez-vous à la section
<ref id="Exemples" name="Exemples">.

</itemize> 

Pour le multitâche, les files, et tout ce qui s'y rapporte, reportez-vous à la
section <ref id="Sujets avances" name="Sujets avancés">.

<sect1> Visite guidée<label id="Visite guidee">

<p>

Maintenant vous êtes prêt pour essayer Linux. Entrez votre identifiant et
votre mot de passe. Attention, Unix distingue les minuscules des majuscules. Ainsi,
si votre login et votre mot de passe 
sont <tt/pierre/ et <tt/Mon_Code/, ne tapez <it/pas/ <tt/Pierre/ ou
<tt/mon_code/.

Une fois que vous êtes logué, le prompt s'affiche. Il y a des chances
pour que se soit quelque chose du genre
<tt/nom_de_la_machine:&dollar;/. Si vous voulez le changer ou lancer
des programmes automatiquement, vous devrez éditer le fichier caché
<tt/.profile/ ou <tt/.bash_profile/ (jetez un oeil aux
exemples dans la section <ref
id="Configurer" name="Configurer">). C'est l'équivalent de
<tt/LOGIN.COM/.

Appuyer sur <sf/alt~+~F1/, <sf/alt~+~F2/, ..., <sf/alt~+~F6/ permet de changer
de console 
virtuelle. Quand une console virtuelle est occupée avec une application
plein écran, vous pouvez changer de console et continuer à travailler.
Essayez et loguez-vous sur une autre console virtuelle.

Maintenant, vous voulez peut-être lancer le <it/Système X Window/ (que nous
appellerons maintenant X). X est un environnement graphique similaire
au DECWindows --- en fait, ce dernier dérive de X. Tapez la commande
<tt/startx/ et attendez quelques secondes~; vous verrez probablement
s'ouvrir un <tt/xterm/ ou un autre émulateur de terminal, et peut-être
une barre de boutons (cela dépend de la manière dont votre
administrateur système a configuré votre machine Linux). Cliquez sur le
menu (essayez les deux boutons de la souris) pour voir les menus.

Quand vous utilisez X, vous devez appuyez sur <sf/ctrl~+~alt~+~F1/, ..., 
<sf/ctrl~+~alt~+~F6/ pour accéder au mode texte (console). Essayez. Quand 
vous êtes dans une console, vous pouvez revenir à X en appuyant sur
<sf/alt~+~F7/. Pour quitter X, suivez les instructions de votre menu ou 
appuyez sur <sf/ctrl~+~alt~+~backspace/.

Tapez la commande suivante pour obtenir une liste du contenu du
répertoire courant (incluant les fichiers cachés)~:

<tscreen><verb>
$ ls -al
</verb></tscreen>

Appuyez sur <sf/shift~+~page up/ pour faire défiler l'écran vers le haut.
Maintenant, pour obtenir de l'aide sur la commande <tt/ls/ tapez

<tscreen><verb>
$ man ls
</verb></tscreen>

Appuyez sur <tt/q/ pour quitter. Pour finir notre tour
d'horizon, tapez <tt/exit/ pour quitter votre session. Si maintenant
vous voulez éteindre votre PC, appuyez sur <sf/ctrl~+~alt~+~suppr/ et attendez
quelques secondes (n'éteignez <it/jamais/ votre PC tant que Linux
tourne~; cela peut causer des dommages dans le système de fichier).

Si vous pensez que vous êtes prêt pour travailler, allez-y. Mais si
j'étais vous, je passerais d'abord par la section <ref id="Sujets avances"
name="Sujets avancés">.

<sect> Éditer des fichiers<label id="Editer des fichiers">

<p>

<tt/EDT/ ne tourne pas sous Linux, mais il y a beaucoup d'autres éditeurs
disponibles. Le seul qui soit sûr d'être présent sur tout système Unix
est <tt/vi/ --- oubliez-le, votre administrateur en a sûrement 
installé un meilleur. L'éditeur le plus populaire est probablement
<tt/emacs/, qui peut émuler <tt/EDT/ jusqu'à un certain degré~;
<tt/jed/ est un autre éditeur qui permet l'émulation de <tt/EDT/.

Ces deux éditeurs sont particulièrement utiles pour éditer des
sources de programmes puisque qu'ils ont deux fonctionnalités
inconnue de <tt/EDT/~: la coloration syntaxique et l'indentation
automatique. De plus, vous pouvez compilez vos programmes à partir de
l'éditeur (grâce à <sf/M-x compile/ sous emacs --- pour comprendre la 
notation «~M-x compile~» lisez la suite~; en cas
d'erreur de  syntaxe, le curseur se positionnera tout seul sur la ligne en
question. Je parie que vous ne voudrez plus jamais utiliser <tt/EDT/ après.

Si vous avez <tt/emacs/, lancez-le. Tout d'abord vous devez comprendre le
système de notation de combinaison de touche d'<tt/emacs/. <sf/C/ désigne
contrôle et <sf/M/ la touche méta (en général <sf/alt/ ou <sf/échap/).
Maintenant, tapez  
<sf/M-x edt-emultation-on/. <sf/M-x/ permet de lancer des commandes avec
<tt/emacs/ comme <sf/ctrl~+~z/ avec <tt/EDT/. À partir de maintenant,
<tt/emacs/ fait 
comme s'il était <tt/EDT/ à part pour quelques commandes~:
 
<itemize>

<item> n'appuyez <it/pas/ sur <sf/ctrl~+~z/ pour lancer une commande. Si vous
l'avez fait, vous avez stoppé emacs. Tapez <tt/fg/ pour reprendre
votre session emacs~;

<item> appuyez sur <sf/C-h~?/ pour obtenir de l'aide ou sur <sf/C-h~t/
pour lancer un tutoriel~;

<item> pour sauver un fichier, appuyez sur <sf/C-x~C-s/~;

<item> pour quittez, appuyez sur <sf/C-x~C-c/~;

<item> pour insérez un nouveau fichier dans un buffer (pour ouvrir un
fichier, en gros), appuyez sur <sf/C-x~C-f/, et ensuite <sf/C-x~b/ pour
changer de buffer.

</itemize>

Si vous avez <tt/jed/, demandez à votre administrateur de le
configurer comme il faut. L'émulation est active dès que vous le
lancez. Utilisez les même touches que sur <tt/EDT/ et appuyez sur
<sf/échap~?~h/ pour obtenir l'aide. Les commandes
sont lancées de la même manière que dans <tt/emacs/. De plus, il y a quelques
raccourcis pratiques faisant défaut à <tt/EDT/~; vous pouvez en plus
configurer ces raccourcis clavier. Demandez à votre administrateur.

Vous pouvez aussi utilisez un autre éditeur avec une interface
complètement différente. <tt/emacs/ en mode natif est un choix
courant. Un autre éditeur populaire est <tt/joe/ qui peut émuler
d'autres éditeurs comme emacs lui-même (en étant même plus facile à
utiliser) ou l'éditeur DOS. Lancez l'éditeur sous le nom <tt/jmacs/ ou
<tt/jstar/ et appuyez respectivement sur <sf/ctrl~+~x h/ ou <sf/ctrl~+~j/ pour
obtenir l'aide en ligne. <tt/emacs/ et <tt/jed/ sont <it/beaucoup/
plus puissants que ce bon vieux <tt/EDT/.

<sect> TeXer <label id="TeXer">

<p>

TeX et LaTeX sont identiques à leurs homologues de VMS --- seulement plus
rapides~:-), mais les outils pour manipuler les fichiers <tt/.dvi/ et~<tt/.ps/
sont bien supérieurs~: 

<itemize>

<item> Pour compiler un fichier TeX faites comme d'habitude <tt/tex file.tex/.

<item> Pour convertir un fichier <tt/.dvi/ en~<tt/.ps/, tapez <tt/dvips -o
fichier.ps fichier.dvi/.

<item> Pour visualiser un fichier <tt/.dvi/, tapez lors d'une session X
<tt/xdvi 
fichier.dvi &amp;/. Cliquez sur la page pour zoomer. Ce programme est
intelligent~: si vous éditez et lancez TeX pour produire une nouvelle version
de votre fichier <tt/.dvi/, <tt/xdvi/ actualisera l'affichage.

<item> Pour visualiser un fichier <tt/.ps/, taper lors d'une session X
<tt/ghostview fichier.ps &amp;/. Cliquez sur la page pour zoomer. Le document
entier ou des pages sélectionnés peuvent être imprimés. Un programme plus
récent et meilleur permet également de faire ça~: <tt/gv/~;

<item> Pour imprimer un fichier~<tt/.ps/ on utilise généralement la commande
<tt/lpr fichier.ps/. Cependant si l'imprimante postscript s'appelle, par
exemple, « ps » (demandez à votre administrateur système), il
faudra faire <tt/lrp -Pps fichier.ps/. Pour plus d'informations au sujet des
files d'impressions, allez à la section <ref id="Files d'impressions" 
name="Files d'impressions">.

</itemize>

<sect> Programmer<label id="Programmer">

<p>

Programmer sous Linux est <it/beaucoup/ plus agréable~: il existe un grand
nombre d'outils qui rendent la programmation plus facile et plus rapide. Par
exemple, la torture qu'est le cycle édition, sauvegarde, sortie de l'éditeur,
compilation, réédition, etc. peut être raccourci en utilisant des éditeurs
comme <tt/emacs/ ou <tt/jed/, comme nous l'avons vu au dessus.

<sect1> Fortran

<p>

Il n'y a pas de réelle différence pour le fortran, mais sachez qu'au
moment où j'écris ces lignes, les compilateurs (libres) ne sont pas
totalement compatibles avec ceux de VMS~; attendez-vous à quelques problèmes
mineurs (en fait, le compilateur de VMS utilise des extensions qui ne sont pas
standard). Jetez un oeil à <tt>/usr/doc/g77/DOC</> ou
<tt>/usr/doc/f2c/d2c.ps</> pour plus de détails.

Votre administrateur a sans doute installé soit le compilateur natif <tt/g77/
(bien, mais, au jour de la version 0.5.21, toujours pas parfaitement compatible
avec le Fortran de DEC), soit le traducteur de Fortran en C, <tt/f2c/, et un
des ses front-ends qui font de lui une imitation de compilateur natif. D'après
mon expérience, le paquetage <tt/yaf77/ est celui qui donne les meilleurs
résultats.

Pour compiler un source en Fortran avec <tt/g77/, éditez le et sauvez le avec
l'extension <tt/.f/, et faites

<tscreen><verb>
$ g77 monprog.f
</verb></tscreen>

Cela va créer par défaut un exécutable appelé <tt/a.out/ (vous n'avez pas à
effectuer les liens). Pour donner à l'exécutable un nom différent et faire
quelques optimisations~:

<tscreen><verb>
$ g77 -O2 -o monprog monprog.f
</verb></tscreen>

Méfiez-vous des optimisations~! Demandez à votre administrateur système de lire
la documentation fournie avec le compilateur et de vous dire s'il y a des
problèmes. 

Pour compiler une sous-routine~:

<tscreen><verb>
$ g77 -c masub.f
</verb></tscreen>

Un fichier <tt/masub.o/ sera créé. Pour lier cette sous-routine à un
programme, vous devrez faire

<tscreen><verb>
$ g77 -o monprog monprog.f masub.o
</verb></tscreen>

Si vous avez plusieurs sous-routines externes et que vous voulez créer une
bibliothèque, faites

<tscreen><verb>
$ cd sousroutines/
$ cat *f > mabib.f ; g77 -c mabib.f
</verb></tscreen>

Le fichier <tt/mabib.o/ créé pourra alors être lié à vos programmes.

Pour finir, pour lier une bibliothèque externe appelée, disons,
<tt/liblambda.so/~, utilisez

<tscreen><verb>
$ g77 -o monprog monprog.f -llambda
</verb></tscreen>

Si vous avez <tt/f2c/, vous n'aurez qu'à utiliser <tt/f77/ ou <tt/fort77/
à la place de <tt/g77/.

Un autre outil de programmation utile est <tt/make/. Il est décrit ci-dessous.

<sect1> Utiliser <tt/make/

<p>

<tt/make/ est un outil pour gérer la compilation de programmes divisés en
plusieurs fichiers sources.

Supposons que vous ayez des fichiers sources contenant vos routines appelés
<tt/fichier_1.f, fichier_2.f et fichier_3.f/, et un fichier source 
principal qui utilise ces routines appelé <tt/monprog.f/. Si vous compilez
votre programme à la main, quand vous modifierez un fichier source vous allez
devoir chercher quel fichier dépend de quel fichier, et les recompiler en
tenant compte des dépendances.

Plutôt que de devenir fou, je vous propose d'écrire un <it/makefile/. C'est un
fichier texte qui contient les dépendances entre les 
sources~: quand un source est modifié, seuls les sources qui dépendent du
fichier modifié seront recompilées.

Dans notre cas, le <it/makefile/ ressemblerait à ceci~:

<code>

# Voici le Makefile
# Attention : appuyez sur la touche tabulation quand « &lt;TAB> »
# est écrit ! C'est très important : n'utilisez pas d'espace à la place.

monprog: monprog.o fichier_1.o fichier_2.o fichier_3.o
&lt;TAB>g77 -o monprog monprog.o fichier_1.o fichier_2.o fichier_3.o
# monprog dépend de quatre fichiers objets

monprog.o: monprog.f
&lt;TAB>g77 -c monprog.f
# monprog.o dépend de son fichier source

fichier_1.o: fichier_1.f
&lt;TAB>g77 -c fichier_1.f
# fichier_1.o dépend de son fichier source

fichier_2.o: fichier_2.f fichier_1.o
&lt;TAB>g77 -c fichier_2.f fichier_1.o
# fichier_2.o dépend de son fichier source et d'un fichier objet

fichier_3.o: fichier_3.f fichier_2.o
&lt;TAB>g77 -c fichier_3.f fichier_2.o
# fichier_3.o dépend de son fichier source et d'un fichier objet

# fin du Makefile
</code>

Enregistrez ce fichier sous le nom <tt/Makefile/ et tapez <tt/make/ pour
compiler votre
programme. Vous pouvez aussi l'appeler <tt/monprog.mak/ et taper <tt/make -f
monprog.mak/. Et bien sûr, si vous voulez en savoir plus~: <tt/info make/.

<sect1> Scripts <it/shell/

<p>

Les scripts <it/shell/ sont les équivalents des fichiers de commandes de VMS
et, pour changer, sont beaucoup plus puissants.

Pour écrire un script, tout ce que vous avez à faire est d'écrire un fichier au
format ASCII contenant les commandes, l'enregistrer et le rendre exécutable
(<tt/chmod +x fichier/). Pour le lancer, tapez son nom (précédé de <tt>./</>
s'il n'est pas dans le <it/path/).

Écrire des scripts avec <tt/bash/ est un sujet tellement vaste qu'il
nécessiterait un livre entier, et je ne ne vais pas m'attarder sur le
sujet. Je vais juste vous donner un exemple plus ou moins compréhensible et, je
l'espère, utile, à partir duquel vous pourrez comprendre quelques règles de
base. 

<code>
#!/bin/sh
# exemple.sh
# Je suis un commentaire.
# Ne modifiez pas la première ligne, elle doit être présente.
echo "Ce système est : `uname -a`" # utilise la sortie de la commande
echo "Mon nom est $0" # variable interne
echo "Vous m'avez donné les $# paramètres suivants : "$*
echo "Le premier paramètre est : "$1
echo -n "Quel est votre nom ? " ; read votre_name
echo remarquez la différence : "Salut $votre_name" # cité avec "
echo remarquez la différence : 'Salut $votre_name' # cité avec '
REPS=0 ; FICHIERS=0
for fichier in `ls .` ; do
  if [ -d ${fichier} ] ; then # si le fichier est un répertoire
    REPS=`expr $REPS + 1`  # REPS = REPS + 1
  elif [ -f ${fichier} ] ; then
    FICHIER=`expr $FICHIER + 1`
  fi
  case ${fichier} in
    *.gif|*jpg) echo "${fichier}: fichier graphique" ;;
    *.txt|*.tex) echo "${fichier}: fichier texte" ;;
    *.c|*.f|*.for) echo "${fichier}: fichier source" ;;
    *) echo "${fichier}: fichier quelconque" ;;
  esac
done
echo "Il y a ${REPS} répertoires et ${FICHIERS} fichiers"
ls | grep "ZxY--!!!WKW"
if [ $? != 0 ] ; then # valeur de sortie de la dernière commande
  echo "ZxY--!!!WKW n'a pas été trouvé"
fi
echo "Ça suffit... tapez 'man bash' si vous voulez plus d'informations."
echo "Note du traducteur : 'info bash' est plus complet."

</code>

<sect1> C <label id="C">

<p>

Linux est un excellent environnement pour la programmation en C. Si vous
connaissez le C, voici quelques conseils pour vous débrouiller sous Linux. Pour
compiler le célèbre <tt/hello.c/ vous utiliserez le compilateur <tt/gcc/, qui
est standard dans le monde de Linux et qui a la même syntaxe que <tt/g77/~:

<tscreen><verb>
$ gcc -O2 -o hello hello.c
</verb></tscreen>

Pour lier une bibliothèque à un programme, ajoutez l'option
<tt>-lbibliothèque</>.
Par exemple pour lier la bibliothèque math et optimiser faites

<tscreen><verb>
$ gcc -O2 -o mathprog mathprog.c -lm
</verb></tscreen>

(L'option <tt>-lbibliothèque</> force <tt/gcc/ à lier la bibliothèque
<tt>/usr/lib/libbibliothèque.a</>~; ainsi <tt/-lm/ lie <tt>/usr/lib/libm.a</>.)

Quand votre programme est divisé en plusieurs fichiers sources, vous aurez
besoin 
du programme <tt/make/ décrit juste au dessus.

Vous pouvez obtenir de l'aide sur quelques fonctions de la libc dans la
section~3 des pages man. Par exemple~:

<tscreen><verb>
$ man 3 printf
</verb></tscreen>

Il existe beaucoup de bibliothèques disponible. Parmi les premières que vous
voudrez 
probablement utiliser, il y a <tt/ncurses/, qui permet de gérer quelques effets
du mode texte et <tt/svgalib/ pour faire du graphisme.

<sect> Graphiques <label id="Graphiques">

<p>

Parmi la masse de paquetages de graphiques disponibles, <tt/gnuplot/ sort du
lot 
pour sa puissance et sa facilité d'utilisation. Créez tout d'abord deux
fichiers de données~: <tt/2D-data.dat/ (deux données par ligne) et
<tt/3D-data.dat/ (trois par ligne). Puis, sous X, lancez <tt/gnuplot/.

Exemple d'un graphe en 2D~:

<tscreen><verb>
gnuplot> set title "mon premier graphe"
gnuplot> plot '2D-data.dat'
gnuplot> plot '2D-data.dat' with linespoints
gnuplot> plot '2D-data.dat', sin(x)
gnuplot> plot [-5:10] '2D-data.dat'
</verb></tscreen>

Exemple d'un graphe en 3D (chaque « ligne » de <it/x/ valeurs est suivie
d'une ligne vide)~:

<tscreen><verb>
gnuplot> set parametric ; set hidden3d ; set contour
gnuplot> splot '3D-data.dat' using 1:2:3 with linespoints
</verb></tscreen>

Un fichier de données d'une seule colonne (une série de temps par exemple) peut
aussi être dessiné comme un graphe en 2D~:

<tscreen><verb>
gnuplot> plot [-5:15] '2D-data-1col.dat' with linespoints
</verb></tscreen>

ou en 3D (avec des lignes vides dans le fichier comme au dessus)~:

<tscreen><verb>
gnuplot> set noparametric ; set hidden3d
gnuplot> splot '3D-data-1col.dat' using 1 with linespoints
</verb></tscreen>

Pour imprimez un graphe, si la commande pour imprimer sur votre imprimante
postscript est <tt/lpr -Pps fichier.ps/, faites

<tscreen><verb>
gnuplot> set term post
gnuplot> set out '| lpr -Pps'
gnuplot> replot
</verb></tscreen>

Tapez ensuite <tt/set term x11/ pour réafficher sur votre serveur X. Ne soyez
pas déconcerté~: la dernière impression se lancera seulement quand vous
quitterez <tt/gnuplot/.

Pour plus d'informations, tapez <tt/help/ ou regardez le répertoire des exemples
(<tt>/usr/lib/gnuplot/demos/</>) s'il existe.

<sect> Mail et outils pour Internet<label id="Mail et Outils pour Internet">

<p>

Du fait qu'Internet est né sur des machines Unix, on trouve plein
d'applications 
de qualité et facile d'utilisation sous Linux. En voici quelques-unes~:

<itemize> 

<item> Mail~: utilisez <tt/elm/ ou <tt/pine/ (NDT~: mutt est très bien
aussi) pour gérer votre courrier. Ces deux programmes ont une aide en ligne.
Pour des messages courts, vous pouvez utilisez <tt/mail/ (<tt/mail
-s "Salut" utilisateur@quelquepart < msg.txt/). Vous préférez peut-être d'autres
programmes comme <tt/xmail/ ou équivalent.

<item> Newsgroups~: utilisez <tt/tin/ ou <tt/slrn/. Ils sont tous les deux
très intuitifs.

<item> FTP~: en plus de l'inévitable <tt/ftp/, demandez à votre
administrateur d'installer l'excellent <tt/ncftp/ ou un même un client
graphique comme <tt/xftp/.

<item> WWW~: <tt/netscape/, <tt/xmosaic/, <tt/chimera/ et <tt/arena/ sont
des browsers graphiques~; <tt/lynx/ quant à lui utilise la console et est
rapide et pratique.

</itemize>

<sect> Sujets avancés <label id="Sujets avances">

<p>

Là, le jeu devient coriace. Apprenez ça, et ensuite vous pourrez dire que
vous « connaissez quelque chose à Linux » ;-)

<sect1> Droits et propriété <label id="Droits et propriete">

<p>

Les fichiers et les répertoires ont des droits et des propriétaires, comme 
sous VMS. Si nous ne pouvez pas lancer un programme, ne pouvez pas modifier
un fichier ou ne pouvez pas accéder à un répertoire, c'est parce vous n'avez
pas les droits adéquats pour le faire et/ou parce que le fichier ne vous
appartient pas. Regardez l'exemple suivant~:

<tscreen><verb>
$ ls -l /bin/ls
-rwxr-xr-x   1 root     bin         27281 Aug 15  1995 /bin/ls*
</verb></tscreen>

Le premier champ indique les droits du fichier <tt/ls/. Il y a trois types de
propriété~: le propriétaire, le groupe et les autres (comme le
propriétaire, le groupe et le reste du monde sous VMS) et trois droits~:
lecture, écriture et exécution.

De gauche à droite, <tt/-/~est le type du fichier  (<tt/-/ désigne un fichier
ordinaire, 
<tt/d/ un répertoire, <tt/l/ un lien, etc.)~; <tt/rwx/~sont les droits du
propriétaire (lecture, écriture, exécution)~;  <tt/r-x/~sont les droits du
groupe du propriétaire (lecture, exécution)~; <tt/r-x/~sont les droits pour
tous les autres utilisateurs (lecture, écriture).

Pour changer les droits d'un fichier~:

<tscreen><verb>
$ chmod <quiXdroit> <fichier>
</verb></tscreen>

Avec <it/qui/ représentant <tt/u/ (ce sont alors les droits du propriétaire
qui sont affectés),~<tt/g/ (ceux du groupe) ou~<tt/o/ (ceux des « autres 
»). X est soit~<tt/+/ (dans ce cas il donne les droits), soit~<tt/-/ (il
les enlève). Et <it/droit/ est <tt/r/,~<tt/w/ ou~<tt/x/. Voici un exemple~:

<tscreen><verb>
$ chmod u+x fichier
</verb></tscreen>

Cela permet de rendre le fichier exécutable pour le propriétaire. Il existe un
petit raccourci <tt/chmod +x fichier/.

<tscreen><verb>
$ chmod go-wx fichier
</verb></tscreen>

Là, on enlève les droits d'écriture et d'exécution au groupe et aux autres
(donc à tout le monde sauf au propriétaire).

<tscreen><verb>
$ chmod ugo+rwx fichier
</verb></tscreen>

Tous les droits sont donnés à tout le monde.

Une manière plus courte de préciser les droits se base sur les nombres~:
<tt/rwxr-xr-x/ peut être exprimé par 755 (chaque lettre correspond à un bit~:
<tt/---/ vaut 0, <tt/--x/ 1, <tt/-w-/ 2, etc).

Pour un répertoire, <tt/rx/ signifie que vous pouvez vous placer dans ce
répertoire et <tt/w/ que vous pouvez effacer un fichier dans ce répertoire (en
tenant compte des droits du fichier évidemment) ou le répertoire lui-même. Tout
ça n'est qu'une petit partie du sujet~: man est votre ami.

Pour changer le propriétaire d'un fichier~:

<tscreen><verb>
$ chown <utilisateur> <fichier>
</verb></tscreen>

Pour résumer, voici un tableau~:

<tscreen><verb>
VMS				Linux		
------------------------------------------------------------------------------

SET PROT=(O:RW) fichier.txt     $ chmod u+rw fichier.txt
                                $ chmod 600 fichier.txt
SET PROT=(O:RWED,W) fichier     $ chmod u+rwx fichier
                                $ chmod 700 fichier
SET PROT=(O:RWED,W:RE) fichier	$ chmod 755 fichier
SET PROT=(O:RW,G:RW,W) fichier	$ chmod 660 fichier
SET FILE/OWNER_UIC=JOE fichier	$ chown joe fichier
SET DIR/OWNER_UIC=JOE [.dir]	$ chown joe rep/
</verb></tscreen>


<sect1> Multitâche~: processus et tâches (<it/jobs/) <label id="Multitache">

<p>

En voici plus à propos de la manière de lancer les programmes. Il n'y a pas de
file 
d'attente sous Linux~; le multitâche est géré très différemment. Voici à quoi
ressemble une ligne de commande typique~: 

<tscreen><verb>
$ commande -s1 -s2 ... -sn par1 par2 ... parn < entrée > sortie &
</verb></tscreen>

Maintenant, voyons comment marche le multitâche. Les programmes qui tournent en
avant-plan (<it/foreground/) ou arrière-plan (<it/background/) sont appelés des
processus. 

<itemize>

<item> Pour lancer un processus en arrière plan~:

<tscreen><verb>
$ programme [option] [< entrée] [> sortie] &
[1] 234
</verb></tscreen>

Le shell vous donne le numéro de <it/job/ (le premier nombre~; regardez
ci-dessus) et le PID (le numéro du processus). Chaque processus est identifié
par son PID.

Pour voir combien de processus sont lancés~:

<tscreen><verb>
$ ps -ax
</verb></tscreen>

La liste des processus actifs va être affichée.

<item> Pour tuer un processus~:

<tscreen><verb>
$ kill &lt;PID>
</verb></tscreen>

Vous aurez peut-être besoin de tuer un processus quand vous ne savez pas le
quitter de la bonne manière... ;-) Parfois, une processus sera seulement tué
par une des commandes suivantes~:

<tscreen><verb>
$ kill -15 <PID>
$ kill -9 <PID>
</verb></tscreen>

</itemize>

En plus de ça, le shell vous permet de stopper ou de suspendre temporairement
un processus, envoyer un processus en arrière-plan ou en ramener un en
avant-plan. Dans ce contexte, les processus sont appelées <tt/jobs/.

<itemize>

<item> Pour voir combien de <it/jobs/ sont actifs~:

<tscreen><verb>
$ jobs
</verb></tscreen>

Les <it/jobs/ sont identifés par le nombre que le shell leur donne et non pas
par leur PID.

<item> Pour stopper un processus qui tourne en avant-plan appuyez sur
<sf/ctrl~+~c/. (Ça ne marche pas toujours.)

<item> Pour suspendre un processus tournant en avant-plan appuyez sur
<sf/ctrl~+~z/ (Idem.)

<item> Pour envoyer un processus suspendu en arrière-plan (qui devient alors un
<it/job/)~: 

<tscreen><verb>
$ bg &lt;job>
</verb></tscreen>

<item> Pour envoyer un <it/job/ en avant-plan~:

<tscreen><verb>
$ fg &lt;job>
</verb></tscreen>

<item> Pour tuer un <it/job/~:

<tscreen><verb>
$ kill %&lt;job>
</verb></tscreen>

</itemize>

<sect1> Fichiers, deuxième

<p>

Voici plus d'information sur les fichiers.

<itemize>

<item> <it/stdin/, <it/stdout/ et <it/stderr/~: sous Unix, tous les composants
du système 
sont assimilés à des fichiers. Les commandes et les programmes
puisent leur entrée dans un « fichier » appelé <it/stdin/
(l'entrée standard~: généralement le clavier), redirigent leur sortie vers un
« fichier » appelé <it/stdout/ (généralement l'écran) et leurs
erreurs vers un « fichier » appelé <it/stderr/ (généralement 
l'écran). 

En utilisant <tt/&lt;/ et <tt/>/ vous redirigez l'entrée et la sortie vers
un fichier différent. De plus, <tt/>>/ ajoute la sortie à un fichier à la
place de l'écraser~; <tt/2>/ redirige les messages d'erreur (<it/stderr/)~;
2>&amp;1 redirige <it/stderr/ vers <it/stdout/, alors que 1>&amp;2
redirige <it/stdout/ vers <it/stderr/. Il y a un « trou noir » appelé <tt>/dev/null</>~: tout ce qui est redirigez vers lui disparaît.

<item> Jokers/~: sur la ligne de commande <tt/*/ correspond à (et désigne) tous
les fichiers sauf ceux qui sont cachés~; <tt/.*/ correspond à tous les fichiers
cachés~; <tt/*.*/ correspond seulement ceux qui ont un « . » au
milieu de leur nom suivi par d'autres caractères~; <tt/l*c/ correspondra à
« loïc » et « luc »~; <tt/*c*/ correspondra à
« piocher » et « picorer ». <tt/&percnt;/ devient <tt/?/.
Il existe également un autre joker~: <tt/[]/. Par exemple~:
<tt/[abc]*/ désigne les fichiers commençant par a, b ou c~;
<tt/*[I-N123]/ désigne les fichier finissant par I, J, K, L, M, N, 1, 2 ou 3.

<item><tt/mv/ (<tt/RENAME/) ne permet pas de renommer plusieurs fichiers d'un
coup. Ainsi, <tt/mv *.xxx *.yyy/ ne marchera pas.

<item> Utilisez <tt/cp -i/ et <tt/mv -i/ pour être prévenu quand
un fichier va être écrasé.

</itemize>

<sect1> Files d'impression <label id="Files d'impressions">

<p>

Vos fichiers à imprimer sont placés dans une file comme sous VMS.
Quand vous lancez une commande d'impression, vous aurez peut-être
à préciser le nom de l'imprimante. Par exemple

<tscreen><verb>
$ lpr fichier.txt # ce fichier est placé dans la file de l'imprimante standard
$ lpr -Plaser fichier.ps # celui dans celle de l'imprimante « laser »
</verb></tscreen>

Pour gérer la file d'impression utilisez les commandes suivantes~:

<tscreen><verb>
VMS					Linux
------------------------------------------------------------------------------

$ PRINT fichier.ps                      $ lpr fichier.ps
$ PRINT/QUEUE=laser fichier.ps          $ lpr -Plaser fichier.ps
$ SHOW QUEUE                            $ lpq
$ SHOW QUEUE/QUEUE=laser                $ lpq -Plaser
$ STOP/QUEUE                            $ lprm <numéro de job>
</verb></tscreen>

<sect> Configurer <label id="Configurer">

<p>

Votre administrateur système a dû vous fournir certains fichier de
configuration comme <tt/.xinitrc/, <tt/.bash_profile/ et <tt/.inputrc/. Ceux
que vous voudrez peut-être modifier sont~: 

<itemize>

<item> <tt/.bash_profile/ ou <tt/.profile/~: ce fichier est lu par le shell au
moment du login. C'est l'équivalent de <tt/LOGIN.COM/.

<item> <tt/.bash_logout/~: celui-ci est lu en fin de session. C'est
l'équivalent 
de <tt/LOGOUT.COM/.

<item> <tt/.bashrc/~: il est lu par les shells non interactifs

<item> <tt/.inputrc/~: ce fichier configure les rôles des touches du
clavier et le comportement du shell.

</itemize>

Pour vous donner un exemple, j'ai inclus une partie mon <tt/.bash_profile/~:

<code>
# $HOME/.bash_profile

# on ne redéfinit pas le path si ce n'est pas nécessaire
echo $PATH | grep $LOGNAME > /dev/null
if [ $? != 0 ]
then
  export PATH="$PATH:/home/$LOGNAME/bin"  # ajoute mon répertoire au path
fi

export PS1='LOGNAME:\w\$ '
export PS2='Continued...>'

# alias

alias bin="cd ~/bin" ; alias cp="cp -i" ; alias d="dir"
alias del="delete" ; alias dir="/bin/ls $LS_OPTIONS --format=vertical"
alias ed="jed" ; alias mv='mv -i'
alias u="cd .." ; alias undel="undelete"

# Quelques fonctions utiles

inst() # installe un tarball gzipé dans le répertoire courant
{
  tar xvfz $1
}
cz() # liste le contenu d'une archive .zip
{
  unzip -l $*
}
ctgz() # liste le contenu d'un tarball gzipé
{
  for fichier in $* ; do
    tar tfz ${fichier}
  done
}
tgz() # crée une archive .tgz à la zip.
{
  nom=$1 ; tar cvf $1 ; shift
  tar -rf ${nom} $* ; gzip -S .tgz ${nom}
}
</code>

Et voici mon <tt/.inputrc/~:

<code>
# $HOME/.inputrc
#
# Ce fichier est lu par bash et définit les fonctions attachés aux touches
# par le shell ; ce qui suit permet d'avoir un comportement courant pour
# les touches <it/fin/, <it/home/ (la touche au dessus de fin), <it/suppr/
# et les caractères accentués. 
# Pour plus d'information, man readline.

"\e[1~": beginning-of-line
"\e[3~": delete-char
"\e[4~": end-of-line

set bell-style visible
set meta-flag On
set convert-meta Off
set output-meta On
set horizontal-scroll-mode On
set show-all-if-ambiguous On

# (F1 .. F5) sont "\e[[A" ... "\e[[E"

"\e[[A": "info "
</code>

<sect> Programmes utiles<label id="Programmes utiles">

<p>

<sect1> Visionneur de fichiers~: <tt/less/

<p>

Vous utiliserez un tel programme tous les jours, c'est pourquoi je vais vous
donner 
quelques astuces pour l'utiliser au mieux. Avant tout, demandez à votre
administrateur de configurer <tt/less/ pour qu'il puisse afficher non seulement
des fichiers textes mais aussi les fichiers compressés, les archives, etc.

Comme les dernières versions de <tt/TYPE/, <tt/less/ vous permet de vous
déplacer dans le fichier dans les deux directions. Il accepte aussi plusieurs
commandes qui 
sont lancées en appuyant sur une touche. Les plus utilisés sont~:

<itemize> 

<item> tout d'abord, appuyez sur <sf/q/ pour quitter~;

<item> <sf/h/ pour obtenir l'aide~;

<item> <sf/g/ pour aller au début du fichier, <sf/G/ à la fin, un nombre suivi
de <tt/g/ pour aller à cette ligne (par exemple <tt/125g/), un nombre suivi
de <tt/%/ pour aller à ce pourcentage du fichier~;

<item> <tt>/motif</> recherche vers l'avant le motif~; <tt/n/ recherche vers
l'avant la l'occurrence suivante~; <tt>?pattern</> et <tt/N/ font la même chose
vers l'arrière~;

<item> <tt/m/ suivi d'une lettre marque la position courante (par exemple
<tt/ma/)~;
<tt/'/ suivi de la même lettre rappelle cette position~;

<item> <tt/:e/ ouvre un autre fichier~;

<item> <tt/!commande/ exécute un shell.

</itemize>


<sect1> Numéros de version sous Linux<label id="Numeros de version sous
Linux"> 

<p>

Hélas, Linux ne supporte toujours pas les numéros de version nativement.
Cependant, on peut régler ce problème de deux manières. La première est
d'utiliser RCS (Revision Control System) qui vous permet de garder la trace
des précédentes versions d'un fichier. RCS est traité dans <it/Le mini-Howto
RCS/.

La seconde est d'utiliser un éditeur qui sait traiter les numéros de version.
<tt/emacs/ ou <tt/joe/ feront l'affaire. Pour emacs, ajoutez ces lignes dans
votre <tt/.emacs/.

<code>
(setq version-control t)
(setq kept-new-versions 15) ;;; ou toute autre valeur
(setq kept-old-versions 15)
(setq backup-by-copying-when-linked t)
(setq backup-by-copying-when-mismatch t)
</code>

Pour jed, vérifiez que vous avez une version supérieure à la 0.98.7. Le patch
pour les numéros de version est disponible sur <tt><htmlurl
url="http://ibogeo.df.unibo.it/guido/slang/backups.sl"
name="http://ibogeo.df.unibo.it/guido/slang/backups.sl"></> 

<sect1> Archiver~: tar et gzip

<p>

Sous Unix il existe quelques applications très répandues qui sont utilisés pour
archiver et compresser des fichiers. <tt/tar/ est utilisé pour faire des
archives (c'est à dire un regroupement de fichiers). Pour faire une
archive~:

<tscreen><verb>
$ tar -cvf <archive.tar> <fichier> [fichier...]
</verb></tscreen>

Pour extraire des fichiers d'une archive~:

<tscreen><verb>
$ tar -xpvf <archive.tar> [fichier...]
</verb></tscreen>

Pour lister le contenu d'une archive~:

<tscreen><verb>
$ tar -tf <archive.tar> | less
</verb></tscreen>

Les fichiers peuvent être compressés en utilisant <tt/compress/ ou <tt/gzip/.
<tt/compress/ est aujourd'hui obsolète et on n'utilise plus que <tt/gzip/.

<tscreen><verb>
$ compress <fichier>
$ gzip <fichier>
</verb></tscreen>

Ceci créera un fichier compressé avec l'extension~.Z (pour <tt/compress/)
ou~.gz (pour <tt/gzip/). Ces programmes ne font pas d'archives mais compressent
des fichiers individuellement. Pour décompresser utilisez

<tscreen><verb>
$ compress -d <fichier.Z>
$ gzip -d <fichier.gz>
</verb></tscreen>

Faites un tour du côté de leurs pages man.

Les utilitaires <tt/unarj/, <tt/zip/ et <tt/unzip/ sont aussi disponibles. 

Les fichier avec l'extension <tt/.tar.gz/ ou <tt/.tgz/ (archivés par <tt/tar/,
puis compressés par <tt/gzip/) sont
très communs dans le monde Unix. Voici comment lister le contenu d'une telle
archive~:

<tscreen><verb>
$ tar -ztf <fichier.tar.gz> | less
</verb></tscreen>

Pour extraire les fichiers à partir d'un <tt/.tar.gz/~:

<tscreen><verb>
$ tar -zxf <fichier.tar.gz>
</verb></tscreen>

<sect> Exemples du monde réel <label id="Exemples">

<p>

Le principe central d'Unix est qu'il existe plusieurs commandes simples qui
peuvent être liées ensemble grâce aux <it/pipes/ et aux redirections pour
accomplir 
des tâches plus compliquées. Regardez les exemples suivants (je n'expliquerai
que les plus compliqués~; pour les autres, reportez vous aux sections
précédentes ou aux pages man).

<itemize>

<item>
<tt/ls/ est trop rapide et je ne peux pas lire le nom de tous
les fichiers.

<tscreen><verb>
$ ls | less
</verb></tscreen>

<item> J'ai un fichier qui contient une liste de mots. Je veux les
trier dans l'ordre inverse et les imprimer.

<tscreen><verb>
$ cat fichier.txt | sort -r | lpr
</verb></tscreen>

<item> Mon fichier de données contient des doublons. Comment les
effacer~?

<tscreen><verb>
$ sort fichier.dat | uniq > nouveaufichier.dat
</verb></tscreen>

<item> J'ai un fichier appelé papier.txt ou papier.tex ou quelques choses dans
le genre mais je ne m'en rappelle plus. Comment le retrouver~?

<tscreen><verb>
$ find ~ -name "papier*" 
</verb></tscreen>

Expliquons. <tt/find/ est une commande très utile qui liste tous les fichier
dans une arborescence (qui commence à partir du répertoire <it/home/ dans ce
cas). Sa sortie peut-être filtrée selon plusieurs critères comme par exemple
<tt/-name/. 

<item> J'ai un fichier texte qui contient le mot «~entropie~» dans
ce répertoire. Existe-t-il quelque chose de comparable à 
<tt/SEARCH/~?

Bien sûr, essayez cela~:

<tscreen><verb>
$ grep -l 'entropie' *
</verb></tscreen>

<item> Quelque part, j'ai un fichier texte qui contient le mot
«~entropy~» et j'aimerai le retrouver. Sous VMS j'aurais utilisé
<tt/search entropy [...]*.*.*/, mais <tt/grep/ n'est pas récursif.

<tscreen><verb>
$ find . -exec grep -l "entropy" {} \; 2> /dev/null
</verb></tscreen>

<tt/find ./ sort tous les noms des fichiers à partir du
répertoire courant, <tt/-exec grep -l "entropy"/ lance une commande sur chacun
des fichiers (représentés par <tt/&lcub;&rcub;/), <tt/&bsol;/ termine la
commande). Si vous pensez que la syntaxe est horrible... vous avez raison :-)

Vous auriez aussi pu écrire le script suivant~:

<code>
#!/bin/sh
# rgrep: grep récursif
if [ $# != 3 ]
then
  echo "Utilisation : rgrep <paramètres> <motif> <répertoire>"
  exit 1
fi
find $3 -name "*" -exec grep $1 $2 {} \; 2> /dev/null
</code>

Voici l'explication. <tt/grep/ marche comme <tt/SEARCH/ et combiné avec
<tt/find/ nous obtenons le meilleur des deux mondes.

<item> J'ai un fichier qui a deux lignes d'en-tête et qui a ensuite <it/n/
données par ligne, pas nécessairement espacées de la même manière. Je veux
extraire la deuxième et le cinquième champs de chaque ligne. Dois-je écrire un
programme en Fortran~? 

Nan. Ceci est plus rapide~:

<tscreen><verb>
$ awk 'NL > 2 {print $2, "\t", $5}' fichier.dat > nouveaufichier.dat
</verb></tscreen>

<tt/awk/ est en fait un langage de programmation. Pour chaque ligne à partir de
la troisième, on affiche le second et le cinquième champ en les séparant par
une tabulation. Apprenez à vous servir de awk --- il vous fera gagner beaucoup
de temps.

<item> J'ai téléchargé le <tt/ls-lR.gz/ d'un FTP. Pour chaque sous
répertoire, il y a une ligne «~total <it/x/~», avec <it/x/ la
taille en Kilo-octets du répertoire. J'aimerais avoir le total de toutes ces
valeurs.

<tscreen><verb>
zcat ls-lR.gz | awk ' $1 == "total" { i += $2 } END {print i}'
</verb></tscreen>

<tt/zcat/ sort le contenu du fichier <tt/.gz/. La sortie est envoyée
vers awk dont je vous recommande chaudement de lire la page man.

<item> J'ai écrit un programme en Fortran, <tt/monprog/, pour
calculer un paramètre à partir d'un fichier de données. Je voudrais le lancer
sur des centaines de fichiers et avoir la liste des résultats, mais c'est une
calamité de demander chaque fois le nom du fichier. Sous VMS, j'aurais écrit un
long fichier de commande. Et sous Linux~?

Un script très court. Faites votre programme pour qu'il cherche
le programme mesdonnées.dat et pour qu'il afficher le résultat sur l'écran
(stdout) et écrivez ensuite ce petit script~:

<code>
#!/bin/sh
# monprog.sh: lance la même commande sur plusieurs fichiers
# usage: monprog.sh *.dat
for fichier in $*  # pour tous les paramètres (e.g. *.dat)
do
  # ajouter le nom du fichier dans résultat.dat
  echo -n "${fichier}:    " >> résultats.dat
  # copie le paramètre courant dans mesdonnées.dat et lance monprog 
  # et ajoute le sortie à résultats.dat
  cp ${fichier} mesdonnées.dat ; monprog >> résultats.dat
done
</code>

<item> Je veux remplacer «~géologie~» par
«~géophysique~» dans tous mes fichiers textes. Dois-je les éditer 
manuellement~?

Nan. Écrivez ce script~:

<code>
#!/bin/sh
# remplace $1 par $2 dans $*
# utilisation : remplace "vieux-motif" "nouveau-motif" fichier [fichier...]
VIEUX=$1           # premier paramètre
NOUVEAU=$2         # second
shift ; shift      # enlever les deux premier paramètres ; les suivants sont
                   # les noms des fichiers
for fichier in $*  # pour tous les fichier donnés en paramètres
do
# remplace toutes les occurrences de VIEUX par NOUVEAU et sauve cela
# dans un fichier temporaire
  sed "s/$VIEUX/$NOUVEAU/g" ${fichier} > ${fichier}.nouveau
# renommer le fichier temporaire
  /bin/mv ${fichier}.new ${fichier}
done
</code>

<item> J'ai des fichier contenant des données. Je ne connais pas leur
taille et je dois enlever leur avant-dernière et leur avant-avant-dernière
lignes. Heu... à la mimine~?

Bien sûr que non~:

<code>
#!/bin/sh
# prune.sh: efface les n-1ème et n-2ème ligne de fichiers
# utilisation : prune.sh fichier [fichier...]
for fichier in $*   # pour chaque paramètre
do
  LIGNES=`wc -l $fichier | awk '{print $1}'`  # nombre de ligne dans fichier
  LIGNES=`expr $LIGNES - 3`                   # LIGNES = LIGNES - 3
  head -n $LIGNES $fichier > $fichier.new     # sort les premières lignes
                                              # de LIGNES
  tail -n 1 $fichier >> $fichier.new          # ajoute la dernière ligne
done
</code>

NDT~: il est tout de même beaucoup plus élégant d'utiliser <tt/ed/~:

<code>
#!/bin/sh
# prune.sh: efface les n-1ème et n-2ème ligne de fichiers
# utilisation : prune.sh fichier [fichier...]
for fichier in $*   # pour chaque paramètre
do
  printf '$-2,$-1d\nw\nq\n' | ed -s $fichier
done
</code>

</itemize>

J'espère que ces exemples vous auront ouvert l'appétit.

<sect> Astuces dont on ne peut se passer

<p>

<itemize>

<item> La complétion de commande~: l'appui sur la touche tabulation quand
vous tapez une commande va compléter la ligne de commande. Par exemple, disons
que vous devez taper <tt>less un_nom_de_fichier_très_long</>. Il vous suffira
de taper <tt>less un</> puis d'appuyer sur tabulation (si vous avez plusieurs
fichier qui commencent par les mêmes caractères tapez-en assez pour résoudre
l'ambiguïté).

<item> Faire défiler l'écran vers le haut~: en appuyant sur Shift-Page_up 
vous pouvez faire défiler l'écran vers le haut de quelques pages (le nombre de
page dépend de la mémoire vidéo de votre PC).

<item> Rétablir l'écran~: s'il vous arrive de faire un <tt/more/ ou un
<tt/cat/ sur un fichier binaire votre écran pourra se retrouver plein de
symboles bizarres. Pour arranger les choses, à l'aveuglette tapez
<tt/reset/ ou cette séquence de caractères~: <tt/echo ctrl-v Echap c Entrée/.

<item> Copier du texte sur la console~: demandez à votre administrateur
d'installer <tt/gpm/, un driver pour la souris en mode texte. Cliquez et
glissez pour sélectionner du texte et ensuite appuyez sur le bouton droit pour
coller le texte sélectionné. Ça marche entre plusieurs consoles virtuelles.

<item> Copier du texte sous X~: cliquez et glissez pour sélectionnez le texte
dans un <tt/xterm/ et cliquez ensuite sur le bouton du milieu (ou les deux
boutons) pour coller.

</itemize>

<sect> Lire des bandes VMS depuis Linux

<p>
(Cette section a été écrite par Mike Miller)

<sect1> Introduction

<p>

De temps en temps vous pourrez être amené à lire des bandes enregistrées à
partir d'une machine sous VMS (ou des bandes enregistrées pour être lisibles
sous VMS et les systèmes Unix). En général, c'est assez facile pour les bandes
DECFILES11A.

Bien que l'on puisse lire ceci comme une partie d'un mini-HOWTO Linux, je crois
que les informations ici présentées sont appliquables à tout système Unix
-- j'ai fait cela avec Linux et les systèmes Unix d'HP, de SUN et de DEC. La
principale dépendance à la plate-forme est le nom des
fichiers périphériques qui peuvent varier d'un système à l'autre, et les
options de <tt/mt/ pour spécifier le nom du périphérique (par exemple, <tt/mt
-f/ avec Linux et <tt/mt -t/ sur HPUX 9).

Avertissement~: j'ai seulement essayé cela avec des lecteurs de bande Exabyte
8~mm SCSI. Si vous avez lu d'autres formats (vous avez encore des lecteurs
9~pistes qui traînent quelque part~?), faites-le moi savoir et je les 
ajouterai.  

<sect1> Les bases

<p>

Pour lire une bande qui a été écrite avec la commande <tt/copy/ de VMS
(ou une commande compatible) tout ce que vous devez savoir est que, pour
chaque fichier effectif, il y aura trois fichiers de données sur la bande~: une
entête, les données et une terminaison. L'entête et la terminaison 
sont intéressantes car elles contiennent des informations sur le fichier tel
qu'il était sous VMS. Le fichier de données est... le fichier de données.
Chacun de ces fichiers peut être extrait de la bande avec la commande dd. La
bande peut être positionnée en utilisant la commande <tt/mt/.

Prenons un exemple. J'ai une bande VMS. Les deux premiers de ses fichiers
étaient appelés <tt/ce66-2.evt/ et <tt/ce66-3.evt/ sur le système VMS. Le label
de la bande est c66a2.

Si j'exécute les commandes suivantes

<code>
$ dd if=$TAPE bs=16k of=entête1
$ dd if=$TAPE bs=16k of=donnée1
$ dd if=$TAPE bs=16k of=terminaison1
$ dd if=$TAPE bs=16k of=entête2
$ dd if=$TAPE bs=16k of=donnée2
$ dd if=$TAPE bs=16k of=terminaison2
</code>

je me retrouve avec six fichiers~: <tt/entête1/, <tt/donnée1/,
<tt/terminaison1/, <tt/entête2/, <tt/donnée2/ et <tt/terminaison2/. La syntaxe
ici est <tt/if="fichier d'entrée"/, <tt/bs="taille des blocs"/ et 
<tt/of="fichier de sortie"/. TAPE doit être une variable d'environnement
contenant le nom du périphérique de votre lecteur de bande --- par exemple 
/dev/nts0 si vous utilisez le premier disque SCSI sous Linux. 

Si vous aviez voulu récupérer le second fichier, mais pas le premier, sous son
non d'origine, vous n'auriez pas eu à vous préoccuper de l'entête~: 

<code>
$ mt -f $TAPE fsf 4
$ dd if=$TAPE bs=16k of=ce66-2.evt
$ mt -f $TAPE fsf 1
</code>

Notez le 4. Il permet de sauter trois fichiers pour le premier fichier et un
pour l'entête du deuxième. Le second <tt/mt/ saute la seconde terminaison et
positionne la bande au début du prochain fichier~: la troisième entête. Vous
pouvez aussi utilisez <tt/mt/ pour sauter des fichiers en arrière (<tt/bsf/),
rembobiner (<tt/rewind/) ou décharger la bande (<tt/offline/, <tt/rewoffl/).

<sect1> Quelques détails

<p>

Les fichiers d'entêtes et de terminaisons contiennent des données ASCII en
majuscules utilisées par VMS pour stocker des informations sur le fichier
comme par exemple la taille des blocs. Ils contiennent aussi le nom du
fichier, ce qui peut être utile si vous voulez faire des scripts qui lisent
automatiquement des fichiers ou recherchent un fichier particulier. La première
entête de la bande est un peu différente des suivantes.

L'en-tête du premier fichier de la bande (comme par exemple dans l'exemple
ci-dessus) débute par la chaîne «~VOL1~». Suit le nom de volume.
Dans notre exemple, le fichier <tt/entête1/ commence par 
«~VOL1C66A2~». Vient ensuite une série d'espace terminée par un
chiffre. Après, on trouve la chaîne «~HDR1~» qui indique que l'on a
à faire à un fichier d'entête. Les caractères qui suivent 
immédiatement la chaîne «~HDR1~» forment le nom du fichier VMS.
Dans l'exemple, cette chaîne est «~HDR1CE66-2.EVT~». Le prochain
champ est le nom du volume.  

Le champs initial des autres fichiers (c'est-à-dire tous sauf le premier de la
bande) est quelque peu différent. 
«~VOL1~» n'est pas présent. Le reste est identique.
Un autre champ utile est le septième. Il se termine par
«~DECFILES11A~». C'est un 
signe de conformité au standard DEC Files11A. 

<tscreen><verb>
Champ                Entête initiale                  Entêtes suivantes
1                    VOL1 + nom du volume             HDR1 + nom du fichier 
2                    HDR1 + nom du fichier            Nom du volume
3                    Nom du volume                    ...
4                    ...                              ...
5                    ...                              ...
6                    ...                              DECFILES11A
7                    DECFILES11A
</verb></tscreen>

Pour une documentation complète sur le format de l'entête et de la terminaison,
voyez la documentation DEC FILES11 (sur le mur gris/orange --- demandez à 
votre communauté VMS locale :-).

<sect1> Commentaires sur la taille des blocks

<p>

Dans l'exemple, j'ai utilisé une taille de bloc de 16 ko. Sur un système Unix,
il n'y a pas de taille de bloc associée à un fichier sur un disque alors que,
sous VMS, chaque fichier à une taille de bloc spécifique. Cela veut dire que la
taille du bloc importe peu sous linux... sauf que cela  rend la lecture des
bandes plus compliquée. Si vous avez des difficultés pour trouver la taille du
bloc et pour lire une bande, vous pouvez essayer de régler la taille de bloc
matérielle de votre lecteur de bande en utilisant <tt/mt -f $TAPE setblk 0/. La
syntaxe exacte de l'option setblk (et sa disponibilité) dépend de la version de
<tt/mt/, de l'interface matérielle de votre lecteur de bande et de votre
environnement Unix.

(Merci à <htmlurl url="skulski@nsrlc6.nsrl.rochester.edu" name="Wojtek
Skulski"> pour avoir signalé l'option setblk.)

<sect> La fin

<p>

<sect1> Copyright

<p>

Sauf indication contraire, les droits d'auteur des HOWTO Linux sont
détenus par leurs auteurs respectifs. Les HOWTO Linux peuvent être
reproduits et distribués, en totalité ou en partie, sur tout média
physique ou électronique dans la mesure où ce copyright est préservé
dans chaque copie. La distribution commerciale en est autorisée et
encouragée. L'auteur apprécierait toutefois qu'on lui notifie
individuellement ce genre de distribution.

Le présent copyright doit couvrir toute traduction, compilation et
autre travail dérivé des HOWTO Linux. C'est-à-dire qu'il est interdit
d'imposer des restrictions de diffusion allant au delà du présent
copyright à des ouvrages inspirés, ou incorporant des passages, de
HOWTO Linux. Sous certaines conditions, des exceptions à ces règles
seront tolérées~: contactez le coordinateur des HOWTO à l'adresse
donnée ci-dessous.  

Pour résumer, nous souhaitons une diffusion aussi large que possible
de ces informations. Néanmoins, nous entendons garder la propriété
intellectuelle (copyright) des HOWTO, et apprécierions d'être informés
de leur redistribution.

Pour toute question plus générale, merci de contacter le coordinateur
des HOWTO, Guylhem Aznar, à l'adresse électronique <htmlurl
url="mailto:linux-howto@sunsite.unc.edu"
name="linux-howto@sunsite.unc.edu"> par email. 

<sect1> Avertissement

<p>

Ce travail a été écrit d'après l'expérience que nous avons eue au <it/Settore
di Geofisica of Bologna University/ (Italie), ou un VAX 4000 a été remplacé par
un Pentium tournant sous Linux. La plupart de mes collègues sont des
utilisateurs de VMS, et certains d'entre eux l'ont abandonné pour Linux.

Le <it/HOWTO Comment migrer de VMS à Linux/ a été écrit par <htmlurl
url="mailto:guido@ibogeo.df.unibo.it" name="Guido Gonzato"> et <htmlurl 
url="mailto:miller5@uiuc.edu" name="Mike Miller"> qui a écrit la partie sur
la lecture des bandes VMS. Merci beaucoup à mes collègues et amis qui m'ont aidé
à définir les besoins et les habitudes de l'utilisateur lambda de VMS, et 
particulièrement au Dr. Warner Marsocchi.

S'il vous plaît, aidez moi à améliorer ce HOWTO. Je ne suis pas un expert de
VMS et je n'en serai jamais un. C'est pourquoi vos suggestions et reports de
bogues seront plus que bienvenus.

Amusez-vous bien,

Guido <tt/=8-)/

</article>
