<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook V3.1//EN">
<BOOK>
<BOOKINFO>
<Title><ULINK URL="http://www.linuxports.com/">Linux Networking HOWTO</ULINK></Title>
<AUTHOR><FirstName>Joshua</FirstName> <Surname>Drake</Surname></AUTHOR>
<LegalNotice>
<para>
(Traduction et trahison de Jacques.Chion@wanadoo.fr, un grand merci
à Jean-Albert Ferrez, Bernard Choppy, Éric Dumas et Jean-Paul Chiron
pour leur aide).
</para>
<para>NdT : Dans cette version, l'auteur fait appel très souvent à la générosité
publique. Trop à mon goût. J'ai laissé volontairement ces appels, car ce n'est
pas le but d'un traducteur de dénaturer l'esprit d'un document. À vous de
juger.
</para>
</LegalNotice>
<PubDate>v1.7.0, 29 Décembre 2000</PubDate>
<COPYRIGHT><YEAR>2000</YEAR><HOLDER>Commandprompt, Inc</HOLDER></COPYRIGHT>
<ABSTRACT>
<para>
Ceci un document LinuxPorts.Com Document pour le LDP (Linux Documentation
 Project : Projet de Documentation pour Linux).Il a été soutenu en partie
 par le <ULink URL="http://www.opendocspublishing.com/">Open Source 
Documentation Fund.</ULink>
</para>
<para>
La version actuelle est la 1.7.0, qui est une mise à jour mineure
avec quelques corrections grammaticales.
</para>

</ABSTRACT>
</BOOKINFO>

<CHAPTER><TITLE>Comment puis-je apporter mon aide?</TITLE>
<Para>
Nous essayons de fournir un ensemble d'informations pour la compréhension
de toutes les implantations de réseaux sous Linux. Cependant, cela consomme
du temps, et ce document n'est pas une source de revenu. Nous fournissons
ces informations en espérant que ce sera utile à la communauté Linux
et aux nouveaux convertis à Linux. Nous sommes toujours intéressés par
les retours d'information! Nous ajouterons autant que possible tout sujet 
pertinent dans ce document.
</Para>
<Para>
</para>
<SECT1><TITLE>Prêter son concours au Net-HOWTO</TITLE>
<Para>
Si vous vouler apporter votre aide, il existe deux voies qui sont d'un très 
grand secours.
</Para>
<ItemizedList>
<ListItem>
<Para>
<Ulink URL="http://www.linuxports.com/cart/">Achetez un livre OpenBook!</Ulink>
Si vous achetez des livres OpenDocs, OpenDocs Publishing rétrocédera une partie
de la somme au 
<Ulink URL="http://www.opendocspublishing.com/">Fond de Documentation Open Source (Open Source Documentation Fund).</Ulink> Celui-ci aide les auteurs financièrement afin qu'ils continuent à écrire de la documentation pour les projets
 Open Source.
</Para>
</ListItem>
<ListItem>
<Para>
<EMPHASIS>Contribuer financièrement au document</EMPHASIS>. 
Avec cette contribution, vous pouvez même demander ce que vous voudriez
voir mis à jour, écrit, ou développé dans le document. Pour participer
financièrement, contactez s'il vous plaît
 <Ulink URL="http://www.commandprompt.com/">Command Prompt, Inc.</Ulink>
ou <ULink URL="mailto:poet@linuxports.com">Joshua Drake</Ulink>.
</Para>
</ListItem>
<ListItem>
<Para>
Si vous avez écrit quelque chose sur un sujet auquel vous voudriez apporter
votre contribution, envoyez un courrier électronique à
<Ulink URL="mailto:poet@linuxports.com">poet@linuxports.com</Ulink>
</Para>
</ListItem>
</ItemizedList>
</Sect1>
</Chapter>

<chapter>
<title>Historique du document</title>

<para>Le premier document NET-FAQ fut écrit par Matt Welsh et Terry Dawson.
Il répondait aux questions fréquemment posées au sujet des réseaux sous 
Linux, au moment où le LPD (Linux Documentation Project) démarrait tout juste.
Il s'agissait alors des toutes premières versions de développement du 
noyau réseau sous Linux.
 Le document NET-2-HOWTO, qui succéda au NET-FAQ, fut l'un des 
 premiers documents du LDP HOWTO. Il traitait de ce qui fut appelé 
« version 2 » (et plus tard « version 3 ») du logiciel réseau du noyau Linux. 
 Ce document prend la suite à son tour et ne traite que de la version 4 
 du noyau réseau Linux et plus spécialement des versions du noyau 2.x et 2.2.x.
</para>
<para>
Les versions précédentes de ce document étaient devenues
 plutôt énormes en raison du grand nombre de sujets 
 abordés. Pour résoudre ce problème, un certain nombre
 de documents HOWTO ont été créés et traitent de sujets spécifiques.
Ce document fait référence à ceux qui sont pertinents 
et aborde les sujets qui ne sont pas encore couverts par d'autres documents.
</para>
<Sect1>
<title>Retour d'informations</title>
<para>
Nous apprécions toujours les retours d'informations.
 Contactez-nous s'il vous plait à:
<ULink URL="mailto:poet@linuxports.com">poet@linuxports.com</ULink>.
</para>
<para>
Si vous trouvez des erreurs ou bien si vous
désirez que l'on ajoute quelque chose, <ulink url="mailto:poet@linuxports.com">contactez nous</ulink>.
</para>
<Para><Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci
vous a intéressé ? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
</chapter>

<!-- *********************************************************************** -->

<chapter>
<title>Comment utiliser ce document.</title>
<para>
Ce document est organisé de manière à être lu progressivement. 
Les premières sections traitent d'informations sur le matériel et peuvent 
être sautées si cela ne vous intéresse pas. Puis vous trouverez 
une discussion générale sur les réseaux, et vous devez être certains 
de l'avoir assimilée avant de 
poursuivre vers les paragraphes plus spécifiques. Le reste traite
l'aspect plus technique, et est regroupé en trois parties
 principales : informations sur Ethernet et IP, les technologies concernant
le matériel PC le plus courant, et les technologies moins répandues.
</para>
<para> 
La démarche que je suggère pour parcourir ce document est donc la suivante : 
</para>
<para>
<VariableList>
<VarListEntry>
<Term>
Lire les sections générales
</Term>
<ListItem>
<para>
Ces paragraphes s'appliquent à chaque, ou presque, technologie décrite
plus loin et il est donc important que vous les ayez comprises.
D'autre part, j'espère que de nombreux de lecteurs connaissent déjà le sujet.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>Réfléchissez à votre réseau</Term>
<ListItem>
<para>
Vous devez savoir comment votre réseau est (ou sera) conçu et quels
 matériels et types de technologies vous utiliserez.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>Lisez la section ``Ethernet et IP'' si vous êtes connectés en direct
  sur un réseau local ou à l'Internet</Term>
<ListItem>
<para>
 Cette section traite de la configuration de base d'Ethernet et des 
 différentes possibilités offertes par Linux, et qui concernent le réseau, 
 telles que le pare-feu, le routage avancé, etc..
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
Lisez après si vous êtes intéressés par les réseaux locaux à bas coût
ou les connexions par téléphone
</Term>
<ListItem>
<para>
Cette section parle de PLIP, PPP, SLIP, et RNIS, les technologies utilisées 
habituellement sur les stations personnelles.</para></ListItem>
</VarListEntry>
<VarListEntry>
<Term>
Lisez la section concernant la technologie qui correspond
 plus particulièrement à vos besoins.
</Term>
<ListItem>
<para>
Si vos besoins ne concernent pas IP et/ou un matériel courant, vous trouverez
 à la fin des détails sur les protocoles non-IP et les matériels de 
communication particuliers.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
Configurez votre réseau
</Term>
<ListItem>
<para>
Si vous allez réellement essayer de configurer votre réseau, prenez 
soigneusement note de tout problème éventuel.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
Cherchez de l'aide si nécessaire
</Term>
<ListItem>
<para>
Si vous rencontrez des problèmes qui ne sont pas traités dans ce document, 
reportez-vous au paragraphe donnant les endroits où l'on peut en obtenir ou bien
  envoyer des reports de bogues.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
Amusez-vous!
</Term>
<ListItem>
<para>
Le réseau est amusant, profitez-en.
</para>
</ListItem>
</VarListEntry>
</VariableList>
</para>


<Sect1>
<title>Les conventions utilisées dans ce document</title>
 
<para>
Il n'y a pas de convention spéciale utilisée dans ce document, mais vous 
devez faire attention à la façon dont les commandes sont spécifiées. En 
consultant la documentation habituelle d'Unix, toute commande qui doit être 
tapée est précédée d'une invite du shell.
Ce document utilise "<Literal remap="tt">user&percnt;</Literal>" comme invite 
pour les commandes ne nécessitant pas de privilèges de superutilisateur, 
et "<Literal remap="tt">root&num;</Literal>" 
pour les commandes que l'on doit exécuter comme super-utilisateur (root). 
Je préfère utiliser "<Literal remap="tt">root&num;</Literal>" à la place du 
classique "<Literal remap="tt">&num;</Literal>" pour éviter 
toute confusion avec les extraits de scripts shell, ou le signe dièse 
est utilisé pour définir les lignes de commentaires.
</para>

 
<para>
Lorsque les « Options de Compilation du noyau » sont mentionnées, elles 
le sont avec le format utilisé par <Emphasis>menuconfig</Emphasis>. Elles 
devraient donc être compréhensibles même si vous (comme moi) n'êtes pas 
familiers avec <Emphasis>menuconfig</Emphasis>. Si vous avez un doute sur 
l'utilisation de certaines options, faites tourner le programme une fois.
Cela ne peut que vous aider.
</para> 

<Para><Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
</chapter>

<!-- *********************************************************************** -->

<chapter>
<title>Informations générales concernant le réseau sous Linux.</title>
<Sect1>
<title>Informations sur la couche réseau de Linux.</title>
<para>
Il existe un grand nombre d'endroits où l'on peut trouver de bonnes 
informations sur le réseau Linux.</para>
<para>
Il y a un tas de spécialistes disponibles. On peut en trouver une liste
sur <ULink URL="http://www.linuxports.com/">http://www.linuxports.com/.</ULink>
</para>
<para>
Alan Cox, l'actuel mainteneur du code réseau Linux entretient une page
 web contenant les points principaux du réseau actuel, et ses 
nouveaux développements, à l'adresse :
<ULink URL="http://www.uk.linux.org/NetNews.html">www.uk.linux.org</ULink>.
</para>
<para>
Il existe un groupe de discussion dédié au réseau et, en ce
 qui le concerne dans la hiérarchie Linux, c'est :
<ULink URL="news:comp.os.linux.networking">comp.os.linux.networking</ULink>
</para>
<para>
Il existe une liste de diffusion à laquelle vous pouvez vous inscrire, et
 où vous pourrez poser des questions en relation avec le réseau Linux.
 Pour souscrire vous devez envoyer un message par courrier électronique :
<Screen>
To: majordomo@vger.rutgers.edu
Subject: (rien du tout)
Message:

subscribe linux-net
</Screen>
</para>
<para>
Souvenez-vous lorsque vous faites part d'un problème d'y inclure le
 plus possible de détails nécessaires. Plus
 spécialement indiquez les versions des logiciels que vous utilisez,
 en particulier la version du noyau, les versions des outils tels que
<Emphasis remap="bf">pppd</Emphasis> ou <Emphasis remap="bf">dip</Emphasis>,
 et la nature exacte des problèmes que vous
 rencontrez. Cela veut dire prendre note de la syntaxe exacte des messages 
d'erreurs que vous recevez, et les commandes que vous avez exécutées.
</para>

<para><Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
<Sect1>
<title>Où obtenir des informations sur le réseau, non spécifiques de Linux.</title>
<para>
Si vous désirez des informations générales de base sur
 tcp/ip, alors je vous recommande de regarder les documents suivants : 
</para>

<para>
<VariableList>
<VarListEntry>
<Term>
introduction à TCP/IP 
</Term>
<ListItem>
<para>
ce document se trouve à la fois sur
<ULink URL="ftp://athos.rutgers.edu/runet/tcp-ip-intro.doc">
	en version texte</ULink> et
<ULink URL="ftp://athos.rutgers.edu/runet/tcp-ip-intro.ps">
	en version postscript</ULink>.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
administration TCP/IP
</Term>
<ListItem>
<para>
ce document se trouve à la fois sur
<ULink URL="ftp://athos.rutgers.edu/runet/tcp-ip-admin.doc">
	en version texte</ULink> et
<ULink URL="ftp://athos.rutgers.edu/runet/tcp-ip-admin.ps">
	en version postscript</ULink>.
</para>
</ListItem>
</VarListEntry>
</VariableList>
</para>

<para>
Si vous recherchez des informations plus détaillées je vous
 recommande chaudement :
</para>
<para>
<QUOTE>
<Emphasis> Inter Networking with TCP/IP, Volume 1 : Principes,
Protocoles et Architectures</Emphasis>, par Douglas E. Comer,ISBN
 0-13-227836-7, Prentice Hall publications, 3ème édition,
 1995.
</QUOTE>
</para>
<para>
Si vous voulez apprendre comment écrire des applications réseau
 dans un environnement compatible Unix, je vous recommande également
 chaudement :
</para>
<para>
<QUOTE>
<Emphasis> Unix Network Programming</Emphasis> par W. Richard Stevens
ISBN 0-13-949876-1, Prentice Hall publications, 1990.</QUOTE>
</para>
<para>
Une deuxième édition de ce livre va apparaitre sur les rayons : le nouveau
livre comporte 3 volumes : voyez <ULink URL="http://www.phptr.com/">
le site de Prentice Hall</ULink> pour en savoir plus.
</para>

<para>
Vous pouvez essayer aussi le groupe de discussions :
<ULink URL="news:comp.protocols.tcp-ip">comp.protocols.tcp-ip</ULink>.
</para>
<para>
Une importante source d'informations techniques concernant l'Internet
 et la suite des protocoles TCP/IP sont les RFC. RFC est l'acronyme de 
`Request For Comment' et c'est le moyen habituel de soumettre et de s'informer
 des normes de protocoles Internet.
 Il y a beauccoup d'endroits où sont stockées ces RFC. Un grand nombre
 sont des sites ftp, d'autres fournissent des accès WWW
 avec un moteur de recherche qui fouille dans les bases de données RFC avec
 des mots-clés particuliers.
</para>
<para>
Une source possible de RFC est :
<ULink URL="http://pubweb.nexor.co.uk/public/rfc/index/rfc.html">
	la base de données RFC de Nexor</ULink>.
</para>
<para><Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
</chapter>

<!-- *********************************************************************** -->

<chapter>

<title>Informations générales concernant la configuration réseau</title>
<para>
Vous devez connaître et bien comprendre les paragraphes
 suivants avant d'essayer de configurer votre réseau.
 Ce sont des principes de base qui s'appliquent, indépendamment de la 
nature du réseau que vous voulez mettre en place.
</para>
<Sect1>
<title>De quoi ai-je besoin pour démarrer ?</title>
<para>
Avant de commencer à construire ou configurer votre réseau, vous
 aurez besoin de certaines choses. Les plus importantes sont :
</para>

<Sect2>
<title>Sources du noyau récents (Optionnel).</title>
<para>À noter:
</para>
<para>
La majorité des distributions actuelles sont livrées avec l'option réseau
activée, de sorte que vous n'avez pas besoin de recompiler le noyau. Si vous
utilisez du matériel bien connu, tout ira bien. Par exemple: cartes 3COM,
cartes NE2000  ou cartes Intel. Cependant si vous devez recompiler le noyau,
voyez les informations qui suivent.
</para>
<para>
Si le noyau que vous utilisez actuellement ne gère pas les types 
de réseau ou les cartes que vous voulez utiliser, vous aurez 
 besoin des sources du noyau pour pouvoir le recompiler avec 
les options adéquates.
</para>
<para>
Pour les utilisateurs des principales distributions comme RedHat, Caldera,
Debian ou Suse, ce n'est plus vrai. Tant que vous restez avec un matériel
de grande diffusion, il n'est pas nécessaire de recompiler le noyau, à moins que
vous n'ayez une exigence très spécifique.
</para>
<para> 
Vous pouvez toujours obtenir les sources du dernier noyau sur :
<ULink URL="ftp://ftp.cdrom.com/pub/linux/sunsite/kernel.org/pub/linux/kernel/">ftp.cdrom.com</ULink>.
Ce n'est pas le site officiel mais ils ont BEAUCOUP de bande passante et
BEAUCOUP d'utilisateurs peuvent se connecter en même temps. Le site officiel
est kernel.org, mais dans la mesure du possible, utilisez s'il vous plaît celui
que je viens de donner.
Souvenez-vous que ftp.kernel.org est particulièrement surchargé. Utilisez un
miroir.
 (NdT : et bien sûr <ULink URL="ftp://ftp.lip6.fr/pub/linux/kernel/sources/">ftp.lip6.fr</ULink>) .
</para>
<para>
Normalement les sources du noyau doivent être désarchivées 
dans le répertoire <Literal remap="tt">/usr/src/linux</Literal>.
 Pour savoir comment appliquer les patches et compiler le noyau, lisez le
 <ULink URL="Kernel-HOWTO.html">Kernel-HOWTO</ULink>.
Pour savoir comment configurer les modules du noyau, lisez
le ``Modules-mini-HOWTO''. Enfin, le fichier
 <Literal remap="tt">README</Literal> qui
se trouve dans les sources du noyau ainsi que le répertoire
<Literal remap="tt">Documentation</Literal> donnent de nombreux renseignements 
au lecteur courageux.
</para>
<para> 
Sauf indication contraire, je vous recommande de 
vous en tenir à une version stable du noyau (celle avec un chiffre 
pair en seconde place dans le numéro de version). Les versions 
de développement (avec un chiffre impair en seconde place dans le 
numéro de version) peuvent avoir une structure ou autre chose 
qui peut poser problème avec les logiciels de votre 
système. Si vous n'êtes pas certain de résoudre ce type 
de problèmes, avec en plus ceux qui existeraient sur d'autres 
logiciels, n'utilisez pas de noyau en développement.
</para>
</Sect2>

<Sect2>
<title>Adresses IP : une explication.</title>
<para>
Les adresses de protocole Internet (IP) sont composées de 
quatre octets. La convention d'écriture est appelée `notation décimale 
pointée'. Sous cette forme chaque octet est converti en un nombre 
décimal (0-255), en omettant les zéros de tête 
(à moins que ce nombre ne soit lui-même un zéro) et 
 chaque octet est séparé par le caractère `.'.
Par convention, chaque interface d'un hôte ou routeur possède une 
adresse IP. Il se peut que la même 
adresse IP soit utilisée sur différentes interfaces 
d'une même machine, mais, en général, chaque interface possède 
sa propre adresse.
</para>
<para>
Les réseaux IP (Protocole Internet) sont des séquences contiguës 
d'adresses IP. Toutes les adresses d'un même
réseau ont des chiffres en commun. 
La partie d'adresse commune à toutes les adresses d'un réseau 
s'appelle la `partie réseau' de l'adresse. Les chiffres restants 
s'appellent `partie hôte'. Le nombre de bits qui sont partagés 
par toutes les adresses d'un même réseau est appelé masque 
de réseau (netmask) et c'est le rôle du masque de réseau 
de déterminer quelles adresses appartiennent à `son' 
réseau et celles qui ne sont pas concernées.
Par exemple :
</para>
<para>
<Screen>
_______________________________________      _______________
Adresse hôte (host address)                  192.168.110.23
Masque de réseau (network mask)              255.255.255.0
Partie réseau (network portion)              192.168.110.
Partie hôte (host portion)                              .23
_______________________________________      ________________
Adresse réseau (network address)             192.168.110.0
Adresse de diffusion (broadcast address)     192.168.110.255
_______________________________________      ________________
</Screen>
</para>
<para>

Toute adresse qui est un `AND bit à bit' avec son masque de 
réseau révèlera l'adresse du réseau auquel elle appartient.
L'adresse du réseau est par conséquent l'adresse de plus petit 
nombre dans l'ensemble des adresses et a toujours la partie hôte 
codée avec des zéros.
</para>
<para>
L'adresse de diffusion est une adresse spéciale que chaque hôte 
du réseau écoute en même temps que son adresse personnelle.
Cette adresse est celle à laquelle les datagrammes sont envoyés 
si tous les hôtes du réseau sont en mesure de les recevoir. 
Certains types de données telles que les informations de routage et les 
messages d'alerte sont transmis vers l'adresse de diffusion de telle sorte que 
tous les hôtes du réseau peuvent les recevoir en même temps. 
Il y a deux standards utilisés de manière courante pour 
définir ce que doit être l'adresse de diffusion. Le plus largement
 utilisé est de prendre
l'adresse la plus haute possible du réseau comme adresse de diffusion. 
Dans l'exemple ci-dessus ce serait
<Literal remap="tt">192.168.110.255</Literal>. Pour d'autres raisons, certains
 sites ont adopté la convention d'utiliser l'adresse de réseau comme adresse
 de diffusion. En pratique cela n'a pas beaucoup d'importance, mais vous devez
 être sûrs que tous les hôtes du réseau sont 
configurés avec la même adresse de diffusion.
</para>
<para>
Pour des raisons d'administration, il y a quelque temps, lors du 
développement du protocole IP, des ensembles d'adresses ont 
été organisés en réseaux et ces réseaux
 ont été regroupés en ce que l'on a  
appellé classes. Ces classes donnent un certain nombre de réseaux 
de tailles standards  
 auxquels on peut assigner des adresses. Ces classes sont :
</para>
<para>
<Screen>




- - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
|Classe de |Masque de     | Adresses de réseau           |
| réseau   |  réseau      |                              |
- - - - - - - - - - - - - - - - - - - - - - - - - - - - -
|    A    | 255.0.0.0     | 0.0.0.0    - 127.255.255.255 |
|    B    | 255.255.0.0   | 128.0.0.0  - 191.255.255.255 |
|    C    | 255.255.255.0 | 192.0.0.0  - 223.255.255.255 |
|Multicast| 240.0.0.0     | 224.0.0.0  - 239.255.255.255 |
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
</Screen>
</para>

<para>
Le type d'adresse que vous devez utiliser dépend de ce que vous 
voulez faire 
exactement. Vous pouvez utiliser une combinaison des actions suivantes
 pour obtenir l'ensemble des adresses dont vous aurez besoin :
</para>
<para>
<VariableList>
<VarListEntry>
<Term>
Installer une machine Linux sur un réseau IP existant </Term>
<ListItem>
<para>
Vous devez contacter un des administrateurs du réseau et lui 
demander les informations suivantes :
</para>
<para>
<ItemizedList>
<ListItem>
<para>
Adresse hôte;
</para>
</ListItem>
<ListItem>
<para>
Adresse réseau;
</para>
</ListItem>
<ListItem>
<para>
Adresse de diffusion;
</para>
</ListItem>
<ListItem>
<para>
Masque de réseau;
</para>
</ListItem>
<ListItem>
<para>
Adresse de routage; (appelée passerelle sous Windows)
</para>
</ListItem>
<ListItem>
<para>
Adresse du serveur de noms de domaine (DNS).
</para>
</ListItem>
</ItemizedList>
</para>
<para>
Vous configurerez alors votre réseau Linux à l'aide de ces 
données.
Vous ne pouvez pas les inventer vous-même et espérer que votre 
configuration fonctionne.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
Construire un réseau tout neuf non connecté à l'Internet
</Term>
<ListItem>
<para>
Si vous construisez un réseau privé et que vous n'ayez pas 
l'intention de vous connecter à l'Internet, vous pouvez alors choisir 
n'importe quelle adresse.
Cependant, pour des raisons de sécurité et de fiabilité,
 il y a quelques adresses de réseau IP réservées à 
cet usage. Elles sont spécifiées dans la RFC 1597 et sont les 
suivantes :
</para>
<para>
<Screen>
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
|         ALLOCATIONS POUR RÉSEAUX PRIVÉS                 |
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
| Classe  | Masque de     | Adresses de réseau            |
| réseau  |  réseau       |                               |
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
|    A    | 255.0.0.0     | 10.0.0.0    - 10.255.255.255  |
|    B    | 255.255.0.0   | 172.16.0.0  - 172.31.255.255  |
|    C    | 255.255.255.0 | 192.168.0.0 - 192.168.255.255 |
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
</Screen>
</para>
<para>

Vous devez d'abord décider de la dimension de votre réseau et 
choisir ensuite les adresses dont vous avez besoin.
</para>
</ListItem>
</VarListEntry>
</VariableList>
</para>
</Sect2>
</Sect1>

<Sect1>
<title>Où mettre les commandes de configuration ?</title>
<para>
Il y a plusieurs possibilités de procédures
 de démarrage d'un système Linux. Après le 
démarrage du noyau,  
 celui-ci exécute toujours un programme appelé 
`<Emphasis>init</Emphasis>'. Ce programme lit le fichier de configuration appelé
<Literal remap="tt">/etc/inittab</Literal> et commence le processus de 
démarrage. Il y a quelques variantes de <Emphasis>init</Emphasis>, bien que 
maintenant tout le monde se dirige vers la variante System V (cinq), 
développée par Miguel van Smoorenburg.
</para>
<para>
Bien que que le programme <Emphasis>init</Emphasis> soit toujours le même, 
les réglages du processus de démarrage se font différemment suivant le type de 
distribution.
</para>
<para>
Habituellement le fichier <Literal remap="tt">/etc/inittab</Literal> contient 
une entrée telle que :
</para>
<para>
<Screen>
si::sysinit:/etc/init.d/boot
</Screen>
</para>
<para>
Cette ligne spécifie le nom du fichier script qui prend en charge 
réellement la séquence de démarrage. Ce fichier est en 
quelque sorte équivalent au fichier MS-DOS
 <Literal remap="tt">AUTOEXEC.BAT</Literal>.
</para>
<para>
Il y a aussi d'autres scripts appelés par le script de 
démarrage, et souvent le réseau est configuré dans l'un de ceux-ci.
</para>
<para>
Le tableau suivant peut être utilisé comme guide suivant 
le système que vous avez :
</para>
<para>
<Screen>
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Distrib. |Interface Config/Routage           | Initialisation serveur
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Debian   | /etc/init.d/network               | /etc/rc2.d/*     
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
Slackware| /etc/rc.d/rc.inet1                | /etc/rc.d/rc.inet2 
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
RedHat   | /etc/rc.d/init.d/network          | /etc/rc.d/rc3.d/*
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
</Screen>
</para>
<para>
Notez que les distributions Debian et RedHat utilisent tout un répertoire
pour les scripts qui mettent en route les services du système (et 
habituellement l'information ne se situe pas dans ces fichiers, par exemple 
les systèmes RedHat stockent l'ensemble de la configuration du système 
sous <Literal remap="tt">/etc/sysconfig</Literal>, où elle est récupérée par
 les scripts de démarrage). Si vous voulez saisir les détails du processus de 
démarrage, je vous conseille de vérifier <Emphasis>/etc/inittab</Emphasis> 
ainsi que la documentation accompagnant <Emphasis>init</Emphasis>. 
Linux Journal va également publier un article 
sur l'initialisation des systèmes, et nous pointerons sur lui dès qu'il sera 
disponible sur le réseau.
</para>
<para>
La plupart des distributions récentes incluent un programme qui  
permet de configurer de nombreux types d'interfaces réseau. Si vous en 
possédez une, regardez si ce programme vous convient au lieu 
de tenter une configuration manuelle.
</para>
<para>
<Screen>
- - - - - - - - - - - - - - - - - - - - - - - 
Distrib   | Programme de configuration réseau
- - - - - - - - - - - - - - - - - - - - - - -
RedHat    | /sbin/netcfg
Slackware | /sbin/netconfig
- - - - - - - - - - - - - - - - - - - - - - -
</Screen>

<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>


<Sect1>
<title>Créer vos interfaces réseau</title>
<para>
Sur un grand nombre de systèmes Unix, les périphériques 
réseau apparaissent dans le répertoire
<Emphasis>/dev</Emphasis> . Il n'en est pas de même avec Linux. Les 
périphériques réseau  sont créés 
dynamiquement par les logiciels et ne nécessitent donc pas de fichiers de 
périphériques.
</para>
<para>
Dans la majorité des cas, le périphérique réseau 
est automatiquement créé par le gestionnaire de 
périphérique lors de son initialisation par le noyau.
Par exemple le pilote Ethernet crée
les interfaces <Literal remap="tt">eth[0..n]</Literal> une par une lorsqu'il
 détecte votre matériel Ethernet. La première carte Ethernet trouvée devient
 <Literal remap="tt">eth0</Literal>, la deuxième 
<Literal remap="tt">eth1</Literal>, etc.
</para>
<para>
Cependant, dans certains cas, notamment avec 
<Emphasis>SLIP</Emphasis> et <Emphasis>PPP</Emphasis>, les 
périphériques réseau sont créés par un programme utilisateur. Le même mécanisme 
séquentiel s'applique sur les périphériques, mais ce 
n'est pas au moment du démarrage du système. La raison en est 
que, à l'inverse des dispositifs Ethernet, le nombre de 
périphériques
 <Emphasis>slip</Emphasis> ou <Emphasis>ppp</Emphasis> actifs peut varier dans
 le temps. Nous y reviendrons plus tard.
</para>
<para>
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
<Sect1>
<title>Configurer une interface réseau. Noyaux 2.0 et 2.2</title>
<para>
Lorsque vous avez tous les programmes requis, votre adresse et les informations 
 réseau, vous pouvez alors configurer vos interfaces. Lorsque nous 
parlons de la configuration d'interface, nous faisons allusion au processus  
d'assignation des adresses du 
périphérique réseau, et au processus de réglage des paramètres configurables.
 Le programme le plus utilisé pour ce faire est la commande
<Emphasis>ifconfig</Emphasis> (interface configure).
</para>
<para>
Typiquement vous utilisez une commande comme ci-dessous :
</para>
<para>
<Screen>
root# ifconfig eth0 192.168.0.1 netmask 255.255.255.0 up
</Screen>
</para>
<para>
Dans ce cas je configure l'interface Ethernet
 `<Literal remap="tt">eth0</Literal>' avec l'adresse IP 
`<Literal remap="tt">192.168.0.1</Literal>' et un masque de réseau
 `<Literal remap="tt">255.255.255.0</Literal>'.
Le `<Emphasis>up</Emphasis>' qui termine la commande enjoint à l'interface de
 devenir active, mais il peut être omis, étant par défaut. Pour clore une 
interface, vous faites juste 
``<Literal remap="tt">ifconfig eth0 down</Literal>''.
</para>
<para>
Le noyau suppose certaines valeurs par défaut lorsque l'on configure les 
interfaces. Par exemple, vous pouvez indiquer une adresse de réseau et 
une adresse de diffusion, mais si vous ne le faites pas comme nous venons
de le faire dans l'exemple ci-dessus, alors le noyau fera certaines hypothèses  
fondées sur le masque de réseau que vous avez fourni, et si vous ne l'avez pas 
donnée, sur la classe de l'adresse IP configurée.
Dans mon exemple, le noyau considérera que c'est un réseau de classe C et 
configurera une adresse réseau de
`<Literal remap="tt">192.168.0.0</Literal>' et une adresse de diffusion 
de `<Literal remap="tt">192.168.0.255</Literal>'. 
</para>
<para>
Il y a de nombreuses autres options pour la commande
 <Emphasis>ifconfig</Emphasis> . Les plus importantes sont :
</para>
<para>
<VariableList>
<VarListEntry>
<Term>
up
</Term>
<ListItem>
<para>
active une interface (est fait par défaut).
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
down
</Term>
<ListItem>
<para>
désactive une interface.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
&lsqb;-&rsqb;arp
</Term>
<ListItem>
<para>
active ou désactive le protocole de résolution 
d'adresses sur cette interface.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
&lsqb;-&rsqb;allmulti
</Term>
<ListItem>
<para>
active ou désactive la réception de tous les paquets 
multicast matériel (Ndt : Les adresses multicast sont un genre d'adresses 
de diffusion limitées à un groupe de machine qui n'ont pas nécessairement 
besoin de se trouver sur le même sous-réseau). Le multicast matériel permet 
à des groupes d'hôtes de recevoir des paquets adressés vers des destinations 
spéciales. Ce peut être important si vous utilisez des applications comme la 
vidéoconférence, mais la plupart du temps on ne l'utilise pas.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
mtu N
</Term>
<ListItem>
<para>
ce paramètre permet de régler le <Emphasis>MTU</Emphasis> 
(Maximum Transfert Unit) sur le périphérique.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
netmask &lt;addr&#62;
</Term>
<ListItem>
<para>
ce paramètre permet de fixer le masque de réseau.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
irq &lt;addr&#62;
</Term>
<ListItem>
<para>
ce paramètre ne fonctionne qu'avec certains types de 
matériels, mais vous permet d'en fixer l'IRQ.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
&lsqb;-&rsqb;broadcast &lsqb;addr&rsqb;
</Term>
<ListItem>
<para>
permet d'activer ou de désactiver l'acceptation
 de datagrammes destinés à l'adresse de diffusion.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
&lsqb;-&rsqb;pointopoint &lsqb;addr&rsqb;
</Term>
<ListItem>
<para>
permet de fixer l'adresse de la machine à 
l'extrémité d'un lien point-à-point comme pour <Emphasis>slip</Emphasis>
ou <Emphasis>ppp</Emphasis>.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
hw &lt;type &lt;addr&#62;
</Term>
<ListItem>
<para>
permet de fixer l'adresse matérielle 
de certains périphériques réseau. Ce n'est pas souvent 
utilisé pour Ethernet, mais utile pour d'autres types de réseau 
tels que AX.25.
</para>
</ListItem>
</VarListEntry>
</VariableList>
</para>
<para>
Avec les versions 2.2 du noyau, il y a un certain nombre d'options que
nous n'avons pas énumérées ci-dessus. Parmi les plus intéressantes, citons
le tunneling et les options IPV6. Voici les paramètres ifconfig pour 
les noyaux 2.2.
</para>
<para>
<VariableList>
<VarListEntry>
<Term>
interface
</Term>
<ListItem>
<para>
Le nom de l'interface. C'est habituellement le nom d'un gestionnaire 
de périphérique suivi par un numéro d'unité, par exemple eth0 pour la première 
interface Ethernet.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
up
</Term>
<ListItem>
<para>
Ceci provoque l'activation de l'interface. C'est implicitement
spécifié si un adresse est affectée à l'interface.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
down
</Term>
<ListItem>
<para>

Ceci provoque la désactivation de l'interface. 
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
&lsqb;-&rsqb;arp
</Term>
<ListItem>
<para>
Active ou désactive l'utilisation du protocole ARP sur l'interface
considérée.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
&lsqb;-&rsqb;promisc
</Term>
<ListItem>
<para>
Active ou désactive le mode «promiscuous» sur l'interface. S'il
est choisi, tous les paquets du réseau seront reçus par
l'interface.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
&lsqb;-&rsqb;allmulti
</Term>
<ListItem>
<para>
Active ou désactive le mode «all-multicast».  S'il est choisi
tous les paquets multicast du réseau seront reçus par l'interface.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
metric N
</Term>
<ListItem>
<para>
Ce paramètre positionne le paramètre «metric» de l'interface.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
mtu N
</Term>
<ListItem>
<para>
Ce paramètre positionne le Maximum Transfer Unit (MTU) d'une interface.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
dstaddr addri
</Term>
<ListItem>
<para>
Positionne l'adresse IP distante d'un lien point-à-point
(tel que PPP). Ce mot-clé est maintenant obsolète; utilisez
à la place le mot-clé pointopoint.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
netmask addr
</Term>
<ListItem>
<para>
Positionne le masque de réseau IP de l'interface. Donne les
valeurs par défaut pour les classes habituelles de masque réseau
A, B ou C (provenant de l'adresse IP de l'interface), mais on
peut donner n'importe quelle valeur.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
add addr prefixlen
</Term>
<ListItem>
<para>
Ajoute un adresse IPv6 à l'interface.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>

<Term>
del addr prefixlen
</Term>
<ListItem>
<para>
Enlève une adresse IPv6 de l'interface.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
tunnel aa.bb.cc.dd
</Term>
<ListItem>
<para>
Crée un nouveau périphérique SIT (IPv6-in-IPv4), tunnelling vers une destination donnée.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
irq addr
</Term>
<ListItem>
<para>
Positionne l'interruption utilisée par ce périphérique.
Tous les périphériques ne sont pas capables de changer
d'IRQ de manière dynamique.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
io_addr addr
</Term>
<ListItem>
<para>
Positionne l'adresse d'entrée-sortie du périphérique.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
mem_start addr
</Term>
<ListItem>
<para>
Positionne l'adresse de début de la mémoire partagée utilisée
par le périphérique. Seuls quelques périphériques en ont besoin.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
media type
</Term>
<ListItem>
<para>
Positionne le port physique ou bien le type de matériel
qui doit être utilisé par le périphérique. Tous les
périphériques ne peuvent pas changer ce réglage, et ceux
qui peuvent le faire diffèrent quant aux valeurs qui
peuvent leur être assignées. Les valeurs typiques pour
sont 10base2 (thin Ethernet), AUI (transceiver externe) 
et autres. La valeur spéciale auto peut être utilisée pour
dire au gestionnaire de périphérique de détecter automatiquement
le périphérique. Encore une fois tous les gestionnaires de
périphérique ne peuvent faire ceci.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
&lsqb;-&rsqb;broadcast &lsqb;addr&rsqb;
</Term>
<ListItem>
<para>
Si une adresse est donnée en argument, positionne l'adresse
de protocole de diffusion de l'interface. Autrement, positionne
(ou efface) le drapeau IFF_BROADCAST de l'interface.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
&lsqb;-&rsqb;pointopoint &lsqb;addr&rsqb;
</Term>
<ListItem>
<para>
Autorise le mode point-à-point pour l'interface, ce qui
signifie qu'il existe un lien direct entre deux machines
sans que quelqu'un d'autre puisse être à l'écoute. Si une
adresse est donnée comme argument, positionne l'adresse
protocole à l'autre extrémité du lien, tout comme le faisait
la commande dstaddr, devenue obsolète. Autrement, positionne
ou efface le drapeau IFF_POINTTOPOINT de l'interface.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
hw class address
</Term>
<ListItem>
<para>
Positionne l'adresse matérielle de l'interface, si le
gestionnaire de périphérique supporte cela. Le mot-clé doit
être suivi par le nom de la classe matérielle et
l'équivalent ASCII de l'adresse matérielle. Les classes
matérielles actuellement supportées sont ether (Ethernet),
ax25 5AMPR AX.25), ARCnet et netrom (AMPR NET/ROM).
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
multicast
</Term>
<ListItem>
<para>
Positionne le drapeau multicast de l'interface. Normalement
on n'en a pas besoin étant donné que les gestionnaires de périphérique
positionne eux-mêmes le drapeau correctement.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
address
</Term>
<ListItem>
<para>
L'adresse IP que l'on doit assigner à l'interface.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
txqueuelen length
</Term>
<ListItem>
<para>
Positionne la longueur de la file de transmission du périphérique.
Il est préférable de la mettre à une valeure faible
pour les périphériques les plus lents ayant une latence (liens
modem, ISDN) pour empêcher que les grosses masses de transferts
comme telnet perturbent le trafic sur l'interface.
</para>
<para>

Vous pouvez utiliser la commande <Emphasis>ifconfig</Emphasis> pour toutes les 
interfaces réseau. Quelques programmes utilisateurs comme
 <Emphasis>pppd</Emphasis> et <Emphasis>dip</Emphasis> configurent 
automatiquement les périphériques en même temps qu'ils les créent, 
dès lors l'utilisation manuelle de <Emphasis>ifconfig</Emphasis> n'est pas 
nécessaire.

</para>
</ListItem>
</VarListEntry>
</VariableList>

<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>

<Sect1>
<title>Configurer votre solveur de noms</title>
<para>
Le `<Emphasis>Solveur de Noms</Emphasis>' (Name Resolver) fait partie de la 
bibliothèque 
standard de Linux. Sa première fonction est de convertir des noms 
d'hôtes compréhensibles par l'homme, comme
`<Literal remap="tt">ftp.funet.fi</Literal>' , en adresses IP compréhensibles
 par une machine, comme <Literal remap="tt">128.214.248.6</Literal>.
</para>
<Sect2>
<title>Qu'y a-t-il dans un nom ?</title>
<para>
Vous êtes probablement familiers avec l'aspect des noms d'hôtes 
Internet, mais vous ne savez pas comment ils sont composés ou 
décomposés. Les noms de domaine Internet sont 
hiérarchisés par nature, c'est-à-dire qu'ils ont une 
structure arborescente.
Un `<Emphasis>domaine</Emphasis>' est une famille, ou un groupe de noms. 
Un `<Emphasis>domaine</Emphasis>' peut être subdivisé en
`<Emphasis>sous-domaines</Emphasis>'. Un `<Emphasis>domaine de premier 
niveau</Emphasis>' est un domaine qui n'est pas un sous-domaine. Les Domaines 
de Premier Niveau sont spécifiés dans la RFC-920. Quelques exemples :
</para>
<para>
<VariableList>
<VarListEntry>
<Term>
COM
</Term>
<ListItem>
<para>
Organisations Commerciales
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
EDU
</Term>
<ListItem>
<para>
Organisations ayant rapport avec l'Éducation
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
GOV
</Term>
<ListItem>
<para>
Organisations Gouvernementales (NdT: parfois GOUV en France !)
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
MIL
</Term>
<ListItem>
<para>
Organisations Militaires
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
ORG
</Term>
<ListItem>
<para>
Autres organisations
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
NET
</Term>
<ListItem>
<para>
Organisations ayant un rapport avec l'internet
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
Nom de Pays
</Term>
<ListItem>
<para>
il existe des codes de deux lettres qui représentent un pays donné.
</para>
</ListItem>
</VarListEntry>
</VariableList>
</para>
<para>
Pour des raisons historiques la plupart des domaines appartenant à des
domaines qui ne sont pas basés sur des noms de pays sont pour les
organisations situées aux États-Unis, bien que les États-Unis aient aussi
le code de pays `<Literal remap="tt">.us</Literal>'. Ce n'est plus vrai pour 
les domaines <Literal remap="tt">.com</Literal>
et <Literal remap="tt">.org</Literal>, qui sont couramment utilisés par des 
sociétés hors des États-Unis.
</para>

<para>
Chacun de ces domaines de premier niveau possède des sous-domaines. Les 
domaines de premier niveau fondés sur les noms de pays sont 
divisés ensuite en sous-domaines basés sur les domaines 
<Literal remap="tt">com</Literal>, <Literal remap="tt">edu</Literal>,
 <Literal remap="tt">gov</Literal>, <Literal remap="tt">mil</Literal> et 
<Literal remap="tt">org</Literal> . Ainsi par exemple, vous 
finissez par : <Literal remap="tt">com.au</Literal> et 
<Literal remap="tt">gov.au</Literal> pour des organisations commerciales ou 
gouvernementales situées en Australie ; notez que ce n'est pas une règle
absolue, car les politiques réelles dépendant de l'autorité qui donne les noms
 pour chaque domaine.</para>
<para>
Le niveau de division suivant représente habituellement le nom de 
l'organisation. Ces sous-domaines sont variables, souvent ils sont  
fondés sur la structure en départements de l'organisation mais ils
 peuvent l'être également sur d'autres critères 
considérés comme rationnels et compréhensibles par les 
administrateurs réseau de l'organisation.
</para>
<para>
La partie tout à fait à gauche du nom est toujours le nom unique 
assigné à la machine hôte et est appelée le nom 
d'hôte `<Emphasis>hostname</Emphasis>', la partie de droite du nom est le nom 
de domaine `<Emphasis>domainname</Emphasis>' et le nom complet s'appelle le 
nom de domaine complètement qualifié
 `<Emphasis>Fully Qualified Domain Name</Emphasis>' (ou FQDN).
</para>
<para>
Si l'on examine l'adresse de la machine de Terry par exemple, 
le nom pleinement qualifié est 
`<Literal remap="tt">perf.no.itg.telstra.com.au</Literal>'. Cela veut dire
 que le nom d'hôte est `<Literal remap="tt">perf</Literal>'
et le nom de domaine `<Literal remap="tt">no.itg.telstra.com.au</Literal>'. 
Le nom de domaine est fondé sur un domaine de premier niveau basé sur son pays, 
l'Australie et comme son adresse électronique appartient à une 
organisation commerciale nous avons
`<Literal remap="tt">.com</Literal>' comme domaine de niveau adjacent. Le nom 
de la société est (était) `<Literal remap="tt">Telstra</Literal>' et notre 
structure interne de noms est basé sur la structure organisationnelle, dans 
mon cas, ma machine appartient à l'Information Technology Group, section 
Network Operations.
</para>
<para>
Habituellement, les noms sont beaucoup plus courts ; par exemple, mon
 fournisseur d'accès à l'internet est ``<Literal remap="tt">systemy.it</Literal>
'' et mon organisation à but non lucratif est 
``<Literal remap="tt">linux.it</Literal>'', sans sous-domaine 
<Literal remap="tt">com</Literal> ou <Literal remap="tt">org</Literal>, aussi 
mon propre hôte est simplement appelé 
  ``<Literal remap="tt">morgana.systemy.it</Literal>'' et 
<Literal remap="tt">rubini@linux.it</Literal> est une adresse 
  électronique valide. Notez que le propriétaire d'un domaine a le droit 
  d'enregistrer les noms d'hôtes aussi bien
  que les noms de sous-domaine ; par exemple le Groupe d'Utilisateur Linux
 auquel j'appartiens utilise le domaine 
<Literal remap="tt">pluto.linux.it</Literal>, car les propriétaires
   de <Literal remap="tt">linux.it</Literal> étaient d'accord pour créer un 
sous-domaine pour ce groupe.
</para>

</Sect2>
<Sect2>
<title>Les informations nécessaires</title>
<para>
Vous devez connaître le domaine auquel votre nom d'hôte 
appartient. Le solveur de nom effectue la traduction en faisant 
appel à un `<Emphasis>Serveur de Noms de Domaine</Emphasis>'. Vous devez 
connaître l'adresse IP d'un serveur de nom local que vous pouvez utiliser.
</para>
<para>
Il y a trois fichiers que vous devez éditer, nous en parlerons chacun 
à leur tour.
</para>
</Sect2>
<Sect2>
<title>/etc/resolv.conf</title>
<para>
Le fichier <Literal remap="tt">/etc/resolv.conf</Literal> est le fichier 
principal de configuration de la résolution de noms. Son format est très simple. 
C'est un fichier texte avec un mot-clé par ligne. Il y a trois 
mots-clés typiquement utilisés, qui sont :
</para>
<para>
<VariableList>
<VarListEntry>
<Term>
domain
</Term>
<ListItem>
<para>
ce mot-clé indique le nom de domaine local.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
search
</Term>
<ListItem>
<para>
ce mot-clé spécifie une liste d'autres noms de 
domaine pour rechercher un nom d'hôte.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>
name server
</Term>
<ListItem>
<para>
ce mot-clé, qui peut être utilisé 
plusieurs fois, spécifie l'adresse IP d'un serveur de nom de domaine 
pour la résolution de noms.
</para>
</ListItem>
</VarListEntry>
</VariableList>
</para>
<para>
Un exemple de <Literal remap="tt">/etc/resolv.conf</Literal> pourrait
 ressembler à ceci :
</para>
<para>
<Screen>
domain maths.wu.edu.au
search maths.wu.edu.au wu.edu.au
name server 192.168.10.1
name server 192.168.12.1
</Screen>
</para>
<para>
Cet exemple spécifie que le nom de domaine par défaut à 
ajouter aux noms non qualifiés (c'est-à-dire sans domaine) est
 <Literal remap="tt">maths.wu.edu.au</Literal>, et que si l'hôte n'est pas
 trouvé dans ce domaine on peut aussi essayer le domaine 
<Literal remap="tt">wu.edu.au</Literal> directement. Deux entrées de serveurs
 de noms sont fournies, chacune d'elles pouvant être appelée par le 
solveur de noms.
</para>
</Sect2>
<Sect2>
<title>/etc/host.conf</title>
<para>
Le fichier <Literal remap="tt">/etc/host.conf</Literal> sert à configurer 
certaines choses en vue de modifier le comportement du solveur de noms. Son 
format est décrit en détail dans la page de manuel
 `<Literal remap="tt">resolv+</Literal>'. Dans le plupart des cas l'exemple
 suivant vous conviendra :
</para>
<para>
<Screen>                          
order hosts,bind                                          
multi on  
</Screen>
</para>
<para>
Cette configuration indique au solveur de nom de vérifier en 
premier lieu le fichier <Literal remap="tt">/etc/hosts</Literal> avant 
d'essayer un serveur de noms. Cela permet aussi au résolveur de nom de renvoyer
toutes les adresses valables d'un hôte trouvé dans le fichier
 <Literal remap="tt">/etc/hosts</Literal> au lieu d'en donner simplement 
 la première.
</para>
</Sect2>
<Sect2>
<title>/etc/hosts</title>
<para>
Le fichier <Literal remap="tt">/etc/hosts</Literal> est l'endroit où vous mettez les noms et
 les adresses IP des hôtes locaux. Si vous mettez un hôte dans ce 
fichier, alors vous n'avez pas à interroger le serveur de nom de domaine
 pour obtenir son adresse IP. L'inconvénient est que si l'adresse de cet hôte
 a changé, vous devez tenir votre fichier à jour.
Dans un système bien administré les seuls noms d'hôtes qui 
apparaissent habituellement sont l'interface loopback, et le nom des 
hôtes locaux.
</para>
<para>
<Screen>
# /etc/hosts
127.0.0.1      localhost loopback
192.168.0.1    ma.belle.machine
</Screen>
</para>
<para>
Vous pouvez spécifier plus d'un nom d'hôte, comme montré 
dans la première entrée (qui est standard pour l'interface 
loopback).
</para>
</Sect2>

<Sect2>
<title>Faire tourner un serveur de noms</title>
<para>
Si vous voulez faire tourner un serveur de nom local, vous pouvez le
faire facilement. Voyez le <ULink URL="DNS-HOWTO.html">le DNS-HOWTO</ULink>
ainsi que tous les documents inclus dans votre version de <Emphasis>BIND</Emphasis>
(Berkeley Internet Name Domain).
</para>
</Sect2>
</Sect1>
<Sect1>
<title>Configurer votre interface loopback</title>
<para>
L'interface `<Literal remap="tt">loopback</Literal>' est un type spécial d'interface qui permet 
de vous connecter à vous-même. Il y a plusieurs raisons pour 
faire cela. Par exemple si vous voulez faire des essais de logiciel réseau 
sans interférer avec quelqu'un d'autre sur votre réseau. Par 
convention, l'adresse IP 
`<Literal remap="tt">127.0.0.1</Literal>' lui a été assignée. Aussi quelle que 
soit la machine où vous êtes, si vous ouvrez une
 connexion telnet vers
 <Literal remap="tt">127.0.0.1</Literal> vous atteindrez toujours l'hôte local.
</para>
<para>
Configurer l'interface loopback est simple et vous devez vous assurer de 
l'avoir fait (mais notez que cette tâche est habituellement effectuée
par les scripts standards d'initialisation).
</para>
<para>
<Screen>
root# ifconfig lo 127.0.0.1
root# route add -host 127.0.0.1 lo
</Screen>
</para>
<para>
Nous en dirons plus sur la commande <Emphasis>route</Emphasis> dans le prochain paragraphe.
</para>
<para>
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
<Sect1><title>Routage</title>
<para>
Le routage est un vaste sujet. On peut écrire de grandes 
quantités de textes sur ce sujet. La plupart d'entre vous ont 
besoin d'un simple routage, et certains même de rien du tout. 
Je ne parlerai 
que des principes du routage. Si vous voulez plus d'informations je vous 
suggère de vous reporter aux références 
fournies en début du document.
</para>
<para>
Commençons par une définition. Qu'est-ce que le routage IP ? 
Voici celle que j'utilise :
</para>
<para>
<QUOTE>Le routage IP est le processus par lequel un hôte, ayant des 
connexions réseau multiples, décide du chemin 
par lequel délivrer les datagrammes IP qu'il a reçus.
</QUOTE>
</para>
<para>
Il peut être utile d'illustrer cela par un exemple. Imaginez un routeur 
dans un bureau : il peut avoir un lien PPP sur l'Internet, un certain nombre de 
segments Ethernet alimentant les stations de travail et un second lien PPP vers 
un autre bureau.
Lorsque le routeur reçoit un datagramme de l'une de ses connexions, le 
routage est le mécanisme utilisé pour déterminer 
vers quelle interface il doit renvoyer ce datagramme. De simples hôtes ont 
besoin aussi de routage, tous les hôtes Internet ayant deux 
périphériques réseau, l'un étant l'interface 
loopback décrite auparavant et l'autre est celui qui est utilisé 
pour parler avec le reste du monde, soit un lien Ethernet, soit une interface 
série PPP ou SLIP.
</para>
<para>
Ok, alors comment fonctionne le routage ? Chaque hôte possède une 
liste spéciale de règles de routage, appelée une table de 
routage. Cette table contient des colonnes qui contiennent au moins trois
 champs, le premier étant une adresse de destination, le deuxième
étant le nom de l'interface vers lequel le datagramme doit être 
routé et le troisième, qui est optionnel, l'adresse IP d'une 
autre machine qui transportera le datagramme vers sa prochaine destination
 sur le réseau passerelle. Sur Linux vous pouvez voir cette table en utilisant la 
commande suivante :
</para>
<para>
<Screen>
user% cat /proc/net/route
</Screen>
</para>
<para>
ou bien en utilisant l'une des commandes suivantes :
</para>
<para>
<Screen>
user% /sbin/route -n
user% /sbin/netstat -r
</Screen>
</para>
<para>
Le processus de routage est plutôt simple : un datagramme entrant est 
reçu, l'adresse de destination est examinée et comparée 
avec chaque entrée de la table. L'entrée qui correspond le mieux 
à cette adresse est choisie, et le datagramme est renvoyé vers 
l'interface spécifiée. Si le champ passerelle est rempli, alors 
le datagramme est renvoyé vers cet hôte via l'interface 
spécifiée, sinon l'adresse de destination est 
supposée comme étant sur le réseau supporté par 
l'interface.
</para>
<para>
Pour manipuler ce tableau, une commande spéciale est utilisée. 
Cette commande prend des arguments et les convertit en appels système
pour demander au noyau d'ajouter, supprimer ou modifier des 
entrées dans la table de routage. Cette commande s'appelle
 `<Emphasis>route</Emphasis>'.
</para>
<para>
Un exemple simple. Imaginez que vous ayez un réseau Ethernet. On vous a 
dit que c'est un réseau classe C avec une adresse de
<Literal remap="tt">192.168.1.0</Literal>. On vous fournit une adresse IP 
 <Literal remap="tt">192.168.1.10</Literal> pour votre usage et on vous a dit que
 <Literal remap="tt">192.168.1.1</Literal> est un routeur connecté à l'Internet.
</para>
<para>
La première étape est de configurer l'interface comme 
indiqué plus haut. Vous utiliserez la commande :
</para>
<para>
<Screen>
root# ifconfig eth0 192.168.1.10 netmask 255.255.255.0 up
</Screen>
</para>
<para>
Maintenant vous avez besoin d'ajouter une entrée dans la table de 
routage pour indiquer au noyau que les datagrammes destinés aux
 hôtes dont 
les adresses correspondent à
 <Literal remap="tt">192.168.1.*</Literal> doivent être dirigés vers le 
périphérique Ethernet. Vous utiliserez une commande comme ceci :
</para>
<para>
<Screen>
root# route add -net 192.168.1.0 netmask 255.255.255.0 eth0
</Screen>
</para>
<para>
Notez l'utilisation de l'argument `<Literal remap="tt">-net</Literal>' pour indiquer au programme route 
que cette entrée est une route réseau.
Un autre choix peut être `<Literal remap="tt">-host</Literal>' qui est une route spécifique 
 d'une adresse IP.
</para>
<para>
Cette route vous permettra d'établir des connexions IP avec tous les 
hôtes sur votre segment Ethernet. Mais qu'en est-il des hôtes IP 
qui n'y sont pas ?
</para>
<para>
Il serait compliqué d'ajouter des routes pour chaque réseau 
destinataire, aussi il y a une astuce utilisée pour simplifier la 
tâche.
L'astuce est appelée route par `<Literal remap="tt">defaut</Literal>'. La route par 
<Literal remap="tt">defaut</Literal> 
s'adapte à toutes les destinations possibles, mais pas très 
bien, de telle sorte que si il y a une entrée qui correspond à 
l'adresse requise elle sera utilisée à la place de la route par
<Literal remap="tt">defaut</Literal>. L'idée de la route par <Literal remap="tt">defaut</Literal> est simplement de 
pouvoir dire `et tout le reste va ici'. Dans l'exemple que j'ai 
inventé, on utilisera une entrée telle que :
</para>
<para>
<Screen>
root# route add default gw 192.168.1.1 eth0
</Screen>
</para>
<para>
L'argument `<Literal remap="tt">gw</Literal>' indique à la commande route que le prochain 
argument est l'adresse IP, ou le nom, d'une passerelle (gateway) ou 
d'une machine routeur 
vers qui tous les datagrammes correspondant à cette entrée
 seront dirigés pour  routage ultérieur.
</para>
<para>
Ainsi votre configuration complète sera :
</para>
<para>
<Screen>
root# ifconfig eth0 192.168.1.10 netmask 255.255.255.0 up
root# route add -net 192.168.1.0 netmask 255.255.255.0 eth0
root# route add default gw 192.168.1.1 eth0
</Screen>
</para>
<para>
Si vous regardez bien vos fichiers `<Literal remap="tt">rc</Literal>' qui concernent le réseau
vous en trouverez 
au moins un très semblable à celui-ci. C'est une configuration 
courante.
</para>
<para>
Examinons maintenant une configuration un peu plus compliquée. Imaginons
 que nous configurions le routeur examiné auparavant, celui qui avait 
un lien PPP vers l'Internet et des segments LAN alimentant des stations de 
travail dans le bureau. Supposons que ce routeur ait 3 segments Ethernet et un 
lien PPP. Notre configuration de routage ressemblerait à ceci :
</para>
<para>
<Screen>
root# route add -net 192.168.1.0 netmask 255.255.255.0 eth0
root# route add -net 192.168.2.0 netmask 255.255.255.0 eth1
root# route add -net 192.168.3.0 netmask 255.255.255.0 eth2
root# route add default ppp0
</Screen>
</para>
<para>
Chacune des stations de travail utilisera le format plus simple 
décrit ci-dessus, seul le routeur aura besoin d'indiquer les 
routes réseau séparément car pour les stations de travail 
le mécanisme de routage par
 <Literal remap="tt">defaut</Literal> les capturera toutes, laissant au routeur le soin de les 
séparer de manière appropriée. Vous pouvez vous demander 
pourquoi la route par défaut n'utilise pas 
 `<Literal remap="tt">gw</Literal>'.
La raison en est très simple : les protocoles de lien série comme 
PPP et SLIP ont seulement deux hôtes sur leur réseau, un à 
chaque bout. Spécifier à l'hôte que l'autre bout de la 
liaison est une passerelle est sans objet et redondant, car il n'a pas d'autre 
choix, aussi vous n'avez pas à indiquer de passerelle pour ce type de 
connexions réseau. Les autres types comme Ethernet, 
arcnet ou token ring ont besoin que l'on indique une passerelle car ces 
 réseaux supportent un grand nombre d'hôtes.
</para>

<Sect2>
<title>Alors, que fait le programme <Emphasis>routed</Emphasis> ?</title>
<para>
La configuration de routage décrite ci-dessus est bien adaptée 
aux réseaux simples où il n'y a que des chemins 
uniques entre les destinations. Lorsque vous avez un 
réseau plus complexe les choses deviennent plus compliquées. 
Heureusement pour la plupart d'entre vous, ce ne sera pas le cas.
</para>
<para>
Le gros problème est qu'avec le `routage manuel' ou `routage statique' 
comme décrit ci-dessus, si une machine ou un lien tombe en 
panne dans le réseau, alors la seule façon de diriger vos 
datagrammes vers un autre chemin, s'il existe, est d'intervenir manuellement et 
d'exécuter les commandes adéquates. Naturellement c'est lourd, 
lent, peu pratique et source de risques. Des techniques variées ont 
été développées pour régler automatiquement 
les tables de routage dans le cas d'incidents sur un réseau où 
il y a plusieurs routes possibles, toutes ces techniques étant 
regroupées sous le nom de `protocoles de routage dynamique'.
</para>
<para>
Vous avez peut-être entendu parler des plus courants. Ce sont 
 RIP
(Routing Information Protocol) et OSPF (Open
Shortest Path First Protocol). RIP est très souvent utilisé
sur les petits 
ou moyens réseaux d'entreprise. L'OPSF est plus moderne et plus apte 
à gérer de grands réseaux et mieux adapté dans le 
cas où il y a un grand nombre de chemins possibles à travers le 
réseau. 
Les implémentations usuelles de ces protocoles sont :
 `<Emphasis>routed</Emphasis>' - RIP, et `<Emphasis>gated</Emphasis>' - RIP, OSPF et autres.
Le programme `<Emphasis>routed</Emphasis>' est normalement fourni avec votre distribution 
Linux ou est inclus dans la paquetage `NetKit' décrit auparavant.
</para>
<para>
Un exemple pour vous montrer comment et où vous 
pouvez utiliser un protocole de routage 
dynamique ressemblerait à ceci :
</para>
<para>
<Screen>






    192.168.1.0 /                         192.168.2.0 /
       255.255.255.0                         255.255.255.0
     -                                     -
     |                                     |
     |   /- - -\                 /- - -\   |
     |   |     |ppp0   //    ppp0|     |   |
eth0 |- -|  A  |- - - //- - - - -|  B  |- -| eth0
     |   |     |     //          |     |   |
     |   \- - -/                 \- - -/   |
     |      \ ppp1             ppp1 /      |
     -       \                     /       -
              \                   /
               \                 /
                \               /
                 \             /
                  \           /
                   \         /
                    \       /
                     \     /
                  ppp0\   /ppp1
                     /- - -\
                     |     |
                     |  C  |
                     |     |
                     \- - -/
                        |eth0
                        |
                   |- - - - -|
                   192.168.3.0 /
                      255.255.255.0

</Screen>
</para>
<para>
Nous avons trois routeurs A, B et C. Chacun supporte un segment Ethernet avec 
un réseau IP de classe C
(masque de réseau 255.255.255.0). Chaque routeur a également une 
liaison PPP vers chacun des autres routeurs. Ce réseau forme un triangle.
</para>
<para>
Il est évident que la table de routage sur le routeur A ressemble 
à ceci :
</para>
<para>
<Screen>
root# route add -net 192.168.1.0 netmask 255.255.255.0 eth0
root# route add -net 192.168.2.0 netmask 255.255.255.0 ppp0
root# route add -net 192.168.3.0 netmask 255.255.255.0 ppp1
</Screen>
</para>
<para>Cela fonctionnera bien jusqu'à ce que le lien entre A et B tombe en 
panne.  
Les hôtes sur le segment A (voir le diagramme ci-dessus) ne peuvent pas atteindre 
les hôtes sur le segment B : leurs datagrammes seront dirigés 
sur le lien ppp0 du routeur A qui est rompu.
Ils pourront encore continuer à parler aux hôtes du segment C, 
et les hôtes du segment C pourront toujours parler à ceux du 
segment B car la liaison reste intacte. 
</para>
<para>
Si A peut parler à C et si C peut toujours parler à B,  
pourquoi A ne routerait-il pas ses datagrammes pour B via C, et laisser ensuite 
C les envoyer à B ? C'est exactement le type de problèmes que les 
protocoles de routage dynamique comme RIP sont en mesure de résoudre. 
Si chacun des routeurs A, B et C utilisent un démon de routage 
(NdT: démon est une 
francisation familière du vocable informatique anglais daemon, qui
signifie Disk And Extension MONitor, c'est à dire qui n'est pas invoqué 
manuellement mais attend en tâche de fond que quelque chose se passe, que 
quelque condition se produise. Ce terme fut introduit au départ sous CTSS 
(Compatible Time Sharing System), un ancêtre du système MULTICS, lui-même 
parent d'UNIX (voir la traduction de René Cougnenc de `Le système Linux' de 
M. Welsh et L. Kaufman chez O'Reilly International Thomson), alors 
leurs tables de routage seront automatiquement réglées pour 
refléter le nouvel état du réseau même si 
l'une des liaisons est défectueuse. Configurer un tel 
réseau est simple, sur chaque routeur vous devez seulement faire deux 
choses. Dans ce cas, pour le routeur A :
</para>
<para>
<Screen>
root# route add -net 192.168.1.0 netmask 255.255.255.0 eth0
root# /usr/sbin/routed
</Screen>
</para>
<para>
Le démon de routage `<Emphasis>routed</Emphasis>' trouve automatiquement tous les ports 
actifs vers le réseau quand il démarre et écoute tous les 
messages sur chacun des périphériques réseau ce qui lui
permet de déterminer et de mettre à jour sa table de routage. 
</para>
<para>
C'était une très brève explication du routage dynamique et 
de son utilisation. Si vous voulez d'avantage d'explications 
reportez-vous aux références listées en 
début de document.
</para>
<para>
Les points importants relatifs au routage dynamique sont :
</para>
<para>
<OrderedList>
<ListItem>
<para>
Vous n'avez besoin d'utiliser un démon de routage 
dynamique que quand votre machine Linux peut choisir entre
plusieurs routes pour une destination donnée. C'est la cas par exemple
lorsque vous envisagez d'utiliser IP masquerade.
</para>
</ListItem>
<ListItem>
<para>
Le démon de routage dynamique modifiera automatiquement votre 
table de routage pour tenir compte des changements 
survenus dans votre réseau.
</para>
</ListItem>
<ListItem>
<para>
RIP est adapté aux réseaux de petite et moyenne taille.
</para>
</ListItem>
</OrderedList>
</para>
</Sect2>
</Sect1>

<Sect1>
<title>Configurer vos serveurs réseau et les services.</title>
<para>
Les serveurs de réseau et les services sont des programmes qui 
permettent à un utilisateur distant de devenir utilisateur de votre 
machine Linux. Les programmes serveurs sont à l'écoute des ports réseau. 
Les ports réseau permettent de demander un service particulier à un hôte 
particulier  et de faire la différence entre une connexion telnet entrante 
et une connexion ftp entrante. L'utilisateur distant établit une connexion 
réseau avec votre machine puis le programme serveur, ou 
démon de réseau, à l'écoute du port, accepte la connexion et 
s'exécute. Il y a deux façons d'opérer pour les démons de réseau. 
 Les deux sont couramment utilisés en pratique. Ce sont :
</para>
<para>
<VariableList>
<VarListEntry>
<Term>autonome</Term>
<ListItem>
<para>
le programme démon écoute le 
port réseau désigné et lorsqu'il y a une connexion, il 
prend lui-même la connexion en charge pour fournir le service.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>esclave du serveur <Emphasis>inetd</Emphasis> </Term>
<ListItem>
<para>
le serveur <Emphasis>inetd</Emphasis> est un programme
 démon spécial spécialisé dans la conduite 
des connexions réseau. Il possède un fichier de configuration qui
 indique quel programme doit être utilisé lorsqu'une connexion 
entrante est reçue. Chacun des ports service doit être configuré soit avec le protocole tcp, soit avec le protocole udp. 
 Les ports sont décrits dans un autre fichier dont nous parlerons plus tard.
</para>
</ListItem>
</VarListEntry>
</VariableList>
</para>
<para>Il existe deux fichiers importants qui doivent être configurés :
<Literal remap="tt">/etc/services</Literal> qui assigne des noms aux numéros de port et
<Literal remap="tt">/etc/inetd.conf</Literal> qui sert pour la configuration du démon de 
réseau 
<Emphasis>inetd</Emphasis> .
</para>

<Sect2>
<title><Literal remap="tt">/etc/services</Literal></title>
<para>
Le fichier <Literal remap="tt">/etc/services</Literal> est une simple base de données qui 
associe des noms compréhensibles par l'homme à des ports service 
compréhensibles par la machine. Son format est tout à fait 
simple. Le fichier est un fichier texte dont chaque ligne représente une
 entrée de la base de données. Chaque entrée comprend 
trois champs séparés par des caractères espace ou tabulation. Ces champs sont :
</para>
<para>
nom      port/protocole        alias     # commentaire
</para>
<para>
<VariableList>
<VarListEntry>
<Term>nom</Term>
<ListItem>
<para>
un simple mot qui représente le service décrit.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>port/protocole</Term>
<ListItem>
<para>
ce champ est divisé en deux.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>port</Term>
<ListItem>
<para>
un nombre qui spécifie le numéro de port 
où le service désigné sera disponible. La plupart des 
services ont des numéros assignés. Ils sont décrits dans la
	<Literal remap="tt">RFC-1340</Literal>.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
	<Term>protocole</Term>
<ListItem>
<para>
c'est soit <Literal remap="tt">tcp</Literal> soit
	 <Literal remap="tt">udp</Literal>.
</para>
<para>
Il est important de noter qu'une entrée comme <Literal remap="tt">18/tcp</Literal> est 
très différente de 
 <Literal remap="tt">18/udp</Literal> et qu'il n'y a pas de raisons techniques que le même 
service existe sur les deux. Normalement le bon sens prévaut et c'est 
vraiment pour un service particulier disponible  à la fois sur
 <Literal remap="tt">tcp</Literal>
et <Literal remap="tt">udp</Literal> que vous verrez une entrée pour les deux..
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>aliases</Term>
<ListItem>
<para>
Autres noms qui peuvent être utilisés pour se référer à un service.
</para>
</ListItem>
</VarListEntry>
</VariableList>
</para>
<para>Tout texte apparaissant après le caractère `<Literal remap="tt">&num;</Literal>' est 
ignoré et traité comme commentaire.
</para>

<Sect3>
<title>Exemple de fichier <Literal remap="tt">/etc/services</Literal>.</title>
<para>
Toutes les distributions récentes de Linux fournissent un bon fichier  
<Literal remap="tt">/etc/services</Literal>.
Juste au cas où vous construiriez tout depuis 
le départ, voici une 
copie du fichier 
<Literal remap="tt">/etc/services</Literal> fourni avec l'ancienne distribution
<ULink URL="http://www.debian.org/">Debian</ULink> .
</para>
<para>
<Screen>
# /etc/services:
# $Id: Net-HOWTO.sgml,v 1.1.1.1 2001/01/17 19:55:16 lx Exp $
#
# Network services, Internet style
#
# Notez que c'est la politique actuelle de l'IANA d'assigner un seul numéro
# de port à la fois pour TCP et UDP; ainsi, la plupart des ports ont deux
# entrées même si le protocole ne supporte pas UDP.
# Mis à jour d'après la RFC 1340, ``Assigned Numbers'' (Juillet 1992). 
# Il n'y a pas tous les ports, seulement les plus courants.

tcpmux		1/tcp				# TCP port service multiplexer
echo		7/tcp
echo		7/udp
discard		9/tcp		sink null
discard		9/udp		sink null
systat		11/tcp		users
daytime		13/tcp
daytime		13/udp
netstat		15/tcp
qotd		17/tcp		QUOTE
msp		18/tcp				# message send protocol
msp		18/udp				# message send protocol
chargen		19/tcp		ttytst source
chargen		19/udp		ttytst source
ftp-data	20/tcp
ftp		21/tcp
ssh		22/tcp				# SSH Remote Login Protocol
ssh		22/udp				# SSH Remote Login Protocol
telnet		23/tcp
# 24 - private
smtp		25/tcp		mail
# 26 - non assigné
time		37/tcp		timserver
time		37/udp		timserver
rlp		39/udp		resource	# resource location
nameserver	42/tcp		name		# IEN 116
whois		43/tcp		nicname
re-mail-ck	50/tcp				# Remote Mail Checking Protocol
re-mail-ck	50/udp				# Remote Mail Checking Protocol
domain		53/tcp		nameserver	# name-domain server
domain		53/udp		nameserver
mtp		57/tcp				# deprecated
bootps		67/tcp				# BOOTP server
bootps		67/udp
bootpc		68/tcp				# BOOTP client
bootpc		68/udp
tftp		69/udp
gopher		70/tcp				# Internet Gopher
gopher		70/udp
rje		77/tcp		netrjs
finger		79/tcp
www		80/tcp		http		# WorldWideWeb HTTP
www		80/udp				# HyperText Transfer Protocol
link		87/tcp		ttylink
kerberos	88/tcp		kerberos5 krb5	# Kerberos v5
kerberos	88/udp		kerberos5 krb5	# Kerberos v5
supdup		95/tcp
# 100 - reserve
hostnames	101/tcp		hostname	# usually from sri-nic
iso-tsap	102/tcp		tsap		# part of ISODE.
csnet-ns	105/tcp		cso-ns		# also used by CSO name server
csnet-ns	105/udp		cso-ns
rtelnet		107/tcp				# Remote Telnet
rtelnet		107/udp
pop-2		109/tcp		postoffice	# POP version 2
pop-2		109/udp
pop-3		110/tcp				# POP version 3
pop-3		110/udp
sunrpc		111/tcp		portmapper	# RPC 4.0 portmapper TCP
sunrpc		111/udp		portmapper	# RPC 4.0 portmapper UDP
auth		113/tcp		authentication tap ident
sftp		115/tcp
uucp-path	117/tcp
nntp		119/tcp		readnews untp	# USENET News Transfer Protocol
ntp		123/tcp
ntp		123/udp				# Network Time Protocol
netbios-ns	137/tcp				# NETBIOS Name Service
netbios-ns	137/udp
netbios-dgm	138/tcp				# NETBIOS Datagram Service
netbios-dgm	138/udp
netbios-ssn	139/tcp				# NETBIOS session service
netbios-ssn	139/udp
imap2		143/tcp				# Interim Mail Access Proto v2
imap2		143/udp
snmp		161/udp				# Simple Net Mgmt Proto
snmp-trap	162/udp		snmptrap	# Traps for SNMP
cmip-man	163/tcp				# ISO mgmt over IP (CMOT)
cmip-man	163/udp
cmip-agent	164/tcp
cmip-agent	164/udp
xdmcp		177/tcp				# X Display Mgr. Control Proto
xdmcp		177/udp
nextstep	178/tcp		NeXTStep NextStep	# NeXTStep window
nextstep	178/udp		NeXTStep NextStep	# server
bgp		179/tcp				# Border Gateway Proto.
bgp		179/udp
prospero	191/tcp				# Cliff Neuman's Prospero
prospero	191/udp
irc		194/tcp				# Internet Relay Chat
irc		194/udp
smux		199/tcp				# SNMP Unix Multiplexer
smux		199/udp
at-rtmp		201/tcp				# AppleTalk routing
at-rtmp		201/udp
at-nbp		202/tcp				# AppleTalk name binding
at-nbp		202/udp
at-echo		204/tcp				# AppleTalk echo
at-echo		204/udp
at-zis		206/tcp				# AppleTalk zone information
at-zis		206/udp
z3950		210/tcp		wais		# NISO Z39.50 database
z3950		210/udp		wais
ipx		213/tcp				# IPX
ipx		213/udp
imap3		220/tcp				# Interactive Mail Access
imap3		220/udp				# Protocol v3
ulistserv	372/tcp				# UNIX Listserv
ulistserv	372/udp
#
# services spécifiques à UNIX
#
exec		512/tcp
biff		512/udp		comsat
login		513/tcp
who		513/udp		whod
shell		514/tcp		cmd		# no passwords used
syslog		514/udp
printer		515/tcp		spooler		# line printer spooler
talk		517/udp
ntalk		518/udp
route		520/udp		router routed	# RIP
timed		525/udp		timeserver
tempo		526/tcp		newdate
courier		530/tcp		rpc
conference	531/tcp		chat
netnews		532/tcp		readnews
netwall		533/udp				# -for emergency broadcasts
uucp		540/tcp		uucpd		# uucp daemon
remotefs	556/tcp		rfs_server rfs	# Brunhoff remote filesystem
klogin		543/tcp				# Kerberized `rlogin' (v5)
kshell		544/tcp		krcmd		# Kerberized `rsh' (v5)
kerberos-adm	749/tcp				# Kerberos `kadmin' (v5)
#
webster		765/tcp				# Network dictionary
webster		765/udp
#
# D'après ``Assigned Numbers'' :
#
#&#62; Les Ports Enregistrés ne sont pas contrôlés par l'IANA et peuvent être
#&#62; utilisés sur la plupart des systèmes par des processus ordinaires
#&#62; ou des programmes exécutés par des utilisateurs ordinaires.
#
#&#62;Les ports sont utilisés dans le TCP [45,106] pour nommer les extrémités
#&#62; des connexions logiques qui transportent les conversations de longue
#&#62; durée. Pour offrir des services à des utilisateurs non connus, un port 
#&#62; de service pour contact a été défini. Cette liste spécifie le port utilisé
#&#62; par le processus serveur ainsi que son port de contact. Comme l'IANA ne peut
#&#62; contrôler l'usage de ces ports, on donne ici une liste d'utilisation
#&#62; de ces ports pour être agréable à la communauté.
#
ingreslock	1524/tcp
ingreslock	1524/udp
prospero-np	1525/tcp		# Prospero non-privileged
prospero-np	1525/udp
rfe		5002/tcp		# Radio Free Ethernet
rfe		5002/udp		# Actually uses UDP only
bbs		7000/tcp		# BBS service
#
#
# services Kerberos (Project Athena/MIT) 
# Notez que ceux-ci sont pour Kerberos v4, et ne sont pas officiels. Les sites
# tournant sous v4 doivent utiliser ceux-ci et annuler les entrées v5 ci-dessus.
#
kerberos4	750/udp		kdc	# Kerberos (server) udp
kerberos4	750/tcp		kdc	# Kerberos (server) tcp
kerberos_master	751/udp			# Kerberos authentication
kerberos_master	751/tcp			# Kerberos authentication
passwd_server	752/udp			# Kerberos passwd server
krb_prop	754/tcp			# Kerberos slave propagation
krbupdate	760/tcp		kreg	# Kerberos registration
kpasswd		761/tcp		kpwd	# Kerberos "passwd"
kpop		1109/tcp		# Pop with Kerberos
knetd		2053/tcp		# Kerberos de-multiplexor
zephyr-srv	2102/udp		# Zephyr server
zephyr-clt	2103/udp		# Zephyr serv-hm connection
zephyr-hm	2104/udp		# Zephyr hostmanager
eklogin		2105/tcp		# Kerberos encrypted rlogin
#
# Services non officiels mais nécessaires (pour NetBSD) 
#
supfilesrv	871/tcp			# SUP server
supfiledbg	1127/tcp		# SUP debugging
#
# Services protocole de délivrance de datagrammes
#
rtmp		1/ddp			# Routing Table Maintenance Protocol
nbp		2/ddp			# Name Binding Protocol
echo		4/ddp			# AppleTalk Echo Protocol
zip		6/ddp			# Zone Information Protocol
#
# Services Debian GNU/Linux
rmtcfg		1236/tcp		# Gracilis Packeten remote config server
xtel		1313/tcp		# french minitel
cfinger		2003/tcp		# GNU Finger
postgres	4321/tcp		# POSTGRES
mandelspawn	9359/udp	mandelbrot	# network mandelbrot

# Services locaux
</Screen>
</para>
<para>
Dans la réalité, le fichier augmente toujours en taille au fur et à mesure
que de nouveaux services apparaissent. Si vous craignez que votre copie 
soit incomplète, je vous suggère de copier un nouveau fichier <Literal remap="tt">/etc/services</Literal> provenant d'une distribution récente.
</para>
</Sect3>
</Sect2>

<Sect2>
<title><Literal remap="tt">/etc/inetd.conf</Literal></title>
<para>
Le fichier <Literal remap="tt">/etc/inetd.conf</Literal> est le fichier de configuration du serveur 
démon
<Emphasis>inetd</Emphasis> . Il sert à dire à <Emphasis>inetd</Emphasis> ce qu'il doit faire 
lorsqu'il reçoit une demande de connexion pour un service particulier.
Pour les services où vous acceptez une connexion vous devez dire
à <Emphasis>inetd</Emphasis> quel démon serveur de réseau doit tourner, et comment. 
</para>
<para>
Son format est aussi très simple. C'est un fichier texte dont chaque 
ligne décrit un service que vous voulez fournir. Tout texte suivant un
 `<Literal remap="tt">&num</Literal>'
est ignoré et considéré comme commentaire. Chaque ligne
 contient sept champs séparés par un nombre quelconque d'espaces 
(espace ou tabulation). Le format général est comme suit :
</para>
<para>
<Screen>
service  type_de_socket  protocole  drapeaux  utilisateur  chemin  arguments
</Screen>
</para>
<para>
<VariableList>
<VarListEntry>
<Term>service</Term>
<ListItem>
<para>
est le nom de service applicable à cette configuration, pris 
dans le fichier <Literal remap="tt">/etc/services</Literal>.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>type_de_socket</Term>
<ListItem>
<para>
ce champ décrit le type de socket que cette 
entrée considère comme pertinent. Voici les valeurs qui sont autorisées :
<Literal remap="tt">stream</Literal>, <Literal remap="tt">dgram</Literal>, <Literal remap="tt">raw</Literal>, <Literal remap="tt">rdm</Literal>, ou <Literal remap="tt">seqpacket</Literal>. 
C'est un peu technique par nature, mais par expérience, presque tous 
les services basés sur <Literal remap="tt">tcp</Literal> utilisent  <Literal remap="tt">stream</Literal> et presque tous 
les services basés sur <Literal remap="tt">udp</Literal>  utilisent <Literal remap="tt">dgram</Literal>. 
Il n'y a que quelques types de serveurs démons spéciaux utilisant d'autres 
valeurs.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>protocole</Term>
<ListItem>
<para>
le protocole considéré comme valide pour 
cette entrée. Il doit correspondre à l'entrée appropriée dans le fichier
 <Literal remap="tt">/etc/services</Literal> et sera donc soit <Literal remap="tt">tcp</Literal> soit <Literal remap="tt">udp</Literal>. 
 Les serveurs basés sur Sun RPC (Remote Procedure Call) utilisent
<Literal remap="tt">rpc/tcp</Literal> ou <Literal remap="tt">rpc/udp</Literal>.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>drapeaux</Term>
<ListItem>
<para>
il n'y a en fait que deux valeurs pour ce champ. Celles-ci 
 disent à <Emphasis>inetd</Emphasis> si le programme serveur réseau libère le socket 
aprés démarrage, et donc si 
 <Emphasis>inetd</Emphasis> peut prendre en compte une des prochaines demandes de connexion, ou 
bien si <Emphasis>inetd</Emphasis> doit attendre qu'un autre démon serveur tournant 
déjà prenne en charge la nouvelle demande de connexion.
 C'est encore compliqué, mais en pratique tous les serveurs
 <Literal remap="tt">tcp</Literal> doivent avoir cette entrée positionnée sur 
<Literal remap="tt">nowait</Literal> et la plupart des serveurs
 <Literal remap="tt">udp</Literal> ont cette entrée positionnée sur <Literal remap="tt">wait</Literal>. 
Attention il y a quelques exceptions notables, laissez vous guider par 
l'exemple suivant si vous n'êtes pas sûrs.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>utilisateur</Term>
<ListItem>
<para>
ce champ décrit quel compte utilisateur extrait de
<Literal remap="tt">/etc/passwd</Literal> sera considéré comme propriétaire du démon 
réseau lorsqu'il est lancé.  C'est très utile lorsque vous voulez vous 
protéger contre les trous de sécurité. Vous pouvez mettre <Literal remap="tt">nobody</Literal> 
comme utilisateur pour une entrée si bien que dans le cas où le réseau 
comporte une brèche, les dommages éventuels seront minimisés.
Cependant habituellement ce champ est réglé sur <Literal remap="tt">root</Literal>, car 
de nombreux serveurs ont besoin des privilèges de root pour tourner 
correctement.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>chemin&lowbar;de&lowbar;serveur</Term>
<ListItem>
<para>
ce champ est le véritable chemin d'accès au programme.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>arguments</Term>
<ListItem>
<para>
ce champ correspond au reste de la ligne et est optionnel. 
Il sert à indiquer les arguments de commande que vous voulez passer au 
programme serveur au lancement.
</para>
</ListItem>
</VarListEntry>
</VariableList>
</para>

<Sect3>
<title>Exemple de fichier <Literal remap="tt">/etc/inetd.conf</Literal></title>
<para>
Comme pour le fichier <Literal remap="tt">/etc/services</Literal>, toutes les distributions modernes 
incluent un bon fichier
 <Literal remap="tt">/etc/inetd.conf</Literal> pour pouvoir travailler. Ici, pour 
être complet , vous trouverez le fichier 
 <Literal remap="tt">/etc/inetd.conf</Literal> de la distribution
<ULink URL="http://www.debian.org/">Debian</ULink>.
</para>
<para>
<Screen>
# /etc/inetd.conf:  voir inetd(8) pour d'autres informations.
#
# Base de données pour la configuration d'un serveur Internet 
#
#
# Modifié pour Debian par Peter Tobias &#60;tobias@et-inf.fho-emden.de&#62;
#
# &#60;service_name&#62; &#60;sock_type&#62; &#60;proto&#62; &#60;flags&#62; &#60;user&#62; &#60;server_path&#62; &#60;args&#62;
#
# Services internes
#
#echo		stream	tcp	nowait	root	internal
#echo		dgram	udp	wait	root	internal
discard		stream	tcp	nowait	root	internal
discard		dgram	udp	wait	root	internal
daytime		stream	tcp	nowait	root	internal
daytime		dgram	udp	wait	root	internal
#chargen	stream	tcp	nowait	root	internal
#chargen	dgram	udp	wait	root	internal
time		stream	tcp	nowait	root	internal
time		dgram	udp	wait	root	internal
#
# Services standards.
#
telnet	stream	tcp	nowait	root	/usr/sbin/tcpd	/usr/sbin/in.telnetd
ftp	stream	tcp	nowait	root	/usr/sbin/tcpd	/usr/sbin/in.ftpd
#fsp	dgram	udp	wait	root	/usr/sbin/tcpd	/usr/sbin/in.fspd
#
# Shell, login, exec et talk sont des protocoles BSD.
#
shell	stream	tcp	nowait	root	/usr/sbin/tcpd	/usr/sbin/in.rshd
login	stream	tcp	nowait	root	/usr/sbin/tcpd	/usr/sbin/in.rlogind
#exec	stream	tcp	nowait	root	/usr/sbin/tcpd	/usr/sbin/in.rexecd
talk	dgram	udp	wait	root	/usr/sbin/tcpd	/usr/sbin/in.talkd
ntalk	dgram	udp	wait	root	/usr/sbin/tcpd	/usr/sbin/in.ntalkd
#
# Services Mail, news et uucp.
#
smtp	stream	tcp	nowait	root	/usr/sbin/tcpd	/usr/sbin/in.smtpd  
#nntp	stream	tcp	nowait	news	/usr/sbin/tcpd	/usr/sbin/in.nntpd
#uucp	stream	tcp	nowait	uucp	/usr/sbin/tcpd	/usr/lib/uucp/uucico
#comsat	dgram	udp	wait	root	/usr/sbin/tcpd	/usr/sbin/in.comsat
#
# Pop et autres
#
#pop-2	stream	tcp	nowait	root	/usr/sbin/tcpd	/usr/sbin/in.pop2d
#pop-3	stream	tcp	nowait	root	/usr/sbin/tcpd	/usr/sbin/in.pop3d
#
# `cfinger' est le serveur finger GNU de Debian.  (NOTE : L'implémentation
# habituelle du démon `finger' permet de le faire tourner avec `root'.)
#
#cfinger stream	tcp	nowait	root	/usr/sbin/tcpd	/usr/sbin/in.cfingerd
#finger	stream	tcp	nowait	root	/usr/sbin/tcpd	/usr/sbin/in.fingerd
#netstat	stream	tcp	nowait	nobody	/usr/sbin/tcpd	/bin/netstat
#systat	stream	tcp	nowait	nobody	/usr/sbin/tcpd	/bin/ps -auwwx
#
# Le service tftp est fourni principalement pour démarrer. La plupart des sites
# l'utilisent seulement sur les machines servant de `serveurs de boot'.
#
#tftp	dgram	udp	wait	nobody	/usr/sbin/tcpd	/usr/sbin/in.tftpd
#tftp	dgram	udp	wait	nobody	/usr/sbin/tcpd	/usr/sbin/in.tftpd /boot
#bootps	dgram	udp	wait	root	/usr/sbin/bootpd	bootpd -i -t 120
#
# Services Kerberos (ils doivent probablement être corrigés)
#
#klogin		stream	tcp	nowait	root	/usr/sbin/tcpd	/usr/sbin/in.rlogind -k
#eklogin	stream	tcp	nowait	root	/usr/sbin/tcpd	/usr/sbin/in.rlogind -k -x
#kshell		stream	tcp	nowait	root	/usr/sbin/tcpd	/usr/sbin/in.rshd -k
#
# Services tournant UNIQUEMENT sur Kerberos (doivent être probablement corrigés)
#
#krbupdate	stream tcp	nowait	root	/usr/sbin/tcpd	/usr/sbin/registerd
#kpasswd	stream	tcp	nowait	root	/usr/sbin/tcpd	/usr/sbin/kpasswdd
#
# Services RPC
#
#mountd/1	dgram	rpc/udp	wait	root	/usr/sbin/tcpd	/usr/sbin/rpc.mountd
#rstatd/1-3	dgram	rpc/udp	wait	root	/usr/sbin/tcpd	/usr/sbin/rpc.rstatd
#rusersd/2-3	dgram	rpc/udp	wait	root	/usr/sbin/tcpd	/usr/sbin/rpc.rusersd
#walld/1	dgram	rpc/udp	wait	root	/usr/sbin/tcpd	/usr/sbin/rpc.rwalld
#
# Fin de inetd.conf.
ident		stream	tcp	nowait	nobody	/usr/sbin/identd       identd -i
</Screen>
</para>
</Sect3>
</Sect2>
</Sect1>

<Sect1>
<title>Autres fichiers de configuration ayant un rapport avec le réseau</title>
<para>
Il y a de nombreux fichiers relatifs à la configuration réseau 
sous Linux et qui sont susceptibles de vous intéresser. Vous n'aurez jamais à 
modifier ces fichiers, mais il est utile de les décrire pour que 
vous sachiez ce qu'ils contiennent et quelle est leur utilité.
</para>

<Sect2>
<title><Literal remap="tt">/etc/protocols</Literal></title>
<para>
Le fichier <Literal remap="tt">/etc/protocols</Literal> est une base de données qui donne la 
relation des numéros id de protocole avec leurs noms. 
Il est utilisé
 par les programmeurs pour leur permettre de spécifier les protocoles 
par leur nom dans les programmes et aussi par quelques programmes tels que
 <Emphasis>tcpdump</Emphasis> pour pouvoir afficher en sortie des noms au lieu de 
chiffres. La syntaxe générale de ce fichier est :
</para>
<para>
<Screen>
nom du protocole     numéro    alias
</Screen>
</para>
<para>
Le fichier <Literal remap="tt">/etc/protocols</Literal> fourni avec la distribution
<ULink URL="http://www.debian.org/">Debian</ULink> est le suivant :
</para>
<para>
<Screen>
# /etc/protocols:
# $Id: Net-HOWTO.sgml, v 1.1.1.1 2001/01/17 19:55:16 lx Exp $
#
# Protocoles Internet (IP) 
#
#	d'après: @(#)protocols	5.1 (Berkeley) 4/17/89
#
# Mise à jour pour NetBSD basee sur la RFC 1340, Assigned Numbers (July 1992).

ip	0	IP		# internet protocol, pseudo protocol number
icmp	1	ICMP		# internet control message protocol
igmp	2	IGMP		# Internet Group Management
ggp	3	GGP		# gateway-gateway protocol
ipencap	4	IP-ENCAP	# IP encapsulated in IP (officially ``IP'')
st	5	ST		# ST datagram mode
tcp	6	TCP		# transmission control protocol
egp	8	EGP		# exterior gateway protocol
pup	12	PUP		# PARC universal packet protocol
udp	17	UDP		# user datagram protocol
hmp	20	HMP		# host monitoring protocol
xns-idp	22	XNS-IDP		# Xerox NS IDP
rdp	27	RDP		# "reliable datagram" protocol
iso-tp4	29	ISO-TP4		# ISO Transport Protocol class 4
xtp	36	XTP		# Xpress Tranfer Protocol
ddp	37	DDP		# Datagram Delivery Protocol
idpr-cmtp	39	IDPR-CMTP	# IDPR Control Message Transport
rspf	73	RSPF		# Radio Shortest Path First.
vmtp	81	VMTP		# Versatile Message Transport
ospf	89	OSPFIGP		# Open Shortest Path First IGP
ipip	94	IPIP		# Yet Another IP encapsulation
encap	98	ENCAP		# Yet Another IP encapsulation
</Screen>
</para>
</Sect2>

<Sect2>
<title><Literal remap="tt">/etc/networks</Literal></title>
<para>
Le fichier <Literal remap="tt">/etc/networks</Literal> a une fonction similaire au fichier
<Literal remap="tt">/etc/hosts</Literal>. Il fournit une simple base de données de noms de 
réseau avec des adresses. Son format diffère en ce qu'il n'y a 
que deux champs par ligne, et que ces champs sont codés comme ceci :
</para>
<para>
<Screen>
 Nom du réseau   adresse de réseau
</Screen>
</para>
<para>
Un exemple :
</para>
<para>
<Screen>
loopnet    127.0.0.0
localnet   192.168.0.0
amprnet    44.0.0.0
</Screen>
</para>
<para>
Vous obtiendrez le nom du réseau (et NON son adresse) en utilisant une
commande telle que <Emphasis>route</Emphasis> dans l'exemple suivant :
 la destination est un réseau, et ce réseau possède une entrée dans le fichier
 <Literal remap="tt">/etc/networks</Literal>. 
</para>
</Sect2>
</Sect1>

<Sect1>
<title>Sécurité réseau et contrôle d'accès</title>
<para>
Laissez-moi commencer ce paragraphe en vous avertissant que 
la sécurisation de votre machine et du réseau contre les attaques 
pernicieuses est un art complexe. Je ne me considère pas du tout comme 
un expert dans ce domaine et bien que les mécanismes que je 
vais décrire puissent vous aider, si vous êtes préoccupés 
par la sécurité, alors je vous recommande 
d'effectuer vous-même des recherches sur le sujet. Il existe un grand nombre
d'excellentes références sur l'Internet qui traitent du sujet, y compris le <ULink URL="Security-HOWTO.html">Security-HOWTO</ULink>
</para>
<para>
Une importante règle pratique est :
`<Emphasis remap="bf">N'utilisez pas de serveurs dont vous n'avez pas besoin</Emphasis>'.
Un grand nombre de distributions sont livrées avec tout un tas de services 
déjà configurés et démarrant automatiquement. Pour assurer quand
 même un minimum de sécurité vous devriez aller dans votre 
fichier
 <Literal remap="tt">/etc/inetd.conf</Literal> et retirez (<Emphasis>placez un `&num;' au début de 
la ligne</Emphasis>) toute entrée que vous ne comptez pas utiliser.
De bons candidats sont :  <Literal remap="tt">shell</Literal>, <Literal remap="tt">login</Literal>, <Literal remap="tt">exec</Literal>,
<Literal remap="tt">uucp</Literal>, <Literal remap="tt">ftp</Literal>, et les services informatifs tels que <Literal remap="tt">finger</Literal>,
<Literal remap="tt">netstat</Literal> and <Literal remap="tt">systat</Literal>.
</para>
<para>
Il y a plein de sortes de sécurité et de mécanismes de 
contrôle d'accès ; je vais décrire les plus 
élémentaires.
</para>

<Sect2>
<title>/etc/ftpusers</title>
<para>
Le fichier <Literal remap="tt">/etc/ftpusers</Literal> est un mécanisme simple qui vous 
permet d'interdire l'accès de votre machine à certains 
utilisateurs de ftp. Il est lu par le programme démon
 (<Emphasis>ftpd</Emphasis>) lorsqu'une connexion ftp est reçue. Le fichier est une 
simple liste d'utilisateurs qui ne peuvent pas se connecter. Il ressemble 
à :
</para>
<para>
<Screen>
# /etc/ftpusers - utilisateurs ne pouvant pas se connecter par ftp
root
uucp
bin
mail
</Screen>
</para>
</Sect2>

<Sect2>
<title>/etc/securetty</title>
<para>
Le fichier <Literal remap="tt">/etc/securetty</Literal> vous permet de spécifier sur quels 
fichiers de périphériques <Literal remap="tt">tty</Literal> 
<Literal remap="tt">root</Literal> a le droit de se connecter. Le fichier 
<Literal remap="tt">/etc/securetty</Literal> est lu par le programme de connexion (habituellement
 <Emphasis>/bin/login</Emphasis>). Son format est une liste de fichiers de 
périphériques tty autorisés (sur tous les autres <Literal remap="tt">root</Literal> ne peut se
connecter) :
</para>
<para>
<Screen>
# /etc/securetty - consoles où root peut se connecter
tty1
tty2
tty3
tty4
</Screen>
</para>
</Sect2>

<Sect2>
<title>Le mécanisme de contrôle d'accès des hôtes <Emphasis>tcpd</Emphasis>.</title>
<para>
Le programme <Emphasis>tcpd</Emphasis> que vous avez vu dans le fichier
<Literal remap="tt">/etc/inetd.conf</Literal> fournit les mécanismes de contrôle
d'accès et de connexion aux services qu'il a pour but de protéger.
</para>
<para>
Lorsqu'il est invoqué par le programme <Emphasis>inetd</Emphasis>, il lit deux 
fichiers contenant les règles d'accès et il autorise ou  
interdit l'accès au serveur qu'il protège. 
</para>
<para>
Il cherche dans ces deux fichiers jusqu'à ce qu'il
 trouve une correspondance. S'il n'en trouve pas il suppose que l'accès 
est autorisé. Il recherche dans l'ordre suivant :
 <Literal remap="tt">/etc/hosts.allow</Literal>,
<Literal remap="tt">/etc/hosts.deny</Literal>. Je décrirai chacun d'eux plus tard. Pour une 
description complète référez-vous aux pages de manuel 
appropriées
 (<Literal remap="tt">hosts_access(5)</Literal> est un bon point de départ).
</para>

<Sect3>
<title>/etc/hosts.allow</title>
<para>
Le fichier <Literal remap="tt">/etc/hosts.allow</Literal> est un fichier de configuration du 
programme
<Emphasis>/usr/sbin/tcpd</Emphasis>. Il contient les hôtes dont l'accès est 
 <Emphasis>autorisé (allowed)</Emphasis> et qui peuvent donc utiliser un service 
de votre machine.
</para>
<para>
Le format du fichier est très simple :
</para>
<para>
<Screen>
# /etc/hosts.allow
#
# &#60;liste des services&#62;: &#60;liste des hôtes&#62; [: commande]
</Screen>
</para>
<para>
<VariableList>
<VarListEntry>
<Term><Literal remap="tt">liste des services</Literal>
</Term>
<ListItem>
<para>
c'est une liste de serveurs, séparés par des virgules, 
auxquels les règles d'accès s'appliquent.
Exemples de serveur : <Literal remap="tt">ftpd</Literal>, <Literal remap="tt">telnetd</Literal>, et <Literal remap="tt">fingerd</Literal>.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal remap="tt">liste des hôtes</Literal></Term>
<ListItem>
<para>
c'est une liste de noms d'hôtes, séparés par des virgules (vous 
pouvez utiliser également des adresses IP).
Vous pouvez en plus spécifier des noms d'hôtes ou des adresses IP 
avec des jokers pour obtenir des groupes d'hôtes.
 Des exemples : <Literal remap="tt">gw.vk2ktj.ampr.orgi</Literal> 
pour un hôte spécifique, <Literal remap="tt">.uts.edu.au</Literal> pour tous les 
hôtes se terminant par cette chaîne
, <Literal remap="tt">44.</Literal> pour toutes les adresses IP commençant par ces chiffres.
Il y a quelques expressions pour simplifier la configuration, parmi lesquelles :
<Literal remap="tt">ALL</Literal> pour tous les hôtes, <Literal remap="tt">LOCAL</Literal> pour tout hôte dont le nom
 ne contient pas de 
 `<Literal remap="tt">.</Literal>' c'est à dire appartenant au même domaine que votre 
machine, et <Literal remap="tt">PARANOID</Literal>
pour tout hôte dont le nom ne correspond pas avec son adresse 
(tricherie dans
 le nom). Il y a enfin une expression qui peut être utile.
Il s'agit de <Literal remap="tt">EXCEPT</Literal> qui vous permet de fournir une liste 
avec des exceptions.  Nous verrons un exemple plus tard.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term><Literal remap="tt">commande</Literal>
</Term>
<ListItem>
<para>
c'est un paramètre optionnel. Ce paramètre est le nom 
complet d'une commande (avec son répertoire) qui sera 
exécutée 
chaque fois qu'il y aura correspondance.
 Ce peut être par exemple une commande qui essaiera d'identifier qui se 
connecte, ou de générer un message par courrier ou tout message 
d'alerte pour l'administrateur système avertissant 
que quelqu'un est en 
train de se connecter.
 On peut y inclure des extensions, par exemple :
<Literal remap="tt">%h</Literal> donnera le nom de l'hôte qui se connecte ou bien son 
adresse s'il n'a pas de nom
, <Literal remap="tt">%d</Literal> le programme démon appelé.
</para>
</ListItem>
</VarListEntry>
</VariableList>
</para>
<para>
Un exemple :
</para>
<para>
<Screen>
# /etc/hosts.allow
#
# Permet à tout le monde d'utiliser le courrier
in.smtpd: ALL
# telnet et ftp pour les hôtes de mon domaine et my.host.at.home.
telnetd, ftpd: LOCAL, myhost.athome.org.au
# finger pour tout le monde, mais garde une trace de l'identité.
fingerd: ALL: (finger @%h | mail -s "finger from %h" root)
</Screen>
</para>
</Sect3>

<Sect3>
<title>/etc/hosts.deny</title>
<para>
Le fichier <Literal remap="tt">/etc/hosts.deny</Literal> est un fichier de configuration du programme
 <Emphasis>/usr/sbin/tcpd</Emphasis>. Ce fichier contient les hôtes qui
 <Emphasis>n'ont pas l'autorisation</Emphasis>  d'accéder à 
l'un des services de votre machine.
</para>
<para>
Un exemple simple ressemblerait à ceci :
</para>
<para>
<Screen>
# /etc/hosts.deny
#
# Interdit l'acces aux hotes ayant des noms suspects
ALL: PARANOID
#
# Interdit l'acces a tous les hotes
ALL: ALL
</Screen>
</para>
<para>
L'entrée <Literal remap="tt">PARANOID</Literal> est en fait redondante car l'autre 
entrée interdit tous les cas.
 L'une ou l'autre entrée devrait convenir, en fonction de vos besoins 
particuliers.
</para>
<para>
Mettre <Literal remap="tt">ALL: ALL</Literal> par défaut dans le fichier 
<Literal remap="tt">/etc/hosts.deny</Literal> puis autoriser certains services, en liaison avec les 
hôtes que vous avez choisis, dans le fichier
<Literal remap="tt">/etc/hosts.allow</Literal>, est la configuration la plus sûre.
</para>
</Sect3>
</Sect2>
<Sect2>
<title>/etc/hosts.equiv</title>
<para>
Le fichier <Literal remap="tt">hosts.equiv</Literal> est utilisé pour concéder à 
certains hôtes des droits d'accès leur permettant  
d'avoir un compte sur votre 
machine sans fournir de mot de passe. Cela est utile dans un environnement 
sécurisé où vous contrôlez toutes les machines, sinon ce 
peut être très risqué. Votre 
machine est aussi sûre que le moins sûr de vos hôtes de 
confiance. Pour augmenter la sécurité, n'utilisez pas cette 
possiblité et encouragez vos utilisateurs à ne pas utiliser le fichier 
<Literal remap="tt">.rhosts</Literal>.
</para>
</Sect2>

<Sect2>
<title>Configurer votre démon <Emphasis>ftp</Emphasis> correctement</title>
<para>
Un grand nombre de sites sont intéressés à avoir 
un serveur <Emphasis>ftp</Emphasis> 
anonyme pour permettre aux autres de transférer et de 
récupérer des fichiers sans avoir besoin d'une identification spéciale.
 Si vous décidez d'offrir ce service soyez certains de configurer votre 
démon <Emphasis>ftp</Emphasis> de manière adéquate pour les accès anonymes. La 
plupart des pages de manuel dédiées à
<Literal remap="tt">ftpd(8)</Literal> décrivent tous les détails pour y 
arriver. Vous devez toujours vous assurer que vous avez bien 
suivi les instructions.
Un règle importante est de ne pas utiliser une copie de votre fichier
 <Literal remap="tt">/etc/passwd</Literal> dans le répertoire <Literal remap="tt">/etc</Literal> du compte 
anonyme. Soyez sûrs d'avoir éliminé tous les détails
 des comptes exceptés ceux qui sont nécessaires, autrement vous serez 
vulnérables vis à vis de ceux qui maîtrisent 
les techniques de mise en pièces des mots de passe.
</para>
</Sect2>

<Sect2>
<title>Pare-feu (Firewall) sur le réseau</title>
<para>
Ne pas permettre aux datagrammes d'atteindre votre machine ou les serveurs est 
un excellent moyen de sécurisation. Ceci est abordé en 
profondeur dans le <ULink URL="http://www.linuxdoc.org/HOWTO/Firewall-HOWTO.html">Firewall-HOWTO</ULink> et (de
manière plus concise) plus loin dans ce document.
</para>
</Sect2>

<Sect2>
<title>Autres suggestions</title>
<para>
Voici d'autres suggestions, potentiellement religieuses, à prendre en 
considération :
</para>
<para>
<VariableList>
<VarListEntry>
<Term>sendmail</Term> 
<ListItem>
<para>
en dépit de sa popularité, le démon 
<Emphasis>sendmail</Emphasis> apparaît avec une effrayante régularité 
dans les mises en garde concernant la sécurité. Faites comme 
vous voulez, mais j'ai choisi de ne pas l'utiliser. 
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>NFS et autres services Sun RPC</Term>
<ListItem>
<para>
soyez circonspects avec eux. Il y a 
toutes sortes d'exploits possibles avec ces services. Il est difficile de 
trouver une option pour les services tels que NFS, mais si vous les configurez,
 soyez prudents envers ceux à qui vous accordez des droits.
</para>
</ListItem>
</VarListEntry>
</VariableList>
</para>
</Sect2>
</Sect1>
</chapter>

<!-- *********************************************************************** -->

<chapter>


<title>Informations sur Ethernet</title>

<para>
Cette section traite d'informations spécifiques sur Ethernet et la 
configuration des cartes Ethernet.
</para>

<Sect1>
<title>Cartes Ethernet supportées</title>
<Sect2>
<title>3Com</title>
<para>
<ItemizedList>
<ListItem>
<para>
3Com 3c501 - `à fuir comme la peste' (gestionnaire 3c501)
</para>
</ListItem>
<ListItem>
<para>
3Com 3c503 (gestionnaire 3c503), 3c505 (gestionnaire 3c505), 3c507 (gestionnaire 3c507), 3c509/3c509B (ISA) / 3c579
(EISA)
</para>
</ListItem>
<ListItem>
<para>
3Com Etherlink III Vortex Ethercards (3c590, 3c592, 3c595, 3c597)
(PCI), 3Com Etherlink XL Boomerang (3c900, 3c905) (PCI) et Cyclone
(3c905B, 3c980) Ethercards (gestionnaire 3c59x) et 3Com Fast EtherLink
Ethercard (3c515) (ISA) (gestionnaire 3c515)
</para>
</ListItem>
<ListItem>
<para>
3Com 3ccfe575 Cyclone Cardbus (gestionnaire 3c59x)
</para>
</ListItem>
<ListItem>
<para>
3Com 3c575 series Cardbus (gestionnaire 3c59x) (ALL PCMCIA ??)
</para>
</ListItem>
</ItemizedList>
</para>
</Sect2>
<Sect2>
<title>AMD, ATT, Allied Telesis, Ansel, Apricot</title>
<para>
<ItemizedList>
<ListItem>
<para>
AMD LANCE (79C960) / PCnet-ISA/PCI (AT1500, HP J2405A,
NE1500/NE2100)
</para>
</ListItem>
<ListItem>
<para>
 ATT GIS WaveLAN 
</para>
</ListItem>
<ListItem>
<para> 
Allied Telesis AT1700 
</para>
</ListItem>
<ListItem> 
<para>
Allied Telesis LA100PCI-T 
</para>
</ListItem>
<ListItem> <para>
Allied Telesyn AT2400T/BT (module "ne") 
</para>
</ListItem>
<ListItem> 
<para>
Ansel Communications AC3200 (EISA) 
</para>
</ListItem>
<ListItem> 
<para>
Apricot Xen-II / 82596 
</para>
</ListItem>
</ItemizedList>
</para>
</Sect2>
<Sect2>
<title>Cabletron, Cogent, Crystal Lan</title>
<para>
<ItemizedList>
<ListItem> 
<para>
Cabletron E21xx 
</para>
</ListItem>
<ListItem> 
<para>
Cogent EM110 
</para>
</ListItem>
<ListItem>
<para> Crystal Lan CS8920, Cs8900 
</para>
</ListItem>
</ItemizedList>
</para>
</Sect2>
<Sect2>
<title>Danpex, DEC, Digi, DLink</title>
<para>
<ItemizedList>
<ListItem> 
<para>
Danpex EN-9400 
</para>
</ListItem>
<ListItem> 
<para>
DEC DE425 (EISA) / DE434/DE435 (PCI) / DE450/DE500 (gestionnaire DE4x5) 
</para>
</ListItem>
<ListItem> 
<para>
DEC DE450/DE500-XA (dc21x4x) (gestionnaire Tulip) 
</para>
</ListItem>
<ListItem> 
<para>
DEC DEPCA et EtherWORKS 
</para>
</ListItem>
<ListItem> 
<para>
DEC EtherWORKS 3 (DE203, DE204, DE205) 
</para>
</ListItem>
<ListItem> 
<para>
DECchip DC21x4x "Tulip" 
</para>
</ListItem>
<ListItem> 
<para>
DEC QSilver's (Gestionnaire Tulip) 
</para>
</ListItem>
<ListItem> 
<para>
Digi International RightSwitch 
</para>
</ListItem>
<ListItem> 
<para>
DLink DE-220P, DE-528CT, DE-530+, DFE-500TX, DFE-530TX 
</para>
</ListItem>
</ItemizedList>
</para>
</Sect2>
<Sect2>
<title>Fujitsu, HP, ICL, Intel</title>
<para>
<ItemizedList>
<ListItem> 
<para>
Fujitsu FMV-181/182/183/184
 </para>
</ListItem>
<ListItem> 
<para>HP PCLAN (séries 27245 et 27xxx) 
</para>
</ListItem>
<ListItem> 
<para>
HP PCLAN PLUS (27247B et 27252A) 
</para>
</ListItem>
<ListItem> 
<para>
HP 10/100VG PCLAN (J2577, J2573, 27248B, J2585) (ISA/EISA/PCI) 
</para>
</ListItem>
<ListItem> 
<para>ICL EtherTeam 16i / 32 (EISA) 
</para>
</ListItem>
<ListItem> <para>
Intel EtherExpress 
</para>
</ListItem>
<ListItem> 
<para>
Intel EtherExpress Pro 
</para>
</ListItem>
</ItemizedList>
</para>
</Sect2>
<Sect2>
<title>KTI, Macromate, NCR NE2000/1000, Netgear, New Media</title>
<para>
<ItemizedList>
<ListItem> 
<para>
KTI ET16/P-D2, ET16/P-DC ISA (fonctionne sans cavaliers et avec des options de configuration matérielles) 
</para>
</ListItem>
<ListItem> 
<para>
Macromate MN-220P (PnP or NE2000 mode) 
</para>
</ListItem>
<ListItem> 
<para>
NCR WaveLAN 
</para>
</ListItem>
<ListItem> 
<para>
NE2000/NE1000 (attention aux clônes) 
</para>
</ListItem>
<ListItem> 
<para>Netgear FA-310TX (puce Tulip) 
</para>
</ListItem>
<ListItem> 
<para>
New Media Ethernet 
</para>
</ListItem>
</ItemizedList>
</para>
</Sect2>
<Sect2>
<title>PureData, SEEQ, SMC</title>
<para>
<ItemizedList>
<ListItem> 
<para>
PureData PDUC8028, PDI8023 
</para>
</ListItem>
<ListItem> 
<para>
SEEQ 8005 
</para>
</ListItem>
<ListItem> 
<para>
SMC Ultra / EtherEZ (ISA) 
</para>
</ListItem>
<ListItem> 
<para>
SMC 9000 series 
</para>
</ListItem>
<ListItem> 
<para>
SMC PCI EtherPower 10/100 (gestionnaire DEC Tulip) 
</para>
</ListItem>
<ListItem> 
<para>SMC EtherPower II (gestionnaire epic100.c) 
</para>
</ListItem>
</ItemizedList>
</para>
</Sect2>
<Sect2>
<title>Sun Lance, Sun Intel, Schneider, WD, Zenith, IBM, Enyx</title>
<para>
<ItemizedList>
<ListItem> 
<para>
Adaptateurs Sun LANCEs (noyau kernel 2.2 et suivants) 
</para>
</ListItem>
<ListItem> 
<para>
Adaptateurs Sun Intel (noyaux kernel 2.2 et suivants) 
</para>
</ListItem>
<ListItem> 
<para>
Schneider et Koch G16 
</para>
</ListItem>
<ListItem>
<para>
 Western Digital WD80x3 
</para>
</ListItem>
<ListItem> 
<para>
Adaptateur intégré Zenith Z-Note / IBM ThinkPad 300 
</para>
</ListItem>
<ListItem>
<para> 
Ensemble Znyx 312 (gestionnaire Tulip) 
</para>
</ListItem>
</ItemizedList>
</para>
</Sect2>
</Sect1>

<Sect1>
<title>Informations générales sur Ethernet</title>
<para>
Les noms de périphériques Ethernet sont `<Literal remap="tt">eth0</Literal>', `<Literal remap="tt">eth1</Literal>',
 `<Literal remap="tt">eth2</Literal>' etc. La première carte détectée par le noyau devient
 `<Literal remap="tt">eth0</Literal>' et le reste est nommé dans l'ordre de détection.
</para>
<para>
Une fois que vous avez compilé convenablement 
votre noyau pour supporter les 
cartes Ethernet, la configuration des cartes est aisée.
</para>
<para>
Typiquement vous faites ainsi (ce que la plupart des distributions font
automatiquement 
pour vous, si vous les avez configurées pour supporter votre carte ethernet) :
</para>
<para>
<Screen>
root# ifconfig eth0 192.168.0.1 netmask 255.255.255.0 up
root# route add -net 192.168.0.0 netmask 255.255.255.0 eth0
</Screen>
</para>
<para>
La plupart des gestionnaires Ethernet furent développés par Donald Becker,
<ULink URL="mailto:becker@CESDIS.gsfc.nasa.gov">Donald Becker</ULink>
</para>
<para>
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>

</Sect1>
<Sect1>
<title>Utiliser plusieurs cartes Ethernet sur la même machine</title>
<Sect2>
<title>Si le gestionnaire est sous forme de module (habituellement avec les nouvelles distributions)</title>
<para>
Le module pourra normalement détecter toutes les cartes installées.
</para>
<para>
Les informations concernant la détection sont stockées dans le fichier :
</para>
<para>
<Emphasis>
/etc/conf.modules. 
</Emphasis>
</para>
<para>

Supposons qu'un utilisateur possède 3 cartes NE2000, une à l'adresse 0x300,
l'autre à 0x240, et la dernière à 0x220. Il faut ajouter les lignes suivantes au fichier /etc/conf.modules :
</para>
<para>
   <Screen>
        alias eth0 ne
        alias eth1 ne
        alias eth2 ne
	options ne io=0x220,0x240,0x300
   </Screen>
</para>
<para>
Ceci enjoint au programme <Emphasis>modprobe</Emphasis> de rechercher 3 cartes NE aux
adresses spécifiées. De plus cela donne l'ordre dans lequel on doit les trouver
et quel périphérique leur est assigné.
</para>
<para>
La plupart des modules ISA acceptent des valeurs d'E/S séparées par des virgules.
Par exemple :
</para>
<para>
	<Screen>
        alias eth0 3c501
        alias eth1 3c501
        options eth0 -o 3c501-0 io=0x280 irq=5
        options eth1 -o 3c501-1 io=0x300 irq=7
	</Screen>
</para>
<para>

L'option -o permet d'assigner un nom unique à chaque module. La raison en est que
vous ne pouvez charger deux copies du même module.
</para>
<para>
L'option irq= sert à spécifier l'IRQ matériel et l'option io= à 
spécifier les différents ports entrée-sortie.
</para>
<para>

Par défaut, le noyau Linux ne peut détecter qu'un seul dispositif Ethernet, et
vous devez passer des commandes pour forcer la détection des autres
cartes.
</para>
<para>
Pour apprendre à faire fonctionner vos cartes ethernet sous Linux, voyez le
<ULink URL="Ethernet-HOWTO.html">Ethernet-HOWTO</ULink>.
</para>
</Sect2>
</Sect1>
</chapter>

<!-- *********************************************************************** -->

<chapter>
<title>Informations relatives à l'IP</title>
<para>
Cette section traite d'informations spécifiques à l'IP. 
</para>
<Sect1>
<Title>Options au niveau du noyau</title>
<para>
Cette section fournit des informations concernant la mise au point
des options IP dans le noyau au moment de l'amorçage. 
À titre d'exemples, de telles options peuvent être
 <command>ip_forward</command> ou <command>ip_bootp_agent</command>.
Elles sont utilisées en affectant une valeur à un fichier situé
dans le répertoire <screen>/proc/sys/net/ipv4/</screen> Le nom du
fichier est le nom de la commande.
</para>
<para>
Par exemple, pour obtenir <command>ip_forward</command><command> enabled</command>
vous taperez <screen>echo 1 > /proc/sys/net/ipv4/ip_forward</screen>
</para>
<sect2><title>Liste des options IP générales.</title>
<para>
<itemizedlist>
<listitem>
<para>
<command>ip_forward</command>
</para>
<para>
Si <command>ip_forward</command><indexterm><primary>ip_forward</primary></indexterm> est réglé à 0, il est désactivé. Avec tout autre nombre, il est activé.
Cette option est utilisée en conjonction avec des techniques telles que le 
routage entre interfaces avec le masquage IP.<indexterm><primary>IP Masquerading></primary></indexterm>.
</para>
</listitem>
<listitem>
<para>
<command>ip_default_ttl</command>
</para>
<para>
C'est la durée de vie d'un paquet IP. Par défaut, elle est de 64 ms.
</para>
</listitem>
<listitem>
<para>
<command>ip_addrmask_agent</command>
</para>
<para>- BOOLÉEN</para>
<para>
Répond aux requêtes ICMP ADDRESS MASK.
Par défaut TRUE (pour le routeur) et
           FALSE (pour l'hôte)
</para>
</listitem>
<listitem>
<para>
<command>ip_bootp_agent</command>
</para>
<para> 
- BOOLÉEN
</para>
<para>
Accepte des paquets ayant une adresse source du type 0.b.c.d
et destiné à cet hôte, broadcast ou multicast.
Sinon, ces paquets sont ignorés.
FALSE par défaut.
</para>
</listitem>
<listitem>
<para>
<command>ip_no_pmtu_disc</command>
</para>
<para> - BOOLÉEN</para>
<para>
Désactive la recherche du MTU du chemin.
FALSE par défaut.
</para>
</listitem>
<listitem>
<para>
<command>ip_fib_model</command>
</para>
<para>-NOMBRE ENTIER
</para>
<para>
0 - (valeur par défaut) Modèle standard. Toutes les routes sont dans la classe MAIN
</para>
<para>
1 - Les routes par défaut vont dans la classe DEFAULT. Ce mode devrait être
très pratique pour les petits fournisseurs d'accès appliquant une politique de routage.
</para>
<para>
2 - Modèle conforme à la RFC1812.
</para>
<para>
Les routes interface sont dans la classe MAIN.
</para>
<para>
Les routes gateway sont dans la classe DEFAULT.
</para>
</listitem>
</itemizedlist>
</para>
</sect2>
</sect1>
<sect1>
<title>EQL - égaliseur de charge à lignes multiples</title>
<para>
Le nom du périphérique EQL est `<Literal remap="tt">eql</literal>'. Avec les sources 
standards du noyau vous ne pouvez avoir qu'un seul périphérique 
EQL par machine. EQL permet d'utiliser plusieurs lignes point à point 
telles que PPP, SLIP ou PLIP comme si c'était un seul lien logique de 
 transport tcp/ip. C'est souvent moins cher d'utiliser plusieurs lignes 
à faible débit que d'avoir une ligne à haut débit.
</para>
<para>
<Emphasis>Options de compilation du noyau</Emphasis> :
<Screen>
Network device support ---&#62;
    [*] Network device support
    &#60;*&#62; EQL (serial line load balancing) support
</Screen>
</para>
<para>
Pour supporter ce mécanisme la machine à l'autre bout de la ligne
 doit également supporter EQL.
 Linux, Livingstone Portmasters et de nouveaux serveurs de ligne supportent 
des systèmes compatibles.
</para>
<para>
Pour configurer EQL vous avez besoin des outils eql, disponibles sur :
<ULink URL="ftp://metalab.unc.edu/pub/linux/system/Serial/eql-1.2.tar.gz">
	metalab.unc.edu</ULink>.
</para>
<para>
La configuration est plutôt directe. Vous commencez par configurer 
l'interface eql. C'est exactement comme un autre périphérique 
réseau. Vous configurez l'adresse IP et le mtu en utilissant l'outil
 <Emphasis>ifconfig</Emphasis> , comme ceci :
</para>
<para>
<Screen>
root# ifconfig eql 192.168.10.1 mtu 1006
</Screen>
</para>
<para>
Ensuite vous devez initialiser manuellement chacune des lignes que vous allez 
utiliser. Ce peut être toute combinaison de périphériques 
réseau point à point. La façon d'initialiser les 
connexions dépend du type de lien, voyez les paragraphes 
appropriés pour d'autres informations.
</para>
<para>
Enfin vous devez associer le lien série et le dispositif EQL, cela 
s'appelle `asservissement' (enslaving) et est réalisé avec la 
commande
 <Emphasis>eql_enslave</Emphasis> comme suit :
</para>
<para>
<Screen>
root# eql_enslave eql sl0 28800
root# eql_enslave eql ppp0 14400
</Screen>
</para>
<para>
Le paramètre `<Emphasis>estimated speed</Emphasis>' que vous fournissez à  
<Emphasis>eql_enslave</Emphasis> ne fait rien directement. Il est utilisé par le gestionnaire 
EQL pour déterminer comment les datagrammes vont se répartir 
sur ce périphérique, aussi vous pouvez régler 
l'équilibrage des lignes en jouant avec cette valeur.
</para>
<para>
Pour libérer une ligne d'un périphérique EQL,  
utilisez la commande <Emphasis>eql_emancipate</Emphasis> comme ci-dessous :
</para>
<para>
<Screen>
root# eql_emancipate eql sl0
</Screen>
</para>
<para>
Vous ajoutez le routage comme vous le feriez pour tout lien point 
à point, sauf que vos routes doivent se rapporter au dispositif
 <Literal remap="tt">eql</Literal> plutôt qu'aux périphériques séries 
eux-mêmes. Ainsi vous devriez utiliser :
</para>
<para>
<Screen>
root# route add default eql
</Screen>
</para>
<para>
Le gestionnaire EQL fut développé par Simon Janes, <Literal remap="tt">simon@ncm.com</Literal>.
</para>
<Para><Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</sect1>
<Sect1>
<title>Enregistrement IP (IP Accounting) (pour Linux-2.0)</title>
<para>
Les possibilités d'enregistrement IP du noyau Linux vous permettent 
de recueillir et d'analyser les données d'utilisation du réseau.
Les données collectées comprennent le nombre de paquets et le 
nombre d'octets en cumul depuis la dernière remise à zéro. 
 Vous avez à votre disposition une grande variété de 
réglages pour obtenir les données que vous désirez. Cette option a été
enlevée du 2.1.102, car l'ancien dispositif pare-feu basé sur
ipfwadm a été remplacé par ``ipfwchains''.
</para>
<para>
<Emphasis>Options de compilation noyau</Emphasis> :
<Screen>
Networking options  ---&#62;
    [*] IP: accounting
</Screen>
</para>
<para>Après avoir compilé et installé le noyau vous devez 
utiliser la commande
<Emphasis>ipfwadm</Emphasis> pour configurer l'enregistrement IP. Il y a différentes 
possibilités pour choisir les informations à enregistrer. 
J'ai pris un exemple simplifié qui pourrait vous être utile;
 lisez plutôt la page de manuel <Emphasis>ipfwadm</Emphasis> pour plus d'informations.
</para>
<para>
Scenario : Vous avez un réseau Ethernet qui est relié à 
l'Internet via une liaison PPP.
 Sur l'Ethernet vous avez une machine qui offre un grand nombre de services et 
vous voulez savoir quel trafic est engendré par le trafic 
ftp et ww, aussi bien que le trafic total tcp et udp. 
</para>
<para>
Vous pouvez utiliser une commande qui ressemble à ceci, qui se présente
comme un script shell :
</para>
<para>
        <Screen>
	#!/bin/sh
        #
        # Donne les réglages d'enregistrement
        ipfwadm -A -f
        #
        # Met en place les raccourcis
        localnet=44.136.8.96/29
        any=0/0
        # Ajoute des réglages pour le segment Ethernet local
        ipfwadm -A in  -a -P tcp -D $localnet ftp-data
        ipfwadm -A out -a -P tcp -S $localnet ftp-data
        ipfwadm -A in  -a -P tcp -D $localnet www
        ipfwadm -A out -a -P tcp -S $localnet www
        ipfwadm -A in  -a -P tcp -D $localnet
        ipfwadm -A out -a -P tcp -S $localnet
        ipfwadm -A in  -a -P udp -D $localnet
        ipfwadm -A out -a -P udp -S $localnet
        #
        # Réglages par défaut
        ipfwadm -A in  -a -P tcp -D $any ftp-data
        ipfwadm -A out -a -P tcp -S $any ftp-data
        ipfwadm -A in  -a -P tcp -D $any www
        ipfwadm -A out -a -P tcp -S $any www
        ipfwadm -A in  -a -P tcp -D $any
        ipfwadm -A out -a -P tcp -S $any
        ipfwadm -A in  -a -P udp -D $any
        ipfwadm -A out -a -P udp -S $any
        #
        # Liste les réglages
        ipfwadm -A -l -n
        #
        </Screen>
</para>
<para>Les noms ``ftp-data'' et ``www'' se réfèrent aux lignes du fichier
<Literal remap="tt">/etc/services</Literal>.
La dernière commande liste chacune des règles d'enregistrement et 
affiche le total.
</para>
<para>
Il est important de noter, lorsque l'on analyse les 
enregistrement IP,  
que <Emphasis remap="bf">les totaux sont incrémentés à chaque fois</Emphasis>, 
donc pour connaitre les différences vous devez exécuter les 
opérations mathématiques nécessaires.
 Par exemple si je veux savoir combien de données ne venaient pas de 
ftp, telnet, rlogin ou www je dois soustraire les totaux individuels  
 correspondant à chaque port.
</para>
<para>
<Screen>
root# ipfwadm -A -l -n
IP accounting rules
 pkts bytes dir prot source               destination          ports
    0     0 in  tcp  0.0.0.0/0            44.136.8.96/29       * -&#62; 20
    0     0 out tcp  44.136.8.96/29       0.0.0.0/0            20 -&#62; *
   10  1166 in  tcp  0.0.0.0/0            44.136.8.96/29       * -&#62; 80
   10   572 out tcp  44.136.8.96/29       0.0.0.0/0            80 -&#62; *
  252 10943 in  tcp  0.0.0.0/0            44.136.8.96/29       * -&#62; *
  231 18831 out tcp  44.136.8.96/29       0.0.0.0/0            * -&#62; *
    0     0 in  udp  0.0.0.0/0            44.136.8.96/29       * -&#62; *
    0     0 out udp  44.136.8.96/29       0.0.0.0/0            * -&#62; *
    0     0 in  tcp  0.0.0.0/0            0.0.0.0/0            * -&#62; 20
    0     0 out tcp  0.0.0.0/0            0.0.0.0/0            20 -&#62; *
   10  1166 in  tcp  0.0.0.0/0            0.0.0.0/0            * -&#62; 80
   10   572 out tcp  0.0.0.0/0            0.0.0.0/0            80 -&#62; *
  253 10983 in  tcp  0.0.0.0/0            0.0.0.0/0            * -&#62; *
  231 18831 out tcp  0.0.0.0/0            0.0.0.0/0            * -&#62; *
    0     0 in  udp  0.0.0.0/0            0.0.0.0/0            * -&#62; *
    0     0 out udp  0.0.0.0/0            0.0.0.0/0            * -&#62; *
# 
</Screen>
</para>

<Sect2>
<title>Enregistrement IP (IP Accounting) (pour Linux-2.2)</title>
<para>On accède au nouveau code d'enregistrement par des ``chaînes IP pare-feu''.
Voir <ULink URL="http://www.adelaide.net.au/~rustcorp/ipfwchains/ipfwchains.html">
 La page d'accueil des chaînes IP</ULink> pour plus d'informations. Entre autres
 vous devrez utiliser <Emphasis>ipchains</Emphasis> au lieu de <Emphasis>ipfwadm</Emphasis> pour configurer
 vos filtres. (d'après <Literal remap="tt">Documentations/Changes</Literal> dans les sources du
 dernier noyau).
 </para>
</Sect2>
</Sect1>
<Sect1>
<title>IP Aliasing</title>
<para>
Il y a des applications où être en mesure d'affecter 
plusieurs adresses IP à un seul périphérique réseau pourrait être utile.
 Certains fournisseurs d'accès à l'Internet utilise souvent cette 
possibilité pour fournir des offres www et ftp `à la carte' pour 
leurs clients. Vous pouvez vous référer au mini-HOWTO IP-Aliasing
pour plus d'informations.
</para>
<para>
<Emphasis>Options de compilation du noyau</Emphasis> :
<Screen>
Networking options  ---&#62;
    ....
    [*] Network aliasing
    ....
    &#60;*&#62; IP: aliasing support
</Screen>
</para>
<para>
Après avoir compilé et installé le noyau avec le support 
IP&lowbar;Alias, la configuration est très simple. Les alias sont ajoutés 
aux périphériques réseau virtuels  associés au périphérique réseau réel.
Une simple convention de noms s'applique pour périphériques : 
 <Literal remap="tt">&lt;nom de périphérique&#62; : &lt;numéro de 
périphérique virtuel&#62;</Literal>, par ex. <Literal remap="tt">eth0:0</Literal>,
<Literal remap="tt">ppp0:10</Literal> etc. Notez que le gestionnaire de périphérique ifname:number
ne peut être configuré <Emphasis>qu'après</Emphasis> le réglage de l'interface principale.
</para>
<para>
Par exemple, supposons que vous ayez un réseau Ethernet avec 
simultanément deux sous-réseaux IP et que vous vouliez que votre 
machine ait un accès direct aux deux, vous pouvez faire quelque chose 
comme ceci :
</para>
<para>
        <Screen>
        root# ifconfig eth0 192.168.1.1 netmask 255.255.255.0 up
        root# route add -net 192.168.1.0 netmask 255.255.255.0 eth0

        root# ifconfig eth0:0 192.168.10.1 netmask 255.255.255.0 up
        root# route add -net 192.168.10.0 netmask 255.255.255.0 eth0:0
        </Screen>
</para>
<para>
Pour supprimer un alias vous ajoutez simplement un `<Literal remap="tt">-</Literal>' au bout de son nom 
et et vous faites aussi simplement que ça :
</para>
<para>
       <Screen>
       root# ifconfig eth0:0- 0
       </Screen>
</para>
<para>
Toutes les routes associées avec cet alias seront enlevées 
automatiquement.
</para>
<para>
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>

<Sect1>
<title>IP Pare-feu (Firewall) (pour Linux-2.0)</title>
<para>
Le pare-feu IP et les publications le concernant sont traités de
 manière plus approfondie dans le 
<ULink URL="http://www.linuxdoc.org/HOWTO/Firewall-HOWTO.html">Firewall-HOWTO</ULink>. Le pare-feu IP vous 
permet de sécuriser votre machine contre les accès réseau 
non-autorisés en filtrant, ou acceptant, des datagrammes venant de, ou 
allant vers, des adresses IP de votre choix.
Il y a différentes règles : le filtrage en entrée, le 
filtrage en sortie, et le filtrage en retransmission. Les règles en 
entrée s'appliquent aux datagrammes qui sont reçus par un 
dispositif réseau. Les règles en sortie s'appliquent aux 
datagrammes qui sont émis par un dispositif réseau. Les 
règles en retransmission s'appliquent aux datagrammes qui ne sont pas 
pour cette machine, c'est à dire les datagrammes qui seront 
reroutés.
</para>
<para>
<Emphasis>Options de compilation noyau</Emphasis> :
<Screen>
Networking options  ---&#62;
    [*] Network firewalls
    ....
    [*] IP: forwarding/gatewaying
    ....
    [*] IP: firewalling
    [ ] IP: firewall packet logging
</Screen>
</para>
<para>
La configuration du pare-feu IP est réalisée en utilisant la 
commande  <Emphasis>ipfwadm</Emphasis>.
 Comme mentionné plus haut, la sécurité n'est pas ma 
spécialité, aussi, bien que je vous présente un exemple 
utilisable par vous-même, faites des recherches et 
mettez au point vos propres règlages si la sécurité est 
importante pour vous.
</para>
<para>
Utiliser votre machine Linux comme routeur et passerelle pare-feu pour
protéger votre réseau local contre les accès non autorisés (venant de 
l'extérieur) est vraisemblablement l'utilisation la plus courante
 d'un pare-feu IP. 
</para>
<para>
La configuration suivante est due à Arnt Gulbrandsen,
<Literal remap="tt">&lt;agulbra@troll.no&gt;</Literal>.
</para>
<para>
L'exemple décrit une configuration de pare-feu pour une machine Linux 
/pare-feu/routeur illustrée par ce diagramme :
</para>
<para>
<Screen>
-                                   -
 \                                  | 172.16.37.0
  \                                 |   /255.255.255.0
   \                 - - - - -      |
    |  172.16.174.30 | Linux |      |
NET =================|  f/w  |- - - |    ..37.19
    |    PPP         | router|      |   - - - - 
   /                 - - - - -      |--| Mail  |
  /                                 |  | /DNS  |
 /                                  |   - - - -
-                                   -
</Screen>
</para>
<para>
Les commandes suivantes doivent être normalement placées dans un 
fichier <Literal remap="tt">rc</Literal> de telle sorte qu'elles seront démarrées 
automatiquement à chaque redémarrage du système. Pour une 
sécurité maximum, elles devront être effectuées
 après la configuration des interfaces réseau,  
 mais avant le montage de ces interfaces pour 
éviter que quelqu'un puisse se connecter pendant que la machine 
pare-feu redémarre.
</para>
<para>
        <Screen>
        #!/bin/sh

        # Nettoie la table des règles de 'Forwarding'
        # Change le réglage par défaut en 'accept'
        #
        /sbin/ipfwadm -F -f
        /sbin/ipfwadm -F -p accept
        #
        # .. et pour 'Incoming'
        #
        /sbin/ipfwadm -I -f
        /sbin/ipfwadm -I -p accept

        # En premier, dévérouille l'interface PPP 
        # J'aimerais bien utiliser '-a deny' au lieu de '-a reject -y' mais
	# il serait alors impossible d'établir des connexions également sur
	# cette interface. L'utilisation de -o fait en sorte que tous
	# les datagrammes rejetés sont enregistrés. Cela occupe de l'espace
	# disque avec pour compensation la connaissance sur l'attaque due
	# à une erreur de configuration.
        #
        /sbin/ipfwadm -I -a reject -y -o -P tcp -S 0/0 -D 172.16.174.30

        # Rejette certains types de paquets visiblement faux:
        # Rien ne doit venir des adresses multicast/anycast/broadcast s
        #
        /sbin/ipfwadm -F -a deny -o -S 224.0/3 -D 172.16.37.0/24
        #
        # et aucune chose venant du réseau loopback ne doit être vu sur l'air
        #
        /sbin/ipfwadm -F -a deny -o -S 127.0/8 -D 172.16.37.0/24

        # accepte les connexions entrantes SMTP et DNS, mais seules pour
        # le serveur  de courrier et le serveur de noms
        #
        /sbin/ipfwadm -F -a accept -P tcp -S 0/0 -D 172.16.37.19 25 53
        #
        # DNS utilise UDP aussi bien que TCP, ce qui l'autorise donc quand
        # le serveur de noms est interrogé
        #
        /sbin/ipfwadm -F -a accept -P udp -S 0/0 -D 172.16.37.19 53
        #
        # mais pas de "réponses" arrivant sur les ports dangereux tels que
	# NFS et l'extension NFS de Larry McVoy. Si vous utilisez squid
	# ajoutez son port ici.
        #
        /sbin/ipfwadm -F -a deny -o -P udp -S 0/0 53 \
                -D 172.16.37.0/24 2049 2050

        # les réponses aux autres ports utilisateurs sont autorisées
        #
        /sbin/ipfwadm -F -a accept -P udp -S 0/0 53 \
                -D 172.16.37.0/24 53 1024:65535

        # Rejette les connexions entrantres vers identd
        # Nous utilisons 'reject' dans ce cas en sorte qu'il soit dit à l'hôte
	# entrant de ne pas persévérer, sinon nous devrons attendre que
	# identd s'arrête.
        #
        /sbin/ipfwadm -F -a reject -o -P tcp -S 0/0 -D 172.16.37.0/24 113

        # Accepte des connexions sur des services en provenance des réseaux
	# 192.168.64 et 192.168.65, qui sont des amis de confiance.
        #
        /sbin/ipfwadm -F -a accept -P tcp -S 192.168.64.0/23 \
                -D 172.16.37.0/24 20:23

        # accepte et laisse passer tout ce qui vient de l'intérieur
        #
        /sbin/ipfwadm -F -a accept -P tcp -S 172.16.37.0/24 -D 0/0

        # rejette la plupart des autres connexions TCP entrantes et les
	# enregistre (ajoutez 1:1023 si ftp ne fonctionne pas)
        #
        /sbin/ipfwadm -F -a deny -o -y -P tcp -S 0/0 -D 172.16.37.0/24

        # ... pour UDP également
        #
        /sbin/ipfwadm -F -a deny -o -P udp -S 0/0 -D 172.16.37.0/24
</Screen>
</para>
<para>
De bonnes configurations pare-feu sont difficiles à faire. Cet exemple peut 
être un bon point de départ pour vous. La page de manuel
 <Emphasis>ipfwadm</Emphasis>
vous aidera pour savoir comment utiliser cet outil. Si vous voulez 
configurer un pare-feu, demandez autour de vous et recueillez des avis venant 
de sources de confiance et prenez contact avec quelqu'un qui est à
l'extérieur pour tester votre 
configuration et en vérifier la fiabilité.
</para>

<Sect2>
<title>Pare-feu IP (pour Linux-2.2)</title>

<para>
On accède au nouveau code d'enregistrement par des ``chaînes pare-feu IP''.
Voir <ULink URL="http://www.adelaide.net.au/~rustcorp/ipfwchains/ipfwchains.html">
 La page d'accueil des chaînes IP</ULink> pour plus d'informations. Entre autres
  vous devrez utiliser <Emphasis>ipchains/ au lieu de </Emphasis>ipfwadm/ pour configurer
   vos filtres. (D'après <Literal remap="tt">Documentations/Changes</Literal> dans les sources du
   dernier noyau).
</para>
<para>
Nous sommes conscients du fait que ce n'est malheureusement plus
d'actualité et nous oeuvrons actuellement pour que cette section soit
plus à jour. Vous pouvez en espérer une en 1999.
</para>
</Sect2>
</Sect1>
<Sect1>
<title>Encapsulation IPIP</title>
<para>
Pourquoi vouloir encapsuler des paquets IP dans d'autres paquets IP? Cela
 semble bizarre si vous n'avez jamais vu d'applications auparavant.
Il y a deux endroits où c'est utilisé : le Mobile-IP
et l'IP-Multicast. C'est dans un environnement qui est 
peut-être le plus largement
utilisé et qui est le moins connu : le radio-amateurisme.
</para>
<para>
<Emphasis>Options de compilation du noyau</Emphasis> :
<Screen>
Networking options  ---&#62;
    [*] TCP/IP Networking
    [*] IP: forwarding/gatewaying
    ....
    &#60;*&#62; IP tunelling
</Screen>
</para>
<para>
Les périphériques IP tunnel s'appellent `<Literal remap="tt">tunl0</Literal>', `<Literal remap="tt">tunl1</Literal>', etc..
</para>
<para>
"Mais pourquoi ?" D'accord. D'accord. Les règles de routage classiques
spécifient qu'un réseau IP comprend une adresse IP et un masque
de réseau. Ceci fournit un ensemble d'adresses contiguës qui
peuvent toutes être routées par l'intermédiaire
d'une seule entrée de 
routage. Cela marche, mais signifie que vous ne pouvez utiliser
une seule adresse uniquement lorsque vous êtes 
connecté à un point du réseau auquelle elle appartient.
Dans la plupart des cas, il n'y a pas de problèmes,
 mais si vous êtes  
 en mouvement alors vous ne pouvez pas rester connecté
au même endroit tout le temps. L'encapsulation  IP/IP ( IP tunneling)
vous permet de passer outre cette contrainte en permettant aux paquets
destinés à votre adresse d'être enveloppés et
redirigés vers une autre adresse. Si vous savez que vous allez
opérer depuis un autre réseau IP pour quelques temps, vous
pouvez régler une machine qui est chez vous pour accepter des
paquets destinés à votre adresse IP et les rediriger vers
l'adresse que vous allez utiliser provisoirement.
</para>

<Sect2>
<title>Une configuration de réseau avec tunneling.</title>
<para>

<Screen>
 192.168.1.24                         192.168.2.24

     -                                    -
     |      ppp0 =           ppp0 =       |
     |  aaa.bbb.ccc.ddd  fff.ggg.hhh.iii  |
     |                                    |
     |   /- - -\                 /- - -\  |
     |   |     |        //       |     |  |
     |- -|  A  |- - - // - - - - |  B  |  |
     |   |     |    //           |     |  |
     |   \- - -/                 \- - -/  |
     |                                    |
     -                                    -

</Screen>
</para>

<para>
Ce diagramme montre une autre raison possible d'utiliser l'encapsulation IPIP :
le réseau privé virtuel. Cet exemple présuppose que vous
ayez deux machines chacune avec une seule connexion Internet. Chaque hôte
a une seule adresse IP. Derrière chacune de ces machines se trouve
des réseaux privés locaux configurés avec des adresses IP
réservées. Supposez que vous vouliez permettre à chacun
des hôtes du groupe A de se connecter à n'importe quel hôte
du groupe B, comme s'ils étaient vraiment connectés à
l'Internet via un routage réseau. L'encapsulation IPIP vous permettra
de le faire. À noter que l'encapsulation ne vous permettra pas  
 de faire en sorte que chacun des hôtes des 
réseaux A et B puissent parler à n'importe qui sur l'Internet,
vous aurez toujours besoin de choses comme le masquage IP pour pouvoir le faire.
L'encapsulation est normalement accomplie par une machine fonctionnant
comme routeur.
</para>
<para>
Le routeur Linux `<Literal remap="tt">A</Literal>' sera configuré comme suit :
</para>
<para>
        <Screen>
        #!/bin/sh
        PATH=/sbin:/usr/sbin
	mask=255.255.255.0
	remotegw=fff.ggg.hhh.iii
        #
        # configuration éthernet
        ifconfig eth0 192.168.1.1 netmask $mask up
        route add -net 192.168.1.0 netmask $mask eth0
        #
        # ppp0 configuration (start ppp link, set default route)
        pppd
        route add default ppp0
        #
        # configuration du périphérique de tunneling
        ifconfig tunl0 192.168.1.1 up
        route add -net 192.168.2.0 netmask $mask gw $remotegw tunl0
        </Screen>
</para>
<para>
Le routeur Linux `<Literal remap="tt">B</Literal>' sera configuré comme suit :
</para>
<para>
        <Screen>
	#!/bin/sh
        PATH=/sbin:/usr/sbin
	mask=255.255.255.0
	remotegw=aaa.bbb.ccc.ddd
        #
        # configuration éthernet
        ifconfig eth0 192.168.2.1 netmask $mask up
        route add -net 192.168.2.0 netmask $mask eth0
        #
        # ppp0 configuration (start ppp link, set default route)
        pppd
        route add default ppp0
        #
        # configuration du périphérique de tunneling
        ifconfig tunl0 192.168.2.1 up
        route add -net 192.168.1.0 netmask $mask gw $remotegw tunl0
        </Screen>
</para>
<para>
La commande :
</para>
<para>
<Screen>
root# route add -net 192.168.1.0 netmask $mask0 gw $remotegw tunl0
</Screen>
dit : `Envoyer tous les datagrammes destinés à 
<Literal remap="tt">192.168.1.0/24</Literal> dans un paquet d'encapsulation ayant pour adresses de
destination
<Literal remap="tt">aaa.bbb.ccc.ddd</Literal>'.
</para>
<para>
Notez que les configurations sont inversées à l'autre bout.
 Le périphérique tunnel utilise
 `<Literal remap="tt">gw</Literal>' dans la commande route comme <Emphasis>destination</Emphasis> du paquet IP
où se trouve le datagramme qu'il doit router.
Cette machine doit savoir comment `désencapsuler' les paquets IPIP,
c'est à dire qu'elle doit aussi être configurée comme
périphérique tunnel.
</para>
</Sect2>
<Sect2>
<title>Une configuration d'hôte pour l'encapsulation IPIP.</title>
<para>
Ce n'est pas tout un réseau que vous aurez à router. Vous  
pouvez par exemple ne router qu'une seule adresse IP. Dans ce cas vous
devrez configurer le périphérique
 <Literal remap="tt">tunl</Literal> sur la machine `distante' avec sa propre adresse IP et à
l'extrémité A n'utiliser qu'une route hôte (avec Proxy
Arp) plutôt qu'une route réseau via le périphérique 
tunnel. Refaisons et modifions notre configuration de manière 
appropriée. Maintenant nous avons seulement l'hôte
 `<Literal remap="tt">B</Literal>' qui veut agir comme s'il était à la fois 
connecté à l'Internet et également au réseau distant
supporté par l'hôte
 `<Literal remap="tt">A</Literal>' :
</para>
<para>
<Screen>
 192.168.1/24

     -
     |      ppp0 =                ppp0 =
     |  aaa.bbb.ccc.ddd      fff.ggg.hhh.iii
     |
     |   /- - -\                 /- - -\
     |   |     |       //        |     |
     |- -|  A  |- - - //- - - - -|  B  |
     |   |     |     //          |     |
     |   \- - -/                 \- - -/
     |                      aussi: 192.168.1.12
     -
</Screen>
</para>
<para>
Le routeur Linux  `<Literal remap="tt">A</Literal>' sera configuré comme suit :
</para>
<para>
        <Screen>
	#!/bin/sh
        PATH=/sbin:/usr/sbin
	mask=255.255.255.0
	remotegw=fff.ggg.hhh.iii
        #
        # configuration éthernet
        ifconfig eth0 192.168.1.1 netmask $mask up
        route add -net 192.168.1.0 netmask $mask eth0
        #
        # configuration de ppp0 (démarre le lien ppp link, règle la route par
	# défaut)
        pppd
        route add default ppp0
        #
        # configuration du périphérique de tunneling
        ifconfig tunl0 192.168.1.1 up
        route add -host 192.168.1.12 gw $remotegw tunl0
        #
        # Proxy ARP pour l'hôte distant
        arp -s 192.168.1.12 xx:xx:xx:xx:xx:xx pub
</Screen>
</para>
<para>
L'hôte Linux `<Literal remap="tt">B</Literal>' sera configuré comme suit :
</para>
<para>
        <Screen>
        #!/bin/sh
        PATH=/sbin:/usr/sbin
	mask=255.255.255.0
	remotegw=aaa.bbb.ccc.ddd
	#
        # configuration de ppp0 (démarre le lien ppp, règle la route par défaut)
        pppd
        route add default ppp0
        #
        # configuration du périphérique de tunelling
        ifconfig tunl0 192.168.1.12 up
        route add -net 192.168.1.0 netmask $mask gw $remotegw tunl0
        </Screen>
</para>
<para>
Ce type de configuration est vraiment typique d'une application IP-Mobile,
où un simple hôte veut seulement se balader sur l'Internet et 
maintenir une adresse IP utilisable tout le temps. Référez-vous 
au paragraphe Mobile-IP pour avoir plus d'informations 
et savoir comment faire en pratique.
</para>
</Sect2>
</Sect1>

<Sect1>
<title>IP Masquerade </title>
<para>
Un grand nombre de gens ont une simple connexion par téléphone pour 
aller sur l'Internet. Presque tout le monde ne se voit offrir qu'une 
seule adresse IP
 par le founisseur d'accès avec ce type de configuration. Ceci 
est normalement suffisant pour permettre un accès complet au 
réseau. IP Masquerade est une astuce intelligente qui vous permet 
d'avoir plusieurs machines utilisant une seule adresse IP, en faisant croire 
aux autres hôtes qu'il n'y a que la machine supportant la connexion 
(NdT : d'où le terme masquerade=duperie, mascarade).
 Il y a qu'une seule mise en garde, qui est que la fonction masquage ne 
travaille pratiquement que dans un seul sens : les hôtes masqués
 peuvent appeler mais ne peuvent accepter ou recevoir des connexions 
réseau de la part d'hôtes éloignés. Cela signifie 
que certains services réseau comme <Emphasis>talk</Emphasis> ne peuvent fonctionner et 
que d'autres, comme
 <Emphasis>ftp</Emphasis> doivent être configurés pour fonctionner en mode passif 
(PASV). Heureusement la plupart des services réseau comme 
 <Emphasis>telnet</Emphasis>, World Wide Web et <Emphasis>irc</Emphasis> fonctionnent correctement.
</para>
<para>
<Emphasis>Options de compilation du noyau</Emphasis> :
<Screen>
Code maturity level options  ---&#62;
    [*] Prompt for development and/or incomplete code/drivers
Networking options  ---&#62;
    [*] Network firewalls
    ....
    [*] TCP/IP networking
    [*] IP: forwarding/gatewaying
    ....
    [*] IP: masquerading (EXPERIMENTAL)
</Screen>
</para>
<para>
Normalement votre machine Linux supportant un lien SLIP ou PPP se comportera 
comme si elle était toute seule. De plus elle peut avoir un autre 
périphérique réseau configuré, par exemple une
 carte Ethernet, avec des adresses réseau réservée. Les 
hôtes masqués seront ceux du second réseau. Chacun 
de ces hôtes aura l'adresse IP du port Ethernet réglée 
comme passerelle ou routeur par défaut.
</para>
<para>
Une configuration typique ressemble à ceci :
</para>
<para>
<Screen>
-                                   -
 \                                  | 192.168.1.0
  \                                 |   /255.255.255.0
   \                 - - - - -      |
    |                | Linux | .1.1 |
NET =================| masq  |- - - |
    |    PPP/slip    | router|      |   - - - - 
   /                 - - - - -      | -| hôte |
  /                                 |  |      |
 /                                  |   - - - -
-                                   -
</Screen>
</para>
<Sect2>
<title>Masquerading avec IPFWADM (Noyaux 2.0.x)</title>

<para>Les commandes adéquates pour cette configuration sont :
</para>
<para>
<Screen>
# Routage réseau pour éthernet
route add -net 192.168.1.0 netmask 255.255.255.0 eth0
#
# Route par défaut pour le reste de l'internet.
route add default ppp0
#
# Fait en sorte que tous les hôtes du réseau 192.168.1/24  soient masqués.
ipfwadm -F -a m -S 192.168.1.0/24 -D 0.0.0.0/0 
</Screen>
</para>
</Sect2>
<Sect2>
<title>Masquerading avec IPCHAINS</title>
<para>Cela ressemble à l'utilisation avec IPFWADM mais la structure de la commande change:
</para>
<para>
  <Screen>
         # Routage réseau pour ethernet
         route add -net 192.168.1.0 netmask 255.255.255.0 eth0
         #
         # Route par défaut vers le reste de l'internet.
         route add default ppp0
         #
         # Fait en sorte que tous les hôtes sur le réseau 192.168.1/24 soient
	 # masqués.
 	ipchains -A forward -s 192.168.1.0/24 -j MASQ
         </Screen>
</para>
<para>
Vous pouvez obtenir plus d'informations sur IP Masquerade sur la
<ULink URL="http://ipmask.cjb.net/">
Page d'informations sur l'IP Masquerade</ULink>.
Il existe également un document <Emphasis>très</Emphasis> détaillé qui est le
``IP-Masquerade-mini-HOWTO'' (qui donne en plus des renseignements 
pour configurer d'autres systèmes d'exploitation pour fonctionner
avec un serveur de masquage linux).
</para>
<para>Pour obtenir des informations concernant les applications de IP
Masquerade, voyez la page <ulink url="http://www.tsmservices.com/masq/">
Applications IPMASK</ulink>.
</para>
</Sect2>
</Sect1>
<Sect1>
<title>IP Transparent Proxy</title>
<para>
IP transparent proxy est un procédé qui vous permet de rediriger des 
serveurs ou des services destinés à une autre machine vers les 
services de votre machine.
Typiquement c'est utile lorsque vous avez une machine 
Linux routeur et qui 
fournit aussi un serveur proxy. Vous redirigerez toutes les connexions 
à ce service distant vers le serveur proxy local.
</para>
<para>
<Emphasis>Options de compilation du noyau</Emphasis> :
<Screen>
Code maturity level options  ---&#62;
	[*] Prompt for development and/or incomplete code/drivers
Networking options  ---&#62;
	[*] Network firewalls
	....
	[*] TCP/IP networking
	....
	[*] IP: firewalling
	....
	[*] IP: transparent proxy support (EXPERIMENTAL)
</Screen>
</para>
<para>
La configuration du dispositif transparent proxy est réalisé en 
utilisant la commande
<Emphasis>ipfwadm</Emphasis>.
</para>
<para>
Par exemple :
</para>
<para>
<Screen>
ipfwadm -I -a accept -D 0/0 telnet -r 2323
</Screen>
</para>
<para>
Cet exemple fera en sorte que toutes les tentatives de connexion vers le port 
<Literal remap="tt">telnet</Literal> (23), de n'importe quel hôte, 
seront redirigées vers le port
 2323 de ce même hôte. Si vous utilisez un service sur ce port, vous pouvez
rediriger des connexions telnet, les enregistrer ou exécuter tout ce qui 
bon vous semble. 
</para>
<para>
Un exemple plus intéressant est la redirection de tout le trafic
<Literal remap="tt">http</Literal> au travers d'un cache local. Cependant, le protocole utlisé par
les serveurs proxy diffère du protocole natif de http : quand un client se
connecte à <Literal remap="tt">www.server.com:80</Literal> et demande <Literal remap="tt">chemin/page</Literal>,
quand il se connecte au cache local il contacte <Literal remap="tt">proxy.local.domain:8080</Literal>
et recherche <Literal remap="tt">www.server.com/chemin/page</Literal>.
</para>
<para>
Pour filtrer une demande <Literal remap="tt">http</Literal> au travers du proxy local, vous devez 
pouvoir adapter le protocole en insérant un petit serveur, appelé 
<Literal remap="tt">transproxy</Literal> (vous pouvez le trouver sur la toile). Vous pouvez choisir
de faire tourner <Literal remap="tt">transproxy</Literal> sur le port 8081, et exécuter la
commande :
</para>
<para>
<Screen>
ipfwadm -I -a accept -D 0/0 80 -r 8081
</Screen>
</para>
<para>
Alors le programme <Literal remap="tt">transproxy</Literal> recevra toutes les connexions
devant aller vers des serveurs externes et les passera au proxy local
après avoir corrigé les différences de protocole.
</para>
<para>
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>

<Sect1>
<title>IPv6</title>
<para>
À peine pensez-vous avoir commencé à comprendre comment 
fonctionne le réseau IP, que les règles ont changé !
 IPv6 est l'abbréviation de version 6 du `Protocole Internet'
 (version 6 de IP). Il fut développé initialement pour 
calmer les inquiétudes de la communauté Internet. Les utilisateurs
s'inquiétaient d'une pénurie proche d'adresses IP pouvant être allouées. 
 Les adresse IPv6 sont codées sur 16 octets (128 bits). IPv6 inclut un certain nombre d'autres 
changements, la plupart du temps des simplifications, qui rendront les 
réseaux IPv6 plus facilement gérables que les réseaux IPv4.
</para>
<para>
Linux a déjà une implémentation IPv6 qui marche, mais pas 
encore complètement, dans la série des noyaux <Literal remap="tt">2.2.*</Literal>.
</para>
<Para><Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
<Sect1>
<title>Sources de documentation pour IPv6 sous Linux</title>
<para>
<ULink URL="http://www.bieringer.de/linux/IPv6/IPv6-HOWTO.html">IPv6-HOWTO</ULink>
</para>
<para>
<ULink URL="http://www.xelia.ch/Linux/IPng.html">IPv6 pour Linux.</ULink>
</para>
<para>
<ULink URL="http://v6rpm.jindai.net/">Projet RPM Linux IPv6</ULink>
</para>
<para>
<ULink URL="http://www.linuxhq.com/IPv6/linux-ipv6.faq.html">FAQ/HOWTO IPv6</ULink>

</para>
<para><Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>


<Sect1>
<title>IP Mobile</title>
<para>
Le terme "mobilité IP" décrit la possibilité qu'un 
hôte a de transférer sa connexion réseau d'un point de 
l'Internet vers un autre sans changer d'adresse IP ou sans perdre la 
connectivité. Normalement quand un hôte IP change de point de 
connexion, il change aussi d'adresse IP.
La mobilité IP résoud ce problème en allouant une adresse 
IP fixe à l'hôte qui se déplace et en utilisant une 
encapsulation IP
(tunneling) avec routage automatique pour s'assurer que les datagrammes qui lui
 sont destinés seront routés vers l'adresse effectivement   
utilisée à ce moment.
</para>
<para>
Un projet est en cours en vue de fournir un paquetage complet 
d'outils Linux pour 
la mobilité IP. L'état de ce projet et les outils peuvent 
être obtenus sur :
<ULink URL="http://anchor.cs.binghamton.edu/~mobileip/">
	Linux Mobile IP Home Page</ULink>.
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
<Sect1>
<title>Multicast</title>
<para>
L'IP Multicast permet de router simultanément des datagrammes IP
vers un certain nombre d'hôtes se trouvant sur des réseaux différents. 
 Ce mécanisme est exploité 
pour fournir sur l'Internet des 
applications prenant de la bande passante, telles que les transmissions 
audio et video et autres nouvelles applications.
</para>
<para>
<Emphasis>Options de compilation du noyau</Emphasis> :
<Screen>
Networking options  ---&#62;
	[*] TCP/IP networking
	....
	[*] IP: multicasting
</Screen>
</para>
<para>
Un ensemble d'outils et quelques modifications de la configuration 
réseau sont nécessaires. 
Pour plus d'informations sur le support multicast pour Linux, voyez
le <ULink URL="Multicast-HOWTO.html">Multicast-HOWTO.html</ULink>
</para>
<Para><Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>


<Sect1>
<title>Mise en forme du trafic - Changer la bande passante allouée</title>

<para>
Le metteur en forme de trafic est un gestionnaire de périphérique qui crée
 de nouvelles interfaces; celles-ci sont limitées au point de vue trafic
selon les réglages de l'utilisateur, et se connectent aux 
  périphériques de réseau physiques pour la transmission réelle, 
  et peuvent donc être utilisées comme route vers l'extérieur en vue de
  trafic réseau.
</para>
<para>Le metteur en forme fut introduit sur Linux-2.1.15 et ensuite sur
Linux-2.0.36 (il apparut dans le <Literal remap="tt">2.0.36-pre-patch-2</Literal> distributé  par Alan
Cox, l'auteur du dispositif de mise en forme et le mainteneur de Linux-2.0).
</para>
<para>
Le metteur en forme de trafic ne peut être compilé qu'en tant que module,
et se configure à l'aide du programme
 <Emphasis>shapecfg</Emphasis> avec des commandes comme :
</para>
<para>
	<Screen>
	shapecfg attach shaper0 eth1
	shapecfg speed shaper0 64000
	</Screen>
</para>
<para>Ce metteur en forme de trafic ne peut contrôler que la bande passante
 du trafic sortant, car les paquets sont transmis par le metteur en forme
  si l'on se réfère aux tables de routage; ainsi, le fonctionnement
  suivant ``un routage par adresse de départ'' peut aider à limiter
   la bande passante totale d'hôtes spécifiques utilsant un routeur Linux.
</para>
<para>Linux-2.2 possède déjà le support pour un tel routage et si vous en avez
 besoin pour Linux-2.0, voyez le patch de Mike McLagan, sur 
 <Literal remap="tt">ftp.invlogic.com</Literal>. Lisez le fichier <Literal remap="tt">Documentation</Literal>networking/shaper.txt
 pour plus d'informations.
</para>
<para>Si vous voulez faire (une tentative de) mise en forme pour les paquets
 entrants, essayez <Literal remap="tt">rshaper-1.01</Literal> (ou plus récent), sur <ULink URL= "ftp://ftp.systemy.it/pub/develop">ftp.systemy.it</ULink>.
 </para>
 <para>
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
</chapter>
<chapter>
<title>DHCP et DHCPD</title>
<para>
DHCP est l'acronyme de «Dynamic Host Configuration Protocol» (Protocole
de configuration dynamique d'un hôte). La création de DHCP a rendu 
la configuration du réseau avec plusieurs hôtes extrêmement simple.
Au lieu de configurer chaque hôte séparément vous pouvez assigner tous
les paramètres communs à l'ensemble des hôtes utilisant un serveur DHCP.
</para>
<para>
Chaque fois qu'un hôte démarre il diffuse un paquet sur le réseau. Ce paquet
est un appel vers tous les serveurs DHCP situés sur le même segment pour
configurer l'hôte.
</para>
<para>
DHCP est extrêmement utile pour assigner des choses comme l'adresse IP, le
masque de réseau et la passerelle de chaque hôte.
</para>
<Sect1>
<title>Réglage d'un client DHCP pour les utilisateurs de LinuxConf</title>
<para>
Sous linux,  démarrez le programme linuxconf en tant que
super-utilisateur.
Ce programme est disponible avec toutes les versions de redhat et
fonctionne sous X aussi bien qu'en mode console. Il fonctionne également avec
les distributions Suse et Caldera.
</para>
<para>
<Screen>
Select Networking
-----------------&#62;Basic Host Information
-----------------&#62;Select Enable
-----------------&#62;Set Config Mode DHCP
</Screen>
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
<Sect1>
<title>Réglage d'un serveur DHCP sous Linux</title>
<para>
<Emphasis remap="bf">Récupérez DHCPD s'il n'est pas déjà installé sur votre machine.</Emphasis>
<ULink URL="ftp://ftp.isc.org/isc/dhcp/">Télécharger DHCPD</ULink>
</para>
<para>
<Emphasis remap="bf"><Emphasis>Note Brève: SOYEZ CERTAINS D'AVOIR L'OPTION MULTICAST INSTALLÉE
DANS LE NOYAU.
</Emphasis></Emphasis>
</para>
<para>
<Emphasis>Si vous n'avez pas de distribution binaire pour votre version de linux, vous devrez compiler DHCPD.</Emphasis>
</para>
<para>
Éditez /etc/rc.d/rc.local pour prendre en compte l'ajout d'une route vers
255.255.255.255.
</para>
<para>
<Emphasis remap="bf"><Emphasis>Extrait du fichier README de DHCPd :</Emphasis></Emphasis>
</para>
<para>

   
    Afin que dhcpd fonctionne correctement avec des clients difficiles
    (par exemple Windows 95), il doit être en mesure d'envoyer des paquets
    vers l'adresse 255.255.255.255. Malheureusement, Linux insiste pour
    changer l'adresse 255.255.255.255 en l'adresse de diffusion du sous-réseau
    local (ici, 192.5.5.223). Il en résulte une violation du protocole
    DHCP, et alors que de nombreux clients DHCP ne s'aperçoive pas de ce 
    problème, d'autres (par ex, tous les clients DHCP Microsoft) le font.
    Les clients ayant ce problème apparaîtront comme ne voyant pas les messages
    DHCPOFFER venant du serveur.
</para> 
<para>
Sous le compte root, tapez ce qui suit :
</para>
<para>
route add -host 255.255.255.255 dev eth0
</para>
<para>
Si le message suivant apparait :
</para>
<para>
255.255.255.255: Unknown host
</para>
<para>
Essayez d'ajouter la ligne suivante à votre fichier /etc/hosts :
</para>
<para>
255.255.255.255 dhcp
</para>
<para>
Puis réessayez :
</para>
<para>
route add -host dhcp dev eth0
</para>
<Sect2>
<title>Options de DHCPD</title>
<para>
Maintenant vous devez configurer DHCPd. Pour cela vous devez créer ou éditer
le fichier /etc/dhcpd.conf. Il existe une interface graphique pour la
configuration de dhcpd sous <ULink URL="http://www.solucorp.qc.ca">
linuxconf</ULink>. On configure et règle ainsi DHCPD très facilement.
</para>
<para>
Si vous voulez le configurer à la main, suivez les instructions qui suivent.
Je suggère de le faire au moins une fois à la main. Cela vous aidera pour
faire des diagnostiques, ce qu'une interface graphique ne peut vous offrir.
Malheureusement Microsoft n'y croit pas.
</para>
<para>
Le plus facile est d'assigner des adresses IP de manière aléatoire.
Ci-dessous un exemple de fichier de configuration montrant le type 
de réglage.
</para>
<para>

<Screen>
# Exemple de /etc/dhcpd.conf
# (ajoutez vos commentaires ici)
default-lease-time 1200;
max-lease-time 9200;
option subnet-mask 255.255.255.0;
option broadcast-address 192.168.1.255;
option routers 192.168.1.254;
option domain-name-servers 192.168.1.1, 192.168.1.2;
option domain-name "mydomain.org";
subnet 192.168.1.0 netmask 255.255.255.0 {
range 192.168.1.10 192.168.1.100;
range 192.168.1.150 192.168.1.200;
}
</Screen>
</para>
<para>
    Cela permet au serveur DHCP d'assigner au client une adresse IP comprise
    entre 192.168.1.10 et 192.168.1.100 ou bien 192.168.1.150 et 192.168.1.200. 
</para>
<para>

Une adresse IP sera allouée pendant 1200 secondes si le client ne demande pas
plus. Autrement l'allocation maximum permise sera 9200 secondes. Le serveur 
envoie les paramètres suivants au client : 
</para>
<para>

Utilisez 255.255.255.0 comme masque de sous-réseau
Utilisez 192.168.1.255 comme adresse de diffusion
Utilisez 192.168.1.254 comme passerelle par défaut 
Utilisez 192.168.1.1 et 192.168.1.2 comme serveurs DNS.
</para>
<para>
Si vous spécifiez un serveur WINS pour vos clients Windows, vous devez insérer
l'option suivante dans le fichier dhcpd.conf.
</para>
<para>
option netbios-name-servers 192.168.1.1;
</para>
<para>
Vous pouvez aussi assigner des adresses IP spécifiques basées sur une adresse
ethernet <Emphasis remap="bf">MAC</Emphasis>, par exemple
</para>
<para>
<Screen>
  host haagen {
     hardware ethernet 08:00:2b:4c:59:23;
     fixed-address 192.168.1.222;
}
</Screen>
</para>
<para>
Cela assignera l'adresse IP 192.168.1.222 au client ayant une adresse ethernet
<Emphasis remap="bf">MAC</Emphasis> de 08:00:2b:4c:59:23.
</para>
</Sect2>
<Sect2>
<title>Démarrage du serveur</title>
<para>
Dans la plupart des cas, l'installation de DHCP ne crée pas le fichier
 dhcpd.leases. Dès lors, avant de démarrer le serveur, vous devez créer un 
 fichier vide :
</para>
<para>
<Emphasis>touch /var/state/dhcp/dhcpd.leases</Emphasis>
</para>
<para>
Pour démarrer le serveur DHCP, tapez simplement (ou bien insérez-le dans
les scripts de démarrage)
</para>
<para>
<Emphasis> /usr/sbin/dhcpd</Emphasis>
</para>
<para>
Cela démarre dhcpd sur le dispositif eth0. Si vous devez le démarrer sur un
autre dispositif, tapez simplement
</para>
<para>
<Emphasis> /usr/sbin/dhcpd eth1</Emphasis>
</para>
<para>
Si vous voulez tester une configuration bizarre vous pouvez démarrer
dhcpd en mode débogage. En tapant la commande suivante, vous pourrez voir
exactement ce qui se passe sur le serveur.
</para>
<para>
<Emphasis>  /usr/sbin/dhcpd -d -f</Emphasis>
</para>
<para>
<Emphasis remap="bf">Démarrez un client</Emphasis> et jetez un coup d'oeil sur la console du serveur.
Vous verrez apparaître un grand nombre de messages de débogage. 
</para>
<para>
<Emphasis remap="bf"><Emphasis>C'est fini</Emphasis></Emphasis>
</para>
</Sect2>
</Sect1>
</chapter>
<chapter><title>Routage avancé avec Linux-2.2</title>
<para>
Le noyau 2.2 a accru les possibilités de routage de Linux de manière certaine.
Malheureusement la documentation pour exploiter ces nouvelles possibilités
est presque impossible à trouver, même si elle existe.
</para>
<para>
J'y ai passé un peu de temps et ai été en mesure de faire un petit quelque chose.
J'en mettrai plus quand j'aurai le temps et l'aide nécessaire pour comprendre
tout ce qui a été dit.
</para>
<para>
Dans les versions du noyau 2.0 et antérieures, Linux utilise la commande
<Emphasis>route</Emphasis> standard pour positionner les routes dans une seule table de
routage. Si vous aviez tapé <Emphasis>netstat -rn</Emphasis> à l'invite vous auriez pu
voir un exemple.
</para>
<para>
Dans les noyaux récents (2.1 et au-delà) vous avez une autre option.
Cette option est autorisée et vous permet d'avoir plusieurs tables de routage.
Les nouvelles règles donnent beaucoup plus de souplesse sur la façon de manipuler
les paquets. Vous pouvez choisir entre des routes basées non seulement sur
l'adresse de destination, mais aussi l'adresse de départ, TOS, ou un périphérique
de réception.
</para>
<Sect1>
<title>Les bases</title>
<para>
<Emphasis remap="bf">Afficher la table de routage :</Emphasis>
</para>
<para>
ip route
</para>
<para>
Maintenant sur ma machine cela donne la sortie suivante :
</para>
<para>
<Screen>
207.149.43.62 dev eth0  scope link
207.149.43.0/24 dev eth0  proto kernel  scope link  src 207.149.43.62
default via 207.149.43.1 dev eth0
</Screen>
</para>
<para>
La première ligne :
</para>
<para>
<Emphasis>207.149.43.62 dev eth0 scope link</Emphasis> est la route vers l'interface
</para>
<para>
La deuxième :
</para>
<para>
<Emphasis>207.149.43.0/24 dev eth0 proto kernel scope link src 207.149.43.62</Emphasis>
est la route qui dit <Emphasis>tout ce qui va vers 207.149.43.0 doit aller vers
 207.149.43.62</Emphasis>.
</para>
<para>
La troisième :
</para>
<para>
<Emphasis>default via 207.149.43.1 dev eth0</Emphasis> est la route par défaut.
</para>
<Sect2>
<title>Utiliser les informations</title>
<para>
Maintenant que nous avons vu une table de routage de base, voyons comment l'utiliser. Tout d'abord lisez
<ULink URL="http://www.compendium.com.ar/policy-routing.txt"> name="the Policy
routing text."</ULink> Si vous êtes embêtés, ne vous en faites pas -- c'est un texte
confus. Il vous donne tout ce que les nouvelles tables de routage peuvent faire.
</para>
</Sect2>
</Sect1>
<Sect1>
<title>Ajouter une route avec les nouveaux outils ip</title>
<para>
Dans la section précédente, nous avons mentionné comment afficher la table de
routage et comment comprendre les bases. Impeccable, la sortie ressemble
de très près à la syntaxe que nous devons utiliser pour mettre en place la table
de routage correspondant exactement à nos besoins.
</para>
<para>
<Screen>
ip route add 207.149.43.62 dev eth0  scope link
ip route add 207.149.43.0/24 dev eth0 proto kernel scope link src 207.149.43.62
ip route add 127.0.0.0/8 dev lo  scope link
ip route add default via 207.149.43.1 dev eth0
</Screen>
</para>
<para>
Comme vous pouvez le constater, les entrées et sorties sont presque les mêmes,
sauf le <Emphasis>ip route add</Emphasis> au début de chaque ligne.
</para>
<para>
<Emphasis>Note:</Emphasis> Je suis conscient que la documentation sur le routage avec les
noyaux 2.2 fait cruellement défaut. Dans les faits, je pense que TOUT LE MONDE
en est conscient. Si vous avez une petite expérience, contactez-nous s'il vous
plaît à
<ULink URL="mailto:poet@linuxports.com">poet@linuxports.com</ULink> 
nous aimerions obtenir les informations que vous avez pour nous aider
à étoffer notre documentation!
</para>

<Para><Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>

<Sect1>
<title>Utiliser NAT avec le noyau 2.2</title>
<para>

Le système de traduction d'adresse réseau (NAT: Network Address Translation)
ressemble plutôt au « grand frère » standardisé du système de masquage IP de Linux.
Il est décrit en détail dans la RFC-1631 sur votre archive RFC la plus proche.
NAT fournit des possibiltés que IP Masquerade ne sait pas faire, ce qui le
rend plus apte à une utilsation de routeur pare-feu pour un réseau d'entreprise
 et des installations de plus grande dimension.
</para>
<para>
Une implémentation alpha de NAT pour le noyau 2.0.29 de Linux a été développée
par
 Michael.Hasenstein, <Literal remap="tt">Michael.Hasenstein@informatik.tu-chemnitz.de</Literal>. 
 La documentation et l'implémentation de Michael se trouve sur :
</para>
<para>
<ULink URL="http://www.csn.tu-chemnitz.de/HyperNews/get/linux-ip-nat.html">la page web sur l'adressage réseau sous Linux</ULink>
</para>
<para>
L'empilement TCP/IP du noyau 2.2, qui a été grandement amélioré, inclut
les fonctionnalités de NAT. Ce système semble rendre obsolète le travail de
Michael Hasenstein (Michael@informatik.tu-chemnitz.de).
</para>
<para>
Pour le rendre opérationnel vous devez activer dans le noyau
 CONFIG&lowbar;IP&lowbar;ADVANCED&lowbar;ROUTER, CONFIG&lowbar;IP&lowbar;MULTIPLE&lowbar;TABLES (pour le système
 de routage) et CONFIG&lowbar;IP&lowbar;ROUTE&lowbar;NAT (pour un NAT rapide). De plus, si vous
 voulez utiliser un réglage plus fin de NAT, vous devez activer
le pare-feu (CONFIG&lowbar;IP&lowbar;FIREWALL) et CONFIG&lowbar;IP&lowbar;ROUTE&lowbar;FWMARK.
Pour faire fonctionner effectivement ces possibilités incluses dans le noyau,
vous aurez besoin du programme «ip» de Alexey Kuznyetsov 
récupéré sur ftp://ftp.inr.ac.ru/ip-routing/.
</para>
<para>
Datagrammes NAT entrants
</para>
<para>
Maintenant pour traduire les adresses des datagrammes entrants, on utilise
la commande suivante :
</para>
<para>
	<Screen>
	   ip route add nat &#60;ext-addr&#62;[/&#60;masklen&#62;] via &#60;int-addr&#62;
	</Screen>
</para>
<para>
Ceci fait qu'un paquet entrant destiné à l'adresse "ext-addr" 
(l'adresse visible sur l'internet extérieur) aura son champ d'adresse 
converti en "int-addr" (l'adresse de votre réseau interne, derrière votre
passerelle ou pare-feu). Le paquet est alors routé suivant la table de routage locale. Vous pouvez traduire soit une adresse hôte unique, soit des blocs complets.
<Emphasis>Exemples:</Emphasis>
</para>
<para>
<Screen>  
  	ip route add nat 195.113.148.34 via 192.168.0.2
   	ip route add nat 195.113.148.32/27 via 192.168.0.0
</Screen>
</para>
<para>
La première commande rend l'adresse interne 192.168.0.2 accessible en tant que
195.113.148.34. Le second exemple montre une réallocation du bloc
192.168.0.0-31 en 195.113.148.32-63.

<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
</chapter>

<!-- *********************************************************************** -->

<chapter>


<title>Les commandes IP pour les noyaux 2.2 (travail en cours)</title>

<Sect1>
<title>ip</title>
<para>
Si vous avez les outils iproute2 déjà installés, exécutez la commande ip,
ce qui vous permettra d'afficher la syntaxe de base.
</para>
<para>
<Screen>

[root@jd Net4]# ip
Usage: ip [ OPTIONS ] OBJECT { COMMAND | help }
where OBJECT := { link | addr | route | rule | neigh | tunnel |
                  maddr | mroute | monitor }
      OPTIONS := { -V[ersion] | -s[tatistics] | -r[esolve] |
                   -f[amily] { inet | ipv6 | dnet | link } | -o[neline] }

</Screen>
</para>
<para>
Il y a plusieurs options disponibles&nbsp;:
</para>
<para>
<Emphasis>-V, -Version</Emphasis> donne la version de l'utilitaire ip que vous employez
puis vous rend la main.
</para>
<para>
<Emphasis>-s, -stats, -statistics</Emphasis> donne plus d'informations concernant
le périphérique spécifié. Vous pouvez mentionner plusieurs fois cette option
pour afficher plus d'informations.
</para>
<para>
<Emphasis>-f, family suivi d'un nom identifiant la famille de protocole tel que :
inet, inet6 ou link </Emphasis> spécifie la famille de protocole à utiliser, inet
désignant le standard IPv4 (le standard internet actuel),
inet6 désignant IPv6 (révolutionnaire, un standard internet qui ne sera
jamais implanté), et link (un lien physique). Si
vous ne donnez pas d'options, la famille de protocole est devinée et s'il
n'y a pas assez d'informations, ip reviendra aux réglages par défaut.
</para>
<para>
<Emphasis>-o, -oneline</Emphasis> indique la sortie de chaque enregistrement de périphérique
en une seule ligne.
</para>
<para>
<Emphasis>-r, -resolve</Emphasis> utilise le résolveur du système (par exemple DNS), pour
imprimer les noms réels associés aux adresses IP.
</para>
<para>

<Emphasis>OBJECT</Emphasis> C'est l'objet/périphérique que l'on veut gérer ou bien 
sur lequel on veut obtenir des informations. Les types de périphériques 
qui sont compris par l'implémentation actuelle sont&nbsp;:
</para>
<para>
<ItemizedList>
<ListItem>
<para>
link -- Le périphérique réseau, par exemple eth0 ou ppp0 
</para>
</ListItem>
<ListItem>
<para>
address -- L'adresse IP (IP ou IPv6) du périphérique spécifié
</para>
</ListItem>
<ListItem>
<para>
neigh -- L'entrée de cache ARP ou NDISC
</para>
</ListItem>
<ListItem>
<para>
route -- L'entrée de la table de routage
</para>
</ListItem>
<ListItem>
<para>
rule -- Les règles de la base de données de la politique de routage
</para>
</ListItem>
<ListItem>
<para>
maddress -- L'adresse de multidiffusion
</para>
</ListItem>
<ListItem>
<para>
mroute -- L'entrée de cache de la route de multidiffusion
</para>
</ListItem>
<ListItem>
<para>
tunnel -- Faire ou non de l'encapsulation IP
</para>
</ListItem>
</ItemizedList>
</para>
<para>
Le nombre d'options possibles avec chaque type d'objet est fonction de la 
nature de l'action à entreprendre. Comme règle de base, il est possible 
d'<Emphasis>ajouter</Emphasis>,
de <Emphasis>supprimer</Emphasis>, ou de montrer le ou les objets, mais parmi ceux-ci
tous ne permettront pas d'utiliser des commandes supplémentaires. Bien sûr,
une commande d'aide est disponible pour chaque objet et lors de son utilisation,
celle-ci donnera une liste des conventions de syntaxe disponibles pour l'objet
en question.
</para>
<para>
Si vous ne spécifiez pas de commande, c'est celle par défaut qui sera exécutée.
Celle-ci donne la liste des objets, ou bien, si ce n'est pas
possible, vous obtiendrez une aide de base.
</para>
<para>
<Emphasis>ARGUMENTS</Emphasis> est la liste des arguments qui peuvent être donnés lors de
l'exécution de la commande. Le nombre d'arguments dépend de la commande et de
l'objet. Il existe deux types d'arguments :
</para>
<para>
<Emphasis>Les drapeaux</Emphasis> consistant en un mot-clé suivi d'une valeur. 
Pour la commodité, chaque argument possède quelques valeurs par défaut,
qui peuvent être omises pour une utilisation plus facile. Par exemple
le paramètre <Emphasis remap="bf">dev&#62;</Emphasis> est pris par défaut pour une commande telle que
<Emphasis>ip link</Emphasis>.
</para>
<para>

<Emphasis>Les erreurs... rendons grâce aux codeurs intelligents</Emphasis>
Toutes les actions induites par les commandes sont dynamiques. Si la syntaxe
est incorrecte, il n'y aura pas de changement dans la configuration du
système. Comme toujours, il existe une exception : la commande <Emphasis>ip link</Emphasis>
, utilisée pour changer certains paramètres d'un périphérique.
</para>
<para>
Il est difficile de donner la liste de tous les messages d'erreur
(en particulier les erreurs de syntaxe), mais normalement leur signification
est explicite suivant le contexte de la commande.
Les erreurs les plus fréquentes sont :

1. Le réseau n'est pas configuré dans le noyau. Le message est :
Cannot open netlink socket: Invalid value (ne peut ouvrir la socket : valeur incorrecte).
</para>
<para>
2. RTNETLINK n'est pas configuré dans le noyau. Dans ce cas on obtiendra l'un
des messages suivants, selon la commande :
Cannot talk to rtnetlink: Connection refused (ne peut dialoguer avec rtnetlink: connexion refusée)
Cannot send dump request: Connection refused  (ne peut envoyer
une demande de vidage (dump): connexion refusée).
</para>
<para>
3. L'option CONFIG_IP_MULTIPLE_TABLES n'a pas été choisie lors de la
configuration du noyau. Dans ce cas toute tentative d'utilisation de
la commande ip échouera, par exemple :
</para>
<para>
<Emphasis>jd@home $ ip rule list RTNETLINK error: Invalid argument dump terminated </Emphasis>
(erreur de règle ip dans la liste RTNETLINK: argument incorrect, vidage (dump) terminé).
</para>
<para>
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
</chapter>

<!-- *********************************************************************** -->

<chapter>
<title>Utilisation du matériel courant pour PC</title>

<Sect1>
<title>RNIS</title>
<para>
 Le Réseau Numérique à Intégration de Service (RNIS) (en anglais ISDN:
 Integrated Services Digital Network) 
est une série de normes donnant les spécifications d'un 
réseau de données numériques à usage 
général. Un `appel' RNIS crée un service synchrone de 
données point à point vers la destination. RNIS est 
généralement délivré sur une ligne à haut 
débit divisée en un certain nombre de canaux discrets.
Il y a deux types de canaux, les `canaux B' qui transportent 
effectivement les données utilisateurs, et un canal unique appelé
 `canal D' qui est utilisé pour envoyer les informations de 
contrôle pendant l'échange RNIS en vue d'établir des appels et 
autres fonctions. En Australie, par exemple, RNIS peut être fourni sur 
une liaison 2 Mps qui est divisée en 30 canaux B discrets de 
64 kps et un canal D de 64 kps.
N'importe quel nombre de canaux peuvent être utilisés en 
même temps et ceci dans toutes les combinaisons possibles. 
Vous pouvez par 
exemple établir 30 appels différents de 64 kps vers 30 
destinations différentes, ou bien 15 appels de 128 kps chacun vers 15 
destinations différentes (2 canaux utilisés par appel), ou 
seulement un petit nombre d'appels, le reste étant inactif.
Un canal peut être utilisé pour des appels entrant ou sortant. 
Le but initial de RNIS était de permettre aux sociétés de 
Télécommunications de fournir un seul service de données
 pouvant délivrer soit le téléphone (avec une voix 
numérisée) ou bien des services de données vers votre domicile ou 
votre bureau sans avoir à effectuer de changements pour 
obtenir une configuration spéciale.
</para>
<para>
Il y a plusieurs façons de connecter votre 
ordinateur à un service RNIS. L'une consiste à utiliser un 
dispositif appelé `Adaptateur de Terminal' qui se branche sur 
l'unité de terminal réseau que votre opérateur de 
télécommunications a installé au moment de l'obtention de
votre service RNIS, et qui présente des interfaces séries.
L'une de ces interfaces est utilisée pour entrer les commandes pour 
établir les appels et la configuration, et les autres sont 
reliées aux périphériques réseau qui utiliseront 
les circuits de données quand la connexion sera faite. Linux peut 
travailler avec ce type de configuration sans modification, vous devez juste 
traiter le port de l'adaptateur de terminal comme vous traitez tout 
périphérique série. Une autre façon, qui est la raison d'être
pour le support RNIS dans le noyau, vous permet d'installer une carte RNIS 
dans votre 
machine Linux et le logiciel Linux prend en charge les protocoles et fait 
les appels lui-même.
</para>
<para>
<Emphasis remap="bf">Options de compilation noyau</Emphasis> :
<Screen>
ISDN subsystem  ---&#62;
	&#60;<*&#62; ISDN support
	[ ] Support synchronous PPP
	[ ] Support audio via ISDN
	< &#62; ICN 2B and 4B support
	< &#62; PCBIT-D support
	< &#62; Teles/NICCY1016PC/Creatix support
</Screen>
</para>
<para>
L'implémentation Linux de RNIS supporte différents types de cartes 
internes RNIS.
 Il y a celles énumérées dans les options de configuration noyau :
</para>
<para>
<ItemizedList>
<ListItem>
<para>
ICN 2B and 4B
</para>
</Listitem>
<ListItem>
<para>
Octal PCBIT-D
</para>
</ListItem>
<ListItem>
<para>
Teles ISDN-cards et compatibles
</para>
</ListItem>
</ItemizedList>
</para>
<para>
Certaines de ces cartes ont besoin de logiciels devant être 
téléchargés pour les rendre opérationnelles. Il y a un 
utilitaire séparé pour le faire.
</para>
<para>
Tous les détails pour configurer le support RNIS Linux se trouvent dans 
le répertoire 
 <Emphasis>/usr/src/linux/Documentation/isdn/</Emphasis> et un document FAQ 
dédié à
 <Emphasis>isdn4linux</Emphasis> est disponible sur
<ULink URL="http://www.lrz-muenchen.de/~ui161ab/www/isdn/">
	www.lrz-muenchen.de</ULink>
(vous pouvez cliquer sur le drapeau anglais pour obtenir la version anglaise).
</para>
<para>
<Emphasis>Note au sujet de PPP</Emphasis>. L'ensemble des protocoles PPP peut travailler sur 
des lignes série synchrone ou asynchrone. Le démon PPP 
`<Emphasis>pppd</Emphasis>' couramment distribué pour Linux ne supporte que le mode 
asynchrone. Si vous désirez utiliser les protocoles PPP avec votre 
service RNIS vous aurez besoin d'une version spéciale. Les 
détails pour la trouver se trouvent dans la documentation 
mentionnée ci-dessus.
</para>
<para>
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
<Sect1>
<title>PLIP pour Linux-2.0</title>
<para>
Les noms de périphériques PLIP sont `<Literal remap="tt">plip0</Literal>', `<Literal remap="tt">plip1</Literal>', `<Literal remap="tt">plip2</Literal>'.
</para>
<para>
<Emphasis remap="bf">Options de compilation du noyau</Emphasis> :
<Screen>
Networking options  ---i&#62;
    &#60;*&#62; PLIP (parallel port) support
</Screen> 
</para>                           
<para>
<Emphasis>PLIP</Emphasis> (Parallel Line IP) est, comme SLIP,  
utilisé pour fournir une connexion réseau <Emphasis>point à 
point</Emphasis> entre deux machines, sauf qu'il est conçu pour 
utiliser les ports parallèles de votre machine au lieu des ports 
séries. Parce qu'il est possible de transmettre plus d'un bit en 
même temps avec un port parallèle, on peut atteindre des 
plus hautes vitesses avec l'interface
 <Emphasis>PLIP</Emphasis> qu'avec une sortie série standard (un schéma de
câblage est donné plus loin dans ce document).
 De plus, même 
 le plus simple des ports parallèles, le port imprimante, peut 
être utilisé, au lieu d'acheter un UART 16550AFN relativement cher
 pour vos ports séries. PLIP utilise beaucoup de CPU en comparaison d'une 
 liaison série et ce n'est sûrement pas un bon choix si vous avez 
 la possibilité d'avoir des cartes éthernet pas chères, mais ça fonctionne 
 lorsque rien d'autre n'est disponible, et ça fonctionne très bien.
</para>
 <para>
Les gestionnaires PLIP entrent en compétition avec les autres gestionnaires du matériel
branché sur le port parallèle. Si vous voulez utiliser les deux, vous devez alors
les compiler en tant que modules pour pouvoir choisir quel port vous voulez 
utiliser pour PLIP et quel port pour l'imprimante.
Voyez le document « Modules-mini-HOWTO » pour plus
d'informations sur la configuration des modules noyau.
</para>
<para>
Attention, notez que certains portables utilisent des circuits qui ne 
peuvent pas 
fonctionner avec PLIP car ils n'autorisent pas certaines combinaisons dont 
PLIP a besoin et que les imprimantes n'utilisent pas.
</para>
<para>
L'interface Linux <Emphasis>PLIP</Emphasis> est compatible avec le <Emphasis>Gestionnaire PLIP Crynwyr 
Packet
</Emphasis> et ceci signifie que vous pouvez connecter votre machine Linux avec une 
machine DOS tournant avec n'importe quel logiciel TCP/IP
 via <Emphasis>PLIP</Emphasis>.
</para>
<para>
Dans la série des noyaux 2.0.* les gestionnaires de périphérique PLIP sont affectés
aux ports e/s et IRQ comme suit :
</para>
<para>
<Screen>
device  i/o addr    IRQ
- - -   - - - -     - - -
plip0   0x3BC        5
plip1   0x378        7
plip2   0x278        2 
</Screen>
</para>
<para>
Si vos ports parallèles ne correspondent pas aux combinaisons 
précédentes alors vous pouvez changer les IRQ en utilisant la 
commande
 <Emphasis>ifconfig</Emphasis> avec le paramètre 
`<Literal remap="tt">irq</Literal>'. N'oubliez pas de valider les IRQ pour vos ports imprimantes dans 
votre ROM BIOS s'il supporte cette option. Un autre moyen consiste à
spécifier les options ``<Literal remap="tt">io=</Literal>'' et ``<Literal remap="tt">irq=</Literal>'' sur la ligne de 
commande de <Literal remap="tt">insmod</Literal>, si vous utilisez les modules. Par exemple :
</para>
<para>
<Screen>
root# insmod plip.o io=0x288 irq=5
</Screen>
</para>
<para>
Le fonctionnement de PLIP est contrôlé par deux temporisations de 
dépassement de temps, dont les valeurs par défaut devraient convenir la
plupart du temps. Vous devrez peut-être les augmenter si vous avez un ordinateur
particulièrement lent, auquel cas les valeurs devant être augmentées se trouvent
 sur l'<Emphasis remap="bf">autre</Emphasis> ordinateur. Il existe un programme appelé <Emphasis>plipconfig</Emphasis> qui
  permet d'effectuer ces réglages sans recompiler le noyau. Il est fourni
   avec de nombreuses distributions Linux.
</para>

 <para>Pour configurer une interface <Emphasis>plip</Emphasis>, vous devez invoquer les commandes
 suivantes (ou les <Emphasis>ajouter</Emphasis> à vos scripts d'initialisation) :
</para>
<para>
 <Screen>
 root# /sbin/ifconfig plip1 localplip pointopoint remoteplip
 root# /sbin/route add remoteplip plip1
 </Screen>
</para>
 <para>
Dans ce cas, le port utilisé est celui qui a l'adresse 0x378 ;
 <Emphasis>localplip</Emphasis> et <Emphasis>remoteplip</Emphasis> sont les adresses IP utilisées
 sur le câble PLIP. Je les mets personnellement dans la base de données
 <Literal remap="tt">/etc/host</Literal> :
</para>
<para>
 <Screen>
 # entrées plip
 192.168.3.1 localplip
 192.168.3.2 remoteplip
</Screen>
</para>
<para>
Le paramètre <Emphasis>pointopoint</Emphasis> a la même signification que 
pour  SLIP,
c'est-à-dire qu'il spécifie l'adresse de la machine
à l'autre bout de la liaison.
</para>
<para>
Dans la plupart des cas vous pouvez traiter l'interface <Emphasis>PLIP</Emphasis> comme si elle était une interface
 <Emphasis>SLIP</Emphasis>, sauf que ni <Emphasis>dip</Emphasis> ni
<Emphasis>slattach</Emphasis> ne doivent, ou ne peuvent, être utilisés.
</para>
<para>
Plus d'information sur PLIP peut être obtenu avec
le document ``PLIP-mini-HOWTO''.
</para>

<Sect2>
<title>PLIP pour Linux-2.2</title>
<para>
Durant le développement des versions 2.1 du noyau, le support concernant
les ports parallèles s'est amélioré.
</para>
<para><Emphasis>Options de compilation du noyau</Emphasis> :
<Screen>
General setup ---&#62;
    [*] Parallel port support
Network device support ---&#62;
    &#60;*&#62; PLIP (parallel port) support
</Screen>
</para>
<para>
Le nouveau code concernant PLIP se comporte comme l'ancien (on utilise
les mêmes commandes <Emphasis>ifconfig</Emphasis> et <Emphasis>route</Emphasis> comme dans le paragraphe
précédent), mais l'initialisation du système est différente en raison
du support port parallèle amélioré.
</para>
<para>
Le ``premier'' périphérique PLIP est toujours appelé ``plip0'', premier
signifiant celui qui est détecté en premier par le système, comme
pour les périphériques Ethernet. Le port parallèle utilisé de fait est
l'un de ceux qui sont disponibles, comme indiqué dans <Literal remap="tt">/proc/parport</Literal>.
Par exemple, si vous n'avez qu'un seul port parallèle, vous n'aurez qu'un seul
répertoire appelé <Literal remap="tt">/proc/parport/0</Literal>.
</para>
<para>
Si votre noyau ne détecte pas l'IRQ utilisée par votre port parallèle, 
``<Literal remap="tt">insmod plip</Literal>'' échouera ; dans ce cas, vous écrivez juste le chiffre
adéquat dans <Literal remap="tt">/proc/parport/0/irq</Literal> et vous invoquez de nouveau 
<Emphasis>insmod</Emphasis>.
</para>
<para>
Une information complète sur la gestion des ports parallèles est
disponible dans le fichier <Literal remap="tt">Documentation/parport.txt</Literal>, qui se
trouve dans les sources du noyau.
</para>
</Sect2>
</Sect1>
<Sect1>
<title>PPP</title>
<para>
En raison de la nature de PPP, sa taille, sa complexité, et sa souplesse
son propre HOWTO a été créé. Le PPP-HOWTO est toujours un
<ULink URL="http://www.linuxdoc.org">document du LDP</ULink> mais son site
officiel est sur <ULink URL="http://www.LinuxPorts.com">le site LinuxPorts</ULink> <ULink URL="http://www.linuxports.com/howto/ppp">à la section PPP</ULink>.

<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>

<Sect1>
<title>Client SLIP (Antique)</title>
<para>
Les fichiers de périphériques SLIP sont nommés 
`<Literal remap="tt">sl0</Literal>', `<Literal remap="tt">sl1</Literal>', etc. Le premier configuré étant
 `<Literal remap="tt">0</Literal>' et les autres s'incrémentant au fur et à mesure de leur configuration.
</para>
<para>
<Emphasis>Options de compilation du noyau</Emphasis> :
<Screen>
Network device support  ---i&#62;
    [*] Network device support
    &#60;*&#62; SLIP (serial line) support
    [ ]  CSLIP compressed headers
    [ ]  Keepalive and linefill
    [ ]  Six bit SLIP encapsulation
</Screen>
</para>
<para>
SLIP (Serial Line Internet Protocol) vous permet d'utiliser TCP/IP avec une 
ligne série, ce peut être un téléphone et un modem,
 ou tout autre ligne dédiée.
Bien sûr pour utiliser SLIP vous devez avoir accès à un 
<Emphasis>serveur SLIP</Emphasis> dans votre entourage.
De nombreuses universités et de sociétés fournissent des 
accès SLIP de par le monde.
</para>
<para>
SLIP utilise les ports séries de votre machine pour transporter les 
datagrammes IP. Pour cela il doit prendre le contrôle du 
périphérique série. Les noms de périphériques SLIP sont
<Emphasis>sl0</Emphasis>, <Emphasis>sl1</Emphasis>, etc. Comment ceux-ci correspondent avec vos 
périphériques série ? Le code réseau utilise ce que l'on nomme un appel
 <Emphasis>ioctl</Emphasis> (i/o control) pour transformer les périphériques série en 
périphériques SLIP. Il y a deux programmes qui peuvent faire 
cela, ce sont <Emphasis>dip</Emphasis> et <Emphasis>slattach</Emphasis>.
</para>


<Sect2>
<title>dip</title>
<para>
<Emphasis>dip</Emphasis> (Dialup IP) est un programme élégant  
capable de régler la vitesse du dispositif série, de demander 
à votre modem d'appeler l'autre extrémité de la ligne, de 
vous connecter automatiquement au serveur distant, de chercher des messages qui
 vous ont été envoyés par le serveur et d'en extraire des 
informations telles que votre adresse IP et de faire le
 <Emphasis>ioctl</Emphasis> nécessaire pour basculer votre port série en mode SLIP.
 <Emphasis>dip</Emphasis> est très flexible quant à l'utilisation de scripts et 
grâce à ceci vous pouvez automatiser vos procédures de connexion.
</para>
<para>
On peut le trouver sur :
<ULink URL="ftp://metalab.unc.edu/pub/Linux/system/Network/serial/dip/dip337o-uri.tgz">metalab.unc.edu</ULink>.
</para>
<para>
Pour l'installer faites :
</para>
<para>
<Screen>
user% tar xvfz dip337o-uri.tgz
user% cd dip-3.3.7o
user% vi Makefile
root# make install
</Screen>
</para>
<para>
Le fichier <Literal remap="tt">Makefile</Literal> suppose l'existence d'un groupe nommé 
<Emphasis>uucp</Emphasis>,
mais vous pouvez le changer en <Emphasis>dip</Emphasis> ou <Emphasis>SLIP</Emphasis>, selon votre 
configuration.
</para>
</Sect2>
<Sect2>
<title>slattach</title>

<para>
<Emphasis>slattach</Emphasis> au contraire de <Emphasis>dip</Emphasis> est un programme très 
simple, très facile à utiliser, mais qui n'a pas la sophistication de
 <Emphasis>dip</Emphasis>.
Il n'a pas la possiblité d'accepter des scripts, tout ce qu'il fait étant 
de configurer votre périphérique série en 
périphérique SLIP. Il suppose que vous avez toutes les 
informations nécessaires et que la liaison série est 
établie avant de l'invoquer.
 <Emphasis>slattach</Emphasis> est idéal quand vous avez une liaison permanente avec
 votre serveur, comme un câble physique ou une ligne dédiée.
</para>
</Sect2>

<Sect2>
<title>Quand utiliser quoi ?</title>

<para>
Vous devriez utiliser <Emphasis>dip</Emphasis> lorsque votre liaison vers la machine qui est 
votre serveur SLIP est un modem, ou tout autre lien intermittent. Vous devriez 
utiliser <Emphasis>slattach</Emphasis> quand vous avez une ligne dédiée, 
peut-être un câble, entre votre machine et le serveur et qu'il n'y 
a pas d'action spéciale nécessaire pour garder la ligne en 
activité. Voir la section `Connexion SLIP permanente' pour plus de détails.
</para>
<para>
Configurer SLIP est analogue à la configuration 
d'une interface Ethernet (voir la 
section `Configurer un périphérique Ethernet' ci-dessus). 
Cependant, il existe quelques différences.
</para>
<para>
Tout d'abord, les liens SLIP ne sont pas des réseaux Ethernet en ce sens
qu'il n'y a que deux hôtes sur le réseau, un à chaque 
extrémité de la liaison. À la différence de l'Ethernet qui
 est disponible dès que vous êtes câblé, avec SLIP, 
en fonction du type de lien que vous avez, vous serez amené à 
initialiser votre connexion réseau d'une manière spéciale.
</para>
<para>
Si vous utilisez <Emphasis>dip</Emphasis>, alors cela ne sera pas fait au moment du 
démarrage de la machine, mais plus tard, quand vous serez prêt à
 utiliser la liaison.
Il est possible d'automatiser la procédure. Si vous utilisez 
<Emphasis>slattach</Emphasis> vous voudrez probablement ajouter une section dans votre 
fichier
 <Emphasis>rc.inet1</Emphasis>.
Ceci sera décrit bientôt.
</para>
<para>
Il y a deux types principaux de serveurs SLIP : serveurs avec adressage IP 
dynamique et serveurs avec adressage IP statique. Presque tous les serveurs 
SLIP vous demanderont à la connexion d'utiliser un nom d'utilisateur et 
un mot de passe quand vous composez le numéro.
 <Emphasis>dip</Emphasis> peut prendre en charge la connexion automatiquement.
</para>
</Sect2>

<Sect2>
<title>Serveur SLIP statique avec une ligne téléphonique
 et DIP</title>

<para>
Le serveur SLIP statique est celui qui vous fournit une adresse IP qui reste
 exclusivement la vôtre. À chaque fois que vous vous connectez à ce
 serveur, vous configurez votre port SLIP avec cette adresse. Le serveur SLIP
 statique répond à votre appel par modem, vous demande probablement 
  un nom d'utilisateur et un mot de passe, et ensuite dirige tous
 les datagrammes destinés à votre adresse au travers de
 cette connexion. Si vous avez un serveur statique, alors vous mettez des
 entrées pour votre nom d'hôte et votre adresse IP (puisque vous 
savez ce qu'elle sera) dans votre fichier
<Literal remap="tt">/etc/hosts</Literal>. Vous devez aussi configurer d'autres fichiers
 comme :
<Literal remap="tt">rc.inet2</Literal>, <Literal remap="tt">host.conf</Literal>, <Literal remap="tt">resolv.conf</Literal>,
<Literal remap="tt">/etc/HOSTNAME</Literal> et <Literal remap="tt">rc.local</Literal>. N'oubliez pas qu'en configurant
<Literal remap="tt">rc.inet1</Literal>, vous n'avez pas besoin d'ajouter de commandes 
spéciales pendant la connexion SLIP puisque c'est
 <Emphasis>dip</Emphasis> qui fait tout le dur labeur à votre place en configurant 
votre interface. Vous avez besoin de donner à
 <Emphasis>dip</Emphasis> les informations adéquates et il configure l'interface 
pour vous après avoir demandé au modem d'établir 
l'appel et de vous connecter au serveur.
</para>
<para>Si votre serveur SLIP fonctionne comme cela alors vous pouvez directement 
aller à la section `Utiliser Dip' pour apprendre à configurer
 <Emphasis>dip</Emphasis> convenablement.
</para>
</Sect2>

<Sect2>
<title>Serveur SLIP dynamique avec une ligne téléphonique et DIP</title>

<para>
Le serveur SLIP <Emphasis>dynamique</Emphasis> vous alloue une adresse IP de
 manière aléatoire, à partir d'un groupe d'adresses,
 à chaque fois que vous vous connectez. Cela signifie qu'il n'y a
 aucune garantie d'avoir la même adresse à chaque fois, et que
 celle-ci peut être utilisée par quelqu'un d'autre
 après la déconnexion. L'administrateur réseau qui a
 configuré le serveur SLIP a assigné un groupe d'adresses que 
le serveur SLIP peut utiliser quand il reçoit un appel entrant. Il
 prend alors la première adresse inutilisée, guide l'appelant au
 travers du processus de connexion et envoie un message de bienvenue contenant 
l'adresse IP qu'il a allouée et continue d'utiliser cette adresse tout
 le temps de l'appel.
</para>
<para>
Configurer ce type de serveur revient à configurer un serveur statique, 
sauf que vous devez ajouter une étape pour obtenir 
l'adresse IP allouée par le serveur puis configurer le 
périphérique SLIP avec celle-ci.
</para>
<para>
Encore une fois, <Emphasis>dip</Emphasis> fait le sale boulot et les nouvelles versions 
sont suffisamment élégantes pour non seulement établir la 
connexion, mais aussi pour lire l'adresse IP inscrite dans le message de 
bienvenue et la stocker de telle sorte que vous puissiez configurer votre 
périphérique SLIP avec.
</para>
<para>
Si votre serveur SLIP fonctionne ainsi, alors vous 
pouvez aller à la section `Utiliser DIP' pour savoir comment configurer
 <Emphasis>dip</Emphasis> de manière adéquate.
</para>
</Sect2>

<Sect2>
<title>Utiliser DIP</title>

<para>
Comme expliqué plus haut, <Emphasis>dip</Emphasis> est un programme puissant
qui simplifie et automatise le processus de composition d'un numéro
vers un serveur SLIP, se connecte dessus, démarre la connexion et
configure les périphériques SLIP à l'aide des commandes
 <Emphasis>ifconfig</Emphasis> et <Emphasis>route</Emphasis> appropriées.
</para>
<para>
Essentiellement, pour utiliser <Emphasis>dip</Emphasis> vous écrivez un `script dip'
qui est tout simplement une liste de commandes que
 <Emphasis>dip</Emphasis> comprend et qui lui dit
 comment réaliser chacune des actions que vous voulez qu'il
fasse. Voyez le fichier
<Literal remap="tt">sample.dip</Literal> fourni avec <Emphasis>dip</Emphasis> pour avoir une idée de
la manière dont il travaille.
 <Emphasis>dip</Emphasis> est vraiment un programme puissant, avec beaucoup d'options.
Au lieu de regarder chacune d'elles, il vaut mieux jeter un coup d'oeil dans
la page de manuel, le fichier README et les fichiers d'exemple qui sont fournis
avec votre version de <Emphasis>dip</Emphasis>.
</para>
<para>
Vous pouvez noter que le script <Literal remap="tt">sample.dip</Literal> suppose que vous utilisez
un serveur SLIP statique, aussi vous connaissez votre adresse IP à
l'avance. Pour les serveurs SLIP dynamiques, les nouvelles versions de 
 <Emphasis>dip</Emphasis> incluent une commande que vous pouvez utiliser pour lire
 et configurer automatiquement votre périphérique SLIP avec
l'adresse IP donnée par le serveur dynamique. L'exemple suivant
est une version modifiée du fichier
 <Literal remap="tt">sample.dip</Literal> fourni avec
<Emphasis>dip337j-uri.tgz</Emphasis> et qui est probablement un bon point de départ
pour vous. Vous pouvez le sauvegarder sous le nom de
 <Literal remap="tt">/etc/dipscript</Literal> et l'éditer pour l'adapter à votre
configuration :
</para>
<para>
<Screen>
#
# sample.dip	Programme de support pour connexion IP.
#
#	Ce programme (devrait montrer) montre comment utiliser DIP
#       Il devrait fonctionner avec des serveurs dynamiques de type Annex,
#       et si vous utilsez un serveur avec adresse statique utilsez alors le
#       fichier sample.dip livré avec le paquetage dip337-uri.tgz.
#
#
# Version:	@(#)sample.dip	1.40	07/20/93
#
# Auteur:	Fred N. van Kempen, &#60;waltje@uWalt.NL.Mugnet.ORG&#62;
#

main:
# Après, postionner l'adresse et le nom de l'hôte distant.
# Ma machine s'appelle 'xs4all.hacktic.nl' (== 193.78.33.42)
get $remote xs4all.hacktic.nl
# Positionne le masque de réseau sur sl0 à 255.255.255.0
netmask 255.255.255.0
# Règle le port série et la vitesse.
port cua02
speed 38400

# Reset le modem et la ligne de terminal.
# Cela semble poser problème à certains!
reset

# Notez! Valeurs "standards" prédéfinies de "errlevel":
#  0 - OK
#  1 - CONNECT
#  2 - ERROR
#
# Vous pouvez les changer en faisant un grep dans *.c avec "addchat()"...

# On se prépare pour numéroter.
send ATQ0V1E1X4\r
wait OK 2
if $errlvl != 0 goto modem_trouble
dial 555-1234567
if $errlvl != 1 goto modem_trouble

# Nous sommes connectés. Nous nous enregistrons sur le système.
login:
sleep 2
wait ogin: 20
if $errlvl != 0 goto login_trouble
send MYLOGIN\n
wait ord: 20
if $errlvl != 0 goto password_error
send MYPASSWD\n
loggedin:

# Maintenant nous sommes enregistrés.
wait SOMEPROMPT 30
if $errlvl != 0 goto prompt_error

# Demande au serveur de basculer en mode SLIP
send SLIP\n
wait SLIP 30
if $errlvl != 0 goto prompt_error

# Obtenir et ajuster notre adresse IP grâce au serveur.  
# Ici nous supposons qu'après le basculement du serveur en mode SLIP, celui-ci
# nous donne l'adresse IP
#   mode that it prints your IP address
get $locip remote 30
if $errlvl != 0 goto prompt_error

# réglage des paramètres SLIP.
get $mtu 296
# S'assurer que "route add -net default xs4all.hacktic.nl" sera fait
default

# Dire bonjour, et en avant!
done:
print CONNECTED $locip ---&#62; $rmtip
mode CSLIP
goto exit

prompt_error:
print TIME-OUT waiting for sliplogin to fire up...
goto error

login_trouble:
print Trouble waiting for the Login: prompt...
goto error

password:error:
print Trouble waiting for the Password: prompt...
goto error

modem_trouble:
print Trouble occurred with the modem...
error:
print CONNECT FAILED to $remote
quit

exit:
exit
</Screen>
</para>
<para>L'exemple précédent suppose que vous appeliez un serveur SLIP
 <Emphasis>dynamique</Emphasis> ; si vous appelez un serveur SLIP
<Emphasis>statique</Emphasis>,  alors le fichier <Literal remap="tt">sample.dip</Literal> fourni avec
 <Emphasis>dip337j-uri.tgz</Emphasis> devrait vous convenir.
</para>
<para>
Quand on donne à <Emphasis>dip</Emphasis> la commande <Emphasis>get &dollar;local</Emphasis>, 
il cherche dans le texte venant de l'extrémité de la ligne
une chaîne de caractères ressemblant à une adresse IP,
c'est à dire des ensembles de nombres séparés par des
caractères `.'. Cette modification fut mise en place plus 
spécialement pour les serveurs SLIP 
<Emphasis>dynamiques</Emphasis>, afin que le processus de lecture de l'adresse IP
fournie par le serveur soit automatisé.
</para>
<para>
L'exemple ci-dessus crée automatiquement une route par défaut
 via votre liaison SLIP, et si ce n'est pas ce que vous voulez, car vous
avez une connexion Ethernet qui devrait être votre route par
défaut, alors enlevez la commande
 <Emphasis>default</Emphasis> du script.
Après que le script ait fini de tourner, tapez la commande 
<Emphasis>ifconfig</Emphasis>, et vous verrez que vous avez un périphérique
 <Emphasis>sl0</Emphasis>. C'est votre périphérique SLIP. Si le besoin s'en 
fait sentir, vous pouvez modifier manuellement sa configuration, après
que la commande <Emphasis>dip</Emphasis> soit finie, en utilisant les commandes
<Emphasis>ifconfig</Emphasis> et
<Emphasis>route</Emphasis>.
</para>
<para>
Notez que <Emphasis>dip</Emphasis> vous permet de choisir parmi différents
protocoles en utilisant la commande <Literal remap="tt">mode</Literal>, l'exemple le plus
courant étant <Emphasis>cSLIP</Emphasis> pour utiliser SLIP avec compression.
Notez encore que les deux extrémités de la liaison doivent
être d'accord, aussi assurez-vous que ce que vous avez choisi est
en accord avec les réglages du serveur.
</para>
<para>
L'exemple montré ci-dessus est plutôt robuste et devrait
faire face à la plupart des erreurs. Référez-vous
à la page de manuel de <Emphasis>dip</Emphasis> pour plus d'informations.
Naturellement, vous pouvez, par exemple, modifier le script pour réaliser
des choses comme recomposer le numéro vers le serveur si la connexion 
n'a pas été faite au bout d'un certain temps, ou même
 essayer une série de serveurs si vous avez accès à
plus d'un d'entre eux.
</para>
</Sect2>

<Sect2>
<title>Connexion permanente SLIP utilisant une ligne et slattach</title>
<para>
Si vous avez deux machines reliées par un câble, ou si vous
êtes suffisamment riche pour avoir une ligne dédiée,
ou un autre type de connexion permanente entre votre machine et une autre,
alors vous n'avez pas besoin de vous casser la tête avec <Emphasis>dip</Emphasis>
pour régler votre liaison série.
 <Emphasis>slattach</Emphasis> est un utilitaire très simple à utiliser
et vous permet d'avoir les fonctionnalités juste nécessaires
pour configurer votre connexion.
</para>
<para>
Puisque votre connexion est permanente, vous ajoutez quelques commandes
dans votre fichier <Literal remap="tt">rc.inet1</Literal>. Tout ce dont vous avez besoin pour
une connexion permanente est de vous assurer que vous avez configuré
votre périphérique série à la bonne vitesse et
basculer votre périphérique série en mode SLIP.
 <Emphasis>slattach</Emphasis> vous permet de faire ceci avec une seule commande.
Ajoutez ce qui suit à votre fichier
<Literal remap="tt">rc.inet1</Literal> :
</para>
<para>
<Screen>
#
# Attache une connexion SLIP statique sur une ligne dédiée
#
#  configure /dev/cua0 à la vitesse de 19.2kbps et cslip
/sbin/slattach -p cslip -s 19200 /dev/cua0 &#38;
/sbin/ifconfig sl0 IPA.IPA.IPA.IPA pointopoint IPR.IPR.IPR.IPR up
#
# Fin de SLIP statique.
</Screen>
</para>
<para>
Où :
<VariableList>
<VarListEntry>
<Term>IPA.IPA.IPA.IPA</Term>
<ListItem>
<para>
représente votre adresse IP.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>IPR.IPR.IPR.IPR</Term>
<ListItem>
<para>
représente l'adresse IP de 
l'hôte distant.
</para>
</ListItem>
</VarListEntry>
</VariableList>
</para>
<para>
<Emphasis>slattach</Emphasis> alloue le premier périphérique SLIP disponible
 au périphérique série spécifié.
 <Emphasis>slattach</Emphasis> démarre avec <Emphasis>sl0</Emphasis>. Par conséquent la 
première commande <Emphasis>slattach</Emphasis> relie le périphérique
<Emphasis>sl0</Emphasis> au périphérique spécifé, puis <Emphasis>sl1</Emphasis> la fois suivante, etc.
</para>
<para>
<Emphasis>slattach</Emphasis> vous permet de configurer un certain nombre de protocoles
grâce à l'argument <Literal remap="tt">-p</Literal>. Dans votre cas vous utilisez
soit <Emphasis>SLIP</Emphasis> soit <Emphasis>cSLIP</Emphasis> suivant que vous voulez utiliser la 
compression ou non.

Note : les deux extrémités doivent être d'accord sur
l'utilisation de la compression.
</para>
</Sect2>

<Sect2>
<title>Serveur SLIP</title>
<para>
Vous avez peut-être une machine connectée au réseau
et vous aimeriez que d'autres personnes puissent s'y connecter pour y chercher
des services de réseau, alors vous devez configurer votre machine
comme serveur. Si vous voulez utiliser SLIP comme protocole de ligne
série, vous avez trois possiblités pour configurer votre
machine Linux comme serveur SLIP. Ma préférence est la 
première présentée, <Emphasis>sliplogin</Emphasis>, car elle semble
la plus facile à configurer et à comprendre, mais je
présenterai un résumé pour chacune, ainsi vous pourrez
décider par vous-même.
</para>
</Sect2>

<Sect2>
<title>Serveur SLIP utilisant <Emphasis>sliplogin</Emphasis>.</title>
<para>
<Emphasis>sliplogin</Emphasis> est un programme que vous pouvez utiliser à la place
du shell normal de connexion pour les utilisateurs SLIP, et qui convertit
la ligne terminal en ligne SLIP. Il vous permet de configurer votre
machine Linux soit en <Emphasis>serveur à adresse statique</Emphasis> (les utilisateurs
obtiennent toujours la même adresse à chaque connexion), soit
en <Emphasis>serveur à adresse dynamique</Emphasis> (les utilisateurs obtiennent
une adresse qui n'est pas forcément la même 
que lors de la connexion précédente).
</para>
<para>
L'appelant se connecte comme sur un terminal standard, en donnant son
nom d'utilisateur et son mot de passe, mais au lieu d'avoir une invite de
shell après la connexion, <Emphasis>sliplogin</Emphasis> est exécuté 
et cherche dans son fichier de configuration une entrée dont le nom
correspond à celui de l'appelant. S'il en détecte
une, il configure la ligne avec 8 bits de données,
et utilise un appel <Emphasis>ioctl</Emphasis> pour basculer celle-ci en ligne SLIP.
Quand ce processus est fini, la dernière étape de la
configuration prend place, <Emphasis>sliplogin</Emphasis> invoquant un script qui configure
l'interface SLIP avec l'adresse IP adéquate, ainsi que le masque de
réseau et positionne le routage approprié. Ce script est
appelé habituellement <Literal remap="tt">/etc/slip.login</Literal>, mais tout comme
<Emphasis>getty</Emphasis>, si certains appelants nécessitent une initialisation
spéciale, alors vous pouvez créer des scripts de configuration
appelés <Literal remap="tt">/etc/slip.login.loginname</Literal> qui seront utilisés
à la place du script par défaut.
</para>
<para>
Il y a quelques fichiers que vous devez configurer pour que
<Emphasis>sliplogin</Emphasis> travaille pour vous. Je décrirai comment et où
obtenir les logiciels et comment chacun est configuré. Ces fichiers sont :
</para>
<para>
<ItemizedList>
<ListItem>
<para>
<Literal remap="tt">/etc/passwd</Literal>, pour l'acceptation des utilisateurs entrants;
</para>
</ListItem>
<ListItem>
<para>
<Literal remap="tt">/etc/slip.hosts</Literal>, qui contient une information spécifique de chaque utilisateur entrant;
</para>
</ListItem>
<ListItem>
<para>
<Literal remap="tt">/etc/slip.login</Literal>, qui s'occupe de la configuration du routage;
</para>
</ListItem> 
<ListItem>
<para>
<Literal remap="tt">/etc/slip.tty</Literal>, requis uniquement si vous configurez votre
serveur avec <Emphasis>allocation d'adresse dynamique</Emphasis> : il contient une 
table des adresses à allouer.
</para>
</ListItem>
<ListItem>
<para>
<Literal remap="tt">/etc/slip.logout</Literal>, qui contient les commandes de `nettoyage' 
après une déconnexion volontaire ou intempestive.
</para>
</ListItem>
</ItemizedList>
</para>
</Sect2>
<Sect2>
<title>Où obtenir <Emphasis>sliplogin</Emphasis></title>
<para>
Votre distribution contient peut-être déjà le paquetage;
si ce n'est pas le cas alors <Emphasis>sliplogin</Emphasis> peut être obtenu sur
<ULink URL="ftp://metalab.unc.edu/pub/linux/system/Network/serial/sliplogin-2.1.1.tar.gz">metalab.unc.edu</ULink>.
Le fichier tar contient à la fois les sources, les binaires 
précompilés et une page de <Emphasis>manuel</Emphasis>.
</para>
<para>
Pour s'assurer que seuls les utilisateurs autorisés pourront faire
tourner le programme <Emphasis>sliplogin</Emphasis>, vous devez ajouter une entrée
dans votre fichier <Literal remap="tt">/etc/group</Literal> similaire à la suivante :
</para>
<para>
<Screen>
 ..
slip::13:radio,fred
 ..
</Screen>
</para>
<para>
Lorsque vous installez le paquetage <Emphasis>sliplogin</Emphasis>, <Literal remap="tt">Makefile</Literal> 
change le groupe du programme <Emphasis>sliplogin</Emphasis> en <Literal remap="tt">slip</Literal>, et cela
signifie que seuls les utilisateurs qui appartiennent à ce groupe
pourront l'exécuter. L'exemple donné ci-dessus ne permet
qu'aux utilisateurs <Literal remap="tt">radio</Literal> et <Literal remap="tt">fred</Literal> de pouvoir faire tourner
le programme <Emphasis>sliplogin</Emphasis>.
</para>
<para>
Pour installer les binaires dans le répertoire <Literal remap="tt">/sbin</Literal> 
et les pages de <Emphasis>manuel</Emphasis> dans la section 8, faites :
</para>
<para>
<Screen>
root# cd /usr/src
root# gzip -dc .../sliplogin-2.1.1.tar.gz | tar xvf -
root# cd sliplogin-2.1.1
root# &#60;..éditez le Makefile si vous n'utilisez pas les shadow passwords..&#62;
root# make install
</Screen>
</para>
<para>
Si vous voulez recompiler les binaires avant de les installer, faites
<Literal remap="tt">make clean</Literal> avant de faire <Literal remap="tt">make install</Literal>. Si vous voulez installer
les binaires autre part, vous devez éditer le fichier <Literal remap="tt">Makefile</Literal>
et le modifier en conséquence.
</para>
</Sect2>

<Sect2>
<title>Configurer <Literal remap="tt">/etc/passwd</Literal> pour utiliser SLIP</title>
<para>
Normalement vous devez créer des noms d'utilisateurs spéciaux,
pour ceux qui appellent avec SLIP, dans votre fichier <Literal remap="tt">/etc/passwd</Literal>.
Une convention souvent suivie est d'utiliser le <Emphasis>nom d'utilisateur</Emphasis> de
l'appelant préfixée avec la lettre capitale `S'.
Ainsi, par exemple, si l'appelant s'appelle <Literal remap="tt">radio</Literal> alors
vous pouvez créer une entrée dans le fichier <Literal remap="tt">/etc/passwd</Literal>
ressemblant à ceci :
</para>
<para>
<Screen>
Sradio:FvKurok73:1427:1:radio SLIP login:/tmp:/sbin/sliplogin
</Screen>
</para>
<para>
Le nom du compte n'a pas réellement d'importance, du moment qu'il
ait une signification pour vous.
</para>
<para>
Note : l'appelant n'a pas besoin de répertoire home spécial
car il n'utilisera pas de shell sur la machine, dès lors <Literal remap="tt">/tmp</Literal>
est un bon choix. Notez bien que <Emphasis>sliplogin</Emphasis> est utilisé
à la place du shell de connexion normal.
</para>
</Sect2>

<Sect2>
<title>Configurer <Literal remap="tt">/etc/slip.hosts</Literal></title>
<para>
Le fichier <Literal remap="tt">/etc/slip.hosts</Literal>  est le fichier où <Emphasis>sliplogin</Emphasis>
cherche les entrées correspondant au nom de connexion pour obtenir
les détails de configuration. C'est le fichier
où sont indiqués l'adresse IP et le masque de réseau qui
seront assignés à l'appelant et configurés pour leur
usage. Des exemples d'entrées pour deux utilisateurs, une 
statique pour  <Literal remap="tt">radio</Literal> et l'autre dynamique pour <Literal remap="tt">albert</Literal> ressemblent 
à ceci :
</para>
<para>
<Screen>
#
Sradio   44.136.8.99   44.136.8.100  255.255.255.0  normal      -1
Salbert  44.136.8.99   DYNAMIC       255.255.255.0  compressed  60
#
</Screen>
</para>
<para>
Les entrées du fichier <Literal remap="tt">/etc/slip.hosts</Literal> sont :
</para>
<para>
<OrderedList>
<ListItem>
<para>
Le nom de connexion de l'appelant.
</para>
</ListItem>
<ListItem>
<para>
L'adesse IP de la machine serveur, donc de la machine contenant ce fichier.
</para>
</ListItem>
<ListItem>
<para>
L'adresse IP qui sera attribuée à l'appelant. Si le champ vaut
<Literal remap="tt">DYNAMIC</Literal> alors l'adresse IP sera allouée suivant les informations
contenues dans le fichier 
 <Literal remap="tt">/etc/slip.tty</Literal> décrit plus loin. <Emphasis>Note :</Emphasis>
vous devez utiliser au moins la version 1.3 de sliplogin pour que cela 
fonctionne.
</para>
</ListItem>
<ListItem>
<para>
Le masque de réseau assigné à la machine
appelante, en notation décimale, par exemple 255.255.255.0 pour un
masque de réseau de classe C.
</para>
</ListItem>
<ListItem>
<para>
Un réglage du mode SLIP qui active/désactive la compression. Les valeurs autorisées sont "<Literal remap="tt">normal</Literal>" et "<Literal remap="tt">compressed</Literal>".
</para>
</ListItem>
<ListItem>
<para>
Un paramètre de délai qui spécifie 
combien de temps la ligne
peut rester inactive (aucun datagramme reçu) avant une
 déconnexion automatique. Une valeur négative désactive
cette possiblité.
</para>
</ListItem>
<ListItem>
<para>
arguments optionnels.
</para>
</ListItem>
</OrderedList>
</para>
<para>
Note : Vous pouvez mettre soit les noms d'hôtes soit les adresses IP en
 notation décimale pointée pour les champs 2 et 3.
Si vous utilisez les noms d'hôtes, alors ces hôtes doivent
être résolubles, c'est à dire que votre machine
est capable de déterminer une adresse IP pour ces noms d'hôtes,
sinon le script échouera pendant l'appel. Vous pouvez le tester
en faisant telnet vers un nom d'hôte : si vous obtenez le message
`<Emphasis>Trying nnn.nnn.nnn...</Emphasis>' alors votre machine est capable de trouver une 
adresse ip pour ce nom d'hôte. Si vous obtenez le message 
 `<Emphasis>Unknown host</Emphasis>', alors il n'en a pas. Dans ce cas essayez d'utiliser
l'adress IP en notation décimale pointée, ou bien voyez
du côté de votre configuration de solveur de noms (voir
la section <Literal remap="tt">Résolution de noms</Literal>).
</para>
<para>
Les modes les plus courants de SLIP sont :
<VariableList>
<VarListEntry>
<Term>normal </Term>
<ListItem>
<para>
mode SLIP normal non compressé.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>compressed </Term>
<ListItem>
<para>
mode avec compression van Jacobsen des en-têtes (cSLIP)
</para>
</ListItem>
</VarListEntry>
</VariableList>
</para>
<para>
Bien sûr ils sont mutuellement exclusifs, vous devez utiliser l'un ou
l'autre. Pour plus d'informations sur les options disponibles, voir les pages
 de manuels.
</para>
</Sect2>

<Sect2><title>Configurer le fichier <Literal remap="tt">/etc/slip.login</Literal>.</title>
<para>
Après que <Emphasis>sliplogin</Emphasis> ait exploré le fichier 
<Literal remap="tt">/etc/slip.hosts</Literal> et ait trouvé une entrée qui
convient, il essaye d'exécuter le fichier
 <Literal remap="tt">/etc/slip.login</Literal> pour effectivement configurer l'interface SLIP avec
son adresse IP et son masque de réseau.

L'exemple de fichier <Literal remap="tt">/etc/slip.login</Literal> fourni avec le paquetage
 <Emphasis>sliplogin</Emphasis> ressemble à ceci :
</para>
<para>
<Screen>
#!/bin/sh -
#
#       @(#)slip.login  5.1 (Berkeley) 7/1/90
#
# fichier générique de connexion pour une ligne SLIP. Invoqué par sliplogin
# avec les paramètres:
#     $1       $2       $3    $4, $5, $6 ...
# unité SLIP vitesse    pid   arguments tirés de slip.host
#
/sbin/ifconfig $1 $5 pointopoint $6 mtu 1500 -trailers up
/sbin/route add $6
arp -s $6 &#60;hw_addr&#62; pub
exit 0
#
</Screen>
</para>
<para>
Notez que ce script utilise seulement les commandes <Emphasis>ifconfig</Emphasis> 
et <Emphasis>route</Emphasis> pour configurer le périphérique SLIP
avec sa propre adresse IP, l'adresse IP de l'hôte distant
, le masque de réseau puis crée une route vers l'adresse distante
via le périphérique SLIP. C'est-à-dire la même
chose que si vous utilisiez la commande <Emphasis>slattach</Emphasis>.
</para>
<para>
Notez aussi l'utilisation de <Emphasis>Proxy ARP</Emphasis> pour s'assurer que les 
hôtes placés sur le même segment éthernet que la machine serveur
sauront comment atteindre l'hôte qui s'est connecté.
Le champ <Literal remap="tt">&lt;hw&lowbar;addr&gt;</Literal> doit être l'adresse matérielle
de la carte Ethernet de la machine. Si votre machine serveur n'est pas sur un
réseau Ethernet, vous pouvez ignorer cette ligne. 
</para>
</Sect2>

<Sect2><title>Configurer le fichier <Literal remap="tt">/etc/slip.logout</Literal></title>
<para>
Quand la connexion s'est arrêtée, assurez-vous que le
périphérique série soit revenu à son état
 normal de telle sorte que les appelants suivants puissent se connecter
correctement. Ceci est accompli en utilisant le fichier
 <Literal remap="tt">/etc/slip.logout</Literal>. Il est de format très simple et est
appelé avec le même argument que le fichier
<Literal remap="tt">/etc/slip.login</Literal>.
</para>
<para>
<Screen>
#!/bin/sh -
#
#               slip.logout
#
/sbin/ifconfig $1 down
arp -d $6
exit 0
#
</Screen>
</para>
<para>
Tout ce qu'il fait est de `mettre à zéro' l'interface
qui supprimera la route précédemment créée.
Il utilise aussi la commande <Emphasis>arp</Emphasis> pour supprimer tout arp proxy en
place, encore une fois vous n'avez pas besoin de la commande <Emphasis>arp</Emphasis>
 dans le script si votre machine serveur ne possède pas de port Ethernet.
</para>
</Sect2>
<Sect2><title>Configurer le fichier <Literal remap="tt">/etc/slip.tty</Literal></title>
<para>
Si vous utilisez une allocation d'adresse ip dynamique (tous les hôtes
configurés avec le mot-clé
 <Literal remap="tt">DYNAMIC</Literal> dans le fichier <Literal remap="tt">/etc/slip.hosts</Literal>) alors vous devez
configurer le fichier
 <Literal remap="tt">/etc/slip.tty</Literal> pour afficher les adresses qui seront
assignées aux ports. Vous n'aurez besoin de ce fichier
que si vous voulez que votre serveur alloue des adresses aux utilisateurs
de manière dynamique.
</para>
<para>
Ce fichier est un tableau qui liste les périphériques
 <Emphasis>tty</Emphasis> supportant les connexions SLIP entrantes et l'adresse
ip qui sera assignée aux utilisateurs se connectant à ceux-ci.
</para>
<para>
Son format est le suivant :
<Screen>
# slip.tty    mappage d'adresses tty -&#62; IP pour SLIP dynamique
# format: /dev/tty?? xxx.xxx.xxx.xxx
#
/dev/ttyS0      192.168.0.100
/dev/ttyS1      192.168.0.101
#
</Screen>

</para>
<para>
Ce que dit ce tableau est que les appelants qui se connectent sur le port
 <Literal remap="tt">/dev/ttyS0</Literal> et dont le champ adresse dans le fichier
 <Literal remap="tt">/etc/slip.hosts</Literal> vaut sur
 <Literal remap="tt">DYNAMIC</Literal> auront l'adresse <Literal remap="tt">192.168.0.100</Literal>.
</para>
<para>
De cette manière vous n'avez besoin d'allouer qu'une seule adresse
par port pour tous les utilisateurs n'ayant pas besoin d'adresse 
fixe. Ceci vous permet d'avoir le nombre minimum
d'adresses
nécessaires pour éviter du gaspillage.
</para>
</Sect2>

<Sect2><title>Serveur Slip utilisant <Emphasis>dip</Emphasis></title>
<para>
Tout d'abord laissez-moi dire que certaines informations ci-dessous
proviennent des pages de manuel de <Emphasis>dip</Emphasis>, où la manière
de faire tourner Linux comme serveur SLIP est brièvement
décrite. Faites attention aussi que ce qui suit est fondé
sur le paquetage
 <Emphasis>dip337o-uri.tgz</Emphasis> et ne s'applique vraisemblablement pas à
d'autres versions de <Emphasis>dip</Emphasis>.
</para>
<para>

<Emphasis>dip</Emphasis> possède un mode de traitement des données 
d'entrée qui permet de localiser automatiquement
un utilisateur entrant
 et qui configure la ligne série comme lien SLIP
 suivant les informations trouvées dans le fichier
 <Literal remap="tt">/etc/diphosts</Literal>.
 Ce mode est activé en invoquant <Emphasis>dip</Emphasis>
avec <Emphasis>diplogin</Emphasis>. Voilà donc comment utiliser <Emphasis>dip</Emphasis> comme
serveur SLIP, en créant des comptes spéciaux où
 <Emphasis>diplogin</Emphasis> est utilisé comme shell de connexion.
</para>
<para>
La première chose à faire est de créer un lien 
symbolique comme suit :
</para>
<para>
<Screen>
# ln -sf /usr/sbin/dip /usr/sbin/diplogin
</Screen>
</para>
<para>
Ensuite vous devez ajouter des entrées à la fois dans vos
fichiers <Literal remap="tt">/etc/passwd</Literal> et
<Literal remap="tt">/etc/diphosts</Literal>. Les entrées que vous devez 
y mettre sont formatées comme suit :
</para>
<para>
Pour configurer Linux comme serveur SLIP avec <Emphasis>dip</Emphasis>, vous devez
créer quelques comptes SLIP spéciaux pour les utilisateurs,
où <Emphasis>dip</Emphasis> (en mode d'entrée) est utilisé comme
shell de connexion. Une convention suggérée est d'avoir
tous les comptes SLIP commençant avec la lettre 
 `S' majuscule, par exemple `Sfredm'.
</para>
<para>
Un exemple d'entrée dans <Literal remap="tt">/etc/passwd</Literal> pour un utilisateur
 SLIP ressemble à ceci :
</para>
<para>
<Screen>
Sfredm:ij/SMxiTlGVCo:1004:10:Fred:/tmp:/usr/sbin/diplogin
^^         ^^        ^^  ^^   ^^   ^^   ^^
|          |         |   |    |    |    \_ _ diplogin comme shell de connexion
|          |         |   |    |    \_ _ _ _  Répertoire personnel 
|          |         |   |    \_ _ _ _ _ _ _ Nom complet d'utilisateur
|          |         |   \_ _ _ _ _ _ _ _ _  GID
|          |         \_ _ _ _ _ _ _ _ _ _ _  UID
|          \_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _  Mot de passe chiffré
\_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ Nom de connexion Slip 
</Screen>
</para>
<para>
Après la connexion de l'utilisateur, le programme <Emphasis>login</Emphasis>
(s'il trouve et accepte l'utilisateur) exécute la commande
 <Emphasis>diplogin</Emphasis>. <Emphasis>dip</Emphasis>, lorsqu'il est invoqué en tant que
 <Emphasis>diplogin</Emphasis> sait qu'il sera automatiquement 
utilisé comme shell de connexion.
 Quand il est démarré comme <Emphasis>diplogin</Emphasis> la
première chose qu'il fait est d'utiliser l'appel de la fonction
 <Emphasis>getuid()</Emphasis> pour obtenir l'identificateur de l'utilisateur
appelant. Il regarde ensuite dans le fichier
 <Literal remap="tt">/etc/diphosts</Literal> pour trouver la première entrée
qui corresponde soit à l'utilisateur soit au 
périphérique <Emphasis>tty</Emphasis> où l'appel est entré
 et se configure lui-même de manière appropriée.
Par un choix judicieux : soit de donner à l'utilisateur
une entrée dans le fichier
<Literal remap="tt">diphosts</Literal>, soit de laisser à l'utilisateur la
configuration par défaut, vous pouvez construire votre serveur de telle
manière que vous puissiez faire cohabiter des utilisateurs ayant
des adresses allouées statiquement ou dynamiquement.
</para>
<para>
<Emphasis>dip</Emphasis> ajoutera automatiquement une entrée `Proxy-ARP' si elle
est invoquée en mode d'entrée, aussi vous n'avez pas à
vous soucier d'ajouter de telles entrées manuellement.
</para>
</Sect2>
<Sect2>
<title>Configurer <Literal remap="tt">/etc/diphosts</Literal></title>

<para>
<Literal remap="tt">/etc/diphosts</Literal> est utilisé par <Emphasis>dip</Emphasis> pour
examiner des configurations préétablies concernant
des hôtes éloignés. Ceux-ci peuvent être des
hôtes se connectant sur votre machine, ou bien des machines sur
lesquelles vous vous connectez.
</para>
<para>
Le format général de <Literal remap="tt">/etc/diphosts</Literal> est :
</para>
<para>
<Screen>
 ..
Suwalt::145.71.34.1:145.71.34.2:255.255.255.0:SLIP uwalt:CSLIP,1006
ttyS1::145.71.34.3:145.71.34.2:255.255.255.0:Dynamic ttyS1:CSLIP,296
 ..
</Screen>
</para>
<para>
Les champs sont :
<OrderedList>
<ListItem>
<para>
<Literal remap="tt">nom de connexion</Literal> : comme retourné par getpwuid(getuid()) 
ou bien le nom de tty.
</para>
</ListItem>
<ListItem>
<para>
<Literal remap="tt">inutilisé</Literal> : pour compatibilité avec passwd
</para>
</ListItem>
<ListItem>
<para>
<Literal remap="tt">Adresse distante</Literal> : adresse IP de l'appelant, soit 
numérique soit nominative
</para>
</ListItem>
<ListItem>
<para>
<Literal remap="tt">Adresse locale</Literal> : adresse IP de cette machine, soit 
numérique soit nominative.
</para>
</ListItem>
<ListItem>
<para>
<Literal remap="tt">Masque de réseau</Literal> : en notation décimale 
pointée
</para>
</ListItem>
<ListItem>
<para>
<Literal remap="tt">Commentaires</Literal> : vous y mettez ce que vous voulez.
</para>
</ListItem>
<ListItem>
<para>
<Literal remap="tt">protocole</Literal> : Slip, CSlip, etc.
</para>
</ListItem>
<ListItem>
<para>
<Literal remap="tt">MTU</Literal> : nombre décimal
</para>
</ListItem>
</OrderedList>
</para>
<para>

Un exemple d'entrée <Literal remap="tt">/etc/net/diphosts</Literal> pour un hôte 
distant peut être :
</para>
<para>
<Screen>
Sfredm::145.71.34.1:145.71.34.2:255.255.255.0:SLIP uwalt:SLIP,296
</Screen>
</para>
<para>
qui spécifie une liaison SLIP avec une adresse distante de 145.71.34.1 
et un MTU de 296,
ou :
</para>
<para>
<Screen>
Sfredm::145.71.34.1:145.71.34.2:255.255.255.0:SLIP uwalt:CSLIP,1006
</Screen>
</para>
<para>
qui spécifie une liaison compatible cSLIP avec une adresse distante
de 145.71.34.1 et un MTU de 1006.
</para>
<para>
Dès lors, tous les utilisateurs à qui vous permettez
d'avoir une connexion avec allocation d'adresse IP statique auront une
entrée dans <Literal remap="tt">/etc/diphosts</Literal>. Si vous voulez que des
utilisateurs qui appellent sur un port particulier aient leur adresse
allouée dynamiquement, vous devez avoir une entrée pour
le périphérique <Literal remap="tt">tty</Literal>, mais pas d'entrée
pour l'utilisateur lui-même. Vous devez vous souvenir de configurer
au moins une entrée pour chaque périphérique <Literal remap="tt">tty</Literal>
que vos utilisateurs entrants utiliseront pour être sûrs
qu'une configuration adéquate soit disponible, indépendamment
du modem sur lequel ils se connectent.
</para>
<para>
Quand un utilisateur se connecte, il recevra une invite normal de login
et une demande de mot de passe, pour lesquels il devra entrer son 
identificateur SLIP et son mot de passe. Si tout est correct, l'utilisateur
ne verra pas de message spécial, il devra juste basculer en mode SLIP
chez lui et ensuite il sera connecté et configuré avec
les paramètres contenus dans le fichier <Literal remap="tt">diphosts</Literal>.
</para>
</Sect2>
<Sect2>
<title>Serveur SLIP utilisant l'ensemble <Emphasis>dSLIP</Emphasis></title>

<para>
Matt Dillon <Literal remap="tt">&lt;dillon@apollo.west.oic.com&gt;</Literal> a écrit
un paquetage qui permet des liaisons SLIP non seulement entrantes mais aussi
sortantes. Le paquetage de Matt est une combinaison de petits programmes
et de scripts qui prennent en charge les connexions à votre place.
Vous aurez besoin de <Emphasis>tcsh</Emphasis> car au moins l'un des scripts en a
besoin. Matt fournit une copie binaire de l'utilitaire <Emphasis>expect</Emphasis>
car il est aussi nécessaire pour l'un des scripts. 
Il serait préférable
d'avoir une certaine expérience de <Emphasis>expect</Emphasis> pour que ce 
paquetage soit utile pour vous, mais que cela ne vous décourage pas.
</para>
<para>
Matt a écrit une bonne procédure d'installation dans le fichier
README, aussi je ne me fatiguerai pas à la répéter.
</para>
<para>
Vous pouvez récupérer le paquetage <Emphasis>dSLIP</Emphasis> sur son site
d'origine :
</para>
<para>
<Emphasis>apollo.west.oic.com</Emphasis>
<Screen>
/pub/linux/dillon_src/dSLIP203.tgz
</Screen>
</para>
<para>
ou bien sur :
</para>
<para>
<Emphasis>metalab.unc.edu</Emphasis>
<Screen>
/pub/Linux/system/Network/serial/dSLIP203.tgz
</Screen>
</para>
<para>
Lisez le fichier <Literal remap="tt">README</Literal> et créez les entrées 
<Literal remap="tt">/etc/passwd</Literal> et
<Literal remap="tt">/etc/group</Literal> <Emphasis>avant</Emphasis> de faire <Literal remap="tt">make install</Literal>.
</para>
</Sect2>
</Sect1>
</chapter>

<!-- *********************************************************************** -->

<chapter>
<title>Autres technologies réseau</title>
<para>
Les paragraphes suivants traitent de sujets spécifiques concernant
des technologies liées au réseau. Les informations qui y sont contenues
ne s'appliquent pas forcément aux autres types de technologies réseau.
Les sujets sont traités par ordre alphabétique.
</para>

<Sect1>
<title>ARCNet</title>
<para>
Les noms de fichier périphériques de ARCNet sont `<Literal remap="tt">arc0e</Literal>', 
`<Literal remap="tt">arc1e</Literal>', `<Literal remap="tt">arc2e</Literal>' ... ou bien `<Literal remap="tt">arc0s</Literal>', `<Literal remap="tt">arc1s</Literal>', `<Literal remap="tt">arc2s</Literal>', etc. La première carte détectée par le noyau devient
 `<Literal remap="tt">arc0e</Literal>' ou `<Literal remap="tt">arc0s</Literal>' et les autres sont nommées en suivant dans 
l'ordre de leur détection.
 La lettre finale dépend de votre choix : soit un format d'encapsulation 
de paquets Ethernet, soit un format de paquets suivant RFC1051.
</para>
<para>
<Emphasis>Options de compilation du noyau</Emphasis> :
<Screen>
Network device support  ---&#62;
    [*] Network device support
    &#60;*&#62; ARCnet support
    [ ]   Enable arc0e (ARCnet "Ether-Encap" packet format)
    [ ]   Enable arc0s (ARCnet RFC1051 packet format)
</Screen>
</para>
<para>
Si vous avez construit convenablement votre noyau pour supporter 
votre carte Ethernet, alors la configuration de la carte est facile.
</para>
<para>
Typiquement vous devriez utiliser quelque chose comme ceci :
</para>
<para>
<Screen>
root# ifconfig arc0e 192.168.0.1 netmask 255.255.255.0 up
root# route add -net 192.168.0.0 netmask 255.255.255.0 arc0e
</Screen>
</para>
<para>
Merci de vous référer aux documents
<Literal remap="tt">/usr/src/linux/Documentation/networking/arcnet.txt</Literal> et
<Literal remap="tt">/usr/src/linux/Documentation/networking/arcnet-hardware.txt</Literal>
pour d'autres informations.
</para>
<para>
Le support ARCNet fut développé par Avery Pennarun, 
<Literal remap="tt">apenwarr@foxnet.net</Literal>.

<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
<Sect1>
<title>Appletalk (<Literal remap="tt">AF_APPLETALK</Literal>)</title>
<para>
Le support Appletalk ne possède pas de noms de 
périphériques spécifiques car il utilise les périphériques réseau existants.
</para>
<para>
<Emphasis>Options de compilation noyau</Emphasis> :
<Screen>
Networking options  ---&#62;
    &#60;*&#62; Appletalk DDP
</Screen>
</para>
<para>
Le support Appletalk permet à votre machine Linux de dialoguer avec 
les réseaux Apple.
Son utilisation principale est de pouvoir partager des ressources, 
comme les imprimantes et 
les disques, entre vos ordinateurs Linux et Apple. Un logiciel 
supplémentaire est requis, il s'appelle
 <Emphasis>netatalk</Emphasis>. Wesley Craig <Literal remap="tt">netatalk@umich.edu</Literal> représente
une équipe appelée le
 `Research Systems Unix Group' à l'université du Michigan. 
Celle-ci a élaboré le paquetage
 <Emphasis>netatalk</Emphasis>, qui fournit un logiciel implémentant la pile protocole 
Appletalk et quelques utilitaires.
Soit ce paquetage <Emphasis>netatalk</Emphasis> vous a été fourni avec votre 
distribution Linux, soit vous pouvez le récupérer 
par ftp depuis le site
<ULink URL="ftp://terminator.rs.itd.umich.edu/unix/netatalk/">
	University of Michigan</ULink>
</para>
<para>
Pour construire et installer le paquetage, vous faites :
</para>
<para>
<Screen>
user% tar xvfz .../netatalk-1.4b2.tar.Z
user% make
root# make install

</Screen>
</para>
<para>
 Vous pouvez éditer le fichier `Makefile' avant de faire appel à
<Emphasis>make</Emphasis>, plus 
précisément pour changer la valeur de la variable
 DESTDIR qui définit l'endroit où les fichiers seront 
installés plus tard.
 Le répertoire par défaut, /usr/local/atalk, semble
 très raisonnable.
</para>


<Sect2>
<title>Configurer le support Appletalk.</title>
<para>
La première chose à faire pour que tout fonctionne est de vérifier que 
les entrées adéquates sont présentes dans le fichier
 <Literal remap="tt">/etc/services</Literal>. Ces entrées sont :
</para>
<para>
<Screen>
rtmp	1/ddp	# Routing Table Maintenance Protocol
nbp	2/ddp	# Name Binding Protocol
echo	4/ddp	# AppleTalk Echo Protocol
zip	6/ddp	# Zone Information Protocol
</Screen>
</para>
<para>
L'étape suivante consiste à créer les fichiers de 
configuration Appletalk dans le répertoire
<Literal remap="tt">/usr/local/atalk/etc</Literal> (ou bien à l'endroit où vous avez 
installé le paquetage). 
</para>
<para>
Le premier fichier à créer est <Literal remap="tt">/usr/local/atalk/etc/atalkd.conf</Literal>.
Initialement ce fichier ne nécessite qu'une ligne qui indique le 
périphérique supportant le réseau sur lequel sont vos 
machines Apple : 
</para>
<para>
<Screen>
eth0
</Screen>
</para>
<para>
Le programme démon Appletalk ajoutera d'autres détails quand il tournera.
</para>
</Sect2>

<Sect2>
<title>Exporter un système de fichiers Linux avec Appletalk.</title>
<para>
Vous pouvez exporter des systèmes de fichiers depuis votre machine Linux 
vers le réseau en sorte qu'une machine Apple puisse les partager.
</para>
<para>
Pour cela vous devez configurer le fichier
<Literal remap="tt">/usr/local/atalk/etc/AppleVolumes.system</Literal>. Il y a une autre fichier de configuration appelé
 <Literal remap="tt">/usr/local/atalk/etc/AppleVolumes.default</Literal>
qui a exactement le même format et qui décrit quels 
systèmes de fichiers les utilisateurs connectés pourront recevoir 
avec des privilèges d'invités.
</para>
<para>
Tous les détails, qui vous diront comment configurer ces fichiers et avec 
quelles options, peuvent être trouvés dans la page de manuel
de <Emphasis>afpd</Emphasis>.
</para>
<para>
Un simple exemple :
</para>
<para>
<Screen>
/tmp Scratch
/home/ftp/pub "Public Area"
</Screen>
</para>
<para>
Ce qui exportera votre système de fichiers <Literal remap="tt">/tmp</Literal> comme volume 
AppleShare 
 `Scratch' et votre répertoire public ftp comme volume AppleShare
 `Public Area'.
Les noms de volume ne sont pas obligatoires, le programme démon 
pouvant les choisir pour vous, mais ça ne coûte rien de les 
spécifier quand même.
</para>
</Sect2>
<Sect2>
<title>Partager votre imprimante Linux avec Appletalk.</title>
<para>
Partager votre imprimante Linux avec vos machines Apple est 
très simple. Vous devez faire tourner le programme
 <Emphasis>papd</Emphasis> qui est le démon protocole d'accès aux 
imprimantes de Appletalk. Lorsque vous faites tourner ce programme il acceptera 
les requêtes émanant de vos machines Apple et spoulera le travail 
d'impression vers votre démon local d'impression.
</para>
<para>
Vous devrez éditer le fichier <Literal remap="tt">/usr/local/atalk/etc/papd.conf</Literal> 
pour configurer le démon.
La syntaxe de ce fichier est la même que le fichier habituel
<Literal remap="tt">/etc/printcap</Literal>. Le nom que vous donnez à la définition
 de l'imprimante 
doit être conforme au protocole de désignation Appletalk, NBP.
</para>
<para>
Un exemple de configuration ressemble à ceci :
</para>
<para>
<Screen>
TricWriter:\
   :pr=lp:op=cg:
</Screen>
</para>
<para>
Ce qui fera une imprimante nommée `TricWriter' disponible pour le 
réseau Appletalk
 et tous les travaux acceptés seront imprimés sur l'imprimante 
linux `<Literal remap="tt">lp</Literal>'
(telle que définie dans le fichier <Literal remap="tt">/etc/printcap</Literal>) utilisant 
<Emphasis>lpd</Emphasis>. L'entrée
`<Literal remap="tt">op=cg</Literal>' indique que l'utilisateur linux `<Literal remap="tt">cg</Literal>' est l'opérateur 
de l'imprimante.
</para>
</Sect2>
<Sect2>
<title>Démarrer Appletalk.</title>
<para>
Bon, vous devriez être prêts pour essayer cette configuration de 
base. Le fichier
<Emphasis>rc.atalk</Emphasis> fourni avec le paquetage <Emphasis>netatalk</Emphasis> devrait vous 
convenir, alors vous faites ceci : 
</para>
<para>
<Screen>
# /usr/local/atalk/etc/rc.atalk
</Screen>
</para>
<para>
et tout devrait démarrer et tourner sans problémes. Vous ne 
devriez voir aucun message d'erreurs et le programme devrait vous envoyer des 
messages sur la console indiquant chaque étape qui démarre.
</para>
</Sect2>

<Sect2>
<title>Tester Appletalk.</title>
<para>
Pour tester si le programme fonctionne correctement, allez sur une des 
machines Apple, déroulez le menu Pomme, cliquez sur AppleShare, 
et votre boîte Linux devrait apparaître.
</para>
</Sect2>

<Sect2>
<title>Mises en garde sur Appletalk.</title>
<para>
<ItemizedList>
<ListItem>
<para>
Vous aurez peut-être besoin de démarrer votre support 
Appletalk avant de configurer votre réseau IP. Si vous avez des 
problèmes pour démarrer vos programmes Appletalk, ou si 
après les avoir démarrés vous avez des ennuis avec votre 
réseau IP, essayez alors de mettre en route votre programme Appletalk 
avant de faire démarrer
 <Literal remap="tt">/etc/rc.d/rc.inet1</Literal>.
</para>
</ListItem>
<ListItem>
<para>
Le démon <Emphasis>afpd</Emphasis> (Apple Filing Protocol Daemon) SECOUE 
SÉVÈREMENT VOTRE DISQUE DUR. Derrière les points de 
montage il crée deux répertoires appelés
<Literal remap="tt">.AppleDesktop</Literal> et <Literal remap="tt">Network Trash Folder</Literal>. Ensuite, pour chaque 
répertoire auquel vous accédez il crée un 
sous-répertoire
 <Literal remap="tt">.AppleDouble</Literal>  pour pouvoir stocker des fichiers de ressource, etc.
Réfléchissez bien avant d'exporter <Literal remap="tt">/</Literal>, 
vous aurez besoin de pas mal de temps pour tout nettoyer.
</para>
</ListItem>
<ListItem>
<para>
Le programme <Emphasis>afpd</Emphasis> attend des mots de passe en clair venant des 
Macs. La sécurité pouvant être un problème, 
soyez donc
 attentifs lors de l'utilisation de ce démon sur une machine 
connectée sur l'Internet et ne vous en prenez qu'à 
vous-même si quelqu'un de mal intentionné vous fait des  
misères.
</para>
</ListItem>
<ListItem>
<para>
Les outils de diagnostic existants tels que <Emphasis>netstat</Emphasis> et
<Emphasis>ifconfig</Emphasis> ne supportent pas Appletalk. Les informations peuvent 
être trouvées dans le répertoire
 <Literal remap="tt">/proc/net/</Literal> si vous en avez besoin.
</para>
</ListItem>
</ItemizedList>
</para>
</Sect2>
<Sect2>
<title>Autres informations</title>
<para>
Pour en savoir plus sur la configuration de Appletalk pour Linux, 
référez vous à la page de 
 Anders Brownworth <Emphasis>Linux Netatalk-HOWTO</Emphasis> disponible à l'url
<ULink URL="http://thehamptons.com/anders/netatalk/">
	thehamptons.com</ULink>.
</para>
</Sect2>
</Sect1>
<Sect1>
<title>ATM</title>
<para>
Werner Almesberger <Literal remap="tt">&lt;werner.almesberger@lrc.di.epfl.ch&gt;</Literal> dirige 
un projet en vue de fournir un support Mode de Transfert Asynchrone
 (Asynchronous Transfer Mode) pour Linux.
Les informations sur l'état du projet se trouvent sur :
<ULink URL="http://lrcwww.epfl.ch/linux-atm/">
	lrcwww.epfl.ch</ULink>.
</para>
<para>
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>

<Sect1>
<title>AX25 (<Literal remap="tt">AF_AX25</Literal>)</title>
<para>
Les noms de périphériques AX.25 sont `<Literal remap="tt">sl0</Literal>', `<Literal remap="tt">sl1</Literal>', etc. avec les noyaux <Literal remap="tt">2.0.*</Literal> ou
`<Literal remap="tt">ax0</Literal>', `<Literal remap="tt">ax1</Literal>', etc. avec les noyaux <Literal remap="tt">2.1.*</Literal>.
</para>
<para>
<Emphasis>Options de compilation du noyau</Emphasis> :
<Screen>
Networking options  ---&#62;
    [*] Amateur Radio AX.25 Level 2
</Screen>
</para>
<para>
Les protocoles AX25, Netrom et Rose sont couverts par le document
 <ULink URL="AX25-HOWTO.html">AX25-HOWTO</ULink>.
Ces protocoles sont utilisés par les radio-amateurs du monde entier 
pour l'expérimentation packet-radio.
</para>
<para>
L'essentiel du travail d'implémentation de ces protocoles a 
été réalisé par
Jonathon Naylor, <Literal remap="tt">jsn@cs.nott.ac.uk</Literal>.
</para>
<para>
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
<Sect1>
<title>DECNet</title>
<para>
Le support pour DECNet est en cours d'élaboration. Vous devriez le voir 
apparaitre dans l'un des prochains noyaux
 <Literal remap="tt">2.1.*</Literal>.

<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
<Sect1>
<title>FDDI (Fiber Distributed Data Interface)</title>
<para>
Les noms de périphériques FDDI sont `<Literal remap="tt">fddi0</Literal>', `<Literal remap="tt">fddi1</Literal>', 
`<Literal remap="tt">fddi2</Literal>' etc. La première carte détectée par le noyau 
s'appelle
 `<Literal remap="tt">fddi0</Literal>' et le reste est nommé dans l'ordre de détection.
</para>
<para>
Larry Stefani, <Literal remap="tt">lstefani@ultranet.com</Literal>, a développé un 
gestionnaire pour les cartes
 Digital Equipment Corporation FDDI EISA et PCI.
</para>
<para>
<Emphasis>Options de compilation noyau</Emphasis> :
<Screen>
Network device support  ---&#62;
    [*] FDDI driver support
    [*] Digital DEFEA and DEFPA adapter support
</Screen>
</para>
<para>
Lorsque vous avez construit et installé votre noyau pour supporter 
le gestionnaire FDDI, la configuration de l'interface FDDI est presque 
identique à celle d'une interface Ethernet. Vous devez spécifier 
le nom de l'interface FDDI appropriée dans les commandes 
<Emphasis>ifconfig</Emphasis> et <Emphasis>route</Emphasis>.
</para>
<para>
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
<Sect1>
<title>Relais de trames (Frame Relay)</title>
<para>
Les noms de périphériques de `relais de trames' sont `<Literal remap="tt">dlci00</Literal>', 
`<Literal remap="tt">dlci01</Literal>' etc pour les systèmes d'encapsulation
DLCI et  `<Literal remap="tt">sdla0</Literal>', `<Literal remap="tt">sdla1</Literal>' etc pour les FRAD(s) (Frame Relay Access 
Device).
</para>
<para>
Le relais de trames est une nouvelle technologie réseau conçue pour 
s'adapter au trafic de transmission de données `par à coups' 
ou de nature intermittente.
Vous vous connectez à un réseau de ce type
 en utilisant un dispositif d'accès par relais de trames (FRAD).
Les supports Linux relais de trames supportent IP par-dessus celui-ci comme 
décrit dans la RFC-1490.
</para>
<para>
<Emphasis>Options de compilation noyau</Emphasis> :
<Screen>
Network device support  ---&#62;
    &#60;*&#62; Frame relay DLCI support (EXPERIMENTAL)
    (24)   Max open DLCI
    (8)   Max DLCI per device
    &#60;*&#62;   SDLA (Sangoma S502/S508) support
</Screen>
</para>
<para>
Mike McLagan, <Literal remap="tt">mike.mclagan@linux.org</Literal>, a développé le support Frame Relay et les outils de configuration.
</para>
<para>
À l'heure actuelle le seul FRAD supporté est, à ma connaissance,
<ULink URL="http://www.sangoma.com/">
	Sangoma Technologies</ULink>
<Literal remap="tt">S502A</Literal>, <Literal remap="tt">S502E</Literal> et <Literal remap="tt">S508</Literal>.
et Emerging Technologies. Leur site se trouve sur
<ULink URL="http://www.etinc.com/">ici</ULink>.
</para>
<para>
<Emphasis>
Je voudrais dire quelquechose. J'ai une expérience personnelle avec
Emerging Technologies et je vous les recommande pas. Je les ai trouvés
absolument pas professionnels et très grossiers. Si  quelqu'un d'autre
a eu une bonne expérience avec eux, faites le moi savoir. A leur décharge,
leur produit est souple d'utilisation et paraît stable.
</Emphasis>
</para>
<para>
Pour configurer les systèmes FRAD et DLCI après avoir reconstruit
 votre noyau, vous aurez besoin des outils de configuration. Ils sont 
disponibles sur
<ULink URL="ftp://ftp.invlogic.com/pub/linux/fr/frad-0.15.tgz">
	ftp.invlogic.com</ULink>.
</para>
<para>
Compiler et installer les outils est très facile, mais le manque de 
fichier Makefile au premier niveau oblige à le faire à la main :
</para>
<para>
<Screen>
user% tar xvfz .../frad-0.15.tgz
user% cd frad-0.15
user% for i in common dlci frad; make -C $i clean; make -C $i; done
root# mkdir /etc/frad
root# install -m 644 -o root -g root bin/*.sfm /etc/frad
root# install -m 700 -o root -g root frad/fradcfg /sbin
root# install -m 700 -o root -g root dlci/dlcicfg /sbin
</Screen>
</para>

<para>
Notez que ces commandes utilisent la syntaxe du shell <Emphasis>sh</Emphasis>, 
et si vous utilisez <Emphasis>csh</Emphasis> (comme <Emphasis>tcsh</Emphasis>),
 la boucle <Emphasis>for</Emphasis> sera 
différente. 
</para>
<para>
Après l'installation vous devez créer un fichier 
<Literal remap="tt">/etc/frad/router.conf</Literal>
 Vous pouvez utiliser cet exemple, qui est une version modifiée de l'un 
des fichiers donné en exemple :
</para>
<para>
<Screen>
# /etc/frad/router.conf
# C'est un modèle de configuration pour relais de trames.
# Tout y est inclus. Les valeurs par défaut sont fondées sur le code
# fourni avec les gestionnaires DOS de la carte Sangoma S502A.
#
# Une ligne avec '#' est un commentaire
# Les blancs sont ignorés (vous pouvez utiliser des tabulations aussi).
# Les sections [] inconnues et les entrées inconnues sont ignorées.
#

[Devices]
Count=1                 # nombre de périphériques à configurer
Dev_1=sdla0             # nom d'un périphérique
#Dev_2=sdla1            # nom d'un périphérique

# Ce qui est spécifie ici s'applique à tous les périphériques, et peut être 
# mis à jour pour chaque carte individuelle.
#
Access=CPE
Clock=Internal
KBaud=64
Flags=TX
#
# MTU=1500              # Taille maximum de l'unité de transfert 4096 par défaut
# T391=10               # valeur de T391  5 - 30, 10 par défaut
# T392=15               # valeur de T392  5 - 30, 15 par défaut
# N391=6                # valeur de N391  1 - 255, 6 par défaut
# N392=3                # valeur de N392  1 - 10,  3 par défaut
# N393=4                # valeur de N393  1 - 10,  4 par défaut

# On spécifie ici les valeurs par défaut pour toutes les cartes
# CIRfwd=16             # CIR forward   1 - 64
# Bc_fwd=16             # Bc forward    1 - 512 
# Be_fwd=0              # Be forward    0 - 511
# CIRbak=16             # CIR backward  1 - 64
# Bc_bak=16             # Bc backward   1 - 512
# Be_bak=0              # Be backward   0 - 511


#
#
# Configurations spécifiques
#
#

#
#  Sangoma S502E
#
[sdla0]
Type=Sangoma            # Type de périphérique à configurer, actuellement seul 
                        # SANGOMA est reconnu
#
# Spécifique des types 'Sangoma'
#
# cartes S502A, S502E, S508
Board=S502E
#
# Le nom du logiciel de carte en essai pour Sangoma
# Testware=/usr/src/frad-0.10/bin/sdla_tst.502
#
# Le nom du logiciel de carte FR 
# Firmware=/usr/src/frad-0.10/bin/frm_rel.502
#
Port=360                # Port pour cette carte particulière
Mem=C8                  # Adresse de fenêtre mémoire, A0-EE, dépend de la carte
IRQ=5                   # numéro d'IRQ, pas nécessaire pour S502A
DLCIs=1                 # Nombre de DLCI attachés à ce périphérique
DLCI_1=16               # numéro du premier DLCI, de 16 à 991
# DLCI_2=17
# DLCI_3=18
# DLCI_4=19
# DLCI_5=20
#
# Ce qui est spécifie ici s'applique au périphérique seulement, 
# et remplace les valeurs par défaut
#
# Access=CPE            # CPE ou NODE,  CPE par défaut
# Flags=TXIgnore,RXIgnore,BufferFrames,DropAborted,Stats,MCI,AutoDLCI
# Clock=Internal        # Externe ou Interne, Interne par défaut
# Baud=128              # Débit spécifié du CSU/DSU attaché
# MTU=2048              # Taille maximum de l'unité de transfert 4096 par défaut
# T391=10               # valeur de T391   5 - 30, 10 par défaut
# T392=15               # valeur de T392   5 - 30, 15 par défaut
# N391=6                # valeur de N391   1 - 255, 6 par défaut
# N392=3                # valeur de N392   1 - 10,  3 par défaut
# N393=4                # valeur de N393   1 - 10,  4 par défaut

#
# Le second periphérique est une autre carte
#
# [sdla1]
# Type=FancyCard        # Type de périphérique à configurer.
# Board=                # Type de carte Sangoma
# Key=Value             # valeurs spécifiques pour ce type de périphérique


#
# Paramètres de configuration DLCI par défaut.
# Peuvent être écrasés par des configurations spécifiques
#
CIRfwd=64               # CIR forward   1 - 64
# Bc_fwd=16             # Bc forward    1 - 512 
# Be_fwd=0              # Be forward    0 - 511
# CIRbak=16             # CIR backward  1 - 64
# Bc_bak=16             # Bc backward   1 - 512
# Be_bak=0              # Be backward   0 - 511

#
# Configuration DLCI
# Optionnel. La convention d'appellation est
# [DLCI&lowbar;D&#60;devicenum&#62;&lowbar;&#60;DLCI&lowbar;Num&#62;]
#

[DLCI_D1_16]
# IP=
# Net=
# Mask=
# Drapeaux définis par Sangoma: TXIgnore,RXIgnore,BufferFrames
# DLCIFlags=TXIgnore,RXIgnore,BufferFrames
# CIRfwd=64
# Bc_fwd=512
# Be_fwd=0
# CIRbak=64
# Bc_bak=512
# Be_bak=0

[DLCI_D2_16]
# IP=
# Net=
# Mask=
# Drapeaux définis par Sangoma: TXIgnore,RXIgnore,BufferFrames
# DLCIFlags=TXIgnore,RXIgnore,BufferFrames
# CIRfwd=16
# Bc_fwd=16
# Be_fwd=0
# CIRbak=16
# Bc_bak=16
# Be_bak=0
</Screen>
</para>

<para>
Lorsque vous avez construit votre fichier <Literal remap="tt">/etc/frad/router.conf</Literal>,
la seule étape restante est de configurer les périphériques eux-mêmes.
 C'est un tout petit peu plus compliqué que la configuration normale d'un 
périphérique réseau; vous devez vous souvenir de monter 
le périphérique FRAD avant les périphériques d'encapsulation DLCI.
</para>
<para>
<Screen>
#!/bin/sh
# Configure le materiel frad et les parametres DLCI 
/sbin/fradcfg /etc/frad/router.conf || exit 1
/sbin/dlcicfg file /etc/frad/router.conf
#
# Montage du dispositif FRAD
ifconfig sdla0 up
#
# Configure les interfaces d'encapsulation DLCI et le routage
ifconfig dlci00 192.168.10.1 pointopoint 192.168.10.2 up
route add -net 192.168.10.0 netmask 255.255.255.0 dlci00
#
ifconfig dlci01 192.168.11.1 pointopoint 192.168.11.2 up
route add -net 192.168.11.0 netmask 255.255.255.0 dlci00
#
route add default dev dlci00
#
</Screen>

<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>


</Sect1>
<Sect1>
<title>IPX (<Literal remap="tt">AF&lowbar;IPX</Literal>)</title>
<para>
Le protocole IPX est la plupart du temps utilisé dans les environnements
 réseaux locaux Novell NetWare(tm).
Linux offre un support pour ce protocole, et peut être 
configuré pour agir comme extrémité réseau, ou 
comme routeur pour les environnements réseaux IPX.
</para>
<para>
<Emphasis>Options de compilation du noyau</Emphasis> :
<Screen>
Networking options  ---i&#62;
    [*] The IPX protocol
    [ ] Full internal IPX network
</Screen>
</para>
<para>
Le protocole IPX et le NCPFS sont traités en détail dans le 
document <ULink URL="IPX-HOWTO.html">IPX-HOWTO</ULink>.

<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
<Sect1>
<title>NetRom (<Literal remap="tt">AF&lowbar;NETROM</Literal>)</title>
<para>
Les noms de périphériques NetRom sont `<Literal remap="tt">nr0</Literal>', `<Literal remap="tt">nr1</Literal>', etc.
</para>
<para>
<Emphasis>Options de compilation du noyau</Emphasis> :
<Screen>
Networking options  ---&#62;
    [*] Amateur Radio AX.25 Level 2
    [*] Amateur Radio NET/ROM
</Screen>
</para>
<para>
Les protocoles AX25, Netrom et Rose sont décrits dans le document
 <ULink URL="AX25-HOWTO.html">AX25-HOWTO</ULink>.
Ces protocoles sont utilisés par les radio-amateurs dans le monde 
entier pour l'expérimentation du packet-radio.
</para>
<para>
L'essentiel du travail d'implémentation a été fait par
Jonathon Naylor, <Literal remap="tt">jsn@cs.not.ac.uk</Literal>.

<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
<Sect1>
<title>Protocole Rose (<Literal remap="tt">AF&lowbar;ROSE</Literal>)</title>
<para>
Les noms de périphériques Rose sont `<Literal remap="tt">rs0</Literal>', `<Literal remap="tt">rs1</Literal>', etc. 
.
Rose est disponible dans la série des noyaux <Literal remap="tt">2.1.*</Literal>.</para>
<para>
<Emphasis>Options de compilation du noyau</Emphasis> :
<Screen>
Networking options  ---&#62;
    [*] Amateur Radio AX.25 Level 2
    &#60;*&#62; Amateur Radio X.25 PLP (Rose)
</Screen>
</para>
<para>
Les protocoles AX25, Netrom et Rose sont expliqués dans le
 <ULink URL="AX25-HOWTO.html">AX25-HOWTO</ULink>.
Ces protocoles sont utilisés par les opérateurs radio-amateur du 
monde entier pour l'expérimentation du packet-radio.
</para>
<para>
L'essentiel du travail d'implémentation de ces protocoles a 
été réalisé par
Jonathon Naylor, <Literal remap="tt">jsn@cs.not.ac.uki</Literal>.
</para>
<para>
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
<Sect1>
<title>Support SAMBA - `NetBEUI', `NetBios', `CIFS'.</title>
<para>
SAMBA est une implémentation du protocole Session Management Block. Samba
permet aux Systèmes Microsoft et autres de monter et d'utiliser 
vos disques et imprimantes.
</para>
<para>
SAMBA et sa configuration sont décrits en détail dans le
<ULink URL="SMB-HOWTO.html">SMB-HOWTO</ULink>.
</para>
<para>
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
<Sect1>
<title>Support STRIP (Starmode Radio IP)</title>
<para>
Les noms de périphériques STRIP sont `<Literal remap="tt">st0</Literal>', `<Literal remap="tt">st1</Literal>', etc.
</para>
<para>
<Emphasis>Options de compilation du noyau</Emphasis> :
<Screen>
Network device support  ---&#62;
	[*] Network device support
	....
	[*] Radio network interfaces
	&#60; &#62; STRIP (Metricom starmode radio IP)
</Screen>
</para>
<para>
STRIP est un protocole conçu spécialement pour un certain type
de modems radio Metricom dans le cadre d'un projet de recherche conduit par
l'Université de Stanford appelé
<ULink URL="http://mosquitonet.Stanford.EDU/mosquitonet.html">
	MosquitoNet Project</ULink>.
Il y a un tas de choses intéressantes à lire, même si vous 
n'êtes pas directement concerné par le projet.
</para>
<para>
Les radios Metricom se connectent sur un port série et emploient
la technologie à large bande spectrale et peuvent aller jusqu'à
100kbps.
Des informations sur ceux-ci sont disponibles sur :
<ULink URL="http://www.metricom.com/">
	Le serveur web de Metricom</ULink>.
</para>
<para>
À l'heure actuelle, les outils réseau habituels ne 
supportent pas le gestionnaire
STRIP, vous devez donc télécharger des outils 
personnalisés à partir du serveur web MosquitoNet. Pour avoir
des détails sur les logiciels à utiliser allez voir :
<ULink URL="http://mosquitonet.Stanford.EDU/strip.html">
	MosquitoNet STRIP Page</ULink>.
</para>
<para>
En résumé la configuration consiste à utiliser un
programme <Emphasis>slattach</Emphasis> modifié pour régler la discipline
de ligne d'un périphérique série pour SLIP,
puis à configurer le périphérique `<Literal remap="tt">st[0-9]</Literal>'
résultant comme vous le feriez pour Ethernet avec une exception
importante : pour des raisons techniques STRIP ne supporte pas le protocole
ARP , vous devez alors configurer manuellement les entrées ARP pour 
chacun des hôtes de votre sous-réseau. Cela ne devrait pas 
être trop contraignant.
</para>
<para>
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
<Sect1>
<title>Token Ring</title>
<para>
Le noms de périphériques Token ring sont `<Literal remap="tt">tr0</Literal>', `<Literal remap="tt">tr1</literal>'
 etc. Token Ring est un protocole LAN standard IBM en vue d'éviter
les collisions en fournissant un mécanisme qui n'autorise qu'une
seule station du LAN à transmettre à un moment donné.
Un `jeton' est détenu par une station à un moment donné,
et celle-ci est la seule autorisée à émettre. Lorque c'est
fait, elle passe le jeton à la station suivante. Le jeton fait
le tour de toutes les stations actives, d'où le nom de `Token Ring'
(anneau à jeton).
</para>
<para>
<Emphasis>Options de compilation du noyau</Emphasis> :
<Screen>
Network device support  ---&#62;
	[*] Network device support
	....
	[*] Token Ring driver support
	&#60; &#62; IBM Tropic chipset based adaptor support
</Screen>
</para>
<para>
La configuration de token ring est identique à celle de l'Ethernet
à l'exception du nom de périphérique réseau à configurer.
</para>
<para>
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
<Sect1>
<title>X.25</title>
<para>
X.25 est un protocole de circuit basé sur la commutation de paquets
défini par le
<Literal remap="tt">C.C.I.T.T.</Literal> (un groupe de normalisation reconnu par les compagnies de 
télécommunications dans la plupart du monde). Une 
implémentation de X.25 et LAPB est en cours dans les noyaux 
récents <Literal remap="tt">2.1.*</Literal>.
</para>
<para>
Jonathon Naylor <Literal remap="tt">jsn@cs.nott.ac.uk</Literal> dirige le développement
et une liste de diffusion a été créée pour discuter
des affaires relatives à X.25 pour Linux. Pour y souscrire, envoyez
un message à :
 <Literal remap="tt">majordomo@vger.rutgers.edu</Literal> avec le texte
 "<Literal remap="tt">subscribe linux-x25</Literal>" dans le corps du message.
</para>
<para>
Les dernières versions des outils de configuration peuvent être
obtenues sur le site ftp de Jonathon à
 <ULink URL="ftp://ftp.cs.nott.ac.uk/jsn/">ftp.cs.nott.ac.uk</ULink>.
</para>
<para>
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
<Sect1>
<title>Carte WaveLan </title>
<para>
Les noms de périphériques Wavelan sont `<Literal remap="tt">eth0</Literal>', `<Literal remap="tt">eth1</Literal>', 
etc.
</para>
<para>
<Emphasis>Options de compilation du noyau</Emphasis> :
<Screen>
Network device support  --->
	[*] Network device support
	....
	[*] Radio network interfaces
	....
	&#60;*&#62; WaveLAN support
</Screen>
</para>
<para>
La carte WaveLAN est une carte LAN sans-fil à large bande. Elle ressemble
beaucoup en pratique à une carte Ethernet et se configure presque de la
même manière.
</para>
<para>
Vous pouvez avoir des informations sur la carte Wavelan sur
<ULink URL="http://www.wavelan.com/">Wavelan.com</ULink>.
</para>
<para>
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
</chapter>

<chapter>
<title>Câbles et câblages</title>
<para>
Ceux qui sont habiles du fer à souder peuvent vouloir fabriquer leurs
propres câbles pour relier deux machines Linux. Les schémas de
câblage suivants pourront les y aider.
</para>
<Sect1>
<title>Câble série NULL Modem </title>
<para>
Tous les câbles NULL modem ne se ressemblent pas. Une grosse partie
d'entre eux ne font 
que faire croire à votre ordinateur que tous les signaux 
appropriés sont présents et échangent les 
données de 
transmission et de réception. C'est bien, mais cela signifie que
vous devez utiliser le contrôle de flux logiciel (XON/XOFF) qui est
moins efficace que le contrôle de flux matériel. Le câble
suivant donne la meilleure transmission de signal entre les deux machines
et vous permet d'utiliser le contrôle de flux matériel (RTS/CTS).

<Screen>
Pin Name  Pin                               Pin
Tx Data    2  - - - - - - - - - - - - - - - -3
Rx Data    3  - - - - - - - - - - - - - - - -2
RTS        4  - - - - - - - - - - - - - - - -5
CTS        5  - - - - - - - - - - - - - - - -4
Ground     7  - - - - - - - - - - - - - - - -7
DTR        20 -\- - - - - - - - - - - - - - -8
DSR        6  -/
RLSD/DCD   8  - - - - - - - - - - - - - -/-  20
                                         \-  6
</Screen>

<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
<Sect1>
<title>Câble port parallèle (câble PLIP)</title>
<para>
Si vous avez l'intention d'utiliser le protocole PLIP entre deux machines
alors ce câble vous conviendra indépendamment du type de 
port parallèle installé.
<Screen>

Pin Name    pin            pin
STROBE      1*
D0-&#62;ERROR   2  - - - - - - 15
D1-&#62;SLCT    3  - - - - - - 13
D2-&#62;PAPOUT  4  - - - - - - 12
D3-&#62;ACK     5  - - - - - - 10
D4-&#62;BUSY    6  - - - - - - 11
D5          7*
D6          8*
D7          9*
ACK-&#62;D3     10 - - - - - - 5
BUSY-&#62;D4    11 - - - - - - 6
PAPOUT-&#62;D2  12 - - - - - - 4
SLCT-&#62;D1    13 - - - - - - 3
FEED        14*
ERROR-&#62;D0   15 - - - - - - 2
INIT        16*
SLCTIN      17*
GROUND      25- - - - - - -25
</Screen>
</para>
<para>
Notes :
<ItemizedList>
<ListItem>
<para>
Ne pas connecter les broches marquées avec un astérisque 
`*'.
</para>
</ListItem>
<ListItem>
<para>
Les masses supplémentaires sont 18,19,20,21,22,23 et 24.
</para>
</ListItem>
<ListItem>
<para>
Si le câble que vous utilisez possède un blindage, 
il doit être connecté à une des prises DB-25 et
<Emphasis>une seule extrémité</Emphasis>.
</para>
</ListItem>
</ItemizedList>
<Emphasis>Attention : un câble PLIP mal branché peut détruire
votre carte contrôleur</Emphasis>. Soyez attentifs et vérifiez
chaque connexion deux fois pour être sûr de ne pas vous
créer de travail inutile ou de gros ennuis.
</para>
<para>
Bien que l'on puisse utiliser des câbles PLIP sur des longues distances,
évitez-le si possible. Les spécifications du câble
permettent d'avoir une longueur d'environ 1 mètre. Faites attention
si vous utilisez de grandes longueurs, car les sources de champs 
magnétiques élevés comme la foudre, les lignes de 
puissance et les émetteurs radio peuvent interférer et
parfois endommager votre carte contrôleur. Si vous voulez vraiment
connecter deux de vos ordinateurs sur une grande distance, utilisez plutôt
 des cartes Ethernet et un câble coaxial.
</para>
<para>
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
<Sect1>
<title>Câblage Ethernet 10base2 (coaxial fin) </title>
<para>
10base2 est un standard de câblage Ethernet spécifiant 
l'utilisation d'un câble coaxial 50 ohms avec un diamètre
d'environ 5 mm. Il faut se souvenir d'un nombre important de règles 
 quand on relie deux machines avec un câblage 10base2.
La première est que vous devez utiliser des terminaisons <Emphasis>à
chaque extrémité</Emphasis> du câble. Un terminateur est une
résistance de 50 ohms qui sert à s'assurer que le signal
est absorbé et non réfléchi à 
l'extrémité du câble. Sans terminaison à chaque
extrémité vous pourriez trouver que l'Ethernet n'est pas
fiable ou ne marche pas du tout. Normalement vous utilisez des `T' pour
interconnecter les machines, en sorte que vous finirez par avoir quelque 
chose qui ressemble à ceci :
</para>
<para>
<Screen>
 |==========T=============T=============T==========T==========|
            |             |             |          |
            |             |             |          |
          - - -         - - -         - - -      - - -
          |   |         |   |         |   |      |   |
          - - -         - - -         - - -      - - -
</Screen>
</para>
<para>
 Les `<Literal remap="tt">|</Literal>' à chaque extrémité 
représentent une terminaison, les
`<Literal remap="tt">======</Literal>' représentent une longueur de câble coaxial avec
des prises BNC en bout et les
`<Literal remap="tt">T</Literal>' représentent un connecteur en `T'. Gardez la longueur de
câble entre les connecteurs en `T' et les cartes Ethernet aussi courte
que possible, l'idéal étant que ces connecteurs soient
branchés directement sur la carte Ethernet.
</para>
<para>
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
<Sect1>
<title>Câblage Ethernet à paires torsadées</title>
<para>
Si vous n'avez que deux cartes Ethernet avec paires torsadées
et que vous voulez les relier, vous n'avez pas besoin de répartiteur.
Vous pouvez câbler les deux cartes directement ensemble.
Un schéma montrant comment faire est inclus dans le document
<ULink URL="Ethernet-HOWTO.html">Ethernet-HOWTO</ULink>
</para>
<para>
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
</chapter>

<!-- *********************************************************************** -->

<chapter>
<title>Glossaire des termes utilisés dans ce document.</title>
<para>
Ci-dessous une liste des termes les plus importants utilisés dans ce document.
<VariableList>
<VarListEntry>
<Term>ARP</Term>
<ListItem>
<para>
C'est l'acronyme de <Emphasis>Address Resolution Protocol</Emphasis>
(protocole de résolution d'adresses), permettant à une machine du
réseau d'associer une adresse IP à une adresse matérielle.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>ATM</Term>
<ListItem>
<para>
C'est l'acronyme de <Emphasis>Asynchronous Transfer Mode</Emphasis> 
(mode de transfert asynchrone). Un réseau ATM enveloppe les 
données en blocs de taille standard pour pouvoir les convoyer
efficacement d'un point à un autre. ATM est une technologie
réseau à commutation de paquets.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>client</Term>
<ListItem>
<para>
C'est habituellement le morceau de logiciel 
d'un système du côté où se trouve l'utilisateur.
Il y a des exceptions, par exemple, dans le système de fenêtres
X11 c'est en fait le serveur qui est avec l'utilisateur et 
le client qui est sur la
machine distante. Le client est le programme ou l'extrémité d'un
système qui utilise le service fourni par un 
serveur. Dans le cas de 
systèmes <Emphasis>d'égal à égal</Emphasis> tels que <Emphasis>slip</Emphasis> ou
<Emphasis>ppp</Emphasis> le client se trouve à l'extrémité qui a 
initialisé la connexion, l'autre extrémité, étant
 considérée comme le serveur.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>datagramme</Term>
<ListItem>
<para>
Un datagramme est un paquet discret de données
qui contient les adresses, et qui est l'unité de base de transmission
sur un réseau IP. On peut aussi l'appeler `paquet'.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>DLCI</Term>
<ListItem>
<para>
DLCI veut dire `Data Link Connection Identifier'(identifieur
de connexion de liaison de données), et est utilisé pour
identifier une liaison virtuelle unique point à point via un
réseau à relais de trames (Frame Relay). Les DLCI sont
normalement assignés par le fournisseur de réseau à
relais de trames.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>Relais de trames</Term>
<ListItem>
<para>
Frame Relay (Relais de trames) est une technologie
réseau idéale lorsque l'on a un 
trafic de nature cahotique ou sporadique. Les coûts peuvent être
réduits quand on a de nombreux clients partageant la
même capacité réseau et on compte sur le fait que
les clients utilisent le réseau à des instants
différents.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>Adresse matérielle</Term>
<ListItem>
<para>
C'est un nombre qui identifie de 
manière unique un hôte sur un réseau physique au niveau
de la couche accès. Par exemple :
 <Emphasis>Adresses Ethernet
</Emphasis> et <Emphasis>Adresses AX.25</Emphasis>.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>ISDN</Term>
<ListItem>
<para>
C'est l'acronyme de <Emphasis>Integrated Services Digital
Network</Emphasis>(Réseau Numérique à Intégration de
Services=RNIS). Il fournit des moyens standardisés avec lesquels
 les compagnies de télécommunications peuvent délivrer
soit de la voix soit des informations vers des clients.
Techniquement c'est un réseau de données à commutation de paquets.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>ISP</Term>
<ListItem>
<para>
C'est l'acronyme de `Internet Service Provider' (fournisseur
d'accès à l'Internet=FAI). Ce sont des organisations ou des
sociétés qui fournissent une connexion réseau à l'Internet au public.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>Adresse IP</Term>
<ListItem>
<para>
C'est un nombre qui identifie de manière unique
un hôte TCP/IP sur le réseau. Cette adresse est 
codée sur 4 octets et
se présente habituellement sous la forme appelée "notation
décimale pointée", où chaque octet est sous forme 
décimale, avec un point `.' entre chaque.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>MSS</Term>
<ListItem>
<para>
Le Maximum Segment Size (<Emphasis>MSS</Emphasis>) (Taille Maximum de
Segment) est la plus grande quantité de données qui peut
être transmise en une seule fois. Si vous voulez éviter
des fragmentations MSS doit être égal à l'en-tête
MTU-IP.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>MTU</Term>
<ListItem>
<para>
Le Maximum Transmission Unit (<Emphasis>MTU</Emphasis>) (taille maximum
de l'unité de transfert) est un paramètre qui détermine
le plus long datagramme pouvant être transmis par une interface IP
sans avoir besoin d'être fragmenté en unités plus petites.
Le MTU doit être plus grand que le datagramme le plus grand que vous
voulez transmettre sans être fragmenté. Note : ceci protège
de la fragmentation uniquement de manière locale, d'autres liens
sur le chemin peuvent avoir un MTU plus petit et les datagrammes seront
fragmentés à cet endroit. Les valeurs typiques sont de 1500 octets
pour une interface Ethernet, ou de 576 octets pour une interface SLIP.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>route</Term>
<ListItem>
<para>
La <Emphasis>route</Emphasis> est le chemin que les datagrammes suivent
à travers le réseau pour atteindre leur destination.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>serveur</Term>
<ListItem>
<para>
C'est habituellement le morceau de logiciel ou 
l'extrémité d'un système éloigné de
l'utilisateur. Le serveur fournit un service vers un ou plusieurs clients.
Des exemples de serveurs sont
 <Emphasis>ftp</Emphasis>, <Emphasis>Networked File System</Emphasis> (NFS), ou
<Emphasis>Domain Name Server</Emphasis> (DNS). Dans le cas de systèmes <Emphasis>égal
à égal</Emphasis> comme
<Emphasis>SLIP</Emphasis> ou <Emphasis>PPP</Emphasis> le serveur est considéré comme étant
l'extrémité de la liaison qui est appelée et 
l'extrémité appeleante est le client.
</para>
</ListItem>
</VarListEntry>
<VarListEntry>
<Term>fenêtre</Term>
<ListItem>
<para>
La <Emphasis>fenêtre</Emphasis> (window) est la plus
grande quantité de données que l'extrémité 
réceptrice peut accepter à un certain moment.
</para>
</ListItem>
</VarListEntry>
</VariableList>
</para>
</chapter>

<!-- *********************************************************************** -->

<chapter>
<title>Auteurs :</title>

<Sect1>
<title>Actuels</title>
<para>
Joshua D. Drake
</para>

<Para><Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
<Sect1>
<title>Passés</title>
<para>
Terry Dawson
Allessandro Rubini
</para>
<para>
<Ulink URL="https://secure.paypal.com/cgi-bin/webscr?cmd=_xclick&amp;business=auctions@commandprompt.com&amp;return=http://www.linuxdoc.com&amp;item_name=Net-HOWTO_Donation&amp;item_number=Net-HOWTO_Donation&amp;amount=2.50">Ceci vous a intéressé? Pourquoi ne pas donner 2,50 dollars?</Ulink></para>
</Sect1>
</chapter>

<!-- *********************************************************************** -->

<chapter>
<title>Copyright.</title>
<para>
<Emphasis>Information de copyright</Emphasis>
</para>
<para>
Les documents NET-3/4-HOWTO,NET-3 et Networking-HOWTO donnent des informations concernant l'installation
et la configuration du support réseau pour Linux.
Copyright (c) 1997 Terry Dawson, 1998 Alessandro Rubini, 1999 & 2000 Joshua D. Drake &lcub;POET&rcub;/CommandPrompt, Inc -  <ULink URL="http://www.linuxports.com/">http://www.linuxports.com</ULink>
</para>
<para>
Celui-ci est libre ; vous pouvez le redistribuer et/ou le modifier
selon les termes de la
 GNU General Public License telle que publiée par la Free Software
Foundation ; soit avec la version 2 de la license, soit (à votre guise)
avec une version ultérieure.

Ce document est distribué avec l'espoir qu'il sera utile, mais
SANS AUCUNE GARANTIE ; ni même la garantie implicite
de COMMERCIALISATION ou D'ADAPTATION DANS UN BUT PARTICULIER. Voir la
 GNU General Public License pour plus de détails.

Vous devriez recevoir une copie de la GNU General Public License 
avec ce document ; si ce n'est pas le cas, écrivez à :

Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
</para>
<para>
Note du traducteur
</para>
<para>
Voir les autres HOWTO traduits en français.
Lire également le livre «Administration réseau sous Linux, éditions O'Reilly».
Enfin voyez le site <ULink URL="http://www.linux-france.com">www.linux-france.com</ULink> où vous trouverez de très bons articles décrivant en détail différents
points évoqués dans ce document.
</para>
</chapter>
</Book>
