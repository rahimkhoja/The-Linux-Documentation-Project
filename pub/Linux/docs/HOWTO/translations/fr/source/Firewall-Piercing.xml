<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
  "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd" [
  <!ENTITY howto      "http://www.traduc.org/docs/howto/lecture/">
  <!ENTITY guide      "http://www.traduc.org/docs/guides/lecture/">
  <!ENTITY traduc     "http://www.traduc.org">
]>

<!--
$Id: Firewall-Piercing.sgml,v 1.1 2001/11/25 00:39:35 gferg Exp $
Revision 1.25 was the last to use LinuxDoc-SGML
Revision 1.3 corresponds loosely to Firewall-Piercing.fr.sgml 1.3

Compile this file with:
jade -t sgml -d /usr/share/sgml/docbook/stylesheet/dsssl/modular/html/docbook.dsl -V html-index Firewall-Piercing.en.sgml
-->

<article lang="fr">

<articleinfo>

<title>Petit guide du perçage de pare-feux</title>

<subtitle>

Version française du petit guide <foreignphrase lang="en">Firewall 
Piercing mini-HOWTO</foreignphrase>

</subtitle>

<author>

<firstname>François-René</firstname>
<surname>Rideau</surname>
<email>fare PLUS fwprc CHEZ tunes POINT org</email>

</author>

  <othercredit role="traduction" class="translator">
     <firstname>Arnaud</firstname>
     <surname>Muller</surname>
     <contrib>Adaptation française</contrib>
     <email>arnaud POINT muller CHEZ insa TIRET rouen POINT fr</email>
  </othercredit>

  <othercredit role="relecture" class="translator">
    <firstname>Yvon</firstname>
    <surname>Benoist</surname>
    <contrib>Relecture de la version française</contrib>
    <email>yvon POINT benoist CHEZ insa TIRET rouen POINT fr</email>
  </othercredit>

  <othercredit role="publication" class="copyeditor">
    <firstname>Jean-Philippe</firstname>
    <surname>Guérard</surname>
    <contrib>Préparation de la publication de la v.f.</contrib>
    <email>fevrier CHEZ tigreraye POINT org</email>
  </othercredit>

<releaseinfo>Version&nbsp;: 0.97</releaseinfo>
<pubdate>18 septembre 2006</pubdate>

<revhistory>
   <revision>
         <revnumber>0.97.fr.1.0</revnumber>
         <date>2006-09-18</date>
         <authorinitials>AM, YB, JPG</authorinitials>
          <revremark>
                Première version française.
         </revremark>
   </revision>
   <revision>
         <revnumber>0.97</revnumber>
         <date>2001-11-24</date>
         <authorinitials>FRR</authorinitials>
          <revremark>

		Conversion au format SGML DocBook.
                <emphasis lang="en">Conversion to DocBook 
                SGML.</emphasis>

         </revremark>
   </revision>
</revhistory>

<abstract><para>

Comment utiliser <command>ppp</command> par-dessus 
<command>ssh</command>, <command>telnet</command> ou autre, de façon à 
réaliser une connexion réseau transparente à travers un pare-feu. 
Valable aussi bien pour l'élaboration d'un VPN convivial que pour la 
perforation des pare-feu gênants.

</para></abstract>

</articleinfo>

<sect1>
<title>Divers</title>
<sect2>
<title>Avis de non-responsabilité</title>
<para>
<emphasis>Lisez cette section, elle est importante&nbsp;!!!!</emphasis>
</para>
<para>
<emphasis>

Par la présente je décline toute responsabilité quant à l’utilisation 
que vous ferez de cette méthode d'effraction [hack]. Si ça se retourne 
contre vous d’une manière ou d'une autre, c’est pas de pot. Et c’est pas 
ma faute. Si vous ne comprenez pas les risques encourus, laissez tomber. 
Si vous utilisez cette méthode de piratage et qu’il permet à des 
vandales sans scrupules de pénétrer dans les ordinateurs de votre 
société et que ça vous coûte votre boulot et des millions d’euros à 
votre entreprise, eh bien c’est pas de pot. Ne venez pas pleurer chez 
moi.

</emphasis>
</para>
</sect2>
<sect2>
<title>Baratin juridique</title>
<para>
Copyright &copy; 1998-2001 par François-René Rideau.
</para>
<para>
Ce document est publié en logiciel libre sous la
<ulink url="http://www.geocities.com/SoHo/Cafe/5947/bugroff.html"
> license bugroff</ulink>.
</para>
<para>

Pour faciliter leur travail, les droits ont également été cédés aux 
responsables de la maintenance du LDP [Linux Development Project] sous 
la <ulink url="http://www.gnu.org/copyleft/fdl.html">Licence de 
Documentation Libre GNU</ulink>.

</para>
</sect2>
<sect2>
<title>Recherche responsable de la maintenance</title>
<para>

Je ne m'occupe plus activement de l’évolution de ce petit guide, bien 
que je continue d’en assurer la maintenance. Je recherche une personne 
qui pourrait prendre le relais pour la maintenance, qui l’étofferait 
pour en faire un petit guide à part entière en s’étendant davantage sur 
les solutions dont je ne fais que mentionner l’existence, et qui 
pourrait peut être développer des logiciels pour rendre la perforation 
de pare-feu plus facile. J’ai énormément d’idées pour étendre le contenu 
de ce petit guide et développer un logiciel adéquat, si quelqu’un est 
intéressé. J’avais également écrit une version française de ce guide 
pratique, mais personne n’en assure plus la maintenance depuis longtemps 
[NdT : ceci est une nouvelle traduction].

</para>
</sect2>
<sect2>
<title>Remerciements</title>
<para>
Même si tout ce qu’il en reste est le paragraphe sur la non responsabilité, ce document doit énormément au
<ulink url="http://www.linuxdoc.org/HOWTO/mini/Term-Firewall.html"
>Term-Firewall mini-HOWTO</ulink>
de Barak Pearlmutter 

<email>bap CHEZ cs POINT unm POINT edu</email>.

Le petit guide de Barak repose sur <productname>Term</productname>,
ancien programme qui n’est plus supporté (excellent programme en son 
temps, et qui peut être encore utile dans certaines circonstances 
malheureuses), ainsi que certaines particularités d’une implémentation 
non standard de telnet, autrement dit beaucoup d’éléments obsolètes et 
non portables. Néanmoins, un petit guide sur la perforation des pare-feu 
était 
nécessaire, et malgré les limites des méthodes d'effraction [hacks] 
qu'il propose, son petit guide a été un modèle et un encouragement.
</para>
<para>
J’aimerais également féliciter Lars Brinkhoff

<email>lars CHEZ nocrew POINT org</email>

<!-- Andreas 'Ajje' Pettersson <email>ajje@wombat.ludvika.se</email> -->
et Magnus Lundström

<email>logic CHEZ gore POINT nocrew POINT org</email>

pour leurs très bons tunnels http, messagerie et icmp.
</para>
</sect2>
<sect2>
<title>Dernières versions</title>
<para>
La dernière version LDP officielle de ce document est sur&nbsp;:
<ulink url="http://www.linuxdoc.org/HOWTO/mini/Firewall-Piercing.html"
>http://www.linuxdoc.org/HOWTO/mini/Firewall-Piercing.html</ulink>
</para>
<para>
La source de ma dernière version officielle de ce document est sur&nbsp;:
<ulink url="http://fare.tunes.org/files/fwprc/"
>http://fare.tunes.org/files/fwprc/</ulink>
</para>
<para>
La source de mon dernier brouillon de travail pour ce document est sur&nbsp;:
<ulink url="http://tunes.org/cgi-bin/cvsweb/fare/fare/www/articles/Firewall-Piercing.en.sgml"
>http://tunes.org/cgi-bin/cvsweb/fare/fare/www/articles/Firewall-Piercing.en.sgml</ulink>
</para>
</sect2>
</sect1>
<sect1>
<title>Introduction</title>
<sect2>
<title>Avant propos</title>
<para>
Ce document a une morale. Et cette morale est&nbsp;:
<emphasis remap="bf">un pare-feu ne peut pas protéger un réseau contre ses propres utilisateurs internes et ne devrait même pas essayer.
</emphasis>
</para>
<para>
Lorsqu’un utilisateur interne vous demande à vous, administrateur système, d’ouvrir un port sortant vers une machine externe, ou un port entrant vers une machine interne, vous devez le faire pour lui. Evidemment, vous devez aider l’utilisateur pour être sûr que ses transactions sont sécurisées, et que son logiciel est robuste. Mais refuser carrément de rendre ce service à l'utilisateur relève d’une incompétence évidente. A moins que le pare-feu ne le coupe complètement du reste du monde extérieur, au point de se retrouver sans <command>ssh</command>, <command>telnet</command>, navigateur web, courrier électronique, dns, ligne téléphonique, radio, et sans pouvoir faire de <command>ping</command>, rien de rien, il n’en demeure pas moins que l’utilisateur peut utiliser les techniques de perforation de pare-feu pour accéder aux machines qu’il veut , et il le fera, et, résultat final au niveau sécurité, on aura une connexion non vérifiée avec le monde extérieur. Alors soit vous faites confiance à vos utilisateurs, après une formation et une sélection appropriées, soit vous leur refusez tout accès au réseau; mais là encore le rôle d’un administrateur réseau est habituellement de servir ses utilisateurs, alors c’est plutôt le premier cas de figure qu’il faut viser, pas le deuxième. Vous pouvez et vous devez les protéger contre le monde extérieur, vous pouvez et vous devez protéger vos services sensibles contre vos utilisateurs, mais vous ne les protégerez point contre eux-mêmes, et vous ne le pouvez pas.
</para>
<para>

Parce que des administrateurs passifs, ou absents, ou surchargés, ou 
carrément incompétents, ou irresponsables, ou simplement dirigés par des 
personnes incompétentes, ça existe, il se trouve parfois qu’un 
utilisateur puisse se retrouver derrière un pare-feu qu’il peut 
traverser, mais ce ne sera pas très commode. Ce petit guide fournit un 
moyen générique et portable de percer des tunnels dans des pare-feu, en 
transformant les rares petits bits qui arrivent au compte-gouttes en une 
véritable autoroute de l’information, de sorte que l’utilisateur puisse 
utiliser d’une façon cohérente des outils standards pour accéder aux 
ordinateurs de l’autre côté du pare-feu. La même technique peut être 
utilisée par les administrateurs réseaux compétents pour faire des 
réseaux privés virtuels (VPN [Virtual Private Networks]).

</para>
</sect2>
<sect2>
<title>Les problèmes de sécurité.</title>
<para>

Bien entendu si votre administrateur système a installé un pare-feu, il 
a sûrement une bonne raison et vous avez sûrement signé un engagement à 
ne pas le contourner. D’un autre côté, le fait que vous puissiez 
utiliser telnet, le web, la messagerie électronique, ou tout autre flux 
quel qu’il soit d’information bidirectionnel avec l’extérieur du 
pare-feu (ce qui est une condition sine qua non pour que les méthodes 
présentées puissent fonctionner) signifie que vous êtes autorisé à 
accéder à des systèmes externes, et le fait que vous puissiez ouvrir une 
session sur un système externe particulier signifie que vous êtes aussi 
autorisé à le faire.

</para>
<para>
Il s’agit donc ici tout simplement d’utiliser de façon
<emphasis>commode</emphasis>
les failles légales d’un pare-feu, et d’autoriser les programmes génériques à fonctionner à partir de là avec les protocoles génériques, plutôt que d’avoir recours à des programmes spéciaux ou modifiés (et recompilés) passant par de nombreux proxies à usage particulier qui ont été mal configurés par un administrateur système négligent ou incompétent, ou d’installer de nombreux convertisseurs à usage particulier pour accéder à chacun de vos services habituels (comme la messagerie électronique) en passant par des chemins supportés par le pare-feu (comme le web).
</para>
<para>
De plus, l’utilisation d’un émulateur d’IP niveau utilisateur tel que
<productname>SLiRP</productname>
devrait permettre de maintenir la protection contre les attaques extérieures par perforation du pare-feu, à moins que vous ne le permettiez explicitement (ou alors les agresseurs sont astucieux et malicieux, et root, ou, sinon, capables de vous espionner sur le serveur).
</para>
<para>
L’un dans l’autre, la méthode présentée devrait être relativement sécurisée. Cependant, ça dépend des conditions particulières dans lesquelles vous faites l’installation, et je ne peux donner aucune garantie sur cette méthode. De nombreuses choses sont intrinséquement non sécurisées au niveau des connections internet, que ce soit avec cette méthode ou pas, donc n’imaginez surtout pas que telle ou telle chose est sécurisée à moins que vous n’ayez de bonnes raisons, et/ou utilisez un procédé de chiffrage tout le temps.
</para>
<para>
Répétons les bases de la sécurité réseau&nbsp;:
<emphasis>vous ne pouvez faire confiance à rien du tout au niveau d’une connexion, pas plus que vous ne faites confiance aux hôtes qui peuvent manier les données non cryptées
</emphasis>,
y compris les hôtes des deux côtés de la connection, et tous les hôtes qui peuvent intercepter la communication, à moins que la communication soit cryptée correctement avec des clefs secrètes. Si vous placez mal votre confiance, vos mots de passe peuvent être volés et utilisés contre vous, votre numéro de carte de crédit peut être volé et utilisé contre vous, et vous pouvez être viré de votre boulot pour avoir mis en danger toute l’entreprise. Tant pis pour vous.
</para>
<para>
Pour résumer, n’utilisez pas cette méthode sauf si vous savez ce que vous faites. Relisez l’avis de non-responsabilité plus haut.
</para>
</sect2>
<sect2>
<title>Autres conditions requises</title>
<para>

On suppose que vous savez ce que vous faites, que vous savez comment 
configurer une connexion au réseau, qu’en cas de doute vous aurez lu 
toute la documentation qu’il faut (guides pratiques, manuels, pages web, 
archives de listes de diffusion, RFC, cours, tutoriels).

</para>
<para>
On suppose que vous avez des comptes console des deux côtés du pare-feu, que vous pouvez d’une façon ou d’une autre transmettre des paquets d’information dans les deux sens à travers le pare-feu (avec <command>telnet</command>, <command>ssh</command>, le courriel, et le web comme moyens les plus couramment utilisés pour travailler), et que vous pouvez laisser un démon en fonctionnement comme tâche en arrière-plan sur le serveur (ou bénéficier d’un démon existant,
<command>sshd</command>, <command>telnetd</command>, ou
<command>sendmail</command>/<command>procmail</command>).
</para>
<para>
On suppose que vous savez ou que vous êtes disposé à apprendre comment configurer un émulateur d’IP
 (<command>pppd</command>, <command>slirp</command>)
ou un accès à internet démon et la bibliothèque qui va avec 
 (<productname>SOCKS</productname>, <productname>Term</productname>)
des deux côtés, en fonction de vos besoins en terme de connectivité et de vos droits d’accès, en recompilant certains logiciels si besoin est.
</para>
<para>
Enfin, et c’est également important, pour que vous puissiez utiliser les méthodes décrites dans ce document, on suppose que vous êtes root du côté du pare-feu qui a besoin d’un accès IP transparent complet vers l’autre côté. En effet, il vous faudra lancer le démon PPP de ce côté, ce qui permet l’utilisation de l’installation normale de routage du paquet kernel. Au cas où vous n’êtes pas root de ce côté, votre cas n’est pas désespéré malgré tout&nbsp;: en effet le
<ulink url="http://www.linuxdoc.org/HOWTO/mini/Term-Firewall.html"
>Term-Firewall mini-HOWTO</ulink>
de Barak Pearlmutter décrit comment utiliser <productname>Term</productname>,
programme entièrement fait pour l’utilisateur, en vue du perçage de pare-feu. Bien qu’il n’y ait aucun petit guide, je soupçonne
<productname>SOCKS</productname> de pouvoir également être utilisé comme un moyen de percer les pare-feu sans avoir le privilège root; j’accepterai volontiers vos contributions à ce Guide pratique sur cette méthode pour percer les pare-feu.
</para>
</sect2>
<sect2>
<title>Logiciels à télécharger</title>
<para>
La plupart des logiciels mentionnés dans ce Guide pratique devrait être disponible dans votre distribution de Linux standard, éventuellement parmi les contributions. Au moins, les quatre premiers ci-dessous sont disponibles en tant que paquets <filename>.rpm</filename> et <filename>.deb</filename> Au cas vous voudriez récupérer les dernières versions (après tout, un des deux bouts de la connexion peut ne pas fonctionner sous Linux), utilisez les adresses ci-dessous&nbsp;:

<itemizedlist>
<listitem>
<para>
<command>SLiRP</command> se trouve sur

<ulink url="http://blitzen.canberra.edu.au/slirp"
>http://blitzen.canberra.edu.au/slirp</ulink> ou sur
<ulink url="ftp://www.ibc.wustl.edu/pub/slirp_bin/"
>ftp://www.ibc.wustl.edu/pub/slirp_bin/</ulink>.
</para>
</listitem>
<listitem>
<para>
<command>zsh</command> se trouve sur
<ulink url="http://www.zsh.org/">http://www.zsh.org/</ulink>.
</para>
</listitem>
<listitem>
<para>
<command>ppp</command> se trouve sur
<ulink url="ftp://cs.anu.edu.au/pub/software/ppp/"
>ftp://cs.anu.edu.au/pub/software/ppp/</ulink>.
</para>
</listitem>
<listitem>
<para>
<command>ssh</command> se trouve sur
<ulink url="http://www.openssh.com/"
>http://www.openssh.com/</ulink>.
</para>
</listitem>
<listitem>
<para>
<command>fwprc</command>, <command>cotty</command>
et <command>getroute.pl</command> se trouvent sur
<ulink url="http://fare.tunes.org/files/fwprc/"
>http://fare.tunes.org/files/fwprc/</ulink>.
</para>
</listitem>
<listitem>
<para>
<command>httptunnel</command> se trouve sur
<ulink url="http://www.nocrew.org/software/httptunnel/"
>http://www.nocrew.org/software/httptunnel/</ulink>.
</para>
</listitem>
<listitem>
<para>
<command>mailtunnel</command> se trouve sur
<ulink url="http://www.detached.net/mailtunnel/"
>http://www.detached.net/mailtunnel/</ulink>.
</para>
</listitem>
</itemizedlist>
</para>
</sect2>
</sect1>
<sect1>
<title>Compréhension du problème</title>
<para>
Quand vous comprenez un problème, vous avez fait la moitié du chemin vers la solution.
</para>
<sect2>
<title>Donner un nom aux choses</title>
<para>
Si vous voulez que cette méthode fonctionne, vous devrez comprendre comment elle fonctionne pour que, si quelque chose ne marche pas, vous sachiez où chercher.
</para>
<para>
La première étape pour comprendre le problème est de donner un nom aux concepts appropriés.
</para>
<para>
Comme d’habitude, nous allons ci-après appeler «&nbsp;client&nbsp;» la machine qui décide d’initialiser la connexion, ainsi que les programmes et les fichiers sur cette machine. Réciproquement, nous appelerons «&nbsp;serveur&nbsp;» celui qui attend les connexions et les accepte, ainsi que les programmes et fichiers sur cette machine. Le perçage de pare-feu est utile lorsque les deux machines sont séparées par un pare-feu, de telle sorte qu’il est possible pour le serveur d’accepter certaines connexions, alors qu'il n'est pas certain que le client puisse en accepter. Un tunnel sera créé entre les deux machines, ce qui permet un trafic IP complet malgré le pare-feu.
</para>
<para>
Habituellement, lorsque l’on perce un pare-feu, le client est la machine derrière le pare-feu&nbsp;: il a un accès limité à internet, mais peut d’une façon ou d’une autre ouvrir une connexion ou une autre sur le serveur. Le serveur est une machine avec un accès complet à internet, qui va servir de proxy pour le client afin qu’il accède à internet. Dans un VPN, les rôles peuvent être inversés, avec le client étant sur internet et le serveur servant de proxy au client afin d’accéder à certains réseaux privés.
</para>
</sect2>
<sect2>
<title>Le problème principal</title>
<para>
Le problème principal pour le perçage de pare-feu est de créer un tunnel&nbsp;: une connexion continue d’une machine cliente vers une machine serveur de l’autre côté du pare-feu, qui permet un échange bidirectionnel d’informations. Optionnellement, cette connexion devrait être sécurisée. Le problème annexe est de transformer cette connexion en un accès IP complet pour une utilisation transparente par les programmes normaux.
</para>
<para>
Pour le problème principal, nous considérerons que soit (1) vous pouvez établir des connexions TCP/IP normales du côté client du pare-feu vers un port sur une machine serveur où un sshd tourne ou peut être mis en fonctionnement, ou (2) vous pouvez d’une façon ou d’une autre établir une connexion telnet à travers un proxy telnet. Au cas où vous ne pourriez pas, nous allons vous diriger vers un autre logiciel qui permet de percer un tunnel à travers un pare-feu. Bien que nous ne donnions qu’une solution sécurisée dans le premier cas, vous pouvez bidouiller votre propre solution sécurisée dans les autres cas, si vous comprenez le principe (si vous ne le comprenez pas, quelqu’un, par exemple moi, peut le faire pour vous contre rémunération).
</para>
</sect2>
<sect2>
<title>Le problème annexe</title>
<para>
Pour le problème annexe, les émulateurs d’IP
 (<command>pppd</command> ou <productname>SLiRP</productname>)
sont lancés de chaque côté du tunnel.
</para>
<para>
Du côté qui veut un accès IP complet vers l’autre côté, il vous faudra lancer
 <command>pppd</command>.
De l’autre côté, vous devez lancer <command>pppd</command>
si vous voulez un accès IP complet dans l’autre sens, ou <productname>SLiRP</productname> si vous voulez empêcher tout accès. Consultez votre documentation <command>pppd</command> ou <productname>SLiRP</productname>
habituelle pour plus d’informations, si vous avez des besoins spécifiques qui ne sont pas traités dans les exemples ci-dessous.
 </para>
<para>
Bien qu’il s’agisse d’un concept banal, ça nécessite néanmoins quelques astuces toutes bêtes afin de fonctionner, car (a) si vous utilisez une quelconque session shell programmée interactive pour démarrer l’émulateur d’IP du serveur de n’importe quel côté, il vous faut synchroniser correctement le démarrage de l’émulateur d’IP de l’autre côté, afin de ne pas envoyer des saletés dans la session shell, et (b) les émulateurs d’IP sont conçus pour être lancés sur une interface «&nbsp;tty&nbsp;» : vous devez donc convertir votre interface tunnel en une tty.
 </para>
<para>
Le point (a) ne représente rien de plus que le problème de synchronisation habituel, et n’existe même pas si vous utilisez <command>ssh</command>,
qui s’occupe de manière transparente du lancement de commande du serveur.
 </para>
<para>
Le point (b) requiert l’utilisation d’un simple utilitaire extérieur. Nous en avons fait un, <command>cotty</command> juste dans ce but.
</para>
<para>
&lt; PIQUAGE DE CRISE&gt;
</para>
<para>
Entre autres problèmes débiles dûs à l’étroitesse d’esprit des concepteurs de <command>pppd</command> (ceci n’est plus le cas dans les versions récentes de Linux), on peut seulement le lancer soit par un dispositif dans <filename>/dev</filename> ou par le tty courant. On ne peut pas le lancer par une paire de tunnels (ce qui serait la conception évidente). C’est parfait pour le  <command>pppd</command> du serveur s’il y en a un, puisqu’il peut utiliser le <filename>tty</filename> des sessions
 <command>telnet</command> ou <command>ssh</command>; mais pour le
<command>pppd</command> du client, cela entraîne un conflit en cas d’utilisation de
 <command>telnet</command> pour établir une connexion.
</para>
<para>
En effet, <command>telnet</command> veut, également, être sur un tty, il se comporte <emphasis>presque</emphasis> correctement avec deux tunnels, à part qu’il insistera encore pour faire des iotctl au tty courant, avec lequel il va interférer&nbsp;; l’utilisation de <command>telnet</command> sans un tty impose également un régime tel que toute la connexion échouera sur des ordinateurs «&nbsp;lents&nbsp;» (<command>fwprc</command> 0.1 fonctionnait parfaitement sur un P/MMX 233, un délai d’attente de 6 sur un 6x86-P200+, et aucun sur un 486dx2/66). L’un dans l’autre, lors de l’utilisation de <command>telnet</command>, vous avez besoin de <command>cotty</command> comme démon pour copier la sortie d’un tty sur lequel fonctionne pppd sur un autre tty sur lequel fonctionne <command>telnet</command>, et inversement.
</para>
<para>
Si je trouve l’abruti (probablement un gars de <productname>MULTICS</productname> bien que il a dû y avoir des gens d’<productname>UNIX</productname> assez bêtes pour copier cette idée) qui a inventé le principe des dispositifs «&nbsp;tty&nbsp;» grâce auxquels on lit et on écrit à partir d’un «&nbsp;même&nbsp;» pseudo fichier, au lieu d’avoir des couples de tunnels propres, je l’étrangle&nbsp;!
</para>
<para>
&lt;/JE ME CALME&gt;
</para>
</sect2>
</sect1>
<sect1>
<title>La solution sécurisée&nbsp;: percer en utilisant ssh</title>
<sect2>
<title>Principe</title>
<para>
Considérons que votre administrateur de pare-feu autorise les connexions TCP transparentes vers un port quelconque sur un serveur de l’autre côté du pare-feu (que ce soit le port du ssh normal, le 22, un autre port de destination, tel que le port http, le 80, ou autre), ou que vous vous débrouillez d’une façon ou d’une autre pour qu’un port quelconque d’un côté du pare-feu soit redirigé vers un port de l’autre côté (en utilisant
<command>httptunnel</command>, <command>mailtunnel</command>, un tunnel sur le <command>telnet</command>, ou autre).
</para>
<para>
Vous pouvez alors lancer un <command>sshd</command> sur le port côté serveur, et vous y connecter avec un <command>ssh</command> sur le port côté client. Des deux côtés de la connexion <command>ssh</command> vous lancez des émulateurs d’IP ( <command>pppd</command>), et là vous avez votre VPN, réseau privé virtuel, qui évite les restrictions stupides du pare-feu, avec un bonus en plus&nbsp;: la confidentialité grâce au cryptage (faites attention, l’administrateur du pare-feu connaît tout de même l’autre bout du tunnel, et toute information d’authentification quelle qu’elle soit que vous pouvez avoir envoyée avant de lancer le <command>ssh</command>).
</para>
<para>
Exactement la même technologie peut être utilisée pour construire un VPN, réseau privé virtuel, qui permet de regrouper de façon sécurisée des sites physiques en un seul réseau logique sans sacrifier la sécurité au niveau du réseau de transport entre les sites.
</para>
</sect2>
<sect2>
<title>Exemple de session</title>
<para>
Ci-dessous se trouve un exemple de script que vous pouvez adapter à vos besoins. Il utilise le système de rangée de <command>zsh</command>, mais vous pouvez l’adapter facilement à votre shell favori. Utilisez l’option
 <command>-p</command> pour que <command>ssh</command> essaie un autre port que le port 22 (mais à ce moment-là, veillez à bien lancer <command>sshd</command> sur le même port).
</para>
<para>
Notez que le script suppose que <command>ssh</command> peut s’ouvrir sans que vous ayez à taper interactivement votre mot de passe (en effet, son tty de contrôle sera connecté à <command>pppd</command>, alors s'il vous demande un mot de passe, c’est raté). Ceci peut se faire soit avec les clefs ssh dans votre
<filename>&tilde;/.ssh/authorized_keys</filename>
pour lesquelles un mot de passe n'est pas nécessaire, ou que l'on peut débloquer en utilisant
 <command>ssh-agent</command> ou <command>ssh-askpass</command>. Regardez votre documentation sur ssh. En fait vous pourriez aussi utiliser un script de chat pour entrer votre mot de passe, mais ce n’est assurément <emphasis>pas</emphasis> la chose à faire.
</para>
<para>
Si vous n’êtes pas <command>root</command> ou simplement si vous voulez protéger le réseau de votre client des connexions sortantes, vous pouvez utiliser <command>slirp</command> au lieu de <command>pppd</command>
comme émulateur PPP du serveur. Il n’y a qu’à décommenter la ligne appropriée.
</para>
<para>
<programlisting>
<![CDATA[
#!/bin/zsh -f
SERVER_ACCOUNT=root@server.fqdn.tld
SERVER_PPPD="pppd ipcp-accept-local ipcp-accept-remote"
#SERVER_PPPD="pppd" ### Ceci suffit normalement si c’est dans /usr/sbin/
#SERVER_PPPD="/home/joekluser/bin/slirp ppp"
CLIENT_PPPD=( pppd
	silent
	10.0.2.15:10.0.2.2
	### Si vous voulez tester décommentez les lignes suivantes:
	# updetach debug
	### Une autre option potentiellement utile (allez voir la section sur le routage)&nbsp;:
	# defaultroute
)
$CLIENT_PPPD pty "ssh -t $SERVER_ACCOUNT $SERVER_PPPD"
]]>
</programlisting>
</para>
<para>
Notez que les options par défaut de votre <filename>/etc/ppp/options</filename>
ou <filename>&tilde;/.slirprc</filename>
peuvent casser ce script, enlevez donc toute option non désirée.
</para>
<para>
Notez également que <literal>10.0.2.2</literal> est le paramétrage par défaut pour <command>slirp</command>, ce qui peut ne pas fonctionner avec votre installation particulière. En tout cas, vous devriez de préférence utiliser une adresse dans l’une des catégories réservées par la RFC-1918 pour les réseaux privés&nbsp;:
<literal>10.0.0.0/8</literal>,
<literal>172.16.0.0/12</literal> ou <literal>192.168.0.0/16</literal>.
Il se pourrait que le réseau local protégé par pare-feu utilise certaines d’entre elles et il est de votre responsabilité d’éviter les conflits. Pour une plus grande personnalisation, lisez la documentation appropriée.
</para>
<para>
Si le <command>pppd</command> de votre client est vieux ou non-linux (par exemple BSD) et n’a pas d’option <command>pty</command>, utilisez&nbsp;:
<programlisting>
cotty -d -- $CLIENT_PPPD -- ssh -t $SERVER_ACCOUNT $SERVER_PPPD
</programlisting>
Pièges : ne mettez pas les commandes données à cotty entre guillemets, car elles s’exécutent <command>exec()</command>telles quel, et n’oubliez pas de spécifier le chemin complet pour le <command>pppd</command>
du serveur s’il n’est pas dans le chemin standard installé par <command>ssh</command>.
</para>
<para>
On laisse au lecteur la reconnexion automatique (conseil&nbsp;: l’option
<command>nodetach</command> de <command>pppd</command>
pourrait être utile pour ça).
</para>
</sect2>
</sect1>
<sect1>
<title>La solution non sécurisée&nbsp;: percer en utilisant telnet</title>
<sect2>
<title>Principe</title>
<para>
Si vous ne pouvez faire que du <command>telnet</command>
(à cause d’un proxy <command>telnet</command>),
cette solution pourrait bien vous convenir.
</para>
<para>

Le programme de perçage de pare-feu, <command>fwprc</command>, utilisera 
un proxy tty, <command>cotty</command>, qui ouvre deux dispositifs 
pseudo-tty, lance des commandes sur chacun des esclaves de ces 
dispositifs, et copie systématiquement chaque caractère que l’on sort 
sur le tty qui sert d’entrée pour l’autre commande. Une commande sera 
une connexion telnet vers le site serveur, et l’autre sera le 
<command>pppd</command>. <command>pppd</command> peut alors ouvrir et 
contrôler la session telnet avec un script de chat comme d’habitude.

</para>
<para>
En fait, si votre proxy telnet permet une connexion vers un port arbitraire, et si vous pouvez lancer un démon de manière sûre sur l’hôte serveur (avec relance planifiée [cron] en cas de plantage), vous feriez mieux d’écrire un programme qui connectera juste un port côté client au port côté serveur par le proxy, afin de pouvoir utiliser la solution sécurisée ci-dessus, en utilisant éventuellement une variante de 
<programlisting>
ssh -t -o "ProxyCommand ..."
</programlisting>
(Soumettez moi une solution et je l’intégrerai volontiers à la distribution
<command>fwprc</command>).
</para>
<para>
Remarque&nbsp;: si vous devez utiliser la solution non sécurisée basée sur le telnet, assurez vous que, dans votre session cible, il ne se trouve rien de confidentiel ou qui ne doive être bidouillé, puisque le mot de passe sera envoyé en clair sur internet. Si c’est à votre portée, un système ne demandant le mot de passe qu’une seule fois, ou un système de cryptographie explicite augmentera votre sécurité, ce qui, toutefois, rendra les scripts de connexion automatique bien plus complexes.
</para>
</sect2>
<sect2>
<title>fwprc</title>
<para>
J’ai écrit un script qui décrit de façon très détaillée comment percer les pare-feu, <command>fwprc</command>,
disponible sur
<ulink url="http://fare.tunes.org/files/fwprc/">mon site</ulink>,
avec également <command>cotty</command>
(qui est requis à partir de la version <literal>0.2</literal> de
 <command>fwprc</command>).
Au moment où j’ai écrit ces lignes, la version la plus avancée de
<command>fwprc</command> est <literal>0.3e</literal> et pour
<command>cotty</command> <literal>0.4c</literal>.
</para>
<para>
Le nom «&nbsp;fwprc&nbsp;» est volontairement illisible et imprononçable, afin d’embrouiller votre administrateur système incompétent et paranoïaque sans doute responsable de ce pare-feu qui vous casse les pieds (bien sûr il peut y avoir des pare-feu légitimes également, et parfois même, ils sont indispensables&nbsp;; la sécurité n’est qu’un problème de configuration
<emphasis>correcte</emphasis>).
Si vous devez le lire à voix haute, prononcez le de la pire façon possible et imaginable.
</para>
<para>
GRAND CONCOURS&nbsp;! Envoyez moi un fichier audio avec un enregistrement audio numérique de votre prononciation de «&nbsp;fwprc&nbsp;». Le prix pour la prononciation la plus mauvaise est une mise à niveau gratuite et le nom du gagnant sur la page du
 <command>fwprc</command> <literal>1.0</literal>!
</para>
<para>
J’ai testé le programme sur différentes configurations, en le configurant avec des fichiers ressources. Mais bien entendu, selon la loi de l’emmerdement maximum, ça plantera pour vous. N’hésitez pas à proposer les améliorations qui faciliteront la vie de ceux qui configureront après vous.
</para>
</sect2>
<sect2>
<title>.fwprcrc</title>
<para>
<command>fwprc</command> peut être personnalisé grâce au fichier
<filename>.fwprcrc</filename>
fait pour être le même des deux côtés du pare-feu. Avoir plusieurs configurations de rechange parmi lesquelles choisir est certes possible (par exemple, <emphasis>moi</emphasis> je le fais), et on laisse ça comme exercice pour le lecteur.
</para>
<para>
Pour commencer, copiez la section appropriée de <command>fwprc</command>
(l’avant-dernière) dans un fichier nommé <filename>.fwprcrc</filename>
dans votre répertoire home. Remplacez ensuite les valeurs des variables par des trucs qui correspondent à votre configuration. Enfin, copiez le sur l’autre hôte et testez.
</para>
<para>
Le comportement par défaut est d’utiliser <command>pppd</command> sur le client, et <command>slirp</command> sur le serveur. Pour modifier ceci, vous pouvez redéfinir la fonction appropriée dans votre <filename>.fwprcrc</filename> avec une ligne telle que&nbsp;:
<programlisting>
remote_IP_emu () { remote_pppd }
</programlisting>
</para>
<para>
Notez que <productname>SLiRP</productname> est plus sûr que
<command>pppd</command>, et plus facile d’accès, puisqu’il ne requiert pas d’être root sur la machine serveur, et n’a pas besoin d’une configuration supplémentaire du pare-feu pour empêcher les connexions du monde extérieur sur le réseau derrière un pare-feu. La fonctionnalité de base dans
<productname>SLiRP</productname> fonctionne plutôt bien, mais je n’ai pas réussi à faire marcher certains des plus qu’il est censé proposer (tel que le contrôle du temps d’exécution). Bien entendu, puisqu’il s’agit d’un logiciel libre, n’hésitez pas à aller dans la source pour carrément implémenter ou réparer n’importe quel dispositif dont vous aurez besoin.
</para>
</sect2>
</sect1>
<sect1>
<title>Routage</title>
<para>

Il ne suffit pas de percer le pare-feu. Il faut également router les 
paquets du côté client du pare-feu vers le côté serveur. Dans cette 
section, j’aborde les paramètres de base spécifiques au routage à 
travers un tunnel. Pour plus d’explications détaillées sur le routage, 
lisez les guides pratiques correspondants et les pages de manuel sur les 
réseaux, le routage et l’usurpation d’identité.

</para>
<sect2>
<title>Il y a un truc</title>
<para>
Le truc, c’est que, même si votre administrateur réseau vous demandait d’installer un routeur de votre côté client comme route par défaut, (ceci peut être utile si on veut une route spécifique vers les réseaux sur le client du pare-feu), il faudra installer PPP link comme route vers les réseaux sur le côté serveur.
</para>
<para>
En d’autres termes, votre route par défaut devrait pointer vers un routeur de n’importe quel côté du tunnel qui vous donne accès à internet.
</para>
<para>
Ce qui est primordial, c’est que les paquets envoyés au serveur hôte en tant qu’élément de fonctionnement du tunnel doivent être routés à travers votre réseau habituel (par exemple votre routeur ethernet par défaut), autrement, votre kernel aura des problèmes, vu qu’il essaie de router à l’intérieur du tunnel les paquets qui, précisément, devraient constituer l’extérieur du tunnel.
</para>
<para>
Ainsi donc, vous devrez paramétrer correctement les routes dans votre configuration de démarrage du réseau. L’emplacement précis de vos données de configuration de routage dépend de votre distribution, mais c’est généralement sous <filename>/etc/init.d/network</filename>
ou <filename>/etc/network/</filename>;
de même, votre configuration PPP se trouve généralement dans <filename>/etc/ppp/</filename>, et l’endroit normal pour configurer ces routes se trouve habituellement dans <filename>ip-up</filename> ou <filename>ip-up.d/</filename>.
(Astuce&nbsp;: pour identifier les emplacements de fichier spécifiques à votre distribution, vous devez lire la documentation de votre distribution ou encore
<ulink url="http://foldoc.doc.ic.ac.uk/foldoc/foldoc.cgi?RTFM">RTFM</ulink>;
sinon, utilisez <command>grep</command> récursivement dans votre
 <filename>/etc</filename>;
au pire, repérez ce qui se passe au moment du démarrage, comme configuré dans votre <filename>/etc/inittab</filename>.)
</para>
<para>
Lorsque vous percez un tunnel dans un réseau protégé à partir d’un portable sur internet, le script <command>getroute.pl</command>
(disponible sur la distribution <command>fwprc</command>)
donne la route utilisée vers le serveur hôte qui représente l’autre bout du tunnel.
</para>
<para>

Une fois que vous pouvez router les paquets vers le côté serveur du 
tunnel, ça vous intéressera peut-être de configurer votre machine comme 
routeur pour tous vos copains du côté client du pare-feu&nbsp;; vous 
aurez ainsi réalisé un véritable VPN partagé. Ceci n’est pas spécifique 
au perçage de pare-feu, alors lisez donc les guides pratiques 
correspondants sur les réseaux, le routage et l’usurpation d’identité. 
Egalement, pour des raisons de sécurité, veillez à bien installer un bon 
pare-feu sur votre machine, surtout si vous devez être routeur pour 
d’autres personnes.

</para>
<para>
Enfin, souvenez vous que si vous utilisez <command>pppd</command>
sur le côté serveur du tunnel (par opposition au mode utilisateur
<command>slirp</command>), vous devrez également configurer les routes qu’il faut et des règles de pare-feu du côté serveur du tunnel.
</para>
</sect2>
<sect2>
<title>Exemple de routage</title>
<para>
Dans cet exemple, votre machine cliente est connectée à un réseau local avec pare-feu grâce au dispositif ethernet <filename>eth0</filename>.
Son adresse IP est <literal>12.34.56.78</literal>;
son réseau est <literal>12.34.56.0/24</literal>;
son routeur est <literal>12.34.56.1</literal>.
</para>
<para>
Votre administrateur réseau peut vous avoir dit d’utiliser
<literal>12.34.56.1</literal>
comme routeur par défaut, mais n’en tenez pas compte. Vous devez seulement l’utiliser comme route vers le côté client du pare-feu.
</para>
<para>
Supposons que le côté client du pare-feu est composé des réseaux
<literal>12.34.0.0/16</literal> et <literal>12.13.0.0/16</literal>,
et de l’hôte <literal>11.22.33.44</literal>.
Pour les rendre accessibles par votre routeur client, ajoutez ces routes au script de démarrage de votre réseau global&nbsp;:
<programlisting>
route add -net 12.34.0.0 netmask 255.255.0.0 gw 12.34.56.1
route add -net 12.13.0.0 netmask 255.255.0.0 gw 12.34.56.1
route add -host 11.22.33.44 gw 12.34.56.1
</programlisting>
Vous devez également garder la route vers le réseau local du client, nécessaire pour le kernel 2.0 de Linux , mais pas pour le kernel 2.2 et suivants de Linux (ceci l’ajoute implicitement pendant le <command>ifconfig</command>):
<programlisting>
route add -net 12.34.56.0 netmask 255.255.255.0 dev eth0
</programlisting>
Par contre, vous devez <emphasis>impérativement</emphasis> enlever toute route par défaut de vos scripts. Supprimez ou mettez en commentaire une ligne telle que&nbsp;:
<programlisting>
route add default gw 12.34.56.1
</programlisting>
Remarquez qu’il est également possible d’enlever la route de la configuration du kernel en marche sans redémarrer, grâce à la commande suivante&nbsp;:
<programlisting>
route del default gw 12.34.56.1
</programlisting>
Vous pouvez ensuite obtenir de <command>pppd</command> l’installation automatique d’une route par défaut lorsqu’il démarre en utilisant son option
 <command>defaultroute</command> Sinon, vous pouvez l’ajouter plus tard&nbsp;:
<programlisting>
route add default gw 10.0.2.2
</programlisting>
Si vous ne voulez pas de <command>pppd</command> comme route par défaut, parce que l’accès internet est disponible de votre côté du pare-feu, et si vous voulez plutôt que le réseau <literal>98.76.48.0/20</literal>
soit routé par le tunnel, sauf au départ de l’hôte <literal>98.76.54.32</literal>
qui représente l’autre bout du tunnel, ajoutez les lignes suivantes à votre
<filename>/etc/ppp/ip-up</filename>:
<programlisting>
route add -host 98.76.54.32 gw 12.34.56.1
route add -net 98.76.48.0 netmask 255.255.240.0 gw 10.0.2.2
</programlisting>
Si vous êtes sur un portable et que vous changez de réseau local, mais que vous voulez quand même garder votre route actuelle vers
 <literal>98.76.54.32</literal>,
utilisez <command>getroute.pl</command> comme suit pour trouver automatiquement la bonne passerelle dans la commande <command>route add -host</command> :
<programlisting>
$(getroute.pl 98.76.54.32)
</programlisting>
Remarquez que si vous les avez dans votre <filename>/etc/hosts</filename>,
vous pouvez utiliser des noms symboliques au lieu des adresses IP numériques (et vous pouvez même utiliser des FQDN, si vous pensez que le DNS ne plante jamais).
</para>
</sect2>
</sect1>
<sect1>
<title>Perçage inverse</title>
<sect2>
<title>La logique</title>
<para>
Des fois, seul un côté du pare-feu peut lancer des sessions telnet vers l’autre côté, cependant, un moyen de communication est possible (en général par le courrier électronique). Percer un pare-feu est toujours possible, en déclenchant, grâce à n’importe quel moyen de transmission de messages disponible, une connexion telnet du «&nbsp;bon&nbsp;» côté du pare-feu vers l’autre côté.
</para>
<para>
<command>fwprc</command> inclut du code pour déclencher de telles connexions à partir d’un courriel authentifié par OpenPGP&nbsp;; il suffit d’ajouter
 <command>fwprc</command> comme filtre <command>procmail</command> aux messages utilisant ce protocole (instructions contenues dans
 <command>fwprc</command> lui-même). Remarquez cependant que si vous devez lancer <command>pppd</command>
avec les privilèges appropriés, il vous faudra peut-être créer votre propre suid wrapper pour devenir root. Instructions incluses dans
 <command>fwprc</command>.
</para>
<para>
En outre, déclenchement authentifié ne signifie absolument pas connexion sécurisée. Il faut vraiment utiliser <command>ssh</command> (peut être en plus de telnet) pour des connexions sécurisées. Et puis méfiez vous de ce qui se passe entre le déclenchement d’une connexion telnet, et le moment ou
 <command>ssh</command> prend en main cette connexion. Toute contribution à ce sujet sera la bienvenue.
</para>
</sect2>
<sect2>
<title>Obtenir le message de déclenchement</title>
<para>
Si vous êtes sous un pare-feu, votre messagerie peut tout-à-fait être dans un serveur de messagerie central qui ne fait pas de filtrage procmail ou qui n’autorise pas les sessions telnet. Aucun problème! Vous pouvez lancer
<command>fetchmail</command> en mode démon (ou comme tâche cron) pour interroger votre serveur de messagerie et distribuer le courrier à votre système linux qui, lui-même, aura été configuré pour utiliser <command>procmail</command>
à la réception. Remarquez que si vous lancez <command>fetchmail</command> comme démon en arrière plan, il bloquera tout autre fetchmail que vous voudriez simplement lancer à d’autres moments, comme lorsque vous ouvrez un
 <command>fwprc</command>;
bien entendu, si c’est possible, lancez également un démon fetchmail en tant qu’utilisateur bidon. Des scrutations trop fréquentes ne seront pas bonnes pour le serveur de messagerie ou pour l’hôte. Si elles sont trop peu fréquentes, vous devrez attendre avant que le message ne soit lu et que la connexion inverse soit établie. J’utilise une fréquence de scrutation de deux minutes.
</para>
</sect2>
<sect2>
<title>Autres outils automatiques pour le perçage inverse</title>
<para>
Un autre moyen d’interroger un serveur pour voir les messages, quand on n’a pas de boîte de messagerie, mais qu’on a bien un accès FTP vers l’extérieur, est d’utiliser un
<ulink url="http://dhirajbhuyan.hypermart.net/ftp-tunnel.html"
>tunnel FTP</ulink>.
</para>
<para>
Comme outil pour maintenir une connexion permanente entre un hôte sous pare-feu et un proxy externe, afin d’exporter des services depuis l’hôte vers l’extérieur, il y a le
 <ulink url="http://www.employees.org/~hek2000/projects/firewallTunnel/"> tunnel pare-feu</ulink>.
</para>
</sect2>
</sect1>
<sect1>
<title>Remarques finales</title>
<sect2>
<title>Autres réglages</title>
<para>

Je n’ai aucune idée sur la manière de percer des pare-feu avec des 
systèmes d’exploitation de niveau inférieur, mais vous pouvez prendre un 
de ces vieux ordinateurs hors d’usage (quasiment tout ce qui a 8 Mo de 
RAM et une carte ethernet devrait aller), y installer Linux ou BSD, et 
percer le pare-feu avec, tout en servant de routeur pour les autres 
machines fonctionnant avec des SE de niveau inférieur. Lisez les guides 
pratiques correspondants sur le routage, l’acheminement IP, NAT, etc.

</para>
<para>
Je ne connais pas les détails, mais il existe un outil prometteur pour percer les pare-feu &nbsp;: le <ulink url="http://www.r00t3d.org.uk/">Bouncer</ulink> de Chris Mason, qui joue le rôle de proxy SOCKS par-dessus SSL.
</para>
<para>
Il y a d’autres sortes de pare-feu que ceux qui autorisent les connexions ssh ou telnet directes. Tant qu’un flot continu de paquets peut transmettre des informations à travers un pare-feu dans les deux directions, il est possible de le percer&nbsp;; seulement, le prix pour écrire le perforateur peut être plus ou moins élevé.
</para>
<para>
Cela peut être très facile : ainsi, on a remarqué qu’il suffit de lancer
 <command>ssh</command> sur un maître pty et faire du <command>pppd</command> sur l’esclave tty. Si on le souhaite, on peut même le faire sans qu’il soit question de pare-feu, juste pour construire un VPN sécurisé (Virtual Private Network).
Le <ulink url="http://www.linuxdoc.org/HOWTO/mini/VPN.html"
>VPN mini-HOWTO</ulink>
donne tous les détails nécessaires à ce sujet. Comme exercice, nous vous invitons, à modifier <command>fwprc</command>
pour utiliser cette technique, ou peut-être même pour l’utiliser à l’intérieur d’une précédente session <command>fwprc</command> non sécurisée.
</para>
<para>
Maintenant si le seul chemin à travers le pare-feu est un proxy WWW (ce qui est habituellement un minimum pour un réseau connecté à internet), on pourra utiliser le script <ulink url="http://www.snurgle.org/~griffon/ssh-https-tunnel"
>ssh-https-tunnel</ulink> de 
 <ulink url="http://www.snurgle.org/~griffon/">Chris Chiappa</ulink>.
</para>
<para>
Autre programme prometteur pour percer à travers http &nbsp;: le <ulink url="http://www.nocrew.org/software/httptunnel/">httptunnel</ulink> de 
<ulink url="http://lars.nocrew.org/">Lars Brinkoff</ulink>,
une combinaison serveur et client http permettant une connexion TCP/IP par tunnel grâce au protocole http. On devrait ensuite pouvoir lancer
<command>fwprc</command>
(de préférence par-dessus <command>ssh</command>)
sur cette connexion, bien que je n’aie pas encore essayé. Quelqu’un pourrait-il tester et faire un rapport&nbsp;? Remarquez que 
<command>httptunnel</command> est toujours en cours de développement, vous pouvez donc aider à implémenter les fonctionnalités qui lui manquent actuellement, telles que les connexions multiples, et/ou servir des pages bidon pour leurrer les administrateurs méfiants de pare-feu excessivement hermétiques.
</para>
<para>
Quel que soit ce qui passe à travers votre pare-feu, que ce soit telnet, http ou autres connexions TCP/IP, ou des choses vraiment bizarres comme les requêtes DNS, les paquets ICMP, le courrier électronique (lisez
<ulink url="http://www.detached.net/mailtunnel/">mailtunnel</ulink>,
<ulink url="http://www.detached.net/icmptunnel/">icmptunnel</ulink>),
ou que sais-je encore, vous pouvez toujours écrire une combinaison tunnel client/serveur, et lancer un <command>ssh</command> et/ou une connexion PPP à travers celui-ci. La performance pourrait ne pas être très bonne, en fonction de la vitesse effective de communication de l’information après avoir payé les charges dûes au codage de l’ensemble des filtres et proxies, mais un tel tunnel est toujours intéressant tant qu’il peut au moins servir à utiliser
 <command>fetchmail</command>, <command>suck</command>,
et autres programmes non interactifs.
</para>
<para>
Si vous devez traverser une ligne 7 bits, vous devrez utiliser SLIP au lieu de PPP. Je n’ai jamais essayé, parce que les lignes sont plus ou moins 8 bits maintenant, mais ça ne devrait pas être difficile. Si nécessaire, rabattez vous sur le
<ulink url="http://www.linuxdoc.org/HOWTO/mini/Term-Firewall.html"
>Term-Firewall mini-HOWTO</ulink>.
</para>
<para>
Si vous avez une connexion 8 bits propre et que vous êtes root sur linux des deux côtés du pare-feu, vous pouvez utiliser ethertap pour de meilleures performances, en encapsulant des communications ethernet brutes en plus de votre connexion. David Madore a écrit sur les tunnels ethertap-sur-TCP et ethertap-sur-UDP
<ulink url="ftp://quatramaran.ens.fr/pub/madore/misc/"
>ftp://quatramaran.ens.fr/pub/madore/misc/</ulink>.
Il reste à traiter de ethertap-sur-tty pour combiner avec des outils comme fwprc.
</para>
<para>
Si vous cherchez une performance supérieure à celle obtenue en payant un tunnel à communication séquentielle, niveau espace utilisateur, à travers lequel lancer PPP, vous êtes dans la situation très difficile où vous devrez rebidouiller une drôle de pile IP, en utilisant (par exemple) les fonctions de type ‘functor’ des protocoles par paquets du projet Fox. Vous obtiendrez alors une IP sur HTTP, une IP sur DNS, une IP sur ICMP, ou autre, directe, qui requiert non seulement un protocole élaboré, mais également une interface vers un noyau de SE, qui sont tous deux chers à implémenter.
</para>
<para>
Pour finir, si vous n’êtes pas en train de vous battre contre un pare-feu excessivement hermétique, mais que vous faites juste votre propre VPN, il y a un large éventail d’outils VPN, et bien que les trucs que je présente soient simples, qu'ils fonctionnent bien, et qu'ils peuvent être suffisants pour vos besoins, ça serait peut-être pas mal de rechercher dans cette offre évolutive (dont je ne connais pas grand-chose) une solution qui correspond à vos besoins au niveau performance et maintenabilité.
</para>
</sect2>
<sect2>
<title>Le suivi de ce petit guide</title>
<para>

J'ai pensé qu’il était nécessaire de l’assurer, mais je n’ai pas 
beaucoup de temps pour ça, donc ce petit guide est très sommaire. Il va 
donc rester ainsi jusqu’à ce que j’obtienne assez de retours 
d’information pour savoir quelle section améliorer, ou mieux, jusqu’à ce 
que quelqu’un vienne se charger du suivi de ce petit guide. Tout retour 
d’information est le bienvenu. Toute aide est la bienvenue. La prise en 
charge du suivi du petit guide est la bienvenue.

</para>
<para>
En tout cas, les sections ci-dessus montrent que de nombreux problèmes peuvent être facilement résolus si quelqu’un (vous&nbsp;?) y consacre un peu de temps (ou d’argent, en engageant quelqu’un d’autre)&nbsp;; il n’y a qu’à s’asseoir et écrire&nbsp;: le concept n’est pas difficile, bien que, dans le détail, cela puisse ne pas être simple ou évident.
</para>
<para>
N’hésitez pas à proposer d’autres problèmes, et, espérons-le, d’autres solutions, pour ce petit guide.
</para>
</sect2>
<sect2>
<title>Documents sur le sujet</title>
<para>
Le <ulink url="http://www.linuxdoc.org/">LDP</ulink>
publie de nombreux documents en rapport avec ce
<ulink url="http://www.linuxdoc.org/HOWTO/HOWTO-INDEX/mini.html"
>petit guide</ulink>.
tout particulièrement 
<ulink url="http://www.securityportal.com/lskb/"
>Linux Security Knowledge Base</ulink>,
le <ulink url="http://www.linuxdoc.org/HOWTO/VPN.html">HOWTO VPN</ulink>
et le <ulink url="http://www.linuxdoc.org/HOWTO/mini/VPN.html"
>petit guide VPN</ulink>.
Pour des questions plus générales sur le réseau, le routage et les pare-feu, commencez avec le
 <ulink url="http://www.linuxdoc.org/HOWTO/Networking-Overview-HOWTO.html"
>Networking Overview HOWTO</ulink>.
Regardez également le
 <ulink url="http://www.linux-firewall-tools.com/linux/"
>Linux Firewall and Security site</ulink>.
</para>
<para>
Là encore, lorsque vous rencontrez un problème avec un programme, le réflexe pour tout utilisateur de Linux devrait être de Lire le Pstain [sic] de Manuel
 <ulink url="http://foldoc.doc.ic.ac.uk/foldoc/foldoc.cgi?RTFM"> [RTFM&nbsp;: Read The Fscking Manual]
 </ulink> sur les programmes en question.
 </para>
</sect2>
<sect2>
<title>Le mot de la fin</title>
<para>
Je suis arrivé à la conclusion que, de la même façon que le besoin en Design Patterns venait directement du fait que les gens utilisaient des langages inférieurs tels que le
 <productname>C++</productname> ou le <productname>Java</productname>
qui ne permettent pas d’exprimer directement des constructions de programmation de plus haut niveau (alors que de bons langages tels que le
 <productname>LISP</productname>
permettent de les exprimer), on peut dire que le besoin en guides 
pratiques vient directement du fait que les systèmes
 <productname>Linux</productname> et <productname>UNIX</productname> sont des systèmes d’exploitation inférieurs qui ne permettent pas d’exprimer directement les tâches que les gens essayent de faire avec, qui sont pourtant simples.
</para>
<para>

Si vous pensez que tout ce bidouillage de scripts stupides et de guides 
pratiques idiots est trop compliqué et qu’un système d’ordinateur 
convenable devrait nous automatiser tout ça, alors bienvenu au club des 
allergiques comme moi à UNIX (<ulink 
url="http://www.research.microsoft.com/~daniel/preface.html">UNIX 
haters</ulink>) et de ceux qui détestent les systèmes de bas niveau 
actuels, et aspirent à des systèmes informatiques déclaratifs qui 
prennent en charge tous les détails sans intérêt et nous laissent nous 
concentrer sur les choses importantes (jetez un œil, si ça vous dit, à 
mon propre projet <ulink url="http://tunes.org/">TUNES</ulink>).

</para>
</sect2>
<sect2>
<title> Copie supplémentaire de l’avis très important de non responsabilité &mdash; croyez le&nbsp;!!!</title>
<para>
<quote><emphasis> Par la présente je décline toute responsabilité quant à l’utilisation que vous ferez de cette méthode d'effraction [hack]. Si ça se retourne contre vous d’une manière ou d'une autre, c’est pas de pot. Et ce n’est pas ma faute. Si vous ne comprenez pas les risques encourus, laissez tomber. Si vous utilisez cette méthode et qu’elle permet à des vandales sans scrupules de pénétrer dans les ordinateurs de votre société et que ça vous coûte votre boulot et des millions d’euros à votre entreprise, eh bien c’est pas de pot. Ne venez pas pleurer chez moi.</emphasis>
</quote>
</para>
</sect2>
</sect1>
</article>

