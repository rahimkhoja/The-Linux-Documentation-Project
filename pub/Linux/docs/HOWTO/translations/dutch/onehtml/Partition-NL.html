<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Linux Partitie HOWTO</TITLE>


</HEAD>
<BODY>
<H1>Linux Partitie HOWTO</H1>

<H2>Kristan Koehntopp, kris@koehntopp.de,<BR>
Vertaald door Ellen Bokhorst, bokkie@nl.linux.org</H2>v2.4, 3 november 1997
<P><HR>
<EM>Deze Linux Mini-HOWTO leert je hoe diskruimte voor je Linux systeem te plannen en in te delen. Het gaat over disk hardware, partities, grootte
ramen van swap space en positioneringsoverwegingen. Bestandssystemen, bestandssysteemtypes en daaraan gerelateerde onderwerpen. De bedoeling is je wat achtergrondkennis bij
te brengen, geen procedures.</EM>
<HR>
<H2><A NAME="s1">1. Introductie</A></H2>

<H2>1.1 Wat is dit?</H2>

<P>
<P>Dit is een Linux Mini-HOWTO tekst. Een Mini-HOWTO is een beknopte tekst
die een aantal zaken in een leerprogramma-stijl uitlegt, 
en gerelateerd is aan installatie en beheer. Het is mini, omdat de tekst
of het onderwerp, dat erin wordt besproken, te klein is voor een echte
HOWTO of zelfs een boek.
Een HOWTO is geen referentie: daar zijn manual pages voor.
<H2>1.2 Wat staat er in? en gerelateerde HOWTO documenten</H2>

<P>
<P>Deze Mini-HOWTO leert je hoe diskruimte te plannen
en in te delen voor je Linux systeem. Het gaat over disk hardware,
partities, grootte ramen van swapspace en positioneringsoverwegingen,
bestandssystemen, bestandssysteemtypes en gerelateerde onderwerpen. 
De bedoeling is je wat achtergrondkennis bij te brengen. 
We bespreken in deze tekst hoofdzakelijk grondbeginselen en geen tools.
<P>Het beste zou je dit document kunnen lezen v&oacute;&oacute;r je eerste
installatie, maar dit is voor de meeste mensen wat lastig.
Beginnelingen hebben naast optimalisatie van de disk-indeling, nog 
andere problemen.
Dus waarschijnlijk ben je iemand die net een Linux installatie heeft
uitgevoerd en nu manieren aan het bedenken is, om deze installatie
te optimaliseren, of hoe je lastige miscalculaties in de
volgende installatie kan voorkomen. 
Ga er maar vanuit dat je je huidige installatie opnieuw wilt doen,
als je deze tekst gelezen hebt. :-)
<P>Deze Mini-HOWTO beperkt zichzelf de meeste tijd tot het plannen 
en indelen van diskruimte. Het bespreekt niet het gebruik van fdisk,
LILO, mke2fs of backup programma's. Er zijn andere HOWTO's die
deze problemen aanspreken. Bekijk alsjeblieft de Linux HOWTO Index voor
actuele informatie over Linux HOWTO's. Er staan ook instructies in de index
hoe je de HOWTO documenten kunt verkrijgen.
<P>Zie de "Linux Multiple Disks Layout mini-HOWTO", 
door Gjoen Stein &lt;gjoen@nyx.net&gt;
om te leren hoe je de diverse grootte en snelheidsvereisten
voor verschillende delen van het bestandsssysteem kunt ramen.
<P>Zie de "Linux Large Disk mini-HOWTO", door Andries Brouwer
&lt;aeb@cwi.nl&gt; voor instructies en overwegingen met betrekking tot disks
met meer dan 1024 cylinders.
<P>Zie de "Linux Quota mini-HOWTO" door Albert M.C. Tam
&lt;bertie@scn.org&gt;
voor instructies over het beperken van diskruimte per gebruiker
(quota's).
<P>Op dit moment is er geen algemeen document over diskbackup, maar
er zijn verscheidene documenten met verwijzingen naar specifieke
backup oplossingen.
Zie de "Linux ADSM Backup mini-HOWTO", door Thomas Koenig
&lt;Thomas.Koenig@ciw.uni-karlsruhe.de&gt; voor instructies over
het integreren van Linux in een IBM ADSM backup omgeving. Zie de
"Linux Backup with MSDOS mini-HOWTO", door Christopher Neufeld
&lt;neufeld@physics.utoronto.ca&gt; voor informatie over MS-DOS
bestuurde Linux backups.
<P>Zie de Linux HOWTO Index, door Tim Bynum &lt;linux-howto@sunsite.unc.edu&gt;
voor instructies over het schrijven en aanleveren van een HOWTO document.
<P>Bladeren door /usr/src/linux/Documentation kan ook erg leerzaam zijn.
Zie ide.txt en scsi.txt voor wat achtergrondinformatie
over de kenmerken van je diskdrivers en kijk eens in de
filesystems/ subdirectory.
<H2><A NAME="s2">2. Wat is een partitie eigenlijk?</A></H2>

<P>Toen PC harddisks werden uitgevonden, wilden mensen al spoedig
meerdere besturingssystemen installeren, ook al had hun
systeem maar &eacute;&eacute;n disk.
Dus er was een mechanisme nodig om een enkele fysieke disk
in meerdere logische disks in te delen.
Dus dat is wat een partitie is: Een opeenvolgend gedeelte
van je harddisk die door de meeste besturingssystemen als 
een complete afzonderlijke disk wordt behandeld.
<P>Het is tamelijk duidelijk dat partities elkaar niet moeten overlappen: Een
besturingssysteem zal er beslist niet blij mee zijn, als een ander
ge&iuml;nstalleerd besturingssysteem op dezelfde machine belangrijke
informatie zou overschrijven vanwege overlappende partities.
Er zou ook geen gat tussen aangrenzende partities moeten zitten.
Ondanks dat deze constellatie niet schadelijk is, verspil je kostbare 
diskruimte door ruimte tussen partities te laten.
<P>Een disk hoeft niet volledig gepartitioneerd te zijn.
Het kan zijn dat je besluit om wat ruimte aan het einde
van je disk te laten die nog niet aan &eacute;&eacute;n van je 
ge&iuml;nstalleerde besturingssystemen is toegewezen.
Als het je later duidelijk is welke installatie de meeste tijd
wordt gebruikt, kun je deze overgebleven ruimte partitioneren en
er een bestandssysteem op plaatsen.
<P>Partities kunnen niet worden verplaatst, noch kan de
grootte worden gewijzigd zonder
dat je het bestandssysteem wat zich erop bevindt, wordt verwijderd.
Dus het herpartitioneren brengt gewoonlijk het backuppen en
herstellen van alle, tijdens het herpartitioneren,
betrokken bestandssystemen met zich mee. 
In feite is het tamelijk gewoon gedurende het herpartitioneren zaken compleet
te verknoeien, dus je zou van alles op iedere disk op die machine 
een backup moeten maken voordat je zelfs ook maar aan zoiets als 
<CODE>fdisk</CODE> komt.
<P>Een aantal partities met daarop bepaalde bestandssysteemtypes
<EM>kunnen</EM> in werkelijkheid in twee&euml;n worden gesplitst zonder
gegevens te verliezen (als je geluk hebt).
Er is bijvoorbeeld een programma met de naam "fips" voor het in twee&euml;n
splitsen van MS-DOS partities voor een Linux installatie, zonder dat
MS-DOS opnieuw moet worden ge&iuml;stalleerd.
Je raakt deze dingen toch niet aan zonder alles op deze machine zorgvuldig
te backuppen, nietwaar?
<H2>2.1 Backups zijn belangrijk</H2>

<P>Tapes zijn je vriend voor backups. Ze zijn snel, betrouwbaar en
gemakkelijk te gebruiken, dus je kunt vaak backups maken, bij voorkeur
automatisch en zonder gedoe.
<P>En ik heb het over echte, niet die
disk controller bestuurde ftape troep. Overweeg het kopen van SCSI: Linux
ondersteunt intern SCSI. Je hoeft geen ASPI
drivers te laden, je verliest geen kostbare HMA onder Linux en 
zodra de SCSI hostadapter &eacute;&eacute;nmaal is ge&iuml;nstalleerd,
sluit je er gewoon extra disks, tapes en CD-ROM's op aan. 
Geen I/O adressen meer, IRQ
gegoochel met Master/Slave en PIO-level overeenstemming. 
<P>Plus: Goede SCSI-hostadapters geven je een hoge I/O performance
zonder veel CPU load. Zelfs onder zware diskactiviteit zul je
goede responsetijden ervaren. Als je van plan bent om
je Linux-systeem hoofdzakelijk als USENET nieuwstoevoer te gebruiken of 
als je op het punt staat in ISP-bedrijf te gaan, denk er dan zelfs 
niet aan om een systeem zonder SCSI neer te zetten.
<H2>2.2 Nummers en namen van apparaten</H2>

<P>Het aantal partities op een systeem gebaseerd op Intel was
vanaf het allereerste begin beperkt.
De originele partitietabel werd ge&iuml;nstalleerd als onderdeel van de
bootsector en gaf ruimte voor slechts vier partitie-ingangen.
Deze partities worden nu primaire partities genoemd.
Toen het duidelijk werd dat mensen meer partities op hun
systemen nodig hadden, werden de logische partities uitgevonden.
Het aantal logische partities is niet beperkt: Iedere logische partitie
bevat een verwijzing naar de volgende logische partitie,
dus je kunt een mogelijk ongelimiteerde reeks partitie-ingangen
hebben.
<P>Om compatibiliteits redenen, moest de ruimte die door alle
logische partities in beslag werd genomen, worden verantwoord.
Als je logische partities gebruikt, wordt &eacute;&eacute;n partitie
als "uitgebreide partitie" gemarkeerd, en het begin- en eindblok markeren
het gebied dat door de logische partities in beslag wordt genomen.
Dit impliceert dat de ruimte die aan alle logische partities is 
toegekend, aaneengesloten moet zijn. 
Er kan slechts &eacute;&eacute;n uitgebreide partitie voorkomen:
geen enkel <CODE>fdisk</CODE> programma zal meer dan &eacute;&eacute;n
uitgebreide partitie aanmaken.
<P>Linux kan niet meer dan een beperkt aantal partities per drive
beheren. Dus als je in Linux 4 primaire partities hebt (zijn 3 daarvan
te gebruiken, als je gebruik maakt van logische partities) en
alles bij elkaar maximaal 15 partities op een SCSI disk 
(alles bij elkaar 63 op een IDE disk).
<P>Onder Linux worden partities voorgesteld door apparaatbestanden. Een 
apparaatbestand is een bestand met type c (voor "character" apparaten, 
apparaten die geen buffercache gebruiken) of b (voor "blok" apparaten,
die door de buffercache gaan). Onder Linux worden alle disks alleen 
voorgesteld als blokapparaten.
In tegenstelling tot Unices, biedt Linux geen "raw" character 
versies van disks en de partities daarop.
<P>Het enige belangrijke aan een apparaatbestand zijn z'n major en
minor devicenummers, die in plaats van de bestandsgroottes worden
getoond:
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
$ ls -l /dev/hda
brw-rw----   1 root     disk       3,   0 Jul 18  1994 /dev/hda
                                   ^    ^
                                   |    minor devicenummer
                                   major device nummer
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>Bij het benaderen van een apparaatbestand,
selecteert het major nummer welke driver wordt aangeroepen
om de input/output bewerking uit te voeren.
Deze aanroep wordt gedaan met het secundaire nummer als een parameter
en het is helemaal aan de driver hoe het secundaire
nummer wordt ge&iuml;nterpreteerd. De driver-documentatie beschrijft
gewoonlijk hoe de driver secundaire nummers gebruikt. Voor IDE disks,
staat deze documentatie in <CODE>/usr/src/linux/Documentation/ide.txt</CODE>.
Voor SCSI disks, zou je dergelijke documentatie verwachten in
<CODE>/usr/src/linux/Documentation/scsi.txt</CODE>, maar daar staat het niet. 
Men moet bij de source van de driver kijken om zeker te zijn
(<CODE>/usr/src/linux/driver/scsi/sd.c:184-196</CODE>). Gelukkig bestaat er
de lijst met devicenummers en namen van Peter Anvin in
<CODE>/usr/src/linux/Documentation/devices.txt</CODE>; zie de ingangen voor
blokapparaten, major 3, 22, 33, 34 voor IDE en major 8 voor SCSI
disks. De major en minor nummers zijn ieder een byte groot en
daarom is het aantal partities per disk beperkt.
<P>Volgens afspraak hebben apparaatbestanden bepaalde namen en veel
systeemprogramma's hebben de kennis over deze namen ingecompileerd. Ze
verwachten dat je IDE disks <CODE>/dev/hd*</CODE> zijn genoemd en je SCSI disks
<CODE>/dev/sd*</CODE>. Disks zijn genummerd a, b, c en zo verder, dus
<CODE>/dev/hda</CODE> is je eerste IDE disk en <CODE>/dev/sda</CODE> is je eerste SCSI
disk. Beide devices stellen gehele disks voor, beginnend op blok
&eacute;&eacute;n. Met de verkeerde tools naar deze tools schrijven zal
de masterbootloader en partitietabel op deze disks ru&iuml;neren,
onbruikbare weergave van alle gegevens op de disk of je systeem onopstartbaar
maken. Weet wat je doet en, nogmaals, maak een backup voordat je
het doet.
<P>Primaire partities op een disk zijn 1, 2, 3 en 4. Dus <CODE>/dev/hda1</CODE> is
de eerste primaire partitie op de eerste IDE disk en zo verder.
Logische partities hebben de nummers 5 en hoger, dus <CODE>/dev/sdb5</CODE> is de
eerste logische partitie op de tweede SCSI disk.
<P>Aan iedere partitie-ingang is een begin- en een eind-blokadres 
en een type toegewezen.
Het type is een numerieke code (een
byte) die een bepaalde partitie aan een bepaald type besturingssysteem
toewijst. Ten bate van computeradviseurs zijn
partitie type codes niet echt uniek, dus er is altijd
een kans dat twee besturingssystemen dezelfde code gebruiken.
<P>Linux reserveert het type code 0x82 voor swappartities en
0x83 voor "native" bestandssystemen (dat is ext2 voor de meeste van jullie).
Het ooit populaire, nu verouderde Linux/Minix bestandssysteem gebruikte het
type code 0x81 voor partities. OS/2 markeert zijn partities met
een 0x07 type en dit doet NTFS van Windows NT ook. MS-DOS neemt
verscheidene type codes in beslag voor z'n diverse soorten 
FAT bestandssystemen:
0x01, 0x04 en 0x06 zijn bekend. DR-DOS gebruikte 0x81 om
beschermde FAT partities aan te geven, daarmee in die tijd een
conflict genererend met Linux/Minix, 
maar noch Linux/Minix noch DR-DOS worden nog veel gebruikt.
Tussen twee haakjes, de uitgebreide partitie 
die als een container voor logische partities wordt gebruikt, 
is van het type 0x05.
<P>Partities worden aangemaakt en verwijderd met het <CODE>fdisk</CODE>
programma. Ieder zelfrespecterend besturingssysteem komt met een
<CODE>fdisk</CODE> en wordt traditioneel onder bijna alle Os'sen
zelfs <CODE>fdisk</CODE> genoemd (of <CODE>FDISK.EXE</CODE>) 
Sommige <CODE>fdisk</CODE>s, merkbaar die van DOS, zijn op &eacute;&eacute;n 
of andere manier beperkt als ze met partitities van
andere besturingssystemen om moeten gaan. 
Een van dergelijke beperkingen is de complete
onmogelijkheid om te gaan met alles met een type code van een
ander bestandssysteem, de onmogelijkheid om te gaan met 
cylinder nummers boven 1024 en de onmogelijkheid partities aan te maken of zelfs
te begrijpen die niet op een cylinder begrenzing eindigen. 
Bijvoorbeeld, de MS-DOS fdisk kan geen
NTFS partities verwijderen, van de OS/2 fdisk is bekend dat ze in stilte
door Linux aangemaakte partities "corrigeerde" als ze
niet eindigden op een cylinder begrenzing en zowel, de DOS en de
OS/2 fdisk, hadden problemen met disks met meer dan 1024
cylinders (zie de "large-disk" Mini-Howto voor details over
dergelijke disks).
<H2><A NAME="s3">3. Wat voor Partities heb ik nodig</A></H2>

<H2>3.1 Hoeveel partities heb ik nodig?</H2>

<P>
<P>Oke, dus welke partities heb je nodig? Goed, een aantal 
besturingssystemen geloven niet in het booten vanaf logische
partities om volstrekt onbegrijpelijke redenen. 
Dus je wilt waarschijnlijke je primaire partities reserveren
als bootpartities voor je MS-DOS, OS/2 en Linux of wat je ook
gebruikt. Denk eraan dat &eacute;&eacute;n partitie benodigd is
voor een uitgebreide partitie, die als een container optreedt voor
de rest van je disk met logische partities.
<P>Het booten van besturingssystemen is een real-mode aangelegenheid die
BIOS'sen en 1024 cylinder beperkingen met zich meebrengt.
Dus je wilt waarschijnlijk al je bootpartities in de eerste 1024 
cylinders van je harddisk plaatsen,
gewoon om problemen te voorkomen. Nogmaals, lees de "large-disk"
Mini-Howto voor de bloedige details.
<P>Om Linux te installeren heb je op z'n minst &eacute;&eacute;n
partitie nodig. Als de kernel vanaf deze partitie wordt geladen
(bijvoorbeeld door LILO), moet deze partitie leesbaar zijn door
je BIOS.
Als je andere mogelijkheden gebruikt om je kernel te laden
(bijvoorbeeld een opstartdiskette of  
LOADLIN.EXE, een op MS-DOS gebaseerde Linux loader) 
kan de partitie zich overal bevinden.
In ieder geval zal deze partitie van het type 0x83
"Linux native" zijn.
<P>Je systeem zal wat swapspace nodig hebben. Tenzij je naar
bestanden swapt, zul je een hiervoor toegewezen swappartitie
nodig hebben. Aangezien deze partitie alleen door de Linux kernel wordt
benaderd en de Linux kernel niet aan PC BIOS ontoereikendheden
leidt, kan de swap partitie overal worden gepositioneerd. 
Ik raad je aan er een logische partitie
voor te gebruiken (/dev/?d?5 en hoger). Toegewezen Linux swap
partities zijn van het type 0x82 "Linux swap".
<P>Dit zijn minimale partitie vereisten.
Het zou handig kunnen zijn om meer partities voor
Linux aan te maken. Lees verder.
<H2>3.2 Hoe groot zou mijn swapspace moeten zijn?</H2>

<P>Als je hebt besloten om een toegewezen swap partitie te gebruiken,
wat in het algemeen een Goed Idee [tm] is, volg dan deze
richtlijnen voor het ramen van z'n grootte:
<P>
<UL>
<LI> Onder Linux worden RAM en swap space bijelkaar opgeteld 
(Dit geldt niet voor alle
Unices). Als je bijvoorbeeld 8 MB RAM en 12 MB swap hebt, heb je
een totale hoeveelheid van ongeveer 20 MB virtueel geheugen.</LI>
<LI> Wanneer je je swap space passend maakt, zou je in totaal op z'n minst
16 MB virtueel geheugen moeten hebben.
Neem dus voor 4 MB RAM tenminste 12 MB swap in overweging, voor 8 MB RAM,
12 MB swap, neem voor 8 MB RAM op z'n minst 8 MB swap in overweging.</LI>
<LI> Onder Linux, kan een enkele swappartitie niet groter zijn dan 128
MB.  Dat wil zeggen, de partitie kan wel groter zijn dan 128 MB, maar
de toegankelijke ruimte wordt nooit gebruikt.
Als je meer dan 128 MB swap wilt, zul je meerdere swap-partities aan
moeten maken.</LI>
<LI> Als je de grootte van swap space bepaalt, houd dan in gedachten
dat te veel swapspace helemaal niet handig kan zijn.

Ieder proces heeft een "werkset". Dit is een set van pagina's in
het geheugen waarnaar in de zeer nabije toekomst door de processor
zal worden gerefereerd.
Linux probeert deze geheugentoegangen te voorspellen
(ervan uitgaande dat recent gebruikte pagina's in de nabije toekomst 
opnieuw zullen worden gebruikt)
en houdt deze pagina's zo mogelijk in RAM. Als het programma
een goede "referentie-ligging" heeft, zal deze voorspelling kloppen
en het voorspellings algoritme zal werken.

Het in het hoofdgeheugen houden van een werkset, werkt alleen als 
er voldoende hoofdgeheugen is.
Als je te veel processen op een machine hebt draaien,
wordt de kernel gedwongen om pagina's op disk te plaatsen waarnaar het
opnieuw in de zeer nabije toekomst zal refereren (waarbij een pagina
gedwongen uit een andere werkset uit het geheugen wordt gehaald
en vervolgens de pagina waarnaar werd gerefereerd in het geheugen
wordt geladen). Gewoonlijk resulteert dit in een
zeer zware verhoging van paging activiteit en in een aanzienlijke
performance vermindering. Van een machine in deze staat wordt gezegd dat
er "overhead" is. (Voor jullie duitse lezers: Dat is "thrashing"
("dreschen", "schlagen", "haemmern") en niet vermorzelen
("muellen")).

Op een machine met overhead draaien de processen in wezen
vanaf disk en niet vanuit RAM. Ga er maar vanuit dat de performance
zal verminderen met bij benadering de verhouding tussen de 
toegangssnelheid van het geheugen en de toegangssnelheid van de disk.

Een erg oude praktische methode in de dagen van de PDP en de Vax
was, dat de grootte van de werkset van een programma uit ongeveer
25% van zijn feitelijke grootte bestaat. Dus het is waarschijnlijk nutteloos
om in meer swap te voorzien dan drie maal je RAM.

Maar houd in gedachten dat dit slechts een praktische methode is. Het is 
makkelijk mogelijk om scenario's te cre&eacute;ren waarin programma's extreem
grote of extreem kleine werksets hebben. Bijvoorbeeld,
een simulatie programma met een grote gegevensset die op een zeer
willekeurige wijze wordt benaderd, zou bijna geen opmerkelijke 
referentie-ligging in z'n datasegment kunnen hebben,
dus zijn werkset zou nogal groot kunnen zijn.

Aan de andere kant, een xv met veel simultaan geopende
JPEG's, alle behalve &eacute;&eacute;n tot ikoon verkleind, 
zou een zeer groot datasegment kunnen hebben.
Maar afbeeldingtransformaties worden slechts uitgevoerd op &eacute;&eacute;n
enkele afbeelding, het meeste geheugen dat door xv in beslag wordt genomen 
wordt nooit aangeroerd.
Hetzelfde geldt voor een editor met veel editor vensters waar
slechts &eacute;&eacute;n venster tegelijk wordt gewijzigd.   
Deze programma's hebben - als ze op de juiste wijze zijn ontworpen 
- een zeer hoge referentie-ligging - en grote delen ervan kunnen
op disk worden geplaatst zonder een te hevige performance uitwerking.

Men zou kunnen verwachten dat het 25% nummer vanwege de ouderdom
van de commando-regel niet langer geldt voor moderne GUI programma's
die meerdere documenten wijzigen, maar ik ken geen nieuwere stukken
die deze nummers proberen te verifi&euml;ren.</LI>
</UL>
<P>Dus voor een configuratie met 16 MB RAM, is geen swap nodig
voor een minimale configuratie en meer dan 48 MB swap is
waarschijnlijk nutteloos.
De exacte hoeveelheid geheugen hangt af van de mix aan applicaties 
op de machine (wat verwachtte je anders?).
<H2>3.3 Waar zou ik mijn swapspace moeten plaatsen?</H2>

<P>
<P>
<UL>
<LI> Mechanica is langzaam, elektronica is snel.

Moderne harddisks hebben veel koppen. Het schakelen tussen koppen van
hetzelfde spoor gaat snel, aangezien het zuiver elektronisch is.
Schakelen tussen sporen gaat langzaam, aangezien het verplaatsen
op een totaal andere wijze plaatsvindt.

Dus als je een disk met veel koppen hebt en &eacute;&eacute;n met 
minder koppen en beide zijn identiek in andere parameters, zal de disk
met de vele koppen sneller zijn.

Het splitsen van de swap en het op beide disks plaatsen zal echter 
zelfs sneller zijn.</LI>
<LI> Oudere disks hebben eenzelfde aantal sectoren op alle sporen.
Bij deze disks zal het het snelste zijn als je je swap in het midden
van de disks plaatst, ervan uitgaande dat de kop van je disk
zich zal verplaatsen vanaf een willekeurig spoor richting het swapgebied.</LI>
<LI> Nieuwere disks gebruiken ZBR (zone bit recording). Ze hebben op
de buitenste sporen meer sectoren.
Met een constant aantal rpms, levert dit een veel
grotere performance op, op de buitenste sporen
dan op de binnenste. Plaats je swap op de snelste sporen.</LI>
<LI> Natuurlijk zal je diskkop niet willekeurig verplaatsen. Als je
swap space in het midden van een disk hebt tussen een constant drukke
home partitie en een bijna ongebruikte archief partitie, zou je
beter af zijn als je swap zich in het midden van de
home partitie bevond voor nog kortere kop-bewegingen.
Je zou echter zelfs nog beter af zijn,
als je swap zich op een andere ongebruikte disk bevond.</LI>
</UL>
<P><B>Samenvatting:</B> Plaats je swap op een snelle disk met veel koppen die het
niet druk heeft met andere zaken. Als je meerdere disks hebt: Splits
swap en verspreid het over al je disks of zelfs verschillende
controllers.
<P><B>Zelfs beter:</B> Koop meer RAM.
<H2>3.4 Een aantal feiten over bestandsssytemen en fragmentatie</H2>

<P>
<P>Diskruimte wordt door het besturingssysteem in eenheden
blokken en fragmenten blokken beheerd. In ext2 moeten fragmenten en blokken
even groot zijn, dus we kunnen deze verhandeling tot blokken
beperken.
<P>Bestanden zijn er in elke grootte. 
Ze eindigen niet op blokgrenzen.
Dus met ieder bestand wordt een
deel van het laatste blok van ieder bestand verspild.
Ervan uitgaande dat de grootte van bestanden willekeurig is, wordt er
bij benadering een half blok verspild voor ieder bestand op je disk.
Tanenbaum noemt dit "interne fragmentatie" in zijn boek
"Operating Systems".
<P>Je kunt het aantal bestanden op je disk raden door het aantal
in beslag genomen inodes op een disk.
Op mijn disk
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
# df -i
Filesystem           Inodes   IUsed   IFree  %IUsed Mounted on
/dev/hda3              64256   12234   52022    19%  /
/dev/hda5              96000   43058   52942    45%  /var
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>bevinden zich ongeveer 12000 bestanden op <CODE>/</CODE> en ongeveer 44000 
bestanden op <CODE>/var</CODE>.
Bij een blokgrootte van 1 KB, gaat ongeveer 6+22 = 28 MB diskruimte
verloren in de laatste blokken van bestanden.
Als ik een blokgrootte van 4 KB had uitgekozen, 
had ik 4 keer zoveel ruimte verloren.
<P>Gegevenstransport is echter sneller voor grote aaneengesloten blokken
gegevens. Daarom probeert ext2 ruimte in eenheden van 8 aaneengesloten blokken 
vooraf toe te wijzen aan groeiende bestanden.
De ongebruikte vooraf toegewezen ruimte wordt vrijgegeven als het 
bestand wordt gesloten, dus er wordt geen ruimte verspild.
<P>Het dwingt het besturingssysteem de toegang naar een disk te splitsen
en de disk om de kop te verplaatsen.
Dit wordt "externe fragmentatie" genoemd of eenvoudigweg 
"fragmentatie" en het is een algemeen probleem met DOS bestandssystemen.
<P>ext2 heeft verscheidene strategien om externe fragmentatie te
voorkomen.
Normale fragmentatie is in ext2 geen groot probleem, zelfs niet
op zwaar gebruikte partities zoals een USENET nieuwsspool. Ondanks
dat er een tool voor defragmentatie is voor ext2 bestandssystemen, 
gebruikt niemand het ooit en het is niet bijgewerkt met de huidige
release van ext2. Gebruik het op eigen risico.
<P>Het MS-DOS bestandssysteem is goed bekend om z'n pathologische
beheer van diskruimte. In samenwerking met de bodemloze buffer
cache die door MS-DOS wordt gebruikt, zijn de effecten van bestandsfragmentatie
op de performance zeer opmerkelijk.
DOS gebruikers zijn gewend aan het
iedere paar weken defragmenteren van hun disks en een aantal hebben
zelfs een ritueel geloof met betrekking tot defragmentatie ontwikkeld.
Geen van deze gewoonten zou naar Linux en ext2 moeten worden
overgedragen. Linux native bestandssystemen hoeven niet te
worden gedefragmenteerd bij normaal gebruik en dit behelst iedere
voorwaarde met tenminste 5% vrije ruimte op een disk. 
<P>Het MS-DOS bestandssysteem is ook bekend om het verlies van
grote hoeveelheden diskruimte te wijten aan interne fragmentatie. 
Voor partities groter dan 256 MB, wordt de DOS blokgrootte zo groot 
dat ze niet langer bruikbaar zijn
(Dit is tot op zekere hoogte gecorrigeerd met FAT32).
<P>ext2 dwingt je niet om grote blokken voor grote bestandssystemen te
kiezen, behalve voor zeer grote bestandssystemen in de range 0.5 TB
(dat is terabytes waarbij 1 TB gelijk is aan 1024 GB) en daarboven, waar 
kleine blokgroottes inefficient worden. Dus in tegenstelling tot DOS
is het niet nodig om grote disks in meerdere partities onder te verdelen
om de blokgrootte laag te houden.
Gebruik zo mogelijk de 1 KB standaard blokgrootte. 
Voor een aantal partities zou het kunnen dat je met een
2 KB blokgrootte wilt experimenteren, maar ga er maar vanuit
een aantal zelden in acht genomen bugs tegen te komen: 
De meeste mensen gebruiken de standaardwaarde.
<H2>3.5 Levensduur van bestanden en backupcycli als criteria bij partitioneren</H2>

<P>
<P>Met ext2, zouden partitionerings beslissingen moeten worden geleid door
backup overwegingen en om externe fragmentatie door de 
verschillende levensduur van bestanden te voorkomen.
<P>Bestanden hebben een levensduur. Nadat een bestand is aangemaakt, zal het
een tijd op het systeem blijven bestaan en vervolgens worden
verwijderd. De levensduur van een bestand varieert nogal op het systeem
en is gedeeltelijk afhankelijk van de padnaam van het bestand.
Bijvoorbeeld, bestanden in
<CODE>/bin</CODE>, <CODE>/sbin</CODE>, <CODE>/usr/sbin</CODE>, <CODE>/usr/bin</CODE> en vergelijkbare
directory's zullen waarschijnlijk een zeer lange levensduur hebben: 
vele maanden en meer.
Bestanden in <CODE>/home</CODE> zullen vermoedelijk een gemiddelde levensduur
hebben: verscheidene weken of zoiets.
Bestanden in <CODE>/var</CODE> bestaan gewoonlijk maar kort: Bijna geen
enkel bestand in <CODE>/var/spool/news</CODE> zal langer dan een paar dagen
behouden blijven, bestanden in <CODE>/var/spool/lpd</CODE> meten hun levensduur
in minuten of minder.
<P>Voor het backuppen is het handig als de hoeveelheid dagelijkse backup
kleiner is dan de capaciteit van een enkel backup medium. Een dagelijkse
backup kan een complete backup of een incrementele backup zijn.
<P>Je kunt besluiten om je partitiegroottes klein genoeg te houden
zodanig dat ze volledig op een backupmedium passen
(kies dagelijks volledige backups). 
In ieder geval zou een partitie klein genoeg moeten zijn dat
z'n dagelijkse delta (alle gewijzigde bestanden) op &eacute;&eacute;n
backupmedium passen.
(kies voor incrementele backup en ga er maar vanuit de backup
media voor de wekelijkse/maandelijkse volledige dump te moeten wisselen - 
geen onbeheerde bewerking mogelijk).
<P>Je backupstrategie hangt af van die beslissing.
<P>Als je diskruimte koopt, denk er dan aan voldoende
geld voor backup op zij te leggen.
Niet gebackupte gegevens zijn waardeloos! 
De kosten van reproduceren van gegevens zijn voor eigenlijk iedereen
veel hoger dan de backupkosten!
<P>Voor performance is het handig om bestanden met verschillende
levensduur op verschillende partities te houden.
Op deze manier kan het zijn dat de kort bestaande bestanden
op de nieuws-partitie heel erg kunnen zijn gefragmenteerd.
Dit heeft geen impact op de performance van de <CODE>/</CODE> of <CODE>/home</CODE>
partitie.
<H2><A NAME="s4">4. Een voorbeeld</A></H2>

<H2>4.1 Een aanbevolen model voor ambitieuze beginners</H2>

<P>
<P>Een algemeen model maakt <CODE>/</CODE>, <CODE>/home</CODE> en <CODE>/var</CODE>
partities aan zoals hierboven beschreven. Dit is eenvoudig te installeren en
beheren en maakt goed genoeg onderscheid om ongunstige
effecten van verschillende levensduur te voorkomen. Het past ook goed
in een backupmodel:
Bijna niemand bekommert zich om een backup te maken van een USENET newspool
en slechts een aantal bestanden in <CODE>/var</CODE> zijn het waard om te backuppen
(ik denk nu aan <CODE>/var/spool/mail</CODE>). Aan de andere kant,
<CODE>/</CODE> wijzigt niet vaak en hier kan naar behoefte een backup van worden
gemaakt (na configuratie wijzingen) en is klein genoeg om op de
meeste moderne backupmedia als een volledige backup te passen
(reken op 250 tot 500 MB afhankelijk van de hoeveelheid ge&iuml;nstalleerde
software). <CODE>/home</CODE>
bevat waardevolle gebruikersgegevens en hier zou dagelijks een backup van
moeten worden gemaakt.
Een aantal installaties hebben zeer grote <CODE>/home</CODE>s en moeten
incrementele backups gebruiken.
<P>Een aantal systemen plaatsen <CODE>/tmp</CODE> ook op een aparte partitie, anderen
maken een symlink aan naar <CODE>/var/tmp</CODE> om hetzelfde effect te bereiken 
(merk op dat dit effect kan hebben op single user mode, 
waarin <CODE>/var</CODE> niet beschikbaar zal zijn
en het systeem geen <CODE>/tmp</CODE> zal hebben, totdat je een
<CODE>/var</CODE> handmatig mount of aanmaakt) of zet het op een RAM disk (Solaris
doet dit bijvoorbeeld). Dit houdt <CODE>/tmp</CODE> buiten <CODE>/</CODE>, een goed idee.
<P>Dit model is geschikt voor upgrades als ook herinstallatie:
Bewaar je configuratiebestanden (of de gehele <CODE>/etc</CODE>) in
een <CODE>/home</CODE> directory, zet je <CODE>/</CODE> aan de kant, herinstalleer en
haal de oude configuraties vanuit de opgeslagen directory in <CODE>/home</CODE> op.
<H2><A NAME="s5">5. Hoe ik het deed op mijn machine</A></H2>

<P>
<P>Daar stond deze oude ISA bus 386/40 op mijn boekenplank die ik
twee jaar geleden had weggedaan omdat hij niet langer voldeed. Ik was
van plan het om te zetten in een kleine X-loze server voor mijn Lan
thuis.
<P>Zo deed ik het: Ik pakte die 386 en plaatste er 16 MB RAM in.
Voegde een goedkope EIDE disk toe, de kleinste die ik kon krijgen (800 MB) en
een ethernetkaart. Voegde een oude Hercules toe  omdat ik er nog steeds
een monitor voor had. Installeerde Linux erop en daar 
had ik mijn lokale NFS, SMB, HTTP, LPD/LPR en NNTP server als ook mijn 
mailrouter en POP3 server. Met een extra ISDN kaart werd de machine 
mijn TCP/IP router en ook firewall.
<P>De meeste diskruimte op deze machine ging naar de
<CODE>/var</CODE> directory's, <CODE>/var/spool/mail</CODE>, <CODE>/var/spool/news</CODE> en
<CODE>/var/httpd/html</CODE>. Ik plaatste <CODE>/var</CODE> op een aparte partitie en maakte
deze wat groter. Er zullen bijna geen gebruikers op deze machine zijn, dus
ik maakte geen home-partitie aan en mountte
<CODE>/home</CODE> vanuit een ander werkstation via NFS.
<P>Linux zonder X plus verscheidene lokaal ge&iuml;nstalleerde utility's
zal goed gaan met een 250 MB partitie als <CODE>/</CODE>. De machine heeft 16 MB 
RAM, maar het zal veel servers gaan draaien. 16 MB swap zou toereikend moeten
zijn, 32 MB zou ruim voldoende moeten zijn. We hebben geen tekort aan
diskruimte, dus de machine zal 32 MB krijgen. Uit sentimentaliteit blijft er
een MS-DOS partitie van pakweg 20 MB op behouden. Ik besloot 
<CODE>/home</CODE> vanaf een andere machine te importeren, dus de resterende 500+ MB
zal <CODE>/var</CODE> worden. Dit is meer dan genoeg voor een
USENET nieuwstoevoer voor thuisgebruik.
<P>We krijgen
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
Device     Gemount op                       Grootte
/dev/hda1  /dos_c                           25 MB
/dev/hda2  - (Swapspace)                    32 MB
/dev/hda3  /                               250 MB
/dev/hda4  - (Extended Container)          500 MB
/dev/hda5  /var                            500 MB

homeserver:/home /home                     1.6 GB
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>Ik maak een backup van deze machine via het netwerk met gebruik van de tape
in <CODE>homeserver</CODE>. Aangezien alles op deze machine vanaf CD-ROM
is ge&iuml;nstalleerd hoef ik alleen een aantal
configuratie bestanden van <CODE>/etc</CODE>, mijn aangepaste lokaal
ge&iuml;nstalleerde *.tgz bestanden van <CODE>/root/Source/Installed</CODE> en
<CODE>/var/spool/mail</CODE> als ook <CODE>/var/httpd/html</CODE> te bewaren. Ik kopieer
deze bestanden iedere nacht naar een toegewezen directory 
<CODE>/home/backmeup</CODE> op <CODE>homeserver</CODE>, vanwaar de 
reguliere homeserver-backup ze ophaalt.
</BODY>
</HTML>
