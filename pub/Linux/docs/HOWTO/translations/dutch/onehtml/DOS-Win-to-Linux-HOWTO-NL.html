<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Van DOS/Windows naar Linux HOWTO</TITLE>


</HEAD>
<BODY>
<H1>Van DOS/Windows naar Linux HOWTO</H1>

<H2>Door Guido Gonzato, <CODE>ggonza at tin.it</CODE>,<BR>
Vertaald door: Ellen Bokhorst <CODE>bokkie at nl.linux.org</CODE></H2> Versie 1.3.5. 31 augustus 2000
<P><HR>
<EM>Deze HOWTO is opgedragen aan alle (spoedig voormalige?) DOS en Windows
gebruikers die besloten hebben naar Linux, de vrije UNIX-kloon, over te
stappen. Het doel van dit document is de lezer te helpen zijn of haar
kennis van DOS en Windows naar de Linux omgeving om te zetten, als ook in
het voorzien van hints in het uitwisselen van bestanden en bronnen tussen
de twee OS'sen.</EM>
<HR>
<H2><A NAME="s1">1. Introductie</A></H2>

<H2>1.1 Is Linux iets voor jou?</H2>

<P>
<P>Laten we politiek correct beginnen. In dit document heb ik het over ``Linux'',
maar ik bedoel ``GNU/Linux''. Ga alsjeblieft naar
<A HREF="http://www.gnu.org/gnu/linux-and-gnu.html">http://www.gnu.org/gnu/linux-and-gnu.html</A> om te zien waarom.
<P>Wil je van de DOS/Windows wereld naar Linux overstappen? Goed idee:
Linux is technisch gezien superieur aan DOS, Windows 9x en zelfs Windows NT.
Maar pas op: misschien dat het niet van nut is voor je. Dit zijn de belangrijkste verschillen tussen DOS/Windows en Linux:
<P>
<UL>
<LI>Onder Windows draaien Microsoft Office en heel veel spelletjes; wordt
waargenomen als eenvoudig te installeren en configureren; het is opmerkelijk
onstabiel; heeft een magere performance; crasht frequent.</LI>
<LI>Onder Linux draait StarOffice, heel veel technische software en minder
spellen; het kan lastig te installeren en configureren zijn; is rotsvast;
feilloze performance; crashes komen zelden voor.</LI>
</UL>
<P>Het is aan jou uit te maken wat je nodig hebt. Bovendien geeft Linux je
kracht, maar het vraagt wat tijd te leren hoe het te benutten. Dus als
je voornamelijk commerci&euml;le software nodig hebt, of als je er niets
voor voelt om nieuwe commando's en begrippen te leren, kun je je beter
ergens anders op concentreren. Wees je ervan bewust dat veel nieuwkomers
vanwege aanvangsproblemen opgeven.
<P>Er wordt aan gewerkt Linux eenvoudiger in het gebruik te maken, maar <EM>verwacht er niet bedreven in te zijn zonder dat je heel veel documentatie
hebt gelezen en het op z'n minst voor een paar maanden hebt gebruikt</EM>.
Linux geeft je geen kant en klare oplossingen. Ondanks deze waarschuwingen,
ben ik er 100% van overtuigd dat als je het juiste type gebruiker
bent, je zeer tevreden zult zijn over Linux. Tussen twee haakjes,
Linux + DOS/Win kunnen prima op dezelfde computer voorkomen.
<P>Benodigd voor deze howto: Ik ga ervan uit dat
<P>
<UL>
<LI> je bekend bent met de basiscommando's en concepten van DOS;</LI>
<LI> Linux mogelijk met X Window System (afgekort tot X11) op de juiste
wijze op je PC is ge&iuml;nstalleerd;</LI>
<LI> je shell (het equivalent van <CODE>COMMAND.COM</CODE>) <CODE>bash</CODE> is.</LI>
</UL>
<P>Tenzij anders aangegeven, wordt bij dit werk uitgegaan van dat 'slechte
ouwe' DOS. Her en der wordt informatie over Windows gegeven, maar houd in
gedachten dat Windows en Linux totaal verschillend zijn, anders dan DOS
dat een of andere sobere relatie met UNIX heeft.
<P>Bedenk je alsjeblieft ook dat dit werkstuk noch een complete inleiding noch
een configuratiegids is!
<P>De laatste versie van dit document is in verscheidene formaten beschikbaar
op 
<A HREF="http://www.linuxdoc.org">http://www.linuxdoc.org</A>.
<H2>1.2 Vertel verder</H2>

<P>
<P>Je installeerde Linux en de programma's die je nodig had op je PC. Je gaf
jezelf een account
(als dit niet zo is, typ dan <EM>nu!</EM> <CODE>adduser jenaam</CODE>
en Linux is opgestart.
Je hebt zojuist je naam en wachtwoord ingevuld, en nu kijk je naar het
scherm en denkt: ``Tja, en wat nu?''
<P>Wanhoop niet. Je bent bijna zover dat je dezelfde dingen doet die je gewend
bent met DOS/Win te doen en nog wel meer ook. Als je nu onder DOS/Win zou
werken in plaats van onder Linux, dan zou je &eacute;&eacute;n van de volgende
taken aan het verrichten zijn:
<P>
<UL>
<LI> het draaien van programma's, aanmaken, kopi&euml;ren, bekijken,
verwijderen, afdrukken hernoemen van bestanden;</LI>
<LI> CD'en, MD'en, RD'en, en DIR'ren naar je directory's;</LI>
<LI> formatteren van diskettes en er bestanden van/naar kopi&euml;ren;</LI>
<LI> aanpassen van het systeem;</LI>
<LI> surfen op het Internet;</LI>
<LI> het schrijven van .BAT bestanden en programma's in je favoriete taal;</LI>
<LI> de resterende 1%.</LI>
</UL>
<P>Het zal je verheugen te weten dat deze taken onder Linux op een vergelijkbare
manier als onder DOS kunnen worden bewerkstelligd.
Onder DOS, gebruikt de gemiddelde gebruiker een paar van de 100+ 
beschikbare commando's: hetzelfde geldt tot op zekere hoogte voor Linux.
<H3>Inleidende begrippen</H3>

<P>
<P>Oefening baart kunst. Je wordt aangemoedigd om met Linux te experimenteren
en spelen: tenzij je als ``root'' inlogt, kun je het systeem op die manier
niet beschadigen. Een paar aandachtspunten:
<P>
<UL>
<LI> ten eerste hoe je Linux veilig af kunt sluiten. Als je een tekstmode
scherm ziet, druk dan op &lt;CTRL-ALT-DEL&gt;, wacht totdat het systeem
herstart, en zet dan de PC uit. Als je onder het X Window Systeem werkt,
druk dan eerst op &lt;CTRL-ALT-BACKSPACE&gt;, daarna &lt;CTRL-ALT-DEL&gt;.
Schakel de PC <EM>Nooit</EM> direct uit en maak ook geen gebruik van de
reset knop: dit zou het bestandssysteem kunnen beschadigen;</LI>
<LI> in tegenstelling tot DOS of Windows, heeft Linux een ingebouwd
beveiligingsmechanisme. Met bestanden en directory's zijn permissies
geassocieerd; als resultaat daarvan kunnen er een aantal niet door de
gewone gebruiker worden benaderd; (zie Sectie 
<A HREF="#Permissions">Permissies en Eigenaarschap</A>). DOS en Windows laten je daarentegen
de volledige inhoud van je harddisk om zeep helpen;</LI>
<LI> er is een speciale gebruiker genaamd ``root'': de systeembeheerder,
met de kracht van leven en dood op je computer. Als je op een eigen
PC werkt, zal je ook root zijn.
Als root werken is <EM>gevaarlijk</EM>: iedere vergissing kan je systeem
net als met DOS/Windows ernstig beschadigen of ru&iuml;neren.
Werk niet als root tenzij dit absoluut noodzakelijk is;</LI>
<LI> veel van de complexiteit van Linux komt door zijn extreme
configuratiemogelijkheden:
praktisch elke feature en iedere applicatie kan via &eacute;&eacute;n of
meer configuratiebestanden worden aangepast.
Complexiteit is de prijs die moet worden betaald voor kracht;</LI>
<LI> omleiding en het door middel van een pipe-symbool doorgeven van
gegevens zijn een zijdelingse DOS-feature, een zeer
belangrijke en onder Linux veel krachtiger. Eenvoudige commando's kunnen
worden samengevoegd om complexe taken te volbrengen. Ik adviseer je deze
commando's te leren gebruiken.</LI>
</UL>
<H3>Hulp verkrijgen</H3>

<P>
<P>Er zijn veel manieren om hulp te krijgen met Linux. De belangrijkste zijn:
<P>
<UL>
<LI> <EM>het lezen van documentatie</EM>---Ik meen het. Alhoewel de
HOWTO die je aan het lezen bent als een introductie in Linux kan dienen,
zijn er verscheidene boeken die je echt zou moeten lezen: op z'n minst
Matt Welsh's ``Linux Installation and Getting Started'' (
<A HREF="http://www.linuxdoc.org/LDP/gs/gs.html">http://www.linuxdoc.org/LDP/gs/gs.html</A>) en de Linux FAQ (
<A HREF="http://www.linuxdoc.org/FAQ/Linux-FAQ/index.html">http://www.linuxdoc.org/FAQ/Linux-FAQ/index.html</A>). Voel je schuldig
net zolang totdat je er op z'n minst &eacute;&eacute;n van hebt gelezen;</LI>
<LI> de documentatie van de packages die op de computer zijn
ge&iuml;nstalleerd zijn vaak te vinden in subdirectory's onder
/usr/doc/;</LI>
<LI> typ <CODE>help</CODE> of, beter, <CODE>man bash</CODE> of <CODE>info bash</CODE> voor
het verkrijgen van hulp over de ``interne commando's'' van de shell;</LI>
<LI> type voor hulp met een commando <CODE>man commando</CODE> waarmee
de handleiding (``man'') page van <CODE>commando</CODE> wordt aangeroepen.
Typ als alternatief <CODE>info commando </CODE> waarmee de info page die
betrekking heeft op
<CODE>commando</CODE> wordt aangeroepen; info is een op hypertekst gebaseerd
documentatiesysteem, misschien niet inti&uuml;tief om als eerste te
gebruiken. Tenslotte kun je als laatste <CODE>apropos commando</CODE>
of <CODE>whatis commando</CODE> gebruiken. Voor al deze commando's geldt
dat je op `q' drukt om het helpsysteem te verlaten.</LI>
<LI> als laatste op het Internet: de juiste plaats voor het verkrijgen van
hulp is Usenet, zoals 
<A HREF="news:comp.os.linux.setup">news:comp.os.linux.setup</A>. Email mij
alsjeblieft niet om hulp want ik ben zeer overbelast.</LI>
</UL>
<H2>1.3 Afspraken</H2>

<P>
<P>In dit hele document zullen voorbeelden vaak het volgende formaat volgen:
<CODE>&lt;...></CODE> is een vereist argument, en <CODE>[...]</CODE> is een
optioneel argument.
Voorbeeld:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ tar -tf &lt;bestand.tar> [> omleidingsbestand]
</PRE>
</CODE></BLOCKQUOTE>
<P><CODE>bestand.tar</CODE> moet worden opgegeven, maar de omleiding naar het
<CODE>omleidingsbestand</CODE> is optioneel.
<P>``LMP'' betekent ``Lees alsjeblieft de Man Pages voor verdere informatie''.
Ik kan niet genoeg benadrukken hoe belangrijk het lezen van documentatie
is.
<P>Als de prompt van een voorbeeldcommando een <CODE>#</CODE> is, kan het
commando alleen door root worden uitgevoerd.
<H2><A NAME="s2">2. Voor de ongeduldigen</A></H2>

<P>
<P>Wil je graag beginnen? Bekijk dan de volgende tabel:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
DOS                     Linux                  Opmerkingen
------------------------------------------------------------------------------

ATTRIB (+-)attr bestand chmod &lt;mode> bestand   totaal anders
BACKUP                  tar -Mcvf device dir/  idem
CD dirnaam\             cd dirnaam/            bijna dezelfde syntax
COPY bestand1 bestand2  cp bestand1 bestand2   idem
DEL bestand             rm bestand             let op - geen undelete
DELTREE dirnaam         rm -R dirnaam/         idem
DIR                     ls                     niet exact dezelfde syntax
DIR bestand /S          find . -naam bestand   totaal anders
EDIT bestand            vi bestand             Ik denk dat je 't niet leuk vindt
                        jstar bestand          voelt als dos' edit
EDLIN bestand           ed bestand             vergeet het
FORMAT                  fdformat,
                        mount, umount          heel andere syntax
HELP commando           man commando,          zelfde filosofie
                        info commando
MD dirnaam              mkdir dirnaam/         bijna dezelfde syntax
MORE &lt; bestand          less bestand           veel beter
MOVE bestand1 bestand2  mv bestand1 bestand2   idem
NUL                     /dev/null              idem
PRINT bestand           lpr bestand            idem
PRN                     /dev/lp0,
                        /dev/lp1               idem
RD dirnaam              rmdir dirnaam/         bijna dezelfde syntax
REN bestand1 bestand2   mv bestand1 bestand2   niet voor meerdere bestanden
RESTORE                 tar -Mxpvf device      andere syntax
TYPE bestand            less bestand           veel beter
WIN                     startx                 hemelsbreed verschil!
</PRE>
</CODE></BLOCKQUOTE>
<P>Raadpleeg alsjeblieft de volgende secties als je meer nodig hebt dan een
tabel met commando's.
<H2><A NAME="s3">3. Maak kennis met bash</A></H2>

<P>
<P>Goed nieuws: onder Linux typ je veel minder achter de prompt, omdat de
<CODE>bash</CODE> shell zo mogelijk voor je typt, en het heeft geweldige 
regelediting mogelijkheden. Om mee te beginnen, haalt de cursorpijl
naar boven de voorgaande commandoregels terug; maar er is meer.
Het indrukken van de &lt;TAB&gt; vult bestands- en directorynamen aan, dus
het typen van
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ ls /uTABloTABbTAB
</PRE>
</CODE></BLOCKQUOTE>
<P>is als het intikken van
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ ls /usr/local/bin
</PRE>
</CODE></BLOCKQUOTE>
<P>Als er dubbelzinnigheden optreden, zoals bij het intikken van
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ ls /uTABloTABiTAB
</PRE>
</CODE></BLOCKQUOTE>
<P>stopt <CODE>bash</CODE> omdat het niet weet of je
/usr/local/info of /usr/local/include bedoelt.
Voeg meer tekens toe en druk dan nogmaals op &lt;TAB&gt;.
<P>Andere handige toetsaanslagen zijn &lt;ESC-BACKSPACE&gt; waarmee een woord
links wordt verwijderd, en
&lt;ESC-D&gt; waarmee een woord rechts wordt verwijderd; &lt;ESC-F&gt;
verplaatst de cursor &eacute;&eacute;n woord naar rechts, &lt;ESC-B&gt; 
naar links; &lt;CTRL-A&gt; verplaatst de cursor naar het begin van de
regel, &lt;CTRL-E&gt; naar het einde.
De &lt;ALT&gt; toets is equivalent aan &lt;ESC&gt;.
<P>Genoeg voor het moment. 
Zodra je aan deze sneltoetsen gewend raakt, zal je de DOS-prompt zeer
ergerlijk vinden...
<H2><A NAME="s4">4. Bestanden en programma's</A></H2>

<H2>4.1 Bestanden: Opmerkingen vooraf</H2>

<P>
<P>Linux heeft een directory- en bestandsstructuur die erg veel lijkt op
die van DOS/Win. Bestanden hebben namen die aan bepaalde regels moeten
voldoen, worden opgeslagen in directory's, een aantal ervan zijn uitvoerbaar,
en hiervan hebben de meeste commando-switches.
Bovendien kun je gebruik maken van wildcard characters (jokertekens), 
redirection en piping (het omleiden/doorsturen van uitvoer). Er zijn slechts een
paar kleine verschillen:
<P>
<UL>
<LI> onder DOS zijn de bestandsnamen in de zogenoemde 8.3 vorm; b.v.
<CODE>NOTENOUG.TXT</CODE>. Onder Linux kunnen we dat beter. Als je Linux
installeerde door gebruik te maken van een bestandssysteem als ext2 of 
umsdos, kun je langere bestandsnamen gebruiken (tot aan 255 tekens), en met
meer dan &eacute;&eacute;n punt: bijvoorbeeld:
<CODE>Dit_is.een.ZEER_lange.bestandsnaam</CODE>. Merk alsjeblieft op dat ik
zowel gebruik maakte van hoofdletters als kleine letters: in feite...</LI>
<LI> worden hoofdletters en kleine letters in bestandsnamen als
verschillende tekens gezien. Daarom zijn
<CODE>FILENAME.tar.gz</CODE> en <CODE>filename.tar.gz</CODE> twee verschillende
bestanden. <CODE>ls</CODE> is een commando, <CODE>LS</CODE> is een fout;</LI>
<LI> Windows gebruikers, let op wanneer je gebruik maakt van bestandsnamen
onder Linux. Als er in een bestandsnaam spaties voorkomen (niet aan te
bevelen maar wel mogelijk), moet je de bestandsnaam tussen 
dubbele aanhalingstekens plaatsen wanneer je ernaar refereert. Bijvoorbeeld:

<BLOCKQUOTE><CODE>
<PRE>
$ # het volgende commando maakt een directory genaamd "Mijn oude bestanden"
$ mkdir "Mijn oude bestanden"
$ ls
Mijn oude bestanden    bin     tmp
</PRE>
</CODE></BLOCKQUOTE>


Bovendien is het beter een aantal tekens niet te gebruiken: een aantal
daarvan zijn <CODE>!*$&amp;#</CODE>.</LI>
<LI> er zijn voor programma's geen verplichte extensies zoals .COM en
.EXE of .BAT voor batchbestanden.
Uitvoerbare bestanden worden aan het einde van de bestandsnaam
door een asterisk `<CODE>*</CODE>' gemarkeerd wanneer je het commando
<CODE>ls -F</CODE> geeft. Bijvoorbeeld:

<BLOCKQUOTE><CODE>
<PRE>
$ ls -F
Ik_ben_een_dir/   cindy.jpg    cjpg*   brief_aan_Joe    mijn_1e_script*  oud~
</PRE>
</CODE></BLOCKQUOTE>


De bestanden <CODE>cjpg*</CODE> en <CODE>mijn_1e_script*</CODE> zijn uitvoerbare
bestanden, dat wil zeggen ``programma's''. Onder DOS eindigen backupbestanden
op .BAK, onder Linux eindigen ze op een tilde `<CODE>~</CODE>'. 
Een bestand waarvan de naam begint met een punt wordt als verborgen aangemerkt.
Voorbeeld: het bestand
<CODE>.Ik.ben.een.verborgen.bestand</CODE> zal na het commando <CODE>ls</CODE> niet
worden getoond;</LI>
<LI> DOS programma switches worden verkregen met <CODE>/switch</CODE>, Linux
switches met <CODE>-switch</CODE> of <CODE>--switch</CODE>. Voorbeeld: <CODE>dir
/s&lt;</CODE>tt> wordt <CODE>ls -R</CODE>. Merk op dat veel DOS programma's, zoals
<CODE>PKZIP</CODE> of <CODE>ARJ</CODE>, switches in de stijl van UNIX gebruiken.</LI>
</UL>
<P>Je kunt nu naar de sectie 
<A HREF="#Files">Commando's van DOS naar Linux vertalen</A> gaan, maar als ik jou was zou ik verder lezen.
<P>
<H2>4.2 Symbolische links</H2>

<P>
<P>UNIX heeft een type bestand dat onder DOS niet voorkomt: de symbolische link.
Je kunt hierbij denken aan een verwijzer naar een bestand of directory,
en het kan in plaats van het bestand of directory waarnaar het verwijst 
worden gebruikt; het is vergelijkbaar met de snelkoppelingen van Windows.
Voorbeelden van symbolische links zijn <CODE>/usr/X11</CODE>, die naar
<CODE>/usr/X11R6</CODE> verwijst; <CODE>/dev/modem</CODE>, die naar 
<CODE>/dev/ttyS0</CODE> of <CODE>/dev/ttyS1</CODE> verwijst.
<P>Om een symbolische link aan te maken:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ ln -s &lt;bestand_of_dir> &lt;linknaam>
</PRE>
</CODE></BLOCKQUOTE>
<P>Voorbeeld:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ ln -s /usr/doc/g77/DOC g77manual.txt
</PRE>
</CODE></BLOCKQUOTE>
<P>Nu kun je naar <CODE>g77manual.txt</CODE> verwijzen in plaats van
<CODE>/usr/doc/g77/DOC</CODE>. Links verschijnen als volgt in directorylistings:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ ls -F
g77manual.txt@
$ ls -l
(van alles en nog wat...)           g77manual.txt -> /usr/doc/g77/DOC
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="Permissions"></A> 4.3 Permissies en Eigenaarschap </H2>

<P>
<P>DOS bestanden en directory's hebben de volgende kenmerken:
A (archive = archief), H (hidden = verborgen), R (read-only = alleen lezen), en 
S (system = systeem). 
Alleen H en R hebben onder Linux een betekenis: verborgen bestanden
beginnen met een punt, en wat betreft het kenmerk R, lees verder.
<P>Onder UNIX heeft een bestand ``permissies'' en een eigenaar, die op zijn
beurt weer aan een ``groep'' toebehoort.
Kijk naar dit voorbeeld:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ ls -l /bin/ls
-rwxr-xr-x  1  root  bin  27281 Aug 15 1995 /bin/ls*
</PRE>
</CODE></BLOCKQUOTE>
<P>In het eerste veld staan de permissies van het bestand <CODE>/bin/ls</CODE>, welke
aan root toebehoort, groep bin.
De resterende informatie latend voor wat het is, onthoud dat
<CODE>-rwxr-xr-x</CODE> van links naar rechts betekent:
<P><CODE>-</CODE> het bestandstype is (<CODE>-</CODE> = gewoon bestand, <CODE>d</CODE> =
directory, <CODE>l</CODE> = link, enz.); <CODE>rwx</CODE> zijn de permissies voor de
eigenaar van het bestand (read/lezen, write/schrijven, execute/uitvoeren); <CODE>r-x</CODE> zijn de
permissies voor de groep van de eigenaar van het bestand
(read, execute); (Ik ga het niet hebben over het begrip groep, je kunt zolang
je beginner bent zonder ;-0
<CODE>r-x</CODE> zijn de permissies voor alle andere gebruikers (read, execute).
<P>De directory <CODE>/bin</CODE> heeft ook permissies: zie sectie 
<A HREF="#Directories Permissions">Directory Permissies</A> voor verdere details.
Daarom kun je het bestand <CODE>/bin/ls</CODE> niet verwijderen tenzij je root bent:
je hebt geen permissie om dat te doen. Het commando voor het wijzigen van
de bestandspermissies is:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ chmod &lt;wieXperm> &lt;file>
</PRE>
</CODE></BLOCKQUOTE>
<P>`wie' is <CODE>u</CODE> (user, dat is de eigenaar), <CODE>g</CODE> (group),
<CODE>o</CODE> (other=anderen), X is of <CODE>+</CODE> of <CODE>-</CODE>, perm is <CODE>r</CODE>
(read), <CODE>w</CODE> (write), of <CODE>x</CODE> (execute). Algemene voorbeelden van
<CODE>chmod</CODE> zijn:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ chmod +x bestand
</PRE>
</CODE></BLOCKQUOTE>
<P>hiermee wordt de execute permissie voor het bestand ingesteld.
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ chmod go-rw bestand
</PRE>
</CODE></BLOCKQUOTE>
<P>hiermee wordt de read en write permissies voor iedereen behalve de eigenaar
ingesteld.
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ chmod ugo+rwx bestand
</PRE>
</CODE></BLOCKQUOTE>
<P>dit geeft iedereen read, write en execute permissie.
<P>
<BLOCKQUOTE><CODE>
<PRE>
# chmod +s bestand
</PRE>
</CODE></BLOCKQUOTE>
<P>hiermee wordt een zogenoemd ``setuid'' of ``suid'' bestand aangemaakt---
een bestand dat iedereen uit mag voeren met de privileges van de eigenaar.
Je zal ongetwijfeld root suid bestanden tegenkomen; dit zijn vaak belangrijke
systeembestanden, zoals de X-server.
<P>Een beknoptere manier om naar permissies te refereren is met cijfers:
<CODE>rwxr-xr-x</CODE> kan worden uitgedrukt als 755 (iedere letter correspondeert
met een bit: <CODE>---</CODE> is 0,
<CODE>--x</CODE> is 1, <CODE>-w-</CODE> is 2, <CODE>-wx</CODE> is 3...). Het ziet er
moeilijk uit, maar met wat oefening zal je het concept begrijpen. root, als
superuser, kan de bestandspermissies van iedereen wijzigen.
LMP.
<H2><A NAME="Files"></A> 4.4 Bestanden: Commando's vertalen</H2>

<P>
<P>Links de DOS-commando's; rechts de Linux tegenhanger.
<P>
<BLOCKQUOTE><CODE>
<PRE>
ATTRIB:         chmod
COPY:           cp
DEL:            rm
MOVE:           mv
REN:            mv
TYPE:           more, less, cat
</PRE>
</CODE></BLOCKQUOTE>
<P>Omleidings- en andere operatoren: <CODE> &lt; > >> |</CODE>
<P>Wildcards: <CODE>* ?</CODE>
<P><CODE>nul:        /dev/null</CODE>
<P><CODE>prn, lpt1:  /dev/lp0 of /dev/lp1; lpr</CODE>
<H3>Voorbeelden</H3>

<P> 
<P>
<BLOCKQUOTE><CODE>
<PRE>
DOS                                     Linux
---------------------------------------------------------------------

C:\GUIDO>ATTRIB +R FILE.TXT             $ chmod 400 file.txt
C:\GUIDO>COPY JOE.TXT JOE.DOC           $ cp joe.txt joe.doc
C:\GUIDO>COPY *.* TOTAL                 $ cat * > total
C:\GUIDO>COPY FRACTALS.DOC PRN          $ lpr fractals.doc
C:\GUIDO>DEL TEMP                       $ rm temp
C:\GUIDO>DEL *.BAK                      $ rm *~
C:\GUIDO>MOVE PAPER.TXT TMP\            $ mv paper.txt tmp/
C:\GUIDO>REN PAPER.TXT PAPER.ASC        $ mv paper.txt paper.asc
C:\GUIDO>PRINT LETTER.TXT               $ lpr letter.txt
C:\GUIDO>TYPE LETTER.TXT                $ more letter.txt
C:\GUIDO>TYPE LETTER.TXT                $ less letter.txt
C:\GUIDO>TYPE LETTER.TXT > NUL          $ cat letter.txt > /dev/null
        n/a                             $ more *.txt *.asc
        n/a                             $ cat section*.txt | less
</PRE>
</CODE></BLOCKQUOTE>
<P>Opmerkingen:
<P>
<UL>
<LI> <CODE>*</CODE> is slimmer onder Linux: <CODE>*</CODE> komt overeen met
alle bestanden behalve de verborgen bestanden;
<CODE>.*</CODE> komt overeen met alle verborgen bestanden (maar ook de huidige
directory `<CODE>.</CODE>' en parent directory `<CODE>..</CODE>': let op!);
<CODE>*.*</CODE> komt alleen overeen met bestanden met een `<CODE>.</CODE>' in het
midden of die op een punt eindigen; <CODE>p*r</CODE> komt overeen met zowel
`peter' als `piper';
<CODE>*c*</CODE> komt overeen met zowel `picked' als `peck';</LI>
<LI> druk bij gebruik van <CODE>more</CODE>, op de &lt;SPATIEBALK&gt; om
door het bestand te bladeren, `q' om het te verlaten.
<CODE>less</CODE> is intu&iuml;tiever en laat je de pijltjestoetsen gebruiken;</LI>
<LI> er is geen <CODE>UNDELETE</CODE>, dus <EM>bedenk je tweemaal</EM> 
voordat je iets verwijdert;</LI>
<LI> in aanvulling op de <CODE>&lt; &gt; &gt;&gt;</CODE> van DOS, heeft Linux
<CODE>2&gt;</CODE> om foutmeldingen om te leiden (stderr); bovendien
wordt met <CODE>2&gt;&amp;1</CODE> stderr naar stdout omgeleid, en 
<CODE>1&gt;&amp;2</CODE> leidt stdout om naar stderr;</LI>
<LI> Linux heeft nog een wildcard: de <CODE>[]</CODE>. Gebruik: <CODE>[abc]*</CODE>
komt overeen met bestanden die beginnen met een a, b, c; <CODE>*[I-N1-3]</CODE> 
komt overeen met bestanden die eindigen op
I, J, K, L, M, N, 1, 2, 3;</LI>
<LI> <CODE>lpr</CODE> &lt;bestand&gt; drukt een bestand af in de achtergrond.
Gebruik <CODE>lpq</CODE> voor het controleren van de status van de afdrukwachtrij;
gebruik <CODE>lprm</CODE> voor het verwijderen van een bestand uit de afdrukwachtrij;</LI>
<LI> er is geen op DOS lijkend <CODE>RENAME</CODE>; dat wil zeggen dat
<CODE>mv *.xxx *.yyy</CODE> niet zal werken. Een op REN lijkend commando is 
te vinden op 
<A HREF="ftp://metalab.unc.edu/pub/Linux/utils/file">ftp://metalab.unc.edu/pub/Linux/utils/file</A>;</LI>
<LI> gebruik <CODE>cp -i</CODE> en <CODE>mv -i</CODE> om te worden gewaarschuwd
wanneer een bestand zal worden overschreven.</LI>
</UL>
<H2>4.5 Programma's uitvoeren: Multitasking en Sessies</H2>

<P>
<P>Om een programma uit te voeren, typ je net als onder DOS de naam ervan in.
Als de directory (Sectie 
<A HREF="#Directories">Gebruik van directory's</A>)
waarin het programma is opgeslagen in het PATH is opgenomen (Sectie 
<A HREF="#System Initialisation">Systeem initialisatiebestanden</A>), zal het programma
worden opgestart. Uitzondering: in tegenstelling tot DOS, zal een programma
in de huidige directory niet worden uitgevoerd, tenzij de directory in het
PATH is opgenomen. Je kunt hieraan ontsnappen: als <CODE>prog</CODE> je programma
is, typ dan <CODE>./prog</CODE>.
<P>Zo ziet een typische commandoregel eruit:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ commando [-s1 [-s2] ... [-sn]] [par1 [par2] ... [parn]] [&lt; invoer] [> uitvoer]
</PRE>
</CODE></BLOCKQUOTE>
<P>waar de <CODE>-s1</CODE>, ..., <CODE>-sn</CODE> staan voor programma-switches.
<CODE>par1</CODE>, ..., <CODE>parn</CODE> zijn de programma parameters. Je kunt
verscheidene commando's op de commandoregel aanroepen:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ commando-1 ; commando-2 ; ... ; commando-n
</PRE>
</CODE></BLOCKQUOTE>
<P>Dat is alles over het draaien van programma's, maar het is eenvoudig een stap
verder te gaan. E&eacute;n van de belangrijkste redenen om Linux te gebruiken
is dat het een multitasking os is--- het kan verscheidene programma's
tegelijkertijd draaien (van nu af aan, processen).
Je kunt processen in de achtergrond opstarten en gewoon door blijven werken. 
Bovendien staat Linux toe dat je meerdere sessies hebt lopen:
het is alsof je veel computers tegelijk aan het werk zet!
<P>
<UL>
<LI> Druk op &lt;ALT-F1&gt; ... &lt;ALT-F6&gt; om naar sessie 1..6 onder de
virtuele console over te schakelen</LI>
<LI> Typ <CODE>su - &lt;loginnaam&gt;</CODE> voor het starten van een
nieuwe sessie onder dezelfde v.c. zonder de huidige v.c. te verlaten.
Voorbeeld: <CODE>su - root</CODE>. Dit komt bijvoorbeeld van pas als je een
taak uit moet voeren waarvoor alleen de root-gebruiker permissie heeft.</LI>
<LI> Typ voor het be&euml;indigen van een sessie <CODE>exit</CODE>. 
Als er gestopte jobs zijn (zie verderop), krijg je een waarschuwing.</LI>
<LI> Voeg een ampersand '<CODE>&amp;</CODE>' aan het einde van de
commandoregel toe voor het in de achtergrond opstarten van een proces:

<BLOCKQUOTE><CODE>
<PRE>
$ prognaam [-switches] [parameters] [&lt; invoer] [> uitvoer] &amp;
[1] 123
</PRE>
</CODE></BLOCKQUOTE>


de shell identificeert het proces met een jobnummer (b.v. <CODE>[1]</CODE>; zie
hieronder), en met een PID (Proces Identificatie Nummer; 123 in ons voorbeeld).</LI>
<LI> Typ <CODE>ps ax</CODE> om te bekijken hoeveel processen er zijn. 
Hiermee krijg je als uitvoer een lijst met de thans draaiende processen.</LI>
<LI> Typ <CODE>kill &lt;PID&gt;</CODE> voor het killen (be&euml;indigen)
van een proces. Wellicht dat je het eens nodig hebt als je niet weet hoe
je een proces op de juiste wijze moet laten eindigen...
Tenzij je root bent, kun je andermans processen niet killen.
Soms kan een proces alleen worden be&euml;indigd met <CODE>kill -SIGKILL
&lt;PID&gt;</CODE>.

Bovendien laat de shell je een proces stoppen of tijdelijk uitstellen,
een proces naar de achtergrond sturen, en een proces vanuit de achtergrond
naar de voorgrond brengen. In deze context, worden processen ``jobs'' genoemd.</LI>
<LI> Typ <CODE>jobs</CODE> om te zien hoeveel jobs er zijn. Hier worden de
jobs ge&iuml;ndentificeerd door een jobnummer, niet via een PID.</LI>
<LI> Druk op &lt;CTRL-C&gt; om een in de voorgrond draaiend proces te
stoppen (dit werkt niet altijd).</LI>
<LI> Druk op &lt;CTRL-Z&gt; om een in de voorgrond draaiend proces uit te
stellen (idem).</LI>
<LI> Typ <CODE>bg &lt;%job&gt;</CODE> voor een uitgesteld proces naar de
achtergrond te sturen (het wordt een job).</LI>
<LI> Voor het naar de voorgrond brengen van een job typ je 
<CODE>fg &lt;%job&gt;</CODE>. Voor het naar de voorgrond brengen van de laatste
job die naar de achtergrond is gestuurd, typ je eenvoudigweg <CODE>fg</CODE>.</LI>
<LI> Typ voor het killen van een job <CODE>kill &lt;%job&gt;</CODE> 
waarbij &lt;job&gt; gelijk kan zijn aan 1, 2, 3,...</LI>
</UL>
<P>Met deze commando's kun je tegelijkertijd een disk formatteren, een boel
bestanden zippen, een programma compileren en een archief uitpakken en nog
steeds de prompt tot je beschikking hebben. Probeer dit eens met Windows,
enkel om het verschil in performance te zien (als het niet crasht, uiteraard).
<H2>4.6 Programma's op Remote computers uitvoeren</H2>

<P>
<P>Voor het uitvoeren van een programma op een remote computer met de naam
<CODE>remote.machine.edu</CODE>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ telnet remote.machine.edu
</PRE>
</CODE></BLOCKQUOTE>
<P>Start na het inloggen je favoriete programma. Onnodig te zeggen dat je een
shell-account op de remote computer nodig hebt.
<P>Als je X11 hebt, kun je zelfs een X-applicatie op een remote computer
uitvoeren en het op je X scherm weergeven.
Stel dat <CODE>remote.machine.edu</CODE> de remote X-computer is en
<CODE>local.linux.box</CODE> je Linux-computer. Om een X-programma vanaf
<CODE>local.linux.box</CODE> dat zich bevindt op
<CODE>remote.machine.edu</CODE> uit te voeren, doe je het volgende:
<P>
<UL>
<LI> start X11 op, start een <CODE>xterm</CODE> of equivalente terminal emulator,
en typ dan:

<BLOCKQUOTE><CODE>
<PRE>
$ xhost +remote.machine.edu
$ telnet remote.machine.edu
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI> typ na het inloggen:

<BLOCKQUOTE><CODE>
<PRE>
remote:$ DISPLAY=local.linux.box:0.0
remote:$ prognaam &amp;
</PRE>
</CODE></BLOCKQUOTE>


(in plaats van <CODE>DISPLAY...</CODE>, moet je mogelijk opgeven: <CODE>setenv DISPLAY
local.linux.box:0.0</CODE>. Dit is afhankelijk van de remote shell.)</LI>
</UL>
<P>En ziedaar! Nu zal <CODE>prognaam</CODE> op <CODE>remote.machine.edu</CODE> worden
opgestart en op je computer worden weergegeven. Probeer dit echter niet via een
modem, aangezien dit zo langzaam is dat het niet meer werkbaar is.
Bovendien is dit een grove en onveilige methode:
lees alsjeblieft de ``Remote X Apps mini-HOWTO'' op 
<A HREF="http://www.linuxdoc.org/HOWTO/mini/Remote-X-Apps.html">http://www.linuxdoc.org/HOWTO/mini/Remote-X-Apps.html</A>.
<H2><A NAME="Directories"></A> <A NAME="s5">5. Gebruik van directory's</A></H2>

<H2>5.1 Directory's: Opmerkingen vooraf</H2>

<P>
<P>We hebben tussen bestanden onder DOS/Win en Linux verschillen gezien. 
Wat betreft directory's is de root directory onder DOS/Win <CODE>\</CODE>,
onder Linux is het <CODE>/</CODE>. Evenzo worden geneste directory's  
onder DOS/Win gescheiden door een <CODE>\</CODE>
onder Linux door een <CODE>/</CODE>. Voorbeelden van directorypaden:
<P>
<BLOCKQUOTE><CODE>
<PRE>
DOS:    C:\PAPERS\GEOLOGY\MID_EOC.TEX
Linux:  /home/guido/papers/geology/middle_eocene.tex
</PRE>
</CODE></BLOCKQUOTE>
<P>Zoals gebruikelijk is <CODE>..</CODE> de parent directory en <CODE>.</CODE> de 
huidige directory.
Onthoud dat het systeem je niet toelaat overal waar je maar wil 
<CODE>cd</CODE>, <CODE>rd</CODE>, of <CODE>md</CODE> uit te voeren. 
Iedere gebruiker heeft zijn of haar
zaakjes in een directory genaamd `home', gegeven door de systeembeheerder;
op mijn PC bijvoorbeeld, is mijn homedir <CODE>/home/guido</CODE>.
<H2><A NAME="Directories Permissions"></A> 5.2 Directory permissies</H2>

<P>
<P>Ook directory's hebben permissies. Wat we in paragraaf 
<A HREF="#Permissions">Permissies en Eigenaarschap</A> hebben gezien, geldt
ook voor directory's (user, group, en other). 
Voor een directory betekent <CODE>rx</CODE> dat je met <CODE>cd</CODE>
naar die directory kunt gaan, en <CODE>w</CODE> betekent dat je een
bestand in de directory of de directory zelf kunt verwijderen
(overeenkomstig de permissies van het bestand uiteraard).
<P>Om bijvoorbeeld te voorkomen dat andere gebruikers in
<CODE>/home/guido/text</CODE> rond gaan snuffelen:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ chmod o-rwx /home/guido/text
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="Directories: Trans"></A> 5.3 Directory's: Commando's vertalen</H2>

<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
DIR:            ls, find, du
CD:             cd, pwd
MD:             mkdir
RD:             rmdir
DELTREE:        rm -rf
MOVE:           mv
</PRE>
</CODE></BLOCKQUOTE>
<H3>Voorbeelden</H3>

<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
DOS                                     Linux
---------------------------------------------------------------------

C:\GUIDO>DIR                            $ ls
C:\GUIDO>DIR FILE.TXT                   $ ls file.txt
C:\GUIDO>DIR *.H *.C                    $ ls *.h *.c
C:\GUIDO>DIR/P                          $ ls | more
C:\GUIDO>DIR/A                          $ ls -l
C:\GUIDO>DIR *.TMP /S                   $ find / -name "*.tmp"
C:\GUIDO>CD                             $ pwd
        n/a - zie opmerking             $ cd
        idem                            $ cd ~
        idem                            $ cd ~/temp
C:\GUIDO>CD \OTHER                      $ cd /other
C:\GUIDO>CD ..\TEMP\TRASH               $ cd ../temp/trash
C:\GUIDO>MD NEWPROGS                    $ mkdir newprogs
C:\GUIDO>MOVE PROG ..                   $ mv prog ..
C:\GUIDO>MD \PROGS\TURBO                $ mkdir /progs/turbo
C:\GUIDO>DELTREE TEMP\TRASH             $ rm -rf temp/trash
C:\GUIDO>RD NEWPROGS                    $ rmdir newprogs
C:\GUIDO>RD \PROGS\TURBO                $ rmdir /progs/turbo
</PRE>
</CODE></BLOCKQUOTE>
<P>Opmerkingen:
<P>
<UL>
<LI> bij gebruik van <CODE>rmdir</CODE>, moet de te verplaatsen directory
leeg zijn. Gebruik <CODE>rm -rf</CODE> voor het verwijderen van een directory
met gehele inhoud (op eigen risico).</LI>
<LI> het teken `<CODE>~</CODE>' is een verkorte vorm voor de naam van je
homedirectory.
De commando's <CODE>cd</CODE> en <CODE>cd ~</CODE> zullen je naar je homedirectory
laten terugkeren van waar je je ook bevindt; het commando <CODE>cd ~/tmp</CODE>
brengt je naar <CODE>/home/je_home/tmp</CODE>.</LI>
<LI> <CODE>cd -</CODE> ``annuleert'' de laatste <CODE>cd</CODE>.</LI>
</UL>
<H2><A NAME="Floppies"></A> <A NAME="s6">6. Floppy's, Harddisks, en dergelijke </A></H2>

<P>
<P>Er zijn onder Linux twee manieren om devices te beheren: op de manier van DOS
en op de manier van Unix. Maak je keuze.
<H2>6.1 Devices beheren zoals DOS het doet</H2>

<P>
<P>In de meeste Linux distributies is de Mtools suite opgenomen, 
een set commando's welke perfect equivalent is aan de 
DOS tegenhanger, maar waarvan de commando's met een `m' beginnen:
d.w.z., <CODE>mformat</CODE>, <CODE>mdir</CODE>, <CODE>mdel</CODE>, <CODE>mmd</CODE>, 
enzovoort.
Ze kunnen zelfs lange bestandsnamen behouden, maar niet de bestandspermissies.
Als je Mtools configureert door het wijzigen van een bestand genaamd
/etc/mtools.conf (een voorbeeld is in de distributie opgenomen),
kun je ook de DOS/Win partitie, de CD-ROM en de Zip-drive benaderen.
Voor het formatteren van een nieuwe disk is het <CODE>mformat</CODE>
commando echter niet geschikt. Als root zal je het volgende commando
van te voren uit moeten voeren:
<CODE>fdformat /dev/fd0H1440</CODE>.
<P>Je kunt bestanden op de diskette niet benaderen met een commando zoals bv
<CODE>less a:file.txt</CODE>! Dit is het nadeel van het benaderen van disks op
de wijze van DOS.
<H2>6.2 Devices beheren zoals Unix het doet</H2>

<P>
<P>UNIX heeft een andere manier om met devices om te gaan. 
Er zijn geen aparte volumes zoals A: of C:; een disk, of het nu een diskette
is of wat dan ook, wordt onderdeel van het lokale bestandssysteem via een
bewerking genaamd ``mounting''. Wanneer je met de diskette klaar bent,
moet je het ``unmounten'' voordat je de diskette uit het station haalt.
<P>Het fysiek formatteren van een disk is een ding, er een bestandssysteem
op maken is weer iets anders. Het DOS commando
<CODE>FORMAT A:</CODE> doet beiden, maar onder Linux zijn er twee aparte
commando's voor. Zie hiervoor hoe je een diskette formatteert, het aanmaken
van een bestandssysteem gaat zo:
<P>
<BLOCKQUOTE><CODE>
<PRE>
# mkfs -t ext2 -c /dev/fd0H1440
</PRE>
</CODE></BLOCKQUOTE>
<P>In plaats van <CODE>ext2</CODE> kun je <CODE>dos</CODE>, <CODE>vfat</CODE> (aanbevolen) of
andere formaten gebruiken. Zodra de disk is voorbereid, mount je het met het
commando:
<P>
<BLOCKQUOTE><CODE>
<PRE>
# mount -t ext2 /dev/fd0 /mnt
</PRE>
</CODE></BLOCKQUOTE>
<P>waarbij je het juiste bestandssysteem opgeeft als je geen gebruik maakt van
<CODE>ext2</CODE>. Nu kun je de bestanden op de diskette adresseren door gebruik
te maken van <CODE>/mnt</CODE> in plaats van A: of B:.
Voorbeelden:
<P>
<BLOCKQUOTE><CODE>
<PRE>
DOS                                     Linux
---------------------------------------------------------------------

C:\GUIDO>DIR A:                         $ ls /mnt
C:\GUIDO>COPY A:*.*                     $ cp /mnt/* .
C:\GUIDO>COPY *.ZIP A:                  $ cp *.zip /mnt
C:\GUIDO>EDIT A:FILE.TXT                $ jstar /mnt/file.txt
C:\GUIDO>A:                             $ cd /mnt
A:> _                                   /mnt/$ _
</PRE>
</CODE></BLOCKQUOTE>
<P>Als je klaar bent, <EM>moet</EM> je voordat je de disk eruit haalt
het unmounten met het commando
<P>
<BLOCKQUOTE><CODE>
<PRE>
# umount /mnt
</PRE>
</CODE></BLOCKQUOTE>
<P>Uiteraard hoef je de commando's <CODE>fdformat</CODE> en <CODE>mkfs</CODE> 
alleen te gebruiken voor ongeformatteerde disks, niet op voorheen gebruikte
disks. Als je station B: wilt gebruiken, refereer je in de voorbeelden
hiervoor ernaar met <CODE>fd1H1440</CODE> en <CODE>fd1</CODE> in plaats van
<CODE>fd0H1440</CODE> en <CODE>fd0</CODE>.
<P>Onnodig te zeggen dat wat voor diskettes geldt ook voor andere devices geldt;
bijvoorbeeld, wellicht dat je een andere harddisk of CD-ROM station wilt
mounten. Zo mount je een CD-ROM:
<P>
<BLOCKQUOTE><CODE>
<PRE>
# mount -t iso9660 /dev/cdrom /mnt
</PRE>
</CODE></BLOCKQUOTE>
<P>Dit was de ``offici&euml;le manier om je disks te mounten, maar er is een
andere manier. Aangezien het wat lastig is root te moeten zijn voor het mounten
van een diskette of CD-ROM, kan gebruikers worden toegestaan ze op deze
wijze te mounten:
<P>
<UL>
<LI> doe als root het volgende:

<BLOCKQUOTE><CODE>
<PRE>
# mkdir /mnt/floppy ; mkdir /mnt/cdrom
# chmod 777 /mnt/floppy /mnt/cd*
# # zorg ervoor dat het 't juiste CD-ROM device is
# chmod 666 /dev/hdb ; chmod 666 /dev/fd*
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI> voeg aan /etc/fstab de volgende regels toe:

<BLOCKQUOTE><CODE>
<PRE>
/dev/cdrom      /mnt/cdrom  iso9660 ro,user,noauto          0       0
/dev/fd0        /mnt/floppy vfat    user,noauto             0       0
</PRE>
</CODE></BLOCKQUOTE>
</LI>
</UL>
<P>Mount nu een DOS diskete en een CD-ROM:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ mount /mnt/floppy
$ mount /mnt/cdrom
</PRE>
</CODE></BLOCKQUOTE>
<P>/mnt/floppy en /mnt/cdrom
kunnen nu door iedere gebruiker worden benaderd. 
Als dit je wat uitmaakt, denk er dan aan dat het iedereen toestaan op deze
manier disks te mounten een gapend beveiligingslek is.
<P>Twee handige commando's zijn <CODE>df</CODE>, welke informatie geeft over gemounte
bestandssystemen, en <CODE>du dirnaam</CODE> welke de door de directory in beslag
genomen diskruimte rapporteert.
<H2><A NAME="Backing Up"></A> 6.3 Backup maken</H2>

<P>
<P>Er zijn verscheidene packages om je te helpen, maar het minste wat je kunt
doen voor een multi-volume backup (als root) is:
<P>
<BLOCKQUOTE><CODE>
<PRE>
# tar -M -cvf /dev/fd0H1440 dir_to_backup/
</PRE>
</CODE></BLOCKQUOTE>
<P>Zorg ervoor dat er een geformatteerde diskette in het station is en dat je
er nog verscheidene bij de hand hebt.
Voor het terugzetten doe je de eerste diskette in het diskettestation en geef
je op:
<P>
<BLOCKQUOTE><CODE>
<PRE>
# tar -M -xpvf /dev/fd0H1440
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="s7">7. En hoe zit het met Windows?</A></H2>

<P>
<P>Het ``equivalent'' van Windows is het grafische systeem X Window System. In
tegenstelling tot Windows of de Mac, werd X11 niet voor eenvoudig gebruiksgemak
of voor een fraaie weergave ontworpen, maar slechts om te voorzien in
grafische mogelijkheden voor UNIX werkstations.
Dit zijn de belangrijkste verschillen:
<P>
<UL>
<LI> terwijl Windows er in de gehele wereld hetzelfde uitziet, geldt dit
niet voor X11: het is veel beter te configureren. 
X11's algehele look wordt weergegeven door een keycomponent genaamd
``window manager'', waarin je een brede keuze hebt:
<CODE>fvwm</CODE>, een basis maar mooi en geheugeneffici&euml;nt,
<CODE>fvwm2-95</CODE>, <CODE>Afterstep</CODE>, <CODE>WindowMaker</CODE>, 
<CODE>Enlightenment</CODE>, en nog heel wat meer. De w.m. wordt gewoonlijk
aangeroepen vanuit <CODE>.xinitrc</CODE>;</LI>
<LI> je w.m. kan zo worden geconfigueerd zoals een venster onder Windows
fungeert: je klikt erop en het verschijnt op de voorgrond.
Een andere mogelijkheid is dat het naar de voorgrond wordt verplaatst als
de muis erover beweegt (``focus''). Ook kan het plaatsen van vensters
op het scherm automatisch of interactief zijn: als een vreemd frame in
plaats van je programma verschijnt, klik dan met de linkermuis op de plaats
waar je wilt dat het tevoorschijn komt;</LI>
<LI> de meeste features kunnen worden aangepast door het wijzigen van
&eacute;&eacute;n of meer configuratiebestanden.
Lees de docs van je w.m.: het configuratiebestand kan b.v. zijn
<CODE>.fvwmrc</CODE>, <CODE>.fvwm2rc95</CODE>, <CODE>.steprc</CODE>, enz. Een
voorbeeld configuratiebestand is meestal wel te vinden in
/etc/X11/window-manager-name/system.window-manager-name;</LI>
<LI> X11 applicaties zijn geschreven met behulp van speciale library's
(``widget sets''); aangezien er verscheidene beschikbaar zijn, zien de
applicaties er anders uit. De meest fundamentele applicaties zijn degenen die
gebruik maken van de Athena widgets (2--D look; <CODE>xdvi</CODE>,
<CODE>xman</CODE>, <CODE>xcalc</CODE>); anderen maken gebruik van Motif
(<CODE>netscape</CODE>), anderen gebruiken nog steeds
Tcl/Tk, Qt, Gtk, XForms, of wat je ook maar hebt. Bijna al deze library's
voorzien in ruwweg dezelfde look en feel als Windows;</LI>
<LI> de feel kan helaas verwarrend zijn. Als je bijvoorbeeld met behulp
van de muis een regel tekst selecteert en de
&lt;BACKSPACE&gt; indrukt, verwacht je dat de regel zal verdwijnen, nietwaar?
Met op Athena gebaseerde applicaties werkt dit niet, maar dit werkt wel zo
met andere widget sets;</LI>
<LI> hoe schuifbalken en het wijzigen van de grootte werkt is afhankelijk
van de w.m. en de widget set.
Tip: als je bemerkt dat de schuifbalken niet zo werken als je verwacht,
probeer dan de middelste knop of de twee knoppen samen om ze te verplaatsen;</LI>
<LI> applicaties hebben standaard geen ikoon, maar ze kunnen er meerdere
hebben. De meeste w.m. hebben een menu wat je kunt openen door op de desktop
te klikken (``root
window''); onnodig te zeggen dat het menu kan worden aangepast. 
Voor het wijzigen van de opmaak van het root
window gebruik je <CODE>xsetroot</CODE> of <CODE>xloadimage</CODE>;</LI>
<LI> het klembord kan slechts tekst bevatten, en gedraagt zich vreemd.
Zodra je tekst hebt geselecteerd, is het al naar het klembord gekopieerd:
verplaats je naar elders en druk voor het plakken op de middelste knop.
Er is een applicatie genaamd <CODE>xclipboard</CODE>, welke in meerdere
klembordbuffers voorziet;</LI>
<LI> slepen en neerzetten is een optie, en is alleen beschikbaar als je
X11 applicaties en/of een w.m. gebruikt dat dit ondersteunt.</LI>
</UL>
<P>Met dit te hebben gezegd is er goed nieuws voor je. Er zijn projecten die
zich richten op een zelfde look en feel en het fungeren van X11 als Windows.
Gnome, 
<A HREF="http://www.gnome.org">http://www.gnome.org</A>, en KDE, 
<A HREF="http://www.kde.org">http://www.kde.org</A>, boezemen eenvoudigweg ontzag in.
Zeer waarschijnlijk maakt je distributie van &eacute;&eacute;n of beiden
gebruik. Je zal geen spijt meer hebben van je Windows desktop!
<H2><A NAME="s8">8. Aanpassen van het systeem</A></H2>

<H2><A NAME="System Initialisation"></A> 8.1 Systeem Initialisatie Bestanden </H2>

<P>
<P>Twee belangrijke bestanden onder DOS zijn <CODE>AUTOEXEC.BAT</CODE> en
<CODE>CONFIG.SYS</CODE>, die tijdens de systeemstart worden gebruikt om het
systeem te initialiseren, een aantal omgevingsvariabelen, zoals PATH en
FILES in te stellen, en mogelijk een programma of batchbestand op te starten.
Daar bovenop heeft Windows het beruchte register---&eacute;&eacute;n van de
slechtste idee&euml;n ooit in de computerwetenschap.
<P>Onder Linux zijn er heel veel initialisatiebestanden te vinden, waar
je van een aantal maar beter af kunt blijven totdat je exact weet wat je
aan het doen bent; ze zijn te vinden in de
/etc directory. Alle configuratie kan worden gedaan door het
wijzigen van gewone tekstbestanden. Als je alleen 
het PATH en andere omgevingsvariabelen hoeft in te stellen, of je de
loginberichten wilt wijzigen of bij het inloggen automatisch een programma
op wilt laten starten, kijk dan eens naar de volgende bestanden:
<P>
<BLOCKQUOTE><CODE>
<PRE>
BESTANDEN                             OPMERKINGEN

/etc/issue                            instellen bericht voor inloggen
/etc/motd                             instellen bericht na inloggen
/etc/profile                          instellen $PATH en andere variabelen,enz
/etc/bashrc                           instellen aliassen en functies, enz
/home/je_home/.bashrc                 instellen van je aliassen + functies
/home/je_home/.bash_profile   of
/home/je_home/.profile                instellen omgeving + starten van
                                      programma's
</PRE>
</CODE></BLOCKQUOTE>
<P>Als het laatste bestand voorkomt (het is een verborgen bestand), zal het na
het inloggen worden ingelezen, en de commando's die erin staan zullen worden
uitgevoerd.
<P>Voorbeeld---kijk naar dit <CODE>.bash_profile</CODE> bestand:
<P>
<HR>
<PRE>
# Ik ben commentaar
echo Omgeving:
printenv | less   # equivalent aan commando SET onder DOS
alias d='ls -l'   # eenvoudig te begrijpen wat een alias is
alias up='cd ..'
echo "Ik herinner je eraan dat het pad gelijk is aan "$PATH
echo "Vandaag is het `date`"  # gebruik de uitvoer van het commando 'date'
echo "Prettige dag, "$LOGNAME
# Het volgende is een "shell functie"
ctgz() # Toon de inhoud van een .tar.gz archief.
{
  for file in $*
  do
    gzip -dc ${file} | tar tf -
  done
}         
# einde .profile
</PRE>
<HR>
<P><CODE>$PATH</CODE> en <CODE>$LOGNAME</CODE>, je raadde het goed,
zijn omgevingsvariabelen.
Er zijn nog veel anderen om mee te experimenteren; bijvoorbeeld, LMP
voor apps als <CODE>less</CODE> of <CODE>bash</CODE>.
<P>Door deze regel in je /etc/profile te plaatsen zal grofweg
worden voorzien in het equivalent van
<CODE>PROMPT $P$G</CODE>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
export PS1="\w\\$ "
</PRE>
</CODE></BLOCKQUOTE>
<H2>8.2 Programma initialisatiebestanden</H2>

<P>
<P>Onder Linux kan praktisch alles naar behoeften worden aangepast. 
Voor de meeste programma's zijn er &eacute;&eacute;n of meer 
initialisatiebestanden waar je wat mee kunt, vaak als een
<CODE>.prognaamrc</CODE> in je home-dir. De eerste die je daarvan wellicht zal
willen wijzigen zijn:
<P>
<UL>
<LI> <CODE> .inputrc</CODE>: gebruikt door <CODE>bash</CODE> voor het defini&euml;ren
van key bindings;</LI>
<LI> <CODE> .xinitrc</CODE>: gebruikt door <CODE>startx</CODE> voor het initialiseren
van het X Window System;</LI>
<LI> <CODE> .fvwmrc</CODE>: in gebruik door de window manager <CODE>fvwm</CODE>. </LI>
<LI> <CODE> .joerc, .jstarrc</CODE>: in gebruik door de editor <CODE>joe</CODE>;</LI>
<LI> <CODE> .jedrc</CODE>: in gebruik door de editor <CODE>jed</CODE>;</LI>
<LI> <CODE> .pinerc</CODE>: in gebruik door de mailreader <CODE>pine</CODE>;</LI>
<LI> <CODE> .Xdefault</CODE>: in gebruik door diverse X-programma's.</LI>
</UL>
<P>Je komt deze allemaal en nog anderen vroeg of laat tegen, LMP.
Misschien dat ik je kan interesseren voor de Configuratie HOWTO,
<A HREF="http://www.linuxdoc.org/HOWTO/Config-HOWTO.html">http://www.linuxdoc.org/HOWTO/Config-HOWTO.html</A>?
<H2><A NAME="s9">9. Netwerken: begrippen</A></H2>

<P>
<P>Niet alleen is ``Dialup Networking'' onder Linux beschikbaar, maar het
is ook nog eens stabieler en sneller. De naam hiervan is ``PPP'', het
protocol dat wordt gebruikt voor het maken van een verbinding met
het Internet met behulp van modems. Het enige wat je hiervoor nodig
hebt is een utility waarmee kan worden gebeld en de verbinding tot
stand kan worden gebracht.
<P>Om je mail vanaf de server van je ISP op te halen, heb je een tool genaamd
``email fetcher'' nodig welke het POP protocol gebruikt; wanneer de mail is
opgehaald, zal het lijken alsof het direct naar je Linux-box werd bezorgd.
Vervolgens gebruik je een MUA (Mail User Agent) zoals <CODE>pine</CODE>, 
<CODE>mutt</CODE>, <CODE>elm</CODE> of een van de vele anderen om het te beheren.
<P>Terwijl de dialer onder Windows automatisch wordt aangeroepen wanneer je
een Internet applicatie start, gaat het bij Linux net andersom: je belt
eerst, en vervolgens start je de applicatie op. 
Een ding genaamd <CODE>diald</CODE> voorziet in het gebruikelijke functioneren.
Het installeren en configureren van dialup networking was &eacute;&eacute;n
van de moeilijkste taken onder Linux, maar dit is niet meer zo:
raadpleeg alsjeblieft de Configuratie HOWTO.
<P>Als laatste, iets over ``Network neighborhood'': je kunt je Linux-box
als Windows NT/9x in een lokaal netwerk met Windows computers laten verschijnen.
Het magische woord is Samba: niet de levende Braziliaanse dans, maar een
implementatie van het SMB-protocol voor Linux.
Ga hiervoor naar 
<A HREF="http://samba.anu.edu.au/samba">http://samba.anu.edu.au/samba</A>.
<H2><A NAME="s10">10. Iets over programmeren</A></H2>

<H2><A NAME="Shell Scripts"></A> 10.1 Shell Scripts: .BATch bestanden </H2>

<P>
<P>Als je gewend was .BATch bestanden aan te maken als verkorte opdrachten voor
lange opdrachtregels (ik deed dit veel), kan dit doel worden bereikt door
de passende alias regels in <CODE>profile</CODE> of <CODE>.bash_profile</CODE>
in te voegen. Maar als je gecompliceerdere .BATch bestanden gebruikte,
dan zal je de scripttaal die beschikbaar is door de shell weten te 
waarderen: het is zo krachtig en goed als de oude QBasic, zo niet beter.
Het bevat variabelen, structuren zoals while, for, case, if... then...
else, en heel veel andere mogelijkheden: het kan een goed alternatief zijn
voor een ``echte'' programmeertaal.
<P>Voor het schrijven van een script---het equivalent van een .BATch bestand
onder DOS---hoef je slechts een standaard ASCII-bestand met de instructies
te schrijven, het op te slaan, en het vervolgens uitvoerbaar te maken
met het commando <CODE>chmod +x &lt;scriptfile></CODE>.
Typ de naam ervan in, om het uit te laten voeren.
<P>Een waarschuwing. De systeem editor wordt <CODE>vi</CODE> genoemd, en mijn
ervaring is dat nieuwe gebruikers het erg moeilijk in 't gebruik vinden.
Ik ga niet uitleggen hoe je het kunt gebruiken; raadpleeg alsjeblieft
Matt Welsh's boek of zoek naar een tutorial op het net.
Ik volsta met hier te zeggen dat:
<P>
<UL>
<LI>je een `i' intikt en dan je tekst, om tekst in te voegen;</LI>
<LI>je &lt;ESC&gt; dan `x' intikt, om tekens te verwijderen;</LI>
<LI>je typt  &lt;ESC&gt; dan <CODE>:q!</CODE>, om <CODE>vi</CODE> zonder opslaan
te verlaten;</LI>
<LI>typ &lt;ESC&gt; dan <CODE>:wq</CODE>, om op te slaan en te verlaten.</LI>
</UL>
<P>Een goede editor voor beginners is <CODE>joe</CODE>: start het programma door
<CODE>jstar</CODE> in te tikken.
je krijgt dezelfde key bindings als in de DOS/Win editor. 
<CODE>jed</CODE> in WordStar
of IDE mode is zelfs beter. Raadpleeg paragraaf 
<A HREF="#Programs">Waar kun je applicaties vandaan halen</A> om erachter te komen hoe je 
aan deze editors kunt komen.
<P>Het schrijven van scripts onder <CODE>bash</CODE> is zo'n veelomvattend onderwerp
dat hiervoor een volledig boek nodig zou zijn, en ik zal het onderwerp 
hier niet verder uitdiepen.
Ik geef je slechts een voorbeeld van een shellscript, 
van waaruit je enkele basisregels kunt halen:
<P>
<HR>
<PRE>
#!/bin/sh
# sample.sh
# Ik ben commentaar
# verander de eerste regel niet, deze moet hier aanwezig zijn
echo "Dit systeem is: `uname -a`" # gebruik de uitvoer van het commando
echo "Mijn naam is $0" # ingebouwde variabelen
echo "Je gaf me de volgende $# parameters: "$*
echo "De eerste parameter is: "$1
echo -n "Wat is je naam? " ; lees je je_naam
echo merk het verschil op: "hi $je_naam" # omsloten door "
echo merk het verschil op: 'hi $je_naam' # omsloten door '
DIRS=0 ; FILES=0
for file in `ls .` ; do
  if [ -d ${file} ] ; then # als het bestand een directory is
    DIRS=`expr $DIRS + 1`  # DIRS = DIRS + 1
  elif [ -f ${file} ] ; then
    FILES=`expr $FILES + 1`
  fi
  case ${file} in
    *.gif|*jpg) echo "${file}: grafisch bestand" ;;
    *.txt|*.tex) echo "${file}: tekstbestand" ;;
    *.c|*.f|*.for) echo "${file}: bronbestand" ;;
    *) echo "${file}: gewoon bestand" ;;
  esac
done
echo "er zijn ${DIRS} directory's en ${FILES} bestanden"
ls | grep "ZxY--%%WKW"
if [ $? != 0 ] ; then # exit code van laatste commando
  echo "ZxY--%%WKW niet gevonden"
fi
echo "genoeg... typ 'man bash' als je meer info wilt."
</PRE>
<HR>
<H2>10.2 C </H2>

<P>
<P>Onder UNIX is de systeemtaal C, hou ervan of haat het. Er zijn tevens nog
heel wat andere talen (Java, FORTRAN, Pascal, Lisp, Basic, Perl, awk...) 
beschikbaar.
<P>Aangenomen dat je bekend bent met C, zijn hier een aantal richtlijnen voor
degenen die verwend zijn met Turbo C++ of &eacute;&eacute;n van de DOS varianten. Linux's C
compiler wordt <CODE>gcc</CODE> genoemd en het mist alle toeters en bellen waar
gewoonlijk de DOS tegenhangers van vergezeld gaan:
geen IDE, on-line help, ge&iuml;ntegreerde debugger, enz.
Het is slechts een grove commandoregel compiler, erg krachig en effici&euml;nt.
Voor het compileren van je standaard <CODE>hello.c</CODE> geef je op:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ gcc hello.c
</PRE>
</CODE></BLOCKQUOTE>
<P>waarmee een uitvoerbaar bestand genaamd <CODE>a.out</CODE> zal worden aangemaakt.
Geef het uitvoerbare bestand een andere naam met
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ gcc -o hola hello.c
</PRE>
</CODE></BLOCKQUOTE>
<P>Om een library aan het programma te koppelen, voeg je de switch 
-l&lt;libname&gt; toe. Bijvoorbeeld, om de math library te linken:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ gcc -o mathprog mathprog.c -lm
</PRE>
</CODE></BLOCKQUOTE>
<P>(De <CODE>-l&lt;libname&gt;</CODE> switch forceert <CODE>gcc</CODE> de library 
<CODE>/usr/lib/lib&lt;libname&gt;.so</CODE> te koppelen; dus <CODE>-lm</CODE> koppelt 
<CODE>/usr/lib/libm.so</CODE>).
<P>Als je programma uit verschillende bronbestanden bestaat, zul je gebruik
moeten maken van de utility <CODE>make</CODE>. Laten we ervan uitgaan dat je een
expression parser hebt geschreven: het bronbestand heet <CODE>parser.c</CODE> en 
# bestaande uit twee header bestanden, <CODE>parser.h</CODE> en
<CODE>xy.h</CODE>. Dan wil je gebruik maken van de routines in <CODE>parser.c</CODE>
in een programma, stel <CODE>calc.c</CODE>, welke op zijn beurt bestaat uit
# <CODE>parser.h</CODE>. Wat moet je nu doen om <CODE>calc.c</CODE>
te compileren?
<P>Je zal een zogenoemde <CODE>Makefile</CODE> moeten schrijven, die de
compiler laat weten wat de afhankelijkheden tussen sources en object
bestanden zijn. In ons voorbeeld:
<P>
<P>
<HR>
<PRE>
# Dit is Makefile, gebruikt om calc.c te compileren
# Druk waar aangegeven op de &lt;TAB> toets!

calc: calc.o parser.o
&lt;TAB>gcc -o calc calc.o parser.o -lm
# calc rekent op twee objectbestanden: calc.o en parser.o

calc.o: calc.c parser.h
&lt;TAB>gcc -c calc.c
# calc.o rekent op twee bronbestanden

parser.o:  parser.c parser.h xy.h
&lt;TAB>gcc -c parser.c
# parser.o rekent op drie source bestanden

# einde Makefile.
</PRE>
<HR>
<P>Bewaar dit bestand als <CODE>Makefile</CODE> en typ <CODE>make</CODE> om je
programma te compileren; sla het alternatief op als
<CODE>calc.mak</CODE> en typ <CODE>make -f calc.mak</CODE>, en natuurlijk LMP.
Je kunt wat hulp krijgen over de C-functies die in man pages worden
behandeld, in sectie 3, bijvoorbeeld:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ man 3 printf
</PRE>
</CODE></BLOCKQUOTE>
<P>Gebruik voor het opsporen van fouten in je programma's <CODE>gdb</CODE>.
<CODE>info gdb</CODE> om te leren hoe je het kunt gebruiken.
<P>Er zijn heel veel library's beschikbaar; onder de eersten die je wellicht
wilt gebruiken bevinden zich 
<CODE>ncurses</CODE> (tekstmode effecten), en <CODE>svgalib</CODE> (console
graphics). Veel editors kunnen als IDE fungeren; <CODE>emacs</CODE> en <CODE>jed</CODE>,
bijvoorbeeld, hebben als feature syntax highlighting, automatisch inspringen,
enzovoort. Haal als alternatief het package
<CODE>rhide</CODE> op vanaf 
<A HREF="ftp://metalab.unc.edu:/pub/Linux/devel/debuggers/">ftp://metalab.unc.edu:/pub/Linux/devel/debuggers/</A>. Het is een
Borland IDE-kloon, en de kans bestaat dat het je bevalt.
<H2>10.3 X11 Programmeren</H2>

<P>Als je er wat voor voelt om met X11 programmering aan de slag te gaan
(zo moeilijk is het niet), bestaan er verscheidene library's waarmee het
schrijven van X11 programma's een makkie is.
De belangrijkste te bezoeken sites zijn die van GTK+, 
<A HREF="http://www.gtk.org">http://www.gtk.org</A>, and Qt, 
<A HREF="http://www.troll.no">http://www.troll.no</A>. Gtk+ is
een op C gebaseerde widget set oorspronkelijk ontworpen voor het grafische
pakket De GIMP (
<A HREF="http://www.gimp.org">http://www.gimp.org</A>), en het wordt gebruikt in
de Gnome omgeving. Kdeveloper is gebaseerd op de op C++ gebaseerde Qt, die
door KDE wordt gebruikt. Zeer waarschijnlijk zal je &eacute;&eacute;n van
deze library's gebruiken.
<P>Een aantal van de beste tools voor visueel programmeren zijn Kdevelop voor Qt,
<A HREF="http://www.kdevelop.org">http://www.kdevelop.org</A>, en Glade voor GTK+, 
<A HREF="http://glade.pn.org">http://glade.pn.org</A>. Deze pagina geeft meer informatie: 
<A HREF="http://www.free-soft.org/guitool/">http://www.free-soft.org/guitool/</A>.
<H3>Multi-Platform Programmering</H3>

<P>Zou het niet aardig zijn als je code zou kunnen schrijven die onder Linux
<EM>en</EM> Windows naadloos compileerde met gebruik van <CODE>gcc</CODE>?
Tijdens dit schrijven zijn er een aantal widget sets die een meer of
minder stabiele multi-platform programmering mogelijk maken.
Zover als het de stabiliteit als volledigheid echter betreft, zou ik
zeggen dat de keuze is beperkt tot praktisch &eacute;&eacute;n:
FLTK, de Fast Light Tool Kit 
<A HREF="http://www.fltk.org">http://www.fltk.org</A>. 
Het is verbazingwekkend klein, snel en stabiel. Het heeft tevens een
semi-visuele builder genaamd Fluid.
<H2><A NAME="s11">11. De resterende 1%</A></H2>

<P>
<P>Veel meer dan 1%, eigenlijk...
<H2>11.1 Draaien van DOS/Windows Apps</H2>

<P>
<P>Ja, tot op zekere hoogte kun je DOS en Windows applicaties onder Linux
draaien! Er zijn twee tamelijk goede emulators: Dosemu (
<A HREF="http://www.dosemu.org">http://www.dosemu.org</A>) en Wine (
<A HREF="http://www.winehq.com">http://www.winehq.com</A>).
De laatste wordt bij iedere release veel beter en de lijst met uit te voeren
applicaties wordt steeds groter. Zelfs Word en Excel draaien eronder!
<H2>11.2 Gebruik van tar en gzip</H2>

<P>
<P>Onder UNIX zijn een aantal veel gebruikte applicaties voor het archiveren
en comprimeren van bestanden.
<CODE>tar</CODE> wordt gebruikt om archieven te maken---het is als
<CODE>PKZIP</CODE> of <CODE>Winzip</CODE> maar comprimeert niet, het maakt alleen
archieven. Typ voor het maken van een archief:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ tar cvf &lt;archive_name.tar> &lt;file> [file...]
</PRE>
</CODE></BLOCKQUOTE>
<P>Voor het extraheren van bestanden uit een archief:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ tar xvf &lt;archive_name.tar> [file...]
</PRE>
</CODE></BLOCKQUOTE>
<P>Voor het tonen van de inhoud van een archief:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ tar tf &lt;archive_name.tar> | less
</PRE>
</CODE></BLOCKQUOTE>
<P>Met <CODE>compress</CODE>, welke verouderd is en niet meer gebruikt zou moeten
worden, of <CODE>gzip</CODE>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ compress &lt;file>
$ gzip &lt;file>
</PRE>
</CODE></BLOCKQUOTE>
<P>waarmee een gecomprimeerd bestand met de extensie <CODE>.Z</CODE> wordt aangemaakt
(<CODE>compress</CODE>) of <CODE>.gz</CODE> ( voor <CODE>gzip</CODE>). Deze programma's
kunnen slechts &eacute;&eacute;n bestand tegelijkertijd comprimeren.
Decomprimeren:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ compress -d &lt;file.Z>
$ gzip -d &lt;file.gz>
</PRE>
</CODE></BLOCKQUOTE>
<P>LMP.
<P>Er zijn ook nog de utility's <CODE>unarj</CODE>, <CODE>zip</CODE> en 
<CODE>unzip</CODE> (PK??ZIP
compatibele). Bestanden met de extensie <CODE>.tar.gz</CODE> of
<CODE>.tgz</CODE> (gearchiveerd met <CODE>tar</CODE>, en vervolgens gecomprimeerd
met <CODE>gzip</CODE>) zijn ook zeer algemeen in de UNIX-wereld net als .ZIP 
bestanden onder DOS.
Zo kun je de inhoud van een <CODE> .tar.gz</CODE> archief weer laten geven:
<P>
<BLOCKQUOTE><CODE>
<PRE>
$ tar ztf &lt;file.tar.gz> | less
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="Install"></A> 11.3 Applicaties installeren </H2>

<P>
<P>Ten eerste: het installeren van packages is het werk van root. De meeste
Linux applicaties worden als <CODE>.tar.gz</CODE> archief gedistribueerd, die
vaak bestaat uit een directory met waarschijnlijk de naam <CODE>pkgname/</CODE>, 
waarin de bestanden en/of subdirectory's staan. Het is een goede gewoonte 
om deze packages vanuit de directory <CODE>/usr/local</CODE> te installeren met 
het commando:
<P>
<BLOCKQUOTE><CODE>
<PRE>
# tar zxf &lt;archive.tar.gz>
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>en het README of INSTALL bestand te lezen. In de meeste gevallen worden
de bronbestanden van de applicatie gedistribueerd, wat inhoudt dat je het moet
compileren om de uitvoerbare bestanden aan te maken;
vaak is het al voldoende om <CODE>make</CODE> en daarna <CODE>make install</CODE> in 
te tikken. Uiteraard heb je hiervoor de <CODE>gcc</CODE> of <CODE>g++</CODE>
compiler nodig.
<P>Andere archieven moeten worden uitgepakt vanuit /; dit is het
geval met de <CODE>.tgz</CODE> archieven van Slackware.
In andere archieven bevinden zich bestanden, maar dan zonder subdirectory
- pas op dat je de boel niet verknoeit!
Bekijk altijd de inhoud van het archief voordat je het installeert.
<P>De Debian en Red Hat distributies hebben hun eigen archief formaat;
respectievelijk, <CODE>.deb</CODE> en <CODE>.rpm</CODE>. De laatste wint een brede
acceptatie; om een <CODE>.rpm</CODE> package te installeren, tik je in:
<P>
<BLOCKQUOTE><CODE>
<PRE>
# rpm -i package.rpm
</PRE>
</CODE></BLOCKQUOTE>
<H2>11.4 Tips waar je niet zonder kunt</H2>

<P>
<P><B>Terugscrollen</B>: het indrukken van &lt;SHIFT + PAG UP&gt; (de grijze
toets) maakt dat je een paar pagina's terug kunt scrollen, afhankelijk van 
de hoeveelheid van het videogeheugen.
<P><B>Resetten van het scherm</B>: als je met <CODE>more</CODE> of <CODE>cat</CODE>
een binair bestand bekijkt, dan kan het gebeuren dat je scherm vol met rommel
staat. Om dit te herstellen, tik dan blind <CODE>reset</CODE> in of de volgende
reeks met tekens: <CODE>echo CTRL-V ESC c RETURN</CODE>.
<P><B>Het plakken van tekst</B>: in console, zie hieronder; in X, klik
en sleep om de tekst in een <CODE>xterm</CODE> window te selecteren, druk dan
de middelste muisknop in (of de twee muisknoppen samen als je een twee-knops
muis hebt) om de tekst te plakken. Er is ook een <CODE>xclipboard</CODE>
(helaas, alleen voor tekst); laat je niet in de war brengen door de zeer
trage response.
<P><B>Gebruik van de muis</B>: als je <CODE>gpm</CODE>, een mousedriver voor de
console, hebt ge&iuml;nstalleerd, dan kun je klikken en slepen om tekst te
selecteren, en vervolgens (op een andere plaats) de rechtermuisknop indrukken
om de geselecteerde tekst te plakken. Dit werkt ook door in de ene VC tekst te
selecteren en deze in een andere VC te plakken.
<P><B>Meldingen van de kernel</B>: kijk als root in <CODE>/var/adm/messages</CODE> of
<CODE>/var/log/messages</CODE> om te zien wat de kernel je te melden heeft,
inclusief de meldingen bij het opstarten. 
Het commando <CODE>dmesg</CODE> is ook handig.
<H2><A NAME="Programs"></A> 11.5 Waar vind ik applicaties</H2>

<P>
<P>Als je je afvraagt of je je oude en vertrouwde DOS/Win applicatie door
een Linux applicatie kunt vervangen, raad ik je aan eens naar de belangrijkste
Linux software opslagplaats te surfen:
<A HREF="ftp://metalab.unc.edu/pub/Linux">ftp://metalab.unc.edu/pub/Linux</A>. Andere goede
startplaatsen zijn de ``Linux Applications and Utilities Page'' 
<A HREF="http://www.xnet.com/~blatura/linapps.shtml">http://www.xnet.com/~blatura/linapps.shtml</A>, de ``offici&euml;le'' Linux
page 
<A HREF="http://www.linux.org">http://www.linux.org</A>, en 
<A HREF="http://freshmeat.net">http://freshmeat.net</A>.
<H2>11.6 Een aantal dingen die je niet kon doen</H2>

<P>
<P>Linux kan verschrikkelijk veel dat onder DOS/Windows omslachtig, moeilijk
of onmogelijk was. Hier is een beknopte lijst om de smaak te pakken te
krijgen:
<P>
<UL>
<LI> <CODE>at</CODE> maakt het mogelijk programma's op bepaalde tijden
uit te voeren:</LI>
<LI> <CODE>awk</CODE> is een eenvoudige maar krachtige taal om gegevensbestanden
te manipuleren (en niet alleen dat). 
Als bijvoorbeeld <CODE>data.dat</CODE> je uit meerdere velden bestaande
gegevensbestand is, drukt

<BLOCKQUOTE><CODE>
<PRE>
$ awk '$2 ~ "abc" {print $1, "\t", $4}' data.dat
</PRE>
</CODE></BLOCKQUOTE>


de velden 1 en 4 van iedere regels in <CODE>data.dat</CODE> af waarvan het
tweede veld de string ``abc'' bevat.</LI>
<LI> <CODE>cron</CODE> is nuttig voor het periodiek uitvoeren van taken,
op opgegeven datum en tijd. Typ <CODE>man 5 crontab</CODE>.</LI>
<LI> <CODE>file &lt;bestandsnaam&gt;</CODE> vertelt je wat <CODE>bestandsnaam</CODE>
voor een soort bestand is
(ASCII-tekst, uitvoerbaar bestand, archief, enz.);</LI>
<LI> <CODE>find</CODE> (zie tevens sectie 
<A HREF="#Directories: Trans">Directory's: Commando's vertalen</A>) is &eacute;&eacute;n van de
krachtigste en handigste commando's.
Het wordt gebruikt om naar bestanden te zoeken die voldoen aan verscheidene
karakteristieken en waarop acties kunnen worden uitgevoerd. Algemeen gebruik
van <CODE>find</CODE> is:

<BLOCKQUOTE><CODE>
<PRE>
$ find &lt;directory> &lt;expressie>
</PRE>
</CODE></BLOCKQUOTE>


&lt;expressie&gt; bevat zoekcriteria en acties. Voorbeelden:

<BLOCKQUOTE><CODE>
<PRE>
$ find . -type l -exec ls -l {} \;
</PRE>
</CODE></BLOCKQUOTE>


zoekt naar alle bestanden welke symbolische koppelingen zijn en geeft aan
waarnaar ze verwijzen.

<BLOCKQUOTE><CODE>
<PRE>
$ find / -name "*.old" -ok rm {} \;
</PRE>
</CODE></BLOCKQUOTE>


zoekt naar alle bestanden die overeenkomen met het patroon het verwijdert ze,
waarbij eerst om bevestiging wordt gevraagd.

<BLOCKQUOTE><CODE>
<PRE>
$ find . -perm +111
</PRE>
</CODE></BLOCKQUOTE>


zoekt naar alle bestanden waarvan de permissies overeenkomen met 111 
(uitvoerbaar bestand).

<BLOCKQUOTE><CODE>
<PRE>
$ find . -user root
</PRE>
</CODE></BLOCKQUOTE>


zoekt naar alle bestanden die aan root toebehoren. Heel veel mogelijkheden
hier---LMP.</LI>
<LI> <CODE>grep</CODE> zoekt naar tekstpatronen in bestanden. Bijvoorbeeld,

<BLOCKQUOTE><CODE>
<PRE>
$ grep -l "geology" *.tex
</PRE>
</CODE></BLOCKQUOTE>


toont de *.tex bestanden waarin het woord ``geology'' voorkomt. Een variant
op grep genaamd <CODE>zgrep</CODE> werkt op gzipped bestanden. LMP;</LI>
<LI> <B>reguliere expressies</B> zijn complex maar het is een zeer krachtige
manier om zoekbewerkingen op tekst uit te voeren. Bijvoorbeeld:
<CODE>^a[^a-m]X{4,}txt$</CODE> komt overeen met een regel welke begint met een
`a', gevolgd door een willekeurig teken behalve die in het interval a-m,
gevolgd door 4 of meer `X' tekens en eindigt op `txt'.
Reguliere expressies gebruik je met geavanceerde editors,
<CODE>less</CODE>, en vele andere applicaties. <CODE>man grep</CODE> voor
een introductie.</LI>
<LI> <CODE>script &lt;script_file&gt;</CODE> dumpt de inhoud van het scherm
in een scriptbestand genaamd <CODE>script_file</CODE> totdat je het commando
<CODE>exit</CODE> geeft. Handig voor het opsporen van fouten;</LI>
<LI> <CODE>sudo</CODE> maakt het gebruikers mogelijk een aantal van de
taken van root uit te voeren (b.v. het formatteren en mounten van disks;LMP);</LI>
<LI> <CODE>uname -a</CODE> geeft je info over je systeem;</LI>
<LI> <CODE>zcat</CODE> en <CODE>zless</CODE> zijn handig voor het doorbladeren
en omleiden van met gzip gecomprimeerde bestanden zonder ze te 
decomprimeren. Bijvoorbeeld:

<BLOCKQUOTE><CODE>
<PRE>
$ zless textfile.gz
$ zcat textfile.gz | lpr
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI> De volgende commando's komen vaak van pas: <CODE>bc, cal, chsh, cmp,
cut, fmt, head, hexdump, nl, passwd, printf, sort, split, strings, tac,
tail, tee, touch, uniq, w, wall, wc, whereis, write, xargs, znew.</CODE> LMP.</LI>
</UL>
<H2>11.7 UNIX oefenen onder DOS/Win</H2>

<P>
<P>Geloof het of niet, er zijn prima tools die voorzien in een op UNIX lijkende
omgeving onder DOS/Windows! Een daarvan is de Djgpp suite (
<A HREF="http://www.delorie.com/djgpp/">http://www.delorie.com/djgpp/</A>) voor DOS, en Cygwin (
<A HREF="http://www.cygnus.com/cygwin">http://www.cygnus.com/cygwin</A>) is een complexere port voor Win32. 
In beiden zijn dezelfde GNU ontwikkelaars tools en utility's als Linux
opgenomen; je krijgt echter niet dezelfde stabiliteit en performance.
<P>Probeer Djgpp als je de smaak van Linux te pakken wilt krijgen. Download
en installeer de volgende bestanden (tijdens dit schrijven, is de laatste
versie 2.0.2):
<CODE>djdev202.zip, bnu281b.zip, bsh1147b.zip, fil316b.zip, find41b.zip,
grep22b.zip, gwk303b.zip, lss332b.zip, shl112b.zip.</CODE>. In installatie
instructies is voorzien, en je kunt assistentie vinden op
<A HREF="news:comp.os.msdos.djgpp">news:comp.os.msdos.djgpp</A>.
<P>In het bijzonder is het gebruik van <CODE>bash</CODE> onder DOSWin een
opluchting. Om het op je juiste wijze te configureren, wijzig je het
meegeleverde bestand <CODE>BOOT.BAT</CODE> om je installatie weer te
geven, plaats deze bestanden dan in je home-directory (in de 
Windows partitie) in plaats van degene waarin is voorzien:
<P>
<BLOCKQUOTE><CODE>
<PRE>
# dit is _bashrc

LS_OPTIONS="-F -s --color=yes"
alias cp='cp -i'
alias d='ls -l'
alias l=less
alias ls="ls $LS_OPTIONS"
alias mv='mv -i'
alias rm='rm -i'
alias u='cd ..'
</PRE>
</CODE></BLOCKQUOTE>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# dit is _bprof
if [ -f ~/_bashrc ]; then
  . ~/_bashrc
fi
PS1='\w\$ '
PS2='> '
CDPATH="$CDPATH:~"
# stuff for less(1)
LESS="-M-Q"                     # lange prompt, stil
LESSEDIT="%E ?lt+%lt. %f"       # wijzig eerste regel
VISUAL="jed"                    # editor
LESSCHARSET=latin1              # toon geaccentueerde letters
export PS1 PS2 CDPATH LS_OPTIONS LESS LESSEDIT LESSOPEN VISUAL LESSCHARSET
</PRE>
</CODE></BLOCKQUOTE>
<H2>11.8 Algemene extensies en daaraan gerelateerde programma's</H2>

<P>
<P>Je komt mogelijk heel wat soorten bestandsextensies tegen. Uitgezonderd de
meer exotische extensies
(d.w.z. fonts, enz.), tref je hier een lijst van aan:
<P>
<UL>
<LI> <CODE>1 ... 8</CODE>: man pages. Lees ze met
<CODE>groff -Tascii -man &lt;file.1&gt;</CODE>.</LI>
<LI> <CODE>arj</CODE>: archief aangemaakt met <CODE>arj</CODE>.</LI>
<LI> <CODE>dvi</CODE>: uitvoerbestand geproduceerd met TeX (zie hieronder).
<CODE>xdvi</CODE> om het te bekijken; <CODE>dvips</CODE> om het om te zetten in
een PostScript <CODE>.ps</CODE> bestand.</LI>
<LI> <CODE>gz</CODE>: archief gemaakt met <CODE>gzip</CODE>.</LI>
<LI> <CODE>info</CODE>: info bestand (soort alternatief van man pages). Haal
hier <CODE>info</CODE> voor op.</LI>
<LI> <CODE>lsm</CODE>: Linux Software Map bestand. Het is een gewoon ASCII
bestand met de beschrijving van een package.</LI>
<LI> <CODE>ps</CODE>: PostScript bestand. Haal voor het bekijken of afdrukken
<CODE>gs</CODE> op en optioneel <CODE>ghostview</CODE> of <CODE>gv</CODE>.</LI>
<LI> <CODE>rpm</CODE>: Red Hat package. Je kunt het op ieder systeem installeren
met de package manager <CODE>rpm</CODE>.</LI>
<LI> <CODE>taz, tar.Z</CODE>: archief aangemaakt met <CODE>tar</CODE> en
gecomprimeerd met <CODE>compress</CODE>.</LI>
<LI> <CODE>tgz, tar.gz</CODE>: archief gemaakt met <CODE>tar</CODE> en
gecomprimeerd met <CODE>gzip</CODE>.</LI>
<LI> <CODE>tex</CODE>: tekstbestand voor TeX, een krachtige zetsysteem.
Het package <CODE>tex</CODE> is in diverse distibuties beschikbaar.</LI>
<LI> <CODE>texi</CODE>: texinfo bestand, kan zowel TeX als info bestanden
produceren (cp. <CODE>info</CODE>). Haal <CODE>texinfo</CODE> op.</LI>
<LI> <CODE>xbm, xpm, xwd</CODE>: grafisch bestand.</LI>
<LI> <CODE>Z</CODE>: archief aangemaakt met <CODE>compress</CODE>.</LI>
</UL>
<H2>11.9 Bestanden converteren</H2>

<P>
<P>Als je tekstbestanden tussen DOS/Win en Linux uit moet wisselen, wees je
dan bewust van het ``einde regel'' probleem. Onder DOS eindigt iedere
regel tekst op een CR/LF (dat is een ASCII 13 + ASCII 10), onder Linux
op een LF. Als je een DOS tekstbestand onder Linux wijzigt, zal iedere
regel zeer waarschijnlijk op een vreemd--uitziend `M' teken eindigen;
een Linux tekstbestand zal onder DOS verschijnen als een kilometers lange
enkele regel zonder alinea's. Er zijn een aantal tools, <CODE>dos2unix</CODE> en
<CODE>unix2dos</CODE>, om de bestanden te converteren.
<P>Als je bestanden bestaande uit alleen tekst geaccentueerde tekens bevat,
zorg er dan voor dat ze onder Windows (met Notepad/Kladblok) zijn
aangemaakt en niet onder gewoon DOS; anders zullen alle
geaccentueerde tekens zijn verknald.
<H2>11.10 Vrij verkrijgbare Office Suites</H2>

<P>
<P>Ja, je kunt voor niks krijgen wat anders heel veel geld zou kosten!
<P>StarOffice (
<A HREF="http://www.sun.com/staroffice">http://www.sun.com/staroffice</A>.) is thans de
enige keuze, alhoewel Koffice in de pijplijn zit (
<A HREF="http://www.koffice.org">http://www.koffice.org</A>). StarOffice is groot en traag, maar hoe dan
ook erg goed; het biedt heel veel functionaliteit die niet in Microsoft
Office is te vinden. Het kan bovendien Word en Excel bestanden inlezen,
alhoewel de conversie niet altijd perfect is.
<P>Een ander goed package is Corel WordPerfect, een vrij verkrijgbare uitgave
die voor download beschikbaar is. Moet ik nog meer zeggen? Haal het op:
<A HREF="http://www.corel.com">http://www.corel.com</A>.
<H2><A NAME="The End"></A> <A NAME="s12">12. Voor het moment, het einde </A></H2>

<P>
<P>Gefeliciteerd! Je hebt nu een klein beetje van UNIX begrepen en bent zover
om ermee beginnen te werken. Denk eraan dat je kennis van het systeem nog
steeds beperkt is en dat ervan je wordt verwacht meer met Linux te oefenen
om het comfortabel te kunnen gebruiken. Maar als het enige dat je moest doen
een boel applicaties te verkrijgen en ermee beginnen te werken, dan is alles
wat ik hierin heb opgenomen voldoende.
<P>Ik ben er zeker van dat je Linux met plezier zal gaan gebruiken en er meer
over zal gaan leren -- iedereen doet dit.
Ik wed ook dat je nooit meer naar DOS/Win terug zal keren! Ik hoop dat ik
duidelijk ben geweest en de 3 of 4 lezers een goede dienst heb bewezen.
<H2>12.1 Copyright</H2>

<P>
<P>Copyright (c) door Guido Gonzato, <CODE>ggonza at tin.it</CODE>. Dit document
mag alleen onder de voorwaarden en condities uiteengezet in de LDP
Licentie op 
<A HREF="http://www.linuxdoc.org/COPYRIGHT.html">http://www.linuxdoc.org/COPYRIGHT.html</A> worden
gedistribueerd, behalve dat dit document niet in gewijzigde vorm mag
worden gedistribueerd zonder toestemming van de auteur.
<P>Raadpleeg alsjeblieft de Linux Documentatie Project homepage, 
<A HREF="http://www.linuxdoc.org">http://www.linuxdoc.org</A>, als je vragen hebt.
<H2>12.2 Disclaimer</H2>

<P>Dit document wordt zoals het is geleverd. Ik heb er veel moeite voor
gedaan het zo accuraat mogelijk te schrijven, maar je gebruikt de
informatie hierin op eigen risico. In geen geval zal ik verantwoordelijk
kunnen worden gesteld voor enige schade voortvloeiend uit het gebruik
van dit werk.
<P>Veel dank aan Matt Welsh, de auteur van ``Linux Installation and Getting
Started'', aan Ian Jackson, de auteur van ``Linux frequently asked questions
with answers'', aan Giuseppe Zanetti, de auteur van het boek ``Linux'', aan
alle mensen die me aanbevelingen mailden, en vooral aan Linus Torvalds
en GNU die ons Linux gaven.
<P>Feedback is welkom. Neem gerust contact met me op voor verzoeken,
aanbevelingen, flames, enz.
<P>Veel plezier met Linux en in 't leven,
<P>Guido   <CODE>=8-)</CODE>
</BODY>
</HTML>
