<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.7">
 <TITLE>The Linux Tips HOWTO: Petunjuk Singkat</TITLE>
 <LINK HREF="ID-Tips-HOWTO-3.html" REL=next>
 <LINK HREF="ID-Tips-HOWTO-1.html" REL=previous>
 <LINK HREF="ID-Tips-HOWTO.html#toc2" REL=contents>
</HEAD>
<BODY>
<A HREF="ID-Tips-HOWTO-3.html">Next</A>
<A HREF="ID-Tips-HOWTO-1.html">Previous</A>
<A HREF="ID-Tips-HOWTO.html#toc2">Contents</A>
<HR>
<H2><A NAME="s2">2. Petunjuk Singkat</A></H2>

<H2><A NAME="ss2.1">2.1 Trik Syslog yang berguna <I>Paul Anderson, Tips-HOWTO maintainer</I></A>
</H2>

<P>Suntinglah /etc/syslog.conf, dan letakkan baris berikut:
<BLOCKQUOTE><CODE>
<PRE>
# Dump everything on tty8
*.*                                     /dev/tty8
</PRE>
</CODE></BLOCKQUOTE>

Harap diingat: <I>JANGAN LUPA UNTUK MENGGUNAKAN TAB!</I>  syslog tidak menyukai 
spasi...
<P>
<H2><A NAME="ss2.2">2.2 Script untuk melihat isi HOWTO yang dipadatkan (compressed). <I>Didier Juges,</I> <CODE>dj@destin.nfds.net</CODE></A>
</H2>

<P>
<P>Dari pendatang baru dan seterusnya, ini adalah script singkat yang memudahkan 
mencari dan melihat dokumen-dokumen HOWTO.
Berkas-berkas HOWTO terletak di /usr/doc/faq/howto/ dan dipadatkan dengan gzip. 
Nama-nama berkas ialah XXX-HOWTO.gz, di mana XXX adalah subjek dari HOWTO.
Penulis membuat script berikut yang dinamakan "howto" di direktori 
/usr/local/sbin
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#!/bin/sh
if [ "$1" = "" ]; then
    ls /usr/doc/faq/howto | less
else
    gunzip -c /usr/doc/faq/howto/$1-HOWTO.gz | less
fi
</PRE>
<HR>
</CODE></BLOCKQUOTE>

Ketika dijalankan tanpa menyertakan argumen, script ini akan menampilkan 
sebuah direktori berisi HOWTO yang ada. Kemudian ketika disertakan subjek 
dari HOWTO (bagian depan dari nama berkas sebelum tanda hubung) sebagai 
argumen, maka akan meng-unzip (tanpa mengubah berkas asli) dan menampilkan 
isi dokumen tersebut.
<P>Sebagai contoh, untuk melihat dokumen Serial-HOWTO.gz, masukkan:
<P>$ howto Serial
<P>
<P>
<H2><A NAME="ss2.3">2.3 Apakah ada cukup tempat di hard disk??? <I>Hans Zoebelein,</I> <CODE>zocki@goldfish.cube.net</CODE></A>
</H2>

<P>Berikut ini adalah sebuah script singkat yang akan mengecek secara berkala
apakah ada cukup tempat kosong yang tersedia di semua yang ditampilkan oleh 
mount (disks, cdrom, floppy...)
<P>Jika kehabisan tempat kosong, sebuah pesan akan ditampilkan di layar 
setiap X detik dan juga akan dikirim 1 e-mail untuk masing-masing device 
yang penuh.
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#!/bin/sh

#
# $Id: check_hdspace,v 1.18 1996/12/11 22:33:29 root Exp root $
#

#
# Since I got mysterious error messages during compile when
# tmp files filled up my disks, I wrote this to get a warning
# before disks are full.
#
# If this stuff saved your servers from exploding,
# send praising email to zocki@goldfish.cube.net.
# If your site burns down because of this, sorry but I
# warned you: no comps.
# If you really know how to handle sed, please forgive me :)
#

#
# Shoot and forget: Put 'check_hdspace &amp;' in rc.local.
# Checks for free space on devices every $SLEEPTIME sec.
# You even might check your floppies or tape drives. :)
# If free space is below $MINFREE (kb), it will echo a warning
# and send one mail for each triggering device to $MAIL_TO_ME.
# If there is more free space than trigger limit again,
# mail action is also armed again.
#

# TODO: Different $MINFREE for each device.
# Free /*tmp dirs securely from old junk stuff if no more free space.


DEVICES='/dev/sda2 /dev/sda8 /dev/sda9'         # device; your put disks here
MINFREE=20480                                   # kb; below this do warning
SLEEPTIME=10                                    # sec; sleep between checks
MAIL_TO_ME='root@localhost'                     # fool; to whom mail warning


# ------- no changes needed below this line (hopefully :) -------

MINMB=0
ISFREE=0
MAILED=""
let MINMB=$MINFREE/1024         # yep, we are strict :)

while [ 1 ]; do
        DF="`/bin/df`"
                for DEVICE in $DEVICES ; do
                ISFREE=`echo $DF | sed s#.\*$DEVICE" "\*[0-9]\*""\*[0-9]\*" "\*## | sed s#" ".\*##`
                
                if [ $ISFREE -le $MINFREE ] ; then
                        let ISMB=$ISFREE/1024
                        echo  "WARNING: $DEVICE only $ISMB mb free." >&amp;2
                        #echo "more stuff here" >&amp;2
                        echo -e "\a\a\a\a"
                        
                        if [ -z  "`echo $MAILED | grep -w $DEVICE`" ] ; then
                                echo "WARNING: $DEVICE only $ISMB mb free.      (Trigger is set to $MINMB mb)" \
                                | mail -s "WARNING: $DEVICE only $ISMB mb free!" $MAIL_TO_ME
                                MAILEDH="$MAILED $DEVICE"
                                MAILED=$MAILEDH
                                # put further action here like cleaning
                                # up */tmp dirs...
                        fi
                        elif [ -n  "`echo $MAILED | grep -w $DEVICE`" ] ; then
                                # Remove mailed marker if enough disk space
                                # again. So we are ready for new mailing action.
                                MAILEDH="`echo $MAILED  | sed s#$DEVICE##`"
                                MAILED=$MAILEDH
                        fi
                        
                done
                sleep $SLEEPTIME

done
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>
<P>
<H2><A NAME="ss2.4">2.4 Utilitas untuk membersihkan berkas-berkas log. <I>Paul Anderson, Tips-HOWTO Maintainer</I>></A>
</H2>

<P>Jika Anda seperti penulis, Anda punya list dengan 250 pelanggan, ditambah lagi 
100+ e-mail per hari datang lewat UUCP.  Jadi, apa yang akan dilakukan oleh 
hacker dengan log-log yang besar ini? Pasang chklogs, itulah yang seharusnya 
dilakukan. Chklogs ditulis oleh Emilio Grimaldo, <CODE>grimaldo@panama.iaehv.nl</CODE>, 
dan versi terbaru ialah 1.8 yang bisa didapat dari 
<A HREF="ftp.iaehv.nl:/pub/users/grimaldo/chklogs-1.8.tar.gz">ftp.iaehv.nl:/pub/users/grimaldo/chklogs-1.8.tar.gz</A>.
Tidak perlu banyak penjelasan untuk memasang chklogs (tentu saja Anda akan 
membaca info di subdirektori doc). Jika chklogs sudah terpasang dengan benar, 
tambahkan yang berikut ini di crontab:
<BLOCKQUOTE><CODE>
<PRE>
# Run chklogs at 9:00PM daily.
00 21 * * *       /usr/local/sbin/chklogs -m
</PRE>
</CODE></BLOCKQUOTE>

Sambil lalu, sampaikan kepada penulis chklogs betapa bagusnya program ini :)
<P>
<P>
<H2><A NAME="ss2.5">2.5 Script untuk membersihkan berkas-berkas core. <I>Otto Hammersmith,</I></A>
<CODE>ohammers@cu-online.com</CODE></H2>

<P>Buat berkas bernama rmcores (penulisnya menyebutnya handle-cores) yang berisi:
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#!/bin/sh
USAGE="$0 &lt;directory> &lt;message-file>"

if [ $# != 2 ] ; then
        echo $USAGE
        exit
fi

 echo Deleting...
find $1 -name core -atime 7 -print -exec rm {} \;

echo e-mailing
for name in `find $1 -name core -exec ls -l {} \; | cut -c16-24`
do
        echo $name
        cat $2 | mail $name
done
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>Dan buatlah sebuah cron job yang menjalankannya setiap beberapa saat tertentu.
<P>
<P>
<H2><A NAME="ss2.6">2.6 Memindahkan direktori-direktori antar filesystem. <I>Alan Cox,</I> <CODE>A.Cox@swansea.ac.uk</CODE></A>
</H2>

<P>Sebuah cara cepat untuk memindahkan seluruh direktori beserta isinya 
dari satu disk ke disk yang lain:
<BLOCKQUOTE><CODE>
<PRE>
(cd /source/directory &amp;&amp; tar cf - . ) | (cd /dest/directory &amp;&amp; tar xvfp -)
</PRE>
</CODE></BLOCKQUOTE>

<I>[ Gantilah dari cd /source/directory; tar....dst.  untuk menghindari 
kemungkinan terjadinya penghapusan direktori secara tidak sengaja atau 
terjadinya bencana. Terima kasih kepada Jim Dennis, jadestar@rahul.net, 
yang memberitahu penulis. ]</I>
<P>
<H2><A NAME="ss2.7">2.7 Mengetahui direktori yang berukuran terbesar. <I>Mick Ghazey,</I></A>
<CODE>mghazey@miso.lowdown.com</CODE></H2>

<P>Pernahkan terpikir untuk mengetahui direktori mana yang terbesar ukurannya? 
Berikut ini adalah sebuah caranya.
<BLOCKQUOTE><CODE>
<PRE>
du -S | sort -n
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss2.8">2.8 The Linux Gazette</A>
</H2>

<P>Pujian untuk John Fisk, pembuat The Linux Gazette.  Ini adalah sebuah majalah 
elektornik (e-zine) plus, dan <B>GRATIS!!!</B>  Nah, apa lagi yang bisa anda 
harapkan?  Silakan dilihat di:
<BLOCKQUOTE><CODE>
<PRE>
http://www.ssc.com/lg
</PRE>
</CODE></BLOCKQUOTE>

Untuk informasi Anda, (1) LG sekarang terbit bulanan, dan (2) LG bukan lagi 
diurus oleh John Fisk, melainkan orang-orang dari SSC.
<P>
<P>
<H2><A NAME="ss2.9">2.9 Petunjuk untuk memperbaiki GNU Make 3.70: mengubah cara VPATH berlaku.</A>
<I>Ted Stern,</I> <CODE>stern@amath.washington.edu</CODE></H2>

<P>Penulis tidak tahu apakah banyak orang yang mengalami hal yang sama, tetapi 
ada "feature" dari GNU Make version 3.70 yang tidak disukai penulis, ialah 
VPATH berlaku aneh jika diberikan pathname yang absolut. Ada patch yang 
sangat baik yang bisa memperbaiki hal ini, Anda bisa mendapatkannya dari 
Paul D. Smith <CODE>&lt;psmith@wellfleet.com></CODE>.  Beliau juga mengirimkan
dokumentasi dan patch setiap setelah revisi dari GNU Make di newsgroup 
'gnu.utils.bug'.
Pada umumnya, penulis menggunakan patch ini dan meng-compile ulang gmake 
di setiap sistem di mana penulis mempunyai akses.
<P>
<H2><A NAME="ss2.10">2.10 Bagaimana cara memberhentikan fsck pada setiap kali reboot? <I>Dale Lutz,</I> <CODE>dal@wimsey.com</CODE></A>
</H2>

<P>Q:  Bagaimana cara memberhentikan e2fsck mengecek disk saya setiap kali 
saya boot?
<P>A:  Ketika anda membangun ulang kernel, filesystem diberi tanda 'kotor' dan
disk Anda akan dicek pada setiap boot. Untuk memperbaikinya, jalankan:
<P>rdev -R /zImage 1
<P>Ini akan memperbaiki kernel supaya kernel percaya bahwa filesystem 
tidak 'kotor' lagi.
<P><EM>Catatan: jika menggunakan lilo, maka tambahkan </EM><CODE>read-only</CODE> <EM>pada 
linux setup di berkas konfigurasi lilo Anda (biasanya /etc/lilo.conf) </EM>
<P>
<H2><A NAME="ss2.11">2.11 Bagaimana menghindari fsck yang disebabkan oleh "device busy" pada saat reboot. <I>Jon Tombs,</I> <CODE>jon@gtex02.us.es</CODE></A>
</H2>

<P>Jika Anda sering mengalami kesalahan "device busy" pada saat shutdown yang 
menyebabkan filesystem membutuhkan fsck pada saat reboot, berikut ini ada 
cara mudah untuk memperbaikinya:
<P>Tambahkan baris berikut pada <CODE>/etc/rc.d/init.d/halt</CODE> atau <CODE>/etc/rc.d/rc.0</CODE>
<BLOCKQUOTE><CODE>
<PRE>
mount -o remount,ro /mount.dir
</PRE>
</CODE></BLOCKQUOTE>

untuk semua filesystem yang di-mount kecuali /, sebelum menjalankan 
umount -a. Ini berarti, jika untuk suatu alasan, shutdown tidak bisa 
membunuh semua proses dan umount semua disk, semuanya akan masih bersih 
sewaktu reboot. Bagi penulis hal ini dapat menghemat waktu banyak.
<P>
<P>
<H2><A NAME="ss2.12">2.12 Cara untuk menemukan berkas berukuran terbesar di hard-drive Anda.</A>
</H2>

<P><I>Simon Amor,</I> <CODE>simon@foobar.co.uk</CODE>
<P>
<BLOCKQUOTE><CODE>
<PRE>
ls -l | sort +4n
</PRE>
</CODE></BLOCKQUOTE>
<P>Atau, bagi Anda sekalian yang kekurangan tempat kosong, ini agak memakan 
waktu tetapi bisa berjalan dengan baik:
<P>
<BLOCKQUOTE><CODE>
<PRE>
cd /
ls -lR | sort +4n
</PRE>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss2.13">2.13 Cara mencetak supaya kertas bisa dilubangi di bagian tepi. <I>Mike Dickey,</I> <CODE>mdickey@thorplus.lib.purdue.edu</CODE></A>
</H2>

<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
        #!/bin/sh
        # /usr/local/bin/print
        # a simple formatted printout, to enable someone to
        # 3-hole punch the output and put it in a binder

        cat $1 | pr -t -o 5 -w 85 | lpr
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss2.14">2.14 Sebuah cara untuk mencari dengan regular expression di antara berkas-berkas. <I>Raul Deluth Miller,</I> <CODE>rockwell@nova.umd.edu</CODE></A>
</H2>

<P>Penulis memberi nama script ini 'forall'. Cara penggunaannya sebagai berikut:
<BLOCKQUOTE><CODE>
<PRE>
forall /usr/include grep -i ioctl
forall /usr/man grep ioctl
</PRE>
</CODE></BLOCKQUOTE>

Berikut ini adalah script forall:
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#!/bin/sh
if [ 1 = `expr 2 \> $#` ]
then
        echo Usage: $0 dir cmd [optargs]
        exit 1
fi
dir=$1
shift
find $dir -type f -print | xargs "$@"
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss2.15">2.15 Sebuah script untuk membersihkan berkas autosave dan backup yang dibuat oleh program.<I>Barry Tolnas,</I> <CODE>tolnas@nestor.engr.utk.edu</CODE></A>
</H2>

<P>Berikut adalah script dua baris yang secara rekursif menjelajahi hirarki 
dari sebuah direktori dan menghapus berkas-berkas autosave (#) dan 
backup (~) dari emacs, berkas-berkas berakhiran .o, dan berkas-berkas 
berakhiran .log dari TeX. Script ini juga memadatkan (compress) berkas-berkas 
berakhiran .tex dan berkas-berkas README. Penulis memberi nama 'squeeze' 
untuk script ini pada sistemnya.
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#!/bin/sh
#SQUEEZE removes unnecessary files and compresses .tex and README files
#By Barry tolnas, tolnas@sun1.engr.utk.edu
#
echo squeezing $PWD
find  $PWD \( -name \*~ -or -name \*.o -or -name \*.log -or -name \*\#\) -exec
rm -f {} \;
find $PWD \( -name \*.tex -or -name \*README\* -or -name \*readme\* \) -exec gzip -9 {} \;
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>
<H2><A NAME="ss2.16">2.16 Cara mengetahui proses yang paling banyak memakan memori. <I>Simon Amor,</I></A>
<CODE>simon@foobar.co.uk</CODE></H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
ps -aux | sort +4n
</PRE>
</CODE></BLOCKQUOTE>

-ATAU-
<BLOCKQUOTE><CODE>
<PRE>
ps -aux | sort +5n
</PRE>
</CODE></BLOCKQUOTE>
<P>
<HR>
<A HREF="ID-Tips-HOWTO-3.html">Next</A>
<A HREF="ID-Tips-HOWTO-1.html">Previous</A>
<A HREF="ID-Tips-HOWTO.html#toc2">Contents</A>
</BODY>
</HTML>
