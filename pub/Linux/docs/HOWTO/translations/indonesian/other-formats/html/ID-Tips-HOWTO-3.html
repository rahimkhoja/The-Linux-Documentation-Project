<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.7">
 <TITLE>The Linux Tips HOWTO: Petunjuk-petunjuk lebih mendetil.</TITLE>
 <LINK HREF="ID-Tips-HOWTO-2.html" REL=previous>
 <LINK HREF="ID-Tips-HOWTO.html#toc3" REL=contents>
</HEAD>
<BODY>
Next
<A HREF="ID-Tips-HOWTO-2.html">Previous</A>
<A HREF="ID-Tips-HOWTO.html#toc3">Contents</A>
<HR>
<H2><A NAME="s3">3. Petunjuk-petunjuk lebih mendetil.</A></H2>

<H2><A NAME="ss3.1">3.1 Menggunakan partisi swap bersama antara Linux dan Windows. <I>Tony Acero,</I> <CODE>ace3@midway.uchicago.edu</CODE></A>
</H2>

<P>
<OL>
<LI> Formatlah sebuah partisi sebagai partisi DOS, dan buatlah swap untuk
Windows pada partisi tersebut, tetapi jangan menjalankan Windows dahulu. 
(Kita menginginkan supaya swap benar-benar kosong untuk saat ini, sehingga 
dapat dipadatkan (di-compress) dengan baik).
</LI>
<LI> Boot linux dan simpanlah partisi tersebut ke sebuah berkas (file). 
Sebagai contoh, jika partisinya adalah /dev/hda8:
<BLOCKQUOTE><CODE>
<PRE>
dd if=/dev/hda8 of=/etc/dosswap
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI> Padatkan berkas dosswap; karena semua isinya adalah 0 maka akan 
dipadatkan dengan sangat baik
<BLOCKQUOTE><CODE>
<PRE>
gzip -9 /etc/dosswap
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI> Tambahkan yang berikut ini pada berkas /etc/rc untuk mempersiapkan 
dan memasang tempat swap di Linux:

<EM>XXXXX adalah jumlah block di partisi swap</EM>
<BLOCKQUOTE><CODE>
<PRE>
mkswap /dev/hda8 XXXXX
swapon -av   
</PRE>
</CODE></BLOCKQUOTE>

Jangan lupa menambahkan masukan untuk partisi swap di berkas /etc/fstab Anda.
</LI>
<LI> Jika paket init/reboot Anda mendukung /etc/brc atau /sbin/brc tambahkan 
yang berikut ini pada /etc/brc. Jika tidak, jalankan ini secara manual ketika 
Anda menge-boot ke DOS atau OS/2 dan Anda ingin mengubah partisi swap kembali 
ke versi dos/windows:</LI>
</OL>

<BLOCKQUOTE><CODE>
<PRE>
swapoff -av
zcat /etc/dosswap.gz | dd of=/dev/hda8 bs=1k count=100
</PRE>
</CODE></BLOCKQUOTE>

# Harap diingat bahwa ini hanya akan menulis 100 block pertama kembali ke 
partisi. Dari pengalaman, penulis berpendapat bahwa ini sudah cukup.
<P>&gt;&gt;  Apa saja pro dan kontra dari hal ini?
<P>Pro: Anda dapat menghemat sejumlah tempat di disk.
<P>Cons: Jika langkah ke-5 tidak berlangsung otomatis, Anda harus ingat untuk 
melakukannya secara manual, dan ini akan memperlambat proses boot sebanyak 
beberapa nano-detik :-)
<P>
<H2><A NAME="ss3.2">3.2 Undelete dalam keadaan putus asa. <I>Michael Hamilton,</I> <CODE>michael@actrix.gen.nz</CODE></A>
</H2>

<P>Ini adalah trik yang sudah penulis gunakan beberapa kali.
<P>Undelete berkas teks untuk orang yang sudah putus asa.
<P>Jika Anda secara tidak sengaja menghapus sebuah berkas teks, misalnya email, 
atau hasil pemrograman di larut malam, masih ada kemungkinan bahwa semuanya 
tidak hilang. Jika berkas pernah disimpan di disk selama lebih dari 30 detik,
isinya mungkin masih ada di partisi.
<P>Anda bisa menggunakan utilitas grep untuk mencari isi berkas di partisi disk 
secara langsung (raw).
<P>Sebagai contoh, baru-baru ini penulis menghapus sebuah email secara tidak 
sengaja. Jadi penulis berhenti dari semua aktivitas yang bisa mengakibatkan 
berubahnya partisi: dalam hal ini penulis hanya menunda penyimpanan berkas 
atau menunda melakukan compile, dsb. Pada kejadian lain, penulis pernah 
terbawa kesulitan hingga harus berpindah ke mode single user, dan 
meng-unmount filesystem.
<P>Kemudian penulis menggunakan perintah egrep terhadap partisi disk tersebut:  
dalam hal ini, emailnya terletak di /usr/local/home/michael/, jadi dari 
keluaran df, penulis bisa melihat bahwa ini sebenarnya di /dev/hdb5
<BLOCKQUOTE><CODE>
<PRE>
  sputnik3:~ % df
    Filesystem         1024-blocks  Used Available Capacity Mounted on
    /dev/hda3              18621    9759     7901     55%   /
    /dev/hdb3             308852  258443    34458     88%   /usr
    /dev/hdb5             466896  407062    35720     92%   /usr/local

    sputnik3:~ % su
    Password:
    [michael@sputnik3 michael]# egrep -50 'ftp.+COL' /dev/hdb5 > /tmp/x
 
</PRE>
</CODE></BLOCKQUOTE>

Sekarang, penulis sangat berhati-hati ketika bermain-main dengan partisi disk, 
sehingga penulis berhenti sejenak supaya yakin bahwa penulis mengerti arti 
sintaksis dari perintah yang akan dimasukkan SEBELUM menekan  return/enter.  
Dalam hal ini email tersebut mengandung kata 'ftp' yang diikuti dengan
teks tertentu yang diikuti dengan kata 'COL'.  Email tersebut kira-kira 
panjangnya 20 baris, jadi penulis menggunakan -50 untuk mencakup frase 
tersebut. Di masa lampau penulis menggunakan -3000 untuk mencakup sebuah 
frase dari sebuah kode (source code). Penulis mengarahkan keluaran dari 
egrep ke partisi disk yang lain, hal ini mencegah terjadinya penimpaan 
atas email yang dicari tersebut.
<P>Penulis kemudian menggunakan strings untuk membantu mengamati keluaran 
tersebut:
<BLOCKQUOTE><CODE>
<PRE>
   strings /tmp/x | less
 
</PRE>
</CODE></BLOCKQUOTE>

Dan ternyata email tersebut ada di sana.
<P>Metoda ini tidak bisa diandalkan sepenuhnya, karena ada kemungkinan semua 
atau sebagian dari disk space tersebut telah digunakan kembali.
<P>Trik ini mungkin hanya berguna untuk sistem single user.  Pada sistem 
multi-user dengan aktivitas disk yang sangat tinggi, space yang dibebaskan 
(karena proses penghapusan) mungkin telah digunakan kembali untuk yang lain. 
Dan kita tidak bisa seenaknya mengambil alih komputer dari pengguna-pengguna 
yang lain ketika kita butuh untuk mengambil kembali berkas yang terhapus.
<P>Di sistem di rumah penulis trik ini sudah digunakan kira-kira tiga kali
dalam beberapa tahun terakhir - biasanya ketika penulis menghapus
hasil kerja hari tersebut.  Jika apa yang penulis kerjakan sampai pada suatu 
titik di mana penulis merasa bahwa sudah ada cukup kemajuan, pekerjaan itu 
akan di-backup ke floppy, jadi penulis jarang menggunakan trik ini.
<P>
<P>
<H2><A NAME="ss3.3">3.3 Cara menggunakan flag yang tidak berubah (immutable flag). <I>Jim Dennis,</I> <CODE>jadestar@rahul.net</CODE></A>
</H2>

<P>Penggunaan 'Immutable Flag'
<P>Setelah Anda memasang dan mengkonfigurasi sistem Anda,
jelajahilah /bin, /sbin/, /usr/bin, /usr/sbin dan /usr/lib
(dan juga beberapa lagi yang bisa dicurigai) kemudian
pergunakan 'chattr +i command' seperlunya.  Juga tambahkan 
ke berkas-berkas kernel di root. Sekarang 'mkdir /etc/.dist/'
salinlah semua dari /etc/, termasuk sub-subdirektorinya
(Penulis menggunakan 2 langkah, menggunakan /tmp/etcdist.tar
untuk menghindari recursion).
(Kalau Anda mau, bisa juga membuat /etc/.dist.tar.gz) -- dan
tandailah sebagai immutable.
<P>Latar belakang dari semua ini ialah untuk membatasi kerusakan
yang bisa terjadi ketika login sebagai root.  Anda tidak akan
menimpa berkas-berkas dengan operator redirection yang salah,
dan Anda tidak akan membuat sistem tidak bisa terpakai gara-gara
penggunaan sebuah spasi yang salah dalam perintah 'rm -fr' (Masih
banyak kemungkinan Anda bisa melakukan kerusakan pada data Anda --
tetapi berkas-berkas lib dan bin akan menjadi lebih aman).
<P>Hal ini juga akan membuat sejumlah eksploitasi atas security
dan 'denial of service' menjadi tidak mungkin atau lebih sukar
(dikarenakan kebanyakan dari eksploitasi tersebut mengandalkan
penimpaan berkas melalui tindakan-tindakan dari program-program
SUID yang *tidak mendukung perintah shell sembarang*).
<P>Satu-satunya ketidakpraktisan dari hal ini ialah ketika membangun
dan melakukan 'make install' terhadap bermacam jenis berkas biner
sistem. Di lain pihak, hal ini juga mencegah 'make install' dari
penimpaan berkas-berkas. Jika Anda lupa membaca Makefile dan 
'chattr -i' terhadap berkas-berkas yang akan ditimpa (dan direktori
di mana Anda akan menambahkan berkas-berkas) -- program 'make' akan
gagal, Anda tinggal menggunakan perintah chattr dan menjalankan
ulang. Anda juga bisa menggunakan kesempatan itu untuk memindahkan
berkas-berkas bin atau lib yg lama atau apa saja yg lain ke sebuah
direktori .old/ atau mengubah nama direktorinya, melakukan 'tar' atau 
terserah Anda.
<P>
<H2><A NAME="ss3.4">3.4 Saran: tempat untuk meletakkan barang-barang baru.</A>
<I>Jim Dennis,</I> <CODE>jadestar@rahul.net</CODE></H2>

<P>Semua barang baru dimulai di bawah /usr/local! atau 
/usr/local/`hostname`
<P>Jika distribusi Anda adalah yang /usr/local -nya kosong, maka
Anda tinggal membuat /usr/local/src, /usr/local/bin dst dan 
menggunakannya.  Jika distribusi Anda meletakkan berkas-berkas di 
/usr/local maka Anda mungkin bisa melakukan 'mkdir /usr/local/`hostname`'
dan memberikan group 'wheel' +w (Penulis juga membuatnya SUID dan 
SGID untuk menjamin bahwa masing-masing anggota dari group 'wheel'
hanya bisa mengacak-acak berkas mereka sendiri di sana, dan bahwa 
semua berkas yang dibuat akan menjadi milik group 'wheel').
<P>Sekarang, biasakan diri Anda sendiri untuk *SELALU! SELALU! SELALU!*
meletakkan paket-paket baru di bawah 
/usr/local/src/.from/$DARI_MANA_SAYA_DAPAT/
(untuk berkas .tar atau apa pun akhirannya) dan compile-lah di bawah
/usr/local/src (atau .../$HOSTNAME/src). Yakinkan bahwa
itu bisa di-install di bawah hirarki lokal. Jika paket tsb. 
*benar-benar harus* di-install kembali ke /bin atau /usr/bin atau
di tempat lainnya -- berikan symbolic link dari hirarki lokal ke
masing-masing elemen di tempat lainnya.
<P>Alasan dari hal ini ialah -- walaupun berarti menambah pekerjaan --
hal ini bisa membantu mengisolir apa yang harus di backup dan di-
restore atau di-reinstall dalam rangka re-install secara penuh dari
media distribusi (sekarang ini biasanya CD). Dengan
menggunakan direktori /usr/local/.from Anda juga menyimpan
sebuah log informal mengenai asal sumber -- yang akan membantu
jika Anda mencari update -- dan mungkin masalah ini menjadi 
kritis jika memonitor mailing list security announcement.
<P>Salah satu dari sistem di rumah penulis dipasang sebelum
penulis membuat aturan-aturan ini untuk penulis sendiri.
Penulis masih belum tahu semua cara-cara yang berbeda untuk
masing-masing sistem yang terpasang. Hal ini dikarenakan
penulis sangat sedikit melakukan konfigurasi dengan sistem di
rumahnya dan penulis satu-satunya orang yang menggunakannya.
<P>Sistem-sistem yang penulis pasang di tempat kerja (ketika penulis
menjadi system administrator di sana) semua dipasang dengan cara 
ini -- dan sudah diadministrasi oleh beberapa kontraktor dan 
orang-orang MIS lain, dan telah mengalami sejumlah besar
upgrade dan pemasangan paket-paket baru. Walaupun demikian,
penulis masih tahu dengan tepat, elemen-elemen mana saja yang
dipasang *setelah* pemasangan dan konfigurasi pertama kali.
<P>
<H2><A NAME="ss3.5">3.5 Mengubah semua nama berkas di direktori menjadi huruf kecil. <I>Justin Dossey,</I> <CODE>dossey@ou.edu</CODE></A>
</H2>

<P>
<P>Penulis memperhatikan adanya beberapa prosedur yang sulit dan tidak 
perlu dianjurkan di bagian 2c tips dari Edisi 12. Karena ada lebih dari satu, 
maka penulis mengirimkannya sbb:
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#!/bin/sh
         # lowerit
         # convert all file names in the current directory to lower case
         # only operates on plain files--does not change the name of directories
         # will ask for verification before overwriting an existing file
         for x in `ls`
           do
           if [ ! -f $x ]; then
             continue
             fi
           lc=`echo $x  | tr '[A-Z]' '[a-z]'`
           if [ $lc != $x ]; then
             mv -i $x $lc
           fi
           done
</PRE>
<HR>
</CODE></BLOCKQUOTE>

Wow, betapa panjangnya. Penulis tidak akan menggunakan script untuk 
melakukannya; sebaliknya, penulis akan menggunakan perintah:
<BLOCKQUOTE><CODE>
<PRE>
for i in * ; do [ -f $i ] &amp;&amp; mv -i $i `echo $i | tr '[A-Z]' '[a-z]'`;
done;
</PRE>
</CODE></BLOCKQUOTE>

di command line.
<P>Orang yang menyumbangkan script tsb. berkata bahwa dia menulis script tsb.
supaya lebih mudah dimengerti (lihat di bawah).
<P>Di petunjuk berikut, mengenai penambahan dan pneghapusan user, Geoff melakukan
hal yang benar hingga langkah terakhir. Reboot? Wow, penulis berharap dia 
tidak melakukan reboot setiap kali menghapus user. Yang harus Anda lakukan 
hanyalah dua langkah pertama saja. Lagipula, proses apa yang sedang 
berlangsung yang dimiliki oleh si user? IRC bot? Proses tersebut bisa 
dibunuh secara singkat dengan:
<BLOCKQUOTE><CODE>
<PRE>
kill -9 `ps -aux |grep ^&lt;username> |tr -s " " |cut -d " " -f2`
</PRE>
</CODE></BLOCKQUOTE>

Contoh, jika username adalah foo:
<BLOCKQUOTE><CODE>
<PRE>
kill -9 `ps -aux |grep ^foo |tr -s " " |cut -d " " -f2`
</PRE>
</CODE></BLOCKQUOTE>

Hal itu sudah teratasi, sekarang beralih ke root password yang terlupakan.
<P>Solusi yang diberikan di majalah Gazette adalah yang paling universal,
tetapi bukan yang paling mudah. Dengan adanya LILO dan loadlin secara bersamaan,
seseorang mungkin menge-boot dengan memberi parameter "single" untuk boot
langsung ke shell default tanpa login ataupun tampilan password.
Dari sana, dia bisa menghilangkan atau mengubah password sebelum
mengetikkan ``init 3`` untuk pindah ke mode multi-user.
Jumlah reboot: 1
<P>Dengan cara yang lain, jumlah reboot: 2
<P>Justin Dossey
<P>
<P>
<H2><A NAME="ss3.6">3.6 Beberapa petunjuk untuk sysadmin baru.</A>
<I>Jim Dennis,</I> <CODE>jadestar@rahul.net</CODE></H2>

<P>Buatlah sebuah /README.`hostname` dan/atau sebuah
/etc/README.`hostname`, yang kemudian dipelihara.
<EM>[Atau mungkin /usr/local/etc/README.`hostname`]</EM>
<P>Kemudian, sejak *hari pertama* mengadministrasi sebuah sistem
catatlah di sebuah berkas log online. Anda bisa saja membuat
baris 'vi /README.$(hostname)' di &nbsp;/bash_logout milik
root. Cara lain untuk melakukan ini ialah menulis sebuah
script su atau sudo yang isinya kira-kira:
<BLOCKQUOTE><CODE>
<PRE>
                function exit \
                        { unset exit; exit; \
                          cat ~/tmp/session.$(date +%y%m%d) \
                          >> /README.$(hostname) &amp;&amp; \
                          vi /README.$(hostname)
                          }
                script -a ~/tmp/session.$(date +%y%m%d)
                /bin/su.org -
</PRE>
</CODE></BLOCKQUOTE>
<P>(gunakan perintah typescript untuk membuat log dari sebuah 
sessiondan buat sebuah fungsi untuk mengotomatisasi penambahan
dan update dari log).
<P>Penulis mengakui bahwa penulis belum mengimplementasikan
otomatisasi dari aturan -- sejauh ini penulis hanya mengandalkan
dari disiplin diri sendiri.
Bagaimanapun penulis telah bermain-main dengan ide tsb. (bahkan
hingga membuat prototipe dari script dan fungsi-fungsi shell tsb. di
atas). Satu hal yang membuat penulis urung ialah perintah 'script' 
itu sendiri. Penulis berpendapat bahwa beliau harus mendapatkan
sumber-sumbernya dan menambahkan beberapa command line parameters
(untuk memberhentikan (stop/pause) script merekam dari command line)
sebelum penulis berkomitmen untuk menggunakannya.
<P>Saran terakhir penulis (untuk bagian ini):
<P>PATH dari root seharusnya berisi 'PATH=&nbsp;/bin'
<P>Itu saja. Tidak ada lagi yang lainnya. Semua yang dilakukan
oleh root: (1) disediakan melalui symbolic link dari &nbsp;/bin
atau dengan alias atau fungsi shell, atau (2) adalah script
atau berkas biner di &nbsp;/bin, atau (3) diketik secara langsung 
dengan menyertakan path secara eksplisit.
<P>Hal ini membuat seseorang yang bertindak sebagai root
menyadari (terkadang menyakitkan) tentang bagaimana dia
mempercayai berkas-berkas biner. Administrator yang bijak
dari sebuah host multi-user akan mengecek secara berkala
berkas-berkas &nbsp;/bin dan &nbsp;/.*history untuk mencari pola-pola
dan lubang-lubang.
<P>Administrator yang benar-benar termotivasi akan menemukan
daerah-daerah yang bisa diotomatisasi, tempat-tempat di mana
pengecekan kesehatan sistem bisa dimasukkan, dan pekerjaan-
pekerjaan dengan hak/akses 'root' seharusnya dihindarkan
sementara (menjalankan penyunting (editor), MTA dan program-
program interaktif besar yang lain yang memiliki kelebihan
membuat script secara terperinci, yang *mungkin* diikutsertakan
di berkas transparan atau berkas data -- seperti ./.exrc dari vi
dan ./.emacs dari emacs dan $EXINIT yang lebih 
membahayakan lagi dan header/footer macros yang diikutsertakan).
Biasanya perintah-perintah seperti itu bisa dijalankan dengan:
<BLOCKQUOTE><CODE>
<PRE>
                cp $data $some_users_home/tmp
                su -c $origcommand $whatever_switches
                cp $some_users_home/tmp $data
</PRE>
</CODE></BLOCKQUOTE>

(...di mana spesifikasinya tergantung kepada masing-masing perintah).
<P>Kebanyakan bermacam cara pencegahan yang terakhir ini agak berlebihan 
untuk sistem di rumah atau single-user -- tapi ini adalah aturan yang 
sangat baik untuk sistem yang multi-user -- terutama sistem yang bisa
diakses oleh publik (seperti di netcom).
<P>
<P>
<H2><A NAME="ss3.7">3.7 Cara mengkonfigurasi chooser dari xdm untuk pilihan host. <I>Arrigo Triulzi,</I> <CODE>a.triulzi@ic.ac.uk</CODE></A>
</H2>

<P>
<OL>
<LI> Suntinglah berkas yang menjalankan xdm 
(biasanya /etc/rc/rc.6 atau /etc/rc.local) sehingga berkas tsb. mengandung
baris-baris berikut di bagian xdm startup.
<BLOCKQUOTE><CODE>
<PRE>
        
/usr/bin/X11/xdm
exec /usr/bin/X11/X -indirect hostname
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI> Suntinglah /usr/lib/X11/xdm/Xservers dan berikan tanda komentar pada
baris-baris yang memulai server pada mesin lokal yaitu memulai 0:]
<LI> Reboot, dan itu saja.</LI>
</LI>
</OL>
<P>Penulis menambahkan ini karena ketika penulis, sesudah putus asa, mencoba
memasangnya untuk subnet penulis di sini, penulis sudah menghabiskan waktu 
seminggu untuk memcahkan semua persoalannya.
<P>Harap diingat: dengan SLS lama (1.1.1), untuk suatu alasan anda bisa 
membubuhkan -nodaemon setelah baris xdm -- hal ini <B>TIDAK</B> berlaku untuk
rilis setelah itu.
<HR>
Next
<A HREF="ID-Tips-HOWTO-2.html">Previous</A>
<A HREF="ID-Tips-HOWTO.html#toc3">Contents</A>
</BODY>
</HTML>
