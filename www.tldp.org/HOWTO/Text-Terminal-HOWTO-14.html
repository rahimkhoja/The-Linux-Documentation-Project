<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.21">
 <TITLE> Text-Terminal-HOWTO: Terminal Set-Up (Configure) Details </TITLE>
 <LINK HREF="Text-Terminal-HOWTO-15.html" REL=next>
 <LINK HREF="Text-Terminal-HOWTO-13.html" REL=previous>
 <LINK HREF="Text-Terminal-HOWTO.html#toc14" REL=contents>
</HEAD>
<BODY>
<A HREF="Text-Terminal-HOWTO-15.html">Next</A>
<A HREF="Text-Terminal-HOWTO-13.html">Previous</A>
<A HREF="Text-Terminal-HOWTO.html#toc14">Contents</A>
<HR>
<H2><A NAME="term_conf_details"></A> <A NAME="s14">14.</A> <A HREF="Text-Terminal-HOWTO.html#toc14">Terminal Set-Up (Configure) Details </A></H2>

<P> Except for the next subsection on sending escape sequences to the
terminal, this section mainly presents the details of setting up the
terminal manually by sitting at the terminal and going thru menus.  If
you haven't already done so, you should read 
<A HREF="Text-Terminal-HOWTO-13.html#term_conf_ov">Terminal Set-Up (Configure) Overview</A>.  It's best if you have a
terminal manual, but even it you don't there is information here on
many of the options which you might possibly need to set.</P>
<P>The communication parameters such as its baud rate must always be set
up at the terminal since if this is not done there can be no
communication with the terminal.   Once communication is established
you have two choices for doing the rest of the terminal configuration.
You may continue to configure manually at the terminal and save the
results in the terminal's non-volatile memory or you may do this by
sending escape sequences to the terminal from the computer each time
the terminal is powered on (or the like).</P>
<P>If you know how to set up and save a good configuration inside the
terminal it may be the best way.  If you don't, you might want to just
send the init string from terminfo to your terminal each time you use
the terminal.  Perhaps doing nothing will still give you a usable
terminal.  You (or an application program) can always change
things by sending certain escape sequences to the terminal.</P>

<H2><A NAME="ss14.1">14.1</A> <A HREF="Text-Terminal-HOWTO.html#toc14.1">Send Escape Sequences to the Terminal</A>
</H2>

<P> Once the communication interface is established, the rest of the
configuration of the terminals may sometimes be done by sending
escape sequences to the terminals from the computer.  If you have a
large number of terminals, it may be worthwhile to write (or locate) a
shell script to automatically do this.  There may (or may not) be a
command you can send to a terminal to tell it to save its current
set-up in its non-volatile memory so that it will be present the next
time the terminal is powered on.</P>
<P>There is an simple way to send these escape sequences and a complex
way.  Using the simple way, you never look up escape sequences but
issue commands that automatically find an appropriate escape sequence
in the terminfo database and send that.  Unfortunately, not all the
escape sequences which you might want to send are always in the
terminfo database.  Thus the more complex (but possibly better) way is
to directly send escape sequences.</P>
<P>For this complex method you'll need an advanced manual.  Old terminal
manuals once included a detailed list of escape sequences but newer
ones usually don't.  To find them you may need to purchase another
manual called the "programmers manual" (or the like) which is not
supplied with the terminal.  A 
<A HREF="Text-Terminal-HOWTO-22.html#esc_seq_lists">Esc Sequence List</A> for some terminals is on the Internet but it's terse
and likely incomplete.</P>
<P>Even without a manual or the like, you may still send commands to
configure the terminal by using the programs "tput" and "setterm".
See 
<A HREF="Text-Terminal-HOWTO-17.html#term_settings">Changing the Terminal Settings</A>.
You could just send the terminal an init string from the terminfo
entry if the init string sets up the terminal the way want it.  See
<A HREF="Text-Terminal-HOWTO-16.html#init_string">Init String</A>.  Unless you plan to have
these sequences sent from the computer to the terminal each time the
terminal is powered on, you must somehow save the settings in the
non-volatile memory of the terminal.</P>

<H2><A NAME="ss14.2">14.2</A> <A HREF="Text-Terminal-HOWTO.html#toc14.2">Older Terminals Set-Up</A>
</H2>

<P> On older terminals look at the keyboard for labels just above the
top row of numeric keys.  If they exist, these labels may be what
these keys do in set-up mode.  Some older terminals may have only one
"set-up" menu.  Still older ones have physical switches.  In some
cases not all the switches are well labeled but they may be well
concealed.  Of course, if you set something with a switch, it's
"saved" and there is no need to save the setting in non-volatile
memory.</P>

<H2><A NAME="enter_setup"></A> <A NAME="ss14.3">14.3</A> <A HREF="Text-Terminal-HOWTO.html#toc14.3">Getting Into Set-Up (Configuration) Mode </A>
</H2>

<P> To select options (configure) at the terminal, you must first
enter "set-up" mode and then select options (i.e. configure) using
menus stored inside the terminal and displayed on the screen.  To do
this, the terminal does not even need to be connected to a computer.
How to get into set-up mode is covered in the terminal's manual, but
here's some hints that may help:</P>
<P>If there's a "set-up" key try pressing it.  Also try it shifted.
<UL>
<LI> Wyse: First try the shifted "Select" key; then substitute
Ctrl for shifted in all of the above.</LI>
<LI> VT, Dorio: F3 may be the set-up key.  On VT420 and later models
this key may have been programmed to do something else so turn off the
power.  When you turn on the power again, hit the F3 key as soon as
you get an initial screen message.</LI>
<LI> IBM: 3151: Ctrl-ScrollLock.  3153: Ctrl-Minus_on_Keypad (or
like 3151)</LI>
</UL>
</P>
<P>To move around in the set-up menus, try the arrow keys.  Use Return,
Space, or a special key ("toggle" on old terminals) to select.
To exit set-up mode select exit from a menu (or on some older
terminals press the set-up key again).</P>

<H2><A NAME="ss14.4">14.4</A> <A HREF="Text-Terminal-HOWTO.html#toc14.4">Communication Options</A>
</H2>

<P> For the terminal to work at all, speed, parity, :its/character,
and communication mode must be set correctly.  Incorrect flow control
may cause loss and/or corruption of data seen on the screen. The
essential communication options were dealt with (for both the terminal
and computer) in another section:  See 
<A HREF="Text-Terminal-HOWTO-13.html#commun_config">Communication Interface</A>.  The following list provides some
links to that section, as well as some additional communication
options set only at the terminal.</P>
<P>
<UL>
<LI> 
<A HREF="Text-Terminal-HOWTO-13.html#speed">Speed (bits/second) </A>
(baud rate): 9600, 19200, etc.</LI>
<LI> 
<A HREF="Text-Terminal-HOWTO-13.html#parity_">Parity</A> none, even, odd, mark, space</LI>
<LI> 
<A HREF="Text-Terminal-HOWTO-13.html#ch_size">Bits per Character </A> {Data}: 7 or 8</LI>
<LI> 
<A HREF="Text-Terminal-HOWTO-11.html#flow_control">Flow Control:</A> or Handshake
{Hndshk}: none, Xon-Xoff, or hardware (DTR, etc).
<UL>
<LI> Receiver Handshake {Rcv Hndshk} protects data being Received
by the terminal by transmitting flow-control signals to the host.</LI>
<LI> Transmitter Handshake {Xmt Hndshk} is protection of data being
Transmitted by the terminal.   The terminal receives flow-control
signals (and locks/unlocks the keyboard).  Includes "Incoming Xon/Xoff".</LI>
</UL>
</LI>
<LI> number of stop bits: 1 or 2. See 
<A HREF="Text-Terminal-HOWTO-23.html#byte_seq">Voltage Sequence for a Byte</A></LI>
<LI> Flow control level {Rcv Hndshk Level} {{Xoff at ...}}: Flow
control will send "stop" when this number of bytes in the terminal's
buffer is exceeded.</LI>
<LI> 
<A HREF="Text-Terminal-HOWTO-6.html#half_duplex">Communication Mode</A> {Comm}: 
<A HREF="Text-Terminal-HOWTO-6.html#half_duplex">Full Duplex {FDX}, Half Duplex {HDX}</A> {{Local
Echo}}, 
<A HREF="Text-Terminal-HOWTO-19.html#local_mode">Local Mode</A> {{Online/Local}}</LI>
<LI> Transmit Rate (Speed) Limit {Xmt Lim}: limits the transmit rate
to the specified cps (chars/sec) even though the baud rate setting may
be at a higher speed.</LI>
<LI> Function-Key Rate Limit: as above but for function key
messages.</LI>
<LI> 
<A HREF="Text-Terminal-HOWTO-13.html#port_select">Port Select</A>: Which physical connecter
is for the host {Host Port} ?</LI>
</UL>
</P>

<H2><A NAME="ss14.5">14.5</A> <A HREF="Text-Terminal-HOWTO.html#toc14.5">Saving the Set-up</A>
</H2>

<P> Your set-up must be saved in the non-volatile memory of the
terminal so that it will be effective the next time you turn on the
terminal.  If you fail to save it, then the new settings will be lost
when you turn off the terminal.  Before you go to the trouble of
setting up a terminal, make sure that you know how to save the
settings.  For modern terminals the save command is done via a menu.
In some older terminals, only the manual tells how to save.  For many
of these you press Ctrl-S to save.</P>

<H2><A NAME="set_up_pars"></A> <A NAME="ss14.6">14.6</A> <A HREF="Text-Terminal-HOWTO.html#toc14.6">Set-Up Options/Parameters </A>
</H2>

<P> What follows in this section describes some of the options which are
available in the set-up menus of many terminals.  Options are also
called parameters or features.  Many options may be called "modes".
Setting options is often called "configuring".  Many of these options
may also be set by sending certain escape sequences to the terminal.
Different models and brands of terminals have various options and the
same option may be called by different names (not all of which are
given here) Terse names used by Wyse are enclosed in {...}.  Names
used mostly for VT terminals are enclosed in {{...}}.</P>

<H2><A NAME="ss14.7">14.7</A> <A HREF="Text-Terminal-HOWTO.html#toc14.7">Emulation {Personality} {{Terminal Modes}}</A>
</H2>

<P> Most modern terminals can emulate several other terminals.  The
terminal can likely do more if it is set to emulate itself (actually
no emulation) {native personality}.   Sometimes there are 2 different
emulations for the same model of terminal.  For example VT220-7
emulates a VT220 with 7-bits/byte while VT220-8 emulates a VT220 with
8-bits/byte (256 possible characters).</P>
<P>Older models of terminals usually have fewer features than newer
models.  Suppose one wanted to emulate an old terminal but also wanted
some of the advanced capabilities of the later model terminal they are
sitting at.  This is sometimes possible (to some degree).  This
feature is sometimes called {Enhance} (or Enhanced ??).</P>

<H2><A NAME="ss14.8">14.8</A> <A HREF="Text-Terminal-HOWTO.html#toc14.8">Display Options</A>
</H2>

<H3>Character Cell Size {Char Cell}</H3>

<P> This is the size of the cell in which a character fits.  It is
measured in pixels (=tiny dots).  The more dots, the better the
resolution.   10x16 is 10 dots wide by 16 dots high (16 rows and 10
columns).  Note the notation is inverted as compared to the notation
for matrix dimensions which gives rows (height) first..  Also, the
character cell includes rows and columns of pixels allocated for the
space between adjacent characters so the cell size which defines the
boundaries of an actual character may be smaller.</P>

<H3>Columns/Lines</H3>

<P> Usually 80 columns and 24 or 25 lines.  This means that there may
be up to 80 characters in a row (line) on the screen.   Many terminals
have a 132 column option but unless you have a large screen, the tiny
characters may be hard to read. {{Set 132 column mode}}.  If you set
25 lines, make sure that this is in the terminfo.  You should also put
"export LINES=25" into /etc/profile and also use: "stty -F /dev/ttySx
rows 25".  If you don't it might result in a scrolling problem (see
<A HREF="Text-Terminal-HOWTO-19.html#no_scroll_25">Terminal doesn't scroll</A></P>

<H3>Cursor</H3>

<P> The cursor may be set to appear as a rectangle (= block) {Blk}.
Other options are underline {Line} or blinking.  I prefer non-blinking
{Steady} block since it's big enough to find quickly but there is no
distractive blinking.  If you set it invisible (an option on some
terminals) it will disappear but new letters will appear on the screen
as you type at the invisible cursor.</P>

<H3>Display Attributes (Magic Cookies)</H3>

<P> 
<A HREF="Text-Terminal-HOWTO-8.html#display_attributes">Display Attributes</A> may either
be magic cookies or be attribute bytes assigned to each character.
For magic cookies, there is a limit to their extent: Are they in
effect to the end of the line or to the end of the page?  It's best to
use attribute bytes (which could actually be half-bytes = nibbles).</P>

<H3>Display Control Characters {Monitor}</H3>

<P> May be called various names such as "Display Controls".  When off
(normal) it's "Interpret Controls".  When set on, you see the escape
sequences from the host (which you normally never see on the screen).
So that these sequences may be viewed in sequence on a line, they are
not acted upon (interpreted) by the terminal.  Except that a CR LF
sequence creates a new line.  See 
<A HREF="Text-Terminal-HOWTO-8.html#control_codes">Control Codes</A>.</P>

<H3>Double Width/Height</H3>

<P> Some terminals can have their characters double width and/or
double height.  This feature is seldom needed.  When changing a line
to double width (DW) the right half (RH) is pushed off the screen and
there is the question of whether or not to delete (erase) it.
"Preserve" means to keep the RH of DW lines.  When in double height
mode, it may be necessary to send each such line twice (the 2nd time
down one row) in order to get a double-height line on the screen.</P>

<H3>Reverse Video {Display} (Background Light/Dark)</H3>

<P> Normal video is light (white, green, amber) letters (foreground)
on a dark (black) background.  Reverse video {Display Light} is the
opposite: black text on a light background.  This is easier on the
eyes (unless the room is dark).</P>

<H3>Status Line</H3>

<P> A status line is a line at the top or bottom of the screen that
displays info about the application program you are running.  It's
often highlighted in some way.  With a status line enabled, an
application can send the terminal a special escape sequence which
means that the text that follows is for the status line.  However,
many applications don't use this feature but instead only simulate a
real status line by direct cursor positioning.  The ordinary user
looking at it doesn't know the difference.</P>

<H3>Upon 80/132 Change: Clear or Preserve?</H3>

<P> When switching the number of columns from 80 to 132 (or
conversely) should the data displayed in the old format be erased
(cleared) or preserved? {80/132 Clr} {{Screen Width Change}}.  It
should make no difference how you set this option since if an
application program uses 132 columns, it should set this option
appropriately via a control sequence.</P>

<H2><A NAME="ss14.9">14.9</A> <A HREF="Text-Terminal-HOWTO.html#toc14.9">Page Related Options</A>
</H2>

<P> For a Wyse terminal to be able to access multiple pages of display
memory {Multipage} must be set to on.</P>

<H3>Page Size</H3>

<P> The terminal memory may be divided up into a number of pages.
See 
<A HREF="Text-Terminal-HOWTO-9.html#pages_">Pages</A> and 
<A HREF="Text-Terminal-HOWTO-22.html#pages_def">Pages (definition)</A> for explanations of pages.  You may partition the page
memory into a number of pages of selected length.  Linux applications
don't seem to use pages at present so it shouldn't make much
difference how you set this up.</P>

<H3>Coupling (of cursor &amp; display)</H3>

<P> The terminal memory may be divided up into a number of pages.
See 
<A HREF="Text-Terminal-HOWTO-9.html#pages_">Pages</A> and 
<A HREF="Text-Terminal-HOWTO-22.html#pages_def">Pages</A>
for explanations of pages.  When the cursor is moved to a location in
video memory not currently displayed (such as another page, or on the
same page but to a location not displayed on the screen) should the
display change to let one view the new cursor location?  If so, this
is called "Coupling".  For cursor movement within the same page there
is "Vertical Coupling" and "Horizontal Coupling".  For movement to
another page there is "Page Coupling".</P>

<H2><A NAME="ss14.10">14.10</A> <A HREF="Text-Terminal-HOWTO.html#toc14.10">Reporting and Answerback</A>
</H2>

<P> The terminal will identify itself and its state, or send out a
pre-recorded message in response to certain escape sequences.</P>

<H3>Answerback Message (String)</H3>

<P> You may write a short message during set-up which may optionally
be sent to the host at power-up or be sent to the host in response to
a request from the host (perhaps the ENQ (inquire) control character).</P>

<H3>Auto Answerback</H3>

<P> If set, sends the answerback message to the host at power-on
without the host asking for it.  Do any "getty" processes look for
this ??</P>

<H3>Answerback Concealed</H3>

<P> If set, will never let anyone see the answerback message (except
of course the host computer).  If it needs to be changed, deselect
"answerback concealed" and the formerly concealed message will be
destroyed so you then may enter a new message (but you don't get to
see the old one).</P>

<H3>Terminal ID {ANSI ID}</H3>

<P> The terminal sends this reply in answer to a request for identity.</P>

<H2><A NAME="ss14.11">14.11</A> <A HREF="Text-Terminal-HOWTO.html#toc14.11">Keyboard Options</A>
</H2>

<H3>Keyclick</H3>

<P> When set, pressing any key makes a click (broadcast by a tiny
loudspeaker in the keyboard).  These clicks annoy some people and I
think it's best to set keyclick off.</P>

<H3>Caps Lock {Keylock}</H3>

<P> When the Caps-Lock key is down, should only the alphabetic keys
generate shifted characters?  If set to {Caps} or upper-case-only
then hitting a number key with the Caps-Lock on will type the number.
To get the symbol above the number one must manually hold down the
shift key.  This is the normal mode.  If set to {Shift} then all keys
type the shifted character when Caps-Lock is on (hitting the 5 key
should type % without holding down Shift, etc.).</P>

<H3>Auto Repeat {Repeat}</H3>

<P> If a key is held down then that key is repeatedly "typed".  This
is handy for repeatedly typing the same character to create a line across
the page.</P>

<H3>Margin Bell</H3>

<P> When the cursor is 8 columns away from the right side of the
display, a bell is rung (like on an old typewriter).  Almost all
editors will automatically create a new line if needed (no need to
hit the Return key) so this feature is seldom needed.</P>

<H3>Remapping the Keys</H3>

<P> The code sent to the host when a key is pressed is normally the
ASCII code for that key (depends also on Shift and Control key).  On
some terminals you may make any key send any code you wish.  That is,
you may completely remap the keyboard by setting up the terminal that
way.  This may be useful for some foreign languages and Dvorak
keyboard layouts, etc. which permit one to type faster.  Even for
terminals that don't have the feature, there is software to remap the
keyboard (and screen also).  It's something like a device driver
which uses a pseudo terminal.  See 
<A HREF="Text-Terminal-HOWTO-15.html#mapchan_">Character Mapping: mapchan</A></P>

<H3>Corner Key (for Wyse only)</H3>

<P> Wyse terminals have a key near the lower left corner which may be
set to do various things.  Its may be labelled "Funct", "Compose
Character", "Alt", "Hold" or "Scroll Lock".  Early models don't have
all of the following options:</P>
<P>
<UL>
<LI>Hold: No-Scroll.  Hitting it stops the flow of data (using flow
control) to the terminal.  Hitting the key again restores normal flow.</LI>
<LI>Compose: Hitting it followed by certain other keys permits one
to generate a limited number of pre-defined non-Latin characters.</LI>
<LI>Meta: Holding it down while typing another key sets the
high-order bit on each byte.  Are there models where it acts like a
toggle to lock in the meta effect ??</LI>
<LI>Funct: Holding it down while typing any alphanumeric key
gets a header (SOH) and trailer (CR) byte framing the ASCII byte code.</LI>
<LI>Kpd Compose: Holding it down while typing a decimal number
on the numeric keys (followed by "enter") sends out the same number in
hexadecimal ??</LI>
</UL>
</P>

<H3>Numeric Keypad or Arrow Keys Sends</H3>

<P> The numeric keypad (the rectangle of mostly numeric keys to the
right of the main part of the keyboard) can be set to send special
codes which will do special things in certain application programs.
Ditto for the arrow keys.  There is thus a "normal" mode where they
send what is shown on the keycap (or the normal code sequence for an
arrow-key) and an "application" mode where special escape sequences
are sent.  In some cases there is a "hex" numeric mode which is almost
like normal numeric mode except that 6 non-numeric keys send the
letters A-F.  Thus one may type for example "B36F" on the numeric
keypad.</P>

<H3>What does shifted-del and shifted-bs send?</H3>

<P> Depending on how they're set up, shifted-del sometimes sends the
control character CAN and shifted backspace sometimes sends DEL.</P>

<H3>PC Scan Codes</H3>

<P> Many terminals can emulate a PC keyboard by sending PC scancodes
(see Keyboard-and-Console-HOWTO) instead of ASCII codes.  This is
mostly used with special Multiuser DOS OSs.  It won't work with
ordinary MS DOS.  See 
<A HREF="Text-Terminal-HOWTO-21.html#non_linux">Non-Linux OSs</A>
However, hardly any Linux programs that run via the serial port can
accept scancodes.  If this is the latest version of this HOWTO, let me
know if any programs do this.  I think Foxpro can do it.  You need to
define smsc and rmsc in the terminfo, and perhaps pctrm.</P>
<P>When using scancodes it's best to use hardware flow control since
normal software flow control conflicts with some of the codes (??).
If you do use software flow control, you must use the XPC type of flow
control.  It uses 0x65 and 0x67 for on and off characters.  It must be
set this way both in the terminal and by stty for the PC.</P>

<H3>Alternate Characters</H3>

<P> Some keys may have alternative letters on them.  When keys is set
to "Typewriter" they send what they would normally send on a
typewriter.  When keys is set to something else the alternative
characters are sent.</P>

<H2><A NAME="ss14.12">14.12</A> <A HREF="Text-Terminal-HOWTO.html#toc14.12">Meaning of Received Control Codes</A>
</H2>

<H3>Auto New Line {Newline}</H3>

<P> In this case "New Line" means a new line starting at the left
margin below the current line.  In Linux and C "new line" (NL) may
have a different meaning: the line-feed control character LF also
called new-line or NL.  This is because in Linux text files, the LF
character means a "new line starts here" so it's labeled NL.
Normally, a LF (NL) sent to a terminal only results in the cursor
jumping down one line below where is was and does not move the cursor
back to the start of this "new line".</P>
<P>If Auto New Line is set, the above "normal" situation is canceled and
a physical new line is created on the display upon receiving a LF from
the host.  This is exactly what one wants in Linux.  Except that (when
Auto New Line is set) the Return (or Enter) key sends a CR LF sequence
to the host (for Wyse and VT100, but for VT420 ??).  Since Linux uses
LF as a "new line" marker in files, Linux would like only a LF to be
sent (and not a CR LF).  Thus the "New Line" option is seldom used.
Instead, the required translations are made by the serial port device
driver by default.  It is as if one gave the command "stty onlcr
icrnl".  But you don't need to do this since it's the default.</P>

<H3>Auto Line Feed {Rcv CR}</H3>

<P> This is just another type of "Auto New Line".  When a CR (carriage
return) character is received, a LF (line feed) action is added
resulting in a new line being displayed.  Since Linux marks the end of
lines with LF, this option is not used.</P>

<H3><A NAME="rec_del"></A> Recognize Del (Wyse Only ??) or Null </H3>

<P> If off, the DEL character received by the terminal is ignored.  If
on the DEL performs a destructive backspace.  Null characters are
usually ignored in any case.  Both DEL and NULL are sometimes used for
padding.  See 
<A HREF="Text-Terminal-HOWTO-11.html#padding">Padding</A></P>

<H2><A NAME="ss14.13">14.13</A> <A HREF="Text-Terminal-HOWTO.html#toc14.13">Where New Text Goes</A>
</H2>

<H3>Line Wrap</H3>

<P> Also called "Auto Wrap(around)".  What happens when the right edge
of the screen is reached (col. 80, etc) and no return character (or
the like) has been sent from the host?  If Line Wrap is set, then the
rest of the line displays on the line below, etc.  Otherwise, the rest
of the line is lost and is not seen on the screen.  Any good
application should handle the situation correctly (provided the
terminfo knows how Line Wrap is set).  Thus even if Line Wrap is not
set, the application should either wrap the screen for long lines or
provide another way for you to view the cutoff tail of long lines (by
use of the arrow keys, etc).  But a raw copy command (and other
situations) may not do this so it's often best to set line wrap.</P>
<P>For an 80 col. screen, most terminals only wrap if the 81st character
from the host is a graphic (printable) character.  This allows for the
case where 81st character from the host might be "return" or a
"newline" (non-graphic characters) which means that the application is
handing the wrapping OK and intervention by the terminal is not
needed.</P>

<H3>Scrolling</H3>

<P> Scrolling {Scrl} is where all the lines on the screen move up or
down.  Its also called "panning" which includes movement sideways.  In
ordinary scrolling lines roll off the bottom or top of the screen and
disappear, and new lines from the host appear at the opposite edge
(top or bottom).  There are 3 types of this: smooth, jump, or burst.
Burst is not really scrolling since its an instant replacement of an
old screenfull by a new one (although some lines on the new screen may
be from the old screen).  Jump is where new lines jump into view one
at a time.  Smooth {Smth} is where the text moves at a steady speed
upward or downward.  If the smooth scroll rate is slow enough, one may
read the newly visible lines when they are still scrolling (in motion).</P>
<P>Smooth scrolling on slow terminals was once useful since one could
continue reading as the display was scrolling.  But with higher baud
rates, jump scroll is so fast that little time is lost as the new
display appears.  Since it takes a little longer to read scrolling
text than fixed text, it may actually waste more time if smooth
scrolling is selected.</P>
<P>If (auto)scrolling {Autoscrl} is disabled, then new text from the host
must go somewhere so it is put at the top of the display.  If the old
text is not erased, the new text merges (nonsensically) into the old.
If the old text is erased, then the new text is out of context.  So
keep (auto)scrolling enabled.</P>

<H3>New Page?</H3>

<P> See 
<A HREF="Text-Terminal-HOWTO-9.html#pages_">Pages</A> and 
<A HREF="Text-Terminal-HOWTO-22.html#pages_def">Pages</A> for explanations of pages.  When the current page is
full (the last line is finished) should the page scroll, or should a
new page be created (leaving the previous page stored in the
terminal's display memory).  If {Autopage} is set, then a new page is
created.  Since you are probably not using pages, you should probably
set this to off.</P>

<H2><A NAME="funct_keys"></A> <A NAME="ss14.14">14.14</A> <A HREF="Text-Terminal-HOWTO.html#toc14.14">Function Keys </A>
</H2>

<P> These are the keys labeled F1, F2, etc.  On older terminals they
may be labeled PF1, PF2, etc. where the P stands for Programmable.
Some keyboards have both.  One may program (redefine) these keys to
send out a string of user-defined bytes.  This doesn't work for older
terminals such as vt100 or for the Linux command-line interface (how
sad).  They may often be easily "programmed" using a certain set-up
menu {FKey}.  On some terminals, one may also specify where this
string is sent to when the key is pressed.  In "normal" mode, pressing
the key is just like typing the string at the keyboard.  In "local"
mode pressing the key sends it to the terminal (just like if the
terminal was in local mode).  This may be used to send escape
sequences to the terminal so as to configure it in a special way.  In
"remote" mode, the string is always sent out the serial port to the
host computer (even if the terminal is in local mode).</P>

<H2><A NAME="ss14.15">14.15</A> <A HREF="Text-Terminal-HOWTO.html#toc14.15">Block Mode Options</A>
</H2>

<P> Some options are only for the case of 
<A HREF="Text-Terminal-HOWTO-23.html#block">Block Mode</A>.  This option is powerful since it provides forms and takes
load off the host computer by transmitting in bursts.  But it's more
complicated to set up and is thus not used too much.</P>

<H3>Forms Display</H3>

<P> In block mode some regions of the screen are for the text of forms
and are thus write-protected "Prot" {WPRT}.  Options may set the characters
in these regions to appear dim, reverse video {WPRT Rev}, and/or
underlined {WPRT Undrln}.  {WPRT Intensity} may be set to dim, normal,
or even blank (invisible)</P>

<H3>Send Entire Block ?</H3>

<P> Should write-protected text (the original text in the form) be
sent to the host upon transmission of a block: {Send All} or is
write-protected text also read-protected: {Send Erasable}</P>

<H3>Region to Send</H3>

<P> Should the entire screen be sent or just the scrolling region?
{Send Area}.  Should the sending stop when the current cursor position
is reached?  If {Xfer Term} is set to Cursor, only the data on the
screen up to the cursor is sent.</P>

<H3>Block/Page terminator</H3>

<P> What is the termination symbol to be appended to a block of data?
{Blk End} or at the end of a page {Send Term}ination.</P>

<H2><A NAME="ss14.16">14.16</A> <A HREF="Text-Terminal-HOWTO.html#toc14.16">Locks</A>
</H2>

<P> There are various types of Locks.  One is the Locked keyboard due
to flow control.  See 
<A HREF="Text-Terminal-HOWTO-11.html#keybrd_lock">Keyboard Lock</A>
Another lock {Feature Lock} is that which prohibits the host computer
from changing the terminal set-up by sending certain escape sequences
to the terminal.  Placing such a lock may result in unexpected
behavior as application programs send escape sequences to the
terminals that are ignored.  Not all set-up parameters lock.  Unless
you have a good reason to do so, you should not enable such locking.</P>
<P>A Function Key lock will prohibit the computer from redefining what a
programmable function key sends.  You may want to use this if you have
something important programmed into the function keys.</P>

<H2><A NAME="ss14.17">14.17</A> <A HREF="Text-Terminal-HOWTO.html#toc14.17">Screen Saver {Scrn Saver}</A>
</H2>

<P> Also called "CRT Saver".  This turns off (or dims) the screen
after the terminal is not used for a period of time.  It may prolong
the life of the screen and save some energy.  Hitting any key will
usually restore the screen and may "execute" that key so it's best to
hit the shift-key, etc.</P>

<H2><A NAME="ss14.18">14.18</A> <A HREF="Text-Terminal-HOWTO.html#toc14.18">Printer</A>
</H2>

<P> For Wyse, if there is no {Printer Attached} set it to Off.  It's
not essential to do this, but if you do it any escape sequence to send
text to the printer (instead of the terminal) will be ignored.</P>
<P>Setting up the printer port is about the same (usually simpler) as
setting up the communications on the main port.  There are a couple of
options specific to the printer.  Is the printer a serial or parallel
printer?  If it's parallel it should be designated as such in setup
and connected to the parallel port on the terminal (if there is one).
Should a FF (form feed) be sent to the printer at the end of a print
job?  If {Print Term} is set to FF, this will happen.</P>

<HR>
<A HREF="Text-Terminal-HOWTO-15.html">Next</A>
<A HREF="Text-Terminal-HOWTO-13.html">Previous</A>
<A HREF="Text-Terminal-HOWTO.html#toc14">Contents</A>
</BODY>
</HTML>
