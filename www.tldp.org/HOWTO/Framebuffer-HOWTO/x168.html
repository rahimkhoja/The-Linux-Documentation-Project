<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
><HEAD
><TITLE
>Using framebuffer devices on x86 platforms</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REL="HOME"
TITLE="Framebuffer HOWTO"
HREF="index.html"><LINK
REL="PREVIOUS"
TITLE="What advantages does framebuffer devices have?"
HREF="x134.html"><LINK
REL="NEXT"
TITLE="Using framebuffer devices on m68k platforms"
HREF="x591.html"></HEAD
><BODY
CLASS="section"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Framebuffer HOWTO</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x134.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="x591.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="AEN168"
></A
>4. Using framebuffer devices on x86 platforms</H1
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN170"
></A
>4.1. What is vesafb?</H2
><P
>Vesafb is a framebuffer driver for x86
				architecture that works with VESA 2.0 compliant
				graphic cards. It is closely related to the
				framebuffer device drivers in the
				kernel.</P
><P
>vesafb is a display driver that enables the use
				of graphical modes on your x86 platform for
				bitmapped text consoles. It can also display a
				logo, which is probably the main reason why
				you'd want to use vesafb :o)</P
><P
>Unfortunately, you can not use vesafb
				successfully with VESA 1.2 cards.  This is
				because these 1.2 cards do not use
				<EM
>linear</EM
> frame buffering.
				Linear frame buffering simply means that the
				system's CPU is able to access every bit of the
				display. Historically, older graphic adapters
				could allow the CPU to access only 64K at a
				time, hence the limitations of the dreadful
				CGA/EGA graphic modes! It may be that someone
				will write a vesafb12 device driver for these
				cards, but this will use up precious kernel
				memory and involve a nasty hack.</P
><P
>There is however a potential workaround to add
				VESA 2.0 extensions for your legacy VESA 1.2
				card. You may be able to download a TSR type
				program that will run from DOS, and used with
				loadlin, can help configure the card for the
				appropriate graphic console modes.  Note that
				this will not always work, as an example some
				Cirrus Logic cards such as the VLB 54xx series
				are mapped to a range of memory addresses (for
				example, within the 15MB-16MB range) for frame
				buffering which preludes these from being used
				successfully with systems that have more than
				32MB of memory. There is a way to make this
				work, i.e. if you have a BIOS option to leave a
				memory hole at 15MB-16MB range, it might work,
				Linux doesn't support the use of memory holes.
				However there are patches for this option
				though [Who has these and where do one gets
				them from?]. If you wish to experiment with
				this option, there are plenty of TSR style
				programs available, a prime example is UNIVBE,
				which can be found on the Internet.</P
><P
>Alternatively, you may be able to download kernel
				patches to allow your VESA 1.2 card to work
				with the VESA framebuffer driver. For example,
				there are patches for use with older S3 boards
				(such as S3 Trio, S3 Virge) that supports VESA
				1.2. For these cards, you can pick up patches
				from <A
HREF="ftp://ccssu.crimea.ua/pub/linux/kernel/v2.2/unofficial/s3new.diff.gz"
TARGET="_top"
>ftp://ccssu.crimea.ua/pub/linux/kernel/v2.2/unofficial/s3new.diff.gz</A
>.
			</P
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN179"
></A
>4.2. How do I activate the vesafb drivers?</H2
><P
>Assuming you are using menuconfig, you will need
				to do the following steps:</P
><P
>If your processor (on x86 platforms) supports
				MTRRs, enable this. It speeds up memory copies
				between the processor and the graphic card, but
				not strictly necessary. You can of course, do
				this after you have the console device
				working.</P
><P
><EM
>IMPORTANT: For 2.1.x kernels, go into
					the Code Maturity Level menu, and
					enable the prompt for development
					and / or incomplete drivers.  This is
					no longer necessary for the 2.2.x
					kernels.</EM
></P
><P
>Go into the Console Drivers menu, and enable the
				following:</P
><P
></P
><UL
><LI
><P
>VGA Text Console</P
></LI
><LI
><P
>Video Selection
						Support</P
></LI
><LI
><P
>Support for frame buffer
						devices
						(experimental)</P
></LI
><LI
><P
>VESA VGA Graphic
						console</P
></LI
><LI
><P
>Advanced Low Level
						Drivers</P
></LI
><LI
><P
>Select Mono, 2bpp, 4bpp, 8bpp,
						16bpp, 24bpp and 32bpp packed
						pixel drivers</P
></LI
></UL
><P
>VGA Chipset Support (text only) -
				vgafb - used to be part of the
				list above, but it has been removed as it is
				now deprecated and no longer supported. It will
				be removed shortly. Use VGA Text Console
				(fbcon) instead. VGA
				Character/Attributes is only used with VGA
				Chipset Support, and doesn't need to be
				selected.</P
><P
>Ensure that the Mac variable bpp packed pixel
				support is not enabled.  Linux kernel release
				2.1.111 (and 112) seemed to enable this
				automatically if Advanced Low Level Drivers was
				selected for the first time. This no longer
				happens with 2.1.113.</P
><P
>There is also the option to compile in fonts into
				memory, but this isn't really necessary, and
				you can always use kbd-0.99's (see
				section on fonts) setfont utility to change
				fonts by loading fonts into the console
				device.</P
><P
>Make sure these aren't going to be modules. [Not
				sure if it's possible to build them as modules
				yet - please correct me on this]</P
><P
>You'll need to create the framebuffer device in
				/dev. You need one per framebuffer
				device, so all you need to do is to type in
				mknod /dev/fb0 c 29 0 for the
				first one. Subsequent ones would be in
				multiples of 32, so for example to create
				/dev/fb1, you would need to type
				in mknod /dev/fb1 c 29 32, and so
				on up to the eighth framebuffer device
				(mknod /dev/fb7 c 29 224)</P
><P
>Then rebuild the kernel, modify
				/etc/lilo.conf to include the
				VGA=ASK parameter, and run
				lilo, this is required in order
				for you to be able to select the modes you wish
				to use.</P
><P
>Here's a sample LILO configuration (taken from my
				machine)</P
><P
><P
CLASS="literallayout"
>&#13;# LILO configuration file
boot = /dev/hda3
delay = 30
prompt
vga = ASK # Let user enter the desired modes
image = /vmlinuz
  root = /dev/hda3
  label = Linux
  read-only # Non-UMSDOS filesystems should be mounted read-only for checking
		  	</P
></P
><P
>Reboot the kernel, and as a simple test, try
				entering 0301 at the VGA prompt
				(this will give you 640x480 @ 256), and you
				should be able to see a cute little Penguin
				logo.</P
><P
>Note, that at the VGA prompt, you're required to
				type in the number in the format of "0" plus
				the three-digit number, and miss out the 'x'.
				This isn't necessary if you're using
				LILO.</P
><P
>Once you can see that's working well, you can
				explore the various VESA modes (see below) and
				decide on the one that you like the best, and
				hardwire that into the "VGA=x" parameter in
				lilo.conf. When you have chosen
				the one you like the best, look up the
				equivalent hexadecimal number from the table
				below and use that (i.e. for 1280x1024 @ 256,
				you just use "VGA=0x307"), and
				re-run lilo. That's all there it is to it.  For
				further references, read the LoadLin/LILO
				HOWTOs.</P
><P
><EM
>NOTE!</EM
> vesafb does not enable
				scrollback buffering as a default. You will
				need to pass to the kernel the option to enable
				it. Use video=vesa:ypan or
				video=vesa:ywrap to activate it.
				Both does the same thing, but in different
				ways. ywrap is a lot faster than
				ypan but may not work on slightly
				broken VESA 2.0 graphic cards.
				ypan is slower than
				ywrap but a lot more compatible.
				This option is only present in kernel 2.1.116
				and above.  Earlier kernels did not have the
				ability to allow scrollback buffering in
				vesafb.</P
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN235"
></A
>4.3. What VESA modes are available to me?</H2
><P
>This really depends on the type of VESA 2.0
				 compliant graphic card that you have in your
				 system, and the amount of video memory
				 available. This is just a matter of testing
				 which modes work best for your graphic
				 card.</P
><P
>The following table shows the mode numbers you
				can input at the VGA prompt or for use with the
				LILO program. (actually these numbers are plus
				0x200 to make it easier to refer to the
				table)</P
><DIV
CLASS="table"
><A
NAME="AEN239"
></A
><P
><B
>Table 1. VESA modes</B
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
WIDTH="12%"
ALIGN="RIGHT"
VALIGN="MIDDLE"
>Depth</TH
><TH
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>640x400</TH
><TH
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>640x480</TH
><TH
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>800x600</TH
><TH
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>1024x768</TH
><TH
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>1152x864</TH
><TH
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>1280x1024</TH
><TH
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>1600x1200</TH
></TR
></THEAD
><TBODY
><TR
><TD
WIDTH="12%"
ALIGN="RIGHT"
VALIGN="MIDDLE"
>4 bits</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>?</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>?</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x302</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>?</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>?</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>?</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>?</TD
></TR
><TR
><TD
WIDTH="12%"
ALIGN="RIGHT"
VALIGN="MIDDLE"
>8 bits</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x300</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x301</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x303</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x305</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x161</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x307</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x31C</TD
></TR
><TR
><TD
WIDTH="12%"
ALIGN="RIGHT"
VALIGN="MIDDLE"
>15 bits</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>?</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x310</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x313</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x316</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x162</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x319</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x31D</TD
></TR
><TR
><TD
WIDTH="12%"
ALIGN="RIGHT"
VALIGN="MIDDLE"
>16 bits</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>?</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x311</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x314</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x317</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x163</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x31A</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x31E</TD
></TR
><TR
><TD
WIDTH="12%"
ALIGN="RIGHT"
VALIGN="MIDDLE"
>24 bits</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>?</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x312</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x315</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x318</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>?</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x31B</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x31F</TD
></TR
><TR
><TD
WIDTH="12%"
ALIGN="RIGHT"
VALIGN="MIDDLE"
>32 bits</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>?</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>?</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>?</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>?</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>0x164</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>?</TD
><TD
WIDTH="12%"
ALIGN="CENTER"
VALIGN="MIDDLE"
>?</TD
></TR
></TBODY
></TABLE
></DIV
><P
>Key: 8 bits = 256 colours, 15 bits = 32,768
				colours, 16 bits = 65,536 colours, 24 bits =
				16.8 million colours, 32 bits - same as 24
				bits, but the extra 8 bits can be used for
				other things, and fits perfectly on a 32 bit
				PCI/VLB/EISA bus.</P
><P
>Additional modes are at the discretion of the
				manufacturer, as the VESA 2.0 document only
				defines modes up to 0x31F. You may need to do
				some fiddling around to find these extra
				modes.</P
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN317"
></A
>4.4. Got a Matrox card?</H2
><P
>If you've got a Matrox graphic card, you don't
				actually need vesafb, you need the matroxfb
				driver instead. This greatly enhances the
				capabilities of your card. Matroxfb will work
				with Matrox Mystique Millennium I &#38; II,
				G100 and G200. It also supports multiheaded
				systems (that is, if you have two Matrox cards
				in your machine, you can use two displays on
				the same machine!). To configure for Matrox,
				you will need to do the following:</P
><P
>You might want to upgrade the Matrox BIOS first,
				you can download the BIOS upgrade from <A
HREF="http://www.matrox.com/mgaweb/drivers/ftp_bios.htm"
TARGET="_top"
>http://www.matrox.com/mgaweb/drivers/ftp_bios.htm</A
>
				Beware that you will need DOS to do
				this.</P
><P
>Go into the Code Maturity Level menu, and enable
				the prompt for development and/or incomplete
				drivers [note this may change for future
				kernels - when this happens, this HOWTO will be
				revised]</P
><P
>Go into the Console Drivers menu, and enable the
				following:</P
><P
></P
><UL
><LI
><P
>VGA Text
						Console</P
></LI
><LI
><P
>Video Selection
						Support</P
></LI
><LI
><P
>Support for frame buffer
						devices
						(experimental)</P
></LI
><LI
><P
>Matrox
						Acceleration</P
></LI
><LI
><P
>Select the following depending
						on the card that you
						have</P
></LI
><LI
STYLE="list-style-type: none"
><P
></P
><UL
><LI
STYLE="list-style-type: none"
><P
>Millennium I /
								II
								support</P
></LI
><LI
STYLE="list-style-type: none"
><P
>Mystique
								support</P
></LI
><LI
STYLE="list-style-type: none"
><P
>G100 / G200
								support</P
></LI
></UL
></LI
><LI
><P
>Enable Multihead Support if you
						want to use more than one
						Matrox card</P
></LI
><LI
><P
>Advanced Low Level
						Drivers</P
></LI
><LI
><P
>elect Mono, 2bpp, 4bpp, 8bpp,
						16bpp, 24bpp and 32bpp packed
						pixel drivers</P
></LI
></UL
><P
>Rebuild your kernel. Then you will need to modify
				your lilo.conf file to enable the
				Matroxfb device. The quickest and simplest way
				is re-use mine.</P
><P
><P
CLASS="literallayout"
>&#13;# LILO configuration file
boot = /dev/hda3
delay = 30
prompt
vga = 792    # You need to do this so it boots up in a sane state
# Linux bootable partition config begins
image = /vmlinuz
append = "video=matrox:vesa:440" # then switch to Matroxfb
  root = /dev/hda3
  label = Linux
  read-only # Non-UMSDOS filesystems should be mounted read-only for checking
			</P
></P
><P
>Lastly, you'll need to create the framebuffer
				device in /dev. You need one per
				framebuffer device, so all you need to do is to
				type in mknod /dev/fb0 c 29 0 for
				the first one.  Subsequent ones would be in
				multiples of 32, so for example to create
				/dev/fb1, you would need to type
				in mknod /dev/fb1 c 29 32, and so
				on up to the eight framebuffer device
				(mknod /dev/fb7 c 29 224i)</P
><P
>And that should be it! [NOTE: Is anyone using
				this multiheaded support, please get in touch
				with me ASAP - I need to talk to you about it
				so I can document it!</P
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN361"
></A
>4.5. Got a Permedia card?</H2
><P
>Permedia cards cannot be used with the vesafb
				driver, but fortunately, there is the Permedia
				framebuffer driver available to use. Assuming
				you are using menuconfig, do the
				following:</P
><P
>Go into the Code Maturity Level menu, and enable
				the prompt for development and/or incomplete
				drivers [note this may change for future
				kernels - when this happens, this HOWTO will be
				revised]</P
><P
>Go into the Console Drivers menu and select the
				following:</P
><P
></P
><UL
><LI
><P
>VGA Text
						Console</P
></LI
><LI
><P
>Video Selection
						Support</P
></LI
><LI
><P
>Support for frame buffer
						devices
						(experimental)</P
></LI
><LI
><P
>Permedia2 support
						(experimental)</P
></LI
><LI
><P
>Generic Permedia2 PCI board
						support</P
></LI
><LI
><P
>Advanced Low Level
						Drivers</P
></LI
><LI
><P
>Select Mono, 2bpp, 4bpp, 8bpp,
						16bpp, 24bpp and 32bpp packed
						pixel drivers</P
></LI
><LI
><P
>Optionally, select the
						following, if you wish to use
						the compiled in
						fonts</P
></LI
><LI
STYLE="list-style-type: none"
><P
></P
><UL
><LI
STYLE="list-style-type: none"
><P
>Select
								compiled-in
								fonts</P
></LI
><LI
STYLE="list-style-type: none"
><P
>Select Sparc
								console 12x22
								font</P
></LI
></UL
></LI
></UL
><P
>Rebuild your kernel. Then you will need to modify
				your lilo.conf file to enable the
				pm2fb device.  The quickest and simplest way is
				re-use the following:</P
><P
><P
CLASS="literallayout"
>&#13;# LILO configuration file
boot = /dev/hda3
delay = 30
prompt
vga = 792    # You need to do this so it boots up in a sane state
# Linux bootable partition config begins
image = /vmlinuz
append = "video=pm2fb:mode:1024x768-75,font:SUN12x22,ypan" # then switch to pm2fb
  root = /dev/hda3
  label = Linux
  read-only # Non-UMSDOS filesystems should be mounted read-only for checking
			</P
></P
><P
>The line
				"pm2fb:mode:1024x768-75,font:SUN12x22,ypan"
				indicates you are selecting a 1024x768 mode at
				75Hz, with the SUN12x22 font
				selected (if you did select it), including ypan
				for scrollback support. You may select other
				modes if you desire.</P
><P
>Lastly, you'll need to create the framebuffer
				device in /dev. You need one per
				framebuffer device, so all you need to do is to
				type in mknod /dev/fb0 c 29 0 for
				the first one.  Subsequent ones would be in
				multiples of 32, so for example to create
				/dev/fb1, you would need to type
				in mknod /dev/fb1 c 29 32, and so
				on up to the eight framebuffer device
				(mknod /dev/fb7 c 29 224)</P
><P
>For more information on the other features of the
				Permedia framebuffer driver, point your browser
				at <A
HREF="http://www.cs.unibo.it/~nardinoc/pm2fb/index.html"
TARGET="_top"
>http://www.cs.unibo.it/~nardinoc/pm2fb/index.html</A
></P
><P
>video=pm2fb:[option[,option[,option...]]]</P
><P
>where option is one of the following:</P
><P
></P
><UL
><LI
><P
>off - disables the
						driver</P
></LI
><LI
><P
>mode:resolution -
						sets the console resolution.
						The modes have been taken from
						the fb.modes.ATI
						file in Geert's
						fbset package. The
						depth for all the modes is 8
						bpp. This the list of available
						modes:</P
></LI
><LI
STYLE="list-style-type: none"
><P
></P
><UL
><LI
STYLE="list-style-type: none"
><P
>640x480-(60,72,75,90,100)</P
></LI
><LI
STYLE="list-style-type: none"
><P
>640x480-(60,72,75,90,100)</P
></LI
><LI
STYLE="list-style-type: none"
><P
>1024x768-(60,70,72,75,90,100,illo)
									illo=80KHz
									100Hz</P
></LI
><LI
STYLE="list-style-type: none"
><P
>152x864-(60,70,75,80)</P
></LI
><LI
STYLE="list-style-type: none"
><P
>1280x1024-(60,70,74,75)</P
></LI
><LI
STYLE="list-style-type: none"
><P
>1600x1200-(60,66,76)</P
></LI
></UL
></LI
><LI
STYLE="list-style-type: none"
><P
>The default
						resolution is
						640x480-60</P
></LI
><LI
><P
>font:name - sets
						the console font. Example
						font:SUN12x12</P
></LI
><LI
><P
>ypan - sets the
						current virtual height as big
						as video memory
						permits.</P
></LI
><LI
><P
>oldmem - used for
						CybervisionPPC boards only with
						Fujitsi SGRAMs mounted. Applies
						to all CyberVisionPPCs made
						before
						30-Dec-1998.</P
></LI
><LI
><P
>virtual - used
						with kernels capable of
						remapping the PCI
						regions</P
></LI
></UL
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN452"
></A
>4.6. Got an ATI card?</H2
><P
>[Note: This information is at best, only
				second-hand or third-hand, since I don't have
				an ATI card to test it with. Feel free to
				correct me if I am wrong or flame me!] 8)</P
><P
>ATI cards can be used with the vesafb driver, but
				you may or may not have problems, depending on
				how horribly broken the card is. Fortunately,
				there is the atyfb framebuffer driver available
				to use. Assuming you are using menuconfig, do
				the following:</P
><P
>Go into the Code Maturity Level menu, and enable
				the prompt for development and/or incomplete
				drivers [note this may change for future
				kernels - when this happens, this HOWTO will be
				revised]</P
><P
>Go into the Console Drivers menu and select the
				following:</P
><P
></P
><UL
><LI
><P
>VGA Text
						Console</P
></LI
><LI
><P
>Video Selection
						Support</P
></LI
><LI
><P
>Support for frame buffer
						devices
						(experimental)</P
></LI
><LI
><P
>ATI Mach64 display
						support</P
></LI
><LI
><P
>Advanced Low Level
						Drivers</P
></LI
><LI
><P
>Select Mono, 2bpp, 4bpp, 8bpp,
						16bpp, 24bpp and 32bpp packed
						pixel drivers</P
></LI
><LI
><P
>Optionally, select the
						following, if you wish to use
						the compiled in
						fonts</P
></LI
><LI
STYLE="list-style-type: none"
><P
></P
><UL
><LI
STYLE="list-style-type: none"
><P
>Select
								compiled-in
								fonts</P
></LI
><LI
STYLE="list-style-type: none"
><P
>Select Sparc
								console 12x22
								font</P
></LI
></UL
></LI
></UL
><P
>Rebuild your kernel. Then you will need to modify
				your lilo.conf file to enable the
				atyfb device.  The quickest and
				simplest way is re-use the following:</P
><P
><P
CLASS="literallayout"
>&#13;# LILO configuration file
boot = /dev/hda3
delay = 30
prompt
vga = 792    # You need to do this so it boots up in a sane state
# Linux bootable partition config begins
image = /vmlinuz
append = "video=atyfb:mode:1024x768,font:SUN12x22"
  root = /dev/hda3
  label = Linux
  read-only # Non-UMSDOS filesystems should be mounted read-only for checking
			</P
></P
><P
>The line "atyfb:mode:1024x768,font:SUN12x22"
				indicates you are selecting a 1024x768
				mode.</P
><P
>Lastly, you'll need to create the framebuffer
				device in /dev. You need one per
				framebuffer device, so all you need to do is to
				type in mknod /dev/fb0 c 29 0 for
				the first one.  Subsequent ones would be in
				multiples of 32, so for example to create
				/dev/fb1, you would need to type
				in mknod /dev/fb1 c 29 32, and so
				on up to the eight framebuffer device
				(mknod /dev/fb7 c 29 224)</P
><P
>video=atyfb:[option[,option[,option...]]]</P
><P
>where option is one of the following:</P
><P
></P
><UL
><LI
><P
>font - selects
						font to use (compiled into
						kernel)</P
></LI
><LI
><P
>noblink - turns
						off blinking</P
></LI
><LI
><P
>noaccel - disables
						acceleration</P
></LI
><LI
><P
>vram - how much
						video memory is there on the
						card</P
></LI
><LI
><P
>pll -
						unknown</P
></LI
><LI
><P
>mclk -
						unknown</P
></LI
><LI
><P
>vmode -
						unknown</P
></LI
><LI
><P
>cmode - sets
						colour depth (4, 8, 15, 16, 24
						and 32)</P
></LI
></UL
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN521"
></A
>4.7. Which graphic cards are VESA 2.0 compliant?</H2
><P
>This lists all the graphic devices that are known
				to work with the vesafb device driver:</P
><P
></P
><UL
><LI
><P
>ATI PCI VideoExpression 2MB
						(max. 1280x1024 @
						8bit)</P
></LI
><LI
><P
>ATI PCI
						All-in-Wonder</P
></LI
><LI
><P
>Matrox Millennium PCI - BIOS
						v3.0</P
></LI
><LI
><P
>Matrox Millennium II PCI - BIOS
						v1.5</P
></LI
><LI
><P
>Matrox Millennium II AGP - BIOS
						v1.4</P
></LI
><LI
><P
>Matrox Millennium G200 AGP -
						BIOS v1.3</P
></LI
><LI
><P
>Matrox Mystique &#38; Mystique
						220 PCI - BIOS
						v1.8</P
></LI
><LI
><P
>Matrox Mystique G200 AGP - BIOS
						v1.3</P
></LI
><LI
><P
>Matrox Productiva G100 AGP -
						BIOS v1.4</P
></LI
><LI
><P
>All Riva 128 based
						cards</P
></LI
><LI
><P
>Diamond Viper V330 PCI
						4MB</P
></LI
><LI
><P
>Genoa Phantom 3D/S3
						ViRGE/DX</P
></LI
><LI
><P
>Hercules Stingray 128/3D with
						TV output</P
></LI
><LI
><P
>Hercules Stingray 128/3D
						without TV output - needs BIOS
						upgrade (free from
						support@hercules.com)</P
></LI
><LI
><P
>SiS 6326 PCI/AGP
						4MB</P
></LI
><LI
><P
>STB Lightspeed 128 (Nvida Riva
						128 based)
						PCI</P
></LI
><LI
><P
>STB Velocity 128 (Nvida Riva
						128 based)
						PCI</P
></LI
><LI
><P
>Jaton Video-58P ET6000 PCI
						2MB-4MB (max. 1600x1200 @
						8bit)</P
></LI
><LI
><P
>Voodoo2 2000</P
></LI
></UL
><P
>This list below blacklists graphic cards that
				doesn't work with the vesafb device:</P
><P
></P
><UL
><LI
><P
>TBD</P
></LI
></UL
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN567"
></A
>4.8. Can I compile vesafb as a module?</H2
><P
>As far as is known, vesafb can't be modularised,
				although at some point in time, the developer
				of vesafb may decide to modify the sources for
				modularising. Note that even if modularising is
				possible, at boot time you will not be able to
				see any output on the display until vesafb is
				modprobed. It's probably a lot wiser to leave
				it in the kernel, for these cases when there
				are booting problems.</P
></DIV
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="AEN570"
></A
>4.9. How do I modify the cursor</H2
><P
>With thanks to Martin Mares, taken from his
				VGA-softcursor.txt document.</P
><P
>Linux now has some ability to manipulate cursor
				appearance.  Normally, you can set the size of
				hardware cursor (and also work around some ugly
				bugs in those miserable Trident cards -- see
				#define TRIDENT_GLITCH in
				drivers/char/vga.c).  In case you
				enable "Software generated cursor" in the
				system configuration, you can play a few new
				tricks:  you can make your cursor look like a
				non-blinking red block, make it inverse
				background of the character it's over or to
				highlight that character and still choose
				whether the original hardware cursor should
				remain visible or not. There may be other
				things I have never thought of.</P
><P
>The cursor appearance is controlled by a
				&#60;ESC&#62;[?1;2;3c escape
				sequence where 1, 2 and 3 are parameters
				described below. If you omit any of them, they
				will default to zeroes.</P
><P
>Parameter 1 specifies cursor size (0 = default, 1
				= invisible, 2 = underline, ..., 8 = full
				block) + 16 if you want the software cursor to
				be applied + 32 if you want to always change
				the background colour + 64 if you dislike
				having the background the same as the
				foreground.  Highlights are ignored for the
				last two flags.</P
><P
>The second parameter selects character attribute
				bits you want to change (by simply XORing them
				with the value of this parameter). On standard
				VGA, the high four bits specify background and
				the low four the foreground. In both groups,
				low three bits set colour (as in normal colour
				codes used by the console) and the most
				significant one turns on highlight (or
				sometimes blinking - it depends on the
				configuration of your VGA).</P
><P
>The third parameter consists of character
				attribute bits you want to set.  Bit setting
				takes place before bit toggling, so you can
				simply clear a bit by including it in both the
				set mask and the toggle mask.</P
><P
></P
><UL
><LI
><P
>To get normal blinking
						underline, use: echo -e
							'\033&#60;ESC&#62;[?2c'</P
></LI
><LI
><P
>To get blinking block, use:
						echo -e
							'\033&#60;ESC&#62;[?6c'</P
></LI
><LI
><P
>To get red non-blinking block,
						use: echo -e
							'\033i&#60;ESC&#62;[?17;0;64c'</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x134.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="x591.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>What advantages does framebuffer devices have?</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Using framebuffer devices on m68k platforms</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>