<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.21">
 <TITLE>GNU/Linux AI &amp; Alife HOWTO: Agents &amp; Robotics</TITLE>
 <LINK HREF="AI-Alife-HOWTO-7.html" REL=next>
 <LINK HREF="AI-Alife-HOWTO-5.html" REL=previous>
 <LINK HREF="AI-Alife-HOWTO.html#toc6" REL=contents>
</HEAD>
<BODY>
<A HREF="AI-Alife-HOWTO-7.html">Next</A>
<A HREF="AI-Alife-HOWTO-5.html">Previous</A>
<A HREF="AI-Alife-HOWTO.html#toc6">Contents</A>
<HR>
<H2><A NAME="Agents"></A> <A NAME="Agents &amp; Robotics"></A> <A NAME="s6">6.</A> <A HREF="AI-Alife-HOWTO.html#toc6">Agents &amp; Robotics</A>    </H2>


<P>Software brains for computers that do stuff. Everythin from fun and
games to data mining to physical robotics. This is a great hobbiest
area of AI with many areas of interest to pursue. I've broken it down
loosely into 2 sections. AI for purely software based agents and that
for embodied agents (even if only simulated).</P>


<H2><A NAME="Software Agents"></A> <A NAME="ss6.1">6.1</A> <A HREF="AI-Alife-HOWTO.html#toc6.1">Software Agents</A>
        </H2>


<P>Also known as intelligent software agents or just agents, this
area of AI research deals with simple applications of small
programs that aid the user in his/her work. They can be mobile
(able to stop their execution on one machine and resume it on
another) or static (live in one machine). They are usually
specific to the task (and therefore fairly simple) and meant
to help the user much as an assistant would.</P>
<P>
<DL>
<P>
<A NAME="2APL"></A> </P>
<DT><B>2APL</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://apapl.sourceforge.net/">http://apapl.sourceforge.net/</A></LI>
</UL>
</P>
<P>2APL (pronounced as double-a-p-l) is an agent-oriented programming
language that facilitates the implementation of multi-agent systems. At
the multi-agent level, it provides programming constructs to specify a
multi-agent system in terms of a set of individual agents, a set of
environments in which they can perform actions, and the access relation
between the individual agents and the environments. At the individual
agent level, it provides programming constructs to implement cognitive
agents based on the BDI architecture.</P>

<P>
<A NAME="3APL"></A> </P>
<DT><B>3APL</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.uu.nl/3apl/">http://www.cs.uu.nl/3apl/</A></LI>
<LI>Wikipedia entry: 
<A HREF="http://en.wikipedia.org/wiki/3APL">http://en.wikipedia.org/wiki/3APL</A></LI>
<LI>Mobile version: 
<A HREF="http://www.cs.uu.nl/3apl-m/">http://www.cs.uu.nl/3apl-m/</A></LI>
</UL>
</P>
<P>3APL is a programming language for implementing cognitive agents. It
provides programming constructs for implementing agents' beliefs,
goals, basic capabilities (such as belief updates, external actions, or
communication actions) and a set of practical reasoning rules through
which agents' goals can be updated or revised. The 3APL programs are
executed on the 3APL platform. Each 3APL program is executed by means
of an interpreter that deliberates on the cognitive attitudes of that
agent.</P>

<P>
<A NAME="Agent"></A> </P>
<DT><B>Agent</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="http://www.cpan.org/modules/by-category/23_Miscellaneous_Modules/Agent/">http://www.cpan.org/modules/by-category/23_Miscellaneous_Modules/Agent/</A></LI>
</UL>
</P>
<P>The Agent is a prototype for an Information Agent system. It is
both platform and language independent, as it stores contained
information in simple packed strings. It can be packed and shipped
across any network with any format, as it freezes itself in its
current state.</P>

<P>
<A NAME="agentTool"></A> </P>
<DT><B>agentTool</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://agenttool.cis.ksu.edu/">http://agenttool.cis.ksu.edu/</A></LI>
</UL>
</P>
<P>agentTool is a Eclipse-based graphical development environment to help
users analyze, design, and implement multiagent systems.  It is
designed to support the highly tailorable Organization-based Multiagent
Systems Engineering (O-MaSE) methodology. agentTool currently supports
all O-MaSE models including the Goal Model, Agent Model, Role Model,
Organization Model, Protocol Model, Plan Model, Capability-Action
Model, Domain Model, and Policy Model.</P>

<P>
<A NAME="Aglets"></A> </P>
<DT><B>Aglets Workbench</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.trl.ibm.com/aglets/index_e.htm">http://www.trl.ibm.com/aglets/index_e.htm</A></LI>
</UL>
</P>
<P>An aglet is a Java object that can move from one host on the
Internet to another.  That is, an aglet that executes on one host can
suddenly halt execution, dispatch to a remote host, and resume
execution there. When the aglet moves, it takes along its program code
as well as its state (data). A built-in security mechanism makes it
safe for a computer to host untrusted aglets. The Java Aglet API
(J-AAPI) is a proposed public standard for interfacing aglets and
their environment. J-AAPI contains methods for initializing an aglet,
message handling, and dispatching, retracting,
deactivating/activating, cloning, and disposing of the aglet. J-AAPI
is simple, flexible, and stable. Application developers can write
platform-independent aglets and expect them to run on any host that
supports J-AAPI.</P>

<P>
<A NAME="AJA"></A> </P>
<DT><B>AJA</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://home.arcor.de/michal.badonsky/AJA/">http://home.arcor.de/michal.badonsky/AJA/</A></LI>
</UL>
</P>
<P>AJA (Adaptable Java Agents) consists of two programming languages.
HADL (Higher Agent Definition Language) is a higher-level language used
for the description of the main agent parts. Java+ is the lower-level
language used for the programming of the agent parts defined in HADL.
It is actually Java enriched with the constructs for accessing
higher-level agent parts defined in HADL.</P>

<P>
<A NAME="A.L.I.C.E."></A> </P>
<DT><B>A.L.I.C.E.</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.alicebot.org/">http://www.alicebot.org/</A></LI>
<LI>Other AIML implementations:
<A HREF="http://pyaiml.sourceforge.net/">http://pyaiml.sourceforge.net/</A></LI>
</UL>
</P>
<P>The ALICE software implements AIML (Artificial Intelligence Markup
Language), a non-standard evolving markup language for creating chat
robots. The primary design feature of AIML is minimalism. Compared with
other chat robot languages, AIML is perhaps the simplest. The pattern
matching language is very simple, for example permitting only one
wild-card ('*') match character per pattern. AIML is an XML language,
implying that it obeys certain grammatical meta-rules. The choice of
XML syntax permits integration with other tools such as XML editors.
Another motivation for XML is its familiar look and feel, especially to
people with HTML experience.</P>

<P>
<A NAME="APRIL"></A> </P>
<DT><B>APRIL</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://sourceforge.net/projects/networkagent/">http://sourceforge.net/projects/networkagent/</A></LI>
</UL>
</P>
<P>APRIL is a symbolic programming language that is designed for writing
mobile, distributed and agent-based systems especially in an Internet
environment. It has advanced features such as a macro sub-language,
asynchronous message sending and receiving, code mobility, pattern
matching, higher-order functions and strong typing. The language is
compiled to byte-code which is then interpreted by the APRIL
runtime-engine.  APRIL now requires the InterAgent Communications Model
(ICM) to be installed before it can be installed. [Ed. ICM can be found
at the same web site]</P>

<P>
<A NAME="Ara"></A> </P>
<DT><B>Ara</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://wwwagss.informatik.uni-kl.de/Projekte/Ara/index_e.html">http://wwwagss.informatik.uni-kl.de/Projekte/Ara/index_e.html</A></LI>
</UL>
</P>
<P>Ara is a platform for the portable and secure execution of
mobile agents in heterogeneous networks. Mobile agents in this
sense are programs with the ability to change their host machine
during execution while preserving their internal state. This
enables them to handle interactions locally which otherwise had
to be performed remotely. Ara's specific aim in comparison to
similar platforms is to provide full mobile agent functionality
while retaining as much as possible of established programming
models and languages.</P>

<P>
<A NAME="Bee-gent"></A> </P>
<DT><B>Bee-gent</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.toshiba.co.jp/rdc/beegent/download/download.htm">http://www.toshiba.co.jp/rdc/beegent/download/download.htm</A></LI>
<LI>FAQ: 
<A HREF="http://www.toshiba.co.jp/rdc/beegent/faq/faq.htm">http://www.toshiba.co.jp/rdc/beegent/faq/faq.htm</A></LI>
</UL>
</P>
<P>Bee-gent is a new type of development framework in that it is a 100%
pure agent system. As opposed to other systems which make only some use
of agents, Bee-gent completely "Agentifies" the communication that
takes place between software applications. The applications become
agents, and all messages are carried by agents. Thus, Bee-gent allows
developers to build flexible open distributed systems that make optimal
use of existing applications.</P>

<P>
<A NAME="Bond"></A> </P>
<DT><B>Bond</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://bond.cs.ucf.edu/">http://bond.cs.ucf.edu/</A></LI>
</UL>
</P>
<P>Bond is a Java based distributed object system and agent framework. It
implements a message based middleware and associated services like
directory, persistence, monitoring and security. Bond allows to easily
build multi agent, distributed applications. Another application of
Bond will be a Virtual Laboratory supporting data annotation and
metacomputing.</P>

<P>
<A NAME="Cougaar"></A> </P>
<DT><B>Cougaar</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cougaar.org/">http://www.cougaar.org/</A></LI>
</UL>
</P>
<P>Cougaar is java-based architecture for the construction of large-scale
distributed agent-based applications.  It is the product of a
multi-year DARPA research project into large scale agent systems and
includes not only the core architecture but also a variety of
demonstration, visualization and management components to simplify the
development of complex, distributed applications. [Yet another java
based agent system -- ed.]</P>

<P>
<A NAME="D'Agent"></A> </P>
<DT><B>D'Agent (was AGENT TCL)</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://agent.cs.dartmouth.edu/software/agent2.0/">http://agent.cs.dartmouth.edu/software/agent2.0/</A></LI>
</UL>
</P>
<P>A transportable agent is a program that can migrate from machine
to machine in a heterogeneous network.  The program chooses when and
where to migrate.  It can suspend its execution at an arbitrary point,
transport to another machine and resume execution on the new machine.
For example, an agent carrying a mail message migrates first to a
router and then to the recipient's mailbox.  The agent can perform
arbitrarily complex processing at each machine in order to ensure that
the message reaches the intended recipient.</P>

<P>
<A NAME="DIET Agents"></A> </P>
<DT><B>DIET Agents</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://diet-agents.sourceforge.net">http://diet-agents.sourceforge.net</A></LI>
</UL>
</P>
<P>DIET Agents is a lightweight, scalable and robust multi-agent platform
in Java. It is especially suitable for rapidly developing P2P prototype
applications and/or adaptive, distributed applications that use
bottom-up, nature-inspired techniques.</P>

<P>
<A NAME="FishMarket"></A> </P>
<DT><B>FishMarket</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.iiia.csic.es/Projects/fishmarket/newindex.html">http://www.iiia.csic.es/Projects/fishmarket/newindex.html</A></LI>
</UL>
</P>
<P>FM - The FishMarket project conducted at the Artificial Intelligence
Research Institute (IIIA-CSIC) attempts to contribute in that direction
by developing FM, an agent-mediated electronic auction house which has
been evolved into a test-bed for electronic auction markets. The
framework, conceived and implemented as an extension of FM96.5 (a
Java-based version of the Fishmarket auction house), allows to define
trading scenarios based on fish market auctions (Dutch auctions). FM
provides the framework wherein agent designers can perform controlled
experimentation in such a way that a multitude of experimental market
scenarios--that we regard as tournament scenarios due to the
competitive nature of the domain-- of varying degrees of realism and
complexity can be specified, activated, and recorded; and trading
(buyer and seller) heterogeneous (human and software) agents compared,
tuned and evaluated.</P>

<P>
<A NAME="Grasshopper"></A> </P>
<DT><B>Grasshopper</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.grasshopper.de/">http://www.grasshopper.de/</A></LI>
</UL>
</P>
<P>Another Java agent system. Full featured and actively developed.
Commercial, but free. Historically targeted at embedded systems.</P>

<P>
<A NAME="Hive"></A> </P>
<DT><B>Hive</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://hive.sourceforge.net/">http://hive.sourceforge.net/</A></LI>
</UL>
</P>
<P>Hive is a Java software platform for creating distributed applications.
Using Hive, programmers can easily create systems that connect and use
data from all over the Internet. At its heart, Hive is an environment
for distributed agents to live, communicating and moving to fulfill
applications. We are trying to make the Internet alive.</P>

<P>
<A NAME="ICM"></A> </P>
<DT><B>ICM</B><DD><P>
<UL>
<LI>SourceForge site: 
<A HREF="http://sourceforge.net/projects/networkagent/">http://sourceforge.net/projects/networkagent/</A></LI>
</UL>
</P>
<P>The Inter-Agent Communication Model (ICM) is a communication mechanism
that can be used for sending messages between agents in an asynchronous
fashion. Its intended application area is as a transportation mechanism
for agent communication languages (ACLs), such as KQML and FIPA's ACL.</P>

<P>
<A NAME="Jacomma"></A> </P>
<DT><B>Jacomma</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://jacomma.sourceforge.net/">http://jacomma.sourceforge.net/</A></LI>
<LI>SourceForge site: 
<A HREF="http://sourceforge.net/projects/jacomma/">http://sourceforge.net/projects/jacomma/</A></LI>
</UL>
</P>
<P>Jacomma is an agent development platform/framework for developing
distributed, mobile, and reactive information agents with heterogeneous
communication capabilities, in Java and JPython.</P>
<P>Jacomma provides a development framework and an execution environment,
which sits on top of the Inter-Agent Communication Model
infrastructure. The ICM defines a communication protocol, a store and
forward messaging architecture, and low level communication
infrastructure for message exchange.  Communication is truly
asynchronous, based on TCP sockets.</P>
<P>ICM has an entry in this howto, or you can find it via a link off the
site.</P>

<P>
<A NAME="Jade"></A> </P>
<DT><B>Jade</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://sharon.cselt.it/projects/jade/">http://sharon.cselt.it/projects/jade/</A></LI>
</UL>
</P>
<P>JADE (Java Agent DEvelopment Framework) is a software framework fully
implemented in Java language. It simplifies the implementation of
multi-agent systems through a middle-ware that claims to comply with
the FIPA specifications and through a set of tools that supports the
debugging and deployment phase. The agent platform can be distributed
across machines (which not even need to share the same OS) and the
configuration can be controlled via a remote GUI. The configuration can
be even changed at run-time by moving agents from one machine to
another one, as and when required.</P>

<P>
<A NAME="JAM Agent"></A> </P>
<DT><B>JAM Agent</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.marcush.net/IRS/irs_downloads.html">http://www.marcush.net/IRS/irs_downloads.html</A></LI>
</UL>
</P>
<P>JAM supports both top-down, goal-based reasoning and bottom-up
data-driven reasoning. JAM selects goals and plans based on maximal
priority if metalevel reasoning is not used, or user-developed
metalevel reasoning plans if they exist. JAM's conceptualization of
goals and goal achievement is more classically defined (UMPRS is more
behavioral performance-based than truly goal-based) and makes the
distinction between plans to achieve goals and plans that simply encode
behaviors. Goal-types implemented include achievement (attain a
specified world state), maintenance (re-attain a specified world
state), and performance. Execution of multiple simultaneous goals are
supported, with suspension and resumption capabilities for each goal
(i.e., intention) thread. JAM plans have explicit precondition and
runtime attributes that restrict their applicability, a postcondition
attribute, and a plan attributes section for specifying 
plan/domain-specific plan features. Available plan constructs include:
sequencing, iteration, subgoaling, atomic (i.e., non-interruptable)
plan segments, n-branch deterministic and non-deterministic conditional
execution, parallel execution of multiple plan segments, goal-based or
world state-based synchronization, an explicit failure-handling
section, and Java primitive function definition through building it
into JAM as well as the invocation of predefined (i.e., legacy) class
members via Java's reflection capabilities without having to build it
into JAM.</P>

<P>
<A NAME="JASA"></A> </P>
<DT><B>JASA</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.csc.liv.ac.uk/~sphelps/jasa">http://www.csc.liv.ac.uk/~sphelps/jasa</A></LI>
<LI>Alt Web site: 
<A HREF="http://sourceforge.net/projects/jasa/">http://sourceforge.net/projects/jasa/</A></LI>
</UL>
</P>
<P>JASA is a high performance auction simulator suitable for conducting
experiments in agent-based computational economics.  It implements
various auction mechanisms, trading strategies and experiments
described in the computational economics literature, and as the
software matures we hope that it will become a repository for reference
implementations of commonly used mechanisms, strategies and learning
algorithms.</P>

<P>
<A NAME="Jason"></A> </P>
<DT><B>Jason</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://jason.sourceforge.net/">http://jason.sourceforge.net/</A></LI>
</UL>
</P>
<P>A Java-based interpreter for an extended version of AgentSpeak. Unlike
other BDI (Beliefs-Desires-Intentions) agent tools, Jason implements
the operational semantics of AgentSpeak, a BDI logic programming
language extensively discussed in the literature. It is available as
Open Source under GNU LGPL.</P>

<P>
<A NAME="JATLite"></A> </P>
<DT><B>JATLite</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://java.stanford.edu/">http://java.stanford.edu/</A></LI>
</UL>
</P>
<P>JATLite is providing a set of java packages which makes easy to
build multi-agent systems using Java. JATLite provides only
light-weight, small set of packages so that the developers can
handle all the packages with little efforts. For flexibility
JATLite provides four different layers from abstract to Router
implementation. A user can access any layer we are
providing. Each layer has a different set of assumptions. The
user can choose an appropriate layer according to the
assumptions on the layer and user's application. The
introduction page contains JATLite features and the set of
assumptions for each layer.</P>

<P>
<A NAME="JATLiteBeans"></A> </P>
<DT><B>JATLiteBeans</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://waitaki.otago.ac.nz/JATLiteBean/">http://waitaki.otago.ac.nz/JATLiteBean/</A></LI>
</UL>
</P>
<P>
<UL>
<LI>Improved, easier-to-use interface to JATLite features
including KQML message parsing, receiving, and sending.
            </LI>
<LI>Extensible architecture for message handling and agent
"thread of control" management 
            </LI>
<LI>Useful functions for parsing of simple KQML message content
            </LI>
<LI>JATLiteBean supports automatic advertising of agent
capabilities to facilitator agents 
        </LI>
<LI>Automatic, optional, handling of the "forward" performative
        </LI>
<LI>Generic configuration file parser
        </LI>
<LI>KQML syntax checker
        </LI>
</UL>
</P>

<P>
<A NAME="Java Agent Template"></A> </P>
<DT><B>Java(tm) Agent Template</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www-cdr.stanford.edu/ABE/JavaAgent.html">www-cdr.stanford.edu/ABE/JavaAgent.html</A></LI>
</UL>
</P>
<P>The JAT provides a fully functional template, written entirely in
the Java language, for constructing software agents which communicate
peer-to-peer with a community of other agents distributed over the
Internet. Although portions of the code which define each agent are
portable, JAT agents are not migratory but rather have a static
existence on a single host. This behavior is in contrast to many other
"agent" technologies. (However, using the Java RMI, JAT agents could
dynamically migrate to a foreign host via an agent resident on that
host).  Currently, all agent messages use KQML as a top-level protocol
or message wrapper. The JAT includes functionality for dynamically
exchanging "Resources", which can include Java classes (e.g. new
languages and interpreters, remote services, etc.), data files and
information inlined into the KQML messages.</P>

<P>
<A NAME="lyntin"></A> </P>
<DT><B>lyntin</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://lyntin.sourceforge.net/">lyntin.sourceforge.net/</A></LI>
</UL>
</P>
<P>Lyntin is an extensible Mud client and framework for the creation of
autonomous agents, or bots, as well as mudding in general. Lyntin is
centered around Python, a dynamic, object-oriented, and fun programming
language and based on TinTin++ a lovely mud client.</P>

<P>
<A NAME="Mole"></A> </P>
<DT><B>Mole</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://mole.informatik.uni-stuttgart.de/">mole.informatik.uni-stuttgart.de/</A></LI>
</UL>
</P>
<P>Mole is an agent system supporting mobile agents programmed in
Java.  Mole's agents consist of a cluster of objects, which have
no references to the outside, and as a whole work on tasks given
by the user or another agent. They have the ability to roam a
network of "locations" autonomously. These "locations" are an
abstraction of real, existing nodes in the underlying
network. They can use location-specific resources by
communicating with dedicated agents representing these
services. Agents are able to use services provided by other
agents and to provide services as well.</P>

<P>
<A NAME="Narval"></A> </P>
<DT><B>Narval</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.logilab.org/">www.logilab.org</A></LI>
</UL>
</P>
<P>Narval is the acronym of "Network Assistant Reasoning with a Validating
Agent Language". It is a personal network assistant based on artificial
intelligence and agent technologies. It executes recipes (sequences of
actions) to perform tasks. It is easy to specify a new action using XML
and to implement it using Python.  Recipes can be built and debugged
using a graphical interface.</P>

<P>
<A NAME="NeL"></A> </P>
<DT><B>NeL</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.nevrax.org/">www.nevrax.org</A></LI>
</UL>
</P>
<P>NeL is actually a game development library (for massive multi-player
games), but I'm including it here as it (will) include a fairly
sizable AI library. Here's a blurb from the whitepaper:</P>
<P>The purpose of the AI library is to provide a pragmatic approach to
creating a distributed agents platform. Its focus is agents; individual
entities that communicate regardless of location, using an
action-reaction model.</P>

<P>
<A NAME="OAA"></A> </P>
<DT><B>OAA</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.ai.sri.com/~oaa/">www.ai.sri.com/~oaa/</A></LI>
</UL>
</P>
<P>The Open Agent Architecture is a framework in which a community of
software agents running on distributed machines can work together on
tasks assigned by human or non-human participants in the community.
Distributed cooperation and high-level communication are two ideas
central to the foundation of the OAA.</P>
<P>It defines an interagent communication language and supports multiple
platforms and programming languages.</P>

<P>
<A NAME="OpenCV"></A> </P>
<DT><B>OpenCV</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://opencvlibrary.sourceforge.net/">http://opencvlibrary.sourceforge.net/</A></LI>
</UL>
</P>
<P>OpenCV (Open Source Computer Vision) is a library of programming
functions mainly aimed at real time computer vision.</P>
<P>Example applications of the OpenCV library are Human-Computer
Interaction (HCI); Object Identification, Segmentation and Recognition;
Face Recognition; Gesture Recognition; Motion Tracking, Ego Motion,
Motion Understanding; Structure From Motion (SFM); and Mobile Robotics.</P>

<P>
<A NAME="OpenCog"></A> </P>
<DT><B>OpenCog</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.opencog.org/">http://www.opencog.org/</A></LI>
</UL>
</P>
<P>The Open Cognition Framework (OpenCog) is software for the
collaborative development of safe and beneficial Artificial General
Intelligence.</P>
<P>OpenCog provides research scientists and software developers with a
common platform to build and share artificial intelligence programs.
The framework includes:</P>
<P>
<UL>
<LI>a flexible and highly optimized in-memory database for
knowledge representation,</LI>
<LI>a plug-in architecture for cognitive algorithms and a cognitive
process scheduler,</LI>
<LI>a built-in LISP-like programming language, and</LI>
<LI>other components to support artificial intelligence research
and development. </LI>
</UL>
</P>

<P>
<A NAME="OpenSteer"></A> </P>
<DT><B>OpenSteer</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://opensteer.sourceforge.net/">opensteer.sourceforge.net</A></LI>
</UL>
</P>
<P>OpenSteer is a C++ library to help build steering behaviors for
autonomous characters in games and animation. OpenSteer provides an app
which displays predefined demos of steering behaviors. You can
prototype, visualize and debug your own as a plug-in.</P>

<P>
<A NAME="ORTS"></A> </P>
<DT><B>ORTS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="https://skatgame.net/mburo/orts/">https://skatgame.net/mburo/orts/</A></LI>
</UL>
</P>
<P>ORTS is a programming environment for studying real-time AI problems
such as pathfinding, dealing with imperfect information, scheduling,
and planning in the domain of RTS games. These games are fast-paced and
very popular. Furthermore, the current state of RTS game AI is bleak
which is mainly caused by the lack of planning and learning - areas in
which humans are currently much better than machines. Therefore, RTS
games make an ideal test-bed for real-time AI research. Unfortunately,
commercial RTS games are closed software which prevents researchers
from connecting remote AI modules to them. Furthermore, commercial RTS
games are based on peer-to-peer technology - which in a nutshell runs
the entire simulation on all player machines and just hides part of the
game state from the players. By tampering with the client software it
is possible to reveal the entire game state and thereby gain an unfair
advantage. We feel that this is unacceptable for playing games on the
internet. We therefore started the ORTS project to create a free
software system that lets people and machines play fair RTS games. The
communication protocol is public and all source code and artwork is
freely available. Users can connect whatever client software they like.
This is made possible by a server/client architecture in which only the
currently visible parts of the game state are sent to the players. This
openness leads to new and interesting possibilities ranging from
on-line tournaments of autonomous AI players to gauge their playing
strength to hybrid systems in which human players use sophisticated
GUIs which allow them to delegate tasks to AI helper modules of
increasing performance.</P>

<P>
<A NAME="Penguin!"></A> </P>
<DT><B>Penguin!</B><DD><P>
<UL>
<LI>FTP site: 
<A HREF="http://www.cpan.org/modules/by-category/23_Miscellaneous_Modules/Penguin/FSG/">http://www.cpan.org/modules/by-category/23_Miscellaneous_Modules/Penguin/FSG/</A></LI>
</UL>
</P>
<P>Penguin is a Perl 5 module. It provides you with a set of functions which
allow you to:
<UL>
<LI>send encrypted, digitally signed Perl code to a remote machine
to be executed.</LI>
<LI>receive code and, depending on who signed it, execute it in an
arbitrarily secure, limited compartment.</LI>
</UL>

The combination of these functions enable direct Perl coding of
algorithms to handle safe internet commerce, mobile
information-gathering agents, "live content" web browser helper
apps, distributed load-balanced computation, remote software
update, distance machine administration, content-based
information propagation, Internet-wide shared-data applications,
network application builders, and so on.</P>

<P>
<A NAME="Ps-i"></A> </P>
<DT><B>Ps-i</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://ps-i.sourceforge.net/">ps-i.sourceforge.net</A></LI>
</UL>
</P>
<P>Ps-i is an environment for running agent-based simulations. It is
cross-platform, with binaries available for Win32. Features include: </P>
<P>
<UL>
<LI>declarative language for model specification</LI>
<LI>industry standard Tcl/Tk scripting
with built-in routine optimization, speculative evaluation
and xf86 JIT compiler users can create complex models without
sacrificing perfomance </LI>
<LI>user friendly interface </LI>
<LI>save and restore program runs </LI>
<LI>change model parameters on the fly </LI>
<LI>data visualization: field display with multiple agent shapes and
color, statistics window, agent viewer, routine browser and
highlight agents tool </LI>
</UL>
</P>

<P>
<A NAME="Pyro"></A> </P>
<DT><B>Pyro</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://pyrorobotics.org/">http://pyrorobotics.org/</A></LI>
</UL>
</P>
<P>Pyro is a library, environment, graphical user interface, and low-level
drivers to explore AI and robotics using the Python language. It works
with many real robotics platforms and simulators. Extensive algorithms
including behavior-based, vision (motion tracking, blobs, etc.),
learning (back-propagation, self-organizing maps, etc.), evolutionary,
and more.</P>

<P>
<A NAME="Quackle"></A> </P>
<DT><B>Quackle</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.quackle.org/">http://www.quackle.org/</A></LI>
<LI>Alt Web site: 
<A HREF="http://web.mit.edu/jasonkb/www/quackle/">http://web.mit.edu/jasonkb/www/quackle/</A></LI>
<LI>Alt Web site: 
<A HREF="http://sourceforge.net/projects/quackle">http://sourceforge.net/projects/quackle</A></LI>
</UL>
</P>
<P>Quackle is a world-class crossword game artificial intelligence and
analysis tool. It includes a move generator, simulator, and Qt-based
user interface and can be used with any board layout, alphabet,
lexicon, and tile distribution.</P>

<P>
<A NAME="Recast"></A> </P>
<DT><B>Recast</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://code.google.com/p/recastnavigation/">http://code.google.com/p/recastnavigation/</A></LI>
</UL>
</P>
<P>Recast is state of the art navigation mesh construction toolset for
games.</P>
<P>
<UL>
<LI>It is automatic, which means that you can throw any level
geometry at it and you will get robust mesh out</LI>
<LI>It is fast which means swift turnaround times for level
designers</LI>
<LI>It is open source so it comes with full source and you can
customize it to your hearts content.</LI>
</UL>
</P>
<P>The Library is free for commercial use and open source under the ZLib
License.</P>
<P>Recast is accompanied with Detour, path-finding and spatial reasoning
toolkit. You can use any navigation mesh with Detour, but of course the
data generated with Recast fits perfectly.</P>
<P>Detour offers simple static navigation mesh which is suitable for many
simple cases, as well as tiled navigation mesh which allows you to plug
in and out pieces of the mesh. The tiled mesh allows to create systems
where you stream new navigation data in and out as the player
progresses the level, or you may regenerate tiles as the world changes. </P>

<P>
<A NAME="Remembrance Agents"></A> </P>
<DT><B>Remembrance Agents</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.remem.org/">www.remem.org</A></LI>
</UL>
</P>
<P>Remembrance Agents are a set of applications that watch over a user's
shoulder and suggest information relevant to the current situation.
While query-based memory aids help with direct recall, remembrance
agents are an augmented associative memory.  For example, the
word-processor version of the RA continuously updates a list of
documents relevant to what's being typed or read in an emacs buffer.
These suggested documents can be any text files that might be relevant
to what you are currently writing or reading.  They might be old emails
related to the mail you are currently reading, or abstracts from papers
and newspaper articles that discuss the topic of your writing.</P>

<P>
<A NAME="SimAgent"></A> </P>
<DT><B>SimAgent</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.bham.ac.uk/research/projects/poplog/packages/simagent.html">www.cs.bham.ac.uk/research/projects/poplog/packages/simagent.html</A></LI>
</UL>
</P>
<P>The SimAgent toolkit provides a range of resources for research and
teaching related to the development of interacting agents in
environments of various degrees and kinds of complexity. It can be run
as a pure simulation tool, or installed in a robot with a sufficiently
powerful on-board computer, e.g. running linux. It was originally
developed to support exploratory research on human-like intelligent
agents, but has also been used for student projects developing a
variety of interactive games and simulations.</P>

<P>
<A NAME="spyse"></A> </P>
<DT><B>spyse</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://spyse.sf.net/">spyse.sf.net</A></LI>
<LI>Alt Web site: 
<A HREF="http://zope.org/Members/drapmeyer/spyse">zope.org/Members/drapmeyer/spyse</A></LI>
</UL>
</P>
<P>spyse is a development framework and platform for building multi-agent
systems using the Python programming language. A multi-agent system
(MAS) combines concepts from distributed computing and artificial
intelligence.  Agents are autonomously reasoning software entities that
can collaborate (or compete) in order to achieve a (common) goal. By
cooperating they create emergent behaviour in the system (distributed
artificial intelligence). The architecture of a MAS is specified in the
FIPA standard.</P>
<P>Spyse provides multiple means for reasoning (BDI logics, CLIPS expert
shell, etc.) and communicating locally and remotely.</P>
<P>Each agent has its own thread of control. Agents within and among
instances of the platform communicate by exchanging messages based on
ontologies. Spyse makes use of the Web Ontology Language (OWL) defined
for the Semantic Web.</P>

<P>
<A NAME="TKQML"></A> </P>
<DT><B>TKQML</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.csee.umbc.edu/tkqml/">www.csee.umbc.edu/tkqml/</A> </LI>
</UL>
</P>
<P>TKQML is a KQML application/addition to Tcl/Tk, which allows Tcl
based systems to communicate easily with a powerful agent
communication language.</P>

<P>
<A NAME="Tocoma Project"></A> </P>
<DT><B>The Tocoma Project</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.tacoma.cs.uit.no/">www.tacoma.cs.uit.no/</A></LI>
</UL>
</P>
<P>An agent is a process that may migrate through a computer network
in order to satisfy requests made by clients. Agents are an attractive
way to describe network-wide computations.</P>
<P>The TACOMA project focuses on operating system support for agents and
how agents can be used to solve problems traditionally addressed by
operating systems. We have implemented a series of prototype systems
to support agents.</P>
<P>TACOMA Version 1.2 is based on UNIX and TCP. The system supports
agents written in C, Tcl/Tk, Perl, Python, and Scheme (Elk). It is
implemented in C. This TACOMA version has been in public domain since
April 1996.</P>
<P>We are currently focusing on heterogeneity, fault-tolerance, security
and management issues. Also, several TACOMA applications are under
construction. We implemented StormCast 4.0, a wide-area network
weather monitoring system accessible over the internet, using TACOMA
and Java. We are now in the process of evaluating this application,
and plan to build a new StormCast version to be completed by June
1997.</P>

<P>
<A NAME="UMPRS Agent"></A> </P>
<DT><B>UMPRS Agent</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.marcush.net/IRS/">http://www.marcush.net/IRS/</A></LI>
</UL>
</P>
<P>UMPRS supports top-down, goal-based reasoning and selects goals and
plans based on maximal priority. Execution of multiple simultaneous
goals are supported, with suspension and resumption capabilities for
each goal (i.e., intention) thread. UMPRS plans have an integrated
precondition/runtime attribute that constrain their applicability.
Available plan constructs include: sequencing, iteration, subgoaling,
atomic (i.e., non-interruptable) blocks, n-branch deterministic
conditional execution, explicit failure-handling section, and C++
primitive function definition.</P>

<P>
<A NAME="WebMate"></A> </P>
<DT><B>WebMate</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.cs.cmu.edu/~softagents/webmate/">http://www.cs.cmu.edu/~softagents/webmate/</A></LI>
</UL>
</P>

<P>WebMate is a personal agent for World-Wide Web browsing and
searching. It accompanies you when you travel on the internet
and provides you what you want. </P>
<P>Features include:
<UL>
<LI>Searching enhancement, including parallel search, searching
keywords refinement using our relevant keywords extraction technology,
relevant feedback, etc.
</LI>
<LI>Browsing assistant, including learning your current interesting,
recommending you new URLs according to your profile and selected
resources, monitoring bookmarks of Netscape or IE, sending the current
browsing page to your friends, etc.
</LI>
<LI>Offline browsing, including downloading the following pages from
the current page for offline browsing.
</LI>
<LI>Filtering HTTP header, including recording http header and all
the transactions between your browser and WWW servers, etc.
</LI>
<LI>Checking the HTML page to find the errors or dead links,  etc.
</LI>
<LI>Programming in Java, independent of operating system, runing in
multi-thread.
</LI>
</UL>
</P>

</DL>
</P>

<H2><A NAME="Robotics and Simulators"></A> <A NAME="ss6.2">6.2</A> <A HREF="AI-Alife-HOWTO.html#toc6.2">Robotics and Simulators</A>
        </H2>


<P>From fun battling robot games to full robot control systems. The idea is
physical agents in the real world, or at least their control programming.</P>
<P>
<DL>
<P>
<A NAME="BattleBots"></A> </P>
<DT><B>BattleBots</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.bluefire.nu/battlebots/">www.bluefire.nu/battlebots/</A></LI>
</UL>
</P>
<P>AI programming game where you design the bot by selecting hardware and
programming its CPU, then competing with other bots. Competitions can
have teams and special rules for a game. </P>
<P>The hardware for use in your bot includes weapons, engine, scanners,
CPU, etc. The programming lauguage is dependent on the CPU type and is
similar to an assembly language. </P>

<P>
<A NAME="Cadaver"></A> </P>
<DT><B>Cadaver</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.erikyyy.de/cadaver/">www.erikyyy.de/cadaver/</A></LI>
</UL>
</P>
<P>Cadaver is a simulated world of cyborgs and nature in realtime.  The
battlefield consists of forests, grain, water, grass, carcass (of
course) and lots of other things. The game server manages the game and
the rules.  You start a server and connect some clients.  The clients
communicate with the server using a very primitive protocol.  They can
order cyborgs to harvest grain, attack enemies or cut forest.  The game
is not intended to be played by humans!  There is too much to control.
Only for die-hards: Just telnet to the server and you can enter
commands by hand.  Instead the idea is that you write artificial  
intelligence clients to beat the other artificial intelligences.  You
can choose a language (and operating system) of your choice to do that
task.  It is enough to write a program that communicates on standard
input and standard output channels.  Then you can use programs like
"socket" to connect your clients to the server.  It is NOT needed to
write TCP/IP code, although i did so :) The battle shall not be boring,
and so there is the so called spyboss client that displays the action
graphically on screen.</P>

<P>
<A NAME="Carmen"></A> </P>
<DT><B>Carmen</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://carmen.sourceforge.net/">http://carmen.sourceforge.net/</A></LI>
</UL>
</P>
<P>CARMEN, the Carnegie Mellon Robot Navigation Toolkit. CARMEN is an
open-source collection of software for mobile robot control. CARMEN is
modular software designed to provide basic navigation primatives
including: base and sensor control, logging, obstacle avoidance,
localization, path planning, and mapping. </P>

<P>
<A NAME="CLARAty"></A> </P>
<DT><B>CLARAty</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://claraty.jpl.nasa.gov/man/overview/">http://claraty.jpl.nasa.gov/man/overview/</A></LI>
</UL>
</P>
<P>CLARAty is an integrated framework for reusable robotic software. It
defines interfaces for common robotic functionality and integrates
multiple implementations of any given functionality. Examples of such
capabilities include pose estimation, navigation, locomotion and
planning. In addition to supporting multiple algorithms, it provides
adaptations to multiple robotic platforms.</P>
<P>This is a public release of the some of the code used in the Mars rover
projects at NASA. It is under a free for non-commercial use licence and
consists of large number of modules and algorithms along with extensive
documentation.</P>

<P>
<A NAME="GNU Robots"></A> </P>
<DT><B>GNU Robots</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.gnu.org/software/robots/">http://www.gnu.org/software/robots/</A></LI>
</UL>
</P>
<P>GNU Robots is a game/diversion where you construct a program for a
little robot, then watch him explore a world. The world is
filled with baddies that can hurt you, objects that you can bump into,
and food that you can eat. The goal of the game is to collect as
many prizes as possible before are killed by a baddie or you run out of
energy. Robots can be written in Guile scheme or using a GUI.</P>

<P>
<A NAME="Infon Battle Arena"></A> </P>
<DT><B>Infon Battle Arena</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://infon.dividuum.de/">http://infon.dividuum.de/</A></LI>
<LI>Web site: 
<A HREF="https://github.com/dividuum/infon">https://github.com/dividuum/infon</A></LI>
</UL>
</P>
<P>Infon Battle Arena is a networked multiplayer real-time programming
game featuring little creatures fighting for food. You upload your
Creature Code (written in Lua) to a game server using a telnet
Interface. The game server then runs your code. The graphical client
can be used to watch running games or replay recorded games.</P>

<P>
<A NAME="Khepera Sim"></A> </P>
<DT><B>Khepera Simulator</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://diwww.epfl.ch/w3lami/team/michel/khep-sim/">http://diwww.epfl.ch/w3lami/team/michel/khep-sim/</A></LI>
</UL>
</P>
<P>Khepera Simulator is a public domain software package written by
<A HREF="http://diwww.epfl.ch/w3lami/team/michel/">Olivier         MICHEL</A> during the preparation of his Ph.D. thesis, at the Laboratoire
I3S, URA 1376 of CNRS and University of Nice-Sophia Antipolis, France.
It allows to write your own controller for the mobile robot Khepera
using C or C++ languages, to test them in a simulated environment and
features a nice colorful X11 graphical interface. Moreover, if you own
a Khepera robot, it can drive the real robot using the same control
algorithm. It is mainly oriented toward to researchers studying
autonomous agents.</P>

<P>
<A NAME="MRPT"></A> </P>
<DT><B>MRPT</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://babel.isa.uma.es/mrpt/index.php/Main_Page">http://babel.isa.uma.es/mrpt/index.php/Main_Page</A></LI>
</UL>
</P>
<P>The Mobile Robot Programming Toolkit (MRPT) is an extensive,
cross-platform, and open source C++ library aimed to help robotics
researchers to design and implement algorithms in the fields of
Simultaneous Localization and Mapping (SLAM), computer vision, and
motion planning (obstacle avoidance).</P>

<P>
<A NAME="Nero"></A> </P>
<DT><B>Nero</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.nerogame.org/">http://www.nerogame.org/</A></LI>
</UL>
</P>
<P>Neuro-Evolving Robotic Operatives, or NERO for short, is a unique
computer game that lets you play with adapting intelligent agents
hands-on. Evolve your own robot army by tuning their artificial brains
for challenging tasks, then pit them against your friends' teams in
online competitions!</P>
<P>The goals of the project are (1) to demonstrate the power of
state-of-the-art machine learning technology, (2) to create an engaging
game based on it, and (3) to provide a robust and challenging
development and benchmarking domain for AI researchers.</P>
<P>Closed source but free to download. They are working on OpenNERO which
will be open source and more intended as a research platform.</P>

<P>
<A NAME="Orca"></A> </P>
<DT><B>Orca</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://orca-robotics.sourceforge.net/">http://orca-robotics.sourceforge.net/</A></LI>
<LI>Web site: 
<A HREF="https://github.com/naderman/orca-robotics">https://github.com/naderman/orca-robotics</A></LI>
</UL>
</P>
<P>Orca is an open-source framework for developing component-based robotic
systems. It provides the means for defining and developing the
building-blocks which can be pieced together to form arbitrarily
complex robotic systems, from single vehicles to distributed sensor
networks.</P>

<P>
<A NAME="Player"></A> </P>
<DT><B>Player</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://playerstage.sourceforge.net/">http://playerstage.sourceforge.net/</A></LI>
<LI>Player wiki: 
<A HREF="http://playerstage.sourceforge.net/wiki/Player">http://playerstage.sourceforge.net/wiki/Player</A></LI>
</UL>
</P>
<P>Player is a device server that provides a powerful, flexible interface
to a variety of sensors and actuators (e.g., robots). Because Player
uses a TCP socket-based client/server model, robot control programs can
be written in any programming language and can execute on any computer
with network connectivity to the robot. In addition, Player supports
multiple concurrent client connections to devices, creating new
possibilities for distributed and collaborative sensing and control.</P>

<P>
<A NAME="RealTimeBattle"></A> </P>
<DT><B>RealTimeBattle</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://realtimebattle.sourceforge.net/">http://realtimebattle.sourceforge.net/</A></LI>
</UL>
</P>
<P>RealTimeBattle is a programming game, in which robots controlled by
programs are fighting each other. The goal is to destroy the enemies,
using the radar to examine the environment and the cannon to shoot.</P>
<P>
<UL>
<LI>Game progresses in real time, with the robot programs
running as child processes to RealTimeBattle.</LI>
<LI>The robots communicate with the main program using the
standard input and output.</LI>
<LI>Robots can be constructed in almost any programming language.</LI>
<LI>Maximum number of robots can compete simultaneously.</LI>
<LI>A simple messaging language is used for communication, which
makes it easy to start constructing robots.</LI>
<LI>Robots behave like real physical object.</LI>
<LI>You can create your own arenas.</LI>
<LI>Highly configurable.</LI>
</UL>
</P>

<P>
<A NAME="Robocode"></A> </P>
<DT><B>Robocode</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://robocode.sourceforge.net/">http://robocode.sourceforge.net/</A></LI>
</UL>
</P>
<P>A java based robot combat programming game. It provides a simple API
and class framework. It is designed as a means of learning Java and is
easy to start using while not constraining the programmer from more
advanced techniques. It has a built in security manager for running
other peoples robots in a safe way.</P>

<P>
<A NAME="Robodeb"></A> </P>
<DT><B>Robodeb</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.transterpreter.org/robodeb/">http://www.transterpreter.org/robodeb/</A></LI>
</UL>
</P>
<P>Robodeb is a complete robotics simulation environment for teaching
concurrency and parallelism. It provides a unique environment for
exploring concurrency and robotics. It provides a complete IDE for the
occam-pi programming language, and leverages the Transterpreter, our
portable and flexible runtime for the language. This combination is
critical, as it provides a principled interface to the Player/Stage
API, a set of widely used libraries for controlling the Pioneer3
robotics platform.</P>

<P>
<A NAME="RobotFlow"></A> </P>
<DT><B>RobotFlow</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://robotflow.sourceforge.net/">http://robotflow.sourceforge.net/</A></LI>
</UL>
</P>
<P>RobotFlow is a mobile robotics tookit based on the
<A HREF="http://flowdesigner.sourceforge.net">FlowDesigner</A>
project. FlowDesigner is a data-flow oriented architecture, similar to
Simulink (Matlab) or Labview that is free (LGPL) and versatile. The
visual programming interface provided in the FlowDesigner project will
help people to better visualize &amp; understand what is really happening
in the robot's control loops, sensors, actuators, by using graphical
probes and debugging in real-time.</P>

<P>
<A NAME="RoboTournament"></A> </P>
<DT><B>RoboTournament</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://robotournament.sourceforge.net/">http://robotournament.sourceforge.net/</A></LI>
</UL>
</P>
<P>RoboTournament is a RoboRally inspired game where players program their
robots to vanquish their opponents. RoboTournament features: Multiple
Game Types: Death Match, Rally, and Capture The Flag. Multi-Player
through TCP/IP, Six weapons including BFG, Map Editor, and a wide
variety of board elements.</P>

<P>
<A NAME="ROS"></A> </P>
<DT><B>ROS</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.ros.org/wiki/">http://www.ros.org/wiki/</A></LI>
</UL>
</P>
<P>ROS is an operating system for your robot. It provides the services you
would expect from an operating system, including hardware abstraction,
low-level device control, implementation of commonly-used
functionality, message-passing between processes, and package
management. It also provides tools and libraries for obtaining,
building, writing, and running code across multiple computers.</P>

<P>
<A NAME="Simbad"></A> </P>
<DT><B>Simbad</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://simbad.sourceforge.net/">http://simbad.sourceforge.net/</A></LI>
</UL>
</P>
<P>Simbad is a Java 3d robot simulator for scientific and educationnal
purposes.  It is mainly dedicated to researchers/programmers who want
a simple basis for studying Situated Artificial Intelligence, Machine
Learning, and more generally AI algorithms, in the context of
Autonomous Robotics  and  Autonomous Agents. It is not intented to
provide a real world simulation and is kept voluntarily readable and
simple.</P>
<P>Simbad enables programmers to write their own robot controller, modify
the environment and use the available sensors. Don't think of it as a
finite product but merely as an opened framework to test your own
ideas.</P>

<P>
<A NAME="SimRobot"></A> </P>
<DT><B>SimRobot</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.informatik.uni-bremen.de/simrobot/">http://www.informatik.uni-bremen.de/simrobot/</A></LI>
<LI>FTP site: 
<A HREF="ftp://ftp.uni-bremen.de/pub/ZKW/INFORM/simrobot/">ftp://ftp.uni-bremen.de/pub/ZKW/INFORM/simrobot/</A></LI>
</UL>
</P>
<P>SimRobot is a program for simulation of sensor based robots in a
3D environment. It is written in C++, runs under UNIX and X11 and
needs the graphics toolkit XView.
<UL>
<LI>Simulation of robot kinematics</LI>
<LI>Hierarchically built scene definition via a simple definition
language</LI>
<LI>Various sensors built in: camera, facette eye, distance
measurement, light sensor, etc.</LI>
<LI>Objects defined as polyeders</LI>
<LI>Emitter abstractly defined; can be interpreted e.g. as
light or sound</LI>
<LI>Camera images computed according to the raytracing or
Z-buffer algorithms known from computer graphics</LI>
<LI>Specific sensor/motor software interface for communicating
with the simulation</LI>
<LI>Texture mapping onto the object surfaces: bitmaps in various
formats</LI>
<LI>Comprehensive visualization of the scene: wire frame w/o
hidden lines, sensor and actor values</LI>
<LI>Interactive as well as batch driven control of the agents
and operation in the environment</LI>
<LI>Collision detection</LI>
<LI>Extendability with user defined object types</LI>
<LI>Possible socket communication to e.g. the Khoros image
processing software</LI>
</UL>
</P>

<P>
<A NAME="TclRobots"></A> </P>
<DT><B>TclRobots</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.nyx.net/~tpoindex/">http://www.nyx.net/~tpoindex/</A></LI>
</UL>
</P>
<P>TclRobots is a programming game, similar to 'Core War'.  To play
TclRobots, you must write a Tcl program that controls a robot.  The
robot's mission is to survive a battle with other robots.  Two, three,
or four robots compete during a battle, each running different
programs (or possibly the same program in different robots.)  Each
robot is equipped with a scanner, cannon, drive mechanism.  A single
match continues until one robot is left running.  Robots may compete
individually, or combine in a team oriented battle.  A tournament
can be run with any number of robot programs, each robot playing every
other in a round-robin fashion, one-on-one.  A battle simulator is
available to help debug robot programs.</P>
<P>The TclRobots program provides a physical environment, imposing
certain game parameters to which all robots must adhere.  TclRobots
also provides a view on a battle, and a controlling user interface.
TclRobots requirements: a wish interpreter built from Tcl 7.4 and Tk
4.0.</P>

<P>
<A NAME="URBI"></A> </P>
<DT><B>URBI</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.urbiforge.org/">http://www.urbiforge.org/</A></LI>
</UL>
</P>
<P>URBI is a Universal Real-time Behavior Interface and gives you a simple
but powerful way to control any robot or complex system like a video
game, using a convenient and easy to use scripting language that can be
interfaced with several popular programming languages (C++, Java,
Matlab,...) and OS (Windows, Mac OSX, Linux). URBI is based on a
client/server architecture, which give a great deal of flexibility.
URBI includes powerful features compared to existing scripting
solutions: parallel execution of commands, event programming, command
tagging, dynamic variables,... Currently, URBI is used as well by
academic research labs, the industry and by hobbyists.</P>

<P>
<A NAME="VWORLD"></A> </P>
<DT><B>VWORLD</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://zhar.net/projects/vworld/">http://zhar.net/projects/vworld/</A></LI>
</UL>
</P>
<P>Vworld is a simulated environment for research with autonomous
agents written in prolog. It is currently in something of an
beta stage. It works well with SWI-prolog, but should work with
Quitnus-prolog with only a few changes.  It is being designed to
serve as an educational tool for class projects dealing with
prolog and autonomous agents. It comes with three demo worlds or
environments, along with sample agents for them. There are
two versions now. One written for SWI-prolog and one written for
LPA-prolog. Documentation is roughly done (with a
student/professor framework in mind).</P>


<P>
<A NAME="Yampa"></A> </P>
<DT><B>Yampa</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://www.haskell.org/yampa/">http://www.haskell.org/yampa/</A></LI>
</UL>
</P>
<P>FRP system with robotics library and graphical interactive robotics
simulator.</P>
<P>Functional reactive programming, or FRP, is a paradigm for programming
hybrid systems  i.e., systems containing a combination of both
continuous and discrete components  in a high-level, declarative way.
The key ideas in FRP are its notions of continuous, time-varying
values, and time-ordered sequences of discrete events. Yampa is an
instantiation of FRP as a domain-specific language embedded in Haskell.</P>

<P>
<A NAME="YARP"></A> </P>
<DT><B>YARP</B><DD><P>
<UL>
<LI>Web site: 
<A HREF="http://eris.liralab.it/yarp/">http://eris.liralab.it/yarp/</A></LI>
</UL>
</P>
<P>YARP is plumbing for robot software.  It is a set of libraries,
protocols, and tools to keep modules and devices cleanly decoupled. It
is reluctant middleware, with no desire or expectation to be in control
of your system.</P>
<P>More specifically, YARP supports building a robot control system as a
collection of programs communicating in a peer-to-peer way, with a
family of connection types that meet the diverse, sometimes
contradictory, and always changing needs of advanced robotics. We also
encourage compilation and use of hardware devices in a future-proof
way. Our strategic goal is to increase the longevity of robot software
projects.</P>



</DL>
</P>

<HR>
<A HREF="AI-Alife-HOWTO-7.html">Next</A>
<A HREF="AI-Alife-HOWTO-5.html">Previous</A>
<A HREF="AI-Alife-HOWTO.html#toc6">Contents</A>
</BODY>
</HTML>
