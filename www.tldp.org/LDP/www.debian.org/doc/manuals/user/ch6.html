<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">

<html>

<head>

<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">

<title>Debian User Reference Manual (Obsolete Documentation) - Basic Commands and Tools</title>

<link href="index.html" rel="start">
<link href="ch-shells.html" rel="prev">
<link href="ch7.html" rel="next">
<link href="index.html#contents" rel="contents">
<link href="index.html#copyright" rel="copyright">
<link href="ch1.html" rel="chapter" title="1 Introduction">
<link href="ch-logging-in.html" rel="chapter" title="2 Overview of a Debian GNU/Linux System">
<link href="ch-manpages.html" rel="chapter" title="3 Documentation">
<link href="ch-files.html" rel="chapter" title="4 Files and File Systems">
<link href="ch-shells.html" rel="chapter" title="5 Shells">
<link href="ch6.html" rel="chapter" title="6 Basic Commands and Tools">
<link href="ch7.html" rel="chapter" title="7 Advanced Commands and Tools">
<link href="ch-editors.html" rel="chapter" title="8 Text Editing">
<link href="ch9.html" rel="chapter" title="9 Text Processing">
<link href="ch10.html" rel="chapter" title="10 Programming">
<link href="ch11.html" rel="chapter" title="11 Science">
<link href="ch12.html" rel="chapter" title="12 Games">
<link href="ch13.html" rel="chapter" title="13 Sound">
<link href="ch14.html" rel="chapter" title="14 Image Manipulation">
<link href="ch15.html" rel="chapter" title="15 Networking">
<link href="ch16.html" rel="chapter" title="16 Databases">
<link href="ch-xwin.html" rel="chapter" title="17 X Windows">
<link href="ch18.html" rel="chapter" title="18 X Windows Managers">
<link href="ch19.html" rel="chapter" title="19 X Windows Applications">
<link href="ch20.html" rel="chapter" title="20 Index">
<link href="ch-files.html#s-files-basics" rel="section" title="4.1 Basic Concepts">
<link href="ch-files.html#s-files-commands" rel="section" title="4.2 Basic file commands - a tutorial">
<link href="ch-files.html#s-files-structure" rel="section" title="4.3 What files are on my Debian system? Where should I put my own files?">
<link href="ch-files.html#s-files-permissions" rel="section" title="4.4 File ownership and permissions">
<link href="ch-files.html#s-files-filesystems" rel="section" title="4.5 Filesystems">
<link href="ch-files.html#s-files-devices" rel="section" title="4.6 How to access particular devices (including hard disk partitions and floppy drives)">
<link href="ch-files.html#s-files-misc" rel="section" title="4.7 Miscellaneous topics">
<link href="ch-files.html#s-files-advanced" rel="section" title="4.8 Advanced Topics">
<link href="ch6.html#s6.1" rel="section" title="6.1 What this chapter covers">
<link href="ch6.html#s6.2" rel="section" title="6.2 Running commands">
<link href="ch6.html#s-regexp" rel="section" title="6.3 Regular expressions">
<link href="ch9.html#s9.1" rel="section" title="9.1 What this chapter covers">
<link href="ch9.html#s9.2" rel="section" title="9.2 Text processing">
<link href="ch9.html#s9.3" rel="section" title="9.3 LaTeX">
<link href="ch10.html#s10.1" rel="section" title="10.1 What this chapter covers">
<link href="ch11.html#s11.1" rel="section" title="11.1 What this chapter covers">
<link href="ch11.html#s11.2" rel="section" title="11.2 Plotting">
<link href="ch11.html#s11.3" rel="section" title="11.3 Combining diagrams">
<link href="ch16.html#s16.1" rel="section" title="16.1 What this chapter covers">
<link href="ch-files.html#s-files-permissions-groups" rel="subsection" title="4.4.1 Groups">
<link href="ch-files.html#s-files-permissions-mode" rel="subsection" title="4.4.2 Mode">
<link href="ch-files.html#s-files-permissions-tutorial" rel="subsection" title="4.4.3 Permissions in practice">
<link href="ch-files.html#s-files-devices-mounting" rel="subsection" title="4.6.1 Mounting a filesystem">
<link href="ch-files.html#s-files-devices-cdromexample" rel="subsection" title="4.6.2 Example: Mounting a CD-ROM">
<link href="ch-files.html#s-files-devices-fstab" rel="subsection" title="4.6.3 <samp>/etc/fstab</samp>: Automating the mount process">
<link href="ch-files.html#s-files-devices-removable" rel="subsection" title="4.6.4 Removable disks (floppies, Zip disks, etc.)">
<link href="ch-files.html#s-files-devices-preparing" rel="subsection" title="4.6.5 Preparing disks for use: formatting and creating a filesystem">
<link href="ch-files.html#s-files-misc-viewing" rel="subsection" title="4.7.1 Viewing the contents of files">
<link href="ch-files.html#s-files-misc-dotfiles" rel="subsection" title="4.7.2 Hidden files beginning with <samp>.</samp>">
<link href="ch-files.html#s-files-misc-find" rel="subsection" title="4.7.3 Finding a file on the system">
<link href="ch-files.html#s-files-misc-compression" rel="subsection" title="4.7.4 Compressing files with <samp>gzip</samp>">
<link href="ch-files.html#s-files-misc-split" rel="subsection" title="4.7.5 Splitting files into smaller parts">
<link href="ch-files.html#s-files-misc-diskspace" rel="subsection" title="4.7.6 Managing disk space">
<link href="ch-files.html#s-files-misc-tar" rel="subsection" title="4.7.7 Backups and large-scale file copying">
<link href="ch-files.html#s-files-misc-guessing" rel="subsection" title="4.7.8 Guessing a file's contents">
<link href="ch-files.html#s-files-misc-umask" rel="subsection" title="4.7.9 Defining default permissions with <samp>umask</samp>">
<link href="ch-files.html#s-files-advanced-hardlinks" rel="subsection" title="4.8.1 The real nature of files: hard links and inodes">
<link href="ch-files.html#s-files-advanced-types" rel="subsection" title="4.8.2 Types of files">
<link href="ch-files.html#s-files-advanced-types-symlinks" rel="subsection" title="4.8.2.1 Symbolic links">
<link href="ch-files.html#s-files-misc-types-devices" rel="subsection" title="4.8.2.2 Device files">
<link href="ch-files.html#s-files-advanced-types-devices-creating" rel="subsection" title="4.8.2.2.1 How to create device files.">
<link href="ch-files.html#s-files-advanced-types-devices-null" rel="subsection" title="4.8.2.2.2 <samp>/dev/null</samp>">
<link href="ch-files.html#s-files-advanced-types-pipes" rel="subsection" title="4.8.2.3 Named pipes (FIFOs)">
<link href="ch-files.html#s-files-advanced-types-sockets" rel="subsection" title="4.8.2.4 Sockets">
<link href="ch-files.html#s-files-advanced-proc" rel="subsection" title="4.8.3 The <samp>proc</samp> filesystem">
<link href="ch-files.html#s-files-advanced-permissions" rel="subsection" title="4.8.4 Advanced aspects of file permissions">
<link href="ch-files.html#s-files-advanced-permissions-absolute" rel="subsection" title="4.8.4.1 Using numeric arguments with <samp>chmod</samp>">
<link href="ch-files.html#s-files-advanced-permissions-suid" rel="subsection" title="4.8.4.2 Making files suid/sgid">
<link href="ch-files.html#s-files-advanced-permissions-sticky" rel="subsection" title="4.8.4.3 Setting the sticky bit">
<link href="ch-files.html#s-files-advanced-undocumented" rel="subsection" title="4.8.5 Other concepts not yet covered, but should be">
<link href="ch6.html#s6.2.1" rel="subsection" title="6.2.1 How to enter commands">
<link href="ch6.html#s6.2.2" rel="subsection" title="6.2.2 How Linux finds commands">
<link href="ch6.html#s6.2.3" rel="subsection" title="6.2.3 Command options">
<link href="ch6.html#s6.2.4" rel="subsection" title="6.2.4 Essential commands">
<link href="ch6.html#s6.2.4.1" rel="subsection" title="6.2.4.1 Commands for reading documentation">
<link href="ch6.html#s6.2.4.2" rel="subsection" title="6.2.4.2 Commands for basic file-handling">
<link href="ch6.html#s6.2.4.3" rel="subsection" title="6.2.4.3 These commands are used for managing file-systems">
<link href="ch6.html#s6.2.4.4" rel="subsection" title="6.2.4.4 Looking at files">
<link href="ch6.html#s-rmacs" rel="subsection" title="6.2.4.5 Managing your screen">
<link href="ch6.html#s6.2.4.6" rel="subsection" title="6.2.4.6 Compressed files">
<link href="ch6.html#s6.2.4.7" rel="subsection" title="6.2.4.7 Commands for backup">
<link href="ch6.html#s6.2.4.8" rel="subsection" title="6.2.4.8 Printing files">
<link href="ch6.html#s6.2.4.9" rel="subsection" title="6.2.4.9 Changing files">
<link href="ch6.html#s6.2.4.10" rel="subsection" title="6.2.4.10 Session management">
<link href="ch6.html#s6.2.4.11" rel="subsection" title="6.2.4.11 Identity">
<link href="ch6.html#s6.2.4.12" rel="subsection" title="6.2.4.12 Turning off the computer">
<link href="ch6.html#s6.2.5" rel="subsection" title="6.2.5 Special characters in commands">
<link href="ch6.html#s6.2.6" rel="subsection" title="6.2.6 Filters">
<link href="ch6.html#s6.2.7" rel="subsection" title="6.2.7 Standard input, standard output and standard error">
<link href="ch6.html#s6.2.8" rel="subsection" title="6.2.8 Redirection">
<link href="ch6.html#s6.2.9" rel="subsection" title="6.2.9 Shell programs">
<link href="ch6.html#s6.2.10" rel="subsection" title="6.2.10 Errors">
<link href="ch9.html#s9.3.1" rel="subsection" title="9.3.1 Invoking LaTeX">
<link href="ch9.html#s9.3.2" rel="subsection" title="9.3.2 Printing dvi-files">
<link href="ch9.html#s9.3.3" rel="subsection" title="9.3.3 Documentation on LaTeX">

</head>

<body>

<p><a name="ch6"></a></p>
<hr>

<p>
[ <a href="ch-shells.html">previous</a> ]
[ <a href="index.html#contents">Contents</a> ]
[ <a href="ch1.html">1</a> ]
[ <a href="ch-logging-in.html">2</a> ]
[ <a href="ch-manpages.html">3</a> ]
[ <a href="ch-files.html">4</a> ]
[ <a href="ch-shells.html">5</a> ]
[ 6 ]
[ <a href="ch7.html">7</a> ]
[ <a href="ch-editors.html">8</a> ]
[ <a href="ch9.html">9</a> ]
[ <a href="ch10.html">10</a> ]
[ <a href="ch11.html">11</a> ]
[ <a href="ch12.html">12</a> ]
[ <a href="ch13.html">13</a> ]
[ <a href="ch14.html">14</a> ]
[ <a href="ch15.html">15</a> ]
[ <a href="ch16.html">16</a> ]
[ <a href="ch-xwin.html">17</a> ]
[ <a href="ch18.html">18</a> ]
[ <a href="ch19.html">19</a> ]
[ <a href="ch20.html">20</a> ]
[ <a href="ch7.html">next</a> ]
</p>

<hr>

<h1>
Debian User Reference Manual (Obsolete Documentation)
<br>Chapter 6 - Basic Commands and Tools
</h1>

<hr>

<p>
author = Oliver Elphick <code><a
href="mailto:olly@lfix.co.uk">olly@lfix.co.uk</a></code>
</p>

<p>
topics = head, tail, grep, etc.
</p>

<p>
Latest update to this chapter: 14th December 1997
</p>

<hr>

<h2><a name="s6.1"></a>6.1 What this chapter covers</h2>

<p>
This chapter tells you how to run the basic commands that you need in order to
use Debian Linux.
</p>

<p>
We assume that you have already logged in and are in a shell where you can
enter commands.  Refer back to <a href="ch-logging-in.html">Overview of a
Debian GNU/Linux System, Chapter 2</a> for instructions on how to log in.  If
you are not running X-Windows, you will normally be put in an interactive shell
as soon as you log in.  If you are running X-Windows, you should refer to <a
href="ch-xwin.html">X Windows, Chapter 17</a> for instructions on how to start
up a window with a shell.
</p>

<p>
The available shells are described in <a href="ch-shells.html">Shells, Chapter
5</a>.  All the examples given here assume that you are using the Bourne-Again
Shell, <code>/bin/bash</code>, though in most cases there will be no difference
between the command syntax for any shell.  Bash is the default shell when
Debian Linux is first installed.
</p>

<hr>

<h2><a name="s6.2"></a>6.2 Running commands</h2>

<hr>

<h3><a name="s6.2.1"></a>6.2.1 How to enter commands</h3>

<p>
To run a command, type the command at the prompt, followed by any necessary
options, and then press the <samp>Enter</samp> key.  The shell will interpret
the command, first handling any special shell syntax, and will then start the
command as a new process.
</p>

<p>
Most commands operate silently unless they are specifically asked to say what
they are doing.  If there is no error message, the command should have worked.
</p>

<hr>

<h3><a name="s6.2.2"></a>6.2.2 How Linux finds commands</h3>

<p>
When you type in a command name, Linux has to find the file which contains the
program you want to run.  This is how it does it:
</p>

<p>
The first word of what you type in is the command[<a href="footnotes.html#f3"
name="fr3">3</a>] itself.  If this contains a slash character (<samp>/</samp>)
the whole command is taken to be a path, either absolute (if it starts with /)
or relative to the current directory.  The file indicated by that path is used,
provided that it exists, that it is executable and (in the case of a script)
that it is readable.
</p>

<p>
If the command does not contain a slash, the shell searches for it in your
current search path.  This is a list of directories, separated one from another
by colons.  The command search path is held in the environment variable PATH:
type <samp>echo $PATH</samp> to see what it is.  For example,
</p>

<pre>
     
     $ echo $PATH
     /usr/bin:/bin:/usr/bin/X11:/usr/local/bin:/usr/games:/home/olly/bin
</pre>

<p>
Each directory is searched in turn, starting at the beginning of the list.  If
a match for the name is found, the shell also considers whether the file found
is executable (and readable, if it is a script).  As soon as such a match is
found, the search stops[<a href="footnotes.html#f4" name="fr4">4</a>].  This is
why new programmers often have trouble getting their first program to run.
They frequently call it <code>test</code> and run it without a path; the shell
finds the system program <code>test</code> first and runs that instead.
</p>

<p>
If you need to change your path, you should add the new directories to the end
of the list; the current directory (.), if it is included at all, should go
last of all[<a href="footnotes.html#f5" name="fr5">5</a>].  The command to use
is <samp>export PATH=$PATH:<var>new_directory</var></samp>[<a
href="footnotes.html#f6" name="fr6">6</a>] .
</p>

<hr>

<h3><a name="s6.2.3"></a>6.2.3 Command options</h3>

<p>
The operation of most commands can be changed by putting command options
immediately after the command name.  There are several styles of options used,
and you have to check the documentation for each command to know what options
it can take, and what they do.
</p>

<p>
The most common form of option is a letter preceded by a hyphen, thus:
</p>

<pre>
     ls -l
</pre>

<p>
With this option style, several single-character options can be combined into
one, thus:
</p>

<pre>
     ls -ali
</pre>

<p>
which is equivalent to
</p>

<pre>
     ls -a -l -i
</pre>

<p>
Sometimes, single-letter options like this need an extra argument:
</p>

<pre>
     awk -F: -f /tmp/bar /tmp/foo
</pre>

<p>
Here <samp>:</samp> and <samp>/tmp/bar</samp> are arguments to the options
<samp>-F</samp> and <samp>-f</samp> respectively.
</p>

<p>
A few commands have options which need not be preceded by a hyphen.  The one
you are most likely to use is <code>tar</code>.
</p>

<pre>
     tar cvmf /dev/st0 /usr
</pre>

<p>
is the same as
</p>

<pre>
     tar -cvmf /dev/st0 /usr
</pre>

<p>
A third option style, commonly used by GNU programs, is whole words or phrases
introduced by <samp>--</samp>.  Many commands can use both the single-letter
and whole-word options:
</p>

<pre>
     tar --create --verbose --modification-time --file /dev/st0 /usr
</pre>

<p>
Finally, commands may define completely different option patterns for
themselves, such as options preceded by <samp>+</samp> as the opposite to
<samp>-</samp>.
</p>

<hr>

<h3><a name="s6.2.4"></a>6.2.4 Essential commands</h3>

<p>
These commands are the ones you really need to know to get anything done.
</p>

<p>
We give only a brief description of the command, describing its basic use.  For
full details, you should always refer to the detailed documentation of the
manual pages and the info files.
</p>

<p>
The brief examples given here are not by any means the only way of doing
things; the key to using Unix is to learn the building blocks and their
capabilities and become able to use them in your own way.  Whatever the task,
there is almost always more than one way to carry it out.  Sometimes there will
be five or six different ways!
</p>

<p>
In this chapter, things which are optional are shown <var>like this</var>.
<var>Words looking like this</var> are to be replaced by whatever is
appropriate to what you are trying to do.
</p>

<hr>

<h4><a name="s6.2.4.1"></a>6.2.4.1 Commands for reading documentation</h4>

<p>
To avoid annoying other users by questions on elementary matters, do, please,
read the manuals!
</p>

<p>
These are the commands to let you do that:
</p>
<dl>
<dt><code>man</code> [<var>section-number</var>] <var>subject</var></dt>
<dd>
<p>
<code>man</code> shows the manual page on the command (use q or ctrl-C to get
out of it if it doesn't terminate at the end of the text).  More details are
given in <a href="ch-manpages.html">Documentation, Chapter 3</a>.
</p>

<p>
This command is crucial for helping you learn how to use it and other Linux
commands.
</p>
</dd>
</dl>
<dl>
<dt><code>info</code> [<var>subject</var>]</dt>
<dd>
<p>
A lot of Debian Linux documentation is provided in <em>info</em> format.  This
is similar to a hypertext format, in that you can jump to other sections of the
documentation by following links embedded in the text.
</p>

<p>
See <a href="ch-manpages.html">Documentation, Chapter 3</a> for a full
description of how to use <code>info</code>.
</p>
</dd>
</dl>
<dl>
<dt><code>help</code> [<var>subject</var>]</dt>
<dd>
<p>
Use <code>help</code> for on-line help about bash's built-in commands.
</p>

<p>
<code>help</code> by itself prints a list of subjects for which you can ask for
help.
</p>
</dd>
</dl>

<hr>

<h4><a name="s6.2.4.2"></a>6.2.4.2 Commands for basic file-handling</h4>

<p>
A fuller description of file-systems and file-handling is given in <a
href="ch-files.html">Files and File Systems, Chapter 4</a>.
</p>

<p>
These are the commands that you really have to know:
</p>
<dl>
<dt><code>pwd</code></dt>
<dd>
<p>
Show the current directory.
</p>
</dd>
</dl>
<dl>
<dt><code>cd</code> [<var>directory</var>]</dt>
<dd>
<p>
Change your current directory to the named <var>directory</var>.  If you don't
specify <var>directory</var>, you will be returned to your home directory.
</p>
</dd>
</dl>
<dl>
<dt><code>mkdir</code> <var>new_directory</var></dt>
<dd>
<p>
<code>mkdir</code> is used to create a new directory.  <var>new_directory</var>
can be specified as a path, or as a simple name (in which case it is created in
the current directory).
</p>
</dd>
</dl>
<dl>
<dt><code>mv</code> <var>source</var> <var>target</var></dt>
<dd>
<p>
<code>mv</code> moves <var>source</var> file to <var>target</var> and deletes
<var>source</var>; <var>source</var> can be a list of files, but in that case
<var>target</var> must be a directory.
</p>

<p>
This is also the way to rename a file or directory.
</p>
</dd>
</dl>
<dl>
<dt><code>cp</code> <var>source</var> <var>target</var></dt>
<dd>
<p>
<code>cp</code> copies <var>source</var> to <var>target</var>.  Again,
<var>target</var> can be a directory and <var>source</var> a list of files.
</p>
</dd>
</dl>
<dl>
<dt><code>ln</code> <var>source</var> <var>target</var></dt>
<dd>
<p>
<code>ln</code> links <var>source</var> to <var>target</var> with hard or
symbolic links according to the options.
</p>
</dd>
</dl>
<dl>
<dt><code>rm</code> <var>filelist</var></dt>
<dd>
<p>
<code>rm</code> deletes files.  With the -r option it can delete directories
and their contents.
</p>

<p>
Be very careful with <code>rm</code>; once a file is deleted, you cannot get it
back.  There is no <code>undelete</code> command.
</p>
</dd>
</dl>
<dl>
<dt><code>rmdir</code> <var>directorylist</var></dt>
<dd>
<p>
<code>rm</code> deletes empty directories.
</p>
</dd>
</dl>
<dl>
<dt><code>chmod</code> <var>mode</var> <var>filelist</var></dt>
<dd>
<p>
<code>chmod</code> changes the permissions of files and directories.  The
<var>mode</var> is either an octal number, such as <samp>644</samp>, or a
symbolic representation of it, such as <samp>u=rw,go=r</samp>.
</p>
</dd>
</dl>
<dl>
<dt><code>chown</code> <var>owner</var>[.<var>group</var>] <var>filelist</var></dt>
<dd>
<p>
<code>chown</code> changes the ownership of files.  Use the <samp>-R</samp>
option to do this for an entire directory tree.
</p>

<p>
If .<var>group</var> is specified as well as <var>owner</var>, the group
ownership of the files is changed as well.
</p>
</dd>
</dl>
<dl>
<dt><code>chgrp</code> <var>group</var> <var>filelist</var></dt>
<dd>
<p>
<code>chgrp</code> changes the group ownership of files.  Use the
<samp>-R</samp> option to do this for an entire directory tree.
</p>
</dd>
</dl>
<dl>
<dt><code>ls</code> <var>directory</var></dt>
<dd>
<p>
<code>ls</code> lists the contents of <var>directory</var>; by default, the
output is sorted.
</p>

<p>
There are more options to <code>ls</code> than to any other command.  Those
most commonly used are <samp>-l</samp>, to show the file permissions and the
latest change date and <samp>-a</samp>, to show hidden dot-files.
</p>
</dd>
</dl>

<hr>

<h4><a name="s6.2.4.3"></a>6.2.4.3 These commands are used for managing file-systems</h4>

<p>
Files are organised into file-systems (see <a href="ch-files.html">Files and
File Systems, Chapter 4</a>).
</p>

<p>
Every Debian Linux system (and every Unix system) has a root file-system,
called, simply, <samp>/</samp>.  All files and devices in the system, and
possibly files on other systems as well, are accessible under <samp>/</samp>.
Files are placed under directories, which may themselves be placed in
directories, and so on.  Segments of this universal tree will be on different
physical devices, or different sections (`partitions') of a single physical
device.  New file-systems, each with its own directory tree, may be grafted
into the universal directory tree at arbitrary `mount-points'.  (These are
simply directories which are nominated to be the head of the new tree.)
</p>

<p>
The process of grafting a segment into the main tree is called `mounting'; the
file system is mounted on a mount-point, which is a directory.
</p>
<dl>
<dt><code>df</code></dt>
<dd>
<p>
<code>df</code> lists mounted partitions and shows the amount of space present,
used and available.  (The partitions will probably include /proc, which is a
special `non-existent' partition, that contains information about the current
state of the Linux kernel.)
</p>
</dd>
</dl>
<dl>
<dt><code>mount</code> [<var>partition</var> <var>directory</var>]</dt>
<dd>
<p>
<code>mount</code> by itself lists mounted partitions.
</p>

<p>
It is also the command to use to add a partition's file-system into the
universal directory tree.  For example:
</p>

<pre>
     mount /dev/hda2 /usr
</pre>

<p>
You have to be superuser (log in as <samp>root</samp> or run <code>su</code>)
in order to mount or unmount file-systems.
</p>
</dd>
</dl>
<dl>
<dt><code>umount</code> <var>directory</var></dt>
<dd>
<p>
<code>umount</code> removes a partition's file-system from the universal
directory tree.  For example:
</p>

<pre>
     umount /usr
</pre>

<p>
You have to be superuser (log in as <samp>root</samp> or run <code>su</code>)
in order to mount or unmount file-systems.
</p>
</dd>
</dl>

<hr>

<h4><a name="s6.2.4.4"></a>6.2.4.4 Looking at files</h4>

<p>
Files include physical devices, executable programs and directories, as well as
text files.  It is as well not to look at compiled executables on the screen
however.  At best they will be garbage; at worst they will make everything on
the screen unreadable (see <a href="#s-rmacs">Managing your screen, Section
6.2.4.5</a> for a way to recover from this.)
</p>
<dl>
<dt><code>cat</code> <var>textfile[s]</var></dt>
<dd>
<p>
<code>cat</code> dumps <var>textfile[s]</var> to screen without paging (like
DOS's type).  If you name more than one file, each will be sent in order, with
no break or heading.
</p>
</dd>
</dl>
<dl>
<dt><code>more</code> <var>textfile[s]</var></dt>
<dd>
<p>
<code>more</code> lists the <var>textfile[s]</var> to the screen in pages so
that you can read it.  Press <samp>Space-bar</samp> to move on one page,
<samp>Enter</samp> to move on one line, and <samp>b</samp> to move back one
page.  Use <samp>q</samp> or <samp>ctrl-c</samp> to quit.
</p>

<p>
<code>more</code> will quit automatically when it gets to the end of the last
file.
</p>
</dd>
</dl>
<dl>
<dt><code>less</code> <var>textfile[s]</var></dt>
<dd>
<p>
<code>less</code> is like <code>more</code> but has more features and somewhat
different behaviour.  You have to type <samp>Q</samp> to terminate it.
</p>
</dd>
</dl>
<dl>
<dt><code>head</code> <var>textfile[s]</var></dt>
<dd>
<p>
<code>head</code> is used to see the first few lines of a file (by default, it
shows 10 lines).
</p>
</dd>
</dl>
<dl>
<dt><code>tail</code> <var>textfile[s]</var></dt>
<dd>
<p>
<code>tail</code> is used to see the last few lines of a file (by default, it
shows 10 lines).
</p>
</dd>
</dl>
<dl>
<dt><code>od</code> <samp>-cx</samp> <var>file[s]</var></dt>
<dd>
<p>
<code>od</code> is used to look at the contents of binary files.  With no
options, it displays the file contents as a series of octal numbers.  Since few
people are fluent with this form, the <samp>-c</samp> and the <samp>-x</samp>
options together are probably more useful.  They display the file contents as
real characters where possible and as octal numbers if the characters are not
displayable, with, underneath, the hexadecimal representation.  For example:
</p>

<pre>
     $ od -cx /bin/ls | more
     0000000 177   E   L   F 001 001 001  \0  \0  \0  \0  \0  \0  \0  \0  \0
             457f 464c 0101 0001 0000 0000 0000 0000
     0000020 002  \0 003  \0 001  \0  \0  \0 240 217 004  \b   4  \0  \0  \0
             0002 0003 0001 0000 8fa0 0804 0034 0000
     0000040 204   o  \0  \0  \0  \0  \0  \0   4  \0      \0 005  \0   (  \0
             6f84 0000 0000 0000 0034 0020 0005 0028
     0000060 026  \0 025  \0 006  \0  \0  \0   4  \0  \0  \0   4 200 004  \b
             0016 0015 0006 0000 0034 0000 8034 0804
     0000100   4 200 004  \b 240  \0  \0  \0 240  \0  \0  \0 005  \0  \0  \0
             8034 0804 00a0 0000 00a0 0000 0005 0000
</pre>

<p>
[<a href="footnotes.html#f7" name="fr7">7</a>]
</p>

<p>
The numbers in the left hand column are always octal; they indicate the byte
offset of the first character on the line from the beginning of the file.
</p>
</dd>
</dl>
<dl>
<dt><code>dd</code> <samp>if=<var>input_file</var> of=<var>output_file</var></samp></dt>
<dd>
<p>
<code>dd</code> is used for arbitrary copying between files and devices (either
<var>file1</var> or <var>file2</var> or both could be devices instead of
files.) You can use <code>dd</code> to copy a file while dropping its first few
bytes, to break a file into chunks, to copy a disk image onto a floppy (for
instance to get a Debian boot floppy), to inspect the contents of a tape, or
anything else that your ingenuity can suggest.
</p>
</dd>
</dl>
<dl>
<dt><code>find</code> <var>directory</var> -name <var>filename</var></dt>
<dd>
<p>
<code>find</code> tells you where <var>filename</var> is in the tree starting
at <var>directory</var>.  This command has many other useful options.
</p>
</dd>
</dl>
<dl>
<dt><code>xargs</code> <var>command</var></dt>
<dd>
<p>
<code>xargs</code> is commonly used with <code>find</code>.  It breaks long
lists of files given to a command into chunks that are short enough for the
shell to handle.  In this way, you can run through the entire file system and
execute some command on all the selected files.  For example, this command
looks for all files in your home directory that have been changed within the
last two days, and sets group write access on them all:
</p>

<pre>
     find $HOME -mtime -2 | xargs chmod g+w
</pre>
</dd>
</dl>
<dl>
<dt><code>grep</code> <var>pattern</var> <var>filelist</var></dt>
<dd>
<p>
<code>grep</code> scans each file in <var>filelist</var> for lines which match
<var>pattern</var> (see <a href="#s-regexp">Regular expressions, Section
6.3</a>).
</p>
</dd>
</dl>
<dl>
<dt><code>file</code> <var>file</var></dt>
<dd>
<p>
<code>file</code> reports what kind of thing <var>file</var> is.
</p>
</dd>
</dl>
<dl>
<dt><code>type</code> <var>file</var></dt>
<dd>
<p>
<code>type</code> says where to find <var>file</var> in your search path.
</p>
</dd>
</dl>
<dl>
<dt><code>whereis</code> <var>file</var></dt>
<dd>
<p>
<code>whereis</code> is like <code>type</code>, but gives more information.
</p>
</dd>
</dl>

<hr>

<h4><a name="s-rmacs"></a>6.2.4.5 Managing your screen</h4>

<p>
Managing your screen can be a very frustrating experience.
</p>

<p>
When you have sat helpless for a while trying to work out why your entire
display contains total garbage, or why pressing an arrow key puts irrelevant
characters up, you may well feel that it's time to tip the whole computer
system into the dustbin and go back to the abacus.  This section offers you a
lifeline.
</p>

<p>
First of all, here are some commands to handle what you can see on your screen.
The screen can be either the whole text display or a single text window in X.
</p>
<dl>
<dt><code>tput</code> <samp>clear</samp></dt>
<dd>
<p>
All VDUs attached on serial cables, and all memory-mapped displays that emulate
VDUs, including your text console and your xterm windows, respond to special
character sequences that will change the appearance of the whole screen, or
portions of it, when they are sent to the screen.  Usually, these sequences
start with the ESCAPE character, but they don't have to.  Because of the vast
number of different VDUs produced by many different manufacturers, mostly with
different control sequences, Linux has a database of the sequences that apply
to different types of VDU.  The database appears in two forms -- the older is
called termcap and the newer, terminfo.
</p>

<p>
<code>tput</code> is a command that reads the terminfo database for the
sequence named, translates that sequence to screen control characters and sends
those characters to the screen.  The <samp>clear</samp> sequence blanks the
screen and puts the cursor in the top left hand corner.
</p>
</dd>
</dl>
<dl>
<dt><code>tput</code> <samp>rmacs</samp></dt>
<dd>
<p>
If, intentionally or not, you display a binary file on the screen, you may
chance to send to the screen the sequence that makes it display its alternative
character set; this usually contains a lot of graphics line-drawing characters,
card suits, odd mathematical symbols and so on.  The computer's attempt to
display ordinary text in this character set produces a screen containing total
garbage.  The <samp>rmacs</samp> sequence switches the display out of the
alternate character set.  Use this command to stop the display showing garbage
graphics characters and make it show proper text instead.  (The effect is
usually to change new characters sent to be proper text, but leave text already
displayed as it is.)
</p>
</dd>
</dl>
<dl>
<dt><code>stty</code></dt>
<dd>
<p>
<code>stty</code> controls communication between a VDU and the computer.  It
controls characteristics such as the baud-rate, parity, number of stop-bits and
handshaking, all of which should be set up for you by your system administrator
(if that is you, read the System Administration manual).  In the case of your
console, or of an xterm window, which are mapped directly from memory, the line
characteristics are irrelevant, but there are certain characteristics set by
<code>stty</code> which are relevant to every kind of display.
</p>

<p>
These are some characteristics could be used by you if it seemed necessary.
(If it <em>is</em> necessary, you may find that nothing at all seems to work;
this may be because the return key no longer works and Linux has reverted to
using the basic default, which is new line (Ctrl-J).  If nothing at all seems
to work, press Ctrl-J before entering any command and finish your commands with
Ctrl-J instead of return.)
</p>
<dl>
<dt><samp>sane</samp></dt>
<dd>
<p>
<samp>stty sane</samp> is one option to try if everything has stopped working.
Remember to use Ctrl-J both before and after the command and don't use the
return key.
</p>
</dd>
</dl>
<dl>
<dt><samp>echo</samp></dt>
<dd>
<p>
Use <samp>stty echo</samp> if what you type doesn't appear on the screen.
</p>
</dd>
</dl>
<dl>
<dt><samp>intr '^C'</samp></dt>
<dd>
<p>
Use <samp>stty intr '^C'</samp> to make Ctrl-C work as your interrupt key
(which will tell the running program to stop).
</p>
</dd>
</dl>
<dl>
<dt><samp>-a</samp></dt>
<dd>
<p>
Use <samp>stty -a</samp> to show you what your existing <code>stty</code>
settings are.
</p>
</dd>
</dl>
</dd>
</dl>

<hr>

<h4><a name="s6.2.4.6"></a>6.2.4.6 Compressed files</h4>

<p>
In order to save space on your disks, many files are compressed.  They are
scanned by a program such as <code>gzip</code> or <code>compress</code> and
reduced in size, often to about one third of their original size.
</p>

<p>
Compressed files cannot be read unless they are uncompressed again.
</p>
<dl>
<dt><code>gunzip</code> <var>file.suffix</var></dt>
<dd>
<p>
<code>gunzip</code> uncompresses <var>file.suffix</var> (where
<var>suffix</var>is <samp>.gz</samp> or perhaps <samp>.Z</samp>), deletes it
and writes an uncompressed file called <var>file</var>.
</p>

<p>
In spite of its name, <code>gunzip</code> cannot handle zip format files
created by <code>PKZIP</code>.  There is a <code>pkunzip</code> program that
can handle such files.
</p>
</dd>
</dl>
<dl>
<dt><code>zcat</code> <var>compressed_file</var></dt>
<dd>
<p>
<code>zcat</code> does the same job as <code>cat</code>, but uncompresses
<var>compressed_file</var> first, without changing it on the disk.
</p>
</dd>
</dl>
<dl>
<dt><code>zmore</code> <var>compressed_file</var></dt>
<dd>
<p>
<code>zmore</code> does the same job as <code>more</code>, but uncompresses
<var>compressed_file</var> first, without changing it on the disk.
</p>
</dd>
</dl>
<dl>
<dt><code>zless</code> <var>compressed_file</var></dt>
<dd>
<p>
<code>zless</code> does the same job as <code>less</code>, but uncompresses
<var>compressed_file</var> first, without changing it on the disk.
</p>
</dd>
</dl>
<dl>
<dt><code>zgrep</code> <var>compressed_file</var></dt>
<dd>
<p>
<code>zgrep</code> does the same job as <code>grep</code>, but uncompresses
<var>compressed_file</var> first, without changing it on the disk.
</p>
</dd>
</dl>

<hr>

<h4><a name="s6.2.4.7"></a>6.2.4.7 Commands for backup</h4>

<p>
You need to do regular backups, in order to be able to recover your system and
data in case of disaster.  In order to get full access to all the files that
need to be backed up, system backups must be done by the superuser.  This
section refers only to backups of your own home directory and of other files to
which you have access.
</p>

<p>
These programs are used for backups of various kinds:
</p>
<dl>
<dt><code>tar</code></dt>
<dd>
<p>
<code>tar</code> is designed to archive directories with all their contents.
It has many options, but here is a simple example of using it to create a
backup of your home directory to a SCSI tape:
</p>

<pre>
     tar cvf /dev/st0 $HOME
</pre>

<p>
Here is how to read the contents of a tape that has been written with
<code>tar</code>:
</p>

<pre>
     tar tf /dev/st0
</pre>

<p>
and here is how to restore a particular directory (with its contents) from such
a tape backup:
</p>

<pre>
     tar xvf /dev/st0 $HOME/private/letters
</pre>

<p>
You can also restore a single file:
</p>

<pre>
     tar xvf /dev/st0 $HOME/private/letters/bank.21Aug
</pre>
</dd>
</dl>
<dl>
<dt><code>cpio</code></dt>
<dd>
<p>
<code>cpio</code> is used to write individual files to a backup.  A list of
files is prepared in some way and then piped into the standard input of
<code>cpio</code>.  This is how to use it to archive your home directory to
SCSI tape:
</p>

<pre>
     find $HOME -print | cpio -ovBH newc &gt;/dev/st0
</pre>

<p>
Here is how to read the contents of a tape that has been written with
<code>cpio</code>:
</p>

<pre>
     cpio -itBH newc &lt;/dev/st0
</pre>

<p>
and here is how to restore a set of files in one directory whose names all
start with `bank' from such a tape backup:
</p>

<pre>
     cpio -itBH newc &quot;$HOME/private/letters/bank*&quot; &lt;/dev/st0
</pre>
</dd>
</dl>
<dl>
<dt><code>afio</code></dt>
<dd>
<p>
<code>afio</code> is used like cpio to write individual files to a backup.  It
has the additional capability of compressing files before it writes them on the
backup.  This is useful if you have a lot of information to store on media of
limited capacity.  This is how to use it to archive your home directory to SCSI
tape, using compression:
</p>

<pre>
     find $HOME -print | afio -ovZ &gt;/dev/st0
</pre>
</dd>
</dl>

<hr>

<h4><a name="s6.2.4.8"></a>6.2.4.8 Printing files</h4>

<p>
There is one basic command for printing (though there are many for specialised
uses):
</p>
<dl>
<dt><code>lpr</code> <var>file</var></dt>
<dd>
<p>
<code>lpr</code> prints <var>file</var> to the default printer.
<code>lpr</code> is the user command for adding jobs to the spooler queue.  The
jobs will continue to print, even if you log out.
</p>

<p>
If you have more than one printer, you can use the option -P<var>printer</var>
to direct a job to one particular printer.
</p>
</dd>
</dl>
<dl>
<dt><code>lpq</code></dt>
<dd>
<p>
<code>lpq</code> shows the current list of jobs on the printer spool queue.
</p>
</dd>
</dl>
<dl>
<dt><code>lprm</code> <var>jobId</var></dt>
<dd>
<p>
<code>lprm</code> removes the job identified by <var>jobId</var> from the
spooler queue.  If a job is already printing, this may not stop it; the job may
already be stored in the printer's memory
</p>
</dd>
</dl>

<hr>

<h4><a name="s6.2.4.9"></a>6.2.4.9 Changing files</h4>

<p>
See <a href="ch-editors.html">Text Editing, Chapter 8</a> for information on
editing files.
</p>

<hr>

<h4><a name="s6.2.4.10"></a>6.2.4.10 Session management</h4>

<p>
A session is the series of events between logging in and logging out of the
computer.
</p>

<p>
When you first log in, you will see a prompt, which may contain your current
machine's hostname, and perhaps the current directory.  The prompt ends with a
dollar sign: <em>$</em>, which indicates that you are an ordinary user.  If you
become superuser, the dollar sign should change to a hash (or sharp) sign:
<em>#</em>.  You need to know that you are superuser, <em>because you can then
do a great deal of damage to your system by mistyping ordinary commands.</em>
</p>

<p>
These commands relate to handling your session:
</p>
<dl>
<dt><code>exit</code> or <code>logout</code></dt>
<dd>
<p>
Use <code>exit</code> or <code>logout</code> to terminate your session and log
out.  All jobs you have started are terminated, unless they were started with
<code>nohup</code>, and your screen should return you to the log-in prompt.
You can often use Ctrl-D to do the same, but that capability can be disabled.
</p>
</dd>
</dl>
<dl>
<dt><code>su</code></dt>
<dd>
<p>
Use <code>su</code> to become superuser.  You will be asked to enter a
password; this is the password for the <samp>root</samp> login.
</p>

<p>
Becoming superuser is almost the same as logging in as root.  You get the same
power to do damage.  <em>Be very careful!</em>
</p>

<p>
Use <code>exit</code>, <code>logout</code> or ctrl-D to stop being superuser.
</p>
</dd>
</dl>
<dl>
<dt><code>bg</code> and <code>fg</code></dt>
<dd>
<p>
If you are running one job and want to run something else in the same screen
without stopping the first job, you can put the first job in the background by
typing Ctrl-Z.  You can then run other commands.  You can start the first job
running again in the background by using <code>bg</code>.  It will continue to
run in the background until it wants to send anything to the screen; then it
will stop and wait.  You can bring it forward again and let it continue by
using the command <code>fg</code>.
</p>
</dd>
</dl>
<dl>
<dt><code>script</code> <var>file</var></dt>
<dd>
<p>
Use <code>script</code> to record everything that appears on the screen (until
the next exit) in <var>file</var>.  This is useful if you need to record what's
going on in order to include it in your message when you ask for help.  Use
exit, logout or ctrl-D to stop the recording session.
</p>
</dd>
</dl>
<dl>
<dt><code>ps</code></dt>
<dd>
<p>
Use <code>ps</code> to list your processes.
</p>

<pre>
     $ ps
       PID  TT STAT   TIME COMMAND
      6122  p1 S      0:00 bash 
      6123  p2 S      0:00 bash 
      6408  p1 S      0:00 ftp 
      6916  p4 R      0:00 ps 
     13115  p7 SW     0:00 bash 
     19102  p3 SW     0:00 bash 
     19497  p4 S      0:00 -bash 
     19554  p3 S     11:25 uvsh 
     19623  p4 S      5:37 xemacs 
     21272  p6 SW     0:00 bash
</pre>

<p>
You can also use ps to see all processes on the system:
</p>

<pre>
     $ ps -ax
       PID  TT STAT   TIME COMMAND
         1  ?  SW     0:18 init 
         2  ?  SW     0:04 kflushd 
         3  ?  SW&lt;    0:00 kswapd 
        10  ?  S      0:18 update 
        31  ?  SW     0:00 nfsiod 
        32  ?  SW     0:00 nfsiod 
        33  ?  SW     0:00 nfsiod 
        34  ?  SW     0:00 nfsiod 
       143  ?  S      0:08 /sbin/syslogd 
       145  ?  S      0:00 klogd 
       154  ?  S      0:00 /sbin/kerneld 
       164  ?  S      0:00 inetd 
       167  ?  S      0:05 named 
       179  ?  SW     0:00 run_job 
       183  ?  SW     0:00 bootpd 
       205  ?  SW     0:00 gpm 
       209  ?  S      0:52 /usr/sbin/tcplogd 
       212  ?  SW     0:00 icmplogd 
       ... and so on ...
</pre>

<p>
The number in the column headed <samp>PID</samp> is the identifying number of
the process.  Under column <samp>TT</samp> is the tty (screen or window
identifier) where it is running.  A question mark here means that it is not
attached to any screen or window, but is running in the background.
</p>
</dd>
</dl>
<dl>
<dt><code>tty</code></dt>
<dd>
<p>
<code>tty</code> shows you which terminal (screen or window) you are in.
</p>

<pre>
     $ tty
     /dev/ttyp4
</pre>
</dd>
</dl>

<hr>

<h4><a name="s6.2.4.11"></a>6.2.4.11 Identity</h4>

<p>
These commands relate to your identity as a user and the machine's own
identity.
</p>
<dl>
<dt><code>passwd</code></dt>
<dd>
<p>
Use <code>passwd</code> to change the password that you use when you log in.
Follow the instructions on screen about what kind of password to choose.  When
you type the password in, it doesn't show on the screen, so you have to enter
it twice, to ensure that you make no typing errors.
</p>
</dd>
</dl>
<dl>
<dt><code>id</code></dt>
<dd>
<p>
<code>id</code> tells you what user you are and what group you are in.
</p>

<pre>
     $ id
     uid=1000(olly) gid=1000(olly) groups=1000(olly),6(disk),20(dialout),25(floppy),26(tape),29(audio),34(backup),37(operator),101(priory)
</pre>

<p>
<var>uid</var> indicates your user number, <var>gid</var> your group number
(which will be assigned to files that you create) and <var>groups</var> lists
the other groups that you are a member of.
</p>
</dd>
</dl>
<dl>
<dt><code>who -u</code></dt>
<dd>
<p>
<code>who -u</code> reports everyone who is logged on.
</p>
</dd>
</dl>
<dl>
<dt><code>uname</code> <samp>-a</samp></dt>
<dd>
<p>
<code>uname</code> <samp>-a</samp> reports the name, type and operating system
of your machine.
</p>
</dd>
</dl>
<dl>
<dt><code>date</code></dt>
<dd>
<p>
<code>date</code> reports the current time and date.
</p>

<p>
The superuser can use this command to set the date and time.
</p>
</dd>
</dl>

<hr>

<h4><a name="s6.2.4.12"></a>6.2.4.12 Turning off the computer</h4>

<p>
Turning the computer on and off is really a system administration subject, but
I include it here because it is something that every user who is his own
administrator needs to know.  If someone else is responsible for administering
the machine, you should neither need nor be able to shut it down.
</p>
<dl>
<dt><code>shutdown -t 0 -h now</code></dt>
<dd>
<p>
This command shuts the computer down safely.  You can also use ctrl-alt-del if
your system is set up for that.  (If you are in X, ctrl-alt-del will be
intercepted by X.  Get out of X first by using ctrl-alt-backspace.) Never turn
off a Unix machine without doing a safe shutdown: if you do, you will damage
your file-systems.
</p>
</dd>
</dl>

<hr>

<h3><a name="s6.2.5"></a>6.2.5 Special characters in commands</h3>

<p>
When you type a command, certain characters have a special meaning to the shell
and are interpreted before the command starts to run.  Full details are given
in the chapter on shells, but you need to understand what is happening, or you
will get results that you did not expect.
</p>

<p>
Shell special characters are interpreted by the shell as soon as it is given
the command.  For example, if you type <samp>ls *.bak</samp>, the shell
translates <samp>*.bak</samp> to the list of all files in the current directory
whose names end in <samp>.bak</samp>.  <em>The <code>ls</code> command never
sees the asterisk.</em> So if you want to search for files which actually have
an asterisk in their names, you have to escape the asterisk to stop the shell
from interpreting it.
</p>

<pre>
     linda:/tmp/junk$ ls **
     fred     george*  joe      mary     peter*
     linda:/tmp/junk$ ls *\*
     george*  peter*
     linda:/tmp/junk$
</pre>

<p>
In the example, the first command matched all files; the second matched only
those with a literal asterisk at the end of their names.
</p>

<p>
The same goes for other special characters.  here is the full list:
</p>
<dl>
<dt>\</dt>
<dd>
<p>
\ escapes itself and other specials
</p>
</dd>
</dl>
<dl>
<dt>[ ]</dt>
<dd>
<p>
[ ] encloses patterns for matching a single character
</p>
</dd>
</dl>
<dl>
<dt>*</dt>
<dd>
<p>
* stands for anything (including nothing)
</p>
</dd>
</dl>
<dl>
<dt>?</dt>
<dd>
<p>
?  stands for any single character
</p>
</dd>
</dl>
<dl>
<dt>( )</dt>
<dd>
<p>
( ) runs the contents of the parentheses in a sub-shell
</p>
</dd>
</dl>
<dl>
<dt>;</dt>
<dd>
<p>
; terminates a command pipeline - use it to separate commands on a single line
</p>
</dd>
</dl>
<dl>
<dt>&amp;</dt>
<dd>
<p>
&amp; runs the preceding pipeline in the background.
</p>

<p>
This is the same as typing Ctrl-Z and then <code>bg</code> to an already
running program.
</p>
</dd>
</dl>
<dl>
<dt>$word and ${word}</dt>
<dd>
<p>
$word and ${word} are interpreted as a shell variable (use ${word} if there is
danger of ambiguity).  There are other characters that can follow $ and give
other meanings.  (See <a href="ch-shells.html">Shells, Chapter 5</a>.)
</p>
</dd>
</dl>
<dl>
<dt>``</dt>
<dd>
<p>
The contents of the backquotes are run as a command and its output is used as
part of this command
</p>
</dd>
</dl>
<dl>
<dt>&quot;&quot;</dt>
<dd>
<p>
The contents of the quotes are treated as one argument; any specials inside the
quotes, except for $ and ``, are left uninterpreted.
</p>
</dd>
</dl>
<dl>
<dt>''</dt>
<dd>
<p>
The contents of the single quotes are passed to the command without any
interpretation.
</p>
</dd>
</dl>
<dl>
<dt>|</dt>
<dd>
<p>
The vertical bar sign is used to indicate a pipe.  The command on the left-hand
side of the pipe sends its output to the input of the command on the right side
of the pipe.
</p>
</dd>
</dl>
<dl>
<dt>&lt; and &gt;</dt>
<dd>
<p>
These symbols are used for redirection; see below.
</p>
</dd>
</dl>
<dl>
<dt>&amp;&amp;</dt>
<dd>
<p>
The double ampersand is used between two commands (on the same line).  It tells
the shell to run the second command only if the first one was successful[<a
href="footnotes.html#f8" name="fr8">8</a>] .
</p>
</dd>
</dl>
<dl>
<dt>||</dt>
<dd>
<p>
The double vertical bar is used between two commands (on the same line).  It
tells the shell to run the second command only if the first one was
unsuccessful.
</p>
</dd>
</dl>

<p>
For example, <samp>ls -d /[uv]*</samp> will list the names of all entries in
the root directory that start with u or v.  Unlike DOS, you can use patterns
like <samp>g*.gz</samp> (with the wildcard bit in the middle).
</p>

<p>
These characters have a special meaning only if they are the first non-space
character in the command:
</p>
<dl>
<dt>!</dt>
<dd>
<p>
If !  is immediately followed by a character other than =, it begins a history
substitution; if it is followed by a space it negates the return code of the
following command pipeline.  (For more details see <a
href="ch-shells.html">Shells, Chapter 5</a>.)
</p>
</dd>
</dl>
<dl>
<dt>^</dt>
<dd>
<p>
Quick history substitution, changing one string to another:
</p>

<pre>
     $ ls *.cc
     SQLBuilder.cc      dbwindow.cc        listitem.cc
     $ ^cc^h^
     ls *.h
     SQLBuilder.h      dbwindow.h        listitem.h
</pre>
</dd>
</dl>
<dl>
<dt>#</dt>
<dd>
<p>
# turns the line into a comment; the line is not processed in any way.
</p>
</dd>
</dl>

<p>
Don't confuse shell special characters with special characters in regular
expressions (see <a href="#s-regexp">Regular expressions, Section 6.3</a>).
Regular expressions must be protected from the shell by enclosing them in
single quotes.
</p>

<hr>

<h3><a name="s6.2.6"></a>6.2.6 Filters</h3>

<p>
Many commands are filters, so you can pass the output of one command to the
input of another:
</p>

<pre>
     awk -F: '{print $1 &quot; &quot; $6}' /etc/passwd | sort
</pre>

<p>
This is a fundamental concept of all Unix and Unix-like systems.  Many commands
are designed to be filters.  They can therefore be used as building blocks to
make more complex commands, in whatever way is needed at the time.
</p>

<hr>

<h3><a name="s6.2.7"></a>6.2.7 Standard input, standard output and standard error</h3>

<p>
When the shell starts a command for you, it opens files for standard input,
standard output and standard error.  By default, standard input is your
keyboard, standard output is your screen, and standard error is also your
screen.
</p>

<p>
Although the defaults are keyboard and screen, this can easily be changed.  In
fact, the shell copies its own standard input, output and error when it starts
a command, so the command inherits whatever the shell has.  A command can
change its own settings, by opening a different file, and you can tell the
shell to use a file instead of the default of keyboard or screen.
</p>

<p>
The file descriptor numbers for standard input, standard output and standard
error are 0, 1 and 2 respectively.
</p>

<hr>

<h3><a name="s6.2.8"></a>6.2.8 Redirection</h3>

<p>
You can redirect standard input, output and error by adding these sequences
after a command:
</p>
<dl>
<dt>&lt;</dt>
<dd>
<p>
&lt; <var>file</var> means take input from <var>file</var>.
</p>
</dd>
</dl>
<dl>
<dt>&gt;</dt>
<dd>
<p>
&gt; <var>file</var> means send output to <var>file</var> (overwriting and
destroying whatever is in the file already).
</p>

<p>
You can use this feature to empty a file, by typing
</p>

<pre>
     &gt;<var>file_with_unwanted_contents</var>
</pre>

<p>
on a line by itself.
</p>
</dd>
</dl>
<dl>
<dt>&gt;&gt;</dt>
<dd>
<p>
&gt;&gt; <var>file</var> means append output to <var>file</var>.
</p>
</dd>
</dl>
<dl>
<dt>2&gt;</dt>
<dd>
<p>
2&gt; <var>file</var> means send error messages to <var>file</var>
(overwriting).  (This means that errors can be directed separately from normal
output.)
</p>
</dd>
</dl>

<p>
There are more complex aspects to redirection, which may be studied in the
shell manual pages.
</p>

<p>
Here are some very common uses of redirection:
</p>
<dl>
<dt><code>cat</code> [<var>filelist</var>] &gt;<var>output_file</var></dt>
<dd>
<p>
We have already seen that <code>cat</code> can be used to look at files.  In
conjunction with redirection of standard output, it can be used to write files
as well.
</p>

<p>
If you omit <var>filelist</var>, cat will take its input from the keyboard,
until you type ctrl-D.
</p>
</dd>
</dl>
<dl>
<dt><code>echo</code> <var>text</var></dt>
<dd>
<p>
<code>echo</code> sends <var>text</var> to the standard output.  It is commonly
used in script programs to put text on the screen.
</p>

<p>
It can also be used with redirection of output to write to a file.  For
example,
</p>

<pre>
     echo &quot;An example file containing
     two lines of text&quot; &gt;/tmp/example
</pre>

<p>
and
</p>

<pre>
     echo &quot;A third line added to the first two&quot; &gt;&gt;/tmp/example
</pre>
</dd>
</dl>

<hr>

<h3><a name="s6.2.9"></a>6.2.9 Shell programs</h3>

<p>
Redirection is a simple part of shell programming, for which see the manual
pages of bash, zsh, tcsh, or whatever shell you have chosen.  A shell program
is a set of commands in a file or typed in.
</p>

<pre>
     for f in `grep -l widgets`
     	do
     		sed -e 's/widgets/gadgets/g' &lt;$f ${f}gadget
     		echo $f
     	done
</pre>

<p>
Once you have stored a shell program in a program file, you have to make it
executable by running chmod:
</p>

<pre>
             chmod a+x <var>my_program_file</var>
</pre>

<hr>

<h3><a name="s6.2.10"></a>6.2.10 Errors</h3>

<p>
Unix commands normally execute silently unless asked to be verbose or unless
there is an error.  An error means something that does not make sense to Linux;
it doesn't mean something you don't want to happen!
</p>

<p>
For example, I once had a client who had some unwanted files in his root
directory which were named &amp;TEMP&amp; and so on.  As superuser in the root
directory he typed <samp>rm -rf /&amp;*</samp> when he should have typed
<samp>rm -rf \&amp;*</samp> What he actually asked for was to delete his entire
file system, as a background job.  It did too.
</p>

<hr>

<h2><a name="s-regexp"></a>6.3 Regular expressions</h2>

<p>
Regular expressions are a way of specifying some text to match without having
to spell it out exactly.  Regular expressions are used inside editors and in
the grep command.  They are not the same as the limited file pattern matching
that is done by the command line.
</p>

<p>
A regular expression can be very simple or very complicated.  Complicated
expressions are built up by joining together simple ones.  In this section we
are only dealing with simple uses of regular expressions in the
<code>grep</code> and <code>zgrep</code> commands.  The simplest expressions
are called atoms, because they cannot be broken down any further.
</p>

<p>
Here are the regular expression atoms:
</p>
<dl>
<dt>character</dt>
<dd>
<p>
Any single character matches itself.
</p>
</dd>
</dl>
<dl>
<dt>.</dt>
<dd>
<p>
A full stop matches any single character.
</p>
</dd>
</dl>
<dl>
<dt>[ ]</dt>
<dd>
<p>
A list of characters in square brackets matches any single character provided
that it occurs inside the brackets.  A range of characters can be expressed
inside the brackets by specifying the two ends of the range separated by a
minus sign.  For example, the regular expression atom <samp>[ACafjl-rx]</samp>
matches any one occurrence of the letters `A', `C', `a', `f', `j', `l', `m',
`n', `o', `p', `q', `r' or `x'.
</p>

<p>
The effect of this atom can be reversed by making `^' the first character
inside the brackets.  This means that any character matches <em>except</em>
those in the brackets.
</p>
</dd>
</dl>
<dl>
<dt>^</dt>
<dd>
<p>
A circumflex character <em>outside</em> square brackets indicates the beginning
of a line.  (So it can only have this meaning at the beginning of a regular
expression.)
</p>
</dd>
</dl>
<dl>
<dt>$</dt>
<dd>
<p>
A dollar character <em>outside</em> square brackets indicates the end of a
line.  (So it can only have this meaning at the end of a regular expression.)
</p>
</dd>
</dl>
<dl>
<dt>\</dt>
<dd>
<p>
A backslash escapes the character that follows it; that is, it alters that
character's meaning.  For example, use <samp>\*</samp> to signify a real
asterisk, or <samp>\\</samp> to signify a real backslash.
</p>

<p>
Some letters have special meanings if they follow a backslash: <samp>\t</samp>
matches a tab character, <samp>\f</samp> matches a form feed character, and so
on.
</p>
</dd>
</dl>

<p>
The regular expression atoms can be affected by these modifiers (+ and ?  have
to be preceded by a backslash when used with <code>grep</code>):
</p>
<dl>
<dt><var>re</var>*</dt>
<dd>
<p>
A regular expression followed by an asterisk is matched by 0 or more
occurrences of that regular expression.  For example, <samp>b*</samp> matches
`', `b', `bb', `bbbbbb' and so on.
</p>
</dd>
</dl>
<dl>
<dt><var>re</var>+</dt>
<dd>
<p>
A regular expression followed by a plus sign is matched by 1 or more
occurrences of that regular expression.  For example, <samp>b+</samp> matches
`b', `bb', `bbbbbb' and so on.
</p>
</dd>
</dl>
<dl>
<dt><var>re</var>?</dt>
<dd>
<p>
A regular expression followed by a question mark is matched by 0 or one
occurrences of that regular expression.  For example, <samp>b?</samp> matches
`' or `b'.
</p>
</dd>
</dl>

<p>
Here is an example of the use of a regular expression with <code>grep</code>:
</p>

<pre>
     grep '^[A-Z][a-z]\+' basic_cmds.sgml
</pre>

<p>
This command would list all lines in <samp>basic_cmds.sgml</samp> that start
with a capital letter immediately followed by one or more lower case letters.
The plus sign is escaped with a backslash to make it have its special meaning.
The whole regular expression is in single quotes to protect it from being
evaluated by the shell.
</p>

<hr>

<p>
[ <a href="ch-shells.html">previous</a> ]
[ <a href="index.html#contents">Contents</a> ]
[ <a href="ch1.html">1</a> ]
[ <a href="ch-logging-in.html">2</a> ]
[ <a href="ch-manpages.html">3</a> ]
[ <a href="ch-files.html">4</a> ]
[ <a href="ch-shells.html">5</a> ]
[ 6 ]
[ <a href="ch7.html">7</a> ]
[ <a href="ch-editors.html">8</a> ]
[ <a href="ch9.html">9</a> ]
[ <a href="ch10.html">10</a> ]
[ <a href="ch11.html">11</a> ]
[ <a href="ch12.html">12</a> ]
[ <a href="ch13.html">13</a> ]
[ <a href="ch14.html">14</a> ]
[ <a href="ch15.html">15</a> ]
[ <a href="ch16.html">16</a> ]
[ <a href="ch-xwin.html">17</a> ]
[ <a href="ch18.html">18</a> ]
[ <a href="ch19.html">19</a> ]
[ <a href="ch20.html">20</a> ]
[ <a href="ch7.html">next</a> ]
</p>

<hr>

<p>
Debian User Reference Manual (Obsolete Documentation)
</p>

<address>
version 0.1, 29 Dezember 2009<br>
<br>
Ardo van Rangelrooij <code><a href="mailto:ardo@debian.org">ardo@debian.org</a></code><br>
Jason D. Waterman <code><a href="mailto:jwaterma@bbn.com">jwaterma@bbn.com</a></code><br>
Thalia L. Hooker <code><a href="mailto:th@visi.com">th@visi.com</a></code><br>
Havoc Pennington <code><a href="mailto:rhpennin@midway.uchicago.edu">rhpennin@midway.uchicago.edu</a></code><br>
Oliver Elphick - Maintainer <code><a href="mailto:Oliver.Elphick@lfix.co.uk">Oliver.Elphick@lfix.co.uk</a></code><br>
Bruce Evry <code><a href="mailto:bruce@fantek.org">bruce@fantek.org</a></code><br>
Karl-Heinz Zimmer <code><a href="mailto:khz@snafu.de">khz@snafu.de</a></code><br>
Andreas Franzen <code><a href="mailto:anfra@debian.org">anfra@debian.org</a></code><br>
<br>
</address>
<hr>

</body>

</html>

