<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
><HEAD
><TITLE
>Pocket Linux Guide</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"></HEAD
><BODY
CLASS="book"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="AEN1"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="title"
><A
NAME="AEN1"
></A
>Pocket Linux Guide</H1
><H3
CLASS="author"
><A
NAME="AEN4"
></A
>David Horton</H3
><DIV
CLASS="affiliation"
><DIV
CLASS="address"
><P
CLASS="address"
><br>
<TT
CLASS="email"
>&#60;<A
HREF="mailto:dhorton<AT>NOSPAM.member.fsf.org"
>dhorton&#60;AT&#62;NOSPAM.member.fsf.org</A
>&#62;</TT
><br>
</P
></DIV
></DIV
><DIV
CLASS="revhistory"
><TABLE
WIDTH="100%"
BORDER="0"
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
COLSPAN="3"
><B
>Revision History</B
></TH
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 3.1</TD
><TD
ALIGN="LEFT"
>2005-04-09</TD
><TD
ALIGN="LEFT"
>Revised by: DH</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Minor clarifications and spelling corrections.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 3.0</TD
><TD
ALIGN="LEFT"
>2004-11-02</TD
><TD
ALIGN="LEFT"
>Revised by: DH</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Changed bootloader to GRUB rather than LILO. Updated
        versions on all source code packages. Made minor clarifications to
        some shell commands and scripts.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 2.1</TD
><TD
ALIGN="LEFT"
>2004-02-18</TD
><TD
ALIGN="LEFT"
>Revised by: DH</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Corrected typos. Changed resource site hosting to
        SourceForge. Added appendix B to include the GNU Free Documentation
        License as part of this document.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 2.0</TD
><TD
ALIGN="LEFT"
>2003-11-08</TD
><TD
ALIGN="LEFT"
>Revised by: DH</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Updated to use GNU coreutils in place of fileutils,
        sh-utils and textutils. Updated version numbers on many source code
        packages. Introduced Freshmeat as a resource for finding source code.
        Changed /etc/mtab to a real file rather than using a symlink to
        /proc/mounts. Corrected local_fs script errors. Updated email
        address.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.2</TD
><TD
ALIGN="LEFT"
>2003-05-31</TD
><TD
ALIGN="LEFT"
>Revised by: DH</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Corrected errors in "strip -o library"
        commands.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.1</TD
><TD
ALIGN="LEFT"
>2003-05-21</TD
><TD
ALIGN="LEFT"
>Revised by: DH</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Bug fixes, typo corrections and improved XML
        markup.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revision 1.0</TD
><TD
ALIGN="LEFT"
>2003-02-17</TD
><TD
ALIGN="LEFT"
>Revised by: DH</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Initial Release, reviewed by LDP.</TD
></TR
></TABLE
></DIV
><DIV
><DIV
CLASS="abstract"
><A
NAME="AEN46"
></A
><P
></P
><P
>The Pocket Linux Guide is for anyone interested in learning the
      techniques of building a GNU/Linux system from source code. The guide is
      structured as a project that builds a small diskette-based GNU/Linux
      system called Pocket Linux. Each chapter explores a small piece of the
      overall system explaining how it works, why it is needed and how to
      build it. After completing the Pocket Linux project, readers should
      possess an enhanced knowledge of what makes GNU/Linux systems work as
      well as the confidence to explore larger, more complex source-code-only
      projects.</P
><P
></P
></DIV
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#legal"
>Legal Information</A
></DT
><DD
><DL
><DT
>1. <A
HREF="#copyright"
>Copyright and License</A
></DT
><DT
>2. <A
HREF="#disclaimer"
>Disclaimer</A
></DT
></DL
></DD
><DT
><A
HREF="#AEN60"
>Introduction</A
></DT
><DD
><DL
><DT
>1. <A
HREF="#AEN62"
>About Pocket Linux</A
></DT
><DT
>2. <A
HREF="#AEN65"
>Prerequisite Skills</A
></DT
><DT
>3. <A
HREF="#AEN77"
>Project Format</A
></DT
><DT
>4. <A
HREF="#AEN91"
>Help &#38; Support</A
></DT
><DT
>5. <A
HREF="#AEN104"
>Feedback</A
></DT
></DL
></DD
><DT
>1. <A
HREF="#initiation"
>Project Initiation</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#AEN110"
>A Brief History of GNU/Linux</A
></DT
><DT
>1.2. <A
HREF="#AEN118"
>The Goal of Pocket Linux</A
></DT
><DT
>1.3. <A
HREF="#AEN132"
>Working Within The Constraints</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#phase1"
>A Simple Prototype</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#AEN140"
>Analysis</A
></DT
><DT
>2.2. <A
HREF="#AEN150"
>Design</A
></DT
><DT
>2.3. <A
HREF="#AEN185"
>Construction</A
></DT
><DT
>2.4. <A
HREF="#AEN311"
>Implementation</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#phase2"
>Saving Space</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#AEN360"
>Analysis</A
></DT
><DT
>3.2. <A
HREF="#AEN367"
>Design</A
></DT
><DT
>3.3. <A
HREF="#AEN388"
>Construction</A
></DT
><DT
>3.4. <A
HREF="#AEN459"
>Implementation</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#phase3"
>Some Basic Utilities</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="#AEN495"
>Analysis</A
></DT
><DT
>4.2. <A
HREF="#AEN510"
>Design</A
></DT
><DT
>4.3. <A
HREF="#AEN581"
>Construction</A
></DT
><DT
>4.4. <A
HREF="#AEN677"
>Implementation</A
></DT
></DL
></DD
><DT
>5. <A
HREF="#phase4"
>Checking and Mounting Disks</A
></DT
><DD
><DL
><DT
>5.1. <A
HREF="#AEN729"
>Analysis</A
></DT
><DT
>5.2. <A
HREF="#AEN755"
>Design</A
></DT
><DT
>5.3. <A
HREF="#AEN867"
>Construction</A
></DT
><DT
>5.4. <A
HREF="#AEN974"
>Implementation</A
></DT
></DL
></DD
><DT
>6. <A
HREF="#phase5"
>Automating Startup &#38; Shutdown</A
></DT
><DD
><DL
><DT
>6.1. <A
HREF="#AEN1036"
>Analysis</A
></DT
><DT
>6.2. <A
HREF="#AEN1058"
>Design</A
></DT
><DT
>6.3. <A
HREF="#AEN1127"
>Construction</A
></DT
><DT
>6.4. <A
HREF="#AEN1226"
>Implementation</A
></DT
></DL
></DD
><DT
>7. <A
HREF="#phase6"
>Enabling Multiple Users</A
></DT
><DD
><DL
><DT
>7.1. <A
HREF="#AEN1257"
>Analysis</A
></DT
><DT
>7.2. <A
HREF="#AEN1265"
>Design</A
></DT
><DT
>7.3. <A
HREF="#AEN1378"
>Construction</A
></DT
><DT
>7.4. <A
HREF="#AEN1517"
>Implementation</A
></DT
></DL
></DD
><DT
>8. <A
HREF="#phase7"
>Filling in the Gaps</A
></DT
><DD
><DL
><DT
>8.1. <A
HREF="#AEN1563"
>Analysis</A
></DT
><DT
>8.2. <A
HREF="#AEN1601"
>Design</A
></DT
><DT
>8.3. <A
HREF="#AEN1654"
>Construction</A
></DT
><DT
>8.4. <A
HREF="#AEN1737"
>Implementation</A
></DT
></DL
></DD
><DT
>9. <A
HREF="#wrap-up"
>Project Wrap Up</A
></DT
><DD
><DL
><DT
>9.1. <A
HREF="#AEN1801"
>Celebrating Accomplishments</A
></DT
><DT
>9.2. <A
HREF="#AEN1815"
>Planning Next Steps</A
></DT
></DL
></DD
><DT
>A. <A
HREF="#a"
>Hosting Applications</A
></DT
><DD
><DL
><DT
>A.1. <A
HREF="#AEN1829"
>Analysis</A
></DT
><DT
>A.2. <A
HREF="#AEN1841"
>Design</A
></DT
><DT
>A.3. <A
HREF="#AEN1950"
>Construction</A
></DT
><DT
>A.4. <A
HREF="#AEN2058"
>Implementation</A
></DT
></DL
></DD
><DT
>B. <A
HREF="#gfdl"
>GNU Free Documentation License</A
></DT
><DD
><DL
><DT
>B.1. <A
HREF="#gfdl-0"
>PREAMBLE</A
></DT
><DT
>B.2. <A
HREF="#gfdl-1"
>APPLICABILITY AND DEFINITIONS</A
></DT
><DT
>B.3. <A
HREF="#gfdl-2"
>VERBATIM COPYING</A
></DT
><DT
>B.4. <A
HREF="#gfdl-3"
>COPYING IN QUANTITY</A
></DT
><DT
>B.5. <A
HREF="#gfdl-4"
>MODIFICATIONS</A
></DT
><DT
>B.6. <A
HREF="#gfdl-5"
>COMBINING DOCUMENTS</A
></DT
><DT
>B.7. <A
HREF="#gfdl-6"
>COLLECTIONS OF DOCUMENTS</A
></DT
><DT
>B.8. <A
HREF="#gfdl-7"
>AGGREGATION WITH INDEPENDENT WORKS</A
></DT
><DT
>B.9. <A
HREF="#gfdl-8"
>TRANSLATION</A
></DT
><DT
>B.10. <A
HREF="#gfdl-9"
>TERMINATION</A
></DT
><DT
>B.11. <A
HREF="#gfdl-10"
>FUTURE REVISIONS OF THIS LICENSE</A
></DT
><DT
>B.12. <A
HREF="#gfdl-addendum"
>ADDENDUM: How to use this License for your documents</A
></DT
></DL
></DD
></DL
></DIV
><DIV
CLASS="preface"
><HR><H1
><A
NAME="legal"
></A
>Legal Information</H1
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="copyright"
></A
>1. Copyright and License</H1
><P
> This document, <EM
>Pocket Linux Guide</EM
>, is
    copyright (c) 2003 - 2005 by <EM
>David Horton</EM
>. Permission
    is granted to copy, distribute and/or modify this document under the terms
    of the GNU Free Documentation License, Version 1.2 or any later version
    published by the Free Software Foundation; with no Invariant Sections,
    with no Front-Cover Texts, and with no Back-Cover Texts. A copy of the
    license is available at the end of this document. </P
><P
>Linux is a registered trademark of Linus Torvalds. </P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="disclaimer"
></A
>2. Disclaimer</H1
><P
>This documentation is provided as-is with no warranty of any kind,
    either expressed or implied, including, but not limited to, the implied
    warranties of merchantability and fitness for a particular purpose. Use
    the concepts, examples and information at your own risk. The author(s) do
    not take any responsibility for damages that may arise from the use of
    this document. </P
><P
>All copyrights are held by their respective owners, unless
    specifically noted otherwise. Use of a term in this document should not be
    regarded as affecting the validity of any trademark or service mark.
    Naming of particular products or brands should not be seen as
    endorsements. </P
></DIV
></DIV
><DIV
CLASS="preface"
><HR><H1
><A
NAME="AEN60"
></A
>Introduction</H1
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="AEN62"
></A
>1. About Pocket Linux</H1
><P
>The Pocket Linux Guide demonstrates how to build a small
    console-based GNU/Linux system using only source code and a couple of
    diskettes. It is intended for Linux users who would like to gain a deeper
    understanding about how their system works beneath the shroud of
    distribution specific features and tools. </P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN65"
></A
>2. Prerequisite Skills</H1
><P
>This guide is intended for intermediate to advanced Linux users. It
    is not intentionally obscure, but certain assumptions about the readers
    skill level are made. Success with this guide depends in part on being
    able to perform the following tasks: </P
><P
></P
><UL
><LI
><P
>Use basic shell commands</P
></LI
><LI
><P
>Reference man and info pages</P
></LI
><LI
><P
>Build a custom Linux kernel</P
></LI
><LI
><P
>Compile source code using make and related tools</P
></LI
></UL
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN77"
></A
>3. Project Format</H1
><P
> The Pocket Linux Guide takes a hands-on approach to learning. The
    guide is written with each chapter building a piece of an overall project.
    Chapters are further broken into sections of Analysis, Design,
    Construction and Implementation. This format is derived from Rapid
    Application Development (RAD) methodology. Without going into detail about
    design methodologies, the sections may be summed up as follows. </P
><P
></P
><UL
><LI
><P
>The Analysis section gives a high-level overview of what is to
        be accomplished in each chapter. It will introduce the tasks that need
        to be completed and why they are important to the overall
        system.</P
></LI
><LI
><P
>The Design section defines the source code packages, files and
        configuration necessary to address the requirements set forth in the
        Analysis section. Much of the theory of why certain system files exist
        and what their purpose is can be found here.</P
></LI
><LI
><P
>The Construction section is where all the hands-on action takes
        place. This section goes into detail about building source code and
        configuring the system files.</P
></LI
><LI
><P
>The Implementation section will test the proper operation of the
        project at the end of each chapter. Often there are a few shell
        commands to perform and samples of expected screen outputs are
        given.</P
></LI
></UL
><P
> Readers interested in learning more about RAD may want to consult a
    textbook covering systems analysis and design or visit the following
    University of California, Davis website on the subject: <A
HREF="http://sysdev.ucdavis.edu/WEBADM/document/rad-stages.htm"
TARGET="_top"
>http://sysdev.ucdavis.edu/WEBADM/document/rad-stages.htm</A
>.
    </P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN91"
></A
>4. Help &#38; Support</H1
><P
> Readers are encouraged to visit the Pocket Linux Resource Site at
    <A
HREF="http://pocket-linux.sourceforge.net"
TARGET="_top"
>http://pocket-linux.sourceforge.net/</A
>.
    The resource site is home to: </P
><P
></P
><UL
><LI
><P
>Information about the Pocket Linux mailing list.</P
></LI
><LI
><P
>A web-based troubleshooting forum where readers can ask
        questions and give tips to others.</P
></LI
><LI
><P
>A collection of diskette images for various chapters.</P
></LI
><LI
><P
>Additional projects that may be of interest to Pocket Linux
        Guide readers.</P
></LI
></UL
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN104"
></A
>5. Feedback</H1
><P
> For technical questions about Pocket Linux please use the mailing
    list or the troubleshooting forum on the <A
HREF="http://pocket-linux.sourceforge.net"
TARGET="_top"
>resource site</A
>. General
    comments and suggestions may be sent to the mailing list or emailed to the
    author directly.</P
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="initiation"
></A
>Chapter 1. Project Initiation</H1
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="AEN110"
></A
>1.1. A Brief History of GNU/Linux</H1
><P
>In the early 90's GNU/Linux systems consisted of little more than a
    beta-quality Linux kernel and a small collection of software ported from
    the GNU project. It was a true hacker's operating system. There were no
    CD-ROM's or GUI installation tools; everything had to be compiled and
    configured by the end user. Being a Linux Expert meant knowing your system
    inside and out.</P
><P
>Toward the middle of the decade several GNU/Linux distributions
    began appearing. One of the first was <A
HREF="http://www.slackware.org"
TARGET="_top"
>Slackware</A
> in 1993 and since then
    there have been many others. Even though there are many "flavors" of Linux
    today, the main purpose of the distribution remains the same. The
    distribution automates many of the tasks involved in GNU/Linux
    installation and configuration taking the burden off of the system
    administrator. Being a Linux Expert now means knowing which button to
    click in the GUI administration tool.</P
><P
>Recently there has been a yearn for a return to the "good old days"
    of Linux when men were men, sysadmins were hardcore geeks and everything
    was compiled from source code. A notable indication of this movement was
    the publication of the Linux-From-Scratch-HOWTO version 1.0 by Gerard
    Beekmans in 1999. Being a Linux Expert once again means knowing how to do
    it yourself.</P
><P
>For more historical information, see Ragib Hasan's "History of
    Linux" at <A
HREF="http://netfiles.uiuc.edu/rhasan/linux"
TARGET="_top"
>http://netfiles.uiuc.edu/rhasan/linux</A
></P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN118"
></A
>1.2. The Goal of Pocket Linux</H1
><P
>The purpose of Pocket Linux is to support and encourage people who
    wish to explore Linux by building a GNU/Linux system from nothing but
    source code. Pocket Linux is not intended to be a full featured system,
    but rather to give the reader a taste of what is involved in building an
    operating system from source code. After completing the Pocket Linux
    system the reader should have enough knowledge to confidently build almost
    any project using only source code. Given this direction we can put a few
    constraints on the project.</P
><P
></P
><UL
><LI
><P
>The main focus should be learning. The project should not just
        describe how to do something, it should also describe why it should be
        done.</P
></LI
><LI
><P
>The required time commitment should be minimal and
        manageable.</P
></LI
><LI
><P
>The project should not require any investment in additional
        hardware or reconfiguration of existing hardware to set up a lab
        environment.</P
></LI
><LI
><P
>Readers should not need to know any programming languages in
        order to complete the project.</P
></LI
><LI
><P
>To remain true to the spirit of GNU/Linux, all software used in
        the project should be covered under the GNU/GPL or another, similarly
        liberal, open-source license.</P
></LI
></UL
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN132"
></A
>1.3. Working Within The Constraints</H1
><P
>The Pocket Linux project gets its name from the fact that the bulk
    of the project fits onto two diskettes making it possible to carry the
    entire, working system around in one's pocket. This has the advantage of
    not requiring any additional hardware since any PC can be booted from the
    diskettes without disrupting any OS that exists on the hard drive. Using
    diskettes also partially addresses the aspect of time commitment, because
    the project size and complexity is necessarily limited by the 1.44
    Megabyte size of the installation media.</P
><P
>To further reduce the time commitment, the Pocket Linux project is
    divided into several phases, each one chapter in length. Each phase builds
    only a small piece of the overall project, but at the same time the
    conclusion of each chapter results in a self-contained, working system.
    This step-by-step approach should allow readers to pace themselves and not
    feel the need to rush to see results.</P
><P
>Chapters are further subdivided into four sections. The first two
    sections, analysis and design, focus on the theory of what is to be
    accomplished in each phase and why. The last two sections, construction
    and implementation, detail the steps needed to do the actual building.
    Advanced readers, who may be familiar with the theories laid out in a
    particular chapter are encouraged to gloss over the analysis and design
    sections in the interest of time. The separation of theory from hands-on
    exercises should allow readers of all skill levels to complete the project
    without feeling either completely lost or mired in too much detail.</P
><P
>Finally, the Pocket Linux project will strive to use GNU/GPL
    software when possible and other open-source licensed software when there
    is no GNU/GPL alternative. Also, Pocket Linux will never require any
    programming more complex than a BASH shell script.</P
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="phase1"
></A
>Chapter 2. A Simple Prototype</H1
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="AEN140"
></A
>2.1. Analysis</H1
><P
>Since this is the first phase of the project it will be kept very
    simple. The goal here is not to create the ultimate GNU/Linux system on
    the first try. Instead, we will be building a very minimal, working system
    to be used as a building block in subsequent phases of the project.
    Keeping this in mind, we can list a few goals for phase one.</P
><P
></P
><UL
><LI
><P
>Keep it simple to avoid stressing out.</P
></LI
><LI
><P
>Build something that works for instant gratification.</P
></LI
><LI
><P
>Make something that it is useful in later phases of the
        project.</P
></LI
></UL
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN150"
></A
>2.2. Design</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN152"
></A
>2.2.1. Simplification</H2
><P
>Take a moment to skim through the Bootdisk-HOWTO or the
      From-PowerUp-to-BASH-Prompt-HOWTO. These HOWTO documents can be found
      online at <A
HREF="http://www.tldp.org/docs.html#howto"
TARGET="_top"
>http://www.tldp.org/docs.html#howto</A
>.
      Both documents offer an excellent view of what it takes to get a
      GNU/Linux system up and running. There is also a lot of information to
      digest. Remember that one of our goals is, "keep it simple to avoid
      stressing out," so we want to ignore everything but the absolutely
      critical pieces of a boot / root diskset.</P
><P
>Basically it boils down to the following required items:</P
><P
></P
><UL
><LI
><P
>A boot loader</P
></LI
><LI
><P
>The Linux kernel</P
></LI
><LI
><P
>A shell</P
></LI
><LI
><P
>Some <TT
CLASS="filename"
>/dev</TT
> files</P
></LI
></UL
><P
>We don't even need an init daemon. The kernel can be told to run
      the shell directly by passing it an option through the boot
      loader.</P
><P
>For easy construction we will build a two-disk boot / root set
      rather than trying to get everything onto a single diskette. The boot
      loader and kernel will go on the boot disk and the shell will reside on
      the root disk.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN169"
></A
>2.2.2. Boot Disk</H2
><P
>For the boot disk we simply need to install the GRUB bootloader
      and a Linux kernel. We will need to use a kernel that does not require
      modules for the hardware we need to access. Mainly, it should have
      compiled-in support for the floppy drive, ram disk, second extended
      filesystem, proc filesystem, ELF binaries, and a text-based console. If
      such a kernel is not available, it will need to be built from source
      code. Kwan Lowe's <A
HREF="http://www.digitalhermit.com/linux/Kernel-Build-HOWTO.html"
TARGET="_top"
>Kernel
      Rebuild Guide</A
> is a good reference for this task, however we can
      ignore the sections that deal with modules and the initial
      ramdisk.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN173"
></A
>2.2.3. Root Disk</H2
><P
>For the root disk we will need a floppy that has been prepared
      with a filesystem. We will also need a BASH shell that is
      statically-linked so we can avoid the additional complexities of shared
      libraries. The <B
CLASS="command"
>configure</B
> program in the BASH source
      code recognizes the <TT
CLASS="option"
>--enable-static-link</TT
> option for
      this feature. We will also be using the
      <TT
CLASS="option"
>--enable-minimal-config</TT
> option to keep the BASH binary
      down to a manageable size. Additional requirements for the root disk are
      a <TT
CLASS="filename"
>/dev</TT
> directory and a device file for the console.
      The <TT
CLASS="filename"
>console</TT
> device is required for BASH to be able
      to communicate with the keyboard and video display.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN181"
></A
>2.2.4. CPU Compatibility</H2
><P
>There is one other, less obvious requirement to keep in mind and
      that is CPU compatibility. Each generation of CPU features a more
      complex architecture than its predecessor. Late generation chips have
      additional registers and instructions when compared to an older 486 or
      386. So a kernel optimized for a new, fast 6x86 machine will not run on
      an older box. (See the <TT
CLASS="filename"
>README</TT
> file in the Linux
      kernel source code for details.) A BASH shell built for a 6x86 will
      probably not run on an older processor either. To avoid this problem, we
      can choose the 386 as a lowest common denominator CPU and build all the
      code for that architecture.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN185"
></A
>2.3. Construction</H1
><P
>In this section, we will be building the actual boot disk and root
    disk floppies. Lines preceded by <TT
CLASS="prompt"
>bash#</TT
> indicate a shell
    command and lines starting with <TT
CLASS="prompt"
>grub&#62;</TT
> indicate a
    command typed within the grub shell.</P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN190"
></A
>2.3.1. Prepare the boot disk media</H2
><P
>Insert a blank diskette labeled "boot disk".</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>It may be necessary to erase the "blank" diskette if it comes
        factory pre-formatted for another, non-Linux operating system. This
        can be done using the command <B
CLASS="command"
>dd if=/dev/zero of=/dev/fd0
        bs=1k count=1440</B
></P
></TD
></TR
></TABLE
></DIV
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> mke2fs -m0 /dev/fd0
<TT
CLASS="prompt"
>bash#</TT
> mount /dev/fd0 /mnt</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN200"
></A
>2.3.2. Build the GRUB bootloader</H2
><P
>Get the GRUB source code from <A
HREF="ftp://alpha.gnu.org/gnu/grub/"
TARGET="_top"
>ftp://alpha.gnu.org/gnu/grub/</A
>
      and unpack it into the <TT
CLASS="filename"
>/usr/src</TT
> directory.</P
><P
>Configure and build the GRUB source code for an i386 processor by
      using the following commands:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>bash# cd /usr/src/grub-0.95
bash# export CC="gcc -mcpu=i386"
bash# ./configure --host=i386-pc-linux-gnu --without-curses
bash# make</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN207"
></A
>2.3.3. Copy the bootloader files to diskette</H2
><P
>Normally, after compiling source code, one would use the command
      <B
CLASS="command"
>make install</B
> to copy the finished files to their
      proper destinations in the filesystem. However, using <B
CLASS="command"
>make
      install</B
> does not work well with small media like the floppy
      disks we are using. The problem is that there are many files in a
      package besides the actual binaries that get the job done. For example,
      there are often man or info pages that provide documentation. These
      extra files can take up more space than we can spare on the diskette. We
      can work around this limitation by copying essential files manually
      rather than using <B
CLASS="command"
>make install</B
>.</P
><P
>For GRUB to boot we will need to copy the stage1 and stage2
      bootloader files to the <TT
CLASS="filename"
>/boot/grub</TT
> directory on the
      boot floppy.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> mkdir -p /mnt/boot/grub
<TT
CLASS="prompt"
>bash#</TT
> cp /usr/src/grub-0.95/stage1/stage1 /mnt/boot/grub
<TT
CLASS="prompt"
>bash#</TT
> cp /usr/src/grub-0.95/stage2/stage2 /mnt/boot/grub</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN219"
></A
>2.3.4. Finish bootloader installation</H2
><P
>Once the bootloader's files are copied to the boot disk we can
      enter the grub shell to finish the installation.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> /usr/src/grub-0.95/grub/grub
<TT
CLASS="prompt"
>grub&#62;</TT
> root (fd0)
<TT
CLASS="prompt"
>grub&#62;</TT
> setup (fd0)
<TT
CLASS="prompt"
>grub&#62;</TT
> quit</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN227"
></A
>2.3.5. Build the Linux kernel</H2
><P
>The steps for building the kernel were tested using Linux kernel
      version 2.4.26 and should work any 2.4.x or 2.6.x kernel. The latest
      version of the kernel source code may be downloaded from <A
HREF="http://www.kernel.org/"
TARGET="_top"
>http://www.kernel.org/</A
> or one of
      its mirrors.</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The instructions below are very brief and are intended for
        someone who has previous experience building custom kernels. A more
        detailed explanation of the kernel building process can be found in
        the <A
HREF="http://www.digitalhermit.com/linux/Kernel-Build-HOWTO.html"
TARGET="_top"
>Kernel
        Rebuild Guide</A
> by Kwan Lowe.</P
></TD
></TR
></TABLE
></DIV
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd /usr/src/linux
<TT
CLASS="prompt"
>bash#</TT
> make menuconfig</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Be sure to configure support for the following:</P
><P
></P
><UL
><LI
><P
>386 processor</P
></LI
><LI
><P
>Console on virtual terminal (2.4.x kernels only)</P
></LI
><LI
><P
>ELF binaries</P
></LI
><LI
><P
>Floppy disk</P
></LI
><LI
><P
>proc filesystem</P
></LI
><LI
><P
>RAM disk with a default size of 4096K</P
></LI
><LI
><P
>Second extended (ext2) filesystem</P
></LI
><LI
><P
>VGA console</P
></LI
></UL
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> make dep
<TT
CLASS="prompt"
>bash#</TT
> make clean
<TT
CLASS="prompt"
>bash#</TT
> make bzImage</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN261"
></A
>2.3.6. Copy the kernel to diskette</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cp /usr/src/linux/arch/i386/boot/bzImage /mnt/boot/vmlinuz</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN266"
></A
>2.3.7. Unmount the boot disk</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd /
<TT
CLASS="prompt"
>bash#</TT
> umount /mnt</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN272"
></A
>2.3.8. Prepare the root disk media</H2
><P
>Insert a blank diskette labeled "root disk".</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> mke2fs -m0 /dev/fd0
<TT
CLASS="prompt"
>bash#</TT
> mount /dev/fd0 /mnt</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN279"
></A
>2.3.9. Build BASH</H2
><P
>Get the bash-3.0 source code package from <A
HREF="ftp://ftp.gnu.org/gnu/bash/"
TARGET="_top"
>ftp://ftp.gnu.org/gnu/bash/</A
>
      and untar it into the <TT
CLASS="filename"
>/usr/src</TT
> directory.</P
><P
>Build BASH for an i386 CPU with the following commands:</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd /usr/src/bash-3.0
<TT
CLASS="prompt"
>bash#</TT
> export CC="gcc -mcpu=i386"
<TT
CLASS="prompt"
>bash#</TT
> ./configure --enable-static-link \
  --enable-minimal-config --host=i386-pc-linux-gnu
<TT
CLASS="prompt"
>bash#</TT
> make
<TT
CLASS="prompt"
>bash#</TT
> strip bash</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN292"
></A
>2.3.10. Copy BASH to the root disk</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> mkdir /mnt/bin
<TT
CLASS="prompt"
>bash#</TT
> cp bash /mnt/bin/bash
<TT
CLASS="prompt"
>bash#</TT
> ln -s bash /mnt/bin/sh</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN299"
></A
>2.3.11. Create device files that BASH needs</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> mkdir /mnt/dev
<TT
CLASS="prompt"
>bash#</TT
> mknod /mnt/dev/console c 5 1</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN305"
></A
>2.3.12. Unmount the root disk</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd /
<TT
CLASS="prompt"
>bash#</TT
> umount /mnt
</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN311"
></A
>2.4. Implementation</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN313"
></A
>2.4.1. System startup</H2
><P
>Follow these steps to boot the system:</P
><P
></P
><UL
><LI
><P
>Restart the PC with the boot disk in the floppy drive.</P
></LI
><LI
><P
>When the <TT
CLASS="prompt"
>grub&#62;</TT
> prompt appears, type
          <TT
CLASS="userinput"
><B
>kernel (fd0)/boot/vmlinuz init=/bin/sh root=/dev/fd0
          load_ramdisk=1 prompt_ramdisk=1</B
></TT
> and press
          <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>After the kernel loads, type <TT
CLASS="userinput"
><B
>boot</B
></TT
> and
          press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>Insert the root disk when prompted.</P
></LI
></UL
><P
>If all goes well the screen should look something like the example
      shown below.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>GNU GRUB version 0.95

grub&#62; kernel (fd0)/boot/vmlinuz init=/bin/sh root=/dev/fd0 load_ramdisk=1 prompt_ramdisk=1
   [Linux-bzImage, setup=0xc00, size=0xce29b]

grub&#62; boot

Linux version 2.4.26
..
.. [various kernel messages]
..
VFS: Insert root floppy disk to be loaded into RAM disk and press ENTER
RAMDISK: ext2 filesystem found at block 0
RAMDISK: Loading 1440 blocks [1 disk] into ram disk... done.
VFS: Mounted root (ext2 filesystem) readonly.
Freeing unused kernel memory: 178k freed
# _</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN333"
></A
>2.4.2. Testing what works</H2
><P
>Try out a few of BASH's built-in commands to see if things are
      working properly.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> echo "Hello World"
<TT
CLASS="prompt"
>bash#</TT
> cd /
<TT
CLASS="prompt"
>bash#</TT
> pwd
<TT
CLASS="prompt"
>bash#</TT
> echo *</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN342"
></A
>2.4.3. Noting what does not work</H2
><P
>Try out a few other familiar commands.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> ls /var
<TT
CLASS="prompt"
>bash#</TT
> mkdir /var/tmp</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Notice that only commands internal to BASH actually work and that
      external commands like <B
CLASS="command"
>ls</B
> and
      <B
CLASS="command"
>mkdir</B
> do not work at all. This shortcoming is
      something that can be addressed in a future phase of the project. For
      now we should just enjoy the fact that our prototype boot / root diskset
      works and that it was not all that hard to build.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN352"
></A
>2.4.4. System shutdown</H2
><P
>Remove the diskette from fd0 and restart the system using
      <B
CLASS="keycap"
>CTRL</B
>-<B
CLASS="keycap"
>ALT</B
>-<B
CLASS="keycap"
>DELETE</B
>.</P
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="phase2"
></A
>Chapter 3. Saving Space</H1
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="AEN360"
></A
>3.1. Analysis</H1
><P
>One of the drawbacks in the prototype phase of the project was that
    the diskset was not all that useful. The only commands that worked were
    the ones built into the BASH shell. We could improve our root disk by
    installing commands like <B
CLASS="command"
>cat</B
>, <B
CLASS="command"
>ls</B
>,
    <B
CLASS="command"
>mv</B
>, <B
CLASS="command"
>rm</B
> and so on. Unfortunately, we
    are short on space. The current root disk has no shared libraries so each
    utility would have to be statically-linked just like the BASH shell. A lot
    of big binaries together with a static shell will rapidly exceed the tiny
    1.44M of available disk space. So our main goal in this phase should be to
    maximize space savings on the root disk and pave the way for expanded
    functionality in the next phase.</P
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN367"
></A
>3.2. Design</H1
><P
>Take another look at the Bootdisk-HOWTO and notice how many
    utilities can be squeezed onto a 1.44M floppy. There are three things that
    make this possible. One is the use of shared libraries. The second is
    stripped binaries. And the third is the use of a compressed filesystem. We
    can use all of these techniques to save space on our root disk.</P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN370"
></A
>3.2.1. Shared Libraries</H2
><P
>First, in order to use shared libraries we will need to rebuild
      the BASH shell. This time we will configure it without using the
      <TT
CLASS="option"
>--enable-static-link</TT
> option. Once BASH is rebuilt we
      need to figure out which libraries it is linked with and be sure to
      include them on the root disk. The <B
CLASS="command"
>ldd</B
> command makes
      this job easy. By typing <B
CLASS="command"
>ldd bash</B
> on the command-line
      we can see a list of all the shared libraries that BASH uses. As long as
      all these libraries are copied to the root disk, the new BASH build
      should work fine.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN376"
></A
>3.2.2. Stripped Binaries</H2
><P
>Next, we should strip any binaries that get copied to the root
      disk. The manpage for <B
CLASS="command"
>strip</B
> does not give much
      description of what it does other than to say, "strip discards all
      symbols from the object files." It seems like removing pieces of a
      binary would render it useless, but this is not the case. The reason it
      works is because a large number of these discarded symbols are used for
      debugging. While debugging symbols are very helpful to programmers
      working to improve the code, they do not do much for the average
      end-user other than take up more disk space. And since space is at a
      premium, we should definitely remove as many symbols as possible from
      BASH and any other binaries before we copy over them to the
      ramdisk.</P
><P
>The process of stripping files to save space also works with
      shared library files. But when stripping libraries it is important to
      use the <TT
CLASS="option"
>--strip-unneeded</TT
> option so as not to break
      them. Using <TT
CLASS="option"
>--strip-unneeded</TT
> shrinks the file size, but
      leaves the symbols needed for relocation intact which is something that
      shared libraries need to function properly.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN383"
></A
>3.2.3. Compressed Root Filesystem</H2
><P
>Finally, we can tackle the problem of how to build a compressed
      root filesystem. The Bootdisk-HOWTO suggests three ways of constructing
      a compressed root filesystem using either a ramdisk, a spare hard drive
      partition or a loopback device. This project will concentrate on using
      the ramdisk approach. It seems logical that if the root filesystem is
      going to be run from a ramdisk, it may as well be built on a ramdisk.
      All we have to do is create a second extended filesystem on a ramdisk
      device, mount it and copy files to it. Once the filesystem is populated
      with all the files that the root disk needs, we simply unmount it,
      compress it and write it out to floppy.</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>For this to work, we need to make sure the system used for
        building has ramdisk support. If ramdisk is not available it is also
        possible to use a loopback device. See the Bootdisk-HOWTO for more
        information on using loopback devices.</P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN388"
></A
>3.3. Construction</H1
><P
>This section is written using ramdisk seven
    (<TT
CLASS="filename"
>/dev/ram7</TT
>) to build the root image. There is nothing
    particularly special about ramdisk seven and it is possible to use any of
    the other available ramdisks provided they are not already in use.</P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN392"
></A
>3.3.1. Create a ramdisk</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> dd if=/dev/zero of=/dev/ram7 bs=1k count=4096
<TT
CLASS="prompt"
>bash#</TT
> mke2fs -m0 /dev/ram7 4096
<TT
CLASS="prompt"
>bash#</TT
> mount /dev/ram7 /mnt</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN399"
></A
>3.3.2. Rebuild the BASH shell</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd /usr/src/bash-3.0
<TT
CLASS="prompt"
>bash#</TT
> make distclean
<TT
CLASS="prompt"
>bash#</TT
> export CC="gcc -mcpu=i386"
<TT
CLASS="prompt"
>bash#</TT
> ./configure --enable-minimal-config --host=i386-pc-linux-gnu
<TT
CLASS="prompt"
>bash#</TT
> make
<TT
CLASS="prompt"
>bash#</TT
> strip bash</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN409"
></A
>3.3.3. Determine which libraries are required</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> ldd bash</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>View the output from the <B
CLASS="command"
>ldd</B
> command. It should
      look similar to the example below.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>bash# ldd bash
  libdl.so.2 =&#62; /lib/libdl.so.2 (0x4001d000)
  libc.so.6 =&#62; /lib/libc.so.6 (0x40020000)
  /lib/ld-linux.so.2 =&#62; /lib/ld-linux.so.2 (0x40000000)</PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Some systems may have a slightly different library set up. For
        example, you may see <TT
CLASS="computeroutput"
>libc.so.6 =&#62;
        /lib/tls/libc.so.6</TT
> rather than
        <TT
CLASS="computeroutput"
>libc.so.6 =&#62; /lib/libc.so.6</TT
> as
        shown in the example. If your <B
CLASS="command"
>ldd</B
> output does not
        match the example then use the path given by your
        <B
CLASS="command"
>ldd</B
> command when completing the next step.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN423"
></A
>3.3.4. Copy BASH and its libraries to the ramdisk</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> mkdir /mnt/bin
<TT
CLASS="prompt"
>bash#</TT
> cp bash /mnt/bin
<TT
CLASS="prompt"
>bash#</TT
> ln -s bash /mnt/bin/sh
<TT
CLASS="prompt"
>bash#</TT
> mkdir /mnt/lib
<TT
CLASS="prompt"
>bash#</TT
> strip --strip-unneeded -o /mnt/lib/libdl.so.2 /lib/libdl.so.2
<TT
CLASS="prompt"
>bash#</TT
> strip --strip-unneeded -o /mnt/lib/libc.so.6 /lib/libc.so.6
<TT
CLASS="prompt"
>bash#</TT
> strip --strip-unneeded -o /mnt/lib/ld-linux.so.2 /lib/ld-linux.so.2
<TT
CLASS="prompt"
>bash#</TT
> chmod +x /mnt/lib/ld-linux.so.2</PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Using <B
CLASS="command"
>strip -o</B
> might seem an odd way to
          copy library files from the development system to the ramdisk. What
          it does is strip the symbols while the file is in transit from the
          source location to the destination. This has the effect of stripping
          symbols from the library on the ramdisk without altering the
          libraries on the development system. Unfortunately file permissions
          are lost when copying libraries this way which is why the
          <B
CLASS="command"
>chmod +x</B
> command is then used to set the execute
          flag for the rootdisk's dynamic loader.</P
></TD
></TR
></TABLE
></DIV
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN439"
></A
>3.3.5. Create a console device</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> mkdir /mnt/dev
<TT
CLASS="prompt"
>bash#</TT
> mknod /mnt/dev/console c 5 1</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN445"
></A
>3.3.6. Compress the ramdisk image</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd /
<TT
CLASS="prompt"
>bash#</TT
> umount /dev/ram7
<TT
CLASS="prompt"
>bash#</TT
> dd if=/dev/ram7 of=~/phase2-image bs=1k count=4096
<TT
CLASS="prompt"
>bash#</TT
> gzip -9 ~/phase2-image</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN453"
></A
>3.3.7. Copy the compressed image to diskette</H2
><P
>Insert the floppy labeled "root disk" into drive fd0.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> dd if=~/phase2-image.gz of=/dev/fd0 bs=1k</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN459"
></A
>3.4. Implementation</H1
><P
>Successful implementation of this phase is probably the most
    difficult part of the Pocket Linux Guide. If you need help getting things
    to work please visit the <A
HREF="http://pocket-linux.sourceforge.net"
TARGET="_top"
>Pocket Linux Guide Resource
    Site</A
> to browse the troubleshooting forum and subscribe to the
    mailing list.</P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN463"
></A
>3.4.1. System startup</H2
><P
>Follow these steps to boot:</P
><P
></P
><UL
><LI
><P
>Restart the PC using the boot disk from the previous
          chapter.</P
></LI
><LI
><P
>At the <TT
CLASS="prompt"
>grub&#62;</TT
> prompt, type
          <TT
CLASS="userinput"
><B
>kernel (fd0)/boot/vmlinuz init=/bin/sh root=/dev/fd0
          load_ramdisk=1 prompt_ramdisk=1</B
></TT
> and press
          <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>Type <TT
CLASS="userinput"
><B
>boot</B
></TT
> at the
          <TT
CLASS="prompt"
>grub&#62;</TT
> prompt and press
          <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>Insert the new, compressed root disk when prompted.</P
></LI
></UL
><P
>The screen output should be similar to the following
      example:</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>GNU GRUB version 0.95

grub&#62; kernel (fd0)/boot/vmlinuz init=/bin/sh root=/dev/fd0 load_ramdisk=1 prompt_ramdisk=1
   [Linux-bzImage, setup=0xc00, size=0xce29b]

grub&#62; boot

Linux version 2.4.26
..
.. [various kernel messages]
..
VFS: Insert root floppy disk to be loaded into RAM disk and press ENTER
RAMDISK: Compressed image found at block 0
VFS: Mounted root (ext2 filesystem) readonly.
Freeing unused kernel memory: 178k freed
# _</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN484"
></A
>3.4.2. Verify results</H2
><P
>If the implementation was successful, this new root disk should
      behave exactly like the root disk from the previous chapter. The key
      difference is that this compressed root disk has much more room to grow
      and we will put this extra space to good use in the next phase of the
      project.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN487"
></A
>3.4.3. System shutdown</H2
><P
>Remove the diskette from fd0 and restart the system using
      <B
CLASS="keycap"
>CTRL</B
>-<B
CLASS="keycap"
>ALT</B
>-<B
CLASS="keycap"
>DELETE</B
>.</P
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="phase3"
></A
>Chapter 4. Some Basic Utilities</H1
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="AEN495"
></A
>4.1. Analysis</H1
><P
>In the previous chapter it might seem like we did not accomplish
    very much. A lot of energy was expended redesigning the root disk, but the
    functionality is basically the same as in the initial prototype phase. The
    root disk still does not do very much. But we did make significant
    improvements when it comes to space savings. In this chapter we will put
    that extra space to good use and start cramming the root disk with as many
    utilities as it can hold.</P
><P
>The first two root disks we built only had shell built-in commands
    like <B
CLASS="command"
>echo</B
> and <B
CLASS="command"
>pwd</B
>. This time it
    would be nice to have some of the commonly used external commands like
    <B
CLASS="command"
>cat</B
>, <B
CLASS="command"
>ls</B
>, <B
CLASS="command"
>mkdir</B
>,
    <B
CLASS="command"
>rm</B
> and such on the root disk. Keeping this in mind we
    can define the goals for this phase as follows:</P
><P
></P
><UL
><LI
><P
>Retain all of the functionality from the previous root
        disk.</P
></LI
><LI
><P
>Add some of the commonly used external commands.</P
></LI
></UL
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN510"
></A
>4.2. Design</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN512"
></A
>4.2.1. Determining Required Commands</H2
><P
>The first question that might come to mind is, "How do we know
      which commands are needed?" It is possible to just start with
      <B
CLASS="command"
>cat</B
> and <B
CLASS="command"
>ls</B
> then install other
      commands as we discover a need for them. But this is terribly
      inefficient. We need a plan or a blueprint to work from. For this we can
      turn to the Filesystem Hierarchy Standard (FHS) available from <A
HREF="http://www.pathname.com/fhs/"
TARGET="_top"
>http://www.pathname.com/fhs/</A
>.
      The FHS dictates which commands should be present on a Linux system and
      where they should be placed in the directory structure.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN518"
></A
>4.2.2. Locating Source Code</H2
><P
>The next logical question is, "Now that we know what we need,
      where do we get the source code?" One way to find the answer to this
      question is to check the manpages. We can either search the manpages
      included with one of the popular GNU/Linux distributions or use one of
      the manpage search engines listed at <A
HREF="http://www.tldp.org/docs.html#man"
TARGET="_top"
>http://www.tldp.org/docs.html#man</A
>.
      One thing that should tip us off as to where to find the source code for
      a particular command is the email address listed for reporting bugs. For
      example the cat manpage lists bug-textutils@gnu.org. From this email
      address we can deduce that <B
CLASS="command"
>cat</B
> is part of the
      textutils package from <A
HREF="http://gnu.org"
TARGET="_top"
>GNU</A
>.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN524"
></A
>4.2.3. Leveraging FHS</H2
><P
>So let's look at the FHS requirements for the
      <TT
CLASS="filename"
>/bin</TT
> directory. The first few commands in the list
      are <B
CLASS="command"
>cat</B
>, <B
CLASS="command"
>chgrp</B
>,
      <B
CLASS="command"
>chmod</B
>, <B
CLASS="command"
>chown</B
> and
      <B
CLASS="command"
>cp</B
>. We already know that <B
CLASS="command"
>cat</B
> is
      part of GNU's textutils. Using the next few commands as keywords in a
      manpage search we discover that we need GNU's fileutils package for
      <B
CLASS="command"
>chmod</B
>, <B
CLASS="command"
>chgrp</B
>,
      <B
CLASS="command"
>chown</B
> and <B
CLASS="command"
>cp</B
>. In fact quite a few
      of the commands in <TT
CLASS="filename"
>/bin</TT
> come from GNU's fileutils.
      The <B
CLASS="command"
>date</B
> command also comes from a GNU package called
      sh-utils. So a good way to tackle the problem of finding source code
      might be to group the commands together by package as shown
      below.</P
><P
></P
><UL
><LI
><P
>The BASH shell -- <B
CLASS="command"
>echo</B
>,
          <B
CLASS="command"
>false</B
>, <B
CLASS="command"
>pwd</B
>,
          <B
CLASS="command"
>sh</B
>, <B
CLASS="command"
>true</B
></P
></LI
><LI
><P
>GNU textutils -- <B
CLASS="command"
>cat</B
></P
></LI
><LI
><P
>GNU fileutils -- <B
CLASS="command"
>chgrp</B
>,
          <B
CLASS="command"
>chmod</B
>, <B
CLASS="command"
>chown</B
>,
          <B
CLASS="command"
>cp</B
>, <B
CLASS="command"
>dd</B
>, <B
CLASS="command"
>df</B
>,
          <B
CLASS="command"
>ln</B
>, <B
CLASS="command"
>ls</B
>,
          <B
CLASS="command"
>mkdir</B
>, <B
CLASS="command"
>mknod</B
>,
          <B
CLASS="command"
>mv</B
>, <B
CLASS="command"
>rm</B
>,
          <B
CLASS="command"
>rmdir</B
>, <B
CLASS="command"
>sync</B
></P
></LI
><LI
><P
>GNU sh-utils -- <B
CLASS="command"
>date</B
>,
          <B
CLASS="command"
>hostname</B
>, <B
CLASS="command"
>stty</B
>,
          <B
CLASS="command"
>su</B
>, <B
CLASS="command"
>uname</B
></P
></LI
></UL
><P
>These four packages do not contain all of the commands in the
      <TT
CLASS="filename"
>/bin</TT
> directory, but they do represent of over 70%
      of them. That should be enough to accomplish our goal of adding some of
      the commonly used external commands. We can worry about the other
      commands in later phases of the project.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN576"
></A
>4.2.4. Downloading Source Code</H2
><P
>To fetch the source code we simply need to connect to <A
HREF="ftp://ftp.gnu.org/gnu"
TARGET="_top"
>GNU's FTP site</A
> and navigate to the
      appropriate package directory.</P
><P
>When we get to the directory for textutils there are several
      versions available. There is also a note informing us that the package
      has been renamed to coreutils. The same message about coreutils appears
      in the fileutils and sh-utils directories as well. So instead of
      downloading three separate packages we can get everything in one
      convenient bundle in the coreutils directory.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN581"
></A
>4.3. Construction</H1
><P
>Rather than copying files directly to the ramdisk, we can make
    things easier by setting up a staging area. The staging area will give us
    room to work without worrying about the space constraints of the ramdisk.
    It will also provide a way to save our work and make it easier to enhance
    the rootdisk in later phases of the project.</P
><P
>The staging procedure will work like this:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Create a directory structure as defined in the FHS.</P
></LI
><LI
><P
>Copy in the files from phase 2's root disk.</P
></LI
><LI
><P
>Build the new package from source code.</P
></LI
><LI
><P
>Install files into the correct FHS directories.</P
></LI
><LI
><P
>Strip the binaries to save space.</P
></LI
><LI
><P
>Check library dependencies.</P
></LI
><LI
><P
>Copy to the whole directory structure to the ramdisk.</P
></LI
><LI
><P
>Compress the ramdisk and write it out to floppy.</P
></LI
></OL
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN602"
></A
>4.3.1. Create a staging area</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> mkdir ~/staging
<TT
CLASS="prompt"
>bash#</TT
> cd ~/staging
<TT
CLASS="prompt"
>bash#</TT
> mkdir bin boot dev etc home lib mnt opt proc root sbin tmp usr var
<TT
CLASS="prompt"
>bash#</TT
> mkdir var/log var/run</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN610"
></A
>4.3.2. Copy contents of phase 2 rootdisk</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> dd if=~/phase2-image.gz | gunzip -c &#62; /dev/ram7
<TT
CLASS="prompt"
>bash#</TT
> mount /dev/ram7 /mnt
<TT
CLASS="prompt"
>bash#</TT
> cp -dpR /mnt/* ~/staging
<TT
CLASS="prompt"
>bash#</TT
> umount /dev/ram7
<TT
CLASS="prompt"
>bash#</TT
> rmdir ~/staging/lost+found</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN619"
></A
>4.3.3. Install binaries from GNU coreutils</H2
><P
>Download a recent version of coreutils from <A
HREF="ftp://ftp.gnu.org/gnu/coreutils/"
TARGET="_top"
>ftp://ftp.gnu.org/gnu/coreutils/</A
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd /usr/src/coreutils-5.2.1
<TT
CLASS="prompt"
>bash#</TT
> export CC="gcc -mcpu=i386"
<TT
CLASS="prompt"
>bash#</TT
> ./configure --host=i386-pc-linux-gnu
<TT
CLASS="prompt"
>bash#</TT
> make
<TT
CLASS="prompt"
>bash#</TT
> cd src
<TT
CLASS="prompt"
>bash#</TT
> cp cat chgrp chmod chown cp date dd df ~/staging/bin
<TT
CLASS="prompt"
>bash#</TT
> cp hostname ln ls mkdir mkfifo mknod ~/staging/bin
<TT
CLASS="prompt"
>bash#</TT
> cp mv rm rmdir stty su sync uname ~/staging/bin</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN633"
></A
>4.3.4. Copy additional libraries</H2
><P
>Check library requirements by using <B
CLASS="command"
>ldd</B
> on some
      of the new binaries.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> ldd ~/staging/bin/cat
<TT
CLASS="prompt"
>bash#</TT
> ldd ~/staging/bin/ls
<TT
CLASS="prompt"
>bash#</TT
> ldd ~/staging/bin/su
<TT
CLASS="prompt"
>bash#</TT
> ls ~/staging/lib
</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Note the differences in the required libraries, as shown by the
      <B
CLASS="command"
>ldd</B
> command, and the libraries present in the staging
      area, as shown by the <B
CLASS="command"
>ls</B
> command, then copy any
      missing libraries to the staging area.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cp /lib/librt.so.1 ~/staging/lib
<TT
CLASS="prompt"
>bash#</TT
> cp /lib/libpthread.so.0 ~/staging/lib
<TT
CLASS="prompt"
>bash#</TT
> cp /lib/libcrypt.so.1 ~/staging/lib</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN651"
></A
>4.3.5. Strip binaries and libraries</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> strip ~/staging/bin/*
<TT
CLASS="prompt"
>bash#</TT
> strip --strip-unneeded ~/staging/lib/*</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN657"
></A
>4.3.6. Create a compressed root disk image</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd /
<TT
CLASS="prompt"
>bash#</TT
> dd if=/dev/zero of=/dev/ram7 bs=1k count=4096
<TT
CLASS="prompt"
>bash#</TT
> mke2fs -m0 /dev/ram7 4096
<TT
CLASS="prompt"
>bash#</TT
> mount /dev/ram7 /mnt
<TT
CLASS="prompt"
>bash#</TT
> cp -dpR ~/staging/* /mnt
<TT
CLASS="prompt"
>bash#</TT
> umount /dev/ram7
<TT
CLASS="prompt"
>bash#</TT
> dd if=/dev/ram7 of=~/phase3-image bs=1k count=4096
<TT
CLASS="prompt"
>bash#</TT
> gzip -9 ~/phase3-image</PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The process for creating the compressed root disk image will
          change very little throughout the remaining chapters. Writing a
          small script to handle this function can be a great time
          saver.</P
></TD
></TR
></TABLE
></DIV
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN671"
></A
>4.3.7. Write the root disk image to floppy</H2
><P
>Insert the diskette labeled "root disk" into drive fd0.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> dd if=~/phase3-image.gz of=/dev/fd0 bs=1k</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN677"
></A
>4.4. Implementation</H1
><P
>We will need to have a read-write filesystem in order for some of
    the commands to work. The kernel's normal behavior is to mount root as
    read-only, but we can change this using a kernel option. By passing the
    kernel the <TT
CLASS="parameter"
><I
>rw</I
></TT
> option before
    <TT
CLASS="parameter"
><I
>init=/bin/sh</I
></TT
> we will get a read-write root
    filesystem.</P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN682"
></A
>4.4.1. System startup</H2
><P
>Follow these steps to get the system running.</P
><P
></P
><UL
><LI
><P
>Boot the PC from using the GRUB boot disk.</P
></LI
><LI
><P
>At the <TT
CLASS="prompt"
>grub&#62;</TT
> prompt, type
          <TT
CLASS="userinput"
><B
>kernel (fd0)/boot/vmlinuz rw init=/bin/sh root=/dev/fd0
          load_ramdisk=1 prompt_ramdisk=1</B
></TT
>.</P
></LI
><LI
><P
>Verify that you remembered to add the
          <TT
CLASS="parameter"
><I
>rw</I
></TT
> parameter and press
          <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>Type boot and press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>Insert the recently created root disk when prompted.</P
></LI
></UL
><P
>The terminal display should look similar to the example
      below.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>GNU GRUB version 0.95

grub&#62; kernel (fd0)/boot/vmlinuz rw init=/bin/sh root=/dev/fd0 load_ramdisk=1 prompt_ramdisk=1
   [Linux-bzImage, setup=0xc00, size=0xce29b]

grub&#62; boot

Linux version 2.4.26
..
.. [various kernel messages]
..
VFS: Insert root floppy disk to be loaded into RAM disk and press ENTER
RAMDISK: Compressed image found at block 0
VFS: Mounted root (ext2 filesystem) read-write.
Freeing unused kernel memory: 178k freed
# _</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN704"
></A
>4.4.2. Testing new commands</H2
><P
>Now that the system is up and running, try using some of the new
      commands.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> uname -a
<TT
CLASS="prompt"
>bash#</TT
> ls /etc
<TT
CLASS="prompt"
>bash#</TT
> echo "PocketLinux" &#62; /etc/hostname
<TT
CLASS="prompt"
>bash#</TT
> hostname $(cat /etc/hostname)
<TT
CLASS="prompt"
>bash#</TT
> uname -n
<TT
CLASS="prompt"
>bash#</TT
> mkdir /home/stuff
<TT
CLASS="prompt"
>bash#</TT
> cd /home/stuff</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>If everything goes well the commands like <B
CLASS="command"
>cat</B
>,
      <B
CLASS="command"
>ls</B
> and <B
CLASS="command"
>hostname</B
> should work now.
      Even <B
CLASS="command"
>mkdir</B
> should work since the root filesystem is
      mounted read-write. Of course since we are using a ramdisk, any changes
      will be lost once the PC is reset.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN721"
></A
>4.4.3. System shutdown</H2
><P
>Remove the diskette from fd0 and restart the system using
      <B
CLASS="keycap"
>CTRL</B
>-<B
CLASS="keycap"
>ALT</B
>-<B
CLASS="keycap"
>DELETE</B
>.</P
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="phase4"
></A
>Chapter 5. Checking and Mounting Disks</H1
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="AEN729"
></A
>5.1. Analysis</H1
><P
>In the previous chapter we added many new commands by installing
    coreutils and as a result the root disk has a lot more functionality. But
    there are still a few things lacking. One thing that really stands out is
    that there was no way to mount disks. In order to get a read-write root
    filesystem we had to resort to passing the <TT
CLASS="parameter"
><I
>rw</I
></TT
>
    kernel parameter at the <TT
CLASS="prompt"
>grub&#62;</TT
> prompt. This is fine for
    an emergency situation, but a normal system boot process should do things
    differently.</P
><P
>Most GNU/Linux distributions take several steps to mount
    filesystems. Watching the boot process or digging into the startup scripts
    on one of the popular Linux distributions reveals the following sequence
    of events:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>The kernel automatically mounts the root filesystem as
        read-only.</P
></LI
><LI
><P
>All local filesystems are checked for errors.</P
></LI
><LI
><P
>If filesystems are clean, root is remounted as
        read-write.</P
></LI
><LI
><P
>The rest of the local filesystems are mounted.</P
></LI
><LI
><P
>Network filesystems are mounted.</P
></LI
></OL
><P
>So far our Pocket Linux system can do step one and that is it. If we
    want to have a professional looking boot / root diskset we will have to do
    better than one out of five. In this phase of the project we will work on
    steps two and three. Steps four and five can wait. Since this is a
    diskette-based system, there really are no other filesystems to mount
    besides root.</P
><P
>Taking into account all of the above information, the goals for this
    phase are defined as follows:</P
><P
></P
><UL
><LI
><P
>A way to check filesystem integrity.</P
></LI
><LI
><P
>The ability to mount filesystems.</P
></LI
><LI
><P
>A script to automate checking and mounting of local
        filesystems.</P
></LI
></UL
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN755"
></A
>5.2. Design</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN757"
></A
>5.2.1. Determining necessary utilities.</H2
><P
>We can use the Filesystem Hierarchy Standard (FHS) document to
      help find the names of utilities we need and where they reside in the
      directory structure. The FHS <TT
CLASS="filename"
>/sbin</TT
> directory lists
      <B
CLASS="command"
>fsck</B
> and something called <B
CLASS="command"
>fsck.*</B
>
      for checking filesystems. Since we are using a Second Extended (ext2)
      filesystem the <B
CLASS="command"
>fsck.*</B
> becomes
      <B
CLASS="command"
>fsck.ext2</B
> for our purposes. Mounting filesystems is
      done using the commands <B
CLASS="command"
>mount</B
> and
      <B
CLASS="command"
>umount</B
> in the <TT
CLASS="filename"
>/bin</TT
> directory.
      However, the name of a script to automatically mount local filesystems
      cannot be found. On most systems this type of script is in the
      <TT
CLASS="filename"
>/etc</TT
> directory, but while FHS does list
      requirements for <TT
CLASS="filename"
>/etc</TT
>, it does not currently make
      recommendations for startup scripts. Several GNU/Linux distributions use
      <TT
CLASS="filename"
>/etc/init.d</TT
> as the place to hold startup scripts so
      we will put our filesystem mounting script there.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN771"
></A
>5.2.2. Finding source code</H2
><P
>In the previous chapter we used manpages to help us find source
      code. In this chapter we will use a tool called the Linux Software Map
      (LSM). LSM is a database of GNU/Linux software that tracks such things
      as package name, author, names of binaries that make up the package and
      download sites. Using an LSM search engine we can locate packages using
      command names as keywords.</P
><P
>If we search Ibiblio's Linux Software Map (LSM) at <A
HREF="http://www.ibiblio.org/pub/Linux/"
TARGET="_top"
>http://www.ibiblio.org/pub/Linux/</A
>
      for the keyword "fsck" we get a large number of matches. Since we are
      using a Second Extended filesystem, called ext2 for short, we can refine
      the search using "ext2" as a keyword. Supplying both keywords to the LSM
      search engine comes up with a package called e2fsprogs. Looking at the
      LSM entry for e2fsprogs we find out that this package contains the
      utilities <B
CLASS="command"
>e2fsck</B
>, <B
CLASS="command"
>mke2fs</B
>,
      <B
CLASS="command"
>dumpe2fs</B
>, <B
CLASS="command"
>fsck</B
> and more. We also
      find out that the LSM entry for e2fsprogs has not been updated for a
      while. There is almost certainly a newer version out there somewhere.
      Another good Internet resource for source code is SourceForge at <A
HREF="http://sourceforge.net/"
TARGET="_top"
>http://sourceforge.net/</A
>. Using the
      keyword "e2fsprogs" in the SourceForge search engine results in a much
      newer version of e2fsprogs.</P
><P
>Finding <B
CLASS="command"
>fsck</B
> was quite an adventure, but now we
      can move on to finding <B
CLASS="command"
>mount</B
> and
      <B
CLASS="command"
>umount</B
>. A search on LSM comes up with a number of
      matches, but most of them point to various versions of a package called
      util-linux. All we have to do is scroll through and pick the most recent
      release. The LSM entry for util-linux lists a lot of utilities besides
      just mount and umount. We should definitely scan through the list to see
      if any of the other util-linux commands show up in the FHS requirements
      for <TT
CLASS="filename"
>/bin</TT
> and <TT
CLASS="filename"
>/sbin</TT
>.</P
><P
>Below is a list of packages we have gathered so far and the
      utilities that match up with FHS.</P
><P
></P
><UL
><LI
><P
>e2fsprogs -- <B
CLASS="command"
>fsck</B
>,
          <B
CLASS="command"
>fsck.ext2</B
> (<B
CLASS="command"
>e2fsck</B
>),
          <B
CLASS="command"
>mkfs.ext2</B
> (<B
CLASS="command"
>mke2fs</B
>)</P
></LI
><LI
><P
>util-linux -- <B
CLASS="command"
>dmesg</B
>,
          <B
CLASS="command"
>getty</B
> (<B
CLASS="command"
>agetty</B
>),
          <B
CLASS="command"
>kill</B
>, <B
CLASS="command"
>login</B
>,
          <B
CLASS="command"
>mount</B
>, <B
CLASS="command"
>swapon</B
>,
          <B
CLASS="command"
>umount</B
></P
></LI
></UL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN806"
></A
>5.2.3. Automating fsck and mount</H2
><P
>Now that we have <B
CLASS="command"
>fsck</B
> and
      <B
CLASS="command"
>mount</B
> commands we need to come up with a shell script
      to automate checking and mounting the local filesystems. An easy way to
      do this would be to write a short, two line script that calls
      <B
CLASS="command"
>fsck</B
> and then <B
CLASS="command"
>mount</B
>. But, what if
      the filesystems are not clean? The system should definitely not try to
      mount a corrupted filesystem. Therefore we need to devise a way of
      determining the status of the filesystems before mounting them. The
      manpage for <B
CLASS="command"
>fsck</B
> gives some insight into how this can
      be accomplished using return codes. Basically, if
      <B
CLASS="command"
>fsck</B
> returns a code of zero or one it means the
      filesystem is okay and a return code of two or greater means some kind
      of manual intervention is needed. A simple if-then statement could
      evaluate the <B
CLASS="command"
>fsck</B
> return code to determine whether or
      not the filesystem should be mounted. For help on writing shell scripts
      we can turn to the BASH(1) manpage and the
      Advanced-BASH-Scripting-Guide. Both references are freely available from
      the Linux Documentation Project web site at <A
HREF="http://www.tldp.org/"
TARGET="_top"
>http://www.tldp.org/</A
>.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN817"
></A
>5.2.4. File dependencies</H2
><P
>The last thing to do is to figure out if any other files besides
      the binaries are needed. We learned about using <B
CLASS="command"
>ldd</B
>
      to check for library dependencies in the last phase of the project and
      we will use it to check the utilities in this phase too. There are also
      some other files that <B
CLASS="command"
>fsck</B
> and
      <B
CLASS="command"
>mount</B
> will need and the fsck(8) and mount(8) manpages
      give some insight into what those files are. There is
      <TT
CLASS="filename"
>/etc/fstab</TT
> that lists devices and their mount
      points, <TT
CLASS="filename"
>/etc/mtab</TT
> that keeps track of what is
      mounted, and a number of <TT
CLASS="filename"
>/dev</TT
> files that represent
      the various disks. We will need to include all of these to have
      everything work right.</P
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN826"
></A
>5.2.4.1. /etc/fstab</H3
><P
>The <TT
CLASS="filename"
>/etc/fstab</TT
> file is just a simple text
        file that can be created with any editor. We will need an entry for
        the root filesystem and for the proc filesystem. Information about the
        format of this file can be found in the fstab(5) manpage or by looking
        at the <TT
CLASS="filename"
>/etc/fstab</TT
> file on any of the popular
        GNU/Linux distributions.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN831"
></A
>5.2.4.2. /etc/mtab</H3
><P
>The <TT
CLASS="filename"
>/etc/mtab</TT
> file presents a unique
        challenge, because it does not contain static information like
        <TT
CLASS="filename"
>fstab</TT
>. The <TT
CLASS="filename"
>mtab</TT
> file tracks
        mounted filesystems and therefore its contents change from time to
        time. We are particularly interested in the state of
        <TT
CLASS="filename"
>mtab</TT
> when the system first starts up, before any
        filesystems are mounted. At this point <TT
CLASS="filename"
>/etc/mtab</TT
>
        should be empty so we will need to configure a startup script to
        create an empty <TT
CLASS="filename"
>/etc/mtab</TT
> before any filesystems
        are mounted. But it is not possible to create any files in the
        <TT
CLASS="filename"
>/etc</TT
> directory because <TT
CLASS="filename"
>/</TT
> is
        read-only at startup. This creates a paradox. We cannot create an
        empty <TT
CLASS="filename"
>mtab</TT
>, because the <TT
CLASS="filename"
>/</TT
>
        filesystem is not mounted as writable and we should not mount any
        filesystems until we have created an empty <TT
CLASS="filename"
>mtab</TT
>.
        In order to sidestep this problem we need to do the following:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Remount <TT
CLASS="filename"
>/</TT
> as read-write, but use the
            <TT
CLASS="option"
>-n</TT
> option so that <B
CLASS="command"
>mount</B
> does
            not attempt to write an entry to <TT
CLASS="filename"
>/etc/mtab</TT
>
            which is read-only at this point.</P
></LI
><LI
><P
>Create an empty <TT
CLASS="filename"
>/etc/mtab</TT
> file now that
            the filesystem is writable.</P
></LI
><LI
><P
>Remount <TT
CLASS="filename"
>/</TT
> as read-write again, this
            time using the <TT
CLASS="option"
>-f</TT
> option so that an entry is
            written into <TT
CLASS="filename"
>/etc/mtab</TT
>, but
            <TT
CLASS="filename"
>/</TT
> is not actually mounted a second
            time.</P
></LI
></OL
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN861"
></A
>5.2.4.3. Device files</H3
><P
>The only thing left to do is to create device files. We will
        need <TT
CLASS="filename"
>/dev/ram0</TT
>, because that is where the root
        filesystem is located. We also need <TT
CLASS="filename"
>/dev/fd0</TT
> to
        mount other floppy disks and <TT
CLASS="filename"
>/dev/null</TT
> for use by
        some of the system commands.</P
></DIV
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN867"
></A
>5.3. Construction</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN869"
></A
>5.3.1. Install utilities from e2fsprogs</H2
><P
>Download the e2fsprogs source code package from <A
HREF="http://sourceforge.net/projects/e2fsprogs/"
TARGET="_top"
>http://sourceforge.net/projects/e2fsprogs/</A
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd /usr/src/e2fsprogs-1.35
<TT
CLASS="prompt"
>bash#</TT
> export CC="gcc -mcpu=i386"
<TT
CLASS="prompt"
>bash#</TT
> ./configure --host=i386-pc-linux-gnu
<TT
CLASS="prompt"
>bash#</TT
> make
<TT
CLASS="prompt"
>bash#</TT
> cd e2fsck
<TT
CLASS="prompt"
>bash#</TT
> cp e2fsck.shared ~/staging/sbin/e2fsck
<TT
CLASS="prompt"
>bash#</TT
> ln -s e2fsck ~/staging/sbin/fsck.ext2
<TT
CLASS="prompt"
>bash#</TT
> cd ../misc
<TT
CLASS="prompt"
>bash#</TT
> cp fsck mke2fs ~/staging/sbin
<TT
CLASS="prompt"
>bash#</TT
> ln -s mke2fs ~/staging/sbin/mkfs.ext2</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN885"
></A
>5.3.2. Install utilities from util-linux</H2
><P
>Get the latest util-linux source from <A
HREF="ftp://ftp.win.tue.nl/pub/linux-local/utils/util-linux/"
TARGET="_top"
>ftp://ftp.win.tue.nl/pub/linux-local/utils/util-linux/</A
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd /usr/src/util-linux-2.12h</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Use a text editor to make the following changes to
      <TT
CLASS="filename"
>MCONFIG</TT
>:</P
><P
></P
><UL
><LI
><P
>Change "CPU=$(shell uname -m)" to "CPU=i386"</P
></LI
><LI
><P
>Change "HAVE_SHADOW=yes" to "HAVE_SHADOW=no"</P
></LI
></UL
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> ./configure
<TT
CLASS="prompt"
>bash#</TT
> make
<TT
CLASS="prompt"
>bash#</TT
> cp disk-utils/mkfs ~/staging/sbin
<TT
CLASS="prompt"
>bash#</TT
> cp fdisk/fdisk ~/staging/sbin
<TT
CLASS="prompt"
>bash#</TT
> cp login-utils/agetty ~/staging/sbin
<TT
CLASS="prompt"
>bash#</TT
> ln -s agetty ~/staging/sbin/getty
<TT
CLASS="prompt"
>bash#</TT
> cp login-utils/login ~/staging/bin
<TT
CLASS="prompt"
>bash#</TT
> cp misc-utils/kill ~/staging/bin
<TT
CLASS="prompt"
>bash#</TT
> cp mount/mount ~/staging/bin
<TT
CLASS="prompt"
>bash#</TT
> cp mount/umount ~/staging/bin
<TT
CLASS="prompt"
>bash#</TT
> cp mount/swapon ~/staging/sbin
<TT
CLASS="prompt"
>bash#</TT
> cp sys-utils/dmesg ~/staging/bin</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN913"
></A
>5.3.3. Check library requirements</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> ldd ~/staging/bin/* | more
<TT
CLASS="prompt"
>bash#</TT
> ldd ~/staging/sbin/* | more
<TT
CLASS="prompt"
>bash#</TT
> ls ~/staging/lib</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>All of the dependencies revealed by the <B
CLASS="command"
>ldd</B
>
      command are for libraries already present in the staging area so there
      is no need to copy anything new.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN922"
></A
>5.3.4. Strip binaries to save space</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> strip ~/staging/bin/*
<TT
CLASS="prompt"
>bash#</TT
> strip ~/staging/sbin/*</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN928"
></A
>5.3.5. Create additional device files</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> mknod ~/staging/dev/ram0 b 1 0
<TT
CLASS="prompt"
>bash#</TT
> mknod ~/staging/dev/fd0 b 2 0
<TT
CLASS="prompt"
>bash#</TT
> mknod ~/staging/dev/null c 1 3</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN935"
></A
>5.3.6. Create the fstab and mtab files</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd ~/staging/etc
</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Use an editor like vi, emacs or pico to create the following file
      and save it as <TT
CLASS="filename"
>~/staging/etc/fstab</TT
>.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>proc        /proc   proc   defaults   0   0
/dev/ram0   /       ext2   defaults   1   1</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Create an empty mtab file.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> echo -n &#62;mtab</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN947"
></A
>5.3.7. Write a script to check and mount local filesystems</H2
><P
>Use an editor to create the following shell script and save it as
      <TT
CLASS="filename"
>~/staging/etc/init.d/local_fs</TT
>:</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>#!/bin/sh
#
# local_fs - check and mount local filesystems
#
PATH=/sbin:/bin ; export PATH

fsck -ATCp
if [ $? -gt 1 ]; then
  echo "Filesystem errors still exist!  Manual intervention required."
  /bin/sh
else
  echo "Remounting / as read-write."
  mount -n -o remount,rw /
  echo -n &#62;/etc/mtab
  mount -f -o remount,rw /
  echo "Mounting local filesystems."
  mount -a -t nonfs,nosmbfs
fi
#
# end of local_fs</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Set execute permissions on the script.<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> chmod +x local_fs</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN956"
></A
>5.3.8. Create a compressed root disk image</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd /
<TT
CLASS="prompt"
>bash#</TT
> dd if=/dev/zero of=/dev/ram7 bs=1k count=4096
<TT
CLASS="prompt"
>bash#</TT
> mke2fs -m0 /dev/ram7 4096
<TT
CLASS="prompt"
>bash#</TT
> mount /dev/ram7 /mnt
<TT
CLASS="prompt"
>bash#</TT
> cp -dpR ~/staging/* /mnt
<TT
CLASS="prompt"
>bash#</TT
> umount /dev/ram7
<TT
CLASS="prompt"
>bash#</TT
> dd if=/dev/ram7 of=~/phase4-image bs=1k count=4096
<TT
CLASS="prompt"
>bash#</TT
> gzip -9 ~/phase4-image</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN968"
></A
>5.3.9. Write the root disk image to floppy</H2
><P
>Insert the diskette labeled "root disk" into drive fd0.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> dd if=~/phase4-image.gz of=/dev/fd0 bs=1k</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN974"
></A
>5.4. Implementation</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN976"
></A
>5.4.1. System startup</H2
><P
>Start the system using the following procedure:</P
><P
></P
><UL
><LI
><P
>Boot the PC using the floppy labeled "boot disk".</P
></LI
><LI
><P
>At the <TT
CLASS="prompt"
>grub&#62;</TT
> prompt, type the usual kernel
          and boot commands, but without the <TT
CLASS="parameter"
><I
>rw</I
></TT
>
          parameter this time. In other words, type <TT
CLASS="userinput"
><B
>kernel
          (fd0)/boot/vmlinuz init=/bin/sh root=/dev/fd0 load_ramdisk=1
          prompt_ramdisk=1</B
></TT
>, press <B
CLASS="keycap"
>Enter</B
> then type
          <TT
CLASS="userinput"
><B
>boot</B
></TT
> and press <B
CLASS="keycap"
>Enter</B
>.</P
></LI
><LI
><P
>Put in the recently created root disk when prompted.</P
></LI
></UL
><P
>The output should resemble the example below:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>GNU GRUB version 0.95

grub&#62; kernel (fd0)/boot/vmlinuz init=/bin/sh root=/dev/fd0 load_ramdisk=1 prompt_ramdisk=1
   [Linux-bzImage, setup=0xc00, size=0xce29b]

grub&#62; boot

Linux version 2.4.26
..
.. [various kernel messages]
..
VFS: Insert root floppy disk to be loaded into RAM disk and press ENTER
RAMDISK: Compressed image found at block 0
VFS: Mounted root (ext2 filesystem) readonly.
Freeing unused kernel memory: 178k freed
# _</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN994"
></A
>5.4.2. Test the local_fs script</H2
><P
>Run the script by typing the following commands at the shell
      prompt:</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> PATH=/sbin:/bin:/etc/init.d ; export PATH
<TT
CLASS="prompt"
>bash#</TT
> cat /etc/mtab
<TT
CLASS="prompt"
>bash#</TT
> local_fs
<TT
CLASS="prompt"
>bash#</TT
> cat /etc/mtab
<TT
CLASS="prompt"
>bash#</TT
> df</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>If everything is working properly, then the screen output should
      look something like the example below.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
><TT
CLASS="prompt"
>bash#</TT
> PATH=/sbin:/bin:/etc/init.d ; export PATH
<TT
CLASS="prompt"
>bash#</TT
> cat /etc/mtab
<TT
CLASS="prompt"
>bash#</TT
> local_fs
/dev/ram0: clean 74/1024 files 3178/4096 blocks
Remounting / as read-write.
Mounting local filesystems.
<TT
CLASS="prompt"
>bash#</TT
> cat /etc/mtab
/dev/ram0 / ext2 rw 0 0
proc /proc proc rw 0 0
<TT
CLASS="prompt"
>bash#</TT
> df
Filesystem      1k-blocks       Used Available Use% Mounted on
/dev/ram0       3963            3045 918        77% /
</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1012"
></A
>5.4.3. Create and mount additional filesystems</H2
><P
>Procure a blank floppy disk and label it as "home". Remove the
      root disk floppy and insert the "home" diskette. Type the following
      commands:</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> mkfs -t ext2 /dev/fd0
<TT
CLASS="prompt"
>bash#</TT
> fsck /dev/fd0
<TT
CLASS="prompt"
>bash#</TT
> mount /dev/fd0 /home
<TT
CLASS="prompt"
>bash#</TT
> mkdir /home/floyd
<TT
CLASS="prompt"
>bash#</TT
> cd /home/floyd
<TT
CLASS="prompt"
>bash#</TT
> echo "Goodbye cruel world." &#62; goodbye.txt
<TT
CLASS="prompt"
>bash#</TT
> cat goodbye.txt</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1024"
></A
>5.4.4. System shutdown</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd /
<TT
CLASS="prompt"
>bash#</TT
> umount /home</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Remove the diskette from fd0 and restart the system using
      <B
CLASS="keycap"
>CTRL</B
>-<B
CLASS="keycap"
>ALT</B
>-<B
CLASS="keycap"
>DELETE</B
>.</P
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="phase5"
></A
>Chapter 6. Automating Startup &#38; Shutdown</H1
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="AEN1036"
></A
>6.1. Analysis</H1
><P
>The root disk from the last chapter is looking pretty good. It has
    about seventy percent of the commands that the Filesystem Hierarchy
    Standard (FHS) document requires for the root filesystem. Plus it has
    commands for checking and mounting filesystems. But even with all of this
    the root disk is far from perfect. The list below outlines three things
    that could use some improvement if the Pocket Linux system is to stand up
    next to the more professional looking distributions.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>The system currently requires the kernel parameters to be typed
        at the <TT
CLASS="prompt"
>grub&#62;</TT
> prompt in order to start properly. On
        any other GNU/Linux system this is only done in an emergency situation
        when the system is corrupted.</P
></LI
><LI
><P
>Checking and mounting the root filesystem has to be done
        manually by running a script at a shell prompt. On most modern
        operating systems this function is handled automatically as part of
        the system start-up process.</P
></LI
><LI
><P
>Using
        <B
CLASS="keycap"
>CTRL</B
>-<B
CLASS="keycap"
>ALT</B
>-<B
CLASS="keycap"
>DELETE</B
> for
        system shutdown is not very graceful. Filesystems should be unmounted
        and cached information should be flushed prior to shutdown. Again,
        this is something that most operating systems handle
        automatically.</P
></LI
></OL
><P
>Taking the above list into consideration, the goals for this phase
    are defined as follows:</P
><P
></P
><UL
><LI
><P
>Kernel loads without manual intervention.</P
></LI
><LI
><P
>Automated system start-up sequence.</P
></LI
><LI
><P
>Graceful shutdown capability.</P
></LI
></UL
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN1058"
></A
>6.2. Design</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN1060"
></A
>6.2.1. Determining necessary utilities</H2
><P
>Loading the kernel without manually typing parameters is easy to
      do if we read the grub info page. According to the section entitled
      "configuration" all of the commands used for booting can be put in a
      file called <TT
CLASS="filename"
>menu.lst</TT
> and placed in the
      <TT
CLASS="filename"
>/boot/grub</TT
> directory.</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Be sure to type the <TT
CLASS="filename"
>menu.lst</TT
> filename
        correctly with a lowercase L after the dot and not a number
        one.</P
></TD
></TR
></TABLE
></DIV
><P
>To automate system start-up we will need an init daemon. We know
      this because the Bootdisk-HOWTO and From-Powerup-To-BASH-Prompt-HOWTO
      both make mention of <B
CLASS="command"
>init</B
> as the first program to
      start after the kernel loads. The latter HOWTO also goes into some
      detail about the <TT
CLASS="filename"
>/etc/inittab</TT
> file and the
      organization of startup scripts. This could be helpful since FHS, the
      blueprint we have used so far, makes no recommendation for init
      scripts.</P
><P
>We will also need to find the <B
CLASS="command"
>shutdown</B
> command
      to fulfill the second goal of graceful shutdown capability.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1073"
></A
>6.2.2. Obtaining source code</H2
><P
>Searching the Linux Software Map on Ibiblio for the keyword "init"
      gives a large number of results. From reading the
      From-Powerup-To-BASH-Prompt-HOWTO however, we know that most Linux
      systems use a System V style init daemon. Narrowing the search with the
      additional key phrase of "System V" gives much better results. The
      sysvinit package contains <B
CLASS="command"
>init</B
>,
      <B
CLASS="command"
>shutdown</B
>, <B
CLASS="command"
>halt</B
> and
      <B
CLASS="command"
>reboot</B
> which is everything we need. The version
      listed in the LSM entry looks to be pretty old, but there is a
      primary-site URL that will probably lead to the latest version.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1080"
></A
>6.2.3. Checking dependencies</H2
><P
>The manpage for <B
CLASS="command"
>init</B
> mentions a FIFO called
      <TT
CLASS="filename"
>/dev/initctl</TT
> that is required for
      <B
CLASS="command"
>init</B
> to communicate with other programs in the
      sysvinit package. We will have to create this file for
      <B
CLASS="command"
>init</B
> to function properly.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1087"
></A
>6.2.4. Designing a simple GRUB configuration file.</H2
><P
>Using a GRUB configuration file is slightly more complex than
      specifying the bootloader commands manually. There are directives for
      features like menus, default selections and timeouts that need to be
      specified in the configuration file as well as the familiar kernel
      loading command. The info page for GRUB gives much of the necessary
      information. We may also be able to use the GRUB configuration file on
      the development system as a template. However, there is some
      inconsistency between vendors as to the name and location of the file.
      Regardless of what the path is on the development system it should be
      <TT
CLASS="filename"
>/boot/grub/menu.lst</TT
> on the Pocket Linux
      System.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1091"
></A
>6.2.5. Outlining start-up scripts</H2
><P
>Many of the popular GNU/Linux distributions use System V style
      init scripts. Since we are using a "sysvinit" daemon it makes sense to
      use System V style scripts as well. The following documents all touch
      upon the System V style init scripts in some way and will serve as
      references when building the scripts for this project:</P
><P
></P
><UL
><LI
><P
>The Debian Policy Manual -- available online at <A
HREF="http://www.debian.org/doc/debian-policy"
TARGET="_top"
>http://www.debian.org/doc/debian-policy</A
>.</P
></LI
><LI
><P
>The Linux Standard Base specification -- downloadable in many
          formats from <A
HREF="http://www.linuxbase.org/spec/index.shtml"
TARGET="_top"
>http://www.linuxbase.org/spec/index.shtml</A
>.</P
></LI
><LI
><P
>Essential System Administration, 3rd Edition by Aeleen Frisch
          -- available at libraries, bookstores or directly from O'Reilly
          Publishing at <A
HREF="http://www.oreilly.com/"
TARGET="_top"
>http://www.oreilly.com/</A
>.</P
></LI
></UL
><P
>After glancing at one or two of the above references we should
      have a pretty good idea of how the System V style system initialization
      process works. We should also know what it takes to create System V
      style init scripts for the Pocket Linux project. Below is a brief list
      of what needs to be done:</P
><P
></P
><UL
><LI
><P
>Create an <TT
CLASS="filename"
>inittab</TT
> file to call an
          <TT
CLASS="filename"
>rc</TT
> script with a numerical argument giving the
          runlevel.</P
></LI
><LI
><P
>Write an <TT
CLASS="filename"
>rc</TT
> script that uses the runlevel
          argument to execute the appropriate "K" and "S" scripts.</P
></LI
><LI
><P
>Modify the previously built <TT
CLASS="filename"
>local_fs</TT
>
          script to take <TT
CLASS="parameter"
><I
>start</I
></TT
> and
          <TT
CLASS="parameter"
><I
>stop</I
></TT
> arguments.</P
></LI
><LI
><P
>Create new scripts for <TT
CLASS="filename"
>shutdown</TT
> and
          <TT
CLASS="filename"
>reboot</TT
>.</P
></LI
><LI
><P
>Set up <TT
CLASS="filename"
>/etc/rcN.d</TT
> directories and links
          to scripts in <TT
CLASS="filename"
>/etc/init.d</TT
>.</P
></LI
></UL
><P
>As always, the BASH(1) manpage and the Advanced BASH Scripting
      Guide are very helpful for writing and understanding shell
      scripts.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN1127"
></A
>6.3. Construction</H1
><P
>There is a lot of typing to do in this section because of all of the
    start-up scripts that need to be created. Using a mouse to copy the text
    from this guide and paste it into a text editor can be a great time saving
    tool.</P
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1130"
></A
>6.3.1. Create a GRUB configuration file</H2
><P
>Insert and mount the floppy labeled "boot disk".</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> mount /dev/fd0 /mnt
<TT
CLASS="prompt"
>bash#</TT
> cd /mnt/boot/grub</PRE
></FONT
></TD
></TR
></TABLE
><P
>Use your favorite text editor to create the following file and
      save it as /mnt/boot/grub/menu.lst:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>default 0
timeout 3
title Pocket Linux Boot Disk
kernel (fd0)/boot/vmlinuz root=/dev/fd0 load_ramdisk=1 prompt_ramdisk=1</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1138"
></A
>6.3.2. Install sysvinit utilities</H2
><P
>Download the latest sysvinit source from <A
HREF="ftp://ftp.cistron.nl/pub/people/miquels/software/"
TARGET="_top"
>ftp://ftp.cistron.nl/pub/people/miquels/software/</A
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd /usr/src/sysvinit-2.85/src
<TT
CLASS="prompt"
>bash#</TT
> make CC="gcc -mcpu=i386"
<TT
CLASS="prompt"
>bash#</TT
> cp halt init shutdown ~/staging/sbin
<TT
CLASS="prompt"
>bash#</TT
> ln -s halt ~/staging/sbin/reboot
<TT
CLASS="prompt"
>bash#</TT
> ln -s init ~/staging/sbin/telinit
<TT
CLASS="prompt"
>bash#</TT
> mknod ~/staging/dev/initctl p</PRE
></FONT
></TD
></TR
></TABLE
></P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>In the interest of speed we are skipping the steps for checking
        libraries and stripping binaries. The library requirements for
        sysvinit are very basic and the Makefile is configured to
        automatically strip the binaries.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1152"
></A
>6.3.3. Create /etc/inittab file</H2
><P
>Use a text editor to create the following file and save it as
      <TT
CLASS="filename"
>~/staging/etc/inittab</TT
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
># /etc/inittab - init daemon configuration file
#
# Default runlevel
id:1:initdefault:
#
# System initialization
si:S:sysinit:/etc/init.d/rc S
#
# Runlevel scripts
r0:0:wait:/etc/init.d/rc 0
r1:1:respawn:/bin/sh
r2:2:wait:/etc/init.d/rc 2
r3:3:wait:/etc/init.d/rc 3
r4:4:wait:/etc/init.d/rc 4
r5:5:wait:/etc/init.d/rc 5
r6:6:wait:/etc/init.d/rc 6
#
# end of /etc/inittab</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1158"
></A
>6.3.4. Create /etc/init.d/rc script</H2
><P
>Use a text editor to create the following file and save it as
      <TT
CLASS="filename"
>~/staging/etc/init.d/rc</TT
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>#!/bin/sh
#
# /etc/init.d/rc - runlevel change script
#
PATH=/sbin:/bin
SCRIPT_DIR="/etc/rc$1.d"
#
# Check that the rcN.d directory really exists.
if [ -d $SCRIPT_DIR ]; then
#
# Execute the kill scripts first.
  for SCRIPT in $SCRIPT_DIR/K*; do
    if [ -x $SCRIPT ]; then
      $SCRIPT stop;
    fi;
  done;
#
# Do the Start scripts last.
  for SCRIPT in $SCRIPT_DIR/S*; do
    if [ -x $SCRIPT ]; then
      $SCRIPT start;
    fi;
  done;
fi
#
# end of /etc/init.d/rc</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Make the file executable.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> chmod +x ~/staging/etc/init.d/rc</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1168"
></A
>6.3.5. Modify /etc/init.d/local_fs script</H2
><P
>A case statement is added to allow the script to either mount or
      unmount local filesystems depending on the command-line argument given.
      The original script is contained inside the "start" portion of the case
      statement. The "stop" portion is new.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>#!/bin/sh
#
# local_fs - check and mount local filesystems
#
PATH=/sbin:/bin ; export PATH

case $1 in

start)
  echo "Checking local filesystem integrity."
  fsck -ATCp
  if [ $? -gt 1 ]; then
    echo "Filesystem errors still exist!  Manual intervention required."
    /bin/sh
  else
    echo "Remounting / as read-write."
    mount -n -o remount,rw /
    echo -n &#62; /etc/mtab
    mount -f -o remount,rw /
    echo "Mounting local filesystems."
    mount -a -t nonfs,smbfs
  fi
;;

stop)
  echo "Unmounting local filesystems."
  umount -a -r
;;

*)
  echo "usage: $0 start|stop";
;;

esac
#
# end of local_fs</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1173"
></A
>6.3.6. Create a hostname script</H2
><P
>Use a text editor to create the following script and save it as
      <TT
CLASS="filename"
>~/staging/etc/init.d/hostname</TT
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>#!/bin/sh
#
# hostname - set the system name to the name stored in /etc/hostname
#
PATH=/sbin:/bin ; export PATH

echo "Setting hostname."
if [ -f /etc/hostname ]; then
  hostname $(cat /etc/hostname)
else
  hostname gnu-linux
fi
#
# end of hostname</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1179"
></A
>6.3.7. Create halt &#38; reboot scripts</H2
><P
>Use a text editor to create
      <TT
CLASS="filename"
>~/staging/etc/init.d/halt</TT
> as shown below.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>#!/bin/sh
#
# halt - halt the system
#
PATH=/sbin:/bin ; export PATH

echo "Initiating system halt."
halt
#
# end of /etc/init.d/halt</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Create the following script and save it as
      <TT
CLASS="filename"
>~/staging/etc/init.d/reboot</TT
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>#!/bin/sh
#
# reboot - reboot the system
#
PATH=/sbin:/bin ; export PATH

echo "Initiating system reboot."
reboot
#
# end of /etc/init.d/reboot</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Flag all script files as executable.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> chmod +x ~/staging/etc/init.d/*</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1193"
></A
>6.3.8. Create rcN.d directories and links</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd ~/staging/etc
<TT
CLASS="prompt"
>bash#</TT
> mkdir rc0.d rc1.d rc2.d rc3.d rc4.d rc5.d rc6.d rcS.d
<TT
CLASS="prompt"
>bash#</TT
> cd ~/staging/etc/rcS.d
<TT
CLASS="prompt"
>bash#</TT
> ln -s ../init.d/local_fs S20local_fs
<TT
CLASS="prompt"
>bash#</TT
> ln -s ../init.d/hostname S30hostname
<TT
CLASS="prompt"
>bash#</TT
> cd ~/staging/etc/rc0.d
<TT
CLASS="prompt"
>bash#</TT
> ln -s ../init.d/local_fs K10local_fs
<TT
CLASS="prompt"
>bash#</TT
> ln -s ../init.d/halt K90halt
<TT
CLASS="prompt"
>bash#</TT
> cd ~/staging/etc/rc6.d
<TT
CLASS="prompt"
>bash#</TT
> ln -s ../init.d/local_fs K10local_fs
<TT
CLASS="prompt"
>bash#</TT
> ln -s ../init.d/reboot K90reboot</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1208"
></A
>6.3.9. Create the root disk image</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd /
<TT
CLASS="prompt"
>bash#</TT
> dd if=/dev/zero of=/dev/ram7 bs=1k count=4096
<TT
CLASS="prompt"
>bash#</TT
> mke2fs -m0 /dev/ram7 4096
<TT
CLASS="prompt"
>bash#</TT
> mount /dev/ram7 /mnt
<TT
CLASS="prompt"
>bash#</TT
> cp -dpR ~/staging/* /mnt
<TT
CLASS="prompt"
>bash#</TT
> umount /dev/ram7
<TT
CLASS="prompt"
>bash#</TT
> dd if=/dev/ram7 of=~/phase5-image bs=1k
<TT
CLASS="prompt"
>bash#</TT
> gzip -9 ~/phase5-image</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1220"
></A
>6.3.10. Copy the image to diskette</H2
><P
>Insert the diskette labeled "root disk" into drive fd0.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> dd if=~/phase5-image.gz of=/dev/fd0 bs=1k</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN1226"
></A
>6.4. Implementation</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN1228"
></A
>6.4.1. System Startup</H2
><P
>Boot the PC using the floppy labeled "boot disk". Place the
      recently created root disk in fd0 when prompted. The output should
      resemble the example below:</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>GNU GRUB version 0.95

Uncompressing Linux... Ok, booting kernel.
..
.. [various kernel messages]
..
VFS: Insert root floppy to be loaded into RAM disk and press ENTER
RAMDISK: Compressed image found at block 0
VFS: Mounted root (ext2 filesystem) readonly.
Freeing unused kernel memory: 178k freed
Checking local filesystem integrity.
/dev/ram0: clean 105/1024 files 2842/4096 blocks
Remounting / as read-write.
Mounting local filesystems.
Setting the hostname.
INIT: Entering runlevel: 1
# _</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1233"
></A
>6.4.2. Verify success of startup scripts</H2
><P
>Use the <B
CLASS="command"
>mount</B
> command to check that local
      filesystems are mounted as read-write. The output should look like the
      example below.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
><TT
CLASS="prompt"
>bash#</TT
> mount
/dev/root on / type ext2 (rw)
proc on /proc type proc (rw)</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Check the hostname.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
><TT
CLASS="prompt"
>bash#</TT
> uname -n
gnu-linux</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1244"
></A
>6.4.3. System shutdown</H2
><P
>Bring the system down gracefully with the
      <B
CLASS="command"
>shutdown</B
> command.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> shutdown -h now</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>We should see the following output from <B
CLASS="command"
>init</B
>
      and the shutdown scripts:</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>INIT: Switching to runlevel: 0
INIT: Sending processes the TERM signal
Terminated
INIT: Sending processes the KILL signal
Unmounting local filesystems.
Initiating system halt.
System halted.</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="phase6"
></A
>Chapter 7. Enabling Multiple Users</H1
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="AEN1257"
></A
>7.1. Analysis</H1
><P
>Up to now the system has been operating in single-user mode. There
    is no login process and anyone who boots the system goes straight into a
    shell with root privileges. Obviously, this is not the normal operating
    mode for most GNU/Linux distributions. Most systems feature multi-user
    capability where many users can access the system simultaneously with
    different privilege levels. These multi-user systems also support virtual
    consoles so that the keyboard and video display can be multiplexed between
    several terminal sessions. So in this phase we would like to add the
    following enhancements to the system:</P
><P
></P
><UL
><LI
><P
>Enable multi-user capability.</P
></LI
><LI
><P
>Create multiple, virtual consoles.</P
></LI
></UL
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN1265"
></A
>7.2. Design</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN1267"
></A
>7.2.1. The login process</H2
><P
>The From-Powerup-To-BASH-Prompt-HOWTO does a good job of outlining
      the steps in the login process. Basically it works like this.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>The <B
CLASS="command"
>init</B
> daemon starts a
          <B
CLASS="command"
>getty</B
> process on the terminal.</P
></LI
><LI
><P
>The <B
CLASS="command"
>getty</B
> program displays the contents of
          <TT
CLASS="filename"
>/etc/issue</TT
> and prompts for a user name.</P
></LI
><LI
><P
>When the user name is entered, control is handed off to the
          <B
CLASS="command"
>login</B
> program.</P
></LI
><LI
><P
>The <B
CLASS="command"
>login</B
> program asks for a password and
          verifies the credentials using <TT
CLASS="filename"
>/etc/passwd</TT
>,
          <TT
CLASS="filename"
>/etc/group</TT
> and possibly
          <TT
CLASS="filename"
>/etc/shadow</TT
>.</P
></LI
><LI
><P
>If everything is okay the user's shell is started.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1290"
></A
>7.2.2. Obtaining source code</H2
><P
>The <B
CLASS="command"
>getty</B
> and <B
CLASS="command"
>login</B
> programs
      were already installed as part of the util-linux package so there is no
      need to download any new source code.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1295"
></A
>7.2.3. Creating support files</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN1297"
></A
>7.2.3.1. Device nodes</H3
><P
>Details about virtual console device files can be found in the
        Linux kernel source code file called <TT
CLASS="filename"
>devices.txt</TT
>
        in the <TT
CLASS="filename"
>Documentation</TT
> directory. We will need to
        create <TT
CLASS="filename"
>tty1</TT
> through <TT
CLASS="filename"
>tty6</TT
> for
        each of the virtual consoles as well as <TT
CLASS="filename"
>tty0</TT
> and
        <TT
CLASS="filename"
>tty</TT
> to represent the current virtual
        console.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN1306"
></A
>7.2.3.2. /etc/issue</H3
><P
>The <TT
CLASS="filename"
>/etc/issue</TT
> file is pretty easy to
        construct. It can contain any text we want displayed on the screen
        prior to the login prompt. It could be something friendly like
        "Welcome to Pocket Linux", something menacing like "Authorized users
        only!" or something informational like "Connected to tty1 at 9600bps".
        The agetty(8) manpage explains how to display information like tty
        line and baud rate using escape codes.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN1310"
></A
>7.2.3.3. /etc/passwd</H3
><P
>The format of <TT
CLASS="filename"
>/etc/passwd</TT
> can be obtained
        by reading the passwd(5) manpage. We can easily create a user account
        by adding a line like "root::0:0:superuser:/root:/bin/sh" to the
        file.</P
><P
>Maintaining passwords will be somewhat challenging because of
        the system being loaded into ramdisk. Any changes to
        <TT
CLASS="filename"
>/etc/passwd</TT
> will be lost when the system is
        shutdown. So to make things easy, we will create all users with null
        passwords.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN1316"
></A
>7.2.3.4. /etc/group</H3
><P
>The structure of <TT
CLASS="filename"
>/etc/group</TT
> is available
        from the group(5) manpage. A line of "root::0:root" would define a
        group called "root" with no password, a group id of zero and the user
        root assigned to it as the only member.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN1320"
></A
>7.2.3.5. Conventions</H3
><P
>User and group names and id's are generally not chosen at
        random. Most Linux systems have very similar looking
        <TT
CLASS="filename"
>/etc/passwd</TT
> and <TT
CLASS="filename"
>/etc/group</TT
>
        files. Definitions for commonly used user id and group id assignments
        may be found in one of several places:</P
><P
></P
><UL
><LI
><P
>The <TT
CLASS="filename"
>/etc/passwd</TT
> and
            <TT
CLASS="filename"
>/etc/group</TT
> files on any popular GNU/Linux
            distribution.</P
></LI
><LI
><P
>The Debian Policy Manual -- available online at <A
HREF="http://www.debian.org/doc/debian-policy"
TARGET="_top"
>http://www.debian.org/doc/debian-policy</A
>.</P
></LI
><LI
><P
>The Linux Standard Base specification -- downloadable in
            many formats from <A
HREF="http://www.linuxbase.org/spec/index.shtml"
TARGET="_top"
>http://www.linuxbase.org/spec/index.shtml</A
>.</P
></LI
><LI
><P
>Essential System Administration, 3rd Edition by Aeleen
            Frisch -- available at libraries, bookstores or directly from
            O'Reilly Publishing at <A
HREF="http://www.oreilly.com/"
TARGET="_top"
>http://www.oreilly.com/</A
>.</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1339"
></A
>7.2.4. Dependencies</H2
><P
>Running <B
CLASS="command"
>ldd</B
> on the <TT
CLASS="filename"
>login</TT
>
      program from util-linux will reveal that it is linked to the libraries
      <TT
CLASS="filename"
>libcrypt.so.1</TT
>, <TT
CLASS="filename"
>libc.so.6</TT
> and
      <TT
CLASS="filename"
>ld-linux.so.2</TT
>. In addition to these libraries there
      is another, unseen dependency on <TT
CLASS="filename"
>libnss_files.so.2</TT
>
      and the configuration file
      <TT
CLASS="filename"
>/etc/nsswitch.conf</TT
>.</P
><P
>The name service switch library
      <TT
CLASS="filename"
>libnss_files.so.2</TT
> and
      <TT
CLASS="filename"
>nsswitch.conf</TT
> are required for
      <TT
CLASS="filename"
>libc.so.6</TT
>, and consequently the
      <TT
CLASS="filename"
>login</TT
> program, to access the
      <TT
CLASS="filename"
>/etc/passwd</TT
> file. Without libnss and its
      configuration file, all logins will mysteriously fail. More information
      about glibc's use of the name service switch libraries can be found at
      <A
HREF="http://www.gnu.org/software/libc/manual/html_node/Name-Service-Switch.html"
TARGET="_top"
>http://www.gnu.org/software/libc/manual/html_node/Name-Service-Switch.html</A
>.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1356"
></A
>7.2.5. Assigning ownership and permissions</H2
><P
>Previously, with the single user system, there was no need to
      worry about permissions when installing directories, files and device
      nodes. The shell was effectively operating as root, so everything was
      accessible. Things become more complex with the addition of multiple
      user capability. Now we need to make sure that every user has access to
      what they need and at the same time gets blocked from what they do not
      need.</P
><P
>A good guideline for assigning ownership and permissions would be
      to give the minimum level of access required. Take the
      <TT
CLASS="filename"
>/bin</TT
> directory as an example. The Filesystem
      Hierarchy (FHS) document says, "<TT
CLASS="filename"
>/bin</TT
> contains
      commands that may be used by both the system administrator and by
      users". From that statement we can infer that <TT
CLASS="filename"
>/bin</TT
>
      should have read and execute permission for everyone. On the other hand,
      the <TT
CLASS="filename"
>/boot</TT
> directory contains files for the boot
      loader. Chances are good that regular users will not need to access
      anything in the <TT
CLASS="filename"
>/boot</TT
> directory. So the minimum
      level of access would be read permission for the root user and other
      administrators who are members of the root group. Normal users would
      have no permissions assigned on the <TT
CLASS="filename"
>/boot</TT
>
      directory.</P
><P
>Most of the time we can assign similar permissions to all the
      commands in a directory, but there are some programs that prove to be
      exceptions to the rule. The <B
CLASS="command"
>su</B
> command is a good
      example. Other commands in the /bin directory have a minimum requirement
      of read and execute, but the <B
CLASS="command"
>su</B
> command needs to be
      setuid root in order to run correctly. Since it is a setuid binary, it
      might not be a good idea to allow just anyone to run it. Ownership of
      0:0 (root user, root group) and permissions of rwsr-x--- (octal 4750)
      would be a good fit for <B
CLASS="command"
>su</B
>.</P
><P
>The same logic can be applied to other directories and files in
      the root filesystem using the following steps:</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Assign ownership to the root user and root group.</P
></LI
><LI
><P
>Set the most restrictive permissions possible.</P
></LI
><LI
><P
>Adjust ownership and permissions on an "as needed"
          basis.</P
></LI
></OL
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN1378"
></A
>7.3. Construction</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN1380"
></A
>7.3.1. Verify presence of getty and login</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> ls ~/staging/sbin/getty
<TT
CLASS="prompt"
>bash#</TT
> ls ~/staging/bin/login</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1386"
></A
>7.3.2. Modify inittab for multi-user mode</H2
><P
>Modify <TT
CLASS="filename"
>~/staging/etc/inittab</TT
> by changing the
      default runlevel and adding <B
CLASS="command"
>getty</B
> entries as shown
      below.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
># /etc/inittab - init daemon configuration file
#
# Default runlevel
id:2:initdefault:
#
# System initialization
si:S:sysinit:/etc/init.d/rc S
#
# Runlevel scripts
r0:0:wait:/etc/init.d/rc 0
r1:1:respawn:/bin/sh
r2:2:wait:/etc/init.d/rc 2
r3:3:wait:/etc/init.d/rc 3
r4:4:wait:/etc/init.d/rc 4
r5:5:wait:/etc/init.d/rc 5
r6:6:wait:/etc/init.d/rc 6
#
# Spawn virtual terminals
1:235:respawn:/sbin/getty 38400 tty1 linux
2:235:respawn:/sbin/getty 38400 tty2 linux
3:235:respawn:/sbin/getty 38400 tty3 linux
4:235:respawn:/sbin/getty 38400 tty4 linux
5:235:respawn:/sbin/getty 38400 tty5 linux
6:2345:respawn:/sbin/getty 38400 tty6 linux
#
# end of /etc/inittab</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1393"
></A
>7.3.3. Create tty devices</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd ~/staging/dev
<TT
CLASS="prompt"
>bash#</TT
> mknod ~/staging/dev/tty0 c 4 0
<TT
CLASS="prompt"
>bash#</TT
> mknod ~/staging/dev/tty1 c 4 1
<TT
CLASS="prompt"
>bash#</TT
> mknod ~/staging/dev/tty2 c 4 2
<TT
CLASS="prompt"
>bash#</TT
> mknod ~/staging/dev/tty3 c 4 3
<TT
CLASS="prompt"
>bash#</TT
> mknod ~/staging/dev/tty4 c 4 4
<TT
CLASS="prompt"
>bash#</TT
> mknod ~/staging/dev/tty5 c 4 5
<TT
CLASS="prompt"
>bash#</TT
> mknod ~/staging/dev/tty6 c 4 6
<TT
CLASS="prompt"
>bash#</TT
> mknod ~/staging/dev/tty c 5 0</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1406"
></A
>7.3.4. Create support files in /etc</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN1408"
></A
>7.3.4.1. /etc/issue</H3
><P
>Create the file <TT
CLASS="filename"
>~/staging/etc/issue</TT
> using
        the example below or design a customized message.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>Connected to \l at \b bps.</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Be sure that "\l" is a lowercase letter L and not the number
        one.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN1415"
></A
>7.3.4.2. /etc/passwd</H3
><P
>Use a text editor to create a minimal passwd file conforming to
        the Linux Standards Base (LSB) document. Save the file as
        <TT
CLASS="filename"
>~/staging/etc/passwd</TT
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>root::0:0:Super User:/root:/bin/sh
bin:x:1:1:Legacy UID:/bin:/bin/false
daemon:x:2:2:Legacy UID:/sbin:/bin/false</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN1421"
></A
>7.3.4.3. /etc/group</H3
><P
>Use a text editor to create an LSB conforming group file and
        save it as <TT
CLASS="filename"
>~/staging/etc/group</TT
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>root::0:root
bin:x:1:root,bin,daemon
daemon:x:2:root,bin,daemon</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN1427"
></A
>7.3.4.4. /etc/nsswitch.conf</H3
><P
>Create the following file and save it as
        <TT
CLASS="filename"
>~/staging/etc/nsswitch.conf</TT
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>passwd: files
group:  files</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1433"
></A
>7.3.5. Copy required libraries</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cp /lib/libnss_files.so.2 ~/staging/lib
bash# strip --strip-unneeded ~/staging/lib/*</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1438"
></A
>7.3.6. Set directory and file permissions</H2
><P
>Set minimal privileges on all files and directories under
      <TT
CLASS="filename"
>~/staging</TT
>. Everything is owned by the root user and
      the root group. Permissions are read-write for the owner and read-only
      for the group. Exceptions to the blanket permissions are handled case by
      case.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd ~/staging
<TT
CLASS="prompt"
>bash#</TT
> chown -R 0:0 ~/staging/*
<TT
CLASS="prompt"
>bash#</TT
> chmod -R 640 ~/staging/*</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Set execute permission on all directories. (Note the capital
      "X")</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> chmod -R +X ~/staging/*</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Files in <TT
CLASS="filename"
>/bin</TT
> are read and execute for all,
      but <TT
CLASS="filename"
>su</TT
> is an exception.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> chmod 755 ~/staging/bin/*
<TT
CLASS="prompt"
>bash#</TT
> chmod 4750 ~/staging/bin/su</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Files in <TT
CLASS="filename"
>/dev</TT
> have various permissions. Disk
      devices should be accessible to administrators only. Other files like
      <TT
CLASS="filename"
>/dev/null</TT
> should have full privileges granted to
      everyone.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> chmod 660 ~/staging/dev/fd0 dev/ram0
<TT
CLASS="prompt"
>bash#</TT
> chmod 666 ~/staging/dev/null
<TT
CLASS="prompt"
>bash#</TT
> chmod 622 ~/staging/dev/console
<TT
CLASS="prompt"
>bash#</TT
> chmod 600 ~/staging/dev/initctl
<TT
CLASS="prompt"
>bash#</TT
> chmod 622 ~/staging/dev/tty
<TT
CLASS="prompt"
>bash#</TT
> chmod 622 ~/staging/dev/tty?</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>The <TT
CLASS="filename"
>passwd</TT
> and <TT
CLASS="filename"
>group</TT
>
      files must be world readable.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> chmod 644 ~/staging/etc/passwd
<TT
CLASS="prompt"
>bash#</TT
> chmod 644 ~/staging/etc/group</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>The scripts in <TT
CLASS="filename"
>/etc/init.d</TT
> are read and
      execute for administrators.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> chmod 750 ~/staging/etc/init.d/*</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Libraries need read and execute permissions for everyone.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> chmod 755 ~/staging/lib/*</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Only root should have access to the <TT
CLASS="filename"
>/root</TT
>
      directory.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> chmod 700 ~/staging/root</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Make files in <TT
CLASS="filename"
>/sbin</TT
> read and execute for
      administrators.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> chmod 750 ~/staging/sbin/*</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Temp should be read-write for all with the sticky bit set.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> chmod 1777 ~/staging/tmp</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1499"
></A
>7.3.7. Create the root disk image</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd /
<TT
CLASS="prompt"
>bash#</TT
> dd if=/dev/zero of=/dev/ram7 bs=1k count=4096
<TT
CLASS="prompt"
>bash#</TT
> mke2fs -m0 /dev/ram7 4096
<TT
CLASS="prompt"
>bash#</TT
> mount /dev/ram7 /mnt
<TT
CLASS="prompt"
>bash#</TT
> cp -dpR ~/staging/* /mnt
<TT
CLASS="prompt"
>bash#</TT
> umount /dev/ram7
<TT
CLASS="prompt"
>bash#</TT
> dd if=/dev/ram7 of=~/phase6-image bs=1k count=4096
<TT
CLASS="prompt"
>bash#</TT
> gzip -9 ~/phase6-image</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1511"
></A
>7.3.8. Copy the image to diskette</H2
><P
>Insert the diskette labeled "root disk" into drive fd0.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> dd if=~/phase6-image.gz of=/dev/fd0 bs=1k</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN1517"
></A
>7.4. Implementation</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN1519"
></A
>7.4.1. System Startup</H2
><P
>If everything goes well, the virtual console display should look
      similar to the following example:</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>Connected to tty1 at 38400 bps.
gnu-linux login:</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1524"
></A
>7.4.2. Add a new user to the system</H2
><P
>Log in as root.</P
><P
>Create a new, unprivileged user and new group by appending a line
      to the <TT
CLASS="filename"
>/etc/passwd</TT
> and
      <TT
CLASS="filename"
>/etc/group</TT
> files, respectively. Be sure to use a
      double greater-than (&#62;&#62;) to avoid accidentally overwriting the
      files.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> echo "floyd::501:500:User:/home/floyd:/bin/sh" &#62;&#62;/etc/passwd
<TT
CLASS="prompt"
>bash#</TT
> echo "users::500:" &#62;&#62;/etc/group
<TT
CLASS="prompt"
>bash#</TT
> mkdir /home/floyd
<TT
CLASS="prompt"
>bash#</TT
> chown floyd.users /home/floyd
<TT
CLASS="prompt"
>bash#</TT
> chmod 700 /home/floyd</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1537"
></A
>7.4.3. Test the new user's ability to use the system</H2
><P
>Switch to virtual terminal tty2 by pressing
      <B
CLASS="keycap"
>ALT</B
>+<B
CLASS="keycap"
>F2</B
>.</P
><P
>Log in as floyd.</P
><P
>Try the following commands and verify that they work.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash$</TT
> pwd
<TT
CLASS="prompt"
>bash$</TT
> ls -l /
<TT
CLASS="prompt"
>bash$</TT
> cat /etc/passwd</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Try the following commands and verify that they do not
      work.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash$</TT
> ls /root
<TT
CLASS="prompt"
>bash$</TT
> /sbin/shutdown -h now
<TT
CLASS="prompt"
>bash$</TT
> su -</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1555"
></A
>7.4.4. System shutdown</H2
><P
>Switch back to tty1 where root is logged in.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> shutdown -h now</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="phase7"
></A
>Chapter 8. Filling in the Gaps</H1
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="AEN1563"
></A
>8.1. Analysis</H1
><P
>The root disk has come a long way since its humble beginnings as a
    statically-linked shell. It now shares many features with the popular,
    ready-made distributions. For example it has:</P
><P
></P
><UL
><LI
><P
>Several common utilities like <B
CLASS="command"
>cat</B
>,
        <B
CLASS="command"
>ls</B
> and so on.</P
></LI
><LI
><P
>Startup scripts that automatically check and mount
        filesystems.</P
></LI
><LI
><P
>Graceful shutdown capability.</P
></LI
><LI
><P
>Support for multiple users and virtual terminals.</P
></LI
></UL
><P
>As a final test, we can put the root disk up against the Filesystem
    Hierarchy Standard (FHS) requirements for the root filesystem. (We will
    ignore anything in the <TT
CLASS="filename"
>/usr</TT
> hierarchy because of
    space constraints.) Compared to FHS requirement, the only files missing
    are a few commands in the <TT
CLASS="filename"
>/bin</TT
> directory.
    Specifically, the root disk lacks the following commands:</P
><P
></P
><UL
><LI
><P
><B
CLASS="command"
>more</B
></P
></LI
><LI
><P
><B
CLASS="command"
>ps</B
></P
></LI
><LI
><P
><B
CLASS="command"
>sed</B
></P
></LI
></UL
><P
>In addition to the required commands, it might be nice to include
    the "ed" editor listed as an option by the FHS. It is not as robust as vi
    or emacs, but it works and it should fit onto the tiny root
    filesystem.</P
><P
>So in order to finish up this phase of the project, we need to
    accomplish the following goals:</P
><P
></P
><UL
><LI
><P
>Add the <B
CLASS="command"
>more</B
>, <B
CLASS="command"
>ps</B
> and
        <B
CLASS="command"
>sed</B
> commands.</P
></LI
><LI
><P
>Install the optional <B
CLASS="command"
>ed</B
> editor.</P
></LI
></UL
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN1601"
></A
>8.2. Design</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN1603"
></A
>8.2.1. more</H2
><P
>There is a <B
CLASS="command"
>more</B
> command that comes with
      util-linux, but it will not work for this project. The reason is because
      of library dependencies and space constraints. The util-linux supplied
      <B
CLASS="command"
>more</B
> needs either the libncurses or libtermcap to
      work and there just is not enough space on the root disk floppy to fit
      everything in. So, in order to have a <B
CLASS="command"
>more</B
> command we
      will have to get creative.</P
><P
>The <B
CLASS="command"
>more</B
> command is used to display a file page
      by page. It's a little like having a <B
CLASS="command"
>cat</B
> command that
      pauses every twenty-five lines. The basic logic is outlined
      below.</P
><P
></P
><UL
><LI
><P
>Read one line of the file.</P
></LI
><LI
><P
>Display the line on the screen.</P
></LI
><LI
><P
>If 25 lines have been displayed, pause.</P
></LI
><LI
><P
>Loop and do it again.</P
></LI
></UL
><P
>Of course there are some details left out like what to do if the
      screen dimensions are not what we anticipated, but overall it is a fair
      representation of what <B
CLASS="command"
>more</B
> does. Given this simple
      program logic, it should not be hard to put together a short shell
      script that emulates the basic functionality of <B
CLASS="command"
>more</B
>.
      The BASH(1) manpage and Adv-BASH-Scripting-Guide will serve as
      references.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1624"
></A
>8.2.2. More device files</H2
><P
>The <B
CLASS="command"
>more</B
> script will need access to device
      files that are not on the root disk yet. Specifically
      <B
CLASS="command"
>more</B
> needs to have <TT
CLASS="filename"
>stdin</TT
>,
      <TT
CLASS="filename"
>stdout</TT
> and <TT
CLASS="filename"
>stderr</TT
>, but while
      we are at it we should check for any other missing
      <TT
CLASS="filename"
>/dev</TT
> files. The Linux Standard Base requires
      <TT
CLASS="filename"
>null</TT
>, <TT
CLASS="filename"
>zero</TT
> and
      <TT
CLASS="filename"
>tty</TT
> to be present in the <TT
CLASS="filename"
>/dev</TT
>
      directory. Files for <TT
CLASS="filename"
>null</TT
> and
      <TT
CLASS="filename"
>tty</TT
> already exist from previous phases of the
      project, but we still need <TT
CLASS="filename"
>/dev/zero</TT
>. We can refer
      to <TT
CLASS="filename"
>devices.txt</TT
> in the Linux source code
      <TT
CLASS="filename"
>Documentation</TT
> directory for major and minor
      numbers.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1642"
></A
>8.2.3. ps, sed &#38; ed</H2
><P
>These three packages can be found by using the Internet resources
      we have used before plus one new site. The "sed" and "ed" packages can
      be found at the same place we found BASH, on the <A
HREF="ftp://ftp.gnu.org"
TARGET="_top"
>GNU FTP server</A
>. The procps package shows
      up in an Ibiblio LSM search, but it is an old version. In order to find
      the latest version we can go to the Freshmeat website at <A
HREF="http://freshmeat.net"
TARGET="_top"
>http://freshmeat.net</A
> and search for
      "procps" in projects.</P
><P
>Both "sed" and "ed" packages feature GNU's familiar
      <B
CLASS="command"
>configure</B
> script and are therefore very easy to
      build. There is no <B
CLASS="command"
>configure</B
> script for "procps" but
      this does not make things too difficult. We can just read the package's
      <TT
CLASS="filename"
>README</TT
> file to find out about how to set various
      configuration options. We can use one of these options to avoid the
      complexity of using and installing libproc. Setting
      <TT
CLASS="parameter"
><I
>SHARED=0</I
></TT
> makes <TT
CLASS="filename"
>libproc</TT
> an
      integrated part of <B
CLASS="command"
>ps</B
> rather than a separate, shared
      library.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN1654"
></A
>8.3. Construction</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN1656"
></A
>8.3.1. Write a "more" script</H2
><P
>Create the following script with a text editor and save it as
      <TT
CLASS="filename"
>~/staging/bin/more.sh</TT
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>#!/bin/sh
#
# more.sh - emulates the basic functions of the "more" binary without
#           requiring ncurses or termcap libraries.
#
# Assume input is coming from STDIN unless a valid file is given as
# a command-line argument. 
if [ -f $1 ]; then
  INPUT="$1"
else
  INPUT="/dev/stdin"
fi
#
# Set IFS to newline only. See BASH(1) manpage for details on IFS.
IFS=$'\n'
#
# If terminal dimensions are not already set as shell variables, take
# a guess of 80x25.
if [ "$COLUMNS" = "" ]; then
  let COLUMNS=80;
fi
if [ "$LINES" = "" ]; then
  let LINES=25;
fi
#
# Initialize line counter variable
let LINE_COUNTER=$LINES
#
# Read the input file one line at a time and display on STDOUT until
# the page fills up. Display "Press &#60;Enter&#62;" message on STDERR and wait
# for keypress from STDERR.  Continue until the end of the input file.
# Any input line greater than $COLUMNS characters in length is wrapped
# and counts as multiple lines.
#
while read -n $COLUMNS LINE_BUFFER; do
  echo "$LINE_BUFFER"
  let LINE_COUNTER=$LINE_COUNTER-1
  if [ $LINE_COUNTER -le 1 ]; then
    echo "Press &#60;ENTER&#62; for next page or &#60;CTRL&#62;+C to quit."&#62;/dev/stderr
    read&#60;/dev/stderr
    let LINE_COUNTER=$LINES
  fi
done&#60;$INPUT
#
# end of more.sh</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Create a symbolic link for <TT
CLASS="filename"
>more</TT
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> ln -s more.sh ~/staging/bin/more</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1667"
></A
>8.3.2. Create additional device files</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> ln -s /proc/self/fd ~/staging/dev/fd
<TT
CLASS="prompt"
>bash#</TT
> ln -s fd/0 ~/staging/dev/stdin
<TT
CLASS="prompt"
>bash#</TT
> ln -s fd/1 ~/staging/dev/stdout
<TT
CLASS="prompt"
>bash#</TT
> ln -s fd/2 ~/staging/dev/stderr
bash# mknod -m644 ~/staging/dev/zero c 1 5</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1675"
></A
>8.3.3. Install ps</H2
><P
>Get the latest procps source package from <A
HREF="http://procps.sourceforge.net/"
TARGET="_top"
>http://procps.sourceforge.net/</A
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd /usr/src/procps-3.2.3
<TT
CLASS="prompt"
>bash#</TT
> make SHARED=0 CC="gcc -mcpu=i386"
<TT
CLASS="prompt"
>bash#</TT
> cd ps
<TT
CLASS="prompt"
>bash#</TT
> cp ps ~/staging/bin</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1685"
></A
>8.3.4. Install sed</H2
><P
>Download GNU's sed from <A
HREF="ftp://ftp.gnu.org/gnu/sed/"
TARGET="_top"
>ftp://ftp.gnu.org/gnu/sed/</A
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd /usr/src/sed-4.1.2
<TT
CLASS="prompt"
>bash#</TT
> export CC="gcc -mcpu=i386"
<TT
CLASS="prompt"
>bash#</TT
> ./configure --host=i386-pc-linux-gnu
<TT
CLASS="prompt"
>bash#</TT
> make
<TT
CLASS="prompt"
>bash#</TT
> cd sed
<TT
CLASS="prompt"
>bash#</TT
> cp sed ~/staging/bin</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1697"
></A
>8.3.5. Install ed</H2
><P
>The ed package also comes from GNU at <A
HREF="ftp://ftp.gnu.org/gnu/ed/"
TARGET="_top"
>ftp://ftp.gnu.org/gnu/ed/</A
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd /usr/src/ed-0.2
<TT
CLASS="prompt"
>bash#</TT
> ./configure --host=i386-pc-linux-gnu
<TT
CLASS="prompt"
>bash#</TT
> make
<TT
CLASS="prompt"
>bash#</TT
> cp ed ~/staging/bin</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1707"
></A
>8.3.6. Strip binaries to save space</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> strip ~/staging/bin/*</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1712"
></A
>8.3.7. Ensure proper permissions</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> chown 0:0 ~/staging/bin/*
<TT
CLASS="prompt"
>bash#</TT
> chmod -R 755 ~/staging/bin
<TT
CLASS="prompt"
>bash#</TT
> chmod 4750 ~/staging/bin/su</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1719"
></A
>8.3.8. Create the root disk image</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cd /
<TT
CLASS="prompt"
>bash#</TT
> dd if=/dev/zero of=/dev/ram7 bs=1k count=4096
<TT
CLASS="prompt"
>bash#</TT
> mke2fs -m0 /dev/ram7 4096
<TT
CLASS="prompt"
>bash#</TT
> mount /dev/ram7 /mnt
<TT
CLASS="prompt"
>bash#</TT
> cp -dpR ~/staging/* /mnt
<TT
CLASS="prompt"
>bash#</TT
> umount /dev/ram7
<TT
CLASS="prompt"
>bash#</TT
> dd if=/dev/ram7 of=~/phase7-image bs=1k
<TT
CLASS="prompt"
>bash#</TT
> gzip -9 ~/phase7-image</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1731"
></A
>8.3.9. Copy the image to diskette</H2
><P
>Insert the diskette labeled "root disk" into drive fd0.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> dd if=~/phase7-image.gz of=/dev/fd0 bs=1k</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN1737"
></A
>8.4. Implementation</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN1739"
></A
>8.4.1. System startup</H2
><P
>Boot from the diskset in the usual way and log in as root.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1742"
></A
>8.4.2. Test the "more" script</H2
><P
>Display kernel messages by piping the output of
      <B
CLASS="command"
>dmesg</B
> to <B
CLASS="command"
>more</B
>.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> dmesg | more</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Examine the <TT
CLASS="filename"
>local_fs</TT
> script by using
      <B
CLASS="command"
>more</B
> with a command-line argument.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> more /etc/init.d/local_fs</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1756"
></A
>8.4.3. Use ps to show running processes</H2
><P
>Display processes for the user currently logged in.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> ps</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Display all available information about all running
      processes.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> ps -ef</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1766"
></A
>8.4.4. Run a simple sed script</H2
><P
>Use <B
CLASS="command"
>sed</B
> to display an alternate version of
      <TT
CLASS="filename"
>/etc/passwd</TT
>.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> sed -e "s/Legacy/Old School/" /etc/passwd</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Verify that sed did not make the changes permanent.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cat /etc/passwd</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1778"
></A
>8.4.5. Test the "ed" editor</H2
><P
>Use <B
CLASS="command"
>ed</B
> to change properties on the "daemon"
      user.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> ed -p*
<TT
CLASS="prompt"
>ed*</TT
> r /etc/passwd
<TT
CLASS="prompt"
>ed*</TT
> %p
<TT
CLASS="prompt"
>ed*</TT
> /daemon/s/Legacy/Old School/
<TT
CLASS="prompt"
>ed*</TT
> %p
<TT
CLASS="prompt"
>ed*</TT
> w
<TT
CLASS="prompt"
>ed*</TT
> q</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Verify that the changes are permanent (at least until the system
      is restarted.)</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
><TT
CLASS="prompt"
>bash#</TT
> cat /etc/passwd</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1795"
></A
>8.4.6. System shutdown</H2
><P
>Bring the system down gracefully with the
      <B
CLASS="command"
>shutdown</B
> command.</P
></DIV
></DIV
></DIV
><DIV
CLASS="chapter"
><HR><H1
><A
NAME="wrap-up"
></A
>Chapter 9. Project Wrap Up</H1
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="AEN1801"
></A
>9.1. Celebrating Accomplishments</H1
><P
>As the Pocket Linux Project draws to a close we should take a moment
    to celebrate all of our accomplishments. Some of the highlights are listed
    below:</P
><P
></P
><UL
><LI
><P
>We have built a system, from source code only, that fully
        implements all of the commands described in the Filesystem Hierarchy
        Standard requirements for a root filesystem.</P
></LI
><LI
><P
>We have learned how to use Internet resources to locate and
        download the source code needed to build a GNU/Linux system.</P
></LI
><LI
><P
>We have written basic system startup and shutdown scripts and
        configured them to execute in the proper runlevels.</P
></LI
><LI
><P
>We have included support for multiple users on virtual consoles
        and implemented permissions on system files.</P
></LI
><LI
><P
>But most importantly, we have learned some good design
        techniques and project management skills that will enable us to tackle
        any future projects with ease and confidence.</P
></LI
></UL
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN1815"
></A
>9.2. Planning Next Steps</H1
><P
>The Pocket Linux system is nearly overflowing, so there really is no
    more room to expand the current root diskette to support any additional
    commands and features. This leaves us with a few choices of where to go
    next. We can:</P
><P
></P
><UL
><LI
><P
>Find a way to expand the current system just enough to host a
        small application. (For more information about hosting applications
        with Pocket Linux, see Appendix A)</P
></LI
><LI
><P
>Remove multi-user capability and some of the less often used
        commands from the root disk, replacing them with utilities like tar
        and gzip that would be useful for a rescue/restore diskset.</P
></LI
><LI
><P
>Use the techniques we have learned to design and build an entire
        GNU/Linux system and install it on a more spacious hard disk
        partition. (For more infomation about building a larger system, check
        out the GNU/Linux System Architect Toolkit at: <A
HREF="http://architect.sourceforge.net/"
TARGET="_top"
>http://architect.sourceforge.net/</A
>.)</P
></LI
></UL
><P
>Which ever path is chosen, we can move forward confidently, armed
    with the knowledge we need to be successful in our endeavors.</P
></DIV
></DIV
><DIV
CLASS="appendix"
><HR><H1
><A
NAME="a"
></A
>Appendix A. Hosting Applications</H1
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="AEN1829"
></A
>A.1. Analysis</H1
><P
>An operating system by itself is not much fun. What makes an OS
    great is the applications that can be run on top of it. Unfortunately,
    Pocket Linux currently does not have much room for anything other than
    system programs. Still, it would be nice to expand the system just enough
    to host some cool applications. Obviously a full-blown X-Windows GUI is
    out of the question, but running a small console based program should be
    within our reach.</P
><P
>Rather than doing a typical "hello world" program as an example,
    application hosting will be demonstrated using a console based audio
    player called mp3blaster. Building mp3blaster offers more technical
    challenge than "hello world" and the finished product should be a lot more
    fun. However, it should not be construed that a console-based jukebox is
    the only application for Pocket Linux. On the contrary, after completing
    this phase the reader should have the knowledge and tools to build almost
    any console-based program he or she desires.</P
><P
>So what will it take to turn a pocket-sized GNU/Linux system into a
    pocket-sized mp3 player? A few things are listed below.</P
><P
></P
><UL
><LI
><P
>Add support for audio hardware.</P
></LI
><LI
><P
>Create space for the mp3blaster program.</P
></LI
><LI
><P
>Provide a convenient way to access audio files.</P
></LI
></UL
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN1841"
></A
>A.2. Design</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN1843"
></A
>A.2.1. Support for audio hardware</H2
><P
>There is a vast proliferation of audio hardware on the market and
      each sound card has its own particular configuration. For details on how
      to set up a particular sound card we can turn to the Sound-HOWTO
      available from <A
HREF="http://www.tldp.org"
TARGET="_top"
>The Linux Documentation
      Project</A
>. In a broader sense, however, we can treat a sound card
      like any other piece of new hardware. To add new hardware to a GNU/Linux
      system we will need configure the kernel to recognize it and configure
      <TT
CLASS="filename"
>/dev</TT
> files on the root disk to access it.</P
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN1848"
></A
>A.2.1.1. Kernel support for audio</H3
><P
>In order to support sound cards, a new kernel will have to be
        built. It is very important that audio hardware support be configured
        as built-in, because Pocket Linux is not set up to handle kernel
        modules.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN1851"
></A
>A.2.1.2. Root disk support for audio</H3
><P
>Searching <TT
CLASS="filename"
>devices.txt</TT
> for the keyword
        "sound" will list quite a few possible audio devices, but usually only
        <TT
CLASS="filename"
>/dev/dsp</TT
> and <TT
CLASS="filename"
>/dev/mixer</TT
> are
        required to get sound from a PC. These two files control the digital
        audio output and mixer controls, respectively.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1857"
></A
>A.2.2. Creating space for the program</H2
><P
>Probably the easiest way to create more space for the mp3blaster
      program is to mount an additional storage device. There are several
      choices for mount points. So far <TT
CLASS="filename"
>/usr</TT
>,
      <TT
CLASS="filename"
>/home</TT
> and <TT
CLASS="filename"
>/opt</TT
> are all empty
      directories and any one of them could be used to mount a floppy, CD-ROM
      or additional compressed ramdisk image. The <TT
CLASS="filename"
>/usr</TT
>
      directory is a logical choice for a place to put an application, but
      what about the choice of media? Mp3blaster and its required libraries
      are too big to fit on a 1.44M floppy and burning a CD-ROM seems like a
      lot of work for one little program. So given these constraints, the best
      choice would be to put the program on a compressed floppy.</P
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN1864"
></A
>A.2.2.1. Mounting additional compressed floppies</H3
><P
>Mounting CDs and uncompressed diskettes is easy, but what about
        loading compressed images from floppy into ramdisk? It will have to be
        done manually, because automatic mounting of compressed floppies only
        works for the root diskette. And using <B
CLASS="command"
>mount
        /dev/fd0</B
> will not work because there is no filesystem on the
        diskette, there are only the contents of a gzip file. The actual
        filesystem is contained inside the gzip file. So how can we mount the
        filesystem buried beneath the gzip file? This puzzle can be solved by
        examining at the steps used to create the familiar compressed root
        disk floppy.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>A ramdisk is created, mounted and filled with files.</P
></LI
><LI
><P
>The ramdisk device is unmounted.</P
></LI
><LI
><P
>The contents of the ramdisk are dumped to an image file
            using <B
CLASS="command"
>dd</B
>.</P
></LI
><LI
><P
>The image file is compressed with
            <B
CLASS="command"
>gzip</B
>.</P
></LI
><LI
><P
>The compressed image file is written to floppy with
            <B
CLASS="command"
>dd</B
>.</P
></LI
></OL
><P
>If that is how the compressed image makes its way from ramdisk
        to compressed floppy, then going from compressed floppy to ramdisk
        should be as simple as running through the steps in reverse.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>The compressed image file is read from floppy with
            <B
CLASS="command"
>dd</B
>.</P
></LI
><LI
><P
>The image file is uncompressed with
            <B
CLASS="command"
>gunzip</B
>.</P
></LI
><LI
><P
>The contents of the image file are dumped into ramdisk using
            <B
CLASS="command"
>dd</B
>.</P
></LI
><LI
><P
>The ramdisk device is mounted.</P
></LI
><LI
><P
>The files are available.</P
></LI
></OL
><P
>We can cut out the intermediate image file by using a pipe to
        combine <B
CLASS="command"
>dd</B
> and <B
CLASS="command"
>gunzip</B
> like this:
        <B
CLASS="command"
>dd if=/dev/fd0 | gunzip -cq &#62; /dev/ram1</B
>. Now the
        compressed floppy goes straight into ramdisk, decompressing on the
        fly.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN1901"
></A
>A.2.2.2. Root disk support for additional ramdisks</H3
><P
>We already have kernel support for ramdisks, because we are
        using a compressed root disk, but we will need to create more ramdisks
        in <TT
CLASS="filename"
>/dev</TT
>. Typically the kernel supports eight
        ramdisks on <TT
CLASS="filename"
>/dev/ram0</TT
> through
        <TT
CLASS="filename"
>/dev/ram7</TT
> with <TT
CLASS="filename"
>ram0</TT
> being
        used for the rootdisk. The <TT
CLASS="filename"
>devices.txt</TT
> file
        included in the Linux source code documentation will be helpful for
        matching devices to their major and minor numbers.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1909"
></A
>A.2.3. Accessing audio files</H2
><P
>The sample mp3 file that we will be using in our example is small
      enough to fit on an uncompressed floppy disk so that there is no need to
      burn a CD. However, serious music lovers may want to have the capability
      to mount a custom CD-ROM full of tunes and that option will require
      support for additional hardware.</P
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN1912"
></A
>A.2.3.1. CD-ROM hardware support</H3
><P
>Most modern CD-ROM drives will use IDE devices like
        <TT
CLASS="filename"
>/dev/hdc</TT
> or <TT
CLASS="filename"
>/dev/hdd</TT
>. To
        support these CD-ROM drives we will have to configure IDE support in
        the kernel and create the appropriate device files on the root
        disk.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN1917"
></A
>A.2.3.2. CD-ROM filesystem support</H3
><P
>CD-ROMs have different filesystems than hard disks and floppies.
        Most CD burning applications use a filesystem called ISO-9660 and have
        the capability to support Joliet or Rockridge extensions. We will have
        to include support for these filesystems in the kernel in order to
        mount CD-ROMs.</P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1920"
></A
>A.2.4. Other required files</H2
><P
>We will want to have all of mp3blaster's required libraries and
      other supporting files available as part of the compressed
      <TT
CLASS="filename"
>/usr</TT
> image so that mp3blaster can run correctly.
      The familiar <B
CLASS="command"
>ldd</B
> command can be used to determine
      which libraries mp3blaster requires. Any additional libraries can be
      placed in <TT
CLASS="filename"
>/usr/lib</TT
>. Even though some of the
      libraries may appear in <TT
CLASS="filename"
>/lib</TT
> on the development
      system, they can still go in <TT
CLASS="filename"
>/usr/lib</TT
> on the Pocket
      Linux system. The dynamic linker, <TT
CLASS="filename"
>ld-linux.so</TT
>, is
      smart enough to look in both places when loading libraries.</P
><P
>Because mp3blaster uses the curses (or ncurses) screen control
      library there is one additional file we need. The curses library needs
      to know the characteristics of the terminal it is controlling and it
      gets that information from the terminfo database. The terminfo database
      consists of all the files under the
      <TT
CLASS="filename"
>/usr/share/terminfo</TT
> directory and is very large
      compared to our available disk space. But, since Pocket Linux only
      supports the PC console, we only have one terminal type to worry about
      and therefore need only one file. The piece of the terminfo database we
      need is the file <TT
CLASS="filename"
>/usr/share/terminfo/l/linux</TT
>,
      because we are using a "Linux" terminal. For more information about the
      subject of curses, see John Strang's book entitled "Programming with
      Curses" available from <A
HREF="http://www.oreilly.com"
TARGET="_top"
>O'Reilly
      publishing</A
>.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1933"
></A
>A.2.5. Summary of tasks</H2
><P
>Between sound cards, ramdisks, CD-ROMs and terminfo there is quite
      a bit to keep track of. So let's take a moment to organize and summarize
      the tasks necessary to make the pocket jukebox a reality.</P
><P
></P
><UL
><LI
><P
>Create a new kernel disk that includes built-in support for
          audio hardware, IDE devices and CD-ROM filesystems.</P
></LI
><LI
><P
>Create the appropriate <TT
CLASS="filename"
>/dev</TT
> files on the
          root disk to support audio hardware, additional ramdisks and IDE
          CD-ROMs.</P
></LI
><LI
><P
>Install the <B
CLASS="command"
>gunzip</B
> utility to enable
          decompression of the usr image.</P
></LI
><LI
><P
>Create a startup script to load a compressed image from floppy
          into a ramdisk and mount the ramdisk on
          <TT
CLASS="filename"
>/usr</TT
>.</P
></LI
><LI
><P
>Create a compressed floppy that holds the mp3blaster program,
          its required libraries and terminfo files.</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN1950"
></A
>A.3. Construction</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN1952"
></A
>A.3.1. Create an enhanced boot disk</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN1954"
></A
>A.3.1.1. Build a new kernel</H3
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>bash# cd /usr/src/linux
bash# make menuconfig</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Be sure to configure support for the following:</P
><P
></P
><UL
><LI
><P
>386 processor</P
></LI
><LI
><P
>Floppy disk</P
></LI
><LI
><P
>RAM disk</P
></LI
><LI
><P
>Second extended (ext2) filesystem</P
></LI
><LI
><P
>Virtual console</P
></LI
><LI
><P
>Audio hardware</P
></LI
><LI
><P
>CD-ROM hardware</P
></LI
><LI
><P
>ISO-9660 and Joliet filesystems</P
></LI
></UL
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>bash# make dep
bash# make clean
bash# make bzImage</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN1978"
></A
>A.3.1.2. Copy the kernel to diskette</H3
><P
>Place the boot disk in drive fd0</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>bash# mount /dev/fd0 /mnt
bash# cp /usr/src/linux/arch/i386/boot/bzImage /mnt/boot/vmlinuz</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN1983"
></A
>A.3.1.3. Unmount the boot disk</H3
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>bash# cd /
bash# umount /mnt</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN1987"
></A
>A.3.2. Create an enhanced root disk</H2
><DIV
CLASS="sect3"
><H3
CLASS="sect3"
><A
NAME="AEN1989"
></A
>A.3.2.1. Create additional device files</H3
><DIV
CLASS="sect4"
><H4
CLASS="sect4"
><A
NAME="AEN1991"
></A
>A.3.2.1.1. IDE CD-ROM</H4
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>bash# mknod -m640 ~/staging/dev/hdc b 22 0
bash# mknod -m640 ~/staging/dev/hdd b 22 64</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Optionally create additional IDE devices.</P
></DIV
><DIV
CLASS="sect4"
><HR><H4
CLASS="sect4"
><A
NAME="AEN1996"
></A
>A.3.2.1.2. Ramdisk</H4
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>bash# mknod -m 640 ~/staging/dev/ram1 b 1 1
bash# mknod -m 640 ~/staging/dev/ram2 b 1 2 
bash# mknod -m 640 ~/staging/dev/ram3 b 1 3
bash# mknod -m 640 ~/staging/dev/ram4 b 1 4
bash# mknod -m 640 ~/staging/dev/ram5 b 1 5
bash# mknod -m 640 ~/staging/dev/ram6 b 1 6
bash# mknod -m 640 ~/staging/dev/ram7 b 1 7</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect4"
><HR><H4
CLASS="sect4"
><A
NAME="AEN2000"
></A
>A.3.2.1.3. Audio</H4
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>bash# mknod -m664 ~/staging/dev/dsp c 14 3
bash# mknod -m664 ~/staging/dev/mixer c 14 0</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN2004"
></A
>A.3.2.2. Install the gunzip binary</H3
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>bash# cd /usr/src/gzip-1.2.4a
bash# export CC="gcc -mcpu=i386"
bash# ./configure --host=i386-pc-linux-gnu
bash# make
bash# strip gzip
bash# cp gzip ~/staging/bin
bash# ln -s gzip ~/staging/bin/gunzip</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Don't forget to verify library requirements, check the ownership
        and check permissions on the gzip binary.</P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN2009"
></A
>A.3.2.3. Write a startup script to mount a compressed floppy</H3
><P
>Use a text editor to create the following script and save it as
        <TT
CLASS="filename"
>~/staging/etc/init.d/usr_image</TT
></P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>#!/bin/sh
#
# usr_image - load compressed images from floppy into ramdisk and
#             mount on /usr.
#
echo -n "Is there a compressed diskette to load for /usr [y/N]? "
read REPLY
if [ "$REPLY" = "y" ] || [ "$REPLY" = "Y" ]; then
  echo -n "Please insert the /usr floppy into fd0 and press &#60;ENTER&#62;."
  read REPLY
  echo "Clearing /dev/ram1."
  dd if=/dev/zero of=/dev/ram1 bs=1k count=4096
  echo "Loading compressed image from /dev/fd0 into /dev/ram1..."
  (dd if=/dev/fd0 bs=1k | gunzip -cq) &#62;/dev/ram1 2&#62;/dev/null
  fsck -fp /dev/ram1
  if [ $? -gt 1 ]; then
    echo "Filesystem errors on /dev/ram1!  Manual intervention required."
  else
    echo "Mounting /usr."
    mount /dev/ram1 /usr
  fi
fi
#
# end of usr_image</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Configure the script to run right after root is mounted.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>bash# ln -s ../init.d/usr_image ~/staging/etc/rcS.d/S21usr_image</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN2018"
></A
>A.3.2.4. Create a compressed root disk</H3
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>bash# cd /
bash# dd if=/dev/zero of=/dev/ram7 bs=1k count=4096
bash# mke2fs -m0 /dev/ram7
bash# mount /dev/ram7 /mnt
bash# cp -dpR ~/staging/* /mnt
bash# umount /dev/ram7
bash# dd if=/dev/ram7 of=~/phase8-image bs=1k
bash# gzip -9 ~/phase8-image</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Insert the diskette labeled "root disk" into drive fd0.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>bash# dd if=~/phase8-image.gz of=/dev/fd0 bs=1k</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2025"
></A
>A.3.3. Create a compressed /usr disk for mp3blaster</H2
><P
>The compressed /usr diskette will be created in using the same
      process that is used to create the compressed root disk. We will copy
      files to a staging area, copy the staging area to ramdisk, compress the
      ramdisk and write it to diskette.</P
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN2028"
></A
>A.3.3.1. Create a staging area</H3
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>bash# mkdir ~/usr-staging
bash# cd ~/usr-staging
bash# mkdir bin lib
bash# mkdir -p share/terminfo/l</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN2032"
></A
>A.3.3.2. Install the mp3blaster program</H3
><P
>Download the latest version of mp3blaster source code from its
        home at <A
HREF="http://www.stack.nl/~brama/mp3blaster/"
TARGET="_top"
>http://www.stack.nl/~brama/mp3blaster/</A
>.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>bash# cd ~/usr/src/mp3blaster-3.2.0
bash# ./configure
bash# make
bash# cp src/mp3blaster ~/usr-staging/bin</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN2038"
></A
>A.3.3.3. Copy additional libraries and terminfo</H3
><P
>Use <B
CLASS="command"
>ldd</B
> to find out which libraries are
        needed for mp3blaster.</P
><DIV
CLASS="note"
><P
></P
><TABLE
CLASS="note"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The following is an example from the author's development
          system. It is possible that different systems may yield slightly
          different results in terms of library requirements.</P
></TD
></TR
></TABLE
></DIV
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>bash# cd ~/usr-staging/lib
bash# ldd ~/usr-staging/bin/mp3blaster
bash# cp /usr/lib/ncurses.so.5.0  .
bash# cp /usr/lib/stdc++.so.3 .
bash# cp /lib/libm.so.6 .
bash# cp /usr/lib/libgcc_s.so.1 .
bash# cd ~/usr-staging/share/terminfo/l
bash# cp /usr/share/terminfo/l/linux .</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect3"
><HR><H3
CLASS="sect3"
><A
NAME="AEN2046"
></A
>A.3.3.4. Make a compressed image and copy it to diskette</H3
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>bash# cd /
bash# dd if=/dev/zero of=/dev/ram7 bs=1k count=4096
bash# mke2fs -m0 /dev/ram7
bash# mount /dev/ram7 /mnt
bash# cp -dpR ~/usr-staging/* /mnt
bash# umount /dev/ram7
bash# dd if=/dev/ram7 of=~/mp3blaster-image bs=1k
bash# gzip -9 ~/mp3blaster-image</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Insert the diskette labeled "mp3blaster" into drive fd0.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>bash# dd if=~/mp3blaster-image.gz of=/dev/fd0 bs=1k</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2053"
></A
>A.3.4. Create a data diskette for testing</H2
><P
>Go to the Internet site <A
HREF="http://www.paul.sladen.org"
TARGET="_top"
>http://www.paul.sladen.org</A
> and
      download the mp3 file of Linus Torvalds pronouncing "Linux." The direct
      link is: <A
HREF="http://www.paul.sladen.org/pronunciation/torvalds-says-linux.mp3"
TARGET="_top"
>http://www.paul.sladen.org/pronunciation/torvalds-says-linux.mp3</A
>.
      Create a Second Extended (ext2) filesystem on a floppy and copy the mp3
      file onto the diskette.</P
></DIV
></DIV
><DIV
CLASS="sect1"
><HR><H1
CLASS="sect1"
><A
NAME="AEN2058"
></A
>A.4. Implementation</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN2060"
></A
>A.4.1. System Startup</H2
><P
></P
><OL
TYPE="1"
><LI
><P
>Boot from the kernel diskette.</P
></LI
><LI
><P
>Insert the root floppy when prompted.</P
></LI
><LI
><P
>When prompted for a /usr diskette, say 'Y'.</P
></LI
><LI
><P
>Insert the mp3blaster diskette and press
          <B
CLASS="keycap"
>Enter</B
>.</P
></LI
></OL
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2072"
></A
>A.4.2. Verify that the /usr diskette loaded properly</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>bash# mount
bash# ls -lR /usr</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2076"
></A
>A.4.3. Check the audio device initialization</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>bash# dmesg | more</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>If everything worked there should be a line or two indicating that
      the kernel found the audio hardware. The example below shows how the
      kernel might report a Yamaha integrated sound system.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="screen"
>ymfpci: YMF740C at 0xf4000000 IRQ 10
ac97_codec: AC97 Audio codec, id: 0x4144:0x5303 (Analog Devices AD1819)
</PRE
></FONT
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2083"
></A
>A.4.4. Test audio output</H2
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>bash# echo "Garbage" &#62; /dev/dsp</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>A short burst of static coming from the PC speakers indicates that
      sound is working.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2088"
></A
>A.4.5. Play a sample file</H2
><P
>Insert the diskette containing the sample audio file.</P
><P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>mount /dev/fd0 /home
bash# /usr/bin/mp3blaster</PRE
></FONT
></TD
></TR
></TABLE
></P
><P
>Use mp3blaster to select and play the file
      <TT
CLASS="filename"
>/home/torvalds-says-linux.mp3</TT
>. Use mp3blaster's
      mixer controls to adjust the volume as needed.</P
></DIV
><DIV
CLASS="sect2"
><HR><H2
CLASS="sect2"
><A
NAME="AEN2095"
></A
>A.4.6. System shutdown</H2
><P
>Bring the system down gracefully with the
      <B
CLASS="command"
>shutdown</B
> command.</P
></DIV
></DIV
></DIV
><DIV
CLASS="appendix"
><HR><H1
><A
NAME="gfdl"
></A
>Appendix B. GNU Free Documentation License</H1
><FONT
COLOR="RED"
>Version 1.2, November 2002</FONT
><A
NAME="fsf-copyright"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>Copyright (C) 2000,2001,2002 Free Software Foundation, Inc. 59
    Temple Place, Suite 330, Boston, MA 02111-1307 USA Everyone is permitted
    to copy and distribute verbatim copies of this license document, but
    changing it is not allowed.</P
></BLOCKQUOTE
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="gfdl-0"
></A
>B.1. PREAMBLE</H1
><P
>The purpose of this License is to make a manual, textbook, or other
    functional and useful document "free" in the sense of freedom: to assure
    everyone the effective freedom to copy and redistribute it, with or
    without modifying it, either commercially or noncommercially. Secondarily,
    this License preserves for the author and publisher a way to get credit
    for their work, while not being considered responsible for modifications
    made by others.</P
><P
>This License is a kind of "copyleft", which means that derivative
    works of the document must themselves be free in the same sense. It
    complements the GNU General Public License, which is a copyleft license
    designed for free software.</P
><P
>We have designed this License in order to use it for manuals for
    free software, because free software needs free documentation: a free
    program should come with manuals providing the same freedoms that the
    software does. But this License is not limited to software manuals; it can
    be used for any textual work, regardless of subject matter or whether it
    is published as a printed book. We recommend this License principally for
    works whose purpose is instruction or reference.</P
></DIV
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="gfdl-1"
></A
>B.2. APPLICABILITY AND DEFINITIONS</H1
><P
>This License applies to any manual or other work, in
    any medium, that contains a notice placed by the copyright holder saying
    it can be distributed under the terms of this License. Such a notice
    grants a world-wide, royalty-free license, unlimited in duration, to use
    that work under the conditions stated herein. The "Document", below,
    refers to any such manual or work. Any member of the public is a licensee,
    and is addressed as "you". You accept the license if you copy, modify or
    distribute the work in a way requiring permission under copyright
    law.</P
><P
>A "Modified Version" of the Document means any
    work containing the Document or a portion of it, either copied verbatim,
    or with modifications and/or translated into another language.</P
><P
>A "Secondary Section" is a named appendix or a
    front-matter section of the Document that deals exclusively with the
    relationship of the publishers or authors of the Document to the
    Document's overall subject (or to related matters) and contains nothing
    that could fall directly within that overall subject. (Thus, if the
    Document is in part a textbook of mathematics, a Secondary Section may not
    explain any mathematics.) The relationship could be a matter of historical
    connection with the subject or with related matters, or of legal,
    commercial, philosophical, ethical or political position regarding
    them.</P
><P
>The "Invariant Sections" are certain Secondary
    Sections whose titles are designated, as being those of Invariant
    Sections, in the notice that says that the Document is released under this
    License. If a section does not fit the above definition of Secondary then
    it is not allowed to be designated as Invariant. The Document may contain
    zero Invariant Sections. If the Document does not identify any Invariant
    Sections then there are none.</P
><P
>The "Cover Texts" are certain short passages of
    text that are listed, as Front-Cover Texts or Back-Cover Texts, in the
    notice that says that the Document is released under this License. A
    Front-Cover Text may be at most 5 words, and a Back-Cover Text may be at
    most 25 words.</P
><P
>A "Transparent" copy of the Document means a
    machine-readable copy, represented in a format whose specification is
    available to the general public, that is suitable for revising the
    document straightforwardly with generic text editors or (for images
    composed of pixels) generic paint programs or (for drawings) some widely
    available drawing editor, and that is suitable for input to text
    formatters or for automatic translation to a variety of formats suitable
    for input to text formatters. A copy made in an otherwise Transparent file
    format whose markup, or absence of markup, has been arranged to thwart or
    discourage subsequent modification by readers is not Transparent. An image
    format is not Transparent if used for any substantial amount of text. A
    copy that is not "Transparent" is called "Opaque".</P
><P
>Examples of suitable formats for Transparent copies include plain
    ASCII without markup, Texinfo input format, LaTeX input format, SGML or
    XML using a publicly available DTD, and standard-conforming simple HTML,
    PostScript or PDF designed for human modification. Examples of transparent
    image formats include PNG, XCF and JPG. Opaque formats include proprietary
    formats that can be read and edited only by proprietary word processors,
    SGML or XML for which the DTD and/or processing tools are not generally
    available, and the machine-generated HTML, PostScript or PDF produced by
    some word processors for output purposes only.</P
><P
>The "Title Page" means, for a printed book, the
    title page itself, plus such following pages as are needed to hold,
    legibly, the material this License requires to appear in the title page.
    For works in formats which do not have any title page as such, "Title
    Page" means the text near the most prominent appearance of the work's
    title, preceding the beginning of the body of the text.</P
><P
>A section "Entitled XYZ" means a named subunit of
    the Document whose title either is precisely XYZ or contains XYZ in
    parentheses following text that translates XYZ in another language. (Here
    XYZ stands for a specific section name mentioned below, such as
    "Acknowledgements", "Dedications", "Endorsements", or "History".) To
    "Preserve the Title" of such a section when you modify the Document means
    that it remains a section "Entitled XYZ" according to this
    definition.</P
><P
>The Document may include Warranty Disclaimers next to the notice
    which states that this License applies to the Document. These Warranty
    Disclaimers are considered to be included by reference in this License,
    but only as regards disclaiming warranties: any other implication that
    these Warranty Disclaimers may have is void and has no effect on the
    meaning of this License.</P
></DIV
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="gfdl-2"
></A
>B.3. VERBATIM COPYING</H1
><P
>You may copy and distribute the Document in any medium, either
    commercially or noncommercially, provided that this License, the copyright
    notices, and the license notice saying this License applies to the
    Document are reproduced in all copies, and that you add no other
    conditions whatsoever to those of this License. You may not use technical
    measures to obstruct or control the reading or further copying of the
    copies you make or distribute. However, you may accept compensation in
    exchange for copies. If you distribute a large enough number of copies you
    must also follow the conditions in section 3.</P
><P
>You may also lend copies, under the same conditions stated above,
    and you may publicly display copies.</P
></DIV
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="gfdl-3"
></A
>B.4. COPYING IN QUANTITY</H1
><P
>If you publish printed copies (or copies in media that commonly have
    printed covers) of the Document, numbering more than 100, and the
    Document's license notice requires Cover Texts, you must enclose the
    copies in covers that carry, clearly and legibly, all these Cover Texts:
    Front-Cover Texts on the front cover, and Back-Cover Texts on the back
    cover. Both covers must also clearly and legibly identify you as the
    publisher of these copies. The front cover must present the full title
    with all words of the title equally prominent and visible. You may add
    other material on the covers in addition. Copying with changes limited to
    the covers, as long as they preserve the title of the Document and satisfy
    these conditions, can be treated as verbatim copying in other
    respects.</P
><P
>If the required texts for either cover are too voluminous to fit
    legibly, you should put the first ones listed (as many as fit reasonably)
    on the actual cover, and continue the rest onto adjacent pages.</P
><P
>If you publish or distribute Opaque copies of the Document numbering
    more than 100, you must either include a machine-readable Transparent copy
    along with each Opaque copy, or state in or with each Opaque copy a
    computer-network location from which the general network-using public has
    access to download using public-standard network protocols a complete
    Transparent copy of the Document, free of added material. If you use the
    latter option, you must take reasonably prudent steps, when you begin
    distribution of Opaque copies in quantity, to ensure that this Transparent
    copy will remain thus accessible at the stated location until at least one
    year after the last time you distribute an Opaque copy (directly or
    through your agents or retailers) of that edition to the public.</P
><P
>It is requested, but not required, that you contact the authors of
    the Document well before redistributing any large number of copies, to
    give them a chance to provide you with an updated version of the
    Document.</P
></DIV
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="gfdl-4"
></A
>B.5. MODIFICATIONS</H1
><P
>You may copy and distribute a Modified Version of the Document under
    the conditions of sections 2 and 3 above, provided that you release the
    Modified Version under precisely this License, with the Modified Version
    filling the role of the Document, thus licensing distribution and
    modification of the Modified Version to whoever possesses a copy of it. In
    addition, you must do these things in the Modified Version:</P
><P
></P
><OL
TYPE="A"
><LI
><P
>Use in the Title Page (and on the covers, if any) a title
        distinct from that of the Document, and from those of previous
        versions (which should, if there were any, be listed in the History
        section of the Document). You may use the same title as a previous
        version if the original publisher of that version gives
        permission.</P
></LI
><LI
><P
>List on the Title Page, as authors, one or more persons or
        entities responsible for authorship of the modifications in the
        Modified Version, together with at least five of the principal authors
        of the Document (all of its principal authors, if it has fewer than
        five), unless they release you from this requirement.</P
></LI
><LI
><P
>State on the Title page the name of the publisher of the
        Modified Version, as the publisher.</P
></LI
><LI
><P
>Preserve all the copyright notices of the Document.</P
></LI
><LI
><P
>Add an appropriate copyright notice for your modifications
        adjacent to the other copyright notices.</P
></LI
><LI
><P
>Include, immediately after the copyright notices, a license
        notice giving the public permission to use the Modified Version under
        the terms of this License, in the form shown in the <A
HREF="#gfdl-addendum"
>Addendum</A
> below.</P
></LI
><LI
><P
>Preserve in that license notice the full lists of Invariant
        Sections and required Cover Texts given in the Document's license
        notice.</P
></LI
><LI
><P
>Include an unaltered copy of this License.</P
></LI
><LI
><P
>Preserve the section Entitled "History", Preserve its Title,
        and add to it an item stating at least the title, year, new authors,
        and publisher of the Modified Version as given on the Title Page. If
        there is no section Entitled "History" in the Document, create one
        stating the title, year, authors, and publisher of the Document as
        given on its Title Page, then add an item describing the Modified
        Version as stated in the previous sentence.</P
></LI
><LI
><P
>Preserve the network location, if any, given in the Document
        for public access to a Transparent copy of the Document, and likewise
        the network locations given in the Document for previous versions it
        was based on. These may be placed in the "History" section. You may
        omit a network location for a work that was published at least four
        years before the Document itself, or if the original publisher of the
        version it refers to gives permission.</P
></LI
><LI
><P
>For any section Entitled "Acknowledgements" or "Dedications",
        Preserve the Title of the section, and preserve in the section all the
        substance and tone of each of the contributor acknowledgements and/or
        dedications given therein.</P
></LI
><LI
><P
>Preserve all the Invariant Sections of the Document,
        unaltered in their text and in their titles. Section numbers or the
        equivalent are not considered part of the section titles.</P
></LI
><LI
><P
>Delete any section Entitled "Endorsements". Such a section
        may not be included in the Modified Version.</P
></LI
><LI
><P
>Do not retitle any existing section to be Entitled
        "Endorsements" or to conflict in title with any Invariant
        Section.</P
></LI
><LI
><P
>Preserve any Warranty Disclaimers.</P
></LI
></OL
><P
>If the Modified Version includes new front-matter sections or
    appendices that qualify as Secondary Sections and contain no material
    copied from the Document, you may at your option designate some or all of
    these sections as invariant. To do this, add their titles to the list of
    Invariant Sections in the Modified Version's license notice. These titles
    must be distinct from any other section titles.</P
><P
>You may add a section Entitled "Endorsements", provided it contains
    nothing but endorsements of your Modified Version by various parties--for
    example, statements of peer review or that the text has been approved by
    an organization as the authoritative definition of a standard.</P
><P
>You may add a passage of up to five words as a Front-Cover Text, and
    a passage of up to 25 words as a Back-Cover Text, to the end of the list
    of Cover Texts in the Modified Version. Only one passage of Front-Cover
    Text and one of Back-Cover Text may be added by (or through arrangements
    made by) any one entity. If the Document already includes a cover text for
    the same cover, previously added by you or by arrangement made by the same
    entity you are acting on behalf of, you may not add another; but you may
    replace the old one, on explicit permission from the previous publisher
    that added the old one.</P
><P
>The author(s) and publisher(s) of the Document do not by this
    License give permission to use their names for publicity for or to assert
    or imply endorsement of any Modified Version.</P
></DIV
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="gfdl-5"
></A
>B.6. COMBINING DOCUMENTS</H1
><P
>You may combine the Document with other documents released under
    this License, under the terms defined in <A
HREF="#gfdl-4"
>section
    4</A
> above for modified versions, provided that you include in the
    combination all of the Invariant Sections of all of the original
    documents, unmodified, and list them all as Invariant Sections of your
    combined work in its license notice, and that you preserve all their
    Warranty Disclaimers.</P
><P
>The combined work need only contain one copy of this License, and
    multiple identical Invariant Sections may be replaced with a single copy.
    If there are multiple Invariant Sections with the same name but different
    contents, make the title of each such section unique by adding at the end
    of it, in parentheses, the name of the original author or publisher of
    that section if known, or else a unique number. Make the same adjustment
    to the section titles in the list of Invariant Sections in the license
    notice of the combined work.</P
><P
>In the combination, you must combine any sections Entitled "History"
    in the various original documents, forming one section Entitled "History";
    likewise combine any sections Entitled "Acknowledgements", and any
    sections Entitled "Dedications". You must delete all sections Entitled
    "Endorsements".</P
></DIV
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="gfdl-6"
></A
>B.7. COLLECTIONS OF DOCUMENTS</H1
><P
>You may make a collection consisting of the Document and other
    documents released under this License, and replace the individual copies
    of this License in the various documents with a single copy that is
    included in the collection, provided that you follow the rules of this
    License for verbatim copying of each of the documents in all other
    respects.</P
><P
>You may extract a single document from such a collection, and
    distribute it individually under this License, provided you insert a copy
    of this License into the extracted document, and follow this License in
    all other respects regarding verbatim copying of that document.</P
></DIV
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="gfdl-7"
></A
>B.8. AGGREGATION WITH INDEPENDENT WORKS</H1
><P
>A compilation of the Document or its derivatives with other separate
    and independent documents or works, in or on a volume of a storage or
    distribution medium, is called an "aggregate" if the copyright resulting
    from the compilation is not used to limit the legal rights of the
    compilation's users beyond what the individual works permit. When the
    Document is included in an aggregate, this License does not apply to the
    other works in the aggregate which are not themselves derivative works of
    the Document.</P
><P
>If the Cover Text requirement of section 3 is applicable to these
    copies of the Document, then if the Document is less than one half of the
    entire aggregate, the Document's Cover Texts may be placed on covers that
    bracket the Document within the aggregate, or the electronic equivalent of
    covers if the Document is in electronic form. Otherwise they must appear
    on printed covers that bracket the whole aggregate.</P
></DIV
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="gfdl-8"
></A
>B.9. TRANSLATION</H1
><P
>Translation is considered a kind of modification, so you may
    distribute translations of the Document under the terms of section 4.
    Replacing Invariant Sections with translations requires special permission
    from their copyright holders, but you may include translations of some or
    all Invariant Sections in addition to the original versions of these
    Invariant Sections. You may include a translation of this License, and all
    the license notices in the Document, and any Warranty Disclaimers,
    provided that you also include the original English version of this
    License and the original versions of those notices and disclaimers. In
    case of a disagreement between the translation and the original version of
    this License or a notice or disclaimer, the original version will
    prevail.</P
><P
>If a section in the Document is Entitled "Acknowledgements",
    "Dedications", or "History", the requirement (section 4) to Preserve its
    Title (section 1) will typically require changing the actual title.</P
></DIV
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="gfdl-9"
></A
>B.10. TERMINATION</H1
><P
>You may not copy, modify, sublicense, or distribute the Document
    except as expressly provided for under this License. Any other attempt to
    copy, modify, sublicense or distribute the Document is void, and will
    automatically terminate your rights under this License. However, parties
    who have received copies, or rights, from you under this License will not
    have their licenses terminated so long as such parties remain in full
    compliance.</P
></DIV
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="gfdl-10"
></A
>B.11. FUTURE REVISIONS OF THIS LICENSE</H1
><P
>The Free Software Foundation may publish new, revised versions of
    the GNU Free Documentation License from time to time. Such new versions
    will be similar in spirit to the present version, but may differ in detail
    to address new problems or concerns. See
    http://www.gnu.org/copyleft/.</P
><P
>Each version of the License is given a distinguishing version
    number. If the Document specifies that a particular numbered version of
    this License "or any later version" applies to it, you have the option of
    following the terms and conditions either of that specified version or of
    any later version that has been published (not as a draft) by the Free
    Software Foundation. If the Document does not specify a version number of
    this License, you may choose any version ever published (not as a draft)
    by the Free Software Foundation.</P
></DIV
><DIV
CLASS="section"
><HR><H1
CLASS="section"
><A
NAME="gfdl-addendum"
></A
>B.12. ADDENDUM: How to use this License for your documents</H1
><P
>To use this License in a document you have written, include a copy
    of the License in the document and put the following copyright and license
    notices just after the title page:</P
><A
NAME="copyright-sample"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>Copyright (c) YEAR YOUR NAME. Permission is granted to copy,
      distribute and/or modify this document under the terms of the GNU Free
      Documentation License, Version 1.2 or any later version published by the
      Free Software Foundation; with no Invariant Sections, no Front-Cover
      Texts, and no Back-Cover Texts. A copy of the license is included in the
      section entitled "GNU Free Documentation License".</P
></BLOCKQUOTE
><P
>If you have Invariant Sections, Front-Cover Texts and Back-Cover
    Texts, replace the "with...Texts." line with this:</P
><A
NAME="inv-cover-sample"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>with the Invariant Sections being LIST THEIR TITLES, with the
      Front-Cover Texts being LIST, and with the Back-Cover Texts being
      LIST.</P
></BLOCKQUOTE
><P
>If you have Invariant Sections without Cover Texts, or some other
    combination of the three, merge those two alternatives to suit the
    situation.</P
><P
>If your document contains nontrivial examples of program code, we
    recommend releasing these examples in parallel under your choice of free
    software license, such as the GNU General Public License, to permit their
    use in free software.</P
></DIV
></DIV
></DIV
></BODY
></HTML
>