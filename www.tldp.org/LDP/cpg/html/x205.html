<HTML
><HEAD
><TITLE
>Getting the console to work</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REL="HOME"
TITLE="Custom Linux: A Porting Guide"
HREF="index.html"><LINK
REL="UP"
TITLE="Booting In The Dark"
HREF="c184.html"><LINK
REL="PREVIOUS"
TITLE="Modifying code using compiler flags"
HREF="x197.html"><LINK
REL="NEXT"
TITLE="Linux Still Isn't Booting"
HREF="c233.html"></HEAD
><BODY
CLASS="sect1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Custom Linux: A Porting Guide: </TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x197.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 3. Booting In The Dark</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c233.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="sect1"
><H1
CLASS="sect1"
><A
NAME="AEN205"
></A
>3.3. Getting the console to work</H1
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN207"
></A
>3.3.1. Forcing the kernel to boot our-way</H2
><P
>Once we discovered the kernel was indeed booting, but the console wasn't printing, it was time to begin.
First, we forced the kernel to boot using a specified configuration for the serial port,
in our case <TT
CLASS="envar"
>9600n1</TT
>, and did not allow any command line options or boot time considerations etc.</P
><P
>The first place to go is <TT
CLASS="filename"
>drivers/char/tty_io.c</TT
>, to <TT
CLASS="function"
>console_init()</TT
>.
This function determines the console configuration at startup. Here's a small part of it:

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;memset(, 0, sizeof(struct termios));
memcpy(tty_std_termios.c_cc, INIT_C_CC, NCCS);
tty_std_termios.c_iflag = ICRNL | IGNPAR;
tty_std_termios.c_oflag = OPOST | ONLCR;
tty_std_termios.c_cflag = CLOCAL | B9600 | CS8 | CREAD;
tty_std_termios.c_cflag &#38;= ~(CRTSCTS);
tty_std_termios.c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHOCTL | ECHOKE | IEXTEN;
tty_std_termios.c_iflag = ICRNL | IXON;
tty_std_termios.c_oflag = OPOST | ONLCR;
tty_std_termios.c_cflag = B38400 | CS8 | CREAD | HUPCL;
tty_std_termios.c_lflag = ISIG | ICANON | ECHO | ECHOE | ECHOK | ECHOCTL | ECHOKE | IEXTEN;
</PRE
></FONT
></TD
></TR
></TABLE
>

The first (naive) thing we tried, was to configure the console the way we wanted.
<EM
>Of course, this didn't help us much ;-)</EM
></P
><P
>Disappointed but not discouraged, we remembered that we didn't have a bootloader yet, and that we didn't
really know if any option was being  passed on to the kernel. <SPAN
CLASS="QUOTE"
>"Maybe the kernel gets some garbage for command line?"</SPAN
> 
we (again, naively) thought. So we tried to stop the kernel from parsing command-line options, and manually
inserted our command line. <EM
>This didn't help us much ;-)</EM
></P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN219"
></A
>3.3.2. Non-standard hardware - just say no!</H2
><P
>At that point, we didn't have a console, but we had time. So we dove a bit deeper into the console
issues. Looking at <TT
CLASS="filename"
>drivers/char/serial.c</TT
>, 
we came across <TT
CLASS="function"
>serial_console_setup()</TT
>. This function, apart from parsing command-line
options, also configures the serial port by writing directly to it. Our hardware people 
decided it was a good time to let us know that our serial port wasn't standard. The lines that are used for
flow control were not connected.  We decided to remark-out the following line, which sets the RTS and DTR
lines high, because we just didn't have them.

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>serial_out(info, UART_MCR, UART_MCR_DTR | UART_MCR_RTS);</PRE
></FONT
></TD
></TR
></TABLE
>
<EM
>Ofcourse, this didn't help us much :-(</EM
>
The lesson learned here was <EM
>check, check, check your hardware!</EM
>.  Custom boards might
not be standard, and the porting will go a lot quicker if you know about it.</P
></DIV
><DIV
CLASS="sect2"
><H2
CLASS="sect2"
><A
NAME="AEN227"
></A
>3.3.3. Let there be light: calculating baud rate</H2
><P
>Finally, we decided to check the baudrate. Did Linux mean what we thought it meant when it said
9600? Possibly not, since we didn't know how it computed that value. We've noticed that the file(s)
<TT
CLASS="filename"
>include/asm-ppc/pmppc_serial.h</TT
>  (replace pmppc with your board name) included a definition
of <TT
CLASS="envar"
>BAUDBASE</TT
>, which is later used for everything regarding serial ports. It was computed
using the board's local bus frequency, bus clock to system clock ratio etc. This seemed wrong, so we checked 
out what the base baud was in a vxWorks system we had running on the board, and changed it to:

<TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>&#13;/*
 * system clock = 33Mhz, serial clock = system clock / 4
 * the following must hold: (divisor * BaudRate) == (System clock / 64)
 */
#define BASE_BAUD (33000000 / 4 / 16)
</PRE
></FONT
></TD
></TR
></TABLE
>

A quick compilation, and a reboot later we had a booting kernel visible through our serial port.  Success!
</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x197.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c233.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Modifying code using compiler flags</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c184.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Linux Still Isn't Booting</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>