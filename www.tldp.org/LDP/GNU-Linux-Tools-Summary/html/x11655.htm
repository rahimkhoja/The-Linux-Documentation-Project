<HTML
><HEAD
><TITLE
>Wildcards</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REL="HOME"
TITLE="GNU/Linux Command-Line Tools Summary"
HREF="book1.htm"><LINK
REL="UP"
TITLE="Mini-Guides"
HREF="c11412.htm"><LINK
REL="PREVIOUS"
TITLE="Duplicating disks"
HREF="x11606.htm"><LINK
REL="NEXT"
TITLE="Appendix"
HREF="a12264.htm"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GNU/Linux Command-Line Tools Summary</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="x11606.htm"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 20. Mini-Guides</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="a12264.htm"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="WILDCARDS"
></A
>Wildcards</H1
><P
>Wildcards are useful in many ways for a GNU/Linux system and for various other uses. Commands can use wildcards <A
NAME="AEN11658"
></A
>to perform <A
NAME="AEN11660"
></A
>actions on more <A
NAME="AEN11662"
></A
>than one file at a time,<A
NAME="AEN11664"
></A
> or to find <A
NAME="AEN11666"
></A
>part of a phrase <A
NAME="AEN11668"
></A
>in a text <A
NAME="AEN11670"
></A
>file. There are many uses for wildcards, there are two different <A
NAME="AEN11672"
></A
>major <A
NAME="AEN11674"
></A
>ways that wildcards are used, they are globbing <A
NAME="AEN11676"
></A
>patterns/standard wildcards that are often used by the shell.<A
NAME="AEN11678"
></A
> The alternative <A
NAME="AEN11680"
></A
>is regular expressions, popular <A
NAME="AEN11682"
></A
>with many other commands and popular <A
NAME="AEN11684"
></A
>for use with text searching <A
NAME="AEN11686"
></A
>and manipulation.<A
NAME="AEN11688"
></A
></P
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>Tip: </B
> 
  If you have a file with wildcard expressions in it then you can use single quotes to stop bash expanding them or use backslashes (escape characters), or both. </P
><P
>For example if you wanted to create a file called 'fo*' (fo and asterisk) you would have to do it like this (note that you shouldn't create files with names like this, this is just an example):
  <PRE
CLASS="SCREEN"
>  touch 'fo*' 
  </PRE
>
  </P
></BLOCKQUOTE
></DIV
><P
>Note that parts <A
NAME="AEN11696"
></A
>of both subsections <A
NAME="AEN11698"
></A
>on wildcards are based (at least <A
NAME="AEN11700"
></A
>in part) off <A
NAME="AEN11702"
></A
>the grep <A
NAME="AEN11704"
></A
>manual <A
NAME="AEN11706"
></A
>and info <A
NAME="AEN11708"
></A
>pages. Please see the <A
HREF="b12722.htm"
><I
>Bibliography</I
></A
> for further information.</P
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="STANDARD-WILDCARDS"
></A
>Standard Wildcards (globbing patterns)</H2
><P
>Standard wildcards<A
NAME="AEN11714"
></A
> (also known as globbing patterns<A
NAME="AEN11716"
></A
>) are used by various command-line utilities <A
NAME="AEN11718"
></A
>to work with multiple <A
NAME="AEN11720"
></A
>files. For more information on standard wildcards (globbing patterns) refer <A
NAME="AEN11722"
></A
>to the manual page <A
NAME="AEN11724"
></A
>by typing:</P
><PRE
CLASS="SCREEN"
>man 7 glob</PRE
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Can be used by: </B
> 
  Standard wildcards are used by nearly any command (including mv, cp, rm and many others).
  </P
></BLOCKQUOTE
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>?&nbsp;(question&nbsp;mark)<A
NAME="AEN11733"
></A
></DT
><DD
><P
>this can represent <A
NAME="AEN11737"
></A
>any <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>single </I
></SPAN
>character. If you specified <A
NAME="AEN11740"
></A
>something at the command line like &quot;hd?&quot; GNU/Linux would look <A
NAME="AEN11742"
></A
>for hda,<A
NAME="AEN11744"
></A
> hdb,<A
NAME="AEN11746"
></A
> hdc <A
NAME="AEN11748"
></A
>and every other letter/number between a-z,<A
NAME="AEN11750"
></A
> 0-9.</P
></DD
><DT
>*&nbsp;(asterisk)<A
NAME="AEN11754"
></A
></DT
><DD
><P
>this can represent <A
NAME="AEN11758"
></A
>any number of characters <A
NAME="AEN11760"
></A
>(including zero,<A
NAME="AEN11762"
></A
> in other words, zero <A
NAME="AEN11764"
></A
>or more characters). If you specified <A
NAME="AEN11766"
></A
>a &quot;cd*&quot; it would use &quot;cda&quot;, &quot;cdrom&quot;<A
NAME="AEN11768"
></A
>, &quot;cdrecord&quot;<A
NAME="AEN11770"
></A
> and <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>anything</I
></SPAN
> that starts <A
NAME="AEN11773"
></A
>with &ldquo;cd&rdquo; also including <A
NAME="AEN11775"
></A
>&ldquo;cd&rdquo; itself. &quot;m*l&quot; could by mill, mull,<A
NAME="AEN11777"
></A
> ml, and anything that starts with an m and ends<A
NAME="AEN11779"
></A
> with an l.</P
></DD
><DT
>[&nbsp;]&nbsp;(square&nbsp;brackets)<A
NAME="AEN11783"
></A
></DT
><DD
><P
>specifies <A
NAME="AEN11787"
></A
>a range.<A
NAME="AEN11789"
></A
> If you did m[a,o,u]m it can become: mam, mum,<A
NAME="AEN11791"
></A
> mom <A
NAME="AEN11793"
></A
>if you did: m[a-d]m it can become anything that starts and ends <A
NAME="AEN11795"
></A
>with m and has any character <A
NAME="AEN11797"
></A
>a to d inbetween. For example, these would work: mam, mbm,<A
NAME="AEN11799"
></A
> mcm,<A
NAME="AEN11801"
></A
> mdm.<A
NAME="AEN11803"
></A
> This kind of wildcard specifies <A
NAME="AEN11805"
></A
>an &ldquo;or&rdquo; relationship <A
NAME="AEN11807"
></A
>(you only need one to match).</P
></DD
><DT
>{&nbsp;}&nbsp;(curly&nbsp;brackets)<A
NAME="AEN11811"
></A
></DT
><DD
><P
>terms <A
NAME="AEN11815"
></A
>are separated <A
NAME="AEN11817"
></A
>by commas <A
NAME="AEN11819"
></A
>and each term <A
NAME="AEN11821"
></A
>must be the name of something or a wildcard. This wildcard will copy anything that matches either wildcard(s), or exact<A
NAME="AEN11823"
></A
> name(s) (an &ldquo;or&rdquo; relationship,<A
NAME="AEN11825"
></A
> one or the other).</P
><P
>For example, this would be valid:<A
NAME="AEN11828"
></A
></P
><PRE
CLASS="SCREEN"
>cp {*.doc,*.pdf} ~</PRE
><P
>This will copy anything ending <A
NAME="AEN11832"
></A
>with .doc <A
NAME="AEN11834"
></A
>or .pdf <A
NAME="AEN11836"
></A
>to the users home <A
NAME="AEN11838"
></A
>directory.<A
NAME="AEN11840"
></A
> Note that spaces <A
NAME="AEN11842"
></A
>are not allowed <A
NAME="AEN11844"
></A
>after the commas <A
NAME="AEN11846"
></A
>(or anywhere else).</P
></DD
><DT
>[!]</DT
><DD
><P
><A
NAME="AEN11852"
></A
>This construct is similar to the [&nbsp;] construct, except rather than matching <A
NAME="AEN11854"
></A
>any characters <A
NAME="AEN11856"
></A
>inside <A
NAME="AEN11858"
></A
>the brackets,<A
NAME="AEN11860"
></A
> it'll match <A
NAME="AEN11862"
></A
>any character,<A
NAME="AEN11864"
></A
> as long <A
NAME="AEN11866"
></A
>as it is not listed <A
NAME="AEN11868"
></A
>between the [ and ]. This is a logical <A
NAME="AEN11870"
></A
>NOT.<A
NAME="AEN11872"
></A
> For example<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
> rm <A
NAME="AEN11875"
></A
>myfile[!9]</I
></SPAN
> will remove <A
NAME="AEN11877"
></A
>all myfiles* (ie. myfiles1,<A
NAME="AEN11879"
></A
> myfiles2 <A
NAME="AEN11881"
></A
>etc) but won't remove <A
NAME="AEN11883"
></A
>a file with the number 9 anywhere within it's name.</P
></DD
><DT
>\&nbsp;(backslash)<A
NAME="AEN11887"
></A
></DT
><DD
><P
>is used as an &quot;escape&quot; character,<A
NAME="AEN11891"
></A
> i.e. to protect <A
NAME="AEN11893"
></A
>a subsequent <A
NAME="AEN11895"
></A
>special character.<A
NAME="AEN11897"
></A
> Thus, &quot;\\&rdquo; searches <A
NAME="AEN11899"
></A
>for a backslash.<A
NAME="AEN11901"
></A
> Note you may need to use quotation <A
NAME="AEN11903"
></A
>marks and backslash(es).</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="REGULAR-EXPRESSIONS"
></A
>Regular Expressions</H2
><P
>Regular expressions are a type of globbing pattern <A
NAME="AEN11908"
></A
>used when working with text. They are used for any form <A
NAME="AEN11910"
></A
>of manipulation <A
NAME="AEN11912"
></A
>of multiple <A
NAME="AEN11914"
></A
>parts <A
NAME="AEN11916"
></A
>of text <A
NAME="AEN11918"
></A
>and by various programming <A
NAME="AEN11920"
></A
>languages that work with text. For more information <A
NAME="AEN11922"
></A
>on regular expressions refer <A
NAME="AEN11924"
></A
>to the manual page or try an online tutorial, for example IBM Developerworks<A
NAME="AEN11926"
></A
> <A
HREF="https://www6.software.ibm.com/developerworks/education/l-regexp/index.html"
TARGET="_top"
>using regular expressions</A
>. For the manual <A
NAME="AEN11929"
></A
>page <A
NAME="AEN11931"
></A
>type:</P
><P
>Type:</P
><PRE
CLASS="SCREEN"
>man 7 regex</PRE
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>Regular expressions can be used by: </B
>  
  Regular Expressions are used by <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>grep</I
></SPAN
> (and can be used) by <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>find </I
></SPAN
>and many other programs. 
  </P
></BLOCKQUOTE
></DIV
><DIV
CLASS="TIP"
><BLOCKQUOTE
CLASS="TIP"
><P
><B
>Tip: </B
>If your regular expressions don't seem to be working then you probably need to use single quotation marks over the sentence and then use backslashes on every single special character.</P
></BLOCKQUOTE
></DIV
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>.&nbsp;(dot)<A
NAME="AEN11946"
></A
></DT
><DD
><P
>will match <A
NAME="AEN11950"
></A
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>any single character</I
></SPAN
>, equivalent <A
NAME="AEN11953"
></A
>to ? (question mark) in standard wildcard<A
NAME="AEN11955"
></A
> expressions.<A
NAME="AEN11957"
></A
> Thus, &quot;m.a&quot; matches &quot;mpa&quot; and &quot;mea&quot; but not &quot;ma&quot; or &quot;mppa&quot;. </P
></DD
><DT
>\&nbsp;(backslash)<A
NAME="AEN11961"
></A
></DT
><DD
><P
>is used as an &quot;escape&quot; character,<A
NAME="AEN11965"
></A
> i.e. to protect <A
NAME="AEN11967"
></A
>a subsequent <A
NAME="AEN11969"
></A
>special character.<A
NAME="AEN11971"
></A
> Thus, &quot;\\&quot; searches <A
NAME="AEN11973"
></A
>for a backslash.<A
NAME="AEN11975"
></A
> Note you may need to use quotation <A
NAME="AEN11977"
></A
>marks and backslash(es).</P
></DD
><DT
>.*&nbsp;(dot&nbsp;and&nbsp;asterisk)<A
NAME="AEN11981"
></A
></DT
><DD
><P
>is used to match <A
NAME="AEN11985"
></A
>any string,<A
NAME="AEN11987"
></A
> equivalent <A
NAME="AEN11989"
></A
>to * in standard wildcards.</P
></DD
><DT
>*&nbsp;(asterisk)<A
NAME="AEN11993"
></A
></DT
><DD
><P
>the proceeding <A
NAME="AEN11997"
></A
>item is to be matched <A
NAME="AEN11999"
></A
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
> zero <A
NAME="AEN12002"
></A
>or more<A
NAME="AEN12004"
></A
></I
></SPAN
> times.<A
NAME="AEN12006"
></A
> ie. n* will match <A
NAME="AEN12008"
></A
>n, nn,<A
NAME="AEN12010"
></A
> nnnn,<A
NAME="AEN12012"
></A
> nnnnnnn <A
NAME="AEN12014"
></A
>but not na or any other character.<A
NAME="AEN12016"
></A
></P
></DD
><DT
>^&nbsp;(caret)<A
NAME="AEN12020"
></A
></DT
><DD
><P
>means &quot;the beginning <A
NAME="AEN12024"
></A
>of the line&quot;. So &quot;^a&quot; means find a line <A
NAME="AEN12026"
></A
>starting <A
NAME="AEN12028"
></A
>with an &quot;a&quot;.</P
></DD
><DT
>$&nbsp;(dollar&nbsp;sign)<A
NAME="AEN12032"
></A
></DT
><DD
><P
>means &quot;the end <A
NAME="AEN12036"
></A
>of the line&quot;. So &quot;a$&quot; means find a line ending with an &quot;a&quot;.</P
><P
>For example, this command searches <A
NAME="AEN12039"
></A
>the file myfile <A
NAME="AEN12041"
></A
>for lines <A
NAME="AEN12043"
></A
>starting with an &quot;s&quot; and ending <A
NAME="AEN12045"
></A
>with an &quot;n&quot;, and prints <A
NAME="AEN12047"
></A
>them to the standard output <A
NAME="AEN12049"
></A
>(screen):</P
><PRE
CLASS="SCREEN"
>cat myfile | grep '^s.*n$'</PRE
></DD
><DT
>[&nbsp;]&nbsp;(square&nbsp;brackets)<A
NAME="AEN12054"
></A
></DT
><DD
><P
>specifies <A
NAME="AEN12058"
></A
>a range.<A
NAME="AEN12060"
></A
> If you did m[a,o,u]m it can become: mam, mum,<A
NAME="AEN12062"
></A
> mom <A
NAME="AEN12064"
></A
>if you did: m[a-d]m it can become anything that starts <A
NAME="AEN12066"
></A
>and ends <A
NAME="AEN12068"
></A
>with m and has any character <A
NAME="AEN12070"
></A
>a to d inbetween. For example, these would work: mam, mbm,<A
NAME="AEN12072"
></A
> mcm,<A
NAME="AEN12074"
></A
> mdm.<A
NAME="AEN12076"
></A
> This kind of wildcard specifies <A
NAME="AEN12078"
></A
>an &ldquo;or&rdquo; relationship <A
NAME="AEN12080"
></A
>(you only need one to match).</P
></DD
><DT
>|</DT
><DD
><P
><A
NAME="AEN12086"
></A
>This wildcard <A
NAME="AEN12088"
></A
>makes a logical <A
NAME="AEN12090"
></A
>OR <A
NAME="AEN12092"
></A
>relationship <A
NAME="AEN12094"
></A
>between wildcards.<A
NAME="AEN12096"
></A
> This way you can search <A
NAME="AEN12098"
></A
>for something or something else (possibly using two different regular expressions). You may need to add <A
NAME="AEN12100"
></A
>a '\' (backslash) before this command to work, because the shell may attempt<A
NAME="AEN12102"
></A
> to interpret <A
NAME="AEN12104"
></A
>this as a pipe.<A
NAME="AEN12106"
></A
></P
></DD
><DT
>[^]</DT
><DD
><P
><A
NAME="AEN12112"
></A
>This is the equivalent <A
NAME="AEN12114"
></A
>of [!]<A
NAME="AEN12116"
></A
> in standard wildcards.<A
NAME="AEN12118"
></A
> This performs <A
NAME="AEN12120"
></A
>a logical <A
NAME="AEN12122"
></A
>&ldquo;not&rdquo;. This will match <A
NAME="AEN12124"
></A
>anything that is not listed within those square <A
NAME="AEN12126"
></A
>brackets. For example,<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
> rm <A
NAME="AEN12129"
></A
>myfile[^9]</I
></SPAN
> will remove <A
NAME="AEN12131"
></A
>all myfiles* (ie. myfiles1,<A
NAME="AEN12133"
></A
> myfiles2 <A
NAME="AEN12135"
></A
>etc) but won't remove <A
NAME="AEN12137"
></A
>a file with the number <A
NAME="AEN12139"
></A
>9 anywhere within it's name.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="USEFUL-POSIX-CHARACTERS"
></A
>Useful&nbsp;categories&nbsp;of&nbsp;characters&nbsp;(as&nbsp;defined&nbsp;by&nbsp;the&nbsp;POSIX&nbsp;standard)</H2
><P
>This information has been taken from the grep <A
NAME="AEN12144"
></A
>info <A
NAME="AEN12146"
></A
>page <A
NAME="AEN12148"
></A
>with a tiny <A
NAME="AEN12150"
></A
>amount<A
NAME="AEN12152"
></A
> of editing,<A
NAME="AEN12154"
></A
> see [10] in the <A
HREF="b12722.htm"
><I
>Bibliography</I
></A
> for further information.</P
><P
></P
><UL
><LI
><P
>[:upper:] uppercase <A
NAME="AEN12160"
></A
>letters</P
></LI
><LI
><P
>[:lower:] lowercase <A
NAME="AEN12164"
></A
>letters </P
></LI
><LI
><P
>[:alpha:] alphabetic <A
NAME="AEN12168"
></A
>(letters) meaning upper+lower (both uppercase and lowercase letters)</P
></LI
><LI
><P
>[:digit:] numbers <A
NAME="AEN12172"
></A
>in decimal,<A
NAME="AEN12174"
></A
> 0 to 9 </P
></LI
><LI
><P
>[:alnum:] alphanumeric <A
NAME="AEN12178"
></A
>meaning alpha+digits (any uppercase or lowercase letters <A
NAME="AEN12180"
></A
>or any decimal <A
NAME="AEN12182"
></A
>digits)</P
></LI
><LI
><P
>[:space:] whitespace <A
NAME="AEN12186"
></A
>meaning spaces,<A
NAME="AEN12188"
></A
> tabs,<A
NAME="AEN12190"
></A
> newlines <A
NAME="AEN12192"
></A
>and similar</P
></LI
><LI
><P
>[:graph:] graphically printable <A
NAME="AEN12196"
></A
>characters excluding <A
NAME="AEN12198"
></A
>space</P
></LI
><LI
><P
>[:print:] printable <A
NAME="AEN12202"
></A
>characters including <A
NAME="AEN12204"
></A
>space<A
NAME="AEN12206"
></A
></P
></LI
><LI
><P
>[:punct:] punctuation <A
NAME="AEN12210"
></A
>characters meaning graphical <A
NAME="AEN12212"
></A
>characters minus <A
NAME="AEN12214"
></A
>alpha<A
NAME="AEN12216"
></A
> and digits<A
NAME="AEN12218"
></A
></P
></LI
><LI
><P
>[:cntrl:] control <A
NAME="AEN12222"
></A
>characters meaning non-printable characters<A
NAME="AEN12224"
></A
></P
></LI
><LI
><P
>[:xdigit:] characters <A
NAME="AEN12228"
></A
>that are hexadecimal <A
NAME="AEN12230"
></A
>digits. </P
></LI
></UL
><DIV
CLASS="NOTE"
><BLOCKQUOTE
CLASS="NOTE"
><P
><B
>These are used with: </B
> 
The above commands will work with most tools which work with text (for example: <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>tr</I
></SPAN
>). </P
></BLOCKQUOTE
></DIV
><P
>For example (advanced example)<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>,</I
></SPAN
> this command scans <A
NAME="AEN12238"
></A
>the output <A
NAME="AEN12240"
></A
>of the dir <A
NAME="AEN12242"
></A
>command, and prints <A
NAME="AEN12244"
></A
>lines <A
NAME="AEN12246"
></A
>containing a capital <A
NAME="AEN12248"
></A
>letter followed <A
NAME="AEN12250"
></A
>by a digit:<A
NAME="AEN12252"
></A
> </P
><PRE
CLASS="SCREEN"
>ls -l | grep '[[:upper:]][[:digit:]]'</PRE
><P
>The command greps for [upper_case_letter][any_digit], meaning any uppercase<A
NAME="AEN12256"
></A
> letter <A
NAME="AEN12258"
></A
>followed by any digit.<A
NAME="AEN12260"
></A
> If you remove the [&nbsp;] (square brackets) in the middle <A
NAME="AEN12262"
></A
>it would look for an uppercase letter or a digit, because it would become [upper_case_letter&nbsp;any_digit]</P
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="x11606.htm"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.htm"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="a12264.htm"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Duplicating disks</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="c11412.htm"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Appendix</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>