<HTML>
<center>
<A HREF="../tlk-toc.html"> Table of Contents</A>, 
<A href="../tlk.html" target="_top"> Show Frames</A>, 
<A href="../basics/hw.html" target="_top"> No Frames</A> 
</center>
<hr>
<META NAME="TtH" CONTENT="1.03">                                          

<p>
                  <H1><A NAME="tth_chAp1">Chapter 1     <br>Hardware Basics</H1>
<img src="../logos/sit3-bw-tran.1.gif"><br>
<p>
<A NAME="hw-basics-chapter"></A> <tt><b></tt></b> 
An operating system has to work closely with the hardware system that acts as
its foundations.   The operating system needs certain services that can only
be provided by the hardware.  
In order to fully understand the Linux operating system, you need to 
understand the basics of the underlying hardware.
This chapter gives a brief introduction to that hardware: the modern PC.

<p>
When the ``Popular Electronics'' magazine for January 1975 was printed with an
illustration of the Altair 8080 on its front cover, a revolution started.
The Altair 8080, named after the destination of an early Star Trek episode,
could be assembled by home electronics enthusiasts for a mere $397.
With its Intel 8080 processor and 256 bytes of memory but no screen or
keyboard it was puny by today's standards. 
Its inventor, Ed Roberts, coined the term ``personal computer'' to describe
his new invention, but the term PC is now used to refer to almost any computer that you can pick 
up without needing help.
By this definition, even some of the very powerful Alpha AXP systems are PCs. 

<p>
Enthusiastic hackers saw the Altair's potential and started to write software and 
build hardware for it.
To these early pioneers it represented freedom; the freedom from huge batch 
processing mainframe systems run and guarded by an elite priesthood.
Overnight fortunes were made by college dropouts fascinated by this new 
phenomenon, a computer that you could have at home on your kitchen table.
A lot of hardware appeared, all different to some degree and software hackers
were happy to write software for these new machines.
Paradoxically it was IBM who firmly cast the mould of the modern PC by 
announcing the IBM PC in 1981 and shipping it to customers early in 1982.
With its Intel 8088 processor, 64K of memory (expandable to 256K), two 
floppy disks and an 80 character by 25 lines Colour Graphics Adapter (CGA) 
it was not very powerful by today's standards but it sold well.
It was followed, in 1983, by the IBM PC-XT which had the luxury of a 
10Mbyte hard drive.
It was not long before IBM PC clones were being produced by a host of companies
such as Compaq and the architecture of the PC became a de-facto standard.
This de-facto standard helped a multitude of hardware companies to compete together in
a growing market which, happily for consumers, kept prices low.
Many of the system architectural features of these early PCs have carried over 
into the modern PC.  For example, even the most powerful Intel Pentium 
Pro based system starts running in the Intel 8086's addressing mode.
When Linus Torvalds started writing what was to become Linux, he picked
the most plentiful and reasonably priced hardware, an Intel 80386 PC.

<p>

<p><A NAME="tth_fIg1.1"></A> 
<center><center> <img src="board.gif"><br> 
<p>
</center></center><center>      Figure 1.1: A typical PC motherboard.</center>
<A NAME="motherboard-figure"></A>
<p>
<p>Looking at a PC from the outside, the most obvious components are a 
system box, a keyboard, a mouse and a video monitor.   On the front of 
the system box are some buttons, a little display showing some numbers and a 
floppy drive.  Most systems these days have a CD ROM and if you feel that 
you have to protect your data, then there will also be a tape drive for 
backups.   These devices are collectively known as the peripherals.  

<p>
Although the CPU is in overall control of the system, it is not the only 
intelligent device.  All of the peripheral controllers, for example the IDE
controller, have some level of intelligence.
Inside the PC (Figure&nbsp;<A href="#motherboard-figure"
> 1.1</A>) you will see a motherboard 
containing the CPU or microprocessor, the memory and a number of slots 
for the ISA or PCI peripheral controllers.
Some of the controllers, for example the IDE disk controller may be built 
directly onto the system board.

<p>

<H2><A NAME="tth_sEc1.1">1.1&nbsp;</A> The CPU</H2>

<p>
The CPU, or rather microprocessor, is the heart of any computer system.  
The microprocessor  calculates, performs logical operations and 
manages data flows by reading instructions from memory and then executing
them.
In the early days of computing the functional components of the 
microprocessor were separate (and physically large) units.
This is when the term <em>Central Processing Unit</em> was coined.
The modern microprocessor combines these components onto an 
integrated circuit etched onto a very small piece of silicon.
The terms <em>CPU</em>, <em>microprocessor</em> and <em>processor</em> are
all used interchangeably in this book. 

<p>
Microprocessors operate on binary data; that is data composed of
ones and zeros.

<p>
These ones and zeros correspond to electrical switches being either
on or off.
Just as 42 is a decimal number meaning ``4 10s and 2 units'', a binary
number is a series of binary digits each one representing a power
of 2.
In this context, a power means the number of times that
 a number is multiplied by itself. 10 to the power 1 (
10<sup>1</sup> ) is 10, 10 to
the power 2 ( 10<sup>2</sup> ) is 10x10, 10<sup>3</sup> is 10x10x10 and so on.
Binary 0001 is decimal 1, binary 0010 is decimal 2, binary 0011 is
3, binary 0100 is 4 and so on.
So, 42 decimal is 101010 binary or (2 + 8 + 32 or 2<sup>1</sup> + 2<sup>3</sup> + 2<sup>5</sup> ).
Rather than using binary to represent numbers in computer programs,
another base, hexadecimal is usually used.

<p>
In this base, each digital represents a power of 16.
As decimal numbers only go from 0 to 9 the numbers 10 to 15 are 
represented as a single digit by the letters A, B, C, D, E and F.
For example, hexadecimal E is decimal 14 and hexadecimal 2A is 
decimal 42 (two 16s) + 10).
Using the C programming language notation (as I do throughout this
book) hexadecimal numbers are prefaced by ``<em>0x</em>''; hexadecimal
2A is written as <em>0x2A</em> . 

<p>
Microprocessors can perform arithmetic operations such as add, multiply and
divide and logical operations such as ``is X greater than Y?''.

<p>
The processor's execution is governed by an external clock.
This clock, the system clock, generates regular clock pulses to the
processor and, at each clock pulse, the processor does some work.
For example, a processor could execute an instruction every clock
pulse.
A processor's speed is described in terms of the rate of the system
clock ticks.
A 100Mhz processor will receive 100,000,000 clock ticks every second.
It is misleading to describe the power of a CPU by its clock rate
as different processors perform different amounts of work per
clock tick.
However, all things being equal, a faster clock speed means a more
powerful processor.
The instructions executed by the processor are very simple; for example ``read the 
contents of memory at location X into register Y''.
Registers are the microprocessor's internal storage, used for storing
data and performing operations on it.
The operations performed may cause the processor to stop what it is
doing and jump to another instruction somewhere else in memory.
These tiny building blocks give the modern microprocessor almost
limitless power as it can execute millions or even billions 
of instructions a second.

<p>
The instructions have to be fetched from memory as they are executed.
Instructions may themselves reference data within memory and that data must
be fetched from memory and saved there when appropriate.

<p>
The size, number and type of register within a microprocessor is entirely
dependent on its type.
An Intel 4086 processor has a different register set to an Alpha AXP&nbsp;processor; 
for 
a start, the Intel's are 32 bits wide and the Alpha AXP's are 64 bits wide.
In general, though, any given processor will have a number of general purpose
registers and a smaller number of dedicated registers.  Most processors have
the following special purpose, dedicated, registers:

<DL compact>
<p>
	<dt><b>Program Counter (PC)</b></dt><dd> This register contains the address of 
	the next instruction to be executed.  The contents of the PC are 
	automatically incremented each time an instruction is fetched,

<p>
	<dt><b>Stack Pointer (SP)</b></dt><dd> Processors have to have access to large 
	amounts of external read/write random access memory (RAM) which facilitates 
	temporary storage of data.  The stack is a way of easily saving and 
	restoring temporary values in external memory.  Usually, processors 
	have special instructions which allow you to push values onto the 
	stack and to pop them off again later.  The stack
	works on a last in first out (LIFO) basis.
	In other words, if you push two values, x and y, onto a stack and then pop
	a value off of the stack then you will get back the value of y.

<p>
	Some processor's stacks grow upwards towards the top of memory whilst others
	grow downwards towards the bottom, or base, of memory.  Some processor's 
	support both types, for example ARM.

<p>
	<dt><b>Processor Status (PS)</b></dt><dd> Instructions may yield results; for 
	example ``is the content of register X greater than the content of 
	register Y?'' will yield true or false as a result.  The PS register 
	holds this and other information about the current state of the 
	processor.   For example, most processors have at least two modes of operation, 
	kernel (or supervisor) and user.  The PS register would hold information 
	identifying the current mode.
</DL>
<p>

<H2><A NAME="tth_sEc1.2">1.2&nbsp;</A> Memory</H2>
All systems have a memory hierarchy with memory at different speeds and sizes
at different points in the hierarchy.   The fastest memory is known as 
cache memory and is what it sounds like - memory that is used to temporarily hold, or cache, contents of the main memory.
This sort of memory is very fast but expensive, therefore most processors have
a small amount of on-chip cache memory and more system based (on-board) cache memory.
Some processors have one cache to contain both instructions and data, but others have two, one for instructions
and the other for data.
The Alpha AXP processor has two internal
memory caches; one for data (the D-Cache) and one for instructions (the 
I-Cache).
The external cache (or B-Cache) mixes the two together.   
Finally there is the main memory which relative to the external cache memory 
is very slow. 
Relative to the on-CPU cache, main memory is positively crawling.

<p>
The cache and main memories must be kept in step (coherent).  
In other words, if a word of main memory is held in one or more locations 
in cache, then the system must make sure that the contents of cache and 
memory are the same.  The job of cache coherency is done partially by the 
hardware and partially by the operating system.
This is also true for a number of major system tasks where the hardware and software
must cooperate closely to achieve their aims.

<p>

<H2><A NAME="tth_sEc1.3">1.3&nbsp;</A> Buses</H2>
The individual components of the system board are interconnected by 
multiple connection systems known as buses.
The system bus is divided into  three logical functions; the address bus,
the data bus and the control bus.
The address bus specifies the memory locations (addresses) for the data
transfers.
The data bus holds the data transfered.
The data bus is bidirectional; it allows data to be read into the CPU and
written from the CPU.
The control bus contains various lines used to route timing and control 
signals throughout the system.
Many flavours of bus exist, for example ISA and PCI buses are popular ways
of connecting peripherals to the system.

<p>

<H2><A NAME="tth_sEc1.4">1.4&nbsp;</A> Controllers and Peripherals</H2>
Peripherals are real devices, such as graphics cards or
disks controlled by controller chips on the system board or on cards plugged
into it.
The IDE disks are controlled by the IDE controller chip and the SCSI
disks by the SCSI disk controller chips and so on.
These controllers are connected to the CPU and to each other
by a variety of buses.
Most systems built now use PCI and ISA buses to connect
together the main system components.
The controllers are processors like the CPU itself, they can be
viewed as intelligent helpers to the CPU.
The CPU is in overall control of the system.

<p>
All controllers are different, but they usually have registers which 
control them.
Software running on the CPU must be able to read and write those controlling
registers.
One register might contain status describing an error.
Another might be used for control purposes; changing the mode of the
controller.
Each controller on a bus can be individually addressed by the CPU, this is 
so that the software device driver can write to its registers and thus 
control it.
The IDE ribbon is a good example, as it gives you the ability to access
each drive on the bus separately.
Another good example is the PCI bus which allows each device (for example a
graphics card) to be accessed independently.

<p>

<H2><A NAME="tth_sEc1.5">1.5&nbsp;</A> Address Spaces</H2>
The system bus connects the CPU with the main memory and is separate from the buses
connecting the CPU with the system's hardware peripherals.
Collectively the memory space that the hardware peripherals exist in is known as I/O space.
I/O space may itself be further subdivided, but we will not worry too much about that for the moment.
The CPU can access both the system space memory and the I/O space memory, whereas the controllers themselves
can only access system memory indirectly and then only with the help of the CPU.
From the point of view of the device, say the floppy disk controller, 
it will see only the address space that its control registers are in (ISA), 
and not the system memory.
Typically a CPU will have separate instructions for accessing the memory and I/O space.
For example, there might be an instruction that means ``read a byte from I/O address <em>0x3f0</em> into 
register X''.
This is exactly how the CPU controls the system's hardware peripherals, by reading and writing
to their registers in I/O space.
Where in I/O space the common peripherals (IDE controller, serial port, floppy disk
controller and so on) have their registers has been set by convention over the years as the PC
architecture has developed.
The I/O space address <em>0x3f0</em> just happens to be the address of one of the serial port's (COM1) 
control registers.

<p>
There are times when controllers need to read or write large amounts of data directly to or from
system memory.
For example when user data is being written to the hard disk.
In this case, Direct Memory Access (DMA) controllers are used to allow hardware peripherals to directly 
access system memory but this access is under strict control and supervision of
the CPU.

<p>

<H2><A NAME="tth_sEc1.6">1.6&nbsp;</A> Timers</H2>
All operating systems need to know the time and so the modern PC includes a special peripheral
called the Real Time Clock (RTC).
This provides two things: a reliable time of day and an accurate timing interval.
The RTC has its own battery so that it continues to run even when the PC is not powered on, this is
how your PC always ``knows'' the correct date and time.
The interval timer allows the operating system to accurately schedule essential work.

<p>

<p><hr><small>File translated from T<sub><font size=-1>E</font></sub>X by <a href="http://hutchinson.belmont.ma.us/tth/tth.html">T<sub><font size=-1>T</font></sub>H</a>, version 1.0.</small>
<hr>
<center>
<A HREF="../basics/hw.html"> Top of Chapter</A>, 
<A HREF="../tlk-toc.html"> Table of Contents</A>, 
<A href="../tlk.html" target="_top"> Show Frames</A>, 
<A href="../basics/hw.html" target="_top"> No Frames</A><br> 
© 1996-1999 David A Rusling <A HREF="../misc/copyright.html">copyright notice</a>.
</center>
</HTML>