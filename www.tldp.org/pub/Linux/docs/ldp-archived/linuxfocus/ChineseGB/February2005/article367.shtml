<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
 <META http-equiv="Content-Type" content="text/html; charset=gb2312">
 <META NAME="GENERATOR" CONTENT="lfparser_2.52">
 <META NAME="LFCATEGORY" CONTENT="KernelCorner">
 <link rel="icon" href="../../common/images/lf-16.png" type="image/png">
 <TITLE>lf367, KernelCorner: 自己写 Netfilter 匹配器</TITLE>
<style type="text/css">
<!--
 td.top {font-family: Arial,Geneva,Verdana,Helvetica,sans-serif; font-size:12 }
 pre { font-family:monospace,Courier }
 pre.code { font-family:monospace,Courier;background-color:#aedbe8; }
 p.cl { color:#EE9500 }
 table.left { margin-right:0.3cm }
 a.nodec { text-decoration:none }
 p.trans { font-size:8pt; text-align:right }
 p.clbox { width:50%; alignment:center; background-color:#FFD700; 
           border-style:none; border-width:medium; border-color:#FFD700; 
           padding:0.5cm;  text-align:center }
 p.code { width:80%; alignment:center; background-color:#aedbe8; 
          border-style:none; border-width:medium; border-color:#aedbe8; 
          padding:0.1cm;  text-align:left }
 p.foot { background-color:#AAAAAA; color:#FFFFFF; border-style:none; 
          border-width:medium; border-color:#AAAAAA; padding:0.5cm ; 
          margin-top:0.1cm; margin-right:1cm; margin-left:1cm; 
          text-align:center }
 div.tbbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   margin: 2px 5px 2px 5px;
   text-align: center;
   width: 20em;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
 div.bbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   float: left;
   margin: 2px 5px 2px 5px;
   text-align: center;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
-->
</style>
 
</HEAD>
<BODY bgcolor="#ffffff" text="#000000">
 <!-- this is generated html code. NEVER use this file for your
 translation work. Instead get the file with the same article number
 and .meta.shtml in its name. Translate this meta file and then
 use lfparser program to generate the final article -->
 <!-- lfparser can be obtained from http://main.linuxfocus.org/~guido/dev/lfparser.html -->

<!-- this is used by a number of tools:
 =LF=AUTHOR: Nicolas Bouliane
 =LF=CAT___: KernelCorner
 =LF=TITLE_: 自己写 Netfilter 匹配器
 =LF=NUMBER: 367
 =LF=ANAME_: article367.shtml
 =LF=PARSER: 2.52
 -->

<!-- 2pdaIgnoreStart -->

<!-- start navegation bar, current, style=2 -->
 <!-- top navegation bar -->
 <TABLE summary="topbar_1" cellspacing="0" cellpadding="0" border="0" align="center" width="90%">
   <TR bgcolor="#2e2292">
     <TD class="top"><TABLE summary="topbar_1_logo" cellspacing="0" cellpadding="0" border="0" width=
       "100%">
         <TR><TD width="319"><a href="../../index.shtml"><IMG src="../../common/images/logolftop_319x45.gif"
           alt="[LinuxFocus-icon]" width="319" height="45" align="left" 
           border="0"></a></TD>

           <TD class="top">
             <TABLE summary="topbar_1_links" width="100%">
               <TR align="right">
                 <TD class="top">
                 
                 <A class="nodec" href="../../index.shtml"><FONT color=
                 "#DDDDDD" size="2">&lt;--</FONT></A> &nbsp;| 
                 <A class="nodec" href="../map.html"><FONT color=
                 "#DDDDDD" size="2">站点地图</FONT></A> &nbsp;| 
                 <A class="nodec" href="../indice.html"><FONT color=
                 "#DDDDDD" size="2">索引</FONT></A> &nbsp;| 
                 <A class="nodec" href="../Search/index.shtml"><FONT color=
                 "#DDDDDD" size="2">搜索</FONT></A> </TD>
                 
               </TR>

               <TR align="right">
                 <TD class="top">
                   <HR width="100%" noshade size="1">
                 </TD>
               </TR>
             </TABLE>
           </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end top navegation bar -->
 <!-- blue bar -->
 <TABLE summary="topbar_2" cellspacing="0" cellpadding="0" border="0" align="center"
 width="90%">
   <TR bgcolor="#00ffff">
     <TD><IMG src="../../common/images/transpix.gif" width="1" height=
     "2" alt=""></TD>
   </TR>
 </TABLE>
 <!-- end blue bar -->
 <!-- bottom navegation bar -->
 <TABLE summary="topbar_3" cellspacing="0" cellpadding="0" border="0" align="center"
 width="94%">
   <TR bgcolor="#000000">
     <TD>
       <TABLE summary="topbar_3_links" cellspacing="0" cellpadding="1" border="0" width=
       "100%">
         <TR align="center">
           <TD WIDTH="20%"><A class="nodec" href="../News/index.shtml"><FONT color=
           "#FFFFFF">新闻</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Archives/"><FONT color=
           "#FFFFFF">过往期刊</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Links/index.shtml"><FONT color=
           "#FFFFFF">链接</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../aboutus.html"><FONT color=
           "#FFFFFF">关于LF</FONT></A> </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end bottom navegation bar -->
<!-- stop navegation bar -->

<!-- SSI_INFO -->

<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfdynahead ver 1.5 --><TABLE ALIGN="right" border=0><TR><TD ALIGN="right"><FONT SIZE="-1" FACE="Arial,Helvetica">This document is available in: <A href="../../English/February2005/article367.shtml">English</a> &nbsp;<A href="../../ChineseGB/February2005/article367.shtml">ChineseGB</a> &nbsp;<A href="../../Deutsch/February2005/article367.shtml">Deutsch</a> &nbsp;<A href="../../Francais/February2005/article367.shtml">Francais</a> &nbsp;</FONT></TD></TR></TABLE><br>
 


<!-- SSI_INFO STOP -->
<!-- 2pdaIgnoreStop -->

<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_START -->
<TABLE ALIGN="LEFT" BORDER="0" WIDTH="195" summary="about the author" class="left">
<TR>
<TD>

<img src="../../common/images2/NicolasBouliane.jpg" alt="Photo of Nicolas Bouliane">
<BR>by  Nicolas Bouliane <br> <small>&lt;nib(at)cookinglinux!org&gt;</small>
<BR><BR>
<I>关于作者:</I><BR>
<!-- aboutauthor_start -->

Nicolas 是自由软件界的一个年轻斗士。自从 1998 年在自己的计算机上安装了 Linux 之后，他就沉溺于此了。他长时间地研究 Linux 网络协议栈，写自由软件，并参加 OLS 等 Linux 相关的会议。当 Nicolas 不在计算机前的时候，他喜欢看科幻电影。下象棋和听 Richard Stallman 的访谈.


<!-- aboutauthor_stop -->
<!-- TRANSLATED_TO gb -->
<!-- TRANSLATED_TO_STOP -->
<!-- INDEX_START -->
<BR><i>目录</i>:
<UL>
  <LI><A HREF="#367lfindex0">概述</A></LI>
  <LI><A HREF="#367lfindex1">1.0 iptables 模块</A></LI>
  <LI><A HREF="#367lfindex2">1.1 可用的数据结构和函数</A></LI>
  <LI><A HREF="#367lfindex3">1.2 深入骨架程序</A></LI>
  <LI><A HREF="#367lfindex4">1.2.1 初始化</A></LI>
  <LI><A HREF="#367lfindex5">1.2.2 save 函数</A></LI>
  <LI><A HREF="#367lfindex6">1.2.3 print 函数</A></LI>
  <LI><A HREF="#367lfindex7">1.2.4 final check 函数</A></LI>
  <LI><A HREF="#367lfindex8">1.2.5 parse 函数</A></LI>
  <LI><A HREF="#367lfindex9">1.2.6 options 结构</A></LI>
  <LI><A HREF="#367lfindex10">1.2.7 init 函数</A></LI>
  <LI><A HREF="#367lfindex11">1.2.7 help 函数</A></LI>
  <LI><A HREF="#367lfindex12">1.2.8 头文件 'ipt_ipaddr.h'</A></LI>
  <LI><A HREF="#367lfindex13">1.3 第一章小结</A></LI>
  <LI><A HREF="#367lfindex14">2.0 netfilter 模块</A></LI>
  <LI><A HREF="#367lfindex15">2.1 可用的函数与数据结构</A></LI>
  <LI><A HREF="#367lfindex16">2.2 深入骨架程序</A></LI>
  <LI><A HREF="#367lfindex17">2.2.1 初始化</A></LI>
  <LI><A HREF="#367lfindex18">2.2.2 match 函数</A></LI>
  <LI><A HREF="#367lfindex19">2.2.3 checkentry 函数</A></LI>
  <LI><A HREF="#367lfindex20">2.3 第二章小结</A></LI>
  <LI><A HREF="#367lfindex21">3.0 运行 iptables/netfilter</A></LI>
  <LI><A HREF="#367lfindex22">3.1 iptables</A></LI>
  <LI><A HREF="#367lfindex23">3.2 内核</A></LI>
  <LI><A HREF="#367lfindex24">总结</A></LI>
  <LI><A HREF="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=367">对这篇文章发表评论</A></LI>
</UL>

</TD></TR></TABLE>
<!-- INDEX_STOP -->
<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_STOP -->
<!-- HEAD_OF_THE_ARTICLE_START -->
<br>&nbsp;
<table border="0"><tr><td>
<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfPdf ver 0.1 -->
 

<H2>自己写 Netfilter 匹配器</H2>
 <IMG SRC="../../common/images2/article367.png" ALT="[Illustration]" HSPACE=10>
<!-- ABSTRACT OF THE ARTICLE -->
<P><i>摘要</i>:
<P>
<!-- articleabstract_start -->

iptables/netfilter 框架让我们可以向其中添加功能。要添加功能，我们需要自己写一个内核模块并向这个框架注册。也就是说，依照要添加的功能的分类，写一个 iptables 模块。通过写自定义的扩展模块，你可以匹配、修改、增加保障措施、跟踪一个给定的包。事实上，你几乎可以在这个过滤的世界中做任何你想做的事情。

单要小心，内核模块中的一点错误有可能导致系统立刻崩溃。
<br><br>

简单起见，我将介绍一个我写的匹配器的骨架。通过这个骨架，我希望可以让这个和 iptables/netfilter 框架的交互更加易于理解。这里，我假设你已经对 iptables 有了一定了解并且会使用 C 语言。
<br><br>

这个例子将告诉你如何根据源或是目的 ip 地址来匹配一个包。

<!-- articleabstract_stop -->

<br><!-- HR divider --><center><font color="#8282e0"><b>_________________ _________________ _________________</b></font></center><br>
</td></tr></table>
<!-- HEAD_OF_THE_ARTICLE_STOP -->
<!-- BODY_OF_THE_ARTICLE_START -->



<A NAME="367lfindex0">&nbsp;</A>
<H2>概述</H2>


写一个 iptables/netfilter 匹配模块的大体步骤如下：
<ul>
  <li> 找到你要匹配的具体情况。</li>
  <li> 写用于接受参数的用户空间部分程序。</li>
  <li> 写用于分析包信息，得出是否匹配结论的内核空间部分程序。</li>
</ul>

<A NAME="367lfindex1">&nbsp;</A>
<H2>1.0 iptables 模块</H2>


iptables 库的用途基本上讲就是和用户交互，它捕获用户要传送给核心态程序的参数。

<A NAME="367lfindex2">&nbsp;</A>
<H2>1.1 可用的数据结构和函数</H2>

首先是一些基本数据结构。
&lt;<i>iptables/include/iptables.h</i>&gt;<br>
稍后文中就将可以看到这些结构的用途了。
<table width="70%"><tr><td>
<pre class="code">/* Include file for additions: new matches and targets. */
struct iptables_match
{
   struct iptables_match *next;

   ipt_chainlabel name;

   const char *version;

   /* Size of match data. */
   size_t size;

   /* Size of match data relevent for userspace comparison purposes */
   size_t userspacesize;

   /* Function which prints out usage message. */
   void (*help)(void);

   /* Initialize the match. */
   void (*init)(struct ipt_entry_match *m, unsigned int *nfcache);

   /* Function which parses command options; returns true if it
           ate an option */
   int (*parse)(int c, char **argv, int invert, unsigned int *flags,
           const struct ipt_entry *entry,
           unsigned int *nfcache,
           struct ipt_entry_match **match);

   /* Final check; exit if not ok. */
   void (*final_check)(unsigned int flags);

   /* Prints out the match iff non-NULL: put space at end */
   void (*print)(const struct ipt_ip *ip,
            const struct ipt_entry_match *match, int numeric);

   /* Saves the match info in parsable form to stdout. */
   void (*save)(const struct ipt_ip *ip,
           const struct ipt_entry_match *match);

   /* Pointer to list of extra command-line options */
   const struct option *extra_opts;

   /* Ignore these men behind the curtain: */
   unsigned int option_offset;
   struct ipt_entry_match *m;
   unsigned int mflags;
#ifdef NO_SHARED_LIBS
   unsigned int loaded; /* simulate loading so options are merged properly */
#endif
};
</pre>
</td></tr></table>

<A NAME="367lfindex3">&nbsp;</A>
<H2>1.2 深入骨架程序</H2>

<A NAME="367lfindex4">&nbsp;</A>
<H3>1.2.1 初始化</H3>


我们首先初始化 'iptables_match' 结构中的常用字段：

<pre class="code">static struct iptables_match ipaddr
= {
</pre>

'Name' 是你的函数库的文件名（也就是 libipt_ipaddr）。<br>
你不能在这个位置放其它的东西，这是用来自动加载你的库的。

<pre class="code">    .name            = "ipaddr",
</pre>

下一个字段 'version' 是 iptables 的版本。后面的两个字段都是用于保持用户态程序和核心态共享结构的大小一致性的。

<pre class="code">    .version         = IPTABLES_VERSION,
    .size            = IPT_ALIGN(sizeof(struct ipt_ipaddr_info)),
    .userspacesize   = IPT_ALIGN(sizeof(struct ipt_ipaddr_info)),
</pre>

'Help' 是用户输入 'iptables -m module -h' 的时候要调用的函数。'Parse' 是用户输入一条新规则的时候调用的，用于验证参数的合法性。'print' 就是使用 'iptables -L' 的时候显示前面添加的规则的。

<pre class="code">    .help            = &amp;help,
    .init            = &amp;init,
    .parse           = &amp;parse,
    .final_check     = &amp;final_check,
    .print           = &amp;print,
    .save            = &amp;save,
    .extra_opts      = opts
};
</pre>

iptables 架构能够支持多个共享库。每个共享库必须使用  &lt;<i>iptables/iptables.c</i>&gt; 中定义的 'register_match()' 向 iptables 注册。这个函数将在模块被 iptables 加载的时候调用。

更多信息请参考:'man dlopen'。
<pre class="code">void _init(void)
{
   register_match(&amp;ipaddr);
}
</pre>

<A NAME="367lfindex5">&nbsp;</A>
<H3>1.2.2 save 函数</H3>


如果我们有一个需要保存的规则集，可以利用 iptables 提供的工具 'iptables-save'，它可以保存下所有的规则。显然你需要扩展这个工具来保存下来这些规则。这个扩展通过 save 函数完成。

<pre class="code">static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
{
   const struct ipt_ipaddr_info *info = (const struct ipt_ipaddr_info *)match-&gt;data;
</pre>
如果源地址是规则的一部分的话，打印它。
<pre class="code">   if (info-&gt;flags &amp; IPADDR_SRC) {
      if (info-&gt;flags &amp; IPADDR_SRC_INV)
         printf("! ");
      printf("--ipsrc ");
      print_ipaddr((u_int32_t *)&amp;info-&gt;ipaddr.src);
   }
</pre>
如果目的地址是规则的一部分的话就打印目的地址。
<pre class="code">   if (info-&gt;flags &amp; IPADDR_DST) {
      if (info-&gt;flags &amp; IPADDR_DST_INV)
         printf("! ");
      printf("--ipdst ");
      print_ipaddr((u_int32_t *)&amp;info-&gt;ipaddr.dst);
   }
}
</pre>

<A NAME="367lfindex6">&nbsp;</A>
<H3>1.2.3 print 函数</H3>

和上面的 save 所蕴含的哲学一样，也有一个 print 函数用于打印规则。它在 'iptables -L' 的时候被调用。我们将在下文里看到参数 'ipt_entry_match *match' 的用途，不过我们已经对它有了一点概念了，是吧？

<pre class="code">static void print(const struct ipt_ip *ip,
                  const struct ipt_entry_match *match,
                  int numeric)
{
   const struct ipt_ipaddr_info *info = (const struct ipt_ipaddr_info *)match-&gt;data;

   if (info-&gt;flags &amp; IPADDR_SRC) {
         printf("src IP ");
      if (info-&gt;flags &amp; IPADDR_SRC_INV)
         printf("! ");
      print_ipaddr((u_int32_t *)&amp;info-&gt;ipaddr.src);
   }

   if (info-&gt;flags &amp; IPADDR_DST) {
      printf("dst IP ");
      if (info-&gt;flags &amp; IPADDR_DST_INV)
         printf("! ");
      print_ipaddr((u_int32_t *)&amp;info-&gt;ipaddr.dst);
   }
}
</pre>

<A NAME="367lfindex7">&nbsp;</A>
<H3>1.2.4 final check 函数</H3>

这个函数是最后一次正确性检查的机会。它在用户输入完规则之后、参数解析刚刚完成的时候被调用。

<pre class="code">static void final_check(unsigned int flags)
{
   if (!flags)
      exit_error(PARAMETER_PROBLEM, "ipt_ipaddr: Invalid parameters.");
}
</pre>

<A NAME="367lfindex8">&nbsp;</A>
<H3>1.2.5 parse 函数</H3>

parse 是最重要的一个函数，因为这里要检查参数的正确性，并写入我们将共享给核心态程序的信息。它在每次参数被发现的时候被调用，也就是说，如果用户输入了两个参数，这个函数就将被以不同的参数代码 c 调用两次。
<pre class="code">static int parse(int c, char **argv, int invert, unsigned int *flags,
                 const struct ipt_entry *entry,
                 unsigned int *nfcache,
                 struct ipt_entry_match **match)
{
</pre>

我们使用特殊结构来保存我们要传递给核心态程序的信息。'match' 指针被传递给多个函数，我们可以每次使用同样的数据结构。一旦规则被加载了，这个指针就被复制到了核心态程序里。通过这个方式，内核模块可以知道用户想要分析什么（这正是问题的关键，不是么?）。

<pre class="code">   struct ipt_ipaddr_info *info = (struct ipt_ipaddr_info *)(*match)-&gt;data;
</pre>

每个参数对应着一个单独的值，于是我们能根据进入的参数决定采取何种行动。下文中我们将看到我们如何把参数变成数值。
<br>
<pre class="code">   switch(c) {
</pre>

首先，我们检查参数是否被使用了多次。如果使用了多次的话，调用 &lt;<i>iptables/iptables.c</i>&gt; 中定义的 'exit_error()' 函数，这样程序会立刻带着  &lt;<i>iptables/include/iptables_common.h</i>&gt; 中定义的 'PARAMETER_PROBLEM' 的错误状态推出。否则，我们在我们的头文件中定义的 'IPADDR_SRC' 中设置 'flags' 和 'info-&gt;flags'。稍后我们将介绍这个头文件。
<br><br>
虽然这两个标志看起来差不多，但是是完全不同的。'flag' 的作用域就是这个函数，而 'info-&gt;flags' 是我们用于和核心态程序共享信息的结构的一部分。

<pre class="code">      case '1':
         if (*flags &amp; IPADDR_SRC)
            exit_error(PARAMETER_PROBLEM, "ipt_ipaddr: Only use --ipsrc once!");
         *flags |= IPADDR_SRC;
         info-&gt;flags |= IPADDR_SRC;
</pre>

检查如果取反标志 '!' 是否存在，如果有的话，在 'info-&gt;flags' 中写相应的值。<br>之后调用为这个骨架程序所写的内部函数 'parse_ipaddr' 来把 IP 地址从字符串转化为 32 位值。<br>

<pre class="code">         if (invert)
            info-&gt;flags |= IPADDR_SRC_INV;

         parse_ipaddr(argv[optind-1], &amp;info-&gt;ipaddr.src);
         break;
</pre>

同样考虑，我们检查是否存在多次设置，置恰当的标志。
<pre class="code">      case '2':
         if (*flags &amp; IPADDR_DST)
            exit_error(PARAMETER_PROBLEM, "ipt_ipaddr: Only use --ipdst once!");
         *flags |= IPADDR_DST;
         info-&gt;flags |= IPADDR_DST;
         if (invert)
            info-&gt;flags |= IPADDR_DST_INV;

         parse_ipaddr(argv[optind-1], &amp;info-&gt;ipaddr.dst);
         break;

      default:
         return 0;
   }

   return 1;
}
</pre>
<A NAME="367lfindex9">&nbsp;</A>
<H3>1.2.6 options 结构</H3>

前文中，我们已经谈到了要将每个参数映射到一个值。 'struct option' 就是一个达到这个目的的好办法。要想得到关于这个结构的进一步信息，强烈建议阅读 'man 3 getopt'。
<pre class="code">static struct option opts[] = {
   { .name = "ipsrc",   .has_arg = 1,   .flag = 0,   .val = '1' },
   { .name = "ipdst",   .has_arg = 1,   .flag = 0,   .val = '2' },
   { .name = 0 }
};

</pre>
<A NAME="367lfindex10">&nbsp;</A>
<H3>1.2.7 init 函数</H3>


init 函数用于初始化一些特定的东西，比如 netfilter 的 cache 系统。现在不必过多考虑这个函数的具体用途。
<pre class="code">static void init(struct ipt_entry_match *m, unsigned int *nfcache)
{
   /* Can't cache this */
   *nfcache |= NFC_UNKNOWN;
}

</pre>
<A NAME="367lfindex11">&nbsp;</A>
<H3>1.2.7 help 函数</H3>

这个函数通过 'iptables -m match_name -h' 被调用，用于显示可用的参数。
<pre class="code">static void help(void)
{
   printf (
            "IPADDR v%s options:\n"
            "[!] --ipsrc <ip>\t\t The incoming ip addr matches.\n"
            "[!] --ipdst <ip>\t\t The outgoing ip addr matches.\n"
            "\n", IPTABLES_VERSION
         );
}

</ip></ip></pre>
<A NAME="367lfindex12">&nbsp;</A>
<H3>1.2.8 头文件 'ipt_ipaddr.h'</H3>

这个文件定义了我们需要的一些东西。
<pre class="code">#ifndef _IPT_IPADDR_H
#define _IPT_IPADDR_H
</pre>
我们已经在上文中使用了这些特定的值了。
<pre class="code">#define IPADDR_SRC   0x01     /* Match source IP addr */
#define IPADDR_DST   0x02     /* Match destination IP addr */

#define IPADDR_SRC_INV  0x10  /* Negate the condition */
#define IPADDR_DST_INV  0x20  /* Negate the condition */
</pre>

结构 'ipt_ipaddr_info' 是将要被拷贝到核心态程序的那个数据结构。
<pre class="code">struct ipt_ipaddr {
   u_int32_t src, dst;
};

struct ipt_ipaddr_info {

   struct ipt_ipaddr ipaddr;

   /* Flags from above */
   u_int8_t flags;

};

#endif
</pre>

<A NAME="367lfindex13">&nbsp;</A>
<H2>1.3 第一章小结</H2>


第一部分中，我们讨论了 iptables 库的作用。我们记述了每个函数的内容和 'ipt_ipaddr_info' 这个用于保存信息的将要被拷贝到核心态程序来做进一步处理的重要结构。我们也看到了 iptables 结构和如何注册一个新的库。<br>

应该注意，这仅仅是一个用于演示框架如何工作的骨架程序。而且，'ipt_ipaddr_info' 和其他类似的东西并不是 iptables/netfilter 的一部分，而仅仅是这个例子的一部分。
<A NAME="367lfindex14">&nbsp;</A>
<H2>2.0 netfilter 模块</H2>

一个匹配模块的工作就是察看每一个收到的包并决定是否符合某个判决准则。这个模块要做如下工作：

<ul>
  <li>接收每个包，并察看匹配模块相关的表</li>
  <li>告知 netfilter，我们的模块是否匹配上了这个包</li>
</ul>

<A NAME="367lfindex15">&nbsp;</A>
<H2>2.1 可用的函数与数据结构</H2>

首先是一些基本数据结构，这些数据结构定义在  &lt;<i>linux/netfilter_ipv4/ip_tables.h</i>&gt;。

<br>
如果你对这个结构以及前面的 iptables 部分还有兴趣的话，你可以看看 Rusty Russell 和 Harald Welte 写的 <a href="http://www.netfilter.org/documentation/HOWTO/netfilter-hacking-HOWTO.html">netfilter hacking howto</a> 。

<pre class="code">struct ipt_match
{
   struct list_head list;

   const char name[IPT_FUNCTION_MAXNAMELEN];

   /* Return true or false: return FALSE and set *hotdrop = 1 to
           force immediate packet drop. */
   /* Arguments changed since 2.4, as this must now handle
           non-linear skbs, using skb_copy_bits and
           skb_ip_make_writable. */
   int (*match)(const struct sk_buff *skb,
           const struct net_device *in,
           const struct net_device *out,
           const void *matchinfo,
           int offset,
           int *hotdrop);

   /* Called when user tries to insert an entry of this type. */
   /* Should return true or false. */
   int (*checkentry)(const char *tablename,
           const struct ipt_ip *ip,
           void *matchinfo,
           unsigned int matchinfosize,
           unsigned int hook_mask);

   /* Called when entry of this type deleted. */
   void (*destroy)(void *matchinfo, unsigned int matchinfosize);

   /* Set this to THIS_MODULE. */
   struct module *me;
};
</pre>


<A NAME="367lfindex16">&nbsp;</A>
<H2>2.2 深入骨架程序</H2>

<A NAME="367lfindex17">&nbsp;</A>
<H3>2.2.1 初始化</H3>


<p>
首先,我们初始化 'ipt_match' 数据结构中的常用域。
</p>

<pre class="code">static struct ipt_match ipaddr_match
= {
</pre>
'name' 是你的模块的文件名字符串(也就是说 ipt_ipaddr)。
<pre class="code">	.name       = "ipaddr",
</pre>

下面的字段是框架将要使用的回调函数.'match'是当一个包传送给你的模块的时候要调用的函数.
<pre class="code">	.match      = match,
	.checkentry = checkentry,
	.me         = THIS_MODULE,
};
</pre>

你的内核模块的 init 函数需要通过指向一个 'struct ipt_match' 的指针调用 'ipt_register_match()' 来向 netfilter 框架注册.这个函数在模块被加载的时候调用.
<pre class="code">static int __init init(void)
{
	printk(KERN_INFO "ipt_ipaddr: init!\n");
	return ipt_register_match(&amp;ipaddr_match);
}
</pre>

当把模块从内核中移出的时候这个函数会被调用.这里我们进行的工作是注销匹配器。
<pre class="code">static void __exit fini(void)
{
	printk(KERN_INFO "ipt_ipaddr: exit!\n");
	ipt_unregister_match(&amp;ipaddr_match);
}
</pre>

设置让这两个函数在模块装入和移出的时候被调用。
<pre class="code">module_init(init);
module_exit(fini);

</pre>

<A NAME="367lfindex18">&nbsp;</A>
<H3>2.2.2 match 函数</H3>

Linux 的 TCP/IP 协议栈包括5个 netfilter 钩子。这样，一个包近来之后，协议栈把包送到相应的钩子，依次进入每个表，再依次叠带每条规则。当你的模块得到包的时候，你的模块就可以进行它的工作了。
<pre class="code">static int match(const struct sk_buff *skb,
                 const struct net_device *in,
                 const struct net_device *out,
                 const void *matchinfo,
                 int offset,
                 const void *hdr,
                 u_int16_t datalen,
                 int *hotdrop)
{
</pre>
希望你还记着我们在用户态程序里面做了些什么！ :)。现在把用户态程序拷贝过来的数据结构映射到我们这里
<pre class="code">	const struct ipt_skeleton_info *info = matchinfo;
</pre>
'skb' 包含了我们想要处理的包。想要得到关于这个在 linux 的 TCP/IP 协议栈中到处都是功能强大的数据结构的信息，可以看看 Harald Welte 写的一出色的文章  <a href="ftp://ftp.gnumonks.org/pub/doc/skb-doc.html">article (ftp://ftp.gnumonks.org/pub/doc/skb-doc.html)</a> 。
<pre class="code">   struct iphdr *iph = skb-&gt;nh.iph;
</pre>
这里，我们就是打印一些有趣的东西来看看他们长成什么样子。宏 'NIPQUAD' 用于以可读的方式显示一个 IP 地址，它是在 &lt;<i>linux/include/linux/kernel.h</i>&gt; 中定义的。
<pre class="code">   printk(KERN_INFO "ipt_ipaddr: IN=%s OUT=%s TOS=0x%02X "
                    "TTL=%x SRC=%u.%u.%u.%u DST=%u.%u.%u.%u "
                    "ID=%u IPSRC=%u.%u.%u.%u IPDST=%u.%u.%u.%u\n",

                    in ? (char *)in : "", out ? (char *)out : "", iph-&gt;tos,
                    iph-&gt;ttl, NIPQUAD(iph-&gt;saddr), NIPQUAD(iph-&gt;daddr),
                    ntohs(iph-&gt;id), NIPQUAD(info-&gt;ipaddr.src), NIPQUAD(info-&gt;ipaddr.dst)
         );
</pre>
如果输入了 '--ipsrc' 参数，我们察看源地址是否和规则指定的地址相匹配。别忘了考虑反标志 '!'。如果没有匹配，我们返回 0.
<pre class="code">   if (info-&gt;flags &amp; IPADDR_SRC) {
      if ( (ntohl(iph-&gt;saddr) != ntohl(info-&gt;ipaddr.src)) ^ !!(info-&gt;flags &amp; IPADDR_SRC_INV) ) {

         printk(KERN_NOTICE "src IP %u.%u.%u.%u is not matching %s.\n",
                            NIPQUAD(info-&gt;ipaddr.src),
                            info-&gt;flags &amp; IPADDR_SRC_INV ? " (INV)" : "");
         return 0;
      }
   }
</pre>
这里，我们进行完全相同的工作，只是察看 '--ipdst' 参数。
<pre class="code">   if (info-&gt;flags &amp; IPADDR_DST) {
      if ( (ntohl(iph-&gt;daddr) != ntohl(info-&gt;ipaddr.dst)) ^ !!(info-&gt;flags &amp; IPADDR_DST_INV) )  {

         printk(KERN_NOTICE "dst IP %u.%u.%u.%u is not matching%s.\n",
                            NIPQUAD(info-&gt;ipaddr.dst),
                            info-&gt;flags &amp; IPADDR_DST_INV ? " (INV)" : "");
         return 0;
      }
   }
</pre>
如果都不成功，返回 1，表明我们匹配了这个包。
<pre class="code">   return 1;
}
</pre>


<A NAME="367lfindex19">&nbsp;</A>
<H3>2.2.3 checkentry 函数</H3>

checkentry 通常是最后一次合法性检查的机会。关于它何时被调用有些难以理解。看看 <a href="http://www.mail-archive.com/netfilter-devel@lists.samba.org/msg00625.html">post (http://www.mail-archive.com/netfilter-devel@lists.samba.org/msg00625.html)</a> 作为一个解释吧。这篇文章也是一篇 netfilter hacking howto。

<pre class="code">static int checkentry(const char *tablename,
                             const struct ipt_ip *ip,
                             void *matchinfo,
                             unsigned int matchsize,
                             unsigned int hook_mask)
{
   const struct ipt_skeleton_info *info = matchinfo;

   if (matchsize != IPT_ALIGN(sizeof(struct ipt_skeleton_info))) {
      printk(KERN_ERR "ipt_skeleton: matchsize differ, you may have forgotten to recompile me.\n");
      return 0;
   }

   printk(KERN_INFO "ipt_skeleton: Registered in the %s table, hook=%x, proto=%u\n",
                    tablename, hook_mask, ip-&gt;proto);

   return 1;
}

</pre>
<A NAME="367lfindex20">&nbsp;</A>
<H2>2.3 第二章小结</H2>

在第二部分，我们讲了 netfilter 模块以及如何使用特定结构注册它。另外我们还讨论了如何根据用户空间部分给出的判据匹配特定的情况。

<A NAME="367lfindex21">&nbsp;</A>
<H2>3.0 运行 iptables/netfilter</H2>

我们已经看到了如何写一个新的 iptables/netfilter 匹配模块。现在我们将把它添加到内核中来运行它。这里，我假设你知道如何编译内核。首先把骨架匹配文件从<a href="../../common/src2/article367/index.html">本文下载页面</a>下载下来。

<A NAME="367lfindex22">&nbsp;</A>
<H3>3.1 iptables</H3>

现在，如果你还没有 iptables 的源代码的话，可以从 <a href="ftp://ftp.netfilter.org/pub/iptables/">ftp://ftp.netfilter.org/pub/iptables/</a> 下载。然后拷贝 'libipt_ipaddr.c' 到 &lt;<i>iptables/extensions/</i>&gt;。<br><br>

这是 &lt;<i>iptables/extensions/Makefile</i>&gt; 中的一行，你应该加上 'ipaddr'。
<pre class="code">
PF_EXT_SLIB:=ah addrtype comment connlimit connmark conntrack dscp ecn
esp hashlimit helper icmp iprange length limit <b>ipaddr</b> mac mark
multiport owner physdev pkttype realm rpc sctp standard state tcp tcpmss
tos ttl udp unclean CLASSIFY CONNMARK DNAT DSCP ECN LOG MARK MASQUERADE
MIRROR NETMAP NOTRACK REDIRECT REJECT SAME SNAT TARPIT TCPMSS TOS TRACE
TTL ULOG
</pre>

<A NAME="367lfindex23">&nbsp;</A>
<H3>3.2 内核</H3>


首先，你应该拷贝 'ipt_ipaddr.c' 到 &lt;<i>linux/net/ipv4/netfilter/</i>&gt;，拷贝 ' ipt_ipaddr.h' 到  &lt;<i>linux/net/ipv4/netfilter/</i>&gt;。有些读者可能还在使用 2.4 内核，所以我同时提供了 2.4和 2.6 的文件。<br><br>

对于 2.4 内核，编辑  &lt;<i>linux/net/ipv4/netfilter/Config.in</i>&gt; ，加入下面加重的行。
<pre class="code"># The simple matches.
  dep_tristate '  limit match support' CONFIG_IP_NF_MATCH_LIMIT $CONFIG_IP_NF_IPTABLES
<b>  dep_tristate '  ipaddr match support' CONFIG_IP_NF_MATCH_IPADDR $CONFIG_IP_NF_IPTABLES</b>
</pre>

然后，编辑  &lt;<i>linux/Documentation/Configure.help</i>&gt; 加入加重的行。我复制了一些文本来帮助你找到要加入内容的地方。
<pre class="code">limit match support
CONFIG_IP_NF_MATCH_LIMIT
  limit matching allows you to control the rate at which a rule can be
  ...<b>
ipaddr match support
CONFIG_IP_NF_MATCH_IPADDR
  ipaddr matching. etc etc.</b>
</pre>

最后，你必须把加重的行加入到 &lt;<i>linux/net/ipv4/netfilter/Makefile</i>&gt; 之中。
<pre class="code"># matches
obj-$(CONFIG_IP_NF_MATCH_HELPER) += ipt_helper.o
obj-$(CONFIG_IP_NF_MATCH_LIMIT) += ipt_limit.o
<b>obj-$(CONFIG_IP_NF_MATCH_IPADDR) += ipt_ipaddr.o</b>
</pre>

Now for 2.6, files to edit are &lt;<i>linux/net/ipv4/netfilter/Kconfig</i>&gt; and  &lt;<i>linux/net/ipv4/netfilter/Makefile</i>&gt;.
对 2.6 内核，编辑的文件应该是 &lt;<i>linux/net/ipv4/netfilter/Kconfig</i>&gt;和 &lt;<i>linux/net/ipv4/netfilter/Makefile</i>&gt;。

<A NAME="367lfindex24">&nbsp;</A>
<H2>总结</H2>


下面剩下的的就是从新编译以及我忘了说的了。<br>
Happy hacking!!

<br>
感谢 Samuel Jean.


<!-- BODY_OF_THE_ARTICLE_STOP -->
<!-- 2pdaIgnoreStart -->
<A NAME="talkback">&nbsp;</a>
<h2>对这篇文章发表评论</h2>
每篇文章都有各自的反馈页面。在这个页面里，您可以提交评论，也可以查看其他读者的评论：
<center>
    <table width="250" border=0><tr><td>
    <div class="tbbutton"><A class="nodec" href="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=367">&nbsp;反馈页面&nbsp;</a></div>
    </td></tr></table>
</center>

<br clear="all">
<HR size="2" noshade>
<table width="250" border=0><tr><td>
<div class="bbutton"><a class="nodec" href="../../index.shtml">&lt;--, LF 首页</a></div>
</td><td>
<div class="bbutton"><a class="nodec" href="index.shtml">Go to the index of this issue</a></div>
</td></tr></table>
<br clear="all">
<HR size="2" noshade>
<!-- ARTICLE FOOT -->
<CENTER><TABLE WIDTH="98%" summary="footer">
<TR><TD ALIGN=CENTER BGCOLOR="#bdc6d5" WIDTH="50%">
<A HREF="../../common/lfteam.html">主页由LinuxFocus编辑组维护</A>
<BR><FONT COLOR="#1111aa"><a href="../../common/copy.html">&copy; Nicolas Bouliane</a><br>&quot;some rights reserved&quot; see <a href="../../license/index.shtml">linuxfocus.org/license/</a><br><a href="http://www.linuxfocus.org">http://www.LinuxFocus.org</a></FONT>
</TD>
<TD BGCOLOR="#bdc6d5">
<!-- TRANSLATION INFO -->
<font size=2>翻译信息:</font>
<TABLE summary="translators">
  <tr><td><font size="2">en --&gt; -- : Nicolas Bouliane <small>&lt;nib(at)cookinglinux!org&gt;</small></font></td></tr>
  <tr><td><font size="2">en --&gt; zh: 王旭 &lt;wangxu(at)linuxfocus.org&gt;</font></td></tr>
</TABLE>
</TD>
</TR></TABLE></CENTER>
<p><font size=1>2005-04-28, generated by lfparser version 2.52</font></p>
<!-- 2pdaIgnoreStop -->
</BODY>
</HTML>
