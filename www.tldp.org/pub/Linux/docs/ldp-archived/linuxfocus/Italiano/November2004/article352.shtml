<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
 <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <META NAME="GENERATOR" CONTENT="lfparser_2.52">
 <META NAME="LFCATEGORY" CONTENT="Hardware">
 <link rel="icon" href="../../common/images/lf-16.png" type="image/png">
 <TITLE>lf352, Hardware: Programmazione dei microcontollori AVR con GCC, libc 1.0.4</TITLE>
<style type="text/css">
<!--
 td.top {font-family: Arial,Geneva,Verdana,Helvetica,sans-serif; font-size:12 }
 pre { font-family:monospace,Courier }
 pre.code { font-family:monospace,Courier;background-color:#aedbe8; }
 p.cl { color:#EE9500 }
 table.left { margin-right:0.3cm }
 a.nodec { text-decoration:none }
 p.trans { font-size:8pt; text-align:right }
 p.clbox { width:50%; alignment:center; background-color:#FFD700; 
           border-style:none; border-width:medium; border-color:#FFD700; 
           padding:0.5cm;  text-align:center }
 p.code { width:80%; alignment:center; background-color:#aedbe8; 
          border-style:none; border-width:medium; border-color:#aedbe8; 
          padding:0.1cm;  text-align:left }
 p.foot { background-color:#AAAAAA; color:#FFFFFF; border-style:none; 
          border-width:medium; border-color:#AAAAAA; padding:0.5cm ; 
          margin-top:0.1cm; margin-right:1cm; margin-left:1cm; 
          text-align:center }
 div.tbbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   margin: 2px 5px 2px 5px;
   text-align: center;
   width: 20em;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
 div.bbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   float: left;
   margin: 2px 5px 2px 5px;
   text-align: center;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
-->
</style>
 
</HEAD>
<BODY bgcolor="#ffffff" text="#000000">
 <!-- this is generated html code. NEVER use this file for your
 translation work. Instead get the file with the same article number
 and .meta.shtml in its name. Translate this meta file and then
 use lfparser program to generate the final article -->
 <!-- lfparser can be obtained from http://main.linuxfocus.org/~guido/dev/lfparser.html -->

<!-- this is used by a number of tools:
 =LF=AUTHOR: Guido     Socher
 =LF=CAT___: Hardware
 =LF=TITLE_: Programmazione dei microcontollori AVR con GCC, libc 1.0.4
 =LF=NUMBER: 352
 =LF=ANAME_: article352.shtml
 =LF=PARSER: 2.52
 -->

<!-- 2pdaIgnoreStart -->

<!-- start navegation bar, current, style=2 -->
 <!-- top navegation bar -->
 <TABLE summary="topbar_1" cellspacing="0" cellpadding="0" border="0" align="center" width="90%">
   <TR bgcolor="#2e2292">
     <TD class="top"><TABLE summary="topbar_1_logo" cellspacing="0" cellpadding="0" border="0" width=
       "100%">
         <TR><TD width="319"><a href="../../index.shtml"><IMG src="../../common/images/logolftop_319x45.gif"
           alt="[LinuxFocus-icon]" width="319" height="45" align="left" 
           border="0"></a></TD>

           <TD class="top">
             <TABLE summary="topbar_1_links" width="100%">
               <TR align="right">
                 <TD class="top">
                 
                 <A class="nodec" href="../../index.shtml"><FONT color=
                 "#DDDDDD" size="2">&lt;--</FONT></A> &nbsp;| 
                 <A class="nodec" href="../map.html"><FONT color=
                 "#DDDDDD" size="2">Mappa</FONT></A> &nbsp;| 
                 <A class="nodec" href="../indice.html"><FONT color=
                 "#DDDDDD" size="2">Indice</FONT></A> &nbsp;| 
                 <A class="nodec" href="../Search/index.shtml"><FONT color=
                 "#DDDDDD" size="2">Cerca</FONT></A> </TD>
                 
               </TR>

               <TR align="right">
                 <TD class="top">
                   <HR width="100%" noshade size="1">
                 </TD>
               </TR>
             </TABLE>
           </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end top navegation bar -->
 <!-- blue bar -->
 <TABLE summary="topbar_2" cellspacing="0" cellpadding="0" border="0" align="center"
 width="90%">
   <TR bgcolor="#00ffff">
     <TD><IMG src="../../common/images/transpix.gif" width="1" height=
     "2" alt=""></TD>
   </TR>
 </TABLE>
 <!-- end blue bar -->
 <!-- bottom navegation bar -->
 <TABLE summary="topbar_3" cellspacing="0" cellpadding="0" border="0" align="center"
 width="94%">
   <TR bgcolor="#000000">
     <TD>
       <TABLE summary="topbar_3_links" cellspacing="0" cellpadding="1" border="0" width=
       "100%">
         <TR align="center">
           <TD WIDTH="20%"><A class="nodec" href="../News/index.shtml"><FONT color=
           "#FFFFFF">News</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Archives/index.html"><FONT color=
           "#FFFFFF">Archivo</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Links/index.html"><FONT color=
           "#FFFFFF">Link</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../aboutus.html"><FONT color=
           "#FFFFFF">Cose LF</FONT></A> </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end bottom navegation bar -->
<!-- stop navegation bar -->

<!-- SSI_INFO -->

<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfdynahead ver 1.5 --><TABLE ALIGN="right" border=0><TR><TD ALIGN="right"><FONT SIZE="-1" FACE="Arial,Helvetica">Questo documento &egrave; disponibile in: <A href="../../English/November2004/article352.shtml">English</a> &nbsp;<A href="../../Castellano/November2004/article352.shtml">Castellano</a> &nbsp;<A href="../../Deutsch/November2004/article352.shtml">Deutsch</a> &nbsp;<A href="../../Francais/November2004/article352.shtml">Francais</a> &nbsp;<A href="../../Italiano/November2004/article352.shtml">Italiano</a> &nbsp;<A href="../../Turkce/November2004/article352.shtml">Turkce</a> &nbsp;</FONT></TD></TR></TABLE><br>
 


<!-- SSI_INFO STOP -->
<!-- 2pdaIgnoreStop -->

<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_START -->
<TABLE ALIGN="LEFT" BORDER="0" WIDTH="195" summary="about the author" class="left">
<TR>
<TD>

<img src="../../common/images/Guido-S.gif" alt=
    "[Photo of the Author]" height="164" width="173">
<BR>   Guido Socher <a href="http://linuxfocus.org/~guido/"><font size="1">(homepage)</font></a>
<BR><BR>
<I>L'autore:</I><BR>
<!-- aboutauthor_start -->
<p>A Guido piace linux perch&eacute; &egrave; veramente un buon sistema per sviluppare il proprio  hardware.</p>
<!-- aboutauthor_stop -->
<!-- TRANSLATED_TO it -->
<BR><BR><I>Tradotto in Italiano da:</I><BR>
Gianpaolo Demarchi (<a href="malto:gianpaolo.demarchi[at]gmail.com"><font size="1">homepage</font></a>)
<br>
<!--
 =LF=TRANSTO=it: Gianpaolo Demarchi
-->
<!-- TRANSLATED_TO_STOP -->
<!-- INDEX_START -->
<BR><i>Contenuto</i>:
<UL>
  <LI><A HREF="#352lfindex0">Introduzione</A></LI>
  <LI><A HREF="#352lfindex1">Installazione del software: di cosa c'&egrave; bisogno</A></LI>
  <LI><A HREF="#352lfindex2">Installazione del software: GNU binutils</A></LI>
  <LI><A HREF="#352lfindex3">Installazione del software: AVR GCC</A></LI>
  <LI><A HREF="#352lfindex4">Installazione del software: la libreria avr-libc</A></LI>
  <LI><A HREF="#352lfindex5">Installazione del software: il Programmatore</A></LI>
  <LI><A HREF="#352lfindex6">Un piccolo progetto di prova</A></LI>
  <LI><A HREF="#352lfindex7">Hardware necessario</A></LI>
  <LI><A HREF="#352lfindex8">Costruire l'hardware del programmatore</A></LI>
  <LI><A HREF="#352lfindex9">Scrivere il software</A></LI>
  <LI><A HREF="#352lfindex10">Compilare e caricare</A></LI>
  <LI><A HREF="#352lfindex11">Alcune interessanti  binutils</A></LI>
  <LI><A HREF="#352lfindex12">Idee e suggerimenti</A></LI>
  <LI><A HREF="#352lfindex13">Riferimenti</A></LI>
  <LI><A HREF="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=352">Discussioni su quest'articolo</A></LI>
</UL>

</TD></TR></TABLE>
<!-- INDEX_STOP -->
<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_STOP -->
<!-- HEAD_OF_THE_ARTICLE_START -->
<br>&nbsp;
<table border="0"><tr><td>
<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfPdf ver 0.1 -->
<TABLE style="border-style:outset; border-width:1px" align="right" bgcolor="#ff9616" cellspacing="1"><TR><TD bgcolor="#ff9616">
        <a href="../Archives/lf-2004_11-0352.pdf"><small>PDF</small></a>
        </TD></TR></TABLE>
         

<H2>Programmazione dei microcontollori AVR con GCC, libc 1.0.4</H2>
 <img src="../../common/images2/article352/illustration.gif"
    alt="[Illustration]" hspace="10" width="208" height="148">
<!-- ABSTRACT OF THE ARTICLE -->
<P><i>Premessa</i>:
<P>
<!-- articleabstract_start -->

   I microcontrollori AVR 8-bit RISC sono un tipo di microcontrollori molto comune. Essi contengono in un solo chip EEPROM, Ram, convertitori da analogico a digitale, molte linee di input e output, timer,
   UART per comunicazione via RS232 e altro ancora.<br><br>
     La caratteristica peculiare di questi microcontrollori &egrave; l'esistenza di un completo sistema di sviluppo sotto Linux: &egrave; possibile programmarli infatti in C con il GCC. <br><br>
    Ho gi&agrave; scritto nel Marzo 2002 un <a href=
    "../March2002/article231.shtml">articolo</a> con lo stesso soggetto. Da allora per&ograve; sono cambiate un sacco di cose sia nello sviluppo della libreria avr-libc, sia per il fatto che il microcontrollore AT90S4433 usato in quella serie di articoli non viene pi&ugrave; prodotta da Atmel. <br><br>Questo articolo quindi &egrave; un aggiornamento dell'articolo del Marzo 2002. In questo articolo verranno quindi utilizzati le libc-1.0.4. e il microcontrollore ATmega8.


    
<!-- articleabstract_stop -->

<br><!-- HR divider --><center><font color="#8282e0"><b>_________________ _________________ _________________</b></font></center><br>
</td></tr></table>
<!-- HEAD_OF_THE_ARTICLE_STOP -->
<!-- BODY_OF_THE_ARTICLE_START -->


    <A NAME="352lfindex0">&nbsp;</A>
<H2>Introduzione</H2>

  Molte persone si sono interessate alla programmazione dei microcontrollori dopo l'articolo che scrissi nel 2002. Lo scoglio maggiore &egrave; la realizzazone di un sistema di sviluppo funzionante. Se qualcosa non funziona infatti non si hanno in generale indizi sulle cause del malfunzionamento. Il cavo programmatore sbagliato? Malfunzionamenti nel circuito? Installazione errata? La porta parallela disabilitata nel BIOS? Il modulo del kernel ppdev compilato in maniera errata? Le ragioni per cui le cose non funzionano possono essere molteplici. <a href=
    "http://shop.tuxgraphics.org/electronic/microcontroller.html"><img
     src="../../common/images2/article352/linuxavrcd_th.jpg" align=
    "right" width="150" height="213"></a> <br>
     <br>
   Per facilitare l'ingresso nel mondo eccitante dei microcontrollori <a href=
    "http://shop.tuxgraphics.org/electronic/microcontroller.html">shop.tuxgraphics.org</a>
    offre ora un CD avviabile con un manuale e l'hardware necessario per la programmazione. Tutto quello che si deve fare &egrave; quindi avviare il computer dal CD e tutto sar&agrave; pronto e funzionante.. Non &egrave; necessario installare nessun software aggiuntivo e non viene modificato nulla sul computer. <br>
     <br>
Anchi'io ogni tanto uso questo CD in quanto spesso l'hardware che realizzo spesso sopravvive a molte generazioni di kernel e versioni di software installate sul PC. Se ad un certo punto voglio modificare il software del microcontrollore, usando il CD non devo preoccuparmi di se l'ambiente di sviluppo &egrave; ancora funzionante sul mio PC Linux. Faccio semplicemente partire la macchina da CD e il sistema &egrave; pronto e funzionante. <br>
     <br>
Indipendentemente dal CD, descriver&ograve; nei paragrafi seguenti l'installazione del sistema di sviluppo GCC per gli AVR. Se avete preso il CD su tuxgraphics potete saltare la parte seguente ed andare direttamente al paragrafo "Un piccolo progetto di prova".

    <A NAME="352lfindex1">&nbsp;</A>
<H2>Installazione del software: di cosa c'&egrave; bisogno</H2>


    <p>Per utilizzare l'ambiente di sviluppo GNU C c'&egrave; bisogno del software seguente:</p>

    <table border="1">
      <tr>
        <td>binutils-2.15.tar.bz2</td>

        <td>Disponibile su:<br>
         ftp://ftp.gnu.org/gnu/binutils/<br>
         o su altri mirror. Es:<br>
         ftp://gatekeeper.dec.com/pub/GNU/binutils/</td>
      </tr>

      <tr>
        <td>gcc-core-3.4.2.tar.bz2</td>

        <td>Disponibile su: ftp://ftp.gnu.org/gnu/gcc/<br>
         o su altri mirror. Es:<br>
         ftp://gatekeeper.dec.com/pub/GNU/gcc/</td>
      </tr>

      <tr>
        <td>avr-libc-1.0.4.tar.bz2</td>

        <td>La libreria C per gli AVR:
        http://savannah.nongnu.org/projects/avr-libc/</td>
      </tr>

      <tr>
        <td>uisp-20040311.tar.bz2</td>

        <td>Il software per programmare gli AVR:
        http://savannah.nongnu.org/projects/uisp</td>
      </tr>
    </table>
    <br>
    <br>
    Installeremo tutti i programmi in /usr/local/avr. Questa scelta viene fatta per mantenere separati questi programmi dal compilatore C standard di Linux.
Creiamo la directory in questa maniera:
<pre class="code">
    mkdir /usr/local/avr
</pre>
e aggiungiamo la directory dei programmi al PATH:
<pre class="code">

    mkdir /usr/local/avr/bin
    export PATH=/usr/local/avr/bin:${PATH}
</pre>

    <A NAME="352lfindex2">&nbsp;</A>
<H2>Installazione del software: GNU binutils</H2>

Il pacchetto binutils fornisce tutte le utilities a basso livello necessarie per la creazione dei file oggetto. Il pacchetto comprende un assembler AVR (avr-as), un linker (avr-ld), strumenti per l'uso di librerie (avr-ranlib, avr-ar), un programma per generare file oggetto da caricare nella EEPROM del microcontrollore (avr-objcopy), un disassembler (avr-objdump) e altre utility quali avr-strip e avr-size.
    <br>
     <br>
    Per compilare e installare le binutils &egrave; sufficiente eseguire:

<pre class="code">
tar jxvf binutils-2.15.tar.bz2
cd binutils-2.15/
mkdir obj-avr
cd obj-avr
../configure --target=avr --prefix=/usr/local/avr --disable-nls
make

# come root:
make install
</pre>
    <br>
    <br>
 Per aggiornare la cache del linker &egrave; necessario aggiungere la riga /usr/local/avr/lib al file /etc/ld.so.conf e lanciare il comando /sbin/ldconfig


    <A NAME="352lfindex3">&nbsp;</A>
<H2>Installazione del software: AVR GCC</H2>

    avr-gcc sar&agrave; il nostro compilatore C. <br>
     <br>
Per compilarlo e installarlo &egrave; sufficiente eseguire:
<pre class="code">
tar jxvf gcc-core-3.4.2.tar.bz2
cd gcc-3.4.2

mkdir obj-avr
cd obj-avr
../configure --target=avr --prefix=/usr/local/avr --disable-nls --enable-language=c

make

# come root:
make install

</pre>

    <A NAME="352lfindex4">&nbsp;</A>
<H2>Installazione del software: la libreria avr-libc</H2>

    La libreria avr-libc &egrave; molto pi&ugrave; stabile ora rispetto a quanto non lo fosse nel Marzo 2002. <br>
     Per compilarla ed installarla &egrave; sufficiente eseguire:
<pre class="code">
tar jxvf avr-libc-1.0.4.tar.bz2
cd avr-libc-1.0.4
PREFIX=/usr/local/avr
export PREFIX
sh -x ./doconf
./domake

cd build
#come root:
make install

</pre>

    <A NAME="352lfindex5">&nbsp;</A>
<H2>Installazione del software: il Programmatore</H2>

    Il software programmatore carica il codice oggetto specificatamente preparato per il microcontrollore nella sua memoria EEPROM. <br>
     <br>
    Il programma uisp &egrave; un programmatore molto potente. Pu&ograve; essere utilizzato direttamente all'interno di un Makefile. E' sufficiente infatti aggiungere la regola "make load" per compilare e caricare il codice in un unico passaggio. <br>
     <br>
     Per installare uisp basta eseguire:
<pre class="code">
tar jxvf uisp-20040311.tar.bz2.tar
cd uisp-20040311
./configure --prefix=/usr/local/avr
make

# come root:
make install

</pre>

    <A NAME="352lfindex6">&nbsp;</A>
<H2>Un piccolo progetto di prova</H2>

    Cominceremo con un piccolo circuito di prova, che potr&agrave; essere migliorato con l'aggiunta di altre parti in futuro.
     <br>
    <br>
    Tale circuito pu&ograve; venire anche usato come banco di prova per progetti hardware pi&ugrave; complessi. E' possibile infatti provare il software caricato e aggiungere sensori e sistemi di misura.<br>
    <br>
   Il programma di prova presentato qui di seguito serve per far lampeggiare un LED.<br>
     <img src="../../common/images2/article352/circuit.gif" width=
    "600" height="400"> <br>


    <A NAME="352lfindex7">&nbsp;</A>
<H2>Hardware necessario</H2>


    <img src=
    "../../common/images2/article352/avrm8ledtest_circuit.jpg" alt=
    "[test circuit]" align="right" width="300" height="286"><br>

    Per costruire il circuito sono necessari i componenti elettronici elencati nella tabella successiva. Bench&egrave; gli AVR siano microcontrollori molto comuni, pu&ograve; essere che non siano disponibili nel vostro negozio di elettronica di fiducia, ma i grossi distributori (www.conrad.de (Germania), digikey.com (US), RS o Distrelec (Italia)) sicuramente ne hanno in magazzino. E' possibile ottenere il kit completo o solo il microcontrollore anche sul sito
    <a href="http://shop.tuxgraphics.org/">shop.tuxgraphics.org</a>
    <br clear="all">


    <table border="1" width="70%">
      <tr>
        <td>1 x ATmega8 in versione DIP, Atmel 8 bit Avr processore risc.</td>
      </tr>

      <tr>
        <td>1 x 28 pin 7.5mm zoccolo per IC <br>
         Lo zoccolo da 28 pi &egrave; spesso difficile da trovare. Tipicamente gli zoccoli da 28 sono larghi 14mm ma noi ne abbiamo bisogno di uno da 7.5
        ..</td>
      </tr>

      <tr>
        <td>1 x 10K resistenze (codice colore: marrone, nero, arancione)<br>
         1 x 1K resistenza (codice colore: marrone, nero, rosso)<br>
         1 x 10uF condensatore elettrolitico<br>
         Alcuni fili<br>
         1 x LED<br>
         Basetta millefori<br>
        </td>
      </tr>

      <tr>
        <td>Il materiale seguente &egrave; necessario per il programmatore <small>(non serve se si acquista il  "Linux AVR programming kit" da
        tuxgraphics)</small>:<br>
        1 x DB25 connettore da inserire nella porta parallela. <br>
        Un qualsiasi connettore/zoccolo da 5 pin per il programmatore. Raccomando di usare "precision strip connectors" (simili agli zoccoli per IC) e staccare 5 piedini.<br>
         1 x 220 Ohm resistenza(codice colore: rosso, rosso, marrone)<br>
         2 x 470 Ohm resistenza (codice colore: giallo, viola, marrone)<br>
        </td>
      </tr>
    </table>
 In aggiunta ai componenti elencati sopra bisogna procurarsi un alimentatore DC stabilizzato a 5 V oppure &egrave; possibile utilizzare per l'alimentazione del circuito una batteria da 4,5 V <br>
    <br>
Avrete probabilmente notato che non vi &egrave; alcuna necessit&agrave; di un cristallo esterno. Questo perch&egrave; l'ATmega8 ha un oscillatore incorporato. Tale oscillatore pu&ograve; tranquillamente venir usato nel caso in cui non sia necessaria una tempistica accurata. Nel caso per&ograve; in cui si voglia realizzare un'apparecchiatura di misura abbastanza accurata oppure si voglia utilizzare l'interfaccia UART/RS232 allora &egrave; necessario montare un oscillatore a cristallo. Il tipo di oscillatore utilizzato viene definito attraverso dei "fuse bits" che possono essere modificati dal programmatore. Di default &egrave; attivato l'oscillatore interno a 1 MHz.

    <A NAME="352lfindex8">&nbsp;</A>
<H2>Costruire l'hardware del programmatore</H2>

    I microcontrollori AVR possono essere programmati via ISP (In System Programing).
     <img src=
    "../../common/images2/article352/avr_programmer.jpg" alt=
    "[Linux AVR programmer]" align="right" width="300" height=
    "303"><br>
Ci&ograve; vuol dire che non &egrave; necessario rimuovere in microcontrollore dal circuito per programmarlo. E' possibile procurarsi vari programmatori hardware per 50-150 Euro. Utilizzando Linux &egrave; possibile realizzare un programmatore molto semplice che  fa' al caso nostro. Basta avere sul computer una porta parallela libera e cavo descritto nelle righe seguenti. <br>
    <br>
 Da notare che il cavo programmatore qui presentato rappresenta una versione migliore rispetto a quella presentata nel Marzo 2002. In questo nuovo cavo le resistenze di protezione vengono montate direttamente nel connettore, permettendo anche di risparmiare un po' di spazio nel scheda del circuito. I collegamenti per il cavo programmatore devono essere eseguiti nella maniera seguente:
 <br>


    <table border="1" bgcolor="#CDCDCD">
      <tr>
        <th>pin sul pcb</th>

        <th>pin sul AVR</th>

        <th>resistenza di protezione</th>

        <th>Pin sulla porta parallela</th>
      </tr>

      <tr>
        <td>5</td>

        <td>Reset (1)</td>

        <td>--</td>

        <td>Init (16)</td>
      </tr>

      <tr>
        <td>4</td>

        <td>MOSI (17)</td>

        <td>470 Ohm</td>

        <td>D0 (2)</td>
      </tr>

      <tr>
        <td>3</td>

        <td>MISO (18)</td>

        <td>220 Ohm</td>

        <td>Busy (11)</td>
      </tr>

      <tr>
        <td>2</td>

        <td>SCK (19)</td>

        <td>470 Ohm</td>

        <td>Strobe (1)</td>
      </tr>

      <tr>
        <td>1</td>

        <td>GND</td>

        <td>--</td>

        <td>GND (18)</td>
      </tr>
    </table>
    <br>
    Il cavo inoltre non deve essere pi&ugrave; lungo di 70 cm.<br>
    <br>
Da notare nella figura come le resistenze di protezione possano essere montate direttamente nel connettore.

    <A NAME="352lfindex9">&nbsp;</A>
<H2>Scrivere il software</H2>

L'ATmega8 pu&ograve; essere programmato in C puro con l'aiuto del gcc. La conoscenza dell'assembler AVR pu&ograve; risultare utile ma non &egrave; necessaria.
    <br>
    <br>
    La libreria AVR libc ha il suo <a href=
    "../../common/src2/article352/avr-libc-user-manual-1.0.4.pdf">avr-libc-user-manual-1.0.4.pdf
    (1139921 bytes)</a> che descrive tutte le funzioni disponibili in C. Dal sito di Atmel, (<a href=
    "http://www.atmel.com">www.atmel.com</a>, vai a : avr products
    -&gt; 8 bit risc-&gt; Datasheets),&egrave; possibile inoltre scaricare il datasheet completo, che descrive tutti i registri e spiega come usare la CPU. <br>
     <br>
   Una cosa da ricordare quando si usa un microcontrollore &egrave; che esso &egrave; dotato di pochi Byte di RAM. Ci&ograve; implica che non si possono dichiarare strutture di  dati complesse o stringhe molto lunghe. Il programma inoltre non deve contenere chiamate a funzioni "annidate" (NdT: in inglese deeply nested) o funzioni ricorsive.<br>
     <br>
Ma la pratica conta pi&ugrave; della grammatica. Scriveremo ora un programma che far&agrave; lampeggiare un LED a intervalli di 0.5 secondi. Non &egrave; un programma utilissimo, ma &egrave; un buon punto da cui partire. <br>
    <br>
La libreria avr-libc &egrave; cambiata molto. In origine si settava un bit su una porta chiamando sbi() e si resettava con cbi(). Ora l'uso di tali funzioni &egrave; deprecato. Nella "vecchia maniera" si sarebbe scritto:
<pre class="code">
    /* defines for future compatibility */
    #ifndef cbi
    #define cbi(sfr, bit) (_SFR_BYTE(sfr) &amp;= ~_BV(bit))
    #endif
    #ifndef sbi
    #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
    #endif

    void main(void)
    {
          /* INITIALIZE */
          /* enable PC5 as output */
          sbi(DDRC,PC5);


          /* BLINK, BLINK ... */
          while (1) {
                /* led on, pin=0 */
                cbi(PORTC,PC5);
                delay_ms(500);
                /* set output to 5V, LED off */
                sbi(PORTC,PC5);
                delay_ms(500);
          }
    }

</pre>
    Mentre l'esempio seguente fa lo stesso usando la nuova sintassi:
<pre class="code">
    void main(void)
    {
          /* INITIALIZE */
          /* enable PC5 as output */
          DDRC|= _BV(PC5);


          /* BLINK, BLINK ... */

          /* PC5 is 5 (see file include/avr/iom8.h) and _BV(PC5) is 00100000 */
          while (1) {
                /* led on, pin=0 */
                PORTC&amp;= ~_BV(PC5);
                delay_ms(500);
                /* set output to 5V, LED off */
                PORTC|= _BV(PC5);
                delay_ms(500);
          }
    }

</pre>
    Il pezzo di codice presentato sopra mostra quanto sia semplice scrivere un programma. Qui per brevit&agrave; viene mostrato solo la parte "main" del programma, e la funzione delay_ms &egrave; inclusa nel <a href=
    "../../common/src2/article352/avrm8ledtest.c.html">listato completo (avrm8ledtest.c)</a>.
  Per usare il pin PC5 come output bisogna settare il bit PC5 nel registro della direzione dei dati per la porta C (DDRC). Fatto ci&ograve; si pu&ograve; porre il pin PC5 a 0V chiamando la funzione cbi(PORTC,PC5) (pulisci il bit PC5) oppure si pu&ograve; mettere a 5V  con sbi(PORTC,PC5)  (set bit PC5). Il valore della stringa "PC5" &egrave; definito in iom8.h che &egrave; inclusa via io.h. Non &egrave; necessario preoccuparsi. Se avete gi&agrave; scritto programmi per sistemi multiutente/multitasking come linux saprete sicuramente che non bisogna utilizzare loop infiniti. Essi infatti sono uno spreco di CPU e rallentano il sistema. Nel caso degli AVR per&ograve; non abbiamo altri programmi o altri task che girano, in effetti non c'&egrave; neppure un sistema operativo che gira. Dunque &egrave; normale usare loop infiniti

    <A NAME="352lfindex10">&nbsp;</A>
<H2>Compilare e caricare</H2>

   Prima di cominciare &egrave; necessario assicurarsi  di avere /usr/local/avr/bin nel PATH. Se necessario editate .bash_profile o .tcshrc e aggiungete:


    <p class="code">export PATH=/usr/local/avr/bin:${PATH} (for
    bash)<br>
     setenv PATH /usr/local/atmel/bin:${PATH} (for tcsh)</p>
Noi utilizzeremo la porta parallela e uisp per programmare l'AVR. uisp fa uso dell'interfaccia ppdev del kernel. Perci&ograve; bisogna caricare nel kernel i seguenti moduli necessari. Controllate con il comando /sbin/lsmod se sono caricati:
<pre class="code">
    # /sbin/lsmod
    parport_pc
    ppdev
    parport
</pre>
    altrimenti caricateli (come root):
<pre class="code">
    modprobe parport
    modprobe parport_pc
    modprobe ppdev

</pre>
    E' in generale una buona idea far eseguire tali comandi automaticamente durante lo startup
    E' possibile aggiungerli ad un rc script (es. per Redhat in /etc/rc.d/rc.local)
    <br>
    Per utilizzare l'interfaccia pppdev come utente normale &egrave; necessario che root dia i permessi in scrittura eseguendo una volta il comando:
    <p class="code">chmod 666 /dev/parport0</p>
    E' necessario inoltre accertarsi che non ci sia nessun demone di stampa in ascolto sulla porta parallela. Se cos&igrave; non fosse fermatelo prima di connettere il programmatore alla porta parallela. Ora tutto &egrave; pronto per compilare il programma e caricarlo sul microcontrollore.
   <br>
     <br>
    Il pacchetto contenente il progetto di prova (<a href=
    "../../common/src2/article352/avrm8ledtest-0.1.tar.gz">avrm8ledtest-0.1.tar.gz</a>)
    include anche un make file. Basta quindi scrivere:
    <br>
<br>
     make <br>
     make load<br>
<br>
     Tale comando compiler&agrave; il software e lo caricher&agrave; sul microcontrollore. Non ho intenzione di scendere nei dettagli di tutti i comandi. E' possibile vederli nel <a
    href="../../common/src2/article352/Makefile.html">Makefile</a>
     e sono sempre i soliti. Neppure io me li ricordo tutti. Mi ricordo solo che mi basta fare  "make load".
    Se volete scrivere un programma diverso, basta sostituire il nome del vostro nuovo programma al posto di avrm8ledtest.


    <A NAME="352lfindex11">&nbsp;</A>
<H2>Alcune interessanti  binutils</H2>

    Molto pi&ugrave; interessanti del semplice processo di compilazione sono alcune delle binutils. <br>
    Tali utilities non sono per&ograve; cambiate molto rispetto a quanto scritto nel Marzo 2002.
    Basta quindi dare un'occhiata al capitolo "Alcune interessanti binutils" nell'
    <a href="../March2002/article231.shtml">articolo 231</a> del Marzo 2002.

    <A NAME="352lfindex12">&nbsp;</A>
<H2>Idee e suggerimenti</H2>


    L'ATmega8 &egrave; in generale compatibile con  AT90S4433. E' necessario programmare i "fuse bits" per utilizzare l'oscillatore esterno, ma in generale l'hardware presentato in precedenza dovrebbe funzionare senza modifiche sostanziali.
    Purtroppo non ho avuto il tempo di ritestare tutti i circuiti per l'ATmega8
    Per stare sicuri, &egrave; meglio utilizzare l'AT90S4433 per i vecchi articoli. Se le sfide non vi spaventano potete provare l'ATmega8
    con i vecchi articoli/circuiti. <br>
    <br>
    Ecco una lista degli articoli pubblicati:

    <ul>
      <li><a href="../May2002/article236.shtml">Pannello di controllo LCD per un server Linux</a></li>

      <li><a href="../November2002/article251.shtml">Alimentatore DC basato su microcontrollori</a></li>

      <li><a href="../September2002/article253.shtml">Frequenzimetro/contatore 1Hz-100MHz con display LCD e interfaccia RS232. </a></li>

      <li><a href="../../English/March2003/article286.shtml">Un display LCD per Linux su USB con  watchdog e pulsanti.</a></li>

      <li><a href="../../English/July2003/article297.shtml">Costruire un robot "inseguitore di luce" autonomo.</a></li>
    </ul>
    <br>
    <br>
    Nota: il programmatore presentato in questo articolo include gi&agrave; le resistenze di protezione che nel caso dei vecchi articoli, erano montate direttamente sui circuiti. Per usare il nuovo programmatore con i circuiti vecchi basta sostituire le resistenze di protezione presenti sui circuiti stessi con dei fili.

<p>Atmel fornisce una application note "AVR081: Replacing AT90S4433 by
ATmega8" che descrive le incompatibilit&agrave; tra i due microcontrollori: <a
href="../../common/src2/article352/at90s4433_to_atmega8.pdf">at90s4433_to_atmega8.pdf
(101343 bytes)</a>

    <A NAME="352lfindex13">&nbsp;</A>
<H2>Riferimenti</H2>


    <ul>
      <li>Pascal Stang's AVRlib: <a href=
      "http://www.procyonengineering.com/avr/avrlib/index.html">http://www.procyonengineering.com/avr/avrlib/index.html</a> or <a href="http://hubbard.engr.scu.edu/embedded/avr/avrlib/">http://hubbard.engr.scu.edu/embedded/avr/avrlib/</a></li>

      <li>L'assembler tavrasm : <a href=
      "http://www.tavrasm.org/">www.tavrasm.org</a></li>

      <li><b>Tutto il software e la documentazione <a href="../../common/src2/article352/index.html">menzionata nell'articolo</a></b></li>

      <li>Sito web di Atmel: <a href=
      "http://www.atmel.com/">www.atmel.com</a></li>

      <li>Pagine dedicate all'elettronica dello shop tuxgraphics:
<a href=
    "http://shop.tuxgraphics.org/">shop.tuxgraphics.org</a>
<br>(Qui &egrave; possibile acquistare il "Linux AVR programming CD", i kit e i microcontrollori)
    </li>
    </ul>
    <!-- vim: set sw=2 ts=2 et tw=80: -->
  



<!-- BODY_OF_THE_ARTICLE_STOP -->
<!-- 2pdaIgnoreStart -->
<A NAME="talkback">&nbsp;</a>
<h2>Discussioni su quest'articolo</h2>
ogni articolo possiede una sua pagina di discussione, da questa pagina puoi inviare un commento o leggere quelli degli altri lettori:
<center>
    <table width="250" border=0><tr><td>
    <div class="tbbutton"><A class="nodec" href="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=352">&nbsp;pagina di discussione&nbsp;</a></div>
    </td></tr></table>
</center>

<br clear="all">
<HR size="2" noshade>
<table width="250" border=0><tr><td>
<div class="bbutton"><a class="nodec" href="../../index.shtml">&lt;--, LF Home</a></div>
</td><td>
<div class="bbutton"><a class="nodec" href="index.shtml">Indice di questo numero</a></div>
</td></tr></table>
<br clear="all">
<HR size="2" noshade>
<!-- ARTICLE FOOT -->
<CENTER><TABLE WIDTH="98%" summary="footer">
<TR><TD ALIGN=CENTER BGCOLOR="#bdc6d5" WIDTH="50%">
<A HREF="../../common/lfteam.html">Webpages maintained by the LinuxFocus Editor team</A>
<BR><FONT COLOR="#1111aa"><a href="../../common/copy.html">&copy; Guido     Socher</a><br>&quot;some rights reserved&quot; see <a href="../../license/index.shtml">linuxfocus.org/license/</a><br><a href="http://www.linuxfocus.org">http://www.LinuxFocus.org</a></FONT>
</TD>
<TD BGCOLOR="#bdc6d5">
<!-- TRANSLATION INFO -->
<font size=2>Translation information:</font>
<TABLE summary="translators">
  <tr><td><font size="2">en --&gt; -- : Guido Socher (<a href="http://linuxfocus.org/~guido/"><font size="1">homepage</font></a>)</font></td></tr>
  <tr><td><font size="2">en --&gt; it: Gianpaolo Demarchi (<a href="malto:gianpaolo.demarchi[at]gmail.com"><font size="1">homepage</font></a>)</font></td></tr>
</TABLE>
</TD>
</TR></TABLE></CENTER>
<p><font size=1>2005-02-04, generated by lfparser version 2.52</font></p>
<!-- 2pdaIgnoreStop -->
</BODY>
</HTML>
