<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
 <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <META NAME="GENERATOR" CONTENT="lfparser_2.52">
 <META NAME="LFCATEGORY" CONTENT="Hardware">
 <link rel="icon" href="../../common/images/lf-16.png" type="image/png">
 <TITLE>lf365, Hardware: Ein digitales Thermometer oder rede I2C mit deinem Microcontroller </TITLE>
<style type="text/css">
<!--
 td.top {font-family: Arial,Geneva,Verdana,Helvetica,sans-serif; font-size:12 }
 pre { font-family:monospace,Courier }
 pre.code { font-family:monospace,Courier;background-color:#aedbe8; }
 p.cl { color:#EE9500 }
 table.left { margin-right:0.3cm }
 a.nodec { text-decoration:none }
 p.trans { font-size:8pt; text-align:right }
 p.clbox { width:50%; alignment:center; background-color:#FFD700; 
           border-style:none; border-width:medium; border-color:#FFD700; 
           padding:0.5cm;  text-align:center }
 p.code { width:80%; alignment:center; background-color:#aedbe8; 
          border-style:none; border-width:medium; border-color:#aedbe8; 
          padding:0.1cm;  text-align:left }
 p.foot { background-color:#AAAAAA; color:#FFFFFF; border-style:none; 
          border-width:medium; border-color:#AAAAAA; padding:0.5cm ; 
          margin-top:0.1cm; margin-right:1cm; margin-left:1cm; 
          text-align:center }
 div.tbbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   margin: 2px 5px 2px 5px;
   text-align: center;
   width: 20em;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
 div.bbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   float: left;
   margin: 2px 5px 2px 5px;
   text-align: center;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
-->
</style>
 
</HEAD>
<BODY bgcolor="#ffffff" text="#000000">
 <!-- this is generated html code. NEVER use this file for your
 translation work. Instead get the file with the same article number
 and .meta.shtml in its name. Translate this meta file and then
 use lfparser program to generate the final article -->
 <!-- lfparser can be obtained from http://main.linuxfocus.org/~guido/dev/lfparser.html -->

<!-- this is used by a number of tools:
 =LF=AUTHOR: Guido Socher
 =LF=CAT___: Hardware
 =LF=TITLE_: Ein digitales Thermometer oder rede I2C mit deinem Microcontroller 
 =LF=NUMBER: 365
 =LF=ANAME_: article365.shtml
 =LF=PARSER: 2.52
 -->

<!-- 2pdaIgnoreStart -->

<!-- start navegation bar, current, style=2 -->
 <!-- top navegation bar -->
 <TABLE summary="topbar_1" cellspacing="0" cellpadding="0" border="0" align="center" width="90%">
   <TR bgcolor="#2e2292">
     <TD class="top"><TABLE summary="topbar_1_logo" cellspacing="0" cellpadding="0" border="0" width=
       "100%">
         <TR><TD width="319"><a href="../../index.shtml"><IMG src="../../common/images/logolftop_319x45.gif"
           alt="[LinuxFocus-icon]" width="319" height="45" align="left" 
           border="0"></a></TD>

           <TD class="top">
             <TABLE summary="topbar_1_links" width="100%">
               <TR align="right">
                 <TD class="top">
                 
                 <A class="nodec" href="../../index.shtml"><FONT color=
                 "#DDDDDD" size="2">&lt;--</FONT></A> &nbsp;| 
                 <A class="nodec" href="../map.html"><FONT color=
                 "#DDDDDD" size="2">Plan</FONT></A> &nbsp;| 
                 <A class="nodec" href="../indice.html"><FONT color=
                 "#DDDDDD" size="2">Index</FONT></A> &nbsp;| 
                 <A class="nodec" href="../Search/index.html"><FONT color=
                 "#DDDDDD" size="2">Suchen</FONT></A> </TD>
                 
               </TR>

               <TR align="right">
                 <TD class="top">
                   <HR width="100%" noshade size="1">
                 </TD>
               </TR>
             </TABLE>
           </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end top navegation bar -->
 <!-- blue bar -->
 <TABLE summary="topbar_2" cellspacing="0" cellpadding="0" border="0" align="center"
 width="90%">
   <TR bgcolor="#00ffff">
     <TD><IMG src="../../common/images/transpix.gif" width="1" height=
     "2" alt=""></TD>
   </TR>
 </TABLE>
 <!-- end blue bar -->
 <!-- bottom navegation bar -->
 <TABLE summary="topbar_3" cellspacing="0" cellpadding="0" border="0" align="center"
 width="94%">
   <TR bgcolor="#000000">
     <TD>
       <TABLE summary="topbar_3_links" cellspacing="0" cellpadding="1" border="0" width=
       "100%">
         <TR align="center">
           <TD WIDTH="20%"><A class="nodec" href="../News/index.shtml"><FONT color=
           "#FFFFFF">Nachrichten</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Archives/index.html"><FONT color=
           "#FFFFFF">Archiv</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Links/index.shtml"><FONT color=
           "#FFFFFF">Links</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../aboutus.html"><FONT color=
           "#FFFFFF">&Uuml;ber uns</FONT></A> </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end bottom navegation bar -->
<!-- stop navegation bar -->

<!-- SSI_INFO -->

<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfdynahead ver 1.5 --><TABLE ALIGN="right" border=0><TR><TD ALIGN="right"><FONT SIZE="-1" FACE="Arial,Helvetica">Dieses Dokument ist verf&uuml;bar auf: <A href="../../English/February2005/article365.shtml">English</a> &nbsp;<A href="../../Castellano/February2005/article365.shtml">Castellano</a> &nbsp;<A href="../../ChineseGB/February2005/article365.shtml">ChineseGB</a> &nbsp;<A href="../../Deutsch/February2005/article365.shtml">Deutsch</a> &nbsp;<A href="../../Francais/February2005/article365.shtml">Francais</a> &nbsp;</FONT></TD></TR></TABLE><br>
 


<!-- SSI_INFO STOP -->
<!-- 2pdaIgnoreStop -->

<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_START -->
<TABLE ALIGN="LEFT" BORDER="0" WIDTH="195" summary="about the author" class="left">
<TR>
<TD>

<img src="../../common/images/Guido-S.gif" alt=
  "[Photo of the Author]" height="164" width="173">
<BR>von  Guido Socher <a href="http://linuxfocus.org/~guido/"><font size="1">(homepage)</font></a>
<BR><BR>
<I>&Uuml;ber den Autor:</I><BR>
<!-- aboutauthor_start -->
<p>Guido mag Linux weil es ein wirklich gutes System ist um eigene Hardware
  zu entwickeln</p>
<!-- aboutauthor_stop -->
<!-- TRANSLATED_TO de -->
<BR><BR><I>&Uuml;bersetzt ins Deutsche von:</I><BR>
Guido Socher (<a href="http://linuxfocus.org/~guido/"><font size="1">homepage</font></a>)
<br>
<!--
 =LF=TRANSTO=de: Guido Socher
-->
<!-- TRANSLATED_TO_STOP -->
<!-- INDEX_START -->
<BR><i>Inhalt</i>:
<UL>
  <LI><A HREF="#365lfindex0">Einf&uuml;hrung</A></LI>
  <LI><A HREF="#365lfindex1">Wie I2C/TWI funktioniert</A></LI>
  <LI><A HREF="#365lfindex2">Die Idee</A></LI>
  <LI><A HREF="#365lfindex3">Der Temperatursensor</A></LI>
  <LI><A HREF="#365lfindex4">Die Schaltung</A></LI>
  <LI><A HREF="#365lfindex5">Die Platine erstellen</A></LI>
  <LI><A HREF="#365lfindex6">Der Aufbau</A></LI>
  <LI><A HREF="#365lfindex7">I2C Kommunikation nutzen.</A></LI>
  <LI><A HREF="#365lfindex8">Wie warm ist es?</A></LI>
  <LI><A HREF="#365lfindex9">Zusammenfassung</A></LI>
  <LI><A HREF="#365lfindex10">Referenzen</A></LI>
  <LI><A HREF="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=365">Talkback f&uuml;r diesen Artikel</A></LI>
</UL>

</TD></TR></TABLE>
<!-- INDEX_STOP -->
<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_STOP -->
<!-- HEAD_OF_THE_ARTICLE_START -->
<br>&nbsp;
<table border="0"><tr><td>
<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfPdf ver 0.1 -->
<TABLE style="border-style:outset; border-width:1px" align="right" bgcolor="#ff9616" cellspacing="1"><TR><TD bgcolor="#ff9616">
        <a href="../Archives/lf-2005_02-0365.pdf"><small>PDF</small></a>
        </TD></TR></TABLE>
         

<H2>Ein digitales Thermometer oder rede I2C mit deinem Microcontroller </H2>
 <img src=
  "../../common/images2/article365/title_365.jpg" alt=
  "[Illustration]" hspace="10">
<!-- ABSTRACT OF THE ARTICLE -->
<P><i>Zusammenfassung</i>:
<P>
<!-- articleabstract_start -->

  Der Atmega8 Microcontroller von Atmel hat jede Menge digitale und analoge
  Ein-/Ausg&auml;nge. Es ist das ideale Bauteil um Me&szlig;elektronik zu entwickeln.
  <br><br>
  In diesem Artikel werden wir sehen wie man einen Microcontroller mit einem
  Linux PC &uuml;ber eine physikalische RS232 Schnittstelle verbinden kann, ohne
  aufwendige Adapterschaltungen wie den MAX232 Chip zu benutzen.

  
<!-- articleabstract_stop -->

<br><!-- HR divider --><center><font color="#8282e0"><b>_________________ _________________ _________________</b></font></center><br>
</td></tr></table>
<!-- HEAD_OF_THE_ARTICLE_STOP -->
<!-- BODY_OF_THE_ARTICLE_START -->


  <A NAME="365lfindex0">&nbsp;</A>
<H2>Einf&uuml;hrung</H2>
Eine Voraussetzung f&uuml;r diesen Artikel ist,
  da&szlig; du die GCC AVR Programmierumgebung, wie in den dem Artikel
  <a href="../November2004/article352.shtml">"Programmieren eines
  AVR Microcontrollers mit GCC, libc 1.0.4"</a> beschrieben,
  installiert hast. Nat&uuml;rlich kannst du, um &Auml;rger bei der
  Installation zu vermeiden, auch die "AVR programming CD" von
  <a href=
  "http://shop.tuxgraphics.org/">http://shop.tuxgraphics.org/</a>
  benutzen. <a href=
  "http://shop.tuxgraphics.org/electronic/microcontroller.html"><img src="../../common/images2/article365/linuxavrcd_th.jpg"
       align="right" width="150" height="213" vspace="4" hspace=
       "4"></a><br>
  <br>
  <br>
  Wenn man so ein enorm m&auml;chtiges Bauteil wie einen Microcontroller
  benutzt, um analoge oder digitale Signale zu messen, dann m&ouml;chte
  man nat&uuml;rlich Schnittstellen zum Auswerten haben und Befehle an
  den Microcontroller schicken k&ouml;nnen. In allen vorangegangenen
  Artikeln haben wir immer die RS232 Schnittstelle mit einem UART
  zur Kommunikation benutzt. Der Nachteil ist hierbei, da&szlig; man
  einen zus&auml;tzlichen MAX232 Chip und 4 Kondensatoren braucht. Atmel
  schl&auml;gt sogar vor, da&szlig; man einen externen Quarz f&uuml;r den
  Oszillator benutzen soll damit die UART Kommunikation zuverl&auml;ssig
  funktioniert. In jeden Fall sind das eine Menge extra
  Bauteile.... und diese kann man vermeiden!<br>
  <br>
  Die Menge an Daten, die zwischen PC und Microcontroller
  &uuml;bertragen werden m&uuml;ssen ist normalerweise klein (nur einige
  Bytes). Die &Uuml;bertragungsgeschwindigkeit spielt daher praktisch
  keine Rolle. Das macht den I2C Bus attraktiv f&uuml;r diese
  Aufgabe.<br>
  <br>
  I2C (ausgesprochen "ei-squ&auml;r-sie") ist ein bidirektionales
  Kommunikationssystem mit nur zwei Dr&auml;hten. Es wurden von Philips
  entwickelt und sie haben sich den Namen sch&uuml;tzen lassen. Daher
  nennen es andere Hersteller nicht I2C. Bei Atmel hei&szlig;t es TWI ("two
  wire interface").<br>
  <br>
  Viele von euch benutzen m&ouml;glicherweise I2C in ihrem PC ohne es zu
  wissen. Alle modernen Motherboards haben einen I2C-Bus um
  Temperatursensoren, L&uuml;ftergeschwingigkeit, verf&uuml;gbaren
  Speicher... und alle m&ouml;glichen anderen Daten zu lesen. Dieser
  I2C-Bus ist leider am normalen PC nicht nach au&szlig;en gef&uuml;hrt (es
  gibt au&szlig;en keine physikalischen Anschlu&szlig; daf&uuml;r). Wir m&uuml;ssen uns
  deshalb etwas neues &uuml;berlegen.<br>
  <br>
  Erst wollen wir aber sehen, wie das "two wire interface" (=TWI =
  anderer Name f&uuml;r I2C) funktioniert.

  <A NAME="365lfindex1">&nbsp;</A>
<H2>Wie I2C/TWI funktioniert</H2>
Das Datenblatt des Atmega8 (siehe
  unten) hat eine sehr detaillierte Beschreibung, die auf Seite 160
  beginnt. Ich werde deshalb hier nur einen &Uuml;berblick geben. Danach
  solltest du in der Lage sein, das Datenblatt zu verstehen.<br>
  <br>
  An einem I2C-Bus hat man immer einen "Master" und verschiedene
  "Slaves". Die Kommunikation findet zu einem Zeitpunkt immer
  zwischen dem Master und genau einem Slave statt. Der Master ist
  das Ger&auml;t, das die Kommunikation beginnt und und den Bit-Takt
  (clock) kontrolliert. Die zwei Dr&auml;hte des I2C-Bus nennen sich SDA
  (Datenleitung) und SCL (Clock line, Taktleitung). Jedes der
  Ger&auml;te mu&szlig; von einer separaten Stromversorgung (genau wie bei
  normaler rs232 Kommunikation) gespeist werden. Die zwei Dr&auml;hte des
  Busses sind normalerweise &uuml;ber 4.7K Widerst&auml;nde mit der logischen
  Eins (+5V f&uuml;r 5V ICs) verbunden. Das ergibt eine elektrische
  Veroderung zwischen den Ger&auml;ten. Ein Ger&auml;t braucht dann nur die
  Leitung auf GND ziehen, wenn es eine 0 &uuml;bertragen will oder nichts
  machen, wenn es eine 1 senden will.<br>
  <br>
  Der Master beginnt einen Dialog indem er ein Bitmuster, das als
  "start condition" gefolgt von der Adresse des Ger&auml;tes das er
  ansprechen m&ouml;chte, schickt. Jedes Ger&auml;t an dem Bus hat eine
  eindeutige 7 Bit Adresse. Danach schickt der Master ein Bit das
  anzeigt ob er lesen oder schreiben m&ouml;chte. Der Slave (das
  angesprochene Ger&auml;t) wird nun best&auml;tigen, da&szlig; es den Master
  verstanden hat und schickt ein ack-bit (ack wie acknowledge). Mit
  anderen Worten wir haben jetzt 9 Datenbits auf dem Bus gesehen (7
  Adressbits + read_bit + ack-bit):
  <pre class="code">
| start | 7-bit slave adr | read_data bit | wait for ack | ... data comes here
</pre>Was kommt danach?<br>
  <br>
  Als n&auml;chstes k&ouml;nnen wir Daten senden oder empfangen. Die Daten
  sind immer ein Vielfaches von 8 Bit (1 Byte) und m&uuml;ssen durch ein
  Ack-Bit best&auml;tigt werden. Es werden also immer 9 Bit &uuml;ber den Bus
  geschickt. Wenn die Kommunikation zu ende ist, schickt der Master
  ein Bitmuster namens "stop condition". Mit anderen Worten der
  Master mu&szlig; wissen, wie viele Daten der Slave schicken m&ouml;chte. Das
  ist aber kein Problem, denn man kann diese Information immer in
  den Dialog zwischen Master und Slave mit den Daten &uuml;bertragen. In
  unserem Fall werden wir z.B. das Null-Byte am Ende eines Strings
  benutzen um anzuzeigen, da&szlig; der &uuml;bertragene String zu ende
  ist.<br>
  <br>
  Die Daten auf dem SDA Draht sind immer solange g&uuml;ltig wie SCL 1
  ist. SDA darf sich also nicht &auml;ndern w&auml;hrend SCL 1 ist:
  <pre class="code">
SDA H -\       /---\     /---\          /---\
    L   \-----/     \---/     \--------/     \------....

SCL H ----\     /-\       /-\     /-\    /-\    /-\
    L      \---/   \-----/   \---/   \--/   \--/   \-....


  | START |      1 |       1 |     0 |    1 |    0 |
</pre>Das Beste an diesem Protokoll ist, da&szlig; man kein genaues
synchrones Taktsignal braucht. Das Protokoll wird immer noch
funktionieren wenn der Takt etwas wackelt (Jitter).<br>
  <br>
  Genau diese Eigenschaft macht es m&ouml;glich, I2C in einer ganz
  normalen Benutzerapplikation zu implementieren. Man braucht kein
  Kernelmodul oder spezielle Hardware (wie UART). Genial oder?

  <A NAME="365lfindex2">&nbsp;</A>
<H2>Die Idee</H2>
Wie schon gesagt k&ouml;nnen wir den PC internen I2C
  Bus nicht benutzen. Stattdessen benutzen wir einfach einige
  Leitungen der RS232 Schnittstelle. Unsere
  Kommunikationsschnittstelle ist also immer noch RS232 aber wir
  brauchen keine MAX232 Hardware, keine Kondensatoren, .... etc<br>
  <br>
  Der schwierige Teil ist nun das I2C Protokoll neu in einer
  Linuxapplikation zu implementieren und zu testen. Ich habe daf&uuml;r
  5 Wochen gebraucht bis es 100%ig funktionierte und du kannst es
  einfach kopieren :-). Ich hoffe du erkennst den Wert dieses
  Programms, wenn du es benutzt.<br>
  Als Anwendung f&uuml;r unser neues I2C Protokoll werden wir ein
  Thermometer bauen. Du kannst nat&uuml;rlich auch irgend etwas anderes
  messen oder einfach Lichter ein/aus-schalten. Es ist deine
  Entscheidung.<br>
  <br>
  In einem zweiten Artikel werden wir ein LCD-Display hinzuf&uuml;gen.
  Mit anderen Worten es wird ein Thermometer bei dem man die
  Temperatur &uuml;ber den Linux PC oder direkt &uuml;ber eine Anzeige
  ablesen kann. Das Display kommt in einem zweiten Artikel um
  diesen hier nicht zu &uuml;berladen.

  <table align="right" width="162">
    <tr>
      <td bgcolor="#C5D4F9"><img src=
      "../../common/images2/article365/ntc.jpg" alt="ntc"><br>
      NTCs sind klein, billig und ausreichend genau</td>
    </tr>
  </table>

  <A NAME="365lfindex3">&nbsp;</A>
<H2>Der Temperatursensor</H2>
Es gibt schon fertig kalibrierte
  Temperatursensoren (einige von ihnen reden sogar I2C ;-) aber
  diese sind recht teuer. NTCs sind viel billiger und fast genauso
  gut selbst ohne Kalibrierung. Wenn man sie kalibriert kann man
  Genauigkeiten bis hinter dem Dezimalpunkt erreichen.<br>
  <br>
  Ein Problem von NTCs ist ihre Nichtlinearit&auml;t. Es ist aber
  eigentlich nur eine Frage der Halbleiterphysik hier die richtige
  Formel zu finden und diese nicht lineare Kurve zu korrigieren.
  Der Microcontroller ist ein kleiner Computer und mathematische
  Operationen sind &uuml;berhaupt kein Problem. NTCs sind
  temperaturabh&auml;ngige Widerst&auml;nde. Der Widerstandswert R eines NTCs
  bei einer gegebenen Temperatur ist:<br clear="all">

  <center>
    <img src="../../common/images2/article365/Ntcformula.gif" alt=
    "ntc formula">
  </center>T oder Tc ist die Temperatur, die wir suchen. Rn ist der
  Widerstandswert bei 25'C. Man kann NTCs mit 4.7K, 10K, ...
  kaufen. Rn ist dieser Wert.<br>

  <A NAME="365lfindex4">&nbsp;</A>
<H2>Die Schaltung</H2>


  <table align="right">
    <tr>
      <td>
        <center>
          <a href=
          "../../common/images2/article365/i2ctemp_schematic.gif"><img src="../../common/images2/article365/i2ctemp_schematic_th.gif"
               alt="circuit diagram"></a><br>
          Schaltplan. Klick auf den Plan um eine genauere Ansicht
          zu erhalten.
        </center>
      </td>
    </tr>
  </table>Nun haben wir alles um das digitale Thermometer zu bauen.
  Wir nehmen zwei NTCs. Einen f&uuml;r innen und einen f&uuml;r die
  Au&szlig;entemperatur. Du kannst noch mehr Sensoren anschlie&szlig;en.
  (conn3, Pin PC2 ist z.B frei). In dem Schaltbild sieht man schon
  das LCD-Display. Ich wollte vermeiden, da&szlig; f&uuml;r den n&auml;chsten
  Artikel wieder eine neue Schaltung gebaut werden mu&szlig;.<br>
  <br>
  In der Schaltung findet sich eine ein LED. Das kostet nicht viel
  und ist sehr n&uuml;tzlich zum debuggen. Ich habe es oft benutzt als
  ich die I2C State-machine f&uuml;r die Kommunikation zwischen PC und
  Microcontroller entwickelt habe. Im normalen Betrieb lassen wir
  die LED einfach blinken um zu zeigen, da&szlig; Messwerte genommen
  werden.<br>
  <br>
  Die Schaltung ist ansonsten ganz einfach. Der
  Analogdigitalwandler in dem Microcontroller wird benutzt um den
  Spannungsabfall an einem NTC zu messen. Dieser wird dann in einen
  Temperaturwert &uuml;bersetzt.<br>
  <br>
  Der Atmega8 hat verschiedene M&ouml;glichkeiten die Referenzspannung
  des Analogdigitalwandlers zu w&auml;hlen. Man kann entweder
  5V (AVcc) oder einen interen 2.56V Referenz benutzen. F&uuml;r die
  Innentemperatur brauchen wir einen viel kleineren Bereich. +10'C
  bis +40'C sollten ausreichen. Wir nehmen daher hier die 2.56V
  Referenz und erhalten die doppelte Genauigkeit, da jetzt 1024
  m&ouml;gliche digitale Werte auf 0-2.56V verteilt sind. Das ergibt
  eine Genauigkeit von 2.5mV (genauer als die meisten digitalen
  Voltmeter!).<br>
  <br>
  Der CD Anschlu&szlig; an der RS232 Schnittstelle ist ein Eingang und
  wir schlie&szlig;en ihn daher an die SDA Leitung des I2C Bus an. DTR
  und RTS sind Ausg&auml;nge. Wenn der PC Daten-bits auf den Bus gibt,
  dann &auml;ndert er einfach DTR. Der I2C Master, hier der Linux PC,
  kontrolliert die SCL (Takt) Leitung. Mit anderen Worten SCL ist
  ein Ausgang an dem RS232 Anschlu&szlig;.<br>
  <br>
  Der 78L05 wird benutzt um eine stabile Stromversorgung und eine
  Referenzspannung zu erhalten. Du kannst daher fast jede Art von
  Stromversorgung benutzen. DC oder AC zwischen 7.5V ond 12V. 9V
  ist eine gute Wahl.

  <A NAME="365lfindex5">&nbsp;</A>
<H2>Die Platine erstellen</H2>


  <table align="right" width="202">
    <tr>
      <td bgcolor="#C5D4F9"><a href=
      "http://shop.tuxgraphics.org"><img src=
      "../../common/images2/article365/article365kit_th.jpg" alt=
      "get this kit from the tuxgraphics shop"></a><br>
      tuxgraphics.org verkauft alle n&ouml;tigen Bauteile zusammen mir
      einer ge&auml;tzten Platine.</td>
    </tr>
  </table>Man kann nat&uuml;rlich auch die Lochrasterplatine aus dem
  vorangegangenen Artikel benutzen. Dazu mu&szlig; man die LED auf Pin
  11 uml&ouml;ten und die neuen Bauteile hinzuf&uuml;gen.<br>
  <br>
  Wenn du jedoch eine Schaltung bauen m&ouml;chtest, die auch gut
  aussieht, dann macht es mehr Sinn eine neue Platine zu &auml;tzen,
  denn diese Schaltung ist einfach viel komplexer als die
  Testschaltung aus dem ersten Artikel. Nachdem ich Iznogood's
  Linuxfocus Artikel &uuml;ber gEDA gelesen hatte, beschloss ich dieses
  Mal gEDA anstelle von Eagel zu benutzen. gschem, das
  Schaltplanzeichenprogramm von gEDA ist sehr gut. Die Bibliothek
  der vorhandenen Symbole ist wesentlich kleiner als bei Eagle und
  so mu&szlig;te ich mein eigenes Symbol f&uuml;r den Atmega8 entwerfen, aber
  ging erstaunlich einfach. Viel problematischer ist pcb, das
  Programm zum Zeichnen der Platine. Wenn man vorher Eagle benutzt
  hat wird man zun&auml;chst irritiert sein, da&szlig; sich die
  Gummibandverbindungen von den Bauteilen entfernen lassen. Um
  sicher zu sein, da&szlig; das richtige Gummiband an dem richtigen
  Bauteil h&auml;ngt mu&szlig; man sie von Zeit zu Zeit neu erzeugen
  (Connects-&gt;Optimize rats-nest). Man sollte sich auch sehr
  sicher sein, da&szlig; der Schaltplan komplett ist, denn nachtr&auml;glich
  &Auml;nderungen werden nur halb manuell &uuml;bertragen und es einfach
  dabei Fehler zu machen. <img src=
  "../../common/images2/article365/i2ctemppcb_topview_position_components.png"
        alt="top view, position of components" align="left"><br>
  <br>
  Ich benutzte den orangen Layer zum zeichnen. Irgendwie
  erzeugten die anderen verf&uuml;gbaren Farben einfach keine Ausgabe
  beim Drucken. Das Problem ist jedoch, das dieser orange Layer
  offenbar auf der Seite liegt, wo die Bauteile sind. Man mu&szlig; das
  Ergebnis also spiegeln. Letztendlich entschloss ich mich, die
  wesentlichen Teile des Layout mit pcb und den Rest mit gimp zu
  zeichnen.<br>
  <br>
  Dank <a href=
  "http://shop.tuxgraphics.org">shop.tuxgraphics.org</a> brauchst
  du nicht mit gef&auml;hrlichen Chemikalien zu hantieren oder in
  verschiedenen Gesch&auml;ften nach den richtigen Komponenten suchen.
  tuxgraphics verkauft alle Teile, die man f&uuml;r diesen Artikel
  braucht.

  <A NAME="365lfindex6">&nbsp;</A>
<H2>Der Aufbau</H2>
Beim Zusammenbau sollte man auf die Teile
  achten, bei denen die Polarit&auml;t wichtig ist:
  Elektrolytkoindenstoren, Dioden, Z-Dioden, 78L05, LED und
  Microcontroller.<br>
  <br>
  Bevor man den Microcontroller in den Sockel steckt sollte man die
  Stromversorgung mit einem Me&szlig;ger&auml;t testen. Falls diese nicht
  funktioniert bekommt man nicht nur falsche Werte, sondern zerst&ouml;rt
  m&ouml;glicherweise auch den Microcontroller. Als n&auml;chstes kann man
  die Schaltung an den RS232 Anschlu&szlig; des Linux PCs anschlie&szlig;en un
  mit dem i2c_rs232_pintest Programm die verschiedenen
  Signalkombinationen auf den SDA und SCL Anschl&uuml;ssen zu testen.
  <pre class="code">
i2c_rs232_pintest -d 1 -c 1
i2c_rs232_pintest -d 0 -c 1
i2c_rs232_pintest -d 1 -c 0
</pre>Dieses Programm setzt die Spannungspegel auf den RTS (als SCL
genutzt, Option -c) und DTR (als SDA genutzt, Optio -d) an der
RS232 Schnittstelle. RS232 hat Spannungen von +/- 10V. Hinter den
Z-Dioden sollte man jedoch nur -0.7 f&uuml;r eine logische Null und
+4-5V f&uuml;r eine logische Eins messen.<br>
  <br>
  Erst wenn diese Tests bestanden sind, sollte man den
  Microcontroller in den Sockel setzen.

  <A NAME="365lfindex7">&nbsp;</A>
<H2>I2C Kommunikation nutzen.</H2>
Lade das linuxI2Ctemp tar.gz
  File herunter (siehe Referenzen) und entpacke es. Die I2C
  Kommunikation ist in 2 Dateien implementiert:
  <pre class="code">
i2c_avr.c -- die i2c Zustandsmaschine f&uuml;r den atmega8
i2c_m.c   -- das komplette i2c Protokoll f&uuml;r die Linuxseite.
</pre>Ich habe dem atmega8 die Slave Adresse "3" gegeben. Um den
String "hello" and den atmega8 zu senden w&uuml;rde man folgende C
Funktionen ausf&uuml;hren:
  <pre class="code">
address_slave(3,0); // tell the slave that we will send something
i2c_tx_string("hello");
i2cstop(); // release the i2c bus

Auf der Microcontrollerseite w&uuml;rde man den String mit
der folgenden Funktion empfangen:
i2c_get_received_data(rec_buf);
</pre>Ganz einfach. Das lesen von Daten aus dem Microcontroller
geht &auml;hnlich.

  <A NAME="365lfindex8">&nbsp;</A>
<H2>Wie warm ist es?</H2>
Um den Code f&uuml;r den Microcontroller zu
  kompilieren und zu laden, sind die folgenden Befehle n&ouml;tig:
  <pre class="code">
make
make load
</pre>Um die Programme i2c_rs232_pintest und i2ctemp_linux zu
compilieren tippt man:
  <pre class="code">
make i2c_rs232_pintest
make i2ctemp_linux
</pre>... oder man kann die vorkompilierten Versionen aus dem "bin"
Verzeichnis benutzen.<br>
  <br>
  Um Temperaturwerte zu lesen nimmt man einfach:
  <pre class="code">
i2ctemp_linux
</pre>... und die Werte f&uuml;r Innen- und Au&szlig;entemperatur werden auf
den Bildschirm gedruckt. Um diese Daten &uuml;ber einen Webserver zur
Verf&uuml;gung zu stellen empfehle ich nicht das i2ctemp_linux Programm
direkt vom Webserver aus laufen zu lassen, da es recht langsam ist.
Besser ist es einen cron-Job zu schreiben, der regelm&auml;&szlig;ig eine
html-Datei erzeugt. Ein Beispiel daf&uuml;r findet sich in der README
Datei des linuxI2Ctemp Paketes.

  <A NAME="365lfindex9">&nbsp;</A>
<H2>Zusammenfassung</H2>
Das I2C Protokoll braucht sehr wenig extra
  Hardware und ist optimiert f&uuml;r kleine Datenmengen. Das ist genau
  das, was wir brauchen, wenn wir Me&szlig;daten von dem Microcontroller
  lesen. Eine elegante L&ouml;sung.<br>
  <br>
  In diesem Artikel lag der Schwerpunkt auf der Hardware. Wenn dir
  dieser Artikel gefallen hat, dann schreibe ich noch einen zweiten
  Artikel, in dem die Software beschrieben wird. Speziell wie die
  Analogdigitalwandlung und die Implementation des I2C Protokolls
  funktionieren. In diesem zweiten Artikel kommen auch das LCD
  Display und Celsius nach Fahrenheit Konvertierung hinzu.

  <A NAME="365lfindex10">&nbsp;</A>
<H2>Referenzen</H2>


  <ul>
    <li><b>Download</b>-Seite f&uuml;r diesen Artikel: <a href="../../common/src2/article365/index.html">die linuxI2Ctemp Software,
    Zeichnungen, Software-updates</a></li>

    <li>Wie man den Atmega8 mit gcc programmiert: <a href=
    "../November2004/article352.shtml">November2004 Artikel
    352</a></li>

    <li>Datenblatt f&uuml;r den Atmega8: gehe nach http://www.atmel.com/
    und selektiere products-&gt;Microcontrollers -&gt;AVR-8 bit
    RISC-&gt;Documentation-&gt;datasheets <a href=
    "../../common/src2/article365/atmega8.pdf">(lokale Kopie, pdf,
    2479982 Bytes)</a></li>

    <li>Der tuxgraphics shop. Ein wirklich toller Onlineshop :-):
    <a href=
    "http://shop.tuxgraphics.org/">shop.tuxgraphics.org</a><br>
    Hier bekommt man die Linux AVR Programmier-CD, alle Teile f&uuml;r
    diesen Artikel, LCD Displays und Microcontroller</li>
  </ul><!-- vim: set sw=2 ts=2 et tw=80: -->



<!-- BODY_OF_THE_ARTICLE_STOP -->
<!-- 2pdaIgnoreStart -->
<A NAME="talkback">&nbsp;</a>
<h2>Talkback f&uuml;r diesen Artikel</h2>
Jeder Artikel hat seine eigene Seite f&uuml;r Kommentare und R&uuml;ckmeldungen. Auf dieser Seite kann jeder eigene Kommentare abgeben und die Kommentare anderer Leser sehen:
<center>
    <table width="250" border=0><tr><td>
    <div class="tbbutton"><A class="nodec" href="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=365">&nbsp;Talkback Seite&nbsp;</a></div>
    </td></tr></table>
</center>

<br clear="all">
<HR size="2" noshade>
<table width="250" border=0><tr><td>
<div class="bbutton"><a class="nodec" href="../../index.shtml">&lt;--, LF Home</a></div>
</td><td>
<div class="bbutton"><a class="nodec" href="index.shtml">Zum index dieser Ausgabe</a></div>
</td></tr></table>
<br clear="all">
<HR size="2" noshade>
<!-- ARTICLE FOOT -->
<CENTER><TABLE WIDTH="98%" summary="footer">
<TR><TD ALIGN=CENTER BGCOLOR="#bdc6d5" WIDTH="50%">
<A HREF="../../common/lfteam.html">Der LinuxFocus Redaktion schreiben</A>
<BR><FONT COLOR="#1111aa"><a href="../../common/copy.html">&copy; Guido Socher</a><br>&quot;some rights reserved&quot; see <a href="../../license/index.shtml">linuxfocus.org/license/</a><br><a href="http://www.linuxfocus.org">http://www.LinuxFocus.org</a></FONT>
</TD>
<TD BGCOLOR="#bdc6d5">
<!-- TRANSLATION INFO -->
<font size=2>Autoren und &Uuml;bersetzer:</font>
<TABLE summary="translators">
  <tr><td><font size="2">en --&gt; -- : Guido Socher (<a href="http://linuxfocus.org/~guido/"><font size="1">homepage</font></a>)</font></td></tr>
  <tr><td><font size="2">en --&gt; de: Guido Socher (<a href="http://linuxfocus.org/~guido/"><font size="1">homepage</font></a>)</font></td></tr>
</TABLE>
</TD>
</TR></TABLE></CENTER>
<p><font size=1>2005-03-25, generated by lfparser version 2.52</font></p>
<!-- 2pdaIgnoreStop -->
</BODY>
</HTML>
