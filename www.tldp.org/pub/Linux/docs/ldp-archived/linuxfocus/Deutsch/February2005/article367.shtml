<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
 <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <META NAME="GENERATOR" CONTENT="lfparser_2.52">
 <META NAME="LFCATEGORY" CONTENT="KernelCorner">
 <link rel="icon" href="../../common/images/lf-16.png" type="image/png">
 <TITLE>lf367, KernelCorner: Schreiben Ihres eigenen netfilter-Tests</TITLE>
<style type="text/css">
<!--
 td.top {font-family: Arial,Geneva,Verdana,Helvetica,sans-serif; font-size:12 }
 pre { font-family:monospace,Courier }
 pre.code { font-family:monospace,Courier;background-color:#aedbe8; }
 p.cl { color:#EE9500 }
 table.left { margin-right:0.3cm }
 a.nodec { text-decoration:none }
 p.trans { font-size:8pt; text-align:right }
 p.clbox { width:50%; alignment:center; background-color:#FFD700; 
           border-style:none; border-width:medium; border-color:#FFD700; 
           padding:0.5cm;  text-align:center }
 p.code { width:80%; alignment:center; background-color:#aedbe8; 
          border-style:none; border-width:medium; border-color:#aedbe8; 
          padding:0.1cm;  text-align:left }
 p.foot { background-color:#AAAAAA; color:#FFFFFF; border-style:none; 
          border-width:medium; border-color:#AAAAAA; padding:0.5cm ; 
          margin-top:0.1cm; margin-right:1cm; margin-left:1cm; 
          text-align:center }
 div.tbbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   margin: 2px 5px 2px 5px;
   text-align: center;
   width: 20em;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
 div.bbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   float: left;
   margin: 2px 5px 2px 5px;
   text-align: center;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
-->
</style>
 
</HEAD>
<BODY bgcolor="#ffffff" text="#000000">
 <!-- this is generated html code. NEVER use this file for your
 translation work. Instead get the file with the same article number
 and .meta.shtml in its name. Translate this meta file and then
 use lfparser program to generate the final article -->
 <!-- lfparser can be obtained from http://main.linuxfocus.org/~guido/dev/lfparser.html -->

<!-- this is used by a number of tools:
 =LF=AUTHOR: Nicolas Bouliane
 =LF=CAT___: KernelCorner
 =LF=TITLE_: Schreiben Ihres eigenen netfilter-Tests
 =LF=NUMBER: 367
 =LF=ANAME_: article367.shtml
 =LF=PARSER: 2.52
 -->

<!-- 2pdaIgnoreStart -->

<!-- start navegation bar, current, style=2 -->
 <!-- top navegation bar -->
 <TABLE summary="topbar_1" cellspacing="0" cellpadding="0" border="0" align="center" width="90%">
   <TR bgcolor="#2e2292">
     <TD class="top"><TABLE summary="topbar_1_logo" cellspacing="0" cellpadding="0" border="0" width=
       "100%">
         <TR><TD width="319"><a href="../../index.shtml"><IMG src="../../common/images/logolftop_319x45.gif"
           alt="[LinuxFocus-icon]" width="319" height="45" align="left" 
           border="0"></a></TD>

           <TD class="top">
             <TABLE summary="topbar_1_links" width="100%">
               <TR align="right">
                 <TD class="top">
                 
                 <A class="nodec" href="../../index.shtml"><FONT color=
                 "#DDDDDD" size="2">&lt;--</FONT></A> &nbsp;| 
                 <A class="nodec" href="../map.html"><FONT color=
                 "#DDDDDD" size="2">Plan</FONT></A> &nbsp;| 
                 <A class="nodec" href="../indice.html"><FONT color=
                 "#DDDDDD" size="2">Index</FONT></A> &nbsp;| 
                 <A class="nodec" href="../Search/index.html"><FONT color=
                 "#DDDDDD" size="2">Suchen</FONT></A> </TD>
                 
               </TR>

               <TR align="right">
                 <TD class="top">
                   <HR width="100%" noshade size="1">
                 </TD>
               </TR>
             </TABLE>
           </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end top navegation bar -->
 <!-- blue bar -->
 <TABLE summary="topbar_2" cellspacing="0" cellpadding="0" border="0" align="center"
 width="90%">
   <TR bgcolor="#00ffff">
     <TD><IMG src="../../common/images/transpix.gif" width="1" height=
     "2" alt=""></TD>
   </TR>
 </TABLE>
 <!-- end blue bar -->
 <!-- bottom navegation bar -->
 <TABLE summary="topbar_3" cellspacing="0" cellpadding="0" border="0" align="center"
 width="94%">
   <TR bgcolor="#000000">
     <TD>
       <TABLE summary="topbar_3_links" cellspacing="0" cellpadding="1" border="0" width=
       "100%">
         <TR align="center">
           <TD WIDTH="20%"><A class="nodec" href="../News/index.shtml"><FONT color=
           "#FFFFFF">Nachrichten</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Archives/index.html"><FONT color=
           "#FFFFFF">Archiv</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Links/index.shtml"><FONT color=
           "#FFFFFF">Links</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../aboutus.html"><FONT color=
           "#FFFFFF">&Uuml;ber uns</FONT></A> </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end bottom navegation bar -->
<!-- stop navegation bar -->

<!-- SSI_INFO -->

<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfdynahead ver 1.5 --><TABLE ALIGN="right" border=0><TR><TD ALIGN="right"><FONT SIZE="-1" FACE="Arial,Helvetica">Dieses Dokument ist verf&uuml;bar auf: <A href="../../English/February2005/article367.shtml">English</a> &nbsp;<A href="../../ChineseGB/February2005/article367.shtml">ChineseGB</a> &nbsp;<A href="../../Deutsch/February2005/article367.shtml">Deutsch</a> &nbsp;<A href="../../Francais/February2005/article367.shtml">Francais</a> &nbsp;</FONT></TD></TR></TABLE><br>
 


<!-- SSI_INFO STOP -->
<!-- 2pdaIgnoreStop -->

<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_START -->
<TABLE ALIGN="LEFT" BORDER="0" WIDTH="195" summary="about the author" class="left">
<TR>
<TD>

<img src="../../common/images2/NicolasBouliane.jpg" alt="Photo of Nicolas Bouliane">
<BR>von  Nicolas Bouliane <br> <small>&lt;nib(at)cookinglinux!org&gt;</small>
<BR><BR>
<I>&Uuml;ber den Autor:</I><BR>
<!-- aboutauthor_start -->

Nicolas ist ein junger K&auml;mpfer in der Gemeinschaft freier Software. Er ist ein GNU/Linux-Abh&auml;ngiger,
seit dem er es im Jahre 1998 auf seinem Rechner installierte. Er verbringt seine Zeit damit,
den Linux Netzwerkstack zu untersuchen, freie Software zu schreiben und Linux-bezogene Konferenzen
wie OLS zu besuchen. Wenn er nicht vor seinem Computer sitzt, schaut er SciFi-Filme an,
spielt Schach und h&ouml;rt Richard Stallmans Reden.



<!-- aboutauthor_stop -->
<!-- TRANSLATED_TO de -->
<BR><BR><I>&Uuml;bersetzt ins Deutsche von:</I><BR>
Hermann J. Beckers <small>&lt;hj.beckers /at/ onlinehome.de&gt;</small>
<br>
<!--
 =LF=TRANSTO=de: Hermann J. Beckers
-->
<!-- TRANSLATED_TO_STOP -->
<!-- INDEX_START -->
<BR><i>Inhalt</i>:
<UL>
  <LI><A HREF="#367lfindex0">Beschreibung</A></LI>
  <LI><A HREF="#367lfindex1">1.0 Das iptables-Modul</A></LI>
  <LI><A HREF="#367lfindex2">1.1 verf&uuml;gbare Strukturen und Funktionen</A></LI>
  <LI><A HREF="#367lfindex3">1.2 Innerhalb des Programm-Skeletts</A></LI>
  <LI><A HREF="#367lfindex4">1.2.1 Initialisierung</A></LI>
  <LI><A HREF="#367lfindex5">1.2.2 Speicher-Funktion</A></LI>
  <LI><A HREF="#367lfindex6">1.2.3 Druckfunktion</A></LI>
  <LI><A HREF="#367lfindex7">1.2.4 Funktion letzter Test</A></LI>
  <LI><A HREF="#367lfindex8">1.2.5 Auswerte-Funktion</A></LI>
  <LI><A HREF="#367lfindex9">1.2.6 Optionen-Struktur</A></LI>
  <LI><A HREF="#367lfindex10">1.2.7 Initialisierungs-Funktion</A></LI>
  <LI><A HREF="#367lfindex11">1.2.7 Hilfe-Funktion</A></LI>
  <LI><A HREF="#367lfindex12">1.2.8 Die Header-Datei 'ipt_ipaddr.h'</A></LI>
  <LI><A HREF="#367lfindex13">1.3 Zusammenfassung Kapitel 1</A></LI>
  <LI><A HREF="#367lfindex14">2.0 Das netfilter-Modul</A></LI>
  <LI><A HREF="#367lfindex15">2.1 verf&uuml;gbare Strukturen und Funktionen</A></LI>
  <LI><A HREF="#367lfindex16">2.2 Innerhalb des Programm-Skeletts</A></LI>
  <LI><A HREF="#367lfindex17">2.2.1 Initialisierung</A></LI>
  <LI><A HREF="#367lfindex18">2.2.2 'match'-Funktion</A></LI>
  <LI><A HREF="#367lfindex19">2.2.3 Funktion 'checkentry'</A></LI>
  <LI><A HREF="#367lfindex20">2.3 Zusammenfassung Kapitel 2</A></LI>
  <LI><A HREF="#367lfindex21">3.0 mit iptables/netfilter spielen</A></LI>
  <LI><A HREF="#367lfindex22">3.1 iptables</A></LI>
  <LI><A HREF="#367lfindex23">3.2 Kernel</A></LI>
  <LI><A HREF="#367lfindex24"> Zusammenfassung </A></LI>
  <LI><A HREF="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=367">Talkback f&uuml;r diesen Artikel</A></LI>
</UL>

</TD></TR></TABLE>
<!-- INDEX_STOP -->
<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_STOP -->
<!-- HEAD_OF_THE_ARTICLE_START -->
<br>&nbsp;
<table border="0"><tr><td>
<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfPdf ver 0.1 -->
<TABLE style="border-style:outset; border-width:1px" align="right" bgcolor="#ff9616" cellspacing="1"><TR><TD bgcolor="#ff9616">
        <a href="../Archives/lf-2005_02-0367.pdf"><small>PDF</small></a>
        </TD></TR></TABLE>
         

<H2>Schreiben Ihres eigenen netfilter-Tests</H2>
 <IMG SRC="../../common/images2/article367.png" ALT="[Illustration]" HSPACE=10>
<!-- ABSTRACT OF THE ARTICLE -->
<P><i>Zusammenfassung</i>:
<P>
<!-- articleabstract_start -->

Das iptables/netfilter-Rahmenwerk gibt uns die M&ouml;glichkeit, Eigenschaften hinzuzuf&uuml;gen.
Dazu schreibt man Kernel-Module, die sich bei diesem Rahmenwerk registrieren. Abh&auml;ngig von der
Kategorie dieser neuen Eigenschaft schreiben wir auch ein iptables-Modul. Durch das
Schreiben Ihrer neuen Erweiterung k&ouml;nnen Sie ein bestimmtes Paket testen, ver&auml;ndern,
akzeptieren und verfolgen. Tats&auml;chlich k&ouml;nnen Sie im Bereich des Filterns fast alles tun,
was Sie m&ouml;chten.

Beachten Sie, dass ein kleiner Fehler in einem Kernel-Modul Ihren Computer abst&uuml;rzen
lassen kann.<br><br>

Aus Gr&uuml;nden der Einfachheit werde ich einen Mustertest erl&auml;utern, den ich geschrieben habe.
Auf diese Weise hoffe ich, dass die Interaktion mit dem Rahmenwerk leichter zu verstehen
ist. Ich setze hier voraus, dass Sie bereits etwas &uuml;ber iptables wissen und auch die
C-Programmierung kennen.
<br><br>

Dieses Beispiel wird Ihnen zeigen, wie man ein Paket entsprechend der Quell- und/oder
Zieladresse verfolgt.



<!-- articleabstract_stop -->

<br><!-- HR divider --><center><font color="#8282e0"><b>_________________ _________________ _________________</b></font></center><br>
</td></tr></table>
<!-- HEAD_OF_THE_ARTICLE_STOP -->
<!-- BODY_OF_THE_ARTICLE_START -->

<A NAME="367lfindex0">&nbsp;</A>
<H2>Beschreibung</H2>



Die allgemeinen Schritte zum Erstellen eines iptables/netfilter-Moduls sind:<ul>
  <li> Sie m&ouml;chten eine spezielle Situation abfangen.
  </li><li> Schreiben des Teils f&uuml;r den Benutzerbereich, der die Argumente behandelt.
  </li><li> Schreiben des Teils f&uuml;r den Kernel-Bereich, der die Pakete analysiert und
  erkl&auml;rt, ob eine &Uuml;bereinstimmung vorliegt oder nicht.
</li></ul>

<A NAME="367lfindex1">&nbsp;</A>
<H2>1.0 Das iptables-Modul</H2>



Zweck einer iptables-Bibliothek ist einfach die Interaktion mit dem Anwender. Sie behandelt
die Argumente, die der Anwender an den Kernel-Teil weiterleiten will.

<A NAME="367lfindex2">&nbsp;</A>
<H2>1.1 verf&uuml;gbare Strukturen und Funktionen</H2>


Zun&auml;chst einige grundlegende Strukturen
&lt;<i>iptables/include/iptables.h</i>&gt;<br>
Weiter im Text werden wir sehen, was der Zweck eines jeden Feldes ist.<table width="70%"><tbody><tr><td>
<pre class="code">/* Include file for additions: new matches and targets. */
struct iptables_match
{
   struct iptables_match *next;

   ipt_chainlabel name;

   const char *version;

   /* Size of match data. */
   size_t size;

   /* Size of match data relevent for userspace comparison purposes */
   size_t userspacesize;

   /* Function which prints out usage message. */
   void (*help)(void);

   /* Initialize the match. */
   void (*init)(struct ipt_entry_match *m, unsigned int *nfcache);

   /* Function which parses command options; returns true if it
           ate an option */
   int (*parse)(int c, char **argv, int invert, unsigned int *flags,
           const struct ipt_entry *entry,
           unsigned int *nfcache,
           struct ipt_entry_match **match);

   /* Final check; exit if not ok. */
   void (*final_check)(unsigned int flags);

   /* Prints out the match iff non-NULL: put space at end */
   void (*print)(const struct ipt_ip *ip,
            const struct ipt_entry_match *match, int numeric);

   /* Saves the match info in parsable form to stdout. */
   void (*save)(const struct ipt_ip *ip,
           const struct ipt_entry_match *match);

   /* Pointer to list of extra command-line options */
   const struct option *extra_opts;

   /* Ignore these men behind the curtain: */
   unsigned int option_offset;
   struct ipt_entry_match *m;
   unsigned int mflags;
#ifdef NO_SHARED_LIBS
   unsigned int loaded; /* simulate loading so options are merged properly */
#endif
};
</pre>
</td></tr></tbody></table>

<A NAME="367lfindex3">&nbsp;</A>
<H2>1.2 Innerhalb des Programm-Skeletts</H2>


<A NAME="367lfindex4">&nbsp;</A>
<H3>1.2.1 Initialisierung</H3>



Wir initialisieren die allgemeinen Felder in der Struktur 'iptables_match'.

<pre class="code">static struct iptables_match ipaddr
= {
</pre>

'Name' ist die Zeichenkette mit dem Namen Ihrer Bibliothek (z. B. libipt_ipaddr).<br>
Sie k&ouml;nnen keinen anderen Namen angeben, er wird f&uuml;r das automatische Laden Ihrer
Bibliothek benutzt.

<pre class="code">    .name            = "ipaddr",
</pre>

Das n&auml;chste Feld 'version' ist die Version von iptables. Die beiden n&auml;chsten Felder
werden benutzt, um eine Korelation zwischen der Gr&ouml;&szlig;e der zwischen dem Benutzerbereich und dem
Kernelbereich gemeinsam genutzten Struktur zu erhalten.

<pre class="code">    .version         = IPTABLES_VERSION,
    .size            = IPT_ALIGN(sizeof(struct ipt_ipaddr_info)),
    .userspacesize   = IPT_ALIGN(sizeof(struct ipt_ipaddr_info)),
</pre>

'Help' wird aufgerufen, wenn der Benutzer 'iptables -m module -h' eingibt. 'Parse'
wird aufgerufen, wenn Sie eine neue Regel eingeben, es dient zur &Uuml;berpr&uuml;fung der
Argumente. 'print' wird von 'iptables -L' aufgerufen, um die vorher eingegebenen
Regeln anzuzeigen.

<pre class="code">    .help            = &amp;help,
    .init            = &amp;init,
    .parse           = &amp;parse,
    .final_check     = &amp;final_check,
    .print           = &amp;print,
    .save            = &amp;save,
    .extra_opts      = opts
};
</pre>

Die iptables-Infrastruktur kann mehrere gemeinsam genutzte Bibliotheken unterst&uuml;tzen.
Jede Bibliothek muss sich bei iptables durch Aufruf von 'register_match()' registrieren,
welche in &lt;<i>iptables/iptables.c</i>&gt; definiert ist. Diese Funktion wird aufgerufen,
wenn das Modul von iptables geladen wird.

Zu weiteren Informationen hierzu siehe 'man dlopen'.
<pre class="code">void _init(void)
{
   register_match(&amp;ipaddr);
}
</pre>

<A NAME="367lfindex5">&nbsp;</A>
<H3>1.2.2 Speicher-Funktion</H3>



Wenn wir eine Regelmenge sichern wollen, bietet iptables das Werkzeug 'iptables-save',
das alle Ihre Regeln ausgibt. Offensichtlich ben&ouml;tigt es die Hilfe Ihrer Erweiterung, um
die richtigen Regeln auszugeben. Dies wird durch den Aufruf dieser Funktion erreicht.

<pre class="code">static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
{
   const struct ipt_ipaddr_info *info = (const struct ipt_ipaddr_info *)match-&gt;data;
</pre>
Wir geben die Quell-Adresse aus, wenn sie Teil der Regel ist.

<pre class="code">   if (info-&gt;flags &amp; IPADDR_SRC) {
      if (info-&gt;flags &amp; IPADDR_SRC_INV)
         printf("! ");
      printf("--ipsrc ");
      print_ipaddr((u_int32_t *)&amp;info-&gt;ipaddr.src);
   }
</pre>
Wir geben die Ziel-Adresse aus, wenn sie Teil der Regel ist.
<pre class="code">   if (info-&gt;flags &amp; IPADDR_DST) {
      if (info-&gt;flags &amp; IPADDR_DST_INV)
         printf("! ");
      printf("--ipdst ");
      print_ipaddr((u_int32_t *)&amp;info-&gt;ipaddr.dst);
   }
}
</pre>

<A NAME="367lfindex6">&nbsp;</A>
<H3>1.2.3 Druckfunktion</H3>


Im gleichen Sinne wie die vorherige, versucht diese Funktion, Information &uuml;ber die Regel
auszugeben. Sie wird von 'iptables -L' aufgerufen. Sp&auml;ter im Text werden wir den Zweck von
 'ipt_entry_match *match' sehen, aber Sie wissen bestimmt schon etwas dar&uuml;ber.

<pre class="code">static void print(const struct ipt_ip *ip,
                  const struct ipt_entry_match *match,
                  int numeric)
{
   const struct ipt_ipaddr_info *info = (const struct ipt_ipaddr_info *)match-&gt;data;

   if (info-&gt;flags &amp; IPADDR_SRC) {
         printf("src IP ");
      if (info-&gt;flags &amp; IPADDR_SRC_INV)
         printf("! ");
      print_ipaddr((u_int32_t *)&amp;info-&gt;ipaddr.src);
   }

   if (info-&gt;flags &amp; IPADDR_DST) {
      printf("dst IP ");
      if (info-&gt;flags &amp; IPADDR_DST_INV)
         printf("! ");
      print_ipaddr((u_int32_t *)&amp;info-&gt;ipaddr.dst);
   }
}
</pre>

<A NAME="367lfindex7">&nbsp;</A>
<H3>1.2.4 Funktion letzter Test</H3>


Diese Funktion ist eine letzte Gelegenheit f&uuml;r Sicherheitspr&uuml;fungen. Sie wird direkt
nach der Argumentauswertung aufgerufen, wenn der Anwender eine neue Regel eingibt.

<pre class="code">static void final_check(unsigned int flags)
{
   if (!flags)
      exit_error(PARAMETER_PROBLEM, "ipt_ipaddr: Invalid parameters.");
}
</pre>

<A NAME="367lfindex8">&nbsp;</A>
<H3>1.2.5 Auswerte-Funktion</H3>


Dies ist die wichtigste Funktion, weil wir hier verifizieren, dass die Argumente
korrekt benutzt werden und wir Informationen eintragen, die wir mit dem Kernel-Teil
gemeinsam verwenden. Sie wird jedesmal aufgerufen, wenn ein Argument gefunden wird, d. h.
wenn der Anwender zwei Argumente eingibt, wird sie zweimal mit dem Argument-Code in der
Variablen 'c' aufgerufen.


<pre class="code">static int parse(int c, char **argv, int invert, unsigned int *flags,
                 const struct ipt_entry *entry,
                 unsigned int *nfcache,
                 struct ipt_entry_match **match)
{
</pre>

Wir benutzten diese spezielle Struktur, um Informationen zu erhalten, die wir mit dem
Kernel-Teil teilen. Der 'Match'-Zeiger wird an einige Funktionen weitergereicht,
damit wir mit der gleichen Datenstruktur arbeiten k&ouml;nnen. Sobald die Regel geladen ist,
wird dieser Zeiger in den Kernel-Bereich geladen. Auf diese Weise weiss das Kernel-Modul,
um welche Analyse der Anwender gebeten hat (und darum geht es doch, oder?).

<pre class="code">   struct ipt_ipaddr_info *info = (struct ipt_ipaddr_info *)(*match)-&gt;data;
</pre>
Jedes Argument korrespondiert mit einem einzelnen Wert, so dass wir spezielle Aktionen
entsprechend den eingegebenen Argumenten durchf&uuml;hren k&ouml;nnen	. Wir werden sp&auml;ter im Text
sehen, wie wir Argumente auf Werte abbilden.
<br>
<pre class="code">   switch(c) {
</pre>
Zun&auml;chst testen wir, ob das Argument mehr als einmal benutzt wurde. Wenn dies der Fall
zu sein scheint, rufen wir das in &lt;<i>iptables/iptables.c</i>&gt; definierte
 'exit_error()', das unmittelbar mit dem Status-Flag 'PARAMETER_PROBLEM' (definiert
 in &lt;<i>iptables/include/iptables_common.h</i>&gt;), zur&uuml;ckkehrt.
 Ansonsten setzen wir 'flags' und 'info-&gt;flags' auf den in unserer Header-Datei
 definierten Wert 'IPADDR_SRC'. Diese Header-Datei werden wir sp&auml;ter sehen.
<br><br>
Obwohl beide Flags offensichtlich den gleichen Zweck haben, ist dies wirklich nicht der
Fall. Der Bereich von 'flags' ist nur diese Funktion und 'info-&gt;flags'
ist ein Teilfeld unserer Struktur, die mit dem Kernel-Teil gemeinsam benutzt wird.

<pre class="code">      case '1':
         if (*flags &amp; IPADDR_SRC)
            exit_error(PARAMETER_PROBLEM, "ipt_ipaddr: Only use --ipsrc once!");
         *flags |= IPADDR_SRC;
         info-&gt;flags |= IPADDR_SRC;
</pre>

Wir verifizieren, ob  das Invert-Flag, '!', eingegeben wurde und setzen entsprechende
Informationen in 'info-&gt;flags'.<br>Als n&auml;chstes rufen wir 'parse_ipaddr', eine
interne Funktion, die f&uuml;r dieses Programm-Skelett geschrieben wurde, um eine Zeichenkette mit der
IP-Adresse in einen 32-Bit-Wert zu wandeln.
<br>

<pre class="code">         if (invert)
            info-&gt;flags |= IPADDR_SRC_INV;

         parse_ipaddr(argv[optind-1], &amp;info-&gt;ipaddr.src);
         break;
</pre>

Auf die gleiche Art testen wir auf mehrfache Verwendung und setzen entsprechende
Flags.
<pre class="code">      case '2':
         if (*flags &amp; IPADDR_DST)
            exit_error(PARAMETER_PROBLEM, "ipt_ipaddr: Only use --ipdst once!");
         *flags |= IPADDR_DST;
         info-&gt;flags |= IPADDR_DST;
         if (invert)
            info-&gt;flags |= IPADDR_DST_INV;

         parse_ipaddr(argv[optind-1], &amp;info-&gt;ipaddr.dst);
         break;

      default:
         return 0;
   }

   return 1;
}
</pre>
<A NAME="367lfindex9">&nbsp;</A>
<H3>1.2.6 Optionen-Struktur</H3>


Wir haben bereits diskutiert, das jedes Argument auf einen einzelnen Wert abgebildet
wird. Die 'struct option' ist der bessere Weg, dies zu erreichen. Zu weiteren
Informationen &uuml;ber diese Struktur, empfehle ich Ihnen sehr, 'man 3 getopt' zu lesen.

<pre class="code">static struct option opts[] = {
   { .name = "ipsrc",   .has_arg = 1,   .flag = 0,   .val = '1' },
   { .name = "ipdst",   .has_arg = 1,   .flag = 0,   .val = '2' },
   { .name = 0 }
};

</pre>
<A NAME="367lfindex10">&nbsp;</A>
<H3>1.2.7 Initialisierungs-Funktion</H3>


Diese Initialisierungsfunktion wird benutzt, um einige spezielle Sachen wie das
netfilter-Cache-System einzurichten. Es ist jetzt nicht sehr wichtig zu wissen, wie
das genau funktioniert.

<pre class="code">static void init(struct ipt_entry_match *m, unsigned int *nfcache)
{
   /* Can't cache this */
   *nfcache |= NFC_UNKNOWN;
}

</pre>
<A NAME="367lfindex11">&nbsp;</A>
<H3>1.2.7 Hilfe-Funktion</H3>


Diese Funktion wird von 'iptables -m match_name -h' aufgerufen, um die
verf&uuml;gbaren Argumente anzuzeigen.
<pre class="code">static void help(void)
{
   printf (
            "IPADDR v%s options:\n"
            "[!] --ipsrc &lt;ip>\t\t The incoming ip addr matches.\n"
            "[!] --ipdst &lt;ip>\t\t The outgoing ip addr matches.\n"
            "\n", IPTABLES_VERSION
         );
}

</pre>
<A NAME="367lfindex12">&nbsp;</A>
<H3>1.2.8 Die Header-Datei 'ipt_ipaddr.h'</H3>


In dieser Datei definieren wir die von uns ben&ouml;tigten Sachen.

<pre class="code">#ifndef _IPT_IPADDR_H
#define _IPT_IPADDR_H
</pre>
Wir haben bereits gesehen, dass wir Flags auf bestimmte Werte setzen.

<pre class="code">#define IPADDR_SRC   0x01     /* Match source IP addr */
#define IPADDR_DST   0x02     /* Match destination IP addr */

#define IPADDR_SRC_INV  0x10  /* Negate the condition */
#define IPADDR_DST_INV  0x20  /* Negate the condition */
</pre>

Die Struktur 'ipt_ipaddr_info' ist diejenige, welche in den Kernel-Teil kopiert wird.

<pre class="code">struct ipt_ipaddr {
   u_int32_t src, dst;
};

struct ipt_ipaddr_info {

   struct ipt_ipaddr ipaddr;

   /* Flags from above */
   u_int8_t flags;

};

#endif
</pre>

<A NAME="367lfindex13">&nbsp;</A>
<H2>1.3 Zusammenfassung Kapitel 1</H2>

Im ersten Teil haben wir den Zweck der iptables-Bibliothek diskutiert.
Wir haben die Interna jeder Funktion besprochen und wie die Struktur 'ipt_ipaddr_info'
benutzt wird, um Informationen zu speichern, die zur weiteren Verwendung in den Kernel-Teil
kopiert werden. Wir schauten ausserdem auf die iptables-Struktur und wie wir unsere neue
Bibliothek registrieren. Sie sollten bedenken, dass dies nur ein Programm-Beispiel ist,
das mir hilft, Ihnen zu zeigen, wie dieses Rahmenwerk arbeitet. Weiterhin sind
'ipt_ipaddr_info' und &auml;hnliche Sachen nicht Teil von iptables/netfilter, sondern
Bestandteil dieses Beispiels.
<A NAME="367lfindex14">&nbsp;</A>
<H2>2.0 Das netfilter-Modul</H2>


Zweck eines Match-Moduls ist es, jedes empfangene Paket zu inspizieren und
zu entscheiden, ob es entsprechend unserer Kriterien &uuml;bereinstimmt oder nicht.
Das Modul hat die folgenden M&ouml;glichkeiten, dieses zu tun:


<ul>
  <li>Empfange jedes Paket, welches die mit dem Match-Modul verbundene Tabelle trifft</li>
  <li>Teile netfilter mit, ob unser Modul auf das Paket zutrifft</li>
</ul>

<A NAME="367lfindex15">&nbsp;</A>
<H2>2.1 verf&uuml;gbare Strukturen und Funktionen</H2>


Zun&auml;chst einige grundlegende Strukturen. Diese Struktr ist definiert in
&lt;<i>linux/netfilter_ipv4/ip_tables.h</i>&gt;.

<br> Wenn Sie daran interessiert sind, mehr &uuml;ber diese und die vorher
f&uuml;r iptables vorgestellte Struktur zu lernen, sollten Sie sich
 <a href="http://www.netfilter.org/documentation/HOWTO/netfilter-hacking-HOWTO.html">netfilter hacking howto</a>
 ansehen, das von Rusty Russell und Harald Welte geschrieben wurde.

<pre class="code">struct ipt_match
{
   struct list_head list;

   const char name[IPT_FUNCTION_MAXNAMELEN];

   /* Return true or false: return FALSE and set *hotdrop = 1 to
           force immediate packet drop. */
   /* Arguments changed since 2.4, as this must now handle
           non-linear skbs, using skb_copy_bits and
           skb_ip_make_writable. */
   int (*match)(const struct sk_buff *skb,
           const struct net_device *in,
           const struct net_device *out,
           const void *matchinfo,
           int offset,
           int *hotdrop);

   /* Called when user tries to insert an entry of this type. */
   /* Should return true or false. */
   int (*checkentry)(const char *tablename,
           const struct ipt_ip *ip,
           void *matchinfo,
           unsigned int matchinfosize,
           unsigned int hook_mask);

   /* Called when entry of this type deleted. */
   void (*destroy)(void *matchinfo, unsigned int matchinfosize);

   /* Set this to THIS_MODULE. */
   struct module *me;
};
</pre>


<A NAME="367lfindex16">&nbsp;</A>
<H2>2.2 Innerhalb des Programm-Skeletts</H2>


<A NAME="367lfindex17">&nbsp;</A>
<H3>2.2.1 Initialisierung</H3>



<p>

Wir initialisieren die allgemeinen Felder in der Struktur 'ipt_match'.


</p><pre class="code">static struct ipt_match ipaddr_match
= {
</pre>
'Name' ist die Zeichenkette mit dem Dateinamen Ihres Moduls (z. B. ipt_ipaddr).
<pre class="code">	.name       = "ipaddr",
</pre>

Die n&auml;chsten Felder enthalten R&uuml;cksprungfunktionen, die das Rahmenwerk benutzen wird.
 'Match' wird aufgerufen, wenn ein Paket an Ihr Modul weitergereicht wird.
<pre class="code">	.match      = match,
	.checkentry = checkentry,
	.me         = THIS_MODULE,
};
</pre>
Die Init-Funktion Ihres Kernelmoduls muss 'ipt_register_match()' aufrufen mit einem
Zeiger auf eine Struktur 'struct ipt_match', um sich beim netfiler-Rahmenwerk zu
registrieren. Diese Funktion wird beim Laden des Moduls aufgerufen.

<pre class="code">static int __init init(void)
{
	printk(KERN_INFO "ipt_ipaddr: init!\n");
	return ipt_register_match(&amp;ipaddr_match);
}
</pre>

Beim Entladen des Moduls wird diese Funktion aufgerufen. Hier deregistrieren wir unser
Match-Modul.
<pre class="code">static void __exit fini(void)
{
	printk(KERN_INFO "ipt_ipaddr: exit!\n");
	ipt_unregister_match(&amp;ipaddr_match);
}
</pre>

Wir &uuml;bergeben ihnen Funktionen, die beim Laden und Entladen des Moduls aufgerufen werden.
<pre class="code">module_init(init);
module_exit(fini);

</pre>

<A NAME="367lfindex18">&nbsp;</A>
<H3>2.2.2 'match'-Funktion</H3>


Der Linux-TCP/IP-Stack verf&uuml;gt &uuml;ber 5 netfilter-Einsprungstellen. Wenn ein Paket
hereinkommt, &uuml;bergibt der Stack das Paket an die entsprechende Einsprungstelle,
welche dann jede Tabelle durchl&auml;uft, die dann ihrerseits jede Regel testet. Wenn
dann Ihr Modul mit dem Paket an die Reihe kommt, kann es endlich seine Aufgabe erf&uuml;llen.
<pre class="code">static int match(const struct sk_buff *skb,
                 const struct net_device *in,
                 const struct net_device *out,
                 const void *matchinfo,
                 int offset,
                 const void *hdr,
                 u_int16_t datalen,
                 int *hotdrop)
{
</pre>
Sie erinnern sich hoffentlich daran, was wir im Benutzerbereich getan haben! :).
Nun &uuml;bertragen wir die vom Benutzerbereich kopierte Struktur in unsere eigene.
<pre class="code">	const struct ipt_skeleton_info *info = matchinfo;
</pre>
'skb' enth&auml;lt das Paket, das wir untersuchen wollen. Zu weiteren Informationen &uuml;ber
diese m&auml;chtige Struktur, die &uuml;berall im LInux-TCP/IP-Stack benutzt wird, hat Harald Welte
einen exzellenten
<a href="ftp://ftp.gnumonks.org/pub/doc/skb-doc.html">Artikel (ftp://ftp.gnumonks.org/pub/doc/skb-doc.html)</a>
geschrieben.
<pre class="code">   struct iphdr *iph = skb-&gt;nh.iph;
</pre>
Hier geben wir nur einige lustige Sachen aus, um zu sehen, wie sie aussehen.
Das Makro 'NIPQUAD' wird benutzt, um eine IP-Adresse in lesbarer Form auszugeben,
definiert in &lt;<i>linux/include/linux/kernel.h</i>&gt;.
<pre class="code">   printk(KERN_INFO "ipt_ipaddr: IN=%s OUT=%s TOS=0x%02X "
                    "TTL=%x SRC=%u.%u.%u.%u DST=%u.%u.%u.%u "
                    "ID=%u IPSRC=%u.%u.%u.%u IPDST=%u.%u.%u.%u\n",

                    in ? (char *)in : "", out ? (char *)out : "", iph-&gt;tos,
                    iph-&gt;ttl, NIPQUAD(iph-&gt;saddr), NIPQUAD(iph-&gt;daddr),
                    ntohs(iph-&gt;id), NIPQUAD(info-&gt;ipaddr.src), NIPQUAD(info-&gt;ipaddr.dst)
         );
</pre>
Wenn das Argument '--ipsrc' &uuml;bergeben wurde, schauen wir, ob die Quelladresse mit der in
der Regel angegebenen &uuml;bereinstimmt. Wir vergessen nicht, das Invert-Flag '!'
zu ber&uuml;cksichtigen. Wenn es keine &Uuml;bereinstimmung gibt, geben wir das Urteil 0 zur&uuml;ck.
<pre class="code">   if (info-&gt;flags &amp; IPADDR_SRC) {
      if ( (ntohl(iph-&gt;saddr) != ntohl(info-&gt;ipaddr.src)) ^ !!(info-&gt;flags &amp; IPADDR_SRC_INV) ) {

         printk(KERN_NOTICE "src IP %u.%u.%u.%u is not matching %s.\n",
                            NIPQUAD(info-&gt;ipaddr.src),
                            info-&gt;flags &amp; IPADDR_SRC_INV ? " (INV)" : "");
         return 0;
      }
   }
</pre>
Hier machen wir das gleiche mit der Ausnahme, das wir auf die Zieladresse schauen, wenn
'--ipdst' eingegeben wurde.
<pre class="code">   if (info-&gt;flags &amp; IPADDR_DST) {
      if ( (ntohl(iph-&gt;daddr) != ntohl(info-&gt;ipaddr.dst)) ^ !!(info-&gt;flags &amp; IPADDR_DST_INV) )  {

         printk(KERN_NOTICE "dst IP %u.%u.%u.%u is not matching%s.\n",
                            NIPQUAD(info-&gt;ipaddr.dst),
                            info-&gt;flags &amp; IPADDR_DST_INV ? " (INV)" : "");
         return 0;
      }
   }
</pre>
Wenn beides nicht zutrifft, geben wir das Urteil 1 zur&uuml;ck, was bedeutet, dass das
Paket &uuml;bereinstimmt.
<pre class="code">   return 1;
}
</pre>


<A NAME="367lfindex19">&nbsp;</A>
<H3>2.2.3 Funktion 'checkentry'</H3>


Checkentry wird &uuml;berwiegend benutzt als letzte M&ouml;glichkeit f&uuml;r Sicherheitstest.
Es ist etwas schwer zu verstehen, wenn es aufgerufen wird. Zur Erl&auml;uterung siehe dieses
 <a href="http://www.mail-archive.com/netfilter-devel@lists.samba.org/msg00625.html">Posting (http://www.mail-archive.com/netfilter-devel@lists.samba.org/msg00625.html)</a>.
Dies wird auch im 'netfilter hacking howto' erl&auml;utert.

<pre class="code">static int checkentry(const char *tablename,
                             const struct ipt_ip *ip,
                             void *matchinfo,
                             unsigned int matchsize,
                             unsigned int hook_mask)
{
   const struct ipt_skeleton_info *info = matchinfo;

   if (matchsize != IPT_ALIGN(sizeof(struct ipt_skeleton_info))) {
      printk(KERN_ERR "ipt_skeleton: matchsize differ, you may have forgotten to recompile me.\n");
      return 0;
   }

   printk(KERN_INFO "ipt_skeleton: Registered in the %s table, hook=%x, proto=%u\n",
                    tablename, hook_mask, ip-&gt;proto);

   return 1;
}

</pre>
<A NAME="367lfindex20">&nbsp;</A>
<H2>2.3 Zusammenfassung Kapitel 2</H2>

In diesem zweiten Teil behandelten wir das netfilter-Modul und wie es mittels einer
speziellen Struktur registriert wird. Zus&auml;tzlich diskutierten wir, wie man eine
spezifische Situation entsprechend der vom Benutzer-Teil bereitgestellten Kriterien
auf &Uuml;bereinstimmung testet.
<A NAME="367lfindex21">&nbsp;</A>
<H2>3.0 mit iptables/netfilter spielen</H2>

Wir haben gesehen, wie man ein neues iptables/netfilter-Match-Modul schreibt. Nun wollen
wir es unserem Kernel hinzuf&uuml;gen, um damit zu spielen. Hier setzte ich voraus, dass Sie einen
Kernel erstellen bzw kompilieren k&ouml;nnen. Zun&auml;chst holen Sie sich die match-Dateien f&uuml;r
dieses Programm-Skelett
von <a href="../../common/src2/article367/index.html">der Download-Seite f&uuml;r diesen Artikel</a>.

<A NAME="367lfindex22">&nbsp;</A>
<H3>3.1 iptables</H3>


Wenn Sie nicht &uuml;ber die iptables-Quellen verf&uuml;gen, k&ouml;nnen Sie sie von
<a href="ftp://ftp.netfilter.org/pub/iptables/">ftp://ftp.netfilter.org/pub/iptables/</a> abrufen.
Dann m&uuml;ssen Sie 'libipt_ipaddr.c' nach &lt;<i>iptables/extensions/</i>&gt; kopieren.<br><br>

Dies ist eine Zeile von &lt;<i>iptables/extensions/Makefile</i>&gt; in der Sie 'ipaddr'
hinzuf&uuml;gen m&uuml;ssen.
<pre class="code">PF_EXT_SLIB:=ah addrtype comment connlimit connmark conntrack dscp ecn
esp hashlimit helper icmp iprange length limit <b>ipaddr</b> mac mark
multiport owner physdev pkttype realm rpc sctp standard state tcp tcpmss
tos ttl udp unclean CLASSIFY CONNMARK DNAT DSCP ECN LOG MARK MASQUERADE
MIRROR NETMAP NOTRACK REDIRECT REJECT SAME SNAT TARPIT TCPMSS TOS TRACE
TTL ULOG
</pre>

<A NAME="367lfindex23">&nbsp;</A>
<H3>3.2 Kernel</H3>


Zun&auml;chst m&uuml;ssen Sie 'ipt_ipaddr.c' in &lt;<i>linux/net/ipv4/netfilter/</i>&gt;
und 'ipt_ipaddr.h' nach &lt;<i>linux/include/linux/netfilter_ipv4/</i>&gt; kopieren.
Einige von Ihnen benutzen immer noch Linux 2.4, daher zeige ich die zu editierenden
Dateien f&uuml;r 2.4 und 2.6.<br><br>

F&uuml;r 2.4 editieren Sie &lt;<i>linux/net/ipv4/netfilter/Config.in</i>&gt; und f&uuml;gen die
fett dargestellte Zeile hinzu.
<pre class="code"># The simple matches.
  dep_tristate '  limit match support' CONFIG_IP_NF_MATCH_LIMIT $CONFIG_IP_NF_IPTABLES
<b>  dep_tristate '  ipaddr match support' CONFIG_IP_NF_MATCH_IPADDR $CONFIG_IP_NF_IPTABLES</b>
</pre>

Dann editieren Sie  &lt;<i>linux/Documentation/Configure.help</i>&gt; und f&uuml;gen den
fett dargestellten Text hinzu. Ich habe etwas Text kopiert, um Ihnen dabei zu helfen,
wo Sie Ihren hinzuf&uuml;gen k&ouml;nnen.
<pre class="code">limit match support
CONFIG_IP_NF_MATCH_LIMIT
  limit matching allows you to control the rate at which a rule can be
  ...<b>
ipaddr match support
CONFIG_IP_NF_MATCH_IPADDR
  ipaddr matching. etc etc.</b>
</pre>

Zum Schluss m&uuml;ssen Sie diese fett dargestellte Zeile in
 &lt;<i>linux/net/ipv4/netfilter/Makefile</i>&gt; einf&uuml;gen.
<pre class="code"># matches
obj-$(CONFIG_IP_NF_MATCH_HELPER) += ipt_helper.o
obj-$(CONFIG_IP_NF_MATCH_LIMIT) += ipt_limit.o
<b>obj-$(CONFIG_IP_NF_MATCH_IPADDR) += ipt_ipaddr.o</b>
</pre>

F&uuml;r 2.6 sind die zu editierenden Dateien &lt;<i>linux/net/ipv4/netfilter/Kconfig</i>&gt;
und &lt;<i>linux/net/ipv4/netfilter/Makefile</i>&gt;.

<A NAME="367lfindex24">&nbsp;</A>
<H2> Zusammenfassung </H2>


Nun m&uuml;ssen Sie nur noch rekompilieren und das hinzuf&uuml;gen, was ich vergessen habe, Ihnen
zu erz&auml;hlen.<br>
Fr&ouml;hliches Hacken!!

<br>
Danke an Samuel Jean.




<!-- BODY_OF_THE_ARTICLE_STOP -->
<!-- 2pdaIgnoreStart -->
<A NAME="talkback">&nbsp;</a>
<h2>Talkback f&uuml;r diesen Artikel</h2>
Jeder Artikel hat seine eigene Seite f&uuml;r Kommentare und R&uuml;ckmeldungen. Auf dieser Seite kann jeder eigene Kommentare abgeben und die Kommentare anderer Leser sehen:
<center>
    <table width="250" border=0><tr><td>
    <div class="tbbutton"><A class="nodec" href="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=367">&nbsp;Talkback Seite&nbsp;</a></div>
    </td></tr></table>
</center>

<br clear="all">
<HR size="2" noshade>
<table width="250" border=0><tr><td>
<div class="bbutton"><a class="nodec" href="../../index.shtml">&lt;--, LF Home</a></div>
</td><td>
<div class="bbutton"><a class="nodec" href="index.shtml">Zum index dieser Ausgabe</a></div>
</td></tr></table>
<br clear="all">
<HR size="2" noshade>
<!-- ARTICLE FOOT -->
<CENTER><TABLE WIDTH="98%" summary="footer">
<TR><TD ALIGN=CENTER BGCOLOR="#bdc6d5" WIDTH="50%">
<A HREF="../../common/lfteam.html">Der LinuxFocus Redaktion schreiben</A>
<BR><FONT COLOR="#1111aa"><a href="../../common/copy.html">&copy; Nicolas Bouliane</a><br>&quot;some rights reserved&quot; see <a href="../../license/index.shtml">linuxfocus.org/license/</a><br><a href="http://www.linuxfocus.org">http://www.LinuxFocus.org</a></FONT>
</TD>
<TD BGCOLOR="#bdc6d5">
<!-- TRANSLATION INFO -->
<font size=2>Autoren und &Uuml;bersetzer:</font>
<TABLE summary="translators">
  <tr><td><font size="2">en --&gt; -- : Nicolas Bouliane <small>&lt;nib(at)cookinglinux!org&gt;</small></font></td></tr>
  <tr><td><font size="2">en --&gt; de: Hermann J. Beckers &lt;hj.beckers /at/ onlinehome.de&gt;</font></td></tr>
</TABLE>
</TD>
</TR></TABLE></CENTER>
<p><font size=1>2005-07-21, generated by lfparser version 2.52</font></p>
<!-- 2pdaIgnoreStop -->
</BODY>
</HTML>
