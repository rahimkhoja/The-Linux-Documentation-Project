<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
 <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <META NAME="GENERATOR" CONTENT="lfparser_2.52">
 <META NAME="LFCATEGORY" CONTENT="Hardware">
 <link rel="icon" href="../../common/images/lf-16.png" type="image/png">
 <TITLE>lf369, Hardware: Teil 2 -- Ein digitales Thermomether order rede I2C mit deinem Microcontroller</TITLE>
<style type="text/css">
<!--
 td.top {font-family: Arial,Geneva,Verdana,Helvetica,sans-serif; font-size:12 }
 pre { font-family:monospace,Courier }
 pre.code { font-family:monospace,Courier;background-color:#aedbe8; }
 p.cl { color:#EE9500 }
 table.left { margin-right:0.3cm }
 a.nodec { text-decoration:none }
 p.trans { font-size:8pt; text-align:right }
 p.clbox { width:50%; alignment:center; background-color:#FFD700; 
           border-style:none; border-width:medium; border-color:#FFD700; 
           padding:0.5cm;  text-align:center }
 p.code { width:80%; alignment:center; background-color:#aedbe8; 
          border-style:none; border-width:medium; border-color:#aedbe8; 
          padding:0.1cm;  text-align:left }
 p.foot { background-color:#AAAAAA; color:#FFFFFF; border-style:none; 
          border-width:medium; border-color:#AAAAAA; padding:0.5cm ; 
          margin-top:0.1cm; margin-right:1cm; margin-left:1cm; 
          text-align:center }
 div.tbbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   margin: 2px 5px 2px 5px;
   text-align: center;
   width: 20em;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
 div.bbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   float: left;
   margin: 2px 5px 2px 5px;
   text-align: center;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
-->
</style>
 
</HEAD>
<BODY bgcolor="#ffffff" text="#000000">
 <!-- this is generated html code. NEVER use this file for your
 translation work. Instead get the file with the same article number
 and .meta.shtml in its name. Translate this meta file and then
 use lfparser program to generate the final article -->
 <!-- lfparser can be obtained from http://main.linuxfocus.org/~guido/dev/lfparser.html -->

<!-- this is used by a number of tools:
 =LF=AUTHOR: Guido     Socher
 =LF=CAT___: Hardware
 =LF=TITLE_: Teil 2 -- Ein digitales Thermomether order rede I2C mit deinem Microcontroller
 =LF=NUMBER: 369
 =LF=ANAME_: article369.shtml
 =LF=PARSER: 2.52
 -->

<!-- 2pdaIgnoreStart -->

<!-- start navegation bar, current, style=2 -->
 <!-- top navegation bar -->
 <TABLE summary="topbar_1" cellspacing="0" cellpadding="0" border="0" align="center" width="90%">
   <TR bgcolor="#2e2292">
     <TD class="top"><TABLE summary="topbar_1_logo" cellspacing="0" cellpadding="0" border="0" width=
       "100%">
         <TR><TD width="319"><a href="../../index.shtml"><IMG src="../../common/images/logolftop_319x45.gif"
           alt="[LinuxFocus-icon]" width="319" height="45" align="left" 
           border="0"></a></TD>

           <TD class="top">
             <TABLE summary="topbar_1_links" width="100%">
               <TR align="right">
                 <TD class="top">
                 
                 <A class="nodec" href="../../index.shtml"><FONT color=
                 "#DDDDDD" size="2">&lt;--</FONT></A> &nbsp;| 
                 <A class="nodec" href="../map.html"><FONT color=
                 "#DDDDDD" size="2">Plan</FONT></A> &nbsp;| 
                 <A class="nodec" href="../indice.html"><FONT color=
                 "#DDDDDD" size="2">Index</FONT></A> &nbsp;| 
                 <A class="nodec" href="../Search/index.html"><FONT color=
                 "#DDDDDD" size="2">Suchen</FONT></A> </TD>
                 
               </TR>

               <TR align="right">
                 <TD class="top">
                   <HR width="100%" noshade size="1">
                 </TD>
               </TR>
             </TABLE>
           </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end top navegation bar -->
 <!-- blue bar -->
 <TABLE summary="topbar_2" cellspacing="0" cellpadding="0" border="0" align="center"
 width="90%">
   <TR bgcolor="#00ffff">
     <TD><IMG src="../../common/images/transpix.gif" width="1" height=
     "2" alt=""></TD>
   </TR>
 </TABLE>
 <!-- end blue bar -->
 <!-- bottom navegation bar -->
 <TABLE summary="topbar_3" cellspacing="0" cellpadding="0" border="0" align="center"
 width="94%">
   <TR bgcolor="#000000">
     <TD>
       <TABLE summary="topbar_3_links" cellspacing="0" cellpadding="1" border="0" width=
       "100%">
         <TR align="center">
           <TD WIDTH="20%"><A class="nodec" href="../News/index.shtml"><FONT color=
           "#FFFFFF">Nachrichten</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Archives/index.html"><FONT color=
           "#FFFFFF">Archiv</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Links/index.shtml"><FONT color=
           "#FFFFFF">Links</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../aboutus.html"><FONT color=
           "#FFFFFF">&Uuml;ber uns</FONT></A> </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end bottom navegation bar -->
<!-- stop navegation bar -->

<!-- SSI_INFO -->

<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfdynahead ver 1.5 --><TABLE ALIGN="right" border=0><TR><TD ALIGN="right"><FONT SIZE="-1" FACE="Arial,Helvetica">Dieses Dokument ist verf&uuml;bar auf: <A href="../../English/March2005/article369.shtml">English</a> &nbsp;<A href="../../ChineseGB/March2005/article369.shtml">ChineseGB</a> &nbsp;<A href="../../Deutsch/March2005/article369.shtml">Deutsch</a> &nbsp;<A href="../../Francais/March2005/article369.shtml">Francais</a> &nbsp;</FONT></TD></TR></TABLE><br>
 


<!-- SSI_INFO STOP -->
<!-- 2pdaIgnoreStop -->

<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_START -->
<TABLE ALIGN="LEFT" BORDER="0" WIDTH="195" summary="about the author" class="left">
<TR>
<TD>

<img src="../../common/images/Guido-S.gif" alt=
    "[Photo of the Author]" height="164" width="173">
<BR>von  Guido Socher <a href="http://linuxfocus.org/~guido/"><font size="1">(homepage)</font></a>
<BR><BR>
<I>&Uuml;ber den Autor:</I><BR>
<!-- aboutauthor_start -->
<p>Guido mag Linux weil es ein wirklich gutes System ist, um eigene Hardware
    zu entwickeln.</p>
<!-- aboutauthor_stop -->
<!-- TRANSLATED_TO de -->
<BR><BR><I>&Uuml;bersetzt ins Deutsche von:</I><BR>
Guido Socher (<a href="http://linuxfocus.org/~guido/"><font size="1">homepage</font></a>)
<br>
<!--
 =LF=TRANSTO=de: Guido Socher
-->
<!-- TRANSLATED_TO_STOP -->
<!-- INDEX_START -->
<BR><i>Inhalt</i>:
<UL>
  <LI><A HREF="#369lfindex0">Die neuen Teile</A></LI>
  <LI><A HREF="#369lfindex1">Das LCD-Display</A></LI>
  <LI><A HREF="#369lfindex2">Ein einfaches GUI</A></LI>
  <LI><A HREF="#369lfindex3">Wie es funktioniert: Analogdigitalwandler</A></LI>
  <LI><A HREF="#369lfindex4">Wie es funktioniert: I2C Kommunikation, Atmega8 Teil</A></LI>
  <LI><A HREF="#369lfindex5">Wie es funktioniert: I2C Kommunikation, Linux Seite</A></LI>
  <LI><A HREF="#369lfindex6">USB zu RS232</A></LI>
  <LI><A HREF="#369lfindex7">Zusammenfassung</A></LI>
  <LI><A HREF="#369lfindex8">Referenzen</A></LI>
  <LI><A HREF="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=369">Talkback f&uuml;r diesen Artikel</A></LI>
</UL>

</TD></TR></TABLE>
<!-- INDEX_STOP -->
<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_STOP -->
<!-- HEAD_OF_THE_ARTICLE_START -->
<br>&nbsp;
<table border="0"><tr><td>
<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfPdf ver 0.1 -->
<TABLE style="border-style:outset; border-width:1px" align="right" bgcolor="#ff9616" cellspacing="1"><TR><TD bgcolor="#ff9616">
        <a href="../Archives/lf-2005_03-0369.pdf"><small>PDF</small></a>
        </TD></TR></TABLE>
         

<H2>Teil 2 -- Ein digitales Thermomether order rede I2C mit deinem Microcontroller</H2>
 <img src="../../common/images2/article369/title_369.jpg" alt="[Illustration]" hspace="10" width="320" height="205">
<!-- ABSTRACT OF THE ARTICLE -->
<P><i>Zusammenfassung</i>:
<P>
<!-- articleabstract_start -->

    In diesem zweiten Teil werden wir ein LCD display in unser Thermomether einbauen
    und ich werde erkl&auml;ren wie die Software funktioniert.
<br><br>
Die Leser, die neu hinzugekommen sind, sollten zuerst
<a href="../February2005/article365.shtml">den ersten Teil (Februar 2005
Artikel 365)</a> lesen.

    
<!-- articleabstract_stop -->

<br><!-- HR divider --><center><font color="#8282e0"><b>_________________ _________________ _________________</b></font></center><br>
</td></tr></table>
<!-- HEAD_OF_THE_ARTICLE_STOP -->
<!-- BODY_OF_THE_ARTICLE_START -->


    <A NAME="369lfindex0">&nbsp;</A>
<H2>Die neuen Teile</H2>

In dem
<a href="../February2005/article365.shtml">vorrangegangenen Artikel
</a> haben wir schon den wichtigsten Teil der Hardware, die n&ouml;tig war um
Temperaturen zu messen, aufgebaut. In diesem Artikel gibt es nun ein
sehr einfaches gtk GUI und ein LCD display.
 <br>
<br>
Es ist sehr einfach diese beiden Dinge hinzuzuf&uuml;gen, deshalb werde ich den
Rest des Artikels darauf verwenden die I2C Software und die Analogdigitalwandler
Software zu erkl&auml;ren.

    <A NAME="369lfindex1">&nbsp;</A>
<H2>Das LCD-Display</H2>

Als Display benugtzen wir ein HD44780 kompatibles Display, wie ich es schon in
&auml;lteren Artikeln eingesetzt hatte. Diese Displays sind sehr einfach in Verbindung
mit Microcontrollern zu benutzen, da man einfach ASCII Zeichen an das Display
schicken kann.

<br>
<center>
<img src="../../common/images2/article369/lcd_linux.gif" alt="HD44780 compatible LCD display" width="250" height="103">
</center>
<br>
Wie f&uuml;r alle anderen Artikel in dieser Serie gibt es auch hier wieder die Bauteile
bei <a
href="http://shop.tuxgraphics.org">shop.tuxgraphics.org</a>
<br>
Ich benutze den gleichen LCD-Treiber wie in den &auml;lteren Artikeln. Die Dateien,
die den Treiber implementieren sind lcd.c, lcd.h und lcd_hw.h. Sie sind Teil
des Paketes, welches sich am Ende des Artikels herrunterladen l&auml;&szlig;t.
Das Interface f&uuml;r diesen Code ist wirklich einfach zu benutzen:

<pre class="code">
// call this once:
// initialize LCD display, cursor off
lcd_init(LCD_DISP_ON);

// to write some text we first clear
// the display:
lcd_clrscr();
lcd_puts("Hello");
// go to the second line:
lcd_gotoxy(0,1);
lcd_puts("LCD");
</pre>
Wie diese HD44780 Displays genau funktionieren ist in
<a href="../September2002/article258.shtml">dem linuxfocus
September2002 Artikel "HD44780 kompatible LCD-Displays verstehen"</a>
erkl&auml;rt.

<br>
<br>
Die Software ist so geschrieben, da&szlig; sie mit 16x2 und 20x2 Zeichen Displays
funktioniert.
<br>
<br>
<img src="../../common/images2/article369/boardchange_th.jpg" alt="board change" align="right"  width="220" height="214">
Es gibt leider im Schaltbild ein &Auml;nderung. Ich habe entdeckt, da&szlig; einige LCD Displays
einen h&ouml;heren kapazitiven Innenwiderstand haben als andere. Das ist vermutlich so, weil
sie einen besseren ESD Schutz haben. Diese h&ouml;here Last kann Bit-Errors beim
Programmieren des Microcontrollers verursachen, wenn das Display an die SCK und MOSI
Leitungen des Microcontrollers angschlossen ist.
<br><br>
Als erste L&ouml;sung f&uuml;r dieses Problem habe ich einfach ein paar Widerst&auml;nde
in die Leitungen zum Display eingel&ouml;tet. Das funktionierte problemlos bei mir,
aber einige Leser, speziell Leute mit Laptops hatten immer noch Probleme.
<br><br>
Um das Problem vollst&auml;ndig zu vermeiden habe ich dann das Schaltungsdiagramm
ge&auml;ndert und die D7 und RS Pins des Display an PD7 und PD6 angeschlossen.
Es ist kein Problem das auf der Platine zu &auml;ndern. Dazu ist lediglich ein
kurzes St&uuml;ck Draht unter der Platine n&ouml;tig und die Verbindung zu PB3 mu&szlig; mit einem Messer
unterbrochen werden.
<br clear="all">
<br>
<center>
<a
href="../../common/images2/article369/i2ctemp_newlcdconection.gif"><img src="../../common/images2/article369/i2ctemp_newlcdconection_th.gif" alt="Circuit diagram"  width="590" height="432"></a>
</center>
<br>
    <A NAME="369lfindex2">&nbsp;</A>
<H2>Ein einfaches GUI</H2>

    F&uuml;r die Leser, die gerne ein GUI auf Ihrem Desktop haben, habe ich ein
    wirklich einfaches GUI entwickelt. Es besteht aus 2 Textzeilen die die Ausgabe
    es Befehls i2ctemp_linux wiedergeben (das GUI ruft einfach den Befehl i2ctemp_linux
    auf und dieser liest die Temperatur via I2C).
<br>
<center>
<img src="../../common/images2/article369/guiscreenshot.gif" alt="GUI" width="83" height="80">
</center>
<br>
Jetzt haben wir ein richtig cooles Thermomether:
<ul>
<li>Man kann die Temperatur lokal am Display ablesen.
<li>Man kann ein kleines GUI auf seinem Desktop haben.
<li>Man kann die Temperaturwerte &uuml;ber einen cron-job in eine Datei schreiben
und damit Statistiken &uuml;ber l&auml;ngere Zeit haben.
</ul>
Den Rest des Artikels werde ich jetzt damit verwenden die Interna der Software
zu erkl&auml;ren.
<A NAME="369lfindex3">&nbsp;</A>
<H2>Wie es funktioniert: Analogdigitalwandler</H2>

Der Atmega8 hat zwei Modi. Einen in dem er permanent analog zu digital
wandelt und immer einen Interrupt ausl&ouml;st, wenn ein Konvertierung fertig
ist. Die Applikation kann dann dem Interrupt benutzen um schnell des Ergebnis
aus den Registern in Variablen zu kopieren.
<br>
<br>
In dem anderen Modus, der sich "single shot mode" nennt wird nur ein Konvertierung
durchgef&uuml;hrt. Dieser Mode ist immer noch recht schnell. Mit der Zeit, die man
braucht um alle Voreinstellungen richtig zu setzen kann man immer noch 100 Konvertierungen pro Sekunde erreichen. Das ist mehr als schnell genug f&uuml;r unsere Zwecke.
Wir nehmen deshalb diesen Modus.
<br>
<br>
Als Eing&auml;nge kann der Atmega8 die Pins ADC0 bis ADC3 benutzen. Daneben gibt es
noch die Pins AGND
(analog ground, Verbunden mit der normalen Masse),
AREF (reference voltage) und AVCC (verbunden mit +5V).
<br>
<br>
W&auml;hrend der AD-Wandlung wird das analoge Signal mit AREF verglichen. Ein analoges
Signal das gleich mit AREF ist, entspricht einem digitalen Wert von 1023. AREF kann
eine externe Referenz zwischen 0 und 5V sein. Ohne externe Referenz kann man immer
noch exakte Messungen machen, indem man entweder die interne Referenzspannung (2.56V), oder AVCC benutzt. Welche dieser Optionen benutzt werden soll, l&auml;&szlig;t sich &uuml;ber die
REFS0 und REFS1 Bits im ADMUX Register einstellen.
<br>
<br>
Der Analogdigitalwandler kann zu einem Zeitpunkt nur einen der Eing&auml;nge ADC0-ADC3
konvertieren. Bevor die Konvertierung beginnt mu&szlig; man festlegen, welcher Eingang
benutzt werden soll und das geht auch &uuml;ber Bits im ADMUX Register.
<br>
<br>
Eine einfache AD-Wandlung w&uuml;rde dann so aussehen:
<pre class="code">
volatile static int analog_result;
volatile static unsigned char analog_busy;

analog_busy=1; // busy mark the ADC function
channel=0; // measure ADC0
// use internal 2.56V ref
outp((1&lt;&lt;REFS1)|(1&lt;&lt;REFS0)|(channel &amp; 0x07),ADMUX);
outp((1&lt;&lt;ADEN)|(1&lt;&lt;ADIE)|(1&lt;&lt;ADIF)|(1&lt;&lt;ADPS2),ADCSR);
sbi(ADCSR,ADSC); // start conversion
</pre>
Jetzt wird der Microcontroller die AD-Wandlung durchf&uuml;hren und dann die
Funktion SIGNAL(SIG_ADC) aufrufen sobald die AD-Wandlung fertig ist.
Als Programmierer mu&szlig; man darauf achten, da&szlig; man die unteren 8 Bits der Ergebisregister
immer zuerst lesen mu&szlig;.
<pre class="code">
SIGNAL(SIG_ADC) {
        unsigned char adlow,adhigh;
        adlow=inp(ADCL); /* read low first, two lines. Do not combine
                          the two lines into one C statement */
        adhigh=inp(ADCH);
        analog_result=(adhigh&lt;&lt;8)|(adlow &amp; 0xFF);
        analog_busy=0;
}
</pre>
Jetzt haben wir das Ergebnis in der Variablen analog_result. Dieser Wert kann
nun anderswo im Programm benutzt werden. Ganz einfach.
<br>
<br>
Wie bei allen Interrupts mu&szlig; man einmal global sei(); aufrufen um Interrupts einzuschalten. Das wird im Haupprogramm gemacht und ist deshalb hier nicht aufgef&uuml;hrt.
<br>
<br>
Es gibt eine Menge Bits und Flags, die ich kurz erkl&auml;ren werde:
<ul>
<li>ADEN: Analog Digital Converter Enable, mu&szlig; vor ADSC gesetzt werden<br><br>
<li>ADIE: Enable ADC Interrupt (=schaltet Interrupts ein, daruch wird der Aufruf von SIGNAL(SIG_ADC) m&ouml;glich)<br><br>
<li>ADIF: ADC Interrupt Flag (mu&szlig; auf 1 vor der Konvertierung gesetzt werden)<br><br>
<li>ADPS: ADC clock pre-scaler bits:
Mu&szlig; so eingestellt werden, das die Taktfrequenz geteilt durch den
pre-scale Faktor einen Wert zwischen 50 und 200 kHz ergibt.
Der pre-scale Faktor ist  2^ADPS (zwei hoch ADPS Bits Wert).
Die oben benutzte Einstellung (ADPS2=1, ADPS1=0, ADPS0=0 = dezimal 4 -&gt; 2^4 = 16 -&gt; Teilerfaktor = 16) ist gut f&uuml;r eine Taktfrequenz von
1MHz.<br><br>
</UL>

Der Atmega8 hat verschiedene M&ouml;glichkeiten was die Referenzspannung betrifft:
<table width="400" border=2>
<tr>
<td>REFS0=0, REFS1=0</td><td>benutze eine externe AREF Spannung, die interne  Vref ist aus </td>
</tr><tr>
<td>REFS0=0, REFS1=1</td><td>AVCC mit optionalen Kondensator an dem AREF Pin</td>
</tr><tr>
<td>REFS0=1, REFS1=1</td><td>interne 2.56V Referenz with (optionalem)
externem Kondensator an dem AREF Pin</td>
</tr></table>
Der optionale externe Kondensator am AREF Pin kann rauschen unterdr&uuml;chen und
die AREF Spannung stabilisieren.
<br>
<br>
<A NAME="369lfindex4">&nbsp;</A>
<H2>Wie es funktioniert: I2C Kommunikation, Atmega8 Teil</H2>

Im Teil I
<a
href="../February2005/article365.shtml">(Februar 2005 Artikel365)</a>
habe ich schon erkl&auml;rt wie das I2C Protokoll funktioniert. Jetzt wollen wir
uns die Software etwas n&auml;her ansehen. Der Atmega8 hat Hardwareunterst&uuml;tzung f&uuml;r
I2C Kommunikation. Man mu&szlig; deshalb das I2C Protokoll garnicht implementieren.
Stattdessen schreibt man eine Zustandsmaschine, die dem Atmega8 sagt was
als n&auml;chstes getan werden soll. Hier ein Beispiel:
<br><br>
Ein I2C Paket mit unser eigenen Slave-Adresse ist angekommen.
Der Atmega8 wird nun die Funktion
 SIGNAL(SIG_2WIRE_SERIAL) mit dem
Statuscode 0x60 (f&uuml;r andere Ereignisse gibt es andere Codes) aufrufen.<br>
<br>
--&gt; Jetzt m&uuml;ssen wir einige Register setzen, um dem Atmega8 zu sagen, was
als n&auml;chstes zutun ist. In diesem Fall sagen wir ihm: Empfange den Datenteil und
best&auml;tige mit einem ack-Bit.
<br><br>
Wenn die eigentlichen Daten empfangen wurden, werden wir mit dem
Statuscode 0x80 aufgerufen.
<br>
<br>
--&gt; Nun lesen wir das Datenbyte und sagen dem Atmega8, da&szlig; er auch das n&auml;chste
empfangen und best&auml;tigen soll.
<br>
<br>
Wenn die Kommunikation zuende ist, erhalten wir den Statuscode 0xA0 (stop condition)
und wir k&ouml;nnen unser Applikation sagen, da&szlig; eine vollst&auml;ndige Nachricht empfangen
wurde.
<br>
<br>
Die gesamte Zustandsmaschine f&uuml;r den I2C Slave und alle m&ouml;glichen Statuscodes
sind im Datenblatt Seite 183 erkl&auml;rt (siehe Link unter Referenzen am Ende des
Artikels).
<br>
<br>
Das Senden von Daten funktioniert ganz &auml;nlich. Schau einfach mal in den Code
rein!

<A NAME="369lfindex5">&nbsp;</A>
<H2>Wie es funktioniert: I2C Kommunikation, Linux Seite</H2>

<img src="../../common/images2/article369/input.gif" alt="i2c input stage" align="right" width="256" height="117">
Zun&auml;chst einige Worte zur Hardware. Obwohl I2C ein Bus ist, benutzen wir
nur Punkt zu Punkt Kommunikation zwischen einem Slave und dem Linux PC als
Master. Wir k&ouml;nnen uns deshalb die "pullup" Widerst&auml;nde sparen, solange
der Slave die Leitung gegen Masse ziehen kann, ohne eine Kurzschlu&szlig; zu verursachen.
Wir setzen deshalb die 4.7K Widerst&auml;nde in serie in die Leitung.
<br>
<br>
Die Spannungspegle m&uuml;ssen angepasst werden. Das machen wir mit Z-Dioden, die
negative Spannungen auf -0.7V und positive auf max. +5.1V begrenzen.
<br>
<br>
Nachdem ich inzwischen mehr &uuml;ber die Internas des Atmeag8 gelesen habe, denke
ich da&szlig; man sich eigentlich die Z-Dioden sparen k&ouml;nnte, da der Strom &uuml;ber die
4.7K klein genug ist, damit auch die internen Schutzvorrichtungen des Atmeag8
gegen &Uuml;berspannung ausreichen m&uuml;&szlig;ten. Die Z-Dioden schaden aber
auch nicht. In der n&auml;chsten Schaltung nehme ich sie vielleicht raus.
<br>
<br>
Die Linux I2C Software implementiert einen kompletten I2C Stack. Dadurch
ist die Linux-Seite unabh&auml;ngig von irgenwelchen Kernelmodulen und Bibliotheken.
Es ist einfach ein kleines Programm das unabh&auml;ngig und problemlos funktioniert.
<br>
<br>
Wenn man sich die Datei i2c_m.c ansiehst (siehe Download) dann stellt man fest, da&szlig;
wirklich jede I2C Nachricht Bit f&uuml;r Bit zusammengebaut wird.
<br>
<br>
Um die "Bits" zu erzeugen m&uuml;ssen wir die physikalischen Leitungen der
RC232 Schnittstelle setzen. Das geht &uuml;ber ioctl Aufrufe:
<pre class="code">
        // set RTS pin:
        int arg=TIOCM_RTS;
        ioctl(fd, TIOCMBIS, &amp;arg);
</pre>
... oder um eine "Null" zu erzeugen:
<pre class="code">
        // clear RTS pin:
        int arg=TIOCM_RTS;
        ioctl(fd, TIOCMBIC, &amp;arg);
</pre>
Falls man diesen Code auf ein anderes Betriebsystem portieren m&ouml;chte, braucht
man lediglich diese Zeilen zu &auml;ndern. Der Rest ist ganz normaler ANSI C-Code.

<A NAME="369lfindex6">&nbsp;</A>
<H2>USB zu RS232</H2>

Bei Laptops, die m&ouml;glicherwiese heute keine RS232 Schnittstelle mehr haben, kann
man einfach einen USB zu RS232 Adapter nehmen. Ich benutze, z.B eine No-name Adapter
der einen Prolific 2303 Chip enth&auml;lt. In
 /proc/bus/usb/devices sieht das bei mir so aus:
Vendor=067b ProdID=2303 Rev= 2.02. N&auml;heres zu solchen Adaptern findet sich auch in <a
href="../../English/November2001/article223.shtml">"Einen ATEN
UC-232A USB Adapter unter Linux nutzen (Linuxfocus, November 2001, Artikel 223)"</a>.


<A NAME="369lfindex7">&nbsp;</A>
<H2>Zusammenfassung</H2>

<img src="../../common/images2/article369/mountoutdoorsensor.jpg" alt="mount the sensor" align="right" width="300" height="176">
Ich benutze das Thermometer nun seit 2 Monaten und es gef&auml;llt mir wirklich gut.
Ich kann die Temperatur direkt ablesen und die Daten &uuml;ber den PC auswerten.

 <br>
<br>
Der Au&szlig;ensensor mu&szlig; gut gegen Regen und Sonne gesch&uuml;tzt sein. Man kann versuchen
ihn in irgendwelches Plastik einzuwickeln, aber ich empfehle das nicht. Egal wie
dicht man es verpackt, eines Tages kommt etwas Wasser hinein und kann dann nicht
mehr raus. Der NTC ist recht robust und es macht ihm eigentlich nichts aus, wenn
er mal f&uuml;r kurze Zeit feucht wird, solange er dann auch wieder trocknen kann.
Eine umgedrehte Tablettendose eigent sich ganz gut. Ich habe sie unten offen gelassen
und so kann das Wasser auch wieder raus.

<br clear="all">
<br>

<br>
<center>
<img src="../../common/images2/article369/lcd_i2c_linux_temp.jpg" alt="the thermometer" width="450" height="338">
</center>
<br>
<br>Auch f&uuml;r diesen Artikel bekommt man wieder alle Teile (LCD Display, Platine, Microcontroller, ...) &uuml;ber den
tuxgraphics Online-shop: <a
href="http://shop.tuxgraphics.org">shop.tuxgraphics.org</a>. <br>
Viel Spa&szlig;!

    <A NAME="369lfindex8">&nbsp;</A>
<H2>Referenzen</H2>


    <ul>
      <li><b>Download</b> Seite f&uuml;r diesen Artikel: <a href="../../common/src2/article369/index.html">die linuxI2Ctemp_lcd Software,
      Schaltbilder, Softwareupdates</a></li>

      <li>Wie man den Atmeag8 mit gcc programmiert: <a href=
      "../November2004/article352.shtml">November2004 Artikel
      352</a></li>

      <li>Datenblatt f&uuml;r den Atmega8: Gehe zu http://www.atmel.com/
      und selektiere  products-&gt;Microcontrollers -&gt;AVR-8 bit
      RISC-&gt;Documentation-&gt;datasheets <br><a href=
      "../../common/src2/article365/atmega8.pdf">(lokale Kopie, pdf,
      2479982 Bytes)</a></li>

    </ul>
    <!-- vim: set sw=2 ts=2 et tw=80: -->
  



<!-- BODY_OF_THE_ARTICLE_STOP -->
<!-- 2pdaIgnoreStart -->
<A NAME="talkback">&nbsp;</a>
<h2>Talkback f&uuml;r diesen Artikel</h2>
Jeder Artikel hat seine eigene Seite f&uuml;r Kommentare und R&uuml;ckmeldungen. Auf dieser Seite kann jeder eigene Kommentare abgeben und die Kommentare anderer Leser sehen:
<center>
    <table width="250" border=0><tr><td>
    <div class="tbbutton"><A class="nodec" href="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=369">&nbsp;Talkback Seite&nbsp;</a></div>
    </td></tr></table>
</center>

<br clear="all">
<HR size="2" noshade>
<table width="250" border=0><tr><td>
<div class="bbutton"><a class="nodec" href="../../index.shtml">&lt;--, LF Home</a></div>
</td><td>
<div class="bbutton"><a class="nodec" href="index.shtml">Zum index dieser Ausgabe</a></div>
</td></tr></table>
<br clear="all">
<HR size="2" noshade>
<!-- ARTICLE FOOT -->
<CENTER><TABLE WIDTH="98%" summary="footer">
<TR><TD ALIGN=CENTER BGCOLOR="#bdc6d5" WIDTH="50%">
<A HREF="../../common/lfteam.html">Der LinuxFocus Redaktion schreiben</A>
<BR><FONT COLOR="#1111aa"><a href="../../common/copy.html">&copy; Guido     Socher</a><br>&quot;some rights reserved&quot; see <a href="../../license/index.shtml">linuxfocus.org/license/</a><br><a href="http://www.linuxfocus.org">http://www.LinuxFocus.org</a></FONT>
</TD>
<TD BGCOLOR="#bdc6d5">
<!-- TRANSLATION INFO -->
<font size=2>Autoren und &Uuml;bersetzer:</font>
<TABLE summary="translators">
  <tr><td><font size="2">en --&gt; -- : Guido Socher (<a href="http://linuxfocus.org/~guido/"><font size="1">homepage</font></a>)</font></td></tr>
  <tr><td><font size="2">en --&gt; de: Guido Socher (<a href="http://linuxfocus.org/~guido/"><font size="1">homepage</font></a>)</font></td></tr>
</TABLE>
</TD>
</TR></TABLE></CENTER>
<p><font size=1>2005-03-25, generated by lfparser version 2.52</font></p>
<!-- 2pdaIgnoreStop -->
</BODY>
</HTML>
