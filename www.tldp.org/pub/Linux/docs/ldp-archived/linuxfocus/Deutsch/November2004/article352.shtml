<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
 <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <META NAME="GENERATOR" CONTENT="lfparser_2.52">
 <META NAME="LFCATEGORY" CONTENT="Hardware">
 <link rel="icon" href="../../common/images/lf-16.png" type="image/png">
 <TITLE>lf352, Hardware: Programmieren des AVR Microcontrollers mit GCC, libc 1.0.4</TITLE>
<style type="text/css">
<!--
 td.top {font-family: Arial,Geneva,Verdana,Helvetica,sans-serif; font-size:12 }
 pre { font-family:monospace,Courier }
 pre.code { font-family:monospace,Courier;background-color:#aedbe8; }
 p.cl { color:#EE9500 }
 table.left { margin-right:0.3cm }
 a.nodec { text-decoration:none }
 p.trans { font-size:8pt; text-align:right }
 p.clbox { width:50%; alignment:center; background-color:#FFD700; 
           border-style:none; border-width:medium; border-color:#FFD700; 
           padding:0.5cm;  text-align:center }
 p.code { width:80%; alignment:center; background-color:#aedbe8; 
          border-style:none; border-width:medium; border-color:#aedbe8; 
          padding:0.1cm;  text-align:left }
 p.foot { background-color:#AAAAAA; color:#FFFFFF; border-style:none; 
          border-width:medium; border-color:#AAAAAA; padding:0.5cm ; 
          margin-top:0.1cm; margin-right:1cm; margin-left:1cm; 
          text-align:center }
 div.tbbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   margin: 2px 5px 2px 5px;
   text-align: center;
   width: 20em;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
 div.bbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   float: left;
   margin: 2px 5px 2px 5px;
   text-align: center;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
-->
</style>
 
</HEAD>
<BODY bgcolor="#ffffff" text="#000000">
 <!-- this is generated html code. NEVER use this file for your
 translation work. Instead get the file with the same article number
 and .meta.shtml in its name. Translate this meta file and then
 use lfparser program to generate the final article -->
 <!-- lfparser can be obtained from http://main.linuxfocus.org/~guido/dev/lfparser.html -->

<!-- this is used by a number of tools:
 =LF=AUTHOR: Guido     Socher
 =LF=CAT___: Hardware
 =LF=TITLE_: Programmieren des AVR Microcontrollers mit GCC, libc 1.0.4
 =LF=NUMBER: 352
 =LF=ANAME_: article352.shtml
 =LF=PARSER: 2.52
 -->

<!-- 2pdaIgnoreStart -->

<!-- start navegation bar, current, style=2 -->
 <!-- top navegation bar -->
 <TABLE summary="topbar_1" cellspacing="0" cellpadding="0" border="0" align="center" width="90%">
   <TR bgcolor="#2e2292">
     <TD class="top"><TABLE summary="topbar_1_logo" cellspacing="0" cellpadding="0" border="0" width=
       "100%">
         <TR><TD width="319"><a href="../../index.shtml"><IMG src="../../common/images/logolftop_319x45.gif"
           alt="[LinuxFocus-icon]" width="319" height="45" align="left" 
           border="0"></a></TD>

           <TD class="top">
             <TABLE summary="topbar_1_links" width="100%">
               <TR align="right">
                 <TD class="top">
                 
                 <A class="nodec" href="../../index.shtml"><FONT color=
                 "#DDDDDD" size="2">&lt;--</FONT></A> &nbsp;| 
                 <A class="nodec" href="../map.html"><FONT color=
                 "#DDDDDD" size="2">Plan</FONT></A> &nbsp;| 
                 <A class="nodec" href="../indice.html"><FONT color=
                 "#DDDDDD" size="2">Index</FONT></A> &nbsp;| 
                 <A class="nodec" href="../Search/index.html"><FONT color=
                 "#DDDDDD" size="2">Suchen</FONT></A> </TD>
                 
               </TR>

               <TR align="right">
                 <TD class="top">
                   <HR width="100%" noshade size="1">
                 </TD>
               </TR>
             </TABLE>
           </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end top navegation bar -->
 <!-- blue bar -->
 <TABLE summary="topbar_2" cellspacing="0" cellpadding="0" border="0" align="center"
 width="90%">
   <TR bgcolor="#00ffff">
     <TD><IMG src="../../common/images/transpix.gif" width="1" height=
     "2" alt=""></TD>
   </TR>
 </TABLE>
 <!-- end blue bar -->
 <!-- bottom navegation bar -->
 <TABLE summary="topbar_3" cellspacing="0" cellpadding="0" border="0" align="center"
 width="94%">
   <TR bgcolor="#000000">
     <TD>
       <TABLE summary="topbar_3_links" cellspacing="0" cellpadding="1" border="0" width=
       "100%">
         <TR align="center">
           <TD WIDTH="20%"><A class="nodec" href="../News/index.shtml"><FONT color=
           "#FFFFFF">Nachrichten</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Archives/index.html"><FONT color=
           "#FFFFFF">Archiv</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Links/index.shtml"><FONT color=
           "#FFFFFF">Links</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../aboutus.html"><FONT color=
           "#FFFFFF">&Uuml;ber uns</FONT></A> </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end bottom navegation bar -->
<!-- stop navegation bar -->

<!-- SSI_INFO -->

<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfdynahead ver 1.5 --><TABLE ALIGN="right" border=0><TR><TD ALIGN="right"><FONT SIZE="-1" FACE="Arial,Helvetica">Dieses Dokument ist verf&uuml;bar auf: <A href="../../English/November2004/article352.shtml">English</a> &nbsp;<A href="../../Castellano/November2004/article352.shtml">Castellano</a> &nbsp;<A href="../../Deutsch/November2004/article352.shtml">Deutsch</a> &nbsp;<A href="../../Francais/November2004/article352.shtml">Francais</a> &nbsp;<A href="../../Italiano/November2004/article352.shtml">Italiano</a> &nbsp;<A href="../../Turkce/November2004/article352.shtml">Turkce</a> &nbsp;</FONT></TD></TR></TABLE><br>
 


<!-- SSI_INFO STOP -->
<!-- 2pdaIgnoreStop -->

<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_START -->
<TABLE ALIGN="LEFT" BORDER="0" WIDTH="195" summary="about the author" class="left">
<TR>
<TD>

<img src="../../common/images/Guido-S.gif" alt="
    [Photo of the Author]" height="164" width="173">
<BR>von  Guido Socher <a href="http://linuxfocus.org/~guido/"><font size="1">(homepage)</font></a>
<BR><BR>
<I>&Uuml;ber den Autor:</I><BR>
<!-- aboutauthor_start -->
<p>Guido mag Linux, weil es ein wirklich gutes System ist, um seine eigene Hardware zu entwickeln.</p>
<!-- aboutauthor_stop -->
<!-- TRANSLATED_TO de -->
<!-- TRANSLATED_TO_STOP -->
<!-- INDEX_START -->
<BR><i>Inhalt</i>:
<UL>
  <LI><A HREF="#352lfindex0">Einleitung</A></LI>
  <LI><A HREF="#352lfindex1">Softwareinstallation: Was man dazu braucht</A></LI>
  <LI><A HREF="#352lfindex2">Softwareinstallation: GNU binutils</A></LI>
  <LI><A HREF="#352lfindex3">Softwareinstallation: AVR gcc</A></LI>
  <LI><A HREF="#352lfindex4">Softwareinstallation: Die AVR C-library</A></LI>
  <LI><A HREF="#352lfindex5">Softwareinstallation: Der Programmierer</A></LI>
  <LI><A HREF="#352lfindex6">Ein kleines Testprojekt</A></LI>
  <LI><A HREF="#352lfindex7">Ben&ouml;tigte Hardware</A></LI>
  <LI><A HREF="#352lfindex8">Bauen der Programmiererhardware</A></LI>
  <LI><A HREF="#352lfindex9">Software schreiben</A></LI>
  <LI><A HREF="#352lfindex10">Kompilieren und Laden</A></LI>
  <LI><A HREF="#352lfindex11">Einige interessante binutils</A></LI>
  <LI><A HREF="#352lfindex12">Ideen und Anregungen</A></LI>
  <LI><A HREF="#352lfindex13">Referenzen</A></LI>
  <LI><A HREF="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=352">Talkback f&uuml;r diesen Artikel</A></LI>
</UL>

</TD></TR></TABLE>
<!-- INDEX_STOP -->
<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_STOP -->
<!-- HEAD_OF_THE_ARTICLE_START -->
<br>&nbsp;
<table border="0"><tr><td>
<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfPdf ver 0.1 -->
<TABLE style="border-style:outset; border-width:1px" align="right" bgcolor="#ff9616" cellspacing="1"><TR><TD bgcolor="#ff9616">
        <a href="../Archives/lf-2004_11-0352.pdf"><small>PDF</small></a>
        </TD></TR></TABLE>
         

<H2>Programmieren des AVR Microcontrollers mit GCC, libc 1.0.4</H2>
 <img src="../../common/images2/article352/illustration.gif"
    alt="[Illustration]" hspace="10" width="208" height="148">
<!-- ABSTRACT OF THE ARTICLE -->
<P><i>Zusammenfassung</i>:
<P>
<!-- articleabstract_start -->


    Der AVR 8-Bit RISC Microcontroller von Atmel ist ein sehr verbreiteter Microcontroller. Es ist nur ein Chip mit EEPROM,
    Ram, Analog zu Digital Umwandler, einer Menge digitaler Ein- und Ausgabezeilen, Timern, UART f&uuml;r RS 232 communication und vielen anderen Dingen. <br><br>
     Das beste ist jedoch, dass es daf&uuml;r unter Linux eine vollst&auml;ndige Programmierumgebung daf&uuml;r gibt: Man kann diesen Microcontroller in
    C programmieren, mit dem GCC Compiler. <br><br>
    Ich habe schon im <a href="../March2002/article231.shtml">M&auml;rz 2002 einen Artikel</a> &uuml;ber dasselbe Thema geschrieben. Eine Menge Dinge haben sich seitdem in der avr-libc Entwicklung ge&auml;ndert und der AT90S4433 Microcontroller, den ich
    2002 benutzt habe, wird nicht l&auml;nger von Atmel hergestellt. Dies ist deshalb ein Update des M&auml;rz 2002 Artikels. Ich benutze libc-1.0.4 und den
    ATmega8 Microcontroller. <br><br>

     Dieser Artikel soll nur eine Einf&uuml;hrung sein und in sp&auml;teren Artikel werden wir wieder interessante Hardware bauen, die aber dies Mal auf dem ATmega8 basierend.

    
<!-- articleabstract_stop -->

<br><!-- HR divider --><center><font color="#8282e0"><b>_________________ _________________ _________________</b></font></center><br>
</td></tr></table>
<!-- HEAD_OF_THE_ARTICLE_STOP -->
<!-- BODY_OF_THE_ARTICLE_START -->


    <A NAME="352lfindex0">&nbsp;</A>
<H2>Einleitung</H2>

    Viele Leute waren am Programmieren des Atmel Microcontrollers interessiert, als ich 2002 den Artikel schrieb. Der erste Schritt, die Entwicklungsumgebung zum Laufen zu kriegen, ist jedoch der schwerste. Wenn etwas nicht funktioniert, hat man absolut keinen Hinweis, wo der Fehler liegen k&ouml;nnte. Liegt es am Programmierkabel?? Ein Fehler in der Schaltung? Fehlerhafte Installation? Ist der Parallelport im Bios abgeschaltet? Sind die Kernelmodule f&uuml;r ppdev falsch kompiliert? Es gibt eine Menge Gr&uuml;nde, warum es nicht funktioniert. <a href="http://shop.tuxgraphics.org/electronic/microcontroller.html"><img
     src="../../common/images2/article352/linuxavrcd_th.jpg" align="right"
     width="150" height="213"></a> <br>
     <br>

    Um den Einstieg in die aufregende Welt der Microcontroller einfacher zu machen, gibt es bei
     <a href="http://shop.tuxgraphics.org/electronic/microcontroller.html">shop.tuxgraphics.org</a> jetzt eine bootbare CD mit einem kleinen Handbuch und der Programmierhardware. Alles, was du dann machen mu&szlig;t, ist, von der CD zu booten und alles l&auml;uft. Es ist keine Softwareinstallation erforderlich und auf deinem Computer wird nichts ge&auml;ndert. <br>
     <br>
    Selbst ich benutze seit einer Weile so eine CD, da die Hardware, die ich baue, oft einige Generationen von Kerneln und Softwareinstallationenen auf meinem PC &uuml;berlebt. Wenn ich dann sp&auml;ter die Microcontrollersoftware updaten will, brauche ich mir keine Gedanken dar&uuml;ber zu machen, ob meine Entwicklungsumgebung auf meinem Linux-PC noch l&auml;uft. Ich boote einfach von der CD und alles l&auml;uft. <br>
     <br>
    Unabh&auml;ngig von der CD erkl&auml;re ich in den n&auml;chsten Abschnitten die Installation der GCC avr Entwicklungsumgebung. Wenn du die CD von tuxgraphics hast, dann lies ab "Ein kleines Testprojekt" weiter.

    <A NAME="352lfindex1">&nbsp;</A>
<H2>Softwareinstallation: Was man dazu braucht</H2>


    <p>Um die GNU C Entwicklungsumgebung benutzen zu k&ouml;nnen, braucht man die folgende Software:</p>

    <table border="1">
      <tr>
        <td>binutils-2.15.tar.bz2</td>

        <td>Verf&uuml;gbar unter:<br>
         ftp://ftp.gnu.org/gnu/binutils/<br>

         oder einem der Mirrors. Z.B.<br>
         ftp://gatekeeper.dec.com/pub/GNU/binutils/</td>
      </tr>

      <tr>
        <td>gcc-core-3.4.2.tar.bz2</td>

        <td>Verf&uuml;gbar unter: ftp://ftp.gnu.org/gnu/gcc/<br>

         oder einem der Mirrors. Z.B.<br>
         ftp://gatekeeper.dec.com/pub/GNU/gcc/</td>
      </tr>

      <tr>
        <td>avr-libc-1.0.4.tar.bz2.tar</td>

        <td>Die AVR C-library ist verf&uuml;gbar unter:
        http://savannah.nongnu.org/projects/avr-libc/</td>

      </tr>

      <tr>
        <td>uisp-20040311.tar.bz2</td>

        <td>Die AVR Programmiersoftware gibt es auf:
        http://savannah.nongnu.org/projects/uisp</td>
      </tr>
    </table>
    <br>

    <br>
     Wir installieren alle Programme nach /usr/local/avr. Dadurch halten wir das Programm vom normalem Linux C Compiler getrennt. Erzeuge dieses Verzeichnis mit dem Befehl:
<pre class="code">
    mkdir /usr/local/avr

Du kannst es jetzt schon zu deinem PATH hinzuf&uuml;gen:
    mkdir /usr/local/avr/bin
    export PATH=/usr/local/avr/bin:${PATH}
</pre>

    <A NAME="352lfindex2">&nbsp;</A>
<H2>Softwareinstallation: GNU binutils</H2>

    Das binutils Paket enth&auml;lt alle n&ouml;tigen low-level Utilities, um Objektdateien zu bauen. Es beinhaltet einen AVR assembler
    (avr-as), Linker (avr-ld), library handling tools (avr-ranlib,
    avr-ar), Programme, zum Erzeugen von Objektdateien, die auf das EEPROM des Microcontrollers (avr-objcopy) geladen werden k&ouml;nnen, disassembler
    (avr-objdump) und utilities wie avr-strip und avr-size.
    <br>
     <br>

     La&szlig; die folgenden Befehle laufen, um die binutils zu bilden und zu installieren:

<pre class="code">
tar jxvf binutils-2.15.tar.bz2
cd binutils-2.15/
mkdir obj-avr
cd obj-avr
../configure --target=avr --prefix=/usr/local/avr --disable-nls
make

# as root:
make install
</pre>
    <br>
    <br>
     F&uuml;ge die Zeile /usr/local/avr/lib zu der Datei /etc/ld.so.conf
    hinzu und la&szlig; den Befehl /sbin/ldconfig laufen, um den Linker-cache erneut zu bilden.


    <A NAME="352lfindex3">&nbsp;</A>
<H2>Softwareinstallation: AVR gcc</H2>

    avr-gcc ist unser C Compiler. <br>
     <br>

     La&szlig; den folgenden Befehl zum Bilden und Installieren laufen:
<pre class="code">
tar jxvf gcc-core-3.4.2.tar.bz2
cd gcc-3.4.2

mkdir obj-avr
cd obj-avr
../configure --target=avr --prefix=/usr/local/avr --disable-nls --enable-language=c

make

# as root:
make install

</pre>

    <A NAME="352lfindex4">&nbsp;</A>
<H2>Softwareinstallation: Die AVR C-library</H2>

    Die C-library ist inzwischen ganz stabil, verglichen mit der, die ich im M&auml;rz 2002 vorgestellt habe. La&szlig; den folgenden Befehl zum Bilden und Installieren laufen:
<pre class="code">
tar jxvf avr-libc-1.0.4.tar.bz2.tar
cd avr-libc-1.0.4
PREFIX=/usr/local/avr
export PREFIX
sh -x ./doconf
./domake

cd build
#as root:
make install

</pre>

    <A NAME="352lfindex5">&nbsp;</A>
<H2>Softwareinstallation: Der Programmierer</H2>

    Die Programmiersoftware l&auml;dt den speziell preparierten Objektcode in das  EEPROM unseres Microcontrollers. <br>
     <br>
     Der uisp Programmierer f&uuml;r Linux ist ein sehr guter Programmierer. Er kann direkt von einem Makefile aus benutzt werden. Man f&uuml;gt einfach eine
    "make load" Regel hinzu und schon kann man die Software in einem kompilieren und laden. <br>
     <br>
     uisp wird wie folgt installiert:
<pre class="code">

tar jxvf uisp-20040311.tar.bz2.tar
cd uisp-20040311
./configure --prefix=/usr/local/avr
make

# as root:
make install

</pre>

    <A NAME="352lfindex6">&nbsp;</A>
<H2>Ein kleines Testprojekt</H2>

    Wir beginnen mit einer kleinen Testschaltung, die du dann sp&auml;ter erweitern kannst. <br>
    <br>
    Dieses Schaltung kann auch als einfache Testumgebung f&uuml;r komplexere Hardware benutzt werden. Man kann einfach Software zum Testen laden und dann Sensoren oder Me&szlig;instrumente anschlie&szlig;en. <br>
    <br>
    Unser Testprogramm, so wie es hier dargestellt ist, bringt einfach eine LED zum Blinken. <br>


     <img src="../../common/images2/article352/circuit.gif" width="
    600" height="400"> <br>


    <A NAME="352lfindex7">&nbsp;</A>
<H2>Ben&ouml;tigte Hardware</H2>

    <img src="../../common/images2/article352/avrm8ledtest_circuit.jpg" alt="
    [test circuit]" align="right" width="300" height="286"><br>
     Du brauchst die unten aufgef&uuml;hrten Teile. Obwohl es ein ganz gew&ouml;hnlicher Microcontroller ist, ist er eventuell nicht in jedem  Elektroladen vor Ort zu haben, aber gr&ouml;&szlig;ere Distributoren f&uuml;r elektronische Komponenten wie ( www.conrad.de (Deutschland), www.selectronic.fr
    (Frankreich), digikey.com (US, Canada), etc... haben sie vorr&auml;tig. <br>
    Du kannst sowohl den gesamten Bausatz als auch nur den Microcontroller bei
    <a href="http://shop.tuxgraphics.org/">shop.tuxgraphics.org</a> bestellen.

    <br clear="all">


    <table border="1" width="70%">
      <tr>
        <td>1 x ATmega8 DIP version, Atmel 8 bit Avr risc
        processor.</td>
      </tr>

      <tr>
        <td>1 x 28 pin 7.5mm IC Sockel<br>

         Der 28 pin Sockel ist ein bi&szlig;chen schwieriger zu bekommen. Normalerweise sind die 28 Sockel 14mm breit, aber wir brauchen einen 7.5mm
        Sockel.</td>
      </tr>

      <tr>
        <td>1 x 10K Widerstand (Farbcode: braun, schwarz, orange)<br>
         1 x 1K Widerstand (Farbcode: braun, schwarz, rot)<br>
         1 x 10uF Elektrolytkondensator<br>

         einigen Draht<br>
         1 x LED<br>
         matrix board<br>
        </td>
      </tr>

      <tr>
        <td>Das folgende wird f&uuml;r den Programmierer ben&ouml;tigt <small>(es wird nicht gebraucht, wenn du dir das "Linux AVR programming kit" von
        tuxgraphics besorgst)</small>:<br>

        1 x DB25 Stecker, der in den Parallelport pa&szlig;t.<br>
         Irgendeinen 5 pin Stecker/Sockel f&uuml;r den Programmierer. Ich empfehle,  Prezisonsstreifenstcker (&auml;hnlich der IC
        Sockel) zu benutzen und 5 Pins abzubrechen.<br>
         1 x 220 Ohm Widerstand (Farbcode: rot, rot, braun)<br>
         3 x 470 Ohm Widerstand (Farbcode: gelb, lila. braun)<br>
        </td>
      </tr>
    </table>

    Zus&auml;tzlich zu den oben genannten Teilen brauchst du eine 5V elektronisch stabilisierte Spannungsversorgung oder man kann eine 4.5V Batterie als
    Stromversorgung benutzen. <br>
    <br>
    Du hast wahrscheinlich bemerkt, da&szlig; wir keinen Kristall brauchen. Das ist so, weil der ATmega8 jetzt einen eingebauten Oszillator hat. Dieser Oszillator kann benutzt werden, wenn die genaue Taktfrequenz keine Rolle spielt. Wenn du jedoch pr&auml;zise Me&szlig;instrumente bauen willst oder die UART/RS232 Schnittstelle benutzen willst, dann brauchst du einen Kristall. Welcher Typ von Oszillator benutzt wird, kann durch die
    "fuse bits" definiert werden, die man mit dem Programmierer ver&auml;ndern kann. Ab Werk der interne 1Mhz Oszilator aktiv.

    <A NAME="352lfindex8">&nbsp;</A>
<H2>Bauen der Programmiererhardware</H2>

    Die AVR Microcontroller erlauben in circuit programming
    (ISP). <img src="../../common/images2/article352/avr_programmer.jpg" alt="
    [Linux AVR programmer]" align="right" width="300" height="
    303"><br>
     D.h. man braucht den Microcontroller nicht von der Platine abmachen, um ihn zu programmieren. Es gibt verschiedene Programmierhardware zwischen 50-150 Euro. Mit Linux ist es jedoch m&ouml;glich, einen sehr einfachen Programmierer zu bauen, der dasselbe macht. Man braucht einen freien Parallelport und das folgende Kabel. <br>
    <br>

    Beachte, dass das hier ein verbesserter Programmierer ist im Vergleich zu dem im M&auml;rz 2002 Artikel vorgestellten. Wir bauen die Schutzwiderst&auml;nde in den Programmierer ein. Das spart dann einiges an Platz und Teilen auf der Schaltungsplatine. Die Verdrahtung f&uuml;r das Programmiererkabel mu&szlig; wie folgt sein: <br>


    <table border="1" bgcolor="#CDCDCD">
      <tr>
        <th>Pin auf pcb</th>

        <th>Pin auf AVR</th>

        <th>Schutzwiderstand</th>

        <th>Pin am Parallel Port</th>
      </tr>

      <tr>
        <td>5</td>

        <td>Reset (1)</td>

        <td>--</td>

        <td>Init (16)</td>
      </tr>

      <tr>
        <td>4</td>

        <td>MOSI (17)</td>

        <td>470 Ohm</td>

        <td>D0 (2)</td>
      </tr>

      <tr>
        <td>3</td>

        <td>MISO (18)</td>

        <td>220 Ohm</td>

        <td>Busy (11)</td>
      </tr>

      <tr>
        <td>2</td>

        <td>SCK (19)</td>

        <td>470 Ohm</td>

        <td>Strobe (1)</td>
      </tr>

      <tr>

        <td>1</td>

        <td>GND</td>

        <td>--</td>

        <td>GND (18)</td>
      </tr>

    </table>
    <br>
     Das Kabel sollte nicht l&auml;nger as 70cm lang sein. <br>
    <br>
    Die Schutzwiderst&auml;nde k&ouml;nnen in den Stecker wie in dem Bild rechts eingebaut werden.

    <A NAME="352lfindex9">&nbsp;</A>
<H2>Software schreiben</H2>

    Der Atmeag 8 kann in normalem C mit der Hilfe von gcc programmiert werden. Ein bi&szlig;chen AVR assembler zu k&ouml;nnen, kann n&uuml;tzlich sein, ist aber nicht notwendig.
    <br>
    <br>

    Die AVR libc kommt mit einem <a href="../../common/src2/article352/avr-libc-user-manual-1.0.4.pdf">avr-libc-user-manual-1.0.4.pdf
    (1139921 bytes)</a>, das alle in C verf&uuml;gbaren Funktionen dokumentiert. Auf Atmels Website, (<a href="http://www.atmel.com">www.atmel.com</a>, und dann: avr products
    -&gt; 8 bit risc-&gt; Datasheets), kann man das gesamte Datenblatt herunterladen. Es beschreibt alle Register und wie man die CPU benutzt. <br>
     <br>
     Eine Sache, die man beachten mu&szlig;, wenn man einen Microcontroller benutzt, ist, dass er nur ein paar Bytes an Ram besitzt. D.h., man kann keine gro&szlig;en Datenstrukturen oder Strings deklarieren. Dein Programm sollte auch keine tief verschachtelten Funktionsaufrufe oder Rekursion benutzen. <br>

     <br>
     Viel besser als alle Theorie ist ein richtiges Beispiel. Wir schreiben ein kleines Programm, das unsere LED in 0.5 Sekundenintervallen blinken l&auml;&szlig;t. Nicht sehr n&uuml;tzlich, aber sehr gut f&uuml;r den Anfang. <br>
    <br>
    Die avr-libc hat sich sehr ge&auml;ndert. Fr&uuml;her hat man ein Bit auf einem Port mit sbi gesetzt und es mit cbi wieder gel&ouml;scht. Jetzt werden solche Funktionen abgelehnt. Zuerst stelle ich den "guten alten Weg" dar:
<pre class="code">
    /* defines for future compatibility */
    #ifndef cbi
    #define cbi(sfr, bit) (_SFR_BYTE(sfr) &amp;= ~_BV(bit))
    #endif
    #ifndef sbi
    #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))
    #endif

    void main(void)
    {
          /* INITIALIZE */
          /* enable PC5 as output */
          sbi(DDRC,PC5);


          /* BLINK, BLINK ... */
          while (1) {
                /* led on, pin=0 */
                cbi(PORTC,PC5);
                delay_ms(500);
                /* set output to 5V, LED off */
                sbi(PORTC,PC5);
                delay_ms(500);
          }
    }

</pre>
    Das folgende Beispiel macht genau dasselbe, benutzt aber die neue Syntax:
<pre class="code">

    void main(void)
    {
          /* INITIALIZE */
          /* enable PC5 as output */
          DDRC|= _BV(PC5);


          /* BLINK, BLINK ... */

          /* PC5 is 5 (see file include/avr/iom8.h) and _BV(PC5) is 00100000 */
          while (1) {
                /* led on, pin=0 */
                PORTC&amp;= ~_BV(PC5);
                delay_ms(500);
                /* set output to 5V, LED off */
                PORTC|= _BV(PC5);
                delay_ms(500);
          }
    }

</pre>
    Das obige Codest&uuml;ck zeigt, wie einfach es ist, ein Programm zu schreiben. Du siehst nur das Hauptprogramm, die delay_ms Funktion ist in dem <a href="../../common/src2/article352/avrm8ledtest.c.html">kompletten Programm
    (avrm8ledtest.c)</a> enthalten. Um Pin PC5 als Output zu benutzen, mu&szlig;t du das PC5 Bit in dem Data Direction Register f&uuml;r port C (DDRC) setzen.
    Danach kannst du PC5 auf 0V setzen, mit der Funktion
    cbi(PORTC,PC5) (clear bit PC5) oder auf 5V mit sbi(PORTC,PC5)
    (set bit PC5). Der Wert von "PC5" ist in iom8.h definiert, das in io.h enthalten ist. Du mu&szlig;t dir dar&uuml;ber keine Gedanken machen. Wenn du schon mal Programme f&uuml;r multi user / multi tasking
    Systeme wie Linux geschrieben hast, wei&szlig;t du, dass man niemals eine nicht blockierende Endlosschleife schreiben darf. Dies w&auml;re eine Verschwengung von CPU-Zeit und w&uuml;rde das System sehr verlangsamen. Im Falle des AVR ist das anders. Es gibt nicht mehrere Aufgaben und es l&auml;uft auch kein weiteres Programm. Es gibt nicht mal ein Betriebssystem. Es ist deshalb ganz normal, Schleifen f&uuml;r immer laufen zu lassen.

    <A NAME="352lfindex10">&nbsp;</A>
<H2>Kompilieren und Laden</H2>

    Bevor du anf&auml;ngst, stell sicher, dass du /usr/local/avr/bin im
    PATH stehen hast. Wenn n&ouml;tig, &auml;ndere dein .bash_profile oder .tcshrc und f&uuml;ge folgendes hinzu:


    <p class="code">export PATH=/usr/local/avr/bin:${PATH} (for
    bash)<br>
     setenv PATH /usr/local/atmel/bin:${PATH} (for tcsh)</p>

    Wir benutzen den Parallelport und uisp zum Programmieren des AVRs. Uisp benutzt das ppdev Interface des Kernels. Deshalb mu&szlig;t du die folgenden Kernelmodule geladen haben:
<pre class="code">
    # /sbin/lsmod
    parport_pc
    ppdev
    parport
</pre>
    &Uuml;berpr&uuml;fe mit dem Befehl /sbin/lsmod, dass sie geladen sind, ansonsten lade sie (als root) mit:
<pre class="code">
    modprobe parport
    modprobe parport_pc
    modprobe ppdev

</pre>
    Es ist eine gute Idee, diese Befehle automatisch beim Starten auszuf&uuml;hren. Du kannst sie zu einem rc script (z.B. f&uuml;r RedHat
    /etc/rc.d/rc.local) hinzuf&uuml;gen. <br>
     Um das ppdev Interface als normaler Benutzer zu benutzen, mu&szlig; root dir Schreibrechte geben durch einmaliges Laufenlassen des Befehls

    <p class="code">chmod 666 /dev/parport0</p>

    Stell auch sicher, dass kein Druckerdaemon auf dem Parallelport l&auml;uft. Wenn du einen laufen hast, dann stoppe ihn, bevor du das Programmierkabel anschlie&szlig;t. Jetzt ist alles fertig, um unseren Microcontroller zu kompilieren und zu programmieren.<br>
     <br>
     Das Paket f&uuml;r unser Testprogramm (<a href="../../common/src2/article352/index.html">avrm8ledtest-0.1.tar.gz</a>)
    enth&auml;lt ein Make-file. Alles, was du tun mu&szlig;t, ist, das folgende zu tippen:<br>
<br>
     make <br>
     make load<br>
<br>
     Dies kompiliert und l&auml;dt deine Software. Ich werde die Befehle nicht im Detail beschreiben. Du kannst sie im <a
    href="../../common/src2/article352/Makefile.html">Makefile</a> sehen und sie sind immer gleich. Ich erinnere mich selber nicht mehr an alle. Ich wei&szlig; nur, da&szlig; ich "make load" benutzen mu&szlig;. Wenn du ein anderes Programm schreiben willst, mu&szlig;t du nur alle avrm8ledtest in dem Makefile durch den Namen deines Programms ersetzen.

    <A NAME="352lfindex11">&nbsp;</A>
<H2>Einige interessante binutils</H2>

    Interessanter als der tats&auml;chliche Komilationsprozess sind einige binutils. <br>
    Diese utilities haben sich jedoch seit M&auml;rz 2002 nicht ge&auml;ndert. Schau deshalb im Abschnitt "Einige interessante binutils" im
    <a href="../March2002/article231.shtml">Artikel 231, M&auml;rz
    2002</a> nach.

    <A NAME="352lfindex12">&nbsp;</A>
<H2>Ideen und Anregungen</H2>

    Der ATmega8 ist f&uuml;r die meisten Anwendungen zu dem AT90S4433 kompatibel. Du mu&szlig;t die "fuse bits" programmieren, um den externen Oszillator zu benutzen und die fr&uuml;her dargestellte Hardware arbeitet m&ouml;glicherweise mit nur kleinen &Auml;nderungen. Leider hatte ich noch nicht gen&uuml;gend Zeit, um alle Schaltungen nochmal f&uuml;r den ATmega8 zu testen. Wenn du auf der sicheren Seite sein willst, dann benutze den AT90S4433 f&uuml;r die alten Artikel. Wenn es dir nichts ausmacht, Fehler zu suchen und Probleme zu l&ouml;sen, dann probier den ATmega8 mit den alten Artikeln/Schaltungen aus. <br>
    <br>

    Hier ist eine Liste der fr&uuml;heren Hardwareartikel:

    <ul>
      <li><a href="../May2002/article236.shtml">Eine LCD Anzeige und Steuertasten f&uuml;r den Linux Server</a></li>

      <li><a href="../November2002/article251.shtml">Ein Microcontroller gesteuertes Labornetzteil</a></li>

      <li><a href="../September2002/article253.shtml">Frequenzz&auml;hler 1Hz-100Mhz mit LCD Display und RS232 Interface</a></li>

      <li><a href="../March2003/article286.shtml">Linux USB LCD Display mit Watchdog und Tasten</a></li>

      <li><a href="../July2003/article297.shtml">Bau eines autonomen Lichtfinder-Robots</a></li>
    </ul>
    <br>
    <br>
    Beachte, da&szlig; der hier dargestellte Programmierer schon die Schutzwiderst&auml;nde enth&auml;lt, die in den &auml;lteren Hardwareartikeln auf die Platine eingebaut wurden. Um den neuen Programmierer mit den alten Platinen zu benutzen, mu&szlig;t du nur die Schutzwiderst&auml;nde auf der Platine durch die Dr&auml;hte ersetzen.

    <A NAME="352lfindex13">&nbsp;</A>
<H2>Referenzen</H2>


    <ul>

      <li>Pascal Stangs AVRlib: <a href="http://www.procyonengineering.com/avr/avrlib/index.html">http://www.procyonengineering.com/avr/avrlib/index.html</a></li>

      <li>Der tavrasm assembler f&uuml;r Linux: <a href="http://www.tavrasm.org/">www.tavrasm.org</a></li>

      <li><b>Alle Software und Dokumente<a href="../../common/src2/article352/index.html">
, die in diesem Artikel erw&auml;hnt wurden</a></b></li>

      <li>Die Atmel Website: <a href="http://www.atmel.com/">www.atmel.com</a></li>


      <li>Elektronikseiten im tuxgraphics shop:
<a href="http://shop.tuxgraphics.org/">shop.tuxgraphics.org</a>
<br>(Hier kannst du die Linux AVR programming CD, kits und Microcontroller bekommen)
    </li>
    </ul>
    <!-- vim: set sw=2 ts=2 et tw=80: -->
  


<!-- BODY_OF_THE_ARTICLE_STOP -->
<!-- 2pdaIgnoreStart -->
<A NAME="talkback">&nbsp;</a>
<h2>Talkback f&uuml;r diesen Artikel</h2>
Jeder Artikel hat seine eigene Seite f&uuml;r Kommentare und R&uuml;ckmeldungen. Auf dieser Seite kann jeder eigene Kommentare abgeben und die Kommentare anderer Leser sehen:
<center>
    <table width="250" border=0><tr><td>
    <div class="tbbutton"><A class="nodec" href="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=352">&nbsp;Talkback Seite&nbsp;</a></div>
    </td></tr></table>
</center>

<br clear="all">
<HR size="2" noshade>
<table width="250" border=0><tr><td>
<div class="bbutton"><a class="nodec" href="../../index.shtml">&lt;--, LF Home</a></div>
</td><td>
<div class="bbutton"><a class="nodec" href="index.shtml">Zum index dieser Ausgabe</a></div>
</td></tr></table>
<br clear="all">
<HR size="2" noshade>
<!-- ARTICLE FOOT -->
<CENTER><TABLE WIDTH="98%" summary="footer">
<TR><TD ALIGN=CENTER BGCOLOR="#bdc6d5" WIDTH="50%">
<A HREF="../../common/lfteam.html">Der LinuxFocus Redaktion schreiben</A>
<BR><FONT COLOR="#1111aa"><a href="../../common/copy.html">&copy; Guido     Socher</a><br>&quot;some rights reserved&quot; see <a href="../../license/index.shtml">linuxfocus.org/license/</a><br><a href="http://www.linuxfocus.org">http://www.LinuxFocus.org</a></FONT>
</TD>
<TD BGCOLOR="#bdc6d5">
<!-- TRANSLATION INFO -->
<font size=2>Autoren und &Uuml;bersetzer:</font>
<TABLE summary="translators">
  <tr><td><font size="2">en --&gt; -- : Guido Socher (<a href="http://linuxfocus.org/~guido/"><font size="1">homepage</font></a>)</font></td></tr>
</TABLE>
</TD>
</TR></TABLE></CENTER>
<p><font size=1>2005-02-14, generated by lfparser version 2.52</font></p>
<!-- 2pdaIgnoreStop -->
</BODY>
</HTML>
