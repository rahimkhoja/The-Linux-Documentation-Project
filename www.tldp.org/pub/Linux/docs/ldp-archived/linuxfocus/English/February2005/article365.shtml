<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
 <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <META NAME="GENERATOR" CONTENT="lfparser_2.52">
 <META NAME="LFCATEGORY" CONTENT="Hardware">
 <link rel="icon" href="../../common/images/lf-16.png" type="image/png">
 <TITLE>lf365, Hardware: A digital thermometer or talk I2C to your atmel microcontroller</TITLE>
<style type="text/css">
<!--
 td.top {font-family: Arial,Geneva,Verdana,Helvetica,sans-serif; font-size:12 }
 pre { font-family:monospace,Courier }
 pre.code { font-family:monospace,Courier;background-color:#aedbe8; }
 p.cl { color:#EE9500 }
 table.left { margin-right:0.3cm }
 a.nodec { text-decoration:none }
 p.trans { font-size:8pt; text-align:right }
 p.clbox { width:50%; alignment:center; background-color:#FFD700; 
           border-style:none; border-width:medium; border-color:#FFD700; 
           padding:0.5cm;  text-align:center }
 p.code { width:80%; alignment:center; background-color:#aedbe8; 
          border-style:none; border-width:medium; border-color:#aedbe8; 
          padding:0.1cm;  text-align:left }
 p.foot { background-color:#AAAAAA; color:#FFFFFF; border-style:none; 
          border-width:medium; border-color:#AAAAAA; padding:0.5cm ; 
          margin-top:0.1cm; margin-right:1cm; margin-left:1cm; 
          text-align:center }
 div.tbbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   margin: 2px 5px 2px 5px;
   text-align: center;
   width: 20em;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
 div.bbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   float: left;
   margin: 2px 5px 2px 5px;
   text-align: center;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
-->
</style>
 
</HEAD>
<BODY bgcolor="#ffffff" text="#000000">
 <!-- this is generated html code. NEVER use this file for your
 translation work. Instead get the file with the same article number
 and .meta.shtml in its name. Translate this meta file and then
 use lfparser program to generate the final article -->
 <!-- lfparser can be obtained from http://main.linuxfocus.org/~guido/dev/lfparser.html -->

<!-- this is used by a number of tools:
 =LF=AUTHOR: Guido     Socher
 =LF=CAT___: Hardware
 =LF=TITLE_: A digital thermometer or talk I2C to your atmel microcontroller
 =LF=NUMBER: 365
 =LF=ANAME_: article365.shtml
 =LF=PARSER: 2.52
 -->

<!-- 2pdaIgnoreStart -->

<!-- start navegation bar, current, style=2 -->
 <!-- top navegation bar -->
 <TABLE summary="topbar_1" cellspacing="0" cellpadding="0" border="0" align="center" width="90%">
   <TR bgcolor="#2e2292">
     <TD class="top"><TABLE summary="topbar_1_logo" cellspacing="0" cellpadding="0" border="0" width=
       "100%">
         <TR><TD width="319"><a href="../../index.shtml"><IMG src="../../common/images/logolftop_319x45.gif"
           alt="[LinuxFocus-icon]" width="319" height="45" align="left" 
           border="0"></a></TD>

           <TD class="top">
             <TABLE summary="topbar_1_links" width="100%">
               <TR align="right">
                 <TD class="top">
                 
                 <A class="nodec" href="../../index.shtml"><FONT color=
                 "#DDDDDD" size="2">&lt;--</FONT></A> &nbsp;| 
                 <A class="nodec" href="../map.html"><FONT color=
                 "#DDDDDD" size="2">Map</FONT></A> &nbsp;| 
                 <A class="nodec" href="../indice.html"><FONT color=
                 "#DDDDDD" size="2">Index</FONT></A> &nbsp;| 
                 <A class="nodec" href="../Search/index.html"><FONT color=
                 "#DDDDDD" size="2">Search</FONT></A> </TD>
                 
               </TR>

               <TR align="right">
                 <TD class="top">
                   <HR width="100%" noshade size="1">
                 </TD>
               </TR>
             </TABLE>
           </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end top navegation bar -->
 <!-- blue bar -->
 <TABLE summary="topbar_2" cellspacing="0" cellpadding="0" border="0" align="center"
 width="90%">
   <TR bgcolor="#00ffff">
     <TD><IMG src="../../common/images/transpix.gif" width="1" height=
     "2" alt=""></TD>
   </TR>
 </TABLE>
 <!-- end blue bar -->
 <!-- bottom navegation bar -->
 <TABLE summary="topbar_3" cellspacing="0" cellpadding="0" border="0" align="center"
 width="94%">
   <TR bgcolor="#000000">
     <TD>
       <TABLE summary="topbar_3_links" cellspacing="0" cellpadding="1" border="0" width=
       "100%">
         <TR align="center">
           <TD WIDTH="20%"><A class="nodec" href="../News/index.html"><FONT color=
           "#FFFFFF">News</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Archives/index.html"><FONT color=
           "#FFFFFF">Archives</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Links/index.html"><FONT color=
           "#FFFFFF">Links</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../aboutus.html"><FONT color=
           "#FFFFFF">About LF</FONT></A> </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end bottom navegation bar -->
<!-- stop navegation bar -->

<!-- SSI_INFO -->

<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfdynahead ver 1.5 --><TABLE ALIGN="right" border=0><TR><TD ALIGN="right"><FONT SIZE="-1" FACE="Arial,Helvetica">This document is available in: <A href="../../English/February2005/article365.shtml">English</a> &nbsp;<A href="../../Castellano/February2005/article365.shtml">Castellano</a> &nbsp;<A href="../../ChineseGB/February2005/article365.shtml">ChineseGB</a> &nbsp;<A href="../../Deutsch/February2005/article365.shtml">Deutsch</a> &nbsp;<A href="../../Francais/February2005/article365.shtml">Francais</a> &nbsp;</FONT></TD></TR></TABLE><br>
 


<!-- SSI_INFO STOP -->
<!-- 2pdaIgnoreStop -->

<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_START -->
<TABLE ALIGN="LEFT" BORDER="0" WIDTH="195" summary="about the author" class="left">
<TR>
<TD>

<img src="../../common/images/Guido-S.gif" alt=
    "[Photo of the Author]" height="164" width="173">
<BR>by  Guido Socher <a href="http://linuxfocus.org/~guido/"><font size="1">(homepage)</font></a>
<BR><BR>
<I>About the author:</I><BR>
<!-- aboutauthor_start -->
<p>Guido likes Linux because it is a really good system to
    develop your own hardware.</p>
<!-- aboutauthor_stop -->
<!-- TRANSLATED_TO en -->
<!-- TRANSLATED_TO_STOP -->
<!-- INDEX_START -->
<BR><i>Content</i>:
<UL>
  <LI><A HREF="#365lfindex0">Introduction</A></LI>
  <LI><A HREF="#365lfindex1">How I2C/TWI works</A></LI>
  <LI><A HREF="#365lfindex2">The plan</A></LI>
  <LI><A HREF="#365lfindex3">The temperature sensor</A></LI>
  <LI><A HREF="#365lfindex4">The circuit</A></LI>
  <LI><A HREF="#365lfindex5">Making the board</A></LI>
  <LI><A HREF="#365lfindex6">Putting everything together</A></LI>
  <LI><A HREF="#365lfindex7">Using the I2C communication</A></LI>
  <LI><A HREF="#365lfindex8">How warm is it?</A></LI>
  <LI><A HREF="#365lfindex9">Conclusion</A></LI>
  <LI><A HREF="#365lfindex10">References</A></LI>
  <LI><A HREF="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=365">Talkback form for this article</A></LI>
</UL>

</TD></TR></TABLE>
<!-- INDEX_STOP -->
<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_STOP -->
<!-- HEAD_OF_THE_ARTICLE_START -->
<br>&nbsp;
<table border="0"><tr><td>
<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfPdf ver 0.1 -->
<TABLE style="border-style:outset; border-width:1px" align="right" bgcolor="#ff9616" cellspacing="1"><TR><TD bgcolor="#ff9616">
        <a href="../Archives/lf-2005_02-0365.pdf"><small>PDF</small></a>
        </TD></TR></TABLE>
         

<H2>A digital thermometer or talk I2C to your atmel microcontroller</H2>
 <img src="../../common/images2/article365/title_365.jpg" alt=
    "[Illustration]" hspace="10">
<!-- ABSTRACT OF THE ARTICLE -->
<P><i>Abstract</i>:
<P>
<!-- articleabstract_start -->

    The Atmega8 microcontroller from Atmel has plenty of digital
    and analog input/output lines. It is the ideal device to
    develop any kind of measurement equipment. <br><br>
    In this article we see how to interconnect the microcontroller
    to a linux PC over a physical RS232 interface without the extra
    MAX232 chip.

    
<!-- articleabstract_stop -->

<br><!-- HR divider --><center><font color="#8282e0"><b>_________________ _________________ _________________</b></font></center><br>
</td></tr></table>
<!-- HEAD_OF_THE_ARTICLE_STOP -->
<!-- BODY_OF_THE_ARTICLE_START -->


    <A NAME="365lfindex0">&nbsp;</A>
<H2>Introduction</H2>

    A pre-requisite for this article is that you have the GCC AVR
    programming environment installed as described in <a href=
    "../November2004/article352.shtml">my "Programming the AVR
    microcontroller with GCC, libc 1.0.4" article</a>. If
    you want to avoid troubles with the installation you can of
    course use the AVR programming CD from <a href=
    "http://shop.tuxgraphics.org/">http://shop.tuxgraphics.org/</a>
    <a href=
    "http://shop.tuxgraphics.org/electronic/microcontroller.html"><img
     src="../../common/images2/article365/linuxavrcd_th.jpg" align=
    "right" width="150" height="213" vspace="4" hspace="4"></a>
    <br>
    <br>
    <br>
    When you use such an advanced device as a microcontroller to
    measure analog or digital signals then you want of course
    interfaces to evaluate the data or send commands to the
    microcontroller. In all the articles presented here in the past
    we always used rs232 communication with the UART that is
    included in the microcontroller. The problem is that this
    requires an additional MAX232 chip and 4 extra capacitors.
    Atmel suggests also that an external crystal osciallator is
    required for the UART communication to work reliably. In any
    case it is a lot of extra parts..... and we can avoid them!
    <br>
    <br>
    The amount of data to transfer between PC and microcontroller
    is usually very small (just a few bytes). Speed it therefore no
    issue at all. This makes the I2C bus/protocol suitable for this
    task. <br>
    <br>
    I2C (prounouce "eye-square-see") is a two-wire bidirectional
    communication interface. It was invented by Philips and they
    have protected this name. This is why other manufacturers use a
    different name for the same protocol. Atmel calls I2C "two wire
    interface" (TWI). <br>
    <br>
    Many of you might already be using I2C on their PCs without
    knowing it. All modern motherboards have an I2C bus to read
    temperatures, fan speed, information about available memory....
    all kind of hardware information. This I2C bus is unfortunately
    not available on the outside of the PC (there is no physical
    connector). Therefore we will have to invent something new.
    <br>
    <br>
    But let's first see how the "two wire interface" (=TWI =
    alternative name for I2C) works.

    <A NAME="365lfindex1">&nbsp;</A>
<H2>How I2C/TWI works</H2>

    The datasheet of the Atmega8 (see references) has actually a
    very detailed description starting on page 160. I will therefore
    present here just an overview. After this overview you will be
    able to understand the description in the datasheet. <br>
    <br>
    On the I2C bus you always have one master and one or several
    slave devices. The master is the device that initiates the
    communication and controls the clock. The two wires of this bus
    are called SDA (data line) and SCL (clock line). Each of the
    devices on the bus must be powered independently (same as with
    traditional rs232 communication). The two lines of the bus are
    normally connected via 4.7K pullup resistors to logically
    "High" (+5V for 5V ICs). This gives an electrical "or"
    connection between all the devices. A device just puls a line
    to GND when it wants to transmit a 0 or leaves it "High" when
    it sends a 1. <br>
    <br>
    The master starts a communication by sending a pattern called
    "start condition" and then addresses the device it wants to
    talk to. Each device on the bus has a 7 bit unique address.
    After that the master sends a bit which indicates if it wants
    to read or write data. The slave will now acknowledge that it
    has understood the master by sending an ack-bit. In other words
    we have now seen 9 bits of data on the bus (7 address bits +
    read_bit + ack-bit):
<pre class="code">
| start | 7-bit slave adr | read_data bit | wait for ack | ... data comes here
</pre>
    What's next? <br>
    <br>
    Next we can receive or transmit data. Data is always a multiple
    of 8 bits (1 byte) and must be acknowledged by an ack-bit. In
    other words we will always see 9-bit packets on the bus. When
    the communication is over then the master must transmit a "stop
    condition". In other words the master must know how much data
    will come when it reads data from a slave. This is however not
    a problem since you can transmit this information inside the
    user protocol. We will e.g use the zero byte at the end of a
    string to indicate that there is no more data. <br>
    <br>
     The data on the SDA wire is valid while the SCL is 1. Like
    this:
<pre class="code">
SDA H -\       /---\     /---\          /---\
    L   \-----/     \---/     \--------/     \------....

SCL H ----\     /-\       /-\     /-\    /-\    /-\
    L      \---/   \-----/   \---/   \--/   \--/   \-....


  | START |      1 |       1 |     0 |    1 |    0 |
</pre>
    One of the best things about this protocol is that you do not
    need a precise and synchronous clock signal. The protocol does
    still work when there is a little bit jitter in the clock
    signal. <br>
    <br>
     Exactly this property makes it possible to implement the I2C
    protocol in a user space application without the need for a
    kernel driver or special hardware (like a UART). Cool isn't it?


    <A NAME="365lfindex2">&nbsp;</A>
<H2>The plan</H2>

    As said before we cannot use the PCs internal I2C bus but we
    can use any external interface where we can send and receive
    individual data bits. We will just use the RS232 hardware
    interface of our PC. In other words our communication interface
    is still the same as in previous articles but we save the
    MAX232 hardware, capacitors, etc... <br>
    <br>
    The tough part is of course to implement the I2C protocol from
    scratch. It took me 5 weeks to learn it and debug it but now it
    is done and you can just copy it :-). I hope you remember the
    value of this code when you use it. <br>
    <br>
    As an example application we will build a thermometer. You can
    of course measure something else or just switch on/off lights.
    It's up to you. <br>
    <br>
    In a second article we will add a local LCD display. In other
    words you will have a thermometer where you can read the
    temperature directly from the display and/or you can read it
    out with your linux PC. The display comes in a second article
    in order not to overload this one.

    <table align="right" width="162">
      <tr>
        <td bgcolor="#C5D4F9"><img src=
        "../../common/images2/article365/ntc.jpg" alt="ntc"><br>
        NTCs are small, cheap and accurate enough</td>
      </tr>
    </table>

    <A NAME="365lfindex3">&nbsp;</A>
<H2>The temperature sensor</H2>

    It is possible to get already calibrated temperature sensors
    (some of which talk I2C ;-) but they are quite expensive. NTCs
    are cheaper and almost as good even without individual
    calibration. If you calibrate them a bit then it is
    possible to achieve accuracy behind the decimal point. <br>
    <br>
    One problem with NTCs is that they are non linear. It is
    however just a matter of semiconductor physics to find the
    right formula to correct the non linear curve. The
    microcontroller is a little computer therefore mathematical
    operations are not a problem. NTCs are temperature dependent resistors. The
value R of the NTC at a given temperature is:<br clear="all">

    <center>
      <img src="../../common/images2/article365/Ntcformula.gif"
      alt="ntc formula">
    </center>
    T or Tc is the temperature value that we are looking for. Rn is
    the resistive value of the NTC at 25'C. You can buy 4k7, 10K,
    ... NTCs so Rn is this value. <br>


    <A NAME="365lfindex4">&nbsp;</A>
<H2>The circuit</H2>


    <table align="right">
      <tr>
        <td>
          <center>
            <a href=
            "../../common/images2/article365/i2ctemp_schematic.gif">
            <img src=
            "../../common/images2/article365/i2ctemp_schematic_th.gif"
             alt="circuit diagram"></a><br>
            Circuit diagram. Click on the diagram for a more
            detailed view.
          </center>
        </td>
      </tr>
    </table>
    Now we have all we need to build a digital thermometer. We add
    two NTC sensors, one for inside temperature and one for outside.
    You can add more if you want (conn3, pin PC2 is e.g free). In
    the circuit diagram I add already the needed wires for the
    connection of an LCD display because I don't want you to build
    a complete new circuit for the next article. <br>
    <br>
    There is also an LED connected. It does not cost much and is
    really useful for basic debugging. I used it e.g to debug the
    I2C state machine when I developed the I2C communication
    between PC and microcontroller. During normal operation we can
    just leave it blinking to indicate that measurements are taken.
    <br>
    <br>
    The circuit is otherwise straight forward. The analog to
    digital converter in the microcontroller is used to measure the
    voltage on the NTC which will then be converted into a
    temperature value. <br>
    <br>
    The Atmega8 has two options on what is used as a reference
    voltage for the analog to digital converter. It can use either
    the 5V (AVcc) or an internal 2.56V reference. For the inside
    temperatures we will not need a temperature range which is as
    big as for the outside sensor. +10'C to +40'C should normally
    be sufficient. We can therefore use the 2.56V reference when we
    measure the indoor sensor. This gives very high accuracy as the
    1024 possible digital values are then spread over only 0-2.56V
    that is we get a resolution of 2.5mV (more accurate than most
    digital voltmeters!). <br>
    <br>
    The CD-pin on the RS232 is an input line and it is connected to
    SDA on the I2C bus. We use it to read data from the
    microcontroller. DTR and RTS are output lines. When the PC puts
    data-bits on the SDA line then it just toggles DTR. The
    I2C-master (here the linux PC) controls the SCL (clock) line.
    In other words the clock line is an output line on the rs232.
    <br>
    <br>
    The 78L05 is used to generate a stable power supply and
    reference voltage. You can use almost any type of power supply AC
    or DC between 7.5V and 12V. 9V is a good choice.

    <A NAME="365lfindex5">&nbsp;</A>
<H2>Making the board</H2>


    <table align="right" width="202">
      <tr>
        <td bgcolor="#C5D4F9"><a href=
        "http://shop.tuxgraphics.org"><img src=
        "../../common/images2/article365/article365kit_th.jpg" alt=
        "get this kit from the tuxgraphics shop"></a><br>
        tuxgraphics.org sells all the parts needed for this article
        together with a properly etched board.</td>
      </tr>
    </table>
    You can of course re-use the prototyping board which we used in
    the previous article. Just re-connect the LED to pin 11 and add
    all new things. <br>
    <br>
    If you want to have a nice and good looking circuit then it
    makes sense to use a new board. Because the circuit is much more
    complicated it makes a lot of sence to properly etch a printed
    circuit board. After reading Iznogood's linuxfocus article on
    gEDA I decided to also use gEDA instead of Eagle. gschem the
    schematic drawing tool for gEDA is very good. It does not have
    a library of symbols as big as Eagle and I had to create the
    symbol for the Atmega8 but it is very easy to use and as good
    as Eagle. Quite a bit more problematic is pcb, the tool to draw
    PCBs. When you come from Eagle you will first of all notice
    that it is possible to disconnect the parts from the rubber
    bands. To be sure that the right rubber band is connected to
    the right pin you have to run
    Connects-&gt;Optimize rats-nest once in a while. You should first complete the
    circuit diagram and then make the board. Annotation between the
    two is only manual. <img src=
    "../../common/images2/article365/i2ctemppcb_topview_position_components.png"
     alt="top view, position of components" align="left"> <br>
    <br>
    I used the orange colored layer for drawing. Somehow the other
    layers would not generate any output when printing. The problem
    is that the orange colored layer is acutally on the side of the
    board where the parts are. If you write text in this layer then
    it has to be mirrord when you print it on the physical board.
    Therefore I made the basic layout with pcb and all the rest
    with gimp. <br>
    <br>
    Thanks to <a href=
    "http://shop.tuxgraphics.org">shop.tuxgraphics.org</a> you will
    not have to deal with hazardous chemicals and run around town to
    find the right components. They sell all the parts needed for
    this article. This way you can concentrate on the fun part and
    successfully assemble this circuit.

    <A NAME="365lfindex6">&nbsp;</A>
<H2>Putting everything together</H2>

    When you assemble the circuit then pay attention to the parts
    where polarity is important: Electrolyte capactitors, the
    diode, Z-diodes, 78L05, LED and the microcontroller. <br>
    <br>
    Before you put the microcontroller into the socket you should
    verify the power supply part. If this does not work you will
    not only get incorrect temperature readings but you may also
    destroy the microcontroller. Therefore connect external power
    (e.g a 9V battery) and verify with a voltmeter that you get
    exactly 5V on the socket pin of the microcontroller. As a next
    step connect the circuit to the rs232 port of your linux PC and
    run the porgram i2c_rs232_pintest with various combinations of
    signals.
<pre class="code">
i2c_rs232_pintest -d 1 -c 1
i2c_rs232_pintest -d 0 -c 1
i2c_rs232_pintest -d 1 -c 0
</pre>
    This program sets the voltage levels on the RTS (used as SCL,
    option -c) and DTR (used as SDA, option -d) pins of the rs232
    port. The rs232 port has voltage levels of about +/- 10V.
    Behind the Z-diode you should however measure only -0.7 for a
    logical zero and +4-5V for a logical one. <br>
    <br>
    Insert the microcontroller only after your circuit has passed
    the above tests.

    <A NAME="365lfindex7">&nbsp;</A>
<H2>Using the I2C communication</H2>

    Download (see references) the linuxI2Ctemp tar.gz file and
    unpack it. The I2C communication is implemented in 2 files:
<pre class="code">
i2c_avr.c -- the i2c statemachine for the atmega8
i2c_m.c   -- the complete i2c protocol on the linux side
</pre>
    I have given the atmega8 the slave address "3". To send the
    string "hello" to the atmega8 you would execute the following C
    functions:
<pre class="code">
address_slave(3,0); // tell the slave that we will send something
i2c_tx_string("hello");
i2cstop(); // release the i2c bus

on the microcontroller side you would receive this "hello" string with
i2c_get_received_data(rec_buf);
</pre>
    Very easy. Reading data from the microcontroller is similar.
    Look at the file i2ctemp_avr_main.c to see how it works when
    the temperature readings are done.

    <A NAME="365lfindex8">&nbsp;</A>
<H2>How warm is it?</H2>

    To compile and load the code for the microcontroller run the
    following commands from the linuxI2Ctemp package directory.
<pre class="code">
make
make load
</pre>
    Compile the two programs i2c_rs232_pintest and i2ctemp_linux
<pre class="code">
make i2c_rs232_pintest
make i2ctemp_linux
</pre>
    ... or just use the pre-compiled versions in the "bin"
    subdirectory. <br>
    <br>
    To read temperatures simply run:
<pre class="code">
i2ctemp_linux
</pre>
    ... and it will print indoor and outdoor temperatures. To make
    this data available on a website I suggest to not directly run
    i2ctemp_linux from the webserver because the i2c communication
    is very slow. Instead run it from a cron job and write from
    there to a html file. An example script is included in the
    README file of the linuxI2Ctemp package.

    <A NAME="365lfindex9">&nbsp;</A>
<H2>Conclusion</H2>

    The I2C protocol requires very little extra hardware and is
    optimized for transmitting or receiving small amounts of data.
    That is exactly what we need when we want to communicate with
    our own microcontroller hardware. It is really a very nice
    solution! <br>
    <br>
    In this article I have focused very much on the hardware part.
    If you like this article then I will also write a second one
    where I describe how the software works. Especially how to do
    analog to digital conversion and how the I2C protocol
    implementation works. In this next article we can also add an
    LCD display and add conversion between Farenheit and Celsius.

    <A NAME="365lfindex10">&nbsp;</A>
<H2>References</H2>


    <ul>
      <li><b>Download</b> page for this article: <a href="../../common/src2/article365/index.html">the linuxI2Ctemp software,
      diagrams, software updates</a></li>

      <li>How to program the atmega8 with gcc: <a href=
      "../November2004/article352.shtml">November2004 article
      352</a></li>

      <li>Datasheet for the Atmega8: go to http://www.atmel.com/
      and select products-&gt;Microcontrollers -&gt;AVR-8 bit
      RISC-&gt;Documentation-&gt;datasheets <a href=
      "../../common/src2/article365/atmega8.pdf">(local copy, pdf,
      2479982 bytes)</a></li>

      <li>The tuxgraphics shop. A really great online shop :-): <a
      href=
      "http://shop.tuxgraphics.org/">shop.tuxgraphics.org</a><br>
       Here you can get the Linux AVR programming CD, all parts for
      this article, LCD displays and microcontrollers.</li>
    </ul>
    <!-- vim: set sw=2 ts=2 et tw=80: -->
  



<!-- BODY_OF_THE_ARTICLE_STOP -->
<!-- 2pdaIgnoreStart -->
<A NAME="talkback">&nbsp;</a>
<h2>Talkback form for this article</h2>
Every article has its own talkback page. On this page you can submit a comment or look at comments from other readers:
<center>
    <table width="250" border=0><tr><td>
    <div class="tbbutton"><A class="nodec" href="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=365">&nbsp;talkback page&nbsp;</a></div>
    </td></tr></table>
</center>

<br clear="all">
<HR size="2" noshade>
<table width="250" border=0><tr><td>
<div class="bbutton"><a class="nodec" href="../../index.shtml">&lt;--, LF Home</a></div>
</td><td>
<div class="bbutton"><a class="nodec" href="index.shtml">Go to the index of this issue</a></div>
</td></tr></table>
<br clear="all">
<HR size="2" noshade>
<!-- ARTICLE FOOT -->
<CENTER><TABLE WIDTH="98%" summary="footer">
<TR><TD ALIGN=CENTER BGCOLOR="#bdc6d5" WIDTH="50%">
<A HREF="../../common/lfteam.html">Webpages maintained by the LinuxFocus Editor team</A>
<BR><FONT COLOR="#1111aa"><a href="../../common/copy.html">&copy; Guido     Socher</a><br>&quot;some rights reserved&quot; see <a href="../../license/index.shtml">linuxfocus.org/license/</a><br><a href="http://www.linuxfocus.org">http://www.LinuxFocus.org</a></FONT>
</TD>
<TD BGCOLOR="#bdc6d5">
<!-- TRANSLATION INFO -->
<font size=2>Translation information:</font>
<TABLE summary="translators">
  <tr><td><font size="2">en --&gt; -- : Guido Socher (<a href="http://linuxfocus.org/~guido/"><font size="1">homepage</font></a>)</font></td></tr>
</TABLE>
</TD>
</TR></TABLE></CENTER>
<p><font size=1>2005-02-03, generated by lfparser version 2.52</font></p>
<!-- 2pdaIgnoreStop -->
</BODY>
</HTML>
