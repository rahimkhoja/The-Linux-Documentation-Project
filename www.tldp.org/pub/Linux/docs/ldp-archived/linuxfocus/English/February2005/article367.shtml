<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
 <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <META NAME="GENERATOR" CONTENT="lfparser_2.52">
 <META NAME="LFCATEGORY" CONTENT="KernelCorner">
 <link rel="icon" href="../../common/images/lf-16.png" type="image/png">
 <TITLE>lf367, KernelCorner: Writing your own netfilter match</TITLE>
<style type="text/css">
<!--
 td.top {font-family: Arial,Geneva,Verdana,Helvetica,sans-serif; font-size:12 }
 pre { font-family:monospace,Courier }
 pre.code { font-family:monospace,Courier;background-color:#aedbe8; }
 p.cl { color:#EE9500 }
 table.left { margin-right:0.3cm }
 a.nodec { text-decoration:none }
 p.trans { font-size:8pt; text-align:right }
 p.clbox { width:50%; alignment:center; background-color:#FFD700; 
           border-style:none; border-width:medium; border-color:#FFD700; 
           padding:0.5cm;  text-align:center }
 p.code { width:80%; alignment:center; background-color:#aedbe8; 
          border-style:none; border-width:medium; border-color:#aedbe8; 
          padding:0.1cm;  text-align:left }
 p.foot { background-color:#AAAAAA; color:#FFFFFF; border-style:none; 
          border-width:medium; border-color:#AAAAAA; padding:0.5cm ; 
          margin-top:0.1cm; margin-right:1cm; margin-left:1cm; 
          text-align:center }
 div.tbbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   margin: 2px 5px 2px 5px;
   text-align: center;
   width: 20em;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
 div.bbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   float: left;
   margin: 2px 5px 2px 5px;
   text-align: center;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
-->
</style>
 
</HEAD>
<BODY bgcolor="#ffffff" text="#000000">
 <!-- this is generated html code. NEVER use this file for your
 translation work. Instead get the file with the same article number
 and .meta.shtml in its name. Translate this meta file and then
 use lfparser program to generate the final article -->
 <!-- lfparser can be obtained from http://main.linuxfocus.org/~guido/dev/lfparser.html -->

<!-- this is used by a number of tools:
 =LF=AUTHOR: Nicolas Bouliane
 =LF=CAT___: KernelCorner
 =LF=TITLE_: Writing your own netfilter match
 =LF=NUMBER: 367
 =LF=ANAME_: article367.shtml
 =LF=PARSER: 2.52
 -->

<!-- 2pdaIgnoreStart -->

<!-- start navegation bar, current, style=2 -->
 <!-- top navegation bar -->
 <TABLE summary="topbar_1" cellspacing="0" cellpadding="0" border="0" align="center" width="90%">
   <TR bgcolor="#2e2292">
     <TD class="top"><TABLE summary="topbar_1_logo" cellspacing="0" cellpadding="0" border="0" width=
       "100%">
         <TR><TD width="319"><a href="../../index.shtml"><IMG src="../../common/images/logolftop_319x45.gif"
           alt="[LinuxFocus-icon]" width="319" height="45" align="left" 
           border="0"></a></TD>

           <TD class="top">
             <TABLE summary="topbar_1_links" width="100%">
               <TR align="right">
                 <TD class="top">
                 
                 <A class="nodec" href="../../index.shtml"><FONT color=
                 "#DDDDDD" size="2">&lt;--</FONT></A> &nbsp;| 
                 <A class="nodec" href="../map.html"><FONT color=
                 "#DDDDDD" size="2">Map</FONT></A> &nbsp;| 
                 <A class="nodec" href="../indice.html"><FONT color=
                 "#DDDDDD" size="2">Index</FONT></A> &nbsp;| 
                 <A class="nodec" href="../Search/index.html"><FONT color=
                 "#DDDDDD" size="2">Search</FONT></A> </TD>
                 
               </TR>

               <TR align="right">
                 <TD class="top">
                   <HR width="100%" noshade size="1">
                 </TD>
               </TR>
             </TABLE>
           </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end top navegation bar -->
 <!-- blue bar -->
 <TABLE summary="topbar_2" cellspacing="0" cellpadding="0" border="0" align="center"
 width="90%">
   <TR bgcolor="#00ffff">
     <TD><IMG src="../../common/images/transpix.gif" width="1" height=
     "2" alt=""></TD>
   </TR>
 </TABLE>
 <!-- end blue bar -->
 <!-- bottom navegation bar -->
 <TABLE summary="topbar_3" cellspacing="0" cellpadding="0" border="0" align="center"
 width="94%">
   <TR bgcolor="#000000">
     <TD>
       <TABLE summary="topbar_3_links" cellspacing="0" cellpadding="1" border="0" width=
       "100%">
         <TR align="center">
           <TD WIDTH="20%"><A class="nodec" href="../News/index.html"><FONT color=
           "#FFFFFF">News</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Archives/index.html"><FONT color=
           "#FFFFFF">Archives</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Links/index.html"><FONT color=
           "#FFFFFF">Links</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../aboutus.html"><FONT color=
           "#FFFFFF">About LF</FONT></A> </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end bottom navegation bar -->
<!-- stop navegation bar -->

<!-- SSI_INFO -->

<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfdynahead ver 1.5 --><TABLE ALIGN="right" border=0><TR><TD ALIGN="right"><FONT SIZE="-1" FACE="Arial,Helvetica">This document is available in: <A href="../../English/February2005/article367.shtml">English</a> &nbsp;<A href="../../ChineseGB/February2005/article367.shtml">ChineseGB</a> &nbsp;<A href="../../Deutsch/February2005/article367.shtml">Deutsch</a> &nbsp;<A href="../../Francais/February2005/article367.shtml">Francais</a> &nbsp;</FONT></TD></TR></TABLE><br>
 


<!-- SSI_INFO STOP -->
<!-- 2pdaIgnoreStop -->

<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_START -->
<TABLE ALIGN="LEFT" BORDER="0" WIDTH="195" summary="about the author" class="left">
<TR>
<TD>

<img src="../../common/images2/NicolasBouliane.jpg" alt="Photo of Nicolas Bouliane">
<BR>by  Nicolas Bouliane <br> <small>&lt;nib(at)cookinglinux!org&gt;</small>
<BR><BR>
<I>About the author:</I><BR>
<!-- aboutauthor_start -->

Nicolas is a young warrior in the free software community.
He's a gnu/linux addict since the day he installed it on his computer in 1998.
He spend his time studying the linux networking stack, writing free softwares
and attending at linux related conference like the OLS.
When he's not in front of his computer, he likes watching sci-fi movies,
playing chess and listening Richard Stallman's talk.


<!-- aboutauthor_stop -->
<!-- TRANSLATED_TO en -->
<!-- TRANSLATED_TO_STOP -->
<!-- INDEX_START -->
<BR><i>Content</i>:
<UL>
  <LI><A HREF="#367lfindex0">Description</A></LI>
  <LI><A HREF="#367lfindex1">1.0 The iptables module</A></LI>
  <LI><A HREF="#367lfindex2">1.1 Structures and Functions available</A></LI>
  <LI><A HREF="#367lfindex3">1.2 Inside the skeleton</A></LI>
  <LI><A HREF="#367lfindex4">1.2.1 Initialization</A></LI>
  <LI><A HREF="#367lfindex5">1.2.2 save function</A></LI>
  <LI><A HREF="#367lfindex6">1.2.3 print function</A></LI>
  <LI><A HREF="#367lfindex7">1.2.4 final check function</A></LI>
  <LI><A HREF="#367lfindex8">1.2.5 parse function</A></LI>
  <LI><A HREF="#367lfindex9">1.2.6 options structure</A></LI>
  <LI><A HREF="#367lfindex10">1.2.7 init function</A></LI>
  <LI><A HREF="#367lfindex11">1.2.7 help function</A></LI>
  <LI><A HREF="#367lfindex12">1.2.8 the header's file 'ipt_ipaddr.h'</A></LI>
  <LI><A HREF="#367lfindex13">1.3 Summary chapter 1</A></LI>
  <LI><A HREF="#367lfindex14">2.0 The netfilter module</A></LI>
  <LI><A HREF="#367lfindex15">2.1 Structures and Functions available</A></LI>
  <LI><A HREF="#367lfindex16">2.2 Inside the skeleton</A></LI>
  <LI><A HREF="#367lfindex17">2.2.1 Initialization</A></LI>
  <LI><A HREF="#367lfindex18">2.2.2 match function</A></LI>
  <LI><A HREF="#367lfindex19">2.2.3 checkentry function</A></LI>
  <LI><A HREF="#367lfindex20">2.3 Summary chapter 2</A></LI>
  <LI><A HREF="#367lfindex21">3.0 Playing with iptables/netfilter</A></LI>
  <LI><A HREF="#367lfindex22">3.1 iptables</A></LI>
  <LI><A HREF="#367lfindex23">3.2 kernel</A></LI>
  <LI><A HREF="#367lfindex24"> Conclusion </A></LI>
  <LI><A HREF="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=367">Talkback form for this article</A></LI>
</UL>

</TD></TR></TABLE>
<!-- INDEX_STOP -->
<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_STOP -->
<!-- HEAD_OF_THE_ARTICLE_START -->
<br>&nbsp;
<table border="0"><tr><td>
<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfPdf ver 0.1 -->
<TABLE style="border-style:outset; border-width:1px" align="right" bgcolor="#ff9616" cellspacing="1"><TR><TD bgcolor="#ff9616">
        <a href="../Archives/lf-2005_02-0367.pdf"><small>PDF</small></a>
        </TD></TR></TABLE>
         

<H2>Writing your own netfilter match</H2>
 <IMG SRC="../../common/images2/article367.png" ALT="[Illustration]" HSPACE=10>
<!-- ABSTRACT OF THE ARTICLE -->
<P><i>Abstract</i>:
<P>
<!-- articleabstract_start -->

The iptables/netfilter framework gives us the possibility to add features.
To do so, we write kernel modules that registers against this framework.
Also, depending on the feature's category, we write an iptables module.
By writing your new extension, you can match, mangle, give faith and track a
given packet. In fact, you can do almost everything you want in this filtering
world.

Beware that a little error in a kernel module can severly crash the computer.
<br><br>

For the sake of simplicity, I will explain a skeleton match that I wrote. This way,
I hope to make the interactions with the framework a little easier to understand.
Here, I'll assume you already know a bit about iptables and that you know C programming.
<br><br>

This example will show you how to match a packet according to the source and/or destination address ip.

<!-- articleabstract_stop -->

<br><!-- HR divider --><center><font color="#8282e0"><b>_________________ _________________ _________________</b></font></center><br>
</td></tr></table>
<!-- HEAD_OF_THE_ARTICLE_STOP -->
<!-- BODY_OF_THE_ARTICLE_START -->



<A NAME="367lfindex0">&nbsp;</A>
<H2>Description</H2>


The general steps around creating an iptables/netfilter's match module are:
<ul>
  <li> You want to match a specific situation.
  </li><li> Write the user-space part which will handle arguments.
  </li><li> Write the kernel-space part which will analyze packets and says to match or not.
</li></ul>

<A NAME="367lfindex1">&nbsp;</A>
<H2>1.0 The iptables module</H2>


The purpose of an iptables library is basically to interact with the user. It
will handle the arguments the user want the kernel-part to take in
consideration.

<A NAME="367lfindex2">&nbsp;</A>
<H2>1.1 Structures and Functions available</H2>

At first, some basic structures.
&lt;<i>iptables/include/iptables.h</i>&gt;<br>
We will see later in this text what's the purpose of each field.
<table width="70%"><tr><td>
<pre class="code">/* Include file for additions: new matches and targets. */
struct iptables_match
{
   struct iptables_match *next;

   ipt_chainlabel name;

   const char *version;

   /* Size of match data. */
   size_t size;

   /* Size of match data relevent for userspace comparison purposes */
   size_t userspacesize;

   /* Function which prints out usage message. */
   void (*help)(void);

   /* Initialize the match. */
   void (*init)(struct ipt_entry_match *m, unsigned int *nfcache);

   /* Function which parses command options; returns true if it
           ate an option */
   int (*parse)(int c, char **argv, int invert, unsigned int *flags,
           const struct ipt_entry *entry,
           unsigned int *nfcache,
           struct ipt_entry_match **match);

   /* Final check; exit if not ok. */
   void (*final_check)(unsigned int flags);

   /* Prints out the match iff non-NULL: put space at end */
   void (*print)(const struct ipt_ip *ip,
            const struct ipt_entry_match *match, int numeric);

   /* Saves the match info in parsable form to stdout. */
   void (*save)(const struct ipt_ip *ip,
           const struct ipt_entry_match *match);

   /* Pointer to list of extra command-line options */
   const struct option *extra_opts;

   /* Ignore these men behind the curtain: */
   unsigned int option_offset;
   struct ipt_entry_match *m;
   unsigned int mflags;
#ifdef NO_SHARED_LIBS
   unsigned int loaded; /* simulate loading so options are merged properly */
#endif
};
</pre>
</td></tr></table>

<A NAME="367lfindex3">&nbsp;</A>
<H2>1.2 Inside the skeleton</H2>

<A NAME="367lfindex4">&nbsp;</A>
<H3>1.2.1 Initialization</H3>


We initialize the common fields in the 'iptables_match' structure.

<pre class="code">static struct iptables_match ipaddr
= {
</pre>

'Name' is the file name string of your library (ie: libipt_ipaddr).<br>
You can't provide another name, it's used for auto-loading your library.

<pre class="code">    .name            = "ipaddr",
</pre>

The next field, 'version', is the iptables's version. Both next are used
to keep corelation between the user-space and kernel-space shared
structure's size.
<pre class="code">    .version         = IPTABLES_VERSION,
    .size            = IPT_ALIGN(sizeof(struct ipt_ipaddr_info)),
    .userspacesize   = IPT_ALIGN(sizeof(struct ipt_ipaddr_info)),
</pre>

'Help' is called when a user enter 'iptables -m module -h'. 'Parse' is
called when you enter a new rule, its duty is to validate the arguments.
In the case of 'print', its called by 'iptables -L' to
show previously enterd rules.

<pre class="code">    .help            = &amp;help,
    .init            = &amp;init,
    .parse           = &amp;parse,
    .final_check     = &amp;final_check,
    .print           = &amp;print,
    .save            = &amp;save,
    .extra_opts      = opts
};
</pre>

The iptables infrastructure can support multiple shared libraries. Each
library must register to iptables by calling 'register_match()', defined
into &lt;<i>iptables/iptables.c</i>&gt;. This function is called when the
module is loaded by iptables.

For more information about it: 'man dlopen'.
<pre class="code">void _init(void)
{
   register_match(&amp;ipaddr);
}
</pre>

<A NAME="367lfindex5">&nbsp;</A>
<H3>1.2.2 save function</H3>


If we have a ruleset that we want to save, iptables provide the tool 'iptables-save' which dumps all your rules.
It obviously needs your extension's help to dump proper rules. This is done by calling this function.

<pre class="code">static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
{
   const struct ipt_ipaddr_info *info = (const struct ipt_ipaddr_info *)match-&gt;data;
</pre>
We print out the source-addresse if it's part of the rule.
<pre class="code">   if (info-&gt;flags &amp; IPADDR_SRC) {
      if (info-&gt;flags &amp; IPADDR_SRC_INV)
         printf("! ");
      printf("--ipsrc ");
      print_ipaddr((u_int32_t *)&amp;info-&gt;ipaddr.src);
   }
</pre>
We print out the destination-adresse if it's part of the rule.
<pre class="code">   if (info-&gt;flags &amp; IPADDR_DST) {
      if (info-&gt;flags &amp; IPADDR_DST_INV)
         printf("! ");
      printf("--ipdst ");
      print_ipaddr((u_int32_t *)&amp;info-&gt;ipaddr.dst);
   }
}
</pre>

<A NAME="367lfindex6">&nbsp;</A>
<H3>1.2.3 print function</H3>

In the same philosophy of the previous one, this function aims to print information about the rule.
It's called by 'iptables -L'. We will see later in this text what's the purpose of 'ipt_entry_match *match', but
you certainly already have a little idea about it.

<pre class="code">static void print(const struct ipt_ip *ip,
                  const struct ipt_entry_match *match,
                  int numeric)
{
   const struct ipt_ipaddr_info *info = (const struct ipt_ipaddr_info *)match-&gt;data;

   if (info-&gt;flags &amp; IPADDR_SRC) {
         printf("src IP ");
      if (info-&gt;flags &amp; IPADDR_SRC_INV)
         printf("! ");
      print_ipaddr((u_int32_t *)&amp;info-&gt;ipaddr.src);
   }

   if (info-&gt;flags &amp; IPADDR_DST) {
      printf("dst IP ");
      if (info-&gt;flags &amp; IPADDR_DST_INV)
         printf("! ");
      print_ipaddr((u_int32_t *)&amp;info-&gt;ipaddr.dst);
   }
}
</pre>

<A NAME="367lfindex7">&nbsp;</A>
<H3>1.2.4 final check function</H3>

This function is a kind of last chance for sanity check. It's called when the user enter a new rule,
right after arguments parsing is done.
<pre class="code">static void final_check(unsigned int flags)
{
   if (!flags)
      exit_error(PARAMETER_PROBLEM, "ipt_ipaddr: Invalid parameters.");
}
</pre>

<A NAME="367lfindex8">&nbsp;</A>
<H3>1.2.5 parse function</H3>

This is the most important function because it's here that we verify if
arguments are used correctly
and set informations we will share with the kernel-part. It is called
each time an argument is found, so if the user provides two arguments, it
will be called twice
with the argument code into the var 'c'.
<pre class="code">static int parse(int c, char **argv, int invert, unsigned int *flags,
                 const struct ipt_entry *entry,
                 unsigned int *nfcache,
                 struct ipt_entry_match **match)
{
</pre>

We use this special structure to keep informations we will share with the kernel-part. 'Match' pointer is passed to a couple
of functions so we can work on the same data structure. Once the rule is loaded, this pointer is copied to the kernel-part.
This way, the kernel module knows what the user asks to analyze (and that's the point, no?).
<pre class="code">   struct ipt_ipaddr_info *info = (struct ipt_ipaddr_info *)(*match)-&gt;data;
</pre>Each arguments correspond to an single value, so we can do
specific actions according to the inputed arguments. We will see later
in this text how we map arguments to values.
<br>
<pre class="code">   switch(c) {
</pre>First, we check if the argument has been used more than once. If
it appears to be the case, we call 'exit_error()' defined in &lt;<i>iptables/iptables.c</i>&gt;,
which will exit immediatly with the status flag 'PARAMETER_PROBLEM' defined in &lt;<i>iptables/include/iptables_common.h</i>&gt;.
Else, we set 'flags' and 'info-&gt;flags' to the 'IPADDR_SRC' value
defined in our header's file. We will see this header's file later.<br><br>
Although both var flags seems to have the same purpose, they really
don't. The scope of 'flags' is only this function, and 'info-&gt;flags'
is a field part of our structure which will be shared with the
kernel-part.
<pre class="code">      case '1':
         if (*flags &amp; IPADDR_SRC)
            exit_error(PARAMETER_PROBLEM, "ipt_ipaddr: Only use --ipsrc once!");
         *flags |= IPADDR_SRC;
         info-&gt;flags |= IPADDR_SRC;
</pre>

We verify if the invert flag, '!',  has been inputed and then set appropriate information into the 'info-&gt;flags'.<br>Next,
we call 'parse_ipaddr', an internal function written for this skeleton,
to convert the ip address string to a 32bits value.<br>

<pre class="code">         if (invert)
            info-&gt;flags |= IPADDR_SRC_INV;

         parse_ipaddr(argv[optind-1], &amp;info-&gt;ipaddr.src);
         break;
</pre>

In the same thought, we check for multiple use and set appropriate flags.
<pre class="code">      case '2':
         if (*flags &amp; IPADDR_DST)
            exit_error(PARAMETER_PROBLEM, "ipt_ipaddr: Only use --ipdst once!");
         *flags |= IPADDR_DST;
         info-&gt;flags |= IPADDR_DST;
         if (invert)
            info-&gt;flags |= IPADDR_DST_INV;

         parse_ipaddr(argv[optind-1], &amp;info-&gt;ipaddr.dst);
         break;

      default:
         return 0;
   }

   return 1;
}
</pre>
<A NAME="367lfindex9">&nbsp;</A>
<H3>1.2.6 options structure</H3>

We have discussed earlier that every arguments are mapped to a single
value. The 'struct option' is the better way to achieve it. For more
information about this structure, I strongly suggest you read 'man 3
getopt'.
<pre class="code">static struct option opts[] = {
   { .name = "ipsrc",   .has_arg = 1,   .flag = 0,   .val = '1' },
   { .name = "ipdst",   .has_arg = 1,   .flag = 0,   .val = '2' },
   { .name = 0 }
};

</pre>
<A NAME="367lfindex10">&nbsp;</A>
<H3>1.2.7 init function</H3>
This init function is used to set some
specific stuff like the netfilter cache system. It's not very important
to know how exactly it works for now.
<pre class="code">static void init(struct ipt_entry_match *m, unsigned int *nfcache)
{
   /* Can't cache this */
   *nfcache |= NFC_UNKNOWN;
}

</pre>
<A NAME="367lfindex11">&nbsp;</A>
<H3>1.2.7 help function</H3>

This function is called by 'iptables -m match_name -h' to show available arguments.
<pre class="code">static void help(void)
{
   printf (
            "IPADDR v%s options:\n"
            "[!] --ipsrc &lt;ip>\t\t The incoming ip addr matches.\n"
            "[!] --ipdst &lt;ip>\t\t The outgoing ip addr matches.\n"
            "\n", IPTABLES_VERSION
         );
}

</pre>
<A NAME="367lfindex12">&nbsp;</A>
<H3>1.2.8 the header's file 'ipt_ipaddr.h'</H3>

It's in this file that we define our stuff that we need.
<pre class="code">#ifndef _IPT_IPADDR_H
#define _IPT_IPADDR_H
</pre>
We have seen earlier that we set flags to some specific values.
<pre class="code">#define IPADDR_SRC   0x01     /* Match source IP addr */
#define IPADDR_DST   0x02     /* Match destination IP addr */

#define IPADDR_SRC_INV  0x10  /* Negate the condition */
#define IPADDR_DST_INV  0x20  /* Negate the condition */
</pre>

The structure 'ipt_ipaddr_info' is the one who will be copied to the kernel-part.
<pre class="code">struct ipt_ipaddr {
   u_int32_t src, dst;
};

struct ipt_ipaddr_info {

   struct ipt_ipaddr ipaddr;

   /* Flags from above */
   u_int8_t flags;

};

#endif
</pre>

<A NAME="367lfindex13">&nbsp;</A>
<H2>1.3 Summary chapter 1</H2>
In the first part, we discussed the purpose of the
iptables library. We covered the internals of each function and how the
main structure 'ipt_ipaddr_info' is used to keep information that will
be copied to the kernel-part for further consideration. We also look at
the iptables structure and how to register our new library.<br>
You should keep in mind that this is only a skeleton example to help me
to show you how the framework is working. Furthermore,
'ipt_ipaddr_info' and things like that are not part of the
iptables/netfilter but part of this example.
<A NAME="367lfindex14">&nbsp;</A>
<H2>2.0 The netfilter module</H2>

The duty of a match module is to inspect each packet received and to
decide if it matches or not according to our criteria. The module has the
following means to do that:

<ul>
  <li>Receive each packet hitting the table related with the match module</li>
  <li>Tell netfilter if our module match the packet</li>
</ul>

<A NAME="367lfindex15">&nbsp;</A>
<H2>2.1 Structures and Functions available</H2>

At first some basic structures. This structure is defined in &lt;<i>linux/netfilter_ipv4/ip_tables.h</i>&gt;.

<br> If you are interested in learning more about this structure and
the previous one presented for iptables, you should look at the <a href="http://www.netfilter.org/documentation/HOWTO/netfilter-hacking-HOWTO.html">netfilter hacking howto</a> written by Rusty Russell and Harald Welte.

<pre class="code">struct ipt_match
{
   struct list_head list;

   const char name[IPT_FUNCTION_MAXNAMELEN];

   /* Return true or false: return FALSE and set *hotdrop = 1 to
           force immediate packet drop. */
   /* Arguments changed since 2.4, as this must now handle
           non-linear skbs, using skb_copy_bits and
           skb_ip_make_writable. */
   int (*match)(const struct sk_buff *skb,
           const struct net_device *in,
           const struct net_device *out,
           const void *matchinfo,
           int offset,
           int *hotdrop);

   /* Called when user tries to insert an entry of this type. */
   /* Should return true or false. */
   int (*checkentry)(const char *tablename,
           const struct ipt_ip *ip,
           void *matchinfo,
           unsigned int matchinfosize,
           unsigned int hook_mask);

   /* Called when entry of this type deleted. */
   void (*destroy)(void *matchinfo, unsigned int matchinfosize);

   /* Set this to THIS_MODULE. */
   struct module *me;
};
</pre>


<A NAME="367lfindex16">&nbsp;</A>
<H2>2.2 Inside the skeleton</H2>

<A NAME="367lfindex17">&nbsp;</A>
<H3>2.2.1 Initialization</H3>


<p>

We initialize the common fields in the 'ipt_match' structure.


</p><pre class="code">static struct ipt_match ipaddr_match
= {
</pre>
'Name' is the file name string of your module (ie: ipt_ipaddr).
<pre class="code">	.name       = "ipaddr",
</pre>

Next fields are callbacks that the framework will use. 'Match' is called when a packet is passed to your module.
<pre class="code">	.match      = match,
	.checkentry = checkentry,
	.me         = THIS_MODULE,
};
</pre>

Your kernel module's init function needs to call 'ipt_register_match()' with a pointer to a 'struct ipt_match' to register
against the netfilter framework. This function is called on module loading.
<pre class="code">static int __init init(void)
{
	printk(KERN_INFO "ipt_ipaddr: init!\n");
	return ipt_register_match(&amp;ipaddr_match);
}
</pre>

When unloading the module this function is called. It's here that we unregister our match.
<pre class="code">static void __exit fini(void)
{
	printk(KERN_INFO "ipt_ipaddr: exit!\n");
	ipt_unregister_match(&amp;ipaddr_match);
}
</pre>

We hand them functions that will be called at the loading and unloading of the module.
<pre class="code">module_init(init);
module_exit(fini);

</pre>

<A NAME="367lfindex18">&nbsp;</A>
<H3>2.2.2 match function</H3>

The linux tcp/ip stack is sprink of five netfilter's hooks. Thus when a packet
walks in, the stack passes the packet to the appropriate hook which iterates
through each table which iterates through each rules. When it's the
time to your module to have the packet, it can finally do its job.
<pre class="code">static int match(const struct sk_buff *skb,
                 const struct net_device *in,
                 const struct net_device *out,
                 const void *matchinfo,
                 int offset,
                 const void *hdr,
                 u_int16_t datalen,
                 int *hotdrop)
{
</pre>
Hope you remember what we did in the user-part ! :). Now we map the user-space's copied structure into our own one.
<pre class="code">	const struct ipt_skeleton_info *info = matchinfo;
</pre>
The 'skb' contains the packet we want to look at. For more information
about this powerfull structure used everywhere in the linux tcp/ip
stack, Harald Welte wrote an excellent <a href="ftp://ftp.gnumonks.org/pub/doc/skb-doc.html">article (ftp://ftp.gnumonks.org/pub/doc/skb-doc.html)</a> about it.
<pre class="code">   struct iphdr *iph = skb-&gt;nh.iph;
</pre>
Here, we are just printing some funny stuff to see what they look like.
The macro 'NIPQUAD' is used to display an ip address in readable
format, defined in &lt;<i>linux/include/linux/kernel.h</i>&gt;.
<pre class="code">   printk(KERN_INFO "ipt_ipaddr: IN=%s OUT=%s TOS=0x%02X "
                    "TTL=%x SRC=%u.%u.%u.%u DST=%u.%u.%u.%u "
                    "ID=%u IPSRC=%u.%u.%u.%u IPDST=%u.%u.%u.%u\n",

                    in ? (char *)in : "", out ? (char *)out : "", iph-&gt;tos,
                    iph-&gt;ttl, NIPQUAD(iph-&gt;saddr), NIPQUAD(iph-&gt;daddr),
                    ntohs(iph-&gt;id), NIPQUAD(info-&gt;ipaddr.src), NIPQUAD(info-&gt;ipaddr.dst)
         );
</pre>
If the '--ipsrc' argument has been inputed we look if the source
address match with the one specified in the rule. We don't forget to
take in consideration the invert flag: '!'. If we don't match: we
return the verdict; 0.
<pre class="code">   if (info-&gt;flags &amp; IPADDR_SRC) {
      if ( (ntohl(iph-&gt;saddr) != ntohl(info-&gt;ipaddr.src)) ^ !!(info-&gt;flags &amp; IPADDR_SRC_INV) ) {

         printk(KERN_NOTICE "src IP %u.%u.%u.%u is not matching %s.\n",
                            NIPQUAD(info-&gt;ipaddr.src),
                            info-&gt;flags &amp; IPADDR_SRC_INV ? " (INV)" : "");
         return 0;
      }
   }
</pre>
Here, we do the same, except that we look for the destination address if '--ipdst' has been inputed.
<pre class="code">   if (info-&gt;flags &amp; IPADDR_DST) {
      if ( (ntohl(iph-&gt;daddr) != ntohl(info-&gt;ipaddr.dst)) ^ !!(info-&gt;flags &amp; IPADDR_DST_INV) )  {

         printk(KERN_NOTICE "dst IP %u.%u.%u.%u is not matching%s.\n",
                            NIPQUAD(info-&gt;ipaddr.dst),
                            info-&gt;flags &amp; IPADDR_DST_INV ? " (INV)" : "");
         return 0;
      }
   }
</pre>
If both failed, we return the verdict 1, which means we matched the packet.
<pre class="code">   return 1;
}
</pre>


<A NAME="367lfindex19">&nbsp;</A>
<H3>2.2.3 checkentry function</H3>

Checkentry is most of the time used as a last chance for sanity check.
It's a bit hard to understand when it's called. For explanation, see this <a href="http://www.mail-archive.com/netfilter-devel@lists.samba.org/msg00625.html">post (http://www.mail-archive.com/netfilter-devel@lists.samba.org/msg00625.html)</a>. This is also explained in the netfilter hacking howto.

<pre class="code">static int checkentry(const char *tablename,
                             const struct ipt_ip *ip,
                             void *matchinfo,
                             unsigned int matchsize,
                             unsigned int hook_mask)
{
   const struct ipt_skeleton_info *info = matchinfo;

   if (matchsize != IPT_ALIGN(sizeof(struct ipt_skeleton_info))) {
      printk(KERN_ERR "ipt_skeleton: matchsize differ, you may have forgotten to recompile me.\n");
      return 0;
   }

   printk(KERN_INFO "ipt_skeleton: Registered in the %s table, hook=%x, proto=%u\n",
                    tablename, hook_mask, ip-&gt;proto);

   return 1;
}

</pre>
<A NAME="367lfindex20">&nbsp;</A>
<H2>2.3 Summary chapter 2</H2>
In this second part, we covered the netfilter's
module and how to register it by using a specific structure. In
addition, we discussed how to match a specific situation according to
criteria provided by the user-space part.
<A NAME="367lfindex21">&nbsp;</A>
<H2>3.0 Playing with iptables/netfilter</H2>
We have seen how to write
a new iptables/netfilter's match module. Now, we would like to add it
in our kernel to play with it. Here, I assume that you know how to
build/compile a kernel. First, get the skeletons's match files from <a href="../../common/src2/article367/index.html">the download page for this article</a>.

<A NAME="367lfindex22">&nbsp;</A>
<H3>3.1 iptables</H3>

Now, if you don't have the source of iptables you can download it <a href="ftp://ftp.netfilter.org/pub/iptables/">ftp://ftp.netfilter.org/pub/iptables/</a>. Then you have to copy 'libipt_ipaddr.c' into &lt;<i>iptables/extensions/</i>&gt;.<br><br>

This is a line from &lt;<i>iptables/extensions/Makefile</i>&gt; in which you have to add 'ipaddr'.
<pre class="code">
PF_EXT_SLIB:=ah addrtype comment connlimit connmark conntrack dscp ecn
esp hashlimit helper icmp iprange length limit <b>ipaddr</b> mac mark
multiport owner physdev pkttype realm rpc sctp standard state tcp tcpmss
tos ttl udp unclean CLASSIFY CONNMARK DNAT DSCP ECN LOG MARK MASQUERADE
MIRROR NETMAP NOTRACK REDIRECT REJECT SAME SNAT TARPIT TCPMSS TOS TRACE
TTL ULOG
</pre>

<A NAME="367lfindex23">&nbsp;</A>
<H3>3.2 kernel</H3>


First, you have to copy 'ipt_ipaddr.c' in &lt;<i>linux/net/ipv4/netfilter/</i>&gt; and 'ipt_ipaddr.h' into &lt;<i>linux/include/linux/netfilter_ipv4/</i>&gt;. Some of you are still using linux 2.4, so I'll present both 2.4 and 2.6 files to edit.<br><br>

For 2.4, edit &lt;<i>linux/net/ipv4/netfilter/Config.in</i>&gt; and add the bold line.
<pre class="code"># The simple matches.
  dep_tristate '  limit match support' CONFIG_IP_NF_MATCH_LIMIT $CONFIG_IP_NF_IPTABLES
<b>  dep_tristate '  ipaddr match support' CONFIG_IP_NF_MATCH_IPADDR $CONFIG_IP_NF_IPTABLES</b>
</pre>

Then, edit &lt;<i>linux/Documentation/Configure.help</i>&gt; and add the text in bold. I copied some text to help you find where you add yours.
<pre class="code">limit match support
CONFIG_IP_NF_MATCH_LIMIT
  limit matching allows you to control the rate at which a rule can be
  ...<b>
ipaddr match support
CONFIG_IP_NF_MATCH_IPADDR
  ipaddr matching. etc etc.</b>
</pre>

Finally, you have to add this bold line into &lt;<i>linux/net/ipv4/netfilter/Makefile</i>&gt;.
<pre class="code"># matches
obj-$(CONFIG_IP_NF_MATCH_HELPER) += ipt_helper.o
obj-$(CONFIG_IP_NF_MATCH_LIMIT) += ipt_limit.o
<b>obj-$(CONFIG_IP_NF_MATCH_IPADDR) += ipt_ipaddr.o</b>
</pre>

Now for 2.6, files to edit are &lt;<i>linux/net/ipv4/netfilter/Kconfig</i>&gt; and  &lt;<i>linux/net/ipv4/netfilter/Makefile</i>&gt;.

<A NAME="367lfindex24">&nbsp;</A>
<H2> Conclusion </H2>


It just remains you to recompile and add what I forgot to tell you.<br>
Happy hacking!!

<br>
Thanks to Samuel Jean.


<!-- BODY_OF_THE_ARTICLE_STOP -->
<!-- 2pdaIgnoreStart -->
<A NAME="talkback">&nbsp;</a>
<h2>Talkback form for this article</h2>
Every article has its own talkback page. On this page you can submit a comment or look at comments from other readers:
<center>
    <table width="250" border=0><tr><td>
    <div class="tbbutton"><A class="nodec" href="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=367">&nbsp;talkback page&nbsp;</a></div>
    </td></tr></table>
</center>

<br clear="all">
<HR size="2" noshade>
<table width="250" border=0><tr><td>
<div class="bbutton"><a class="nodec" href="../../index.shtml">&lt;--, LF Home</a></div>
</td><td>
<div class="bbutton"><a class="nodec" href="index.shtml">Go to the index of this issue</a></div>
</td></tr></table>
<br clear="all">
<HR size="2" noshade>
<!-- ARTICLE FOOT -->
<CENTER><TABLE WIDTH="98%" summary="footer">
<TR><TD ALIGN=CENTER BGCOLOR="#bdc6d5" WIDTH="50%">
<A HREF="../../common/lfteam.html">Webpages maintained by the LinuxFocus Editor team</A>
<BR><FONT COLOR="#1111aa"><a href="../../common/copy.html">&copy; Nicolas Bouliane</a><br>&quot;some rights reserved&quot; see <a href="../../license/index.shtml">linuxfocus.org/license/</a><br><a href="http://www.linuxfocus.org">http://www.LinuxFocus.org</a></FONT>
</TD>
<TD BGCOLOR="#bdc6d5">
<!-- TRANSLATION INFO -->
<font size=2>Translation information:</font>
<TABLE summary="translators">
  <tr><td><font size="2">en --&gt; -- : Nicolas Bouliane <small>&lt;nib(at)cookinglinux!org&gt;</small></font></td></tr>
</TABLE>
</TD>
</TR></TABLE></CENTER>
<p><font size=1>2005-07-21, generated by lfparser version 2.52</font></p>
<!-- 2pdaIgnoreStop -->
</BODY>
</HTML>
