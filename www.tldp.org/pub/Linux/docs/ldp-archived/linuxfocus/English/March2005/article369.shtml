<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
 <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <META NAME="GENERATOR" CONTENT="lfparser_2.52">
 <META NAME="LFCATEGORY" CONTENT="Hardware">
 <link rel="icon" href="../../common/images/lf-16.png" type="image/png">
 <TITLE>lf369, Hardware: Part 2 -- A digital thermometer or talk I2C to your atmel microcontroller</TITLE>
<style type="text/css">
<!--
 td.top {font-family: Arial,Geneva,Verdana,Helvetica,sans-serif; font-size:12 }
 pre { font-family:monospace,Courier }
 pre.code { font-family:monospace,Courier;background-color:#aedbe8; }
 p.cl { color:#EE9500 }
 table.left { margin-right:0.3cm }
 a.nodec { text-decoration:none }
 p.trans { font-size:8pt; text-align:right }
 p.clbox { width:50%; alignment:center; background-color:#FFD700; 
           border-style:none; border-width:medium; border-color:#FFD700; 
           padding:0.5cm;  text-align:center }
 p.code { width:80%; alignment:center; background-color:#aedbe8; 
          border-style:none; border-width:medium; border-color:#aedbe8; 
          padding:0.1cm;  text-align:left }
 p.foot { background-color:#AAAAAA; color:#FFFFFF; border-style:none; 
          border-width:medium; border-color:#AAAAAA; padding:0.5cm ; 
          margin-top:0.1cm; margin-right:1cm; margin-left:1cm; 
          text-align:center }
 div.tbbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   margin: 2px 5px 2px 5px;
   text-align: center;
   width: 20em;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
 div.bbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   float: left;
   margin: 2px 5px 2px 5px;
   text-align: center;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
-->
</style>
 
</HEAD>
<BODY bgcolor="#ffffff" text="#000000">
 <!-- this is generated html code. NEVER use this file for your
 translation work. Instead get the file with the same article number
 and .meta.shtml in its name. Translate this meta file and then
 use lfparser program to generate the final article -->
 <!-- lfparser can be obtained from http://main.linuxfocus.org/~guido/dev/lfparser.html -->

<!-- this is used by a number of tools:
 =LF=AUTHOR: Guido     Socher
 =LF=CAT___: Hardware
 =LF=TITLE_: Part 2 -- A digital thermometer or talk I2C to your atmel microcontroller
 =LF=NUMBER: 369
 =LF=ANAME_: article369.shtml
 =LF=PARSER: 2.52
 -->

<!-- 2pdaIgnoreStart -->

<!-- start navegation bar, current, style=2 -->
 <!-- top navegation bar -->
 <TABLE summary="topbar_1" cellspacing="0" cellpadding="0" border="0" align="center" width="90%">
   <TR bgcolor="#2e2292">
     <TD class="top"><TABLE summary="topbar_1_logo" cellspacing="0" cellpadding="0" border="0" width=
       "100%">
         <TR><TD width="319"><a href="../../index.shtml"><IMG src="../../common/images/logolftop_319x45.gif"
           alt="[LinuxFocus-icon]" width="319" height="45" align="left" 
           border="0"></a></TD>

           <TD class="top">
             <TABLE summary="topbar_1_links" width="100%">
               <TR align="right">
                 <TD class="top">
                 
                 <A class="nodec" href="../../index.shtml"><FONT color=
                 "#DDDDDD" size="2">&lt;--</FONT></A> &nbsp;| 
                 <A class="nodec" href="../map.html"><FONT color=
                 "#DDDDDD" size="2">Map</FONT></A> &nbsp;| 
                 <A class="nodec" href="../indice.html"><FONT color=
                 "#DDDDDD" size="2">Index</FONT></A> &nbsp;| 
                 <A class="nodec" href="../Search/index.html"><FONT color=
                 "#DDDDDD" size="2">Search</FONT></A> </TD>
                 
               </TR>

               <TR align="right">
                 <TD class="top">
                   <HR width="100%" noshade size="1">
                 </TD>
               </TR>
             </TABLE>
           </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end top navegation bar -->
 <!-- blue bar -->
 <TABLE summary="topbar_2" cellspacing="0" cellpadding="0" border="0" align="center"
 width="90%">
   <TR bgcolor="#00ffff">
     <TD><IMG src="../../common/images/transpix.gif" width="1" height=
     "2" alt=""></TD>
   </TR>
 </TABLE>
 <!-- end blue bar -->
 <!-- bottom navegation bar -->
 <TABLE summary="topbar_3" cellspacing="0" cellpadding="0" border="0" align="center"
 width="94%">
   <TR bgcolor="#000000">
     <TD>
       <TABLE summary="topbar_3_links" cellspacing="0" cellpadding="1" border="0" width=
       "100%">
         <TR align="center">
           <TD WIDTH="20%"><A class="nodec" href="../News/index.html"><FONT color=
           "#FFFFFF">News</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Archives/index.html"><FONT color=
           "#FFFFFF">Archives</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Links/index.html"><FONT color=
           "#FFFFFF">Links</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../aboutus.html"><FONT color=
           "#FFFFFF">About LF</FONT></A> </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end bottom navegation bar -->
<!-- stop navegation bar -->

<!-- SSI_INFO -->

<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfdynahead ver 1.5 --><TABLE ALIGN="right" border=0><TR><TD ALIGN="right"><FONT SIZE="-1" FACE="Arial,Helvetica">This document is available in: <A href="../../English/March2005/article369.shtml">English</a> &nbsp;<A href="../../ChineseGB/March2005/article369.shtml">ChineseGB</a> &nbsp;<A href="../../Deutsch/March2005/article369.shtml">Deutsch</a> &nbsp;<A href="../../Francais/March2005/article369.shtml">Francais</a> &nbsp;</FONT></TD></TR></TABLE><br>
 


<!-- SSI_INFO STOP -->
<!-- 2pdaIgnoreStop -->

<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_START -->
<TABLE ALIGN="LEFT" BORDER="0" WIDTH="195" summary="about the author" class="left">
<TR>
<TD>

<img src="../../common/images/Guido-S.gif" alt=
    "[Photo of the Author]" height="164" width="173">
<BR>by  Guido Socher <a href="http://linuxfocus.org/~guido/"><font size="1">(homepage)</font></a>
<BR><BR>
<I>About the author:</I><BR>
<!-- aboutauthor_start -->
<p>Guido likes Linux because it is a really good system to
    develop your own hardware.</p>
<!-- aboutauthor_stop -->
<!-- TRANSLATED_TO en -->
<!-- TRANSLATED_TO_STOP -->
<!-- INDEX_START -->
<BR><i>Content</i>:
<UL>
  <LI><A HREF="#369lfindex0">The new things</A></LI>
  <LI><A HREF="#369lfindex1">The LCD display</A></LI>
  <LI><A HREF="#369lfindex2">A little GUI</A></LI>
  <LI><A HREF="#369lfindex3">How it works: Analog to digital conversion</A></LI>
  <LI><A HREF="#369lfindex4">How it works: I2C communication, Atmega8 part</A></LI>
  <LI><A HREF="#369lfindex5">How it works: I2C communication, Linux side</A></LI>
  <LI><A HREF="#369lfindex6">USB to RS232</A></LI>
  <LI><A HREF="#369lfindex7">Conclusion</A></LI>
  <LI><A HREF="#369lfindex8">References</A></LI>
  <LI><A HREF="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=369">Talkback form for this article</A></LI>
</UL>

</TD></TR></TABLE>
<!-- INDEX_STOP -->
<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_STOP -->
<!-- HEAD_OF_THE_ARTICLE_START -->
<br>&nbsp;
<table border="0"><tr><td>
<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfPdf ver 0.1 -->
<TABLE style="border-style:outset; border-width:1px" align="right" bgcolor="#ff9616" cellspacing="1"><TR><TD bgcolor="#ff9616">
        <a href="../Archives/lf-2005_03-0369.pdf"><small>PDF</small></a>
        </TD></TR></TABLE>
         

<H2>Part 2 -- A digital thermometer or talk I2C to your atmel microcontroller</H2>
 <img src="../../common/images2/article369/title_369.jpg" alt="[Illustration]" hspace="10" width="320" height="205">
<!-- ABSTRACT OF THE ARTICLE -->
<P><i>Abstract</i>:
<P>
<!-- articleabstract_start -->

In this second part of the article we will connect a LCD display
and I will explain how the software works.
<br><br>
Those readers who are new to this series should first read
<a href="../February2005/article365.shtml">the first part (February2005
article365)</a>.

    
<!-- articleabstract_stop -->

<br><!-- HR divider --><center><font color="#8282e0"><b>_________________ _________________ _________________</b></font></center><br>
</td></tr></table>
<!-- HEAD_OF_THE_ARTICLE_STOP -->
<!-- BODY_OF_THE_ARTICLE_START -->


    <A NAME="369lfindex0">&nbsp;</A>
<H2>The new things</H2>

In the
<a href="../February2005/article365.shtml">previouse article
</a> we build already most of the hardware and the main functionality
for temperature measurement and transmission of the data to a Linux
PC. In this article a LCD display and a very simple gtk GUI will be
added. <br>
<br>
Adding these two things is very easy to do. I will therefore spend the rest of the article
to explain how the I2C software and the analog to digital converter
works.

    <A NAME="369lfindex1">&nbsp;</A>
<H2>The LCD display</H2>

For the LCD display we use a HD44780 compatible display as it was
already used in previous articles. These displays are very easy to use
in combination with microcontrollers because you can send them
ASCII characters.


<br>
<center>
<img src="../../common/images2/article369/lcd_linux.gif" alt="HD44780 compatible LCD display" width="250" height="103">
</center>
<br>
As for all articles in this series you can again get all the parts
including the LCD display at <a
href="http://shop.tuxgraphics.org">shop.tuxgraphics.org</a>
<br>
I use the same LCD driver code as in all previous articles. The files
which implement this LCD driver are lcd.c lcd.h and lcd_hw.h. They are
in the package which you can download at the end of this article.
The interface for this code is really easy to use:

<pre class="code">
// call this once:
// initialize LCD display, cursor off
lcd_init(LCD_DISP_ON);

// to write some text we first clear
// the display:
lcd_clrscr();
lcd_puts("Hello");
// go to the second line:
lcd_gotoxy(0,1);
lcd_puts("LCD");
</pre>
How those HD44780 displays work is described in
<a href="../September2002/article258.shtml">the linuxfocus
September2002 article "Understanding HD44780 compatible LCD-displays"</a>

<br>
<br>
The software is written such that it works with both 16x2 and 20x2 LCD displays.
<br>
<br>
<img src="../../common/images2/article369/boardchange_th.jpg" alt="board change" align="right"  width="220" height="214">
There is also an update to the circuit diagram. I discovered that some LCD
displays
have a higher capacitive load and lower resistance than others. This is probably
because they have a better ESD protection. This additional load can possibly cause
bit errors during the In Circuit Programming when the LCD display is connected to the SCK and MOSI pins.
<br><br>As a first solution I tried to connect additional resistors into the
lines to the LCD display. This worked for me but some people, especially laptop
users still had problems. <br><br>
To avoid this problem all together I updated the circuit diagram and
the D7 and RS pins of the LCD display are now connected to PD7 and PD6.
It is not a problem to change this even if you have made the board already.
Just add a little wire under the board and cut the connection to PB3 with a
knife.
<br clear="all">
<br>
<center>
<a
href="../../common/images2/article369/i2ctemp_newlcdconection.gif"><img src="../../common/images2/article369/i2ctemp_newlcdconection_th.gif" alt="Circuit diagram"  width="590" height="432"></a>
</center>
<br>
    <A NAME="369lfindex2">&nbsp;</A>
<H2>A little GUI</H2>

For those wo would like to have GUI on their desktop I made a really simple gui. It consists just of 2 labels which
are used to display the two line output of i2ctemp_linux command (the
i2ctemp_linux is the command which read the temperatures from the circuit via
I2C):
<br>
<center>
<img src="../../common/images2/article369/guiscreenshot.gif" alt="GUI" width="83" height="80">
</center>
<br>
Now we have a really cool thermometer. With a lot of possibilities:
<ul>
<li>You can read the temperature locally from the display
<li>You can have a little GUI on your desktop
<li>You can write values with a cronjob to a log file to get long term
statistics
</ul>
I will now use the rest of this ariticle to explain a bit the internals
of the software.
<A NAME="369lfindex3">&nbsp;</A>
<H2>How it works: Analog to digital conversion</H2>

The Atmega8 supports two modes. One where it permanently measures the analog
signals and
just triggers an interrupt when the measurement is ready. The application
software can then use this interrupt to quickly copy the result from
two registers into a variable.
<br>
<br>
The other mode is the so called single shot mode. Here only one conversion
is done. The single shot mode is still pretty fast. Including the setup time of the required
registers before and the reading out you can still get 100 conversion per
second. This is more than fast enough for us. So we use this mode.
<br>
<br>
On our Atmega8 we can use the analog input pins ADC0 to ADC3. In addition to
this there are the pins AGND (analog ground, connected to normal ground),
AREF (the reference voltage) and AVCC (connected to +5V).
<br>
<br>During analog to digital conversion the analog signal is compared with
AREF. An analog signal  equal to AREF corresponds to a digital
value of 1023. AREF can be any external reference between 0 and 5V.
Without the use of an external reference you can still do precise conversion
by either using an internal reference (2.56V) or AVCC. What is used is decided
in the software via the REFS0 and REFS1 bits in the ADMUX register.
<br>
<br>
The analog to digital converter can convert one of the input lines ADC0-ADC3 at
a time. Before you start conversion you have to set bits in the ADMUX register
to tell the chip which channel to use.
<br>
<br>
A simple analog to digital conversion would then look like this:
<pre class="code">
volatile static int analog_result;
volatile static unsigned char analog_busy;

analog_busy=1; // busy mark the ADC function
channel=0; // measure ADC0
// use internal 2.56V ref
outp((1&lt;&lt;REFS1)|(1&lt;&lt;REFS0)|(channel &amp; 0x07),ADMUX);
outp((1&lt;&lt;ADEN)|(1&lt;&lt;ADIE)|(1&lt;&lt;ADIF)|(1&lt;&lt;ADPS2),ADCSR);
sbi(ADCSR,ADSC); // start conversion
</pre>
Now the microcontroller will do the analog to digital conversion and
call the function SIGNAL(SIG_ADC) once it is ready. In this function we
can copy the result to a variable. As a programmer you must watch out
that you read the lower 8 bits first as the microcontroller has some locking
mechanism to simulate "atomic" reading.
<pre class="code">
SIGNAL(SIG_ADC) {
        unsigned char adlow,adhigh;
        adlow=inp(ADCL); /* read low first, two lines. Do not combine
                          the two lines into one C statement */
        adhigh=inp(ADCH);
        analog_result=(adhigh&lt;&lt;8)|(adlow &amp; 0xFF);
        analog_busy=0;
}
</pre>

After this we have the analog to digital conversion result available as
a number in the analog_result variable. This can the be used elsewhere in the
program. Very easy.
<br>
<br>
As for all interrupts you need to call sei(); to globally enable them. This
should be done somewhere in the main program (not shown above).
<br>
<br>
There were a lot if bits and flags which I will shorty explain:
<ul>
<li>ADEN: Analog Digital Converter Enable, set this before setting ADSC<br><br>
<li>ADIE: Enable ADC Interrupt (=enable calling of SIGNAL(SIG_ADC))<br><br>
<li>ADIF: ADC Interrupt Flag (must be set to 1 before conversion)<br><br>
<li>ADPS: ADC clock pre-scaler bits:
must be set such that the clock frequency divided by the
pre-scale factor is a value between 50 and 200 KHz.
The division factor is 2^ADPS (two to the power of the ADPS bits value).
The above setting (ADPS2=1, ADPS1=0, ADPS0=0 = decimal 4 -&gt; 2^4 = 16 -&gt; division factor = 16) is good for a clock frequency of
1MHz.<br><br>
</UL>

The Atmega8 has several possibilities for reference voltage selection. The
reference voltage is compared against our analog input voltage.
It is the voltage that corresponds to a digital value of 1023.
<table width="400" border=2>
<tr>
<td>REFS0=0, REFS1=0</td><td>use external AREF, Internal Vref turned off</td>
</tr><tr>
<td>REFS0=0, REFS1=1</td><td>AVCC with optional external capacitor at AREF pin</td>
</tr><tr>
<td>REFS0=1, REFS1=1</td><td>Internal 2.56V Voltage Reference with (optional)
external capacitor at AREF pin</td>
</tr></table>
An optional capacitor on the AREF pin can be used to suppress noise and
stabilize the AREF voltage.
<br>
<br>
<A NAME="369lfindex4">&nbsp;</A>
<H2>How it works: I2C communication, Atmega8 part</H2>

I explained already in the part 1 <a
href="../February2005/article365.shtml">(February2005 article365)</a>
how this I2C protocol works. Let's now have a look at the software.
The Atmega8 has hardware support for I2C communication. Therefore you do
not actually need to implement the protocol. Instead you need to implement a
state machine. This tells the Atmega8 what to do next. Here is an example:
<br><br>
An I2C packet with our own slave address was received.
The Atmega8 will now call the function SIGNAL(SIG_2WIRE_SERIAL) with
the status code 0x60 (for other events we would get other codes).<br>
<br>
--&gt; We must now set a number of registers to tell the Atmega8 what to do next.
In this case we will tell it: receive the data part and acknowledge it.
<br><br>
When the actual data was received we will get called with status code 0x80.
<br>
<br>
--&gt; Now we read the databyte and tell the Atmega8 to acknowledge the next data byte
if it comes.
<br>
<br>
When the communication is over we get a status code 0xA0 (stop condition) and we
can tell our application  that a complete message was received.
<br>
<br>
The whole state machine for the I2C slave mode and all possible states are explained
in the datasheet
of the Atmega8 on page 183 (see link in reference section at the end of the
article).
<br>
<br>
Transmitting data is very similar. Have a look at the code!

<A NAME="369lfindex5">&nbsp;</A>
<H2>How it works: I2C communication, Linux side</H2>

<img src="../../common/images2/article369/input.gif" alt="i2c input stage" align="right" width="256" height="117">
First a word about the hardware. Even though I2C is a bus we only use
a point to point connection between one slave and the Linux PC as I2C master.
We can therefore save the pullup resistor as long as the slave can still
pull down the line without causing a short circuit. We just put a 4.7K resistor
into the line.<br>
<br>
 The voltage levels
must be adjusted. This done with the Z-diode limiting the negative voltages
to -0.7V and the positive voltages to max +5.1.
<br>
<br>
After reading more about the internals of the Atmeag8 I came meanwhile
to the conclusion that the internal protection of the input stages of the
Atmeag8 is probably sufficient because the currents through the 4.7K resistor
are very low. We don't actually need the Z-diode.
 It does however not harm to have the Z-diode.

<br>
<br>
The Linux I2C software implements basically a complete I2C stack. This is
because I wanted to have a little command line utility which does not
need any special library or kernel module. It should just work on its own.
<br>
<br>
If you look into the file i2c_m.c (see download) you can see that really every
I2C message is build bit by bit.
<br>
<br>
To generate the "bits" we must toggle the physical pins on the rc232 interface.
This is done with ioctl calls:
<pre class="code">
        // set RTS pin:
        int arg=TIOCM_RTS;
        ioctl(fd, TIOCMBIS, &amp;arg);
</pre>
... or to produce a zero:
<pre class="code">
        // clear RTS pin:
        int arg=TIOCM_RTS;
        ioctl(fd, TIOCMBIC, &amp;arg);
</pre>
If you want to port this stack to a different OS then you just change these
lines. The rest is plain C.

<A NAME="369lfindex6">&nbsp;</A>
<H2>USB to RS232</H2>

For laptops which do these days not have a rs232 interface you can simply use
USB to rs232 adapter. I use e.g a no-name adapter which contains a Prolific 2303
chip.
The adapter which I have looks like this in the /proc/bus/usb/devices file:
Vendor=067b ProdID=2303 Rev= 2.02. See also <a
href="../../English/November2001/article223.shtml">"Use your ATEN
UC-232A USB adapter with Linux (Linuxfocus, November 2001, article 223)"</a>.


<A NAME="369lfindex7">&nbsp;</A>
<H2>Conclusion</H2>

<img src="../../common/images2/article369/mountoutdoorsensor.jpg" alt="mount the sensor" align="right" width="300" height="176">
I am now using the thermometer for 2 month and I really like it because you can
read it out directly on the display and you have the possibility to store all
the data on your PC. You can view it there, draw graphs do statistics. Really
cool. <br>
<br>
The outdoor sensor must be protected properly against rain (and sun). You can
try to wrap it into some plastic but I don't recommend this. No matter how
tight you tie it, water will eventually come in and stay in there. The NTC is quite robust and it
does not matter if it gets a bit humid as long as it can dry again.
Use a up-side down mounted tablet tube which you leave open at the bottom.
This way water will be able to get out again.

<br clear="all">
<br>

<br>
<center>
<img src="../../common/images2/article369/lcd_i2c_linux_temp.jpg" alt="the thermometer" width="450" height="338">
</center>
<br>
<br>You can again order all parts (LCD display, PCB, microcontroller, ...) from
the tuxgraphics online shop: <a
href="http://shop.tuxgraphics.org">shop.tuxgraphics.org</a>. <br>
Have fun!

    <A NAME="369lfindex8">&nbsp;</A>
<H2>References</H2>


    <ul>
      <li><b>Download</b> page for this article: <a href="../../common/src2/article369/index.html">the linuxI2Ctemp_lcd software,
      diagrams, software updates</a></li>

      <li>How to program the atmega8 with gcc: <a href=
      "../November2004/article352.shtml">November2004 article
      352</a></li>

      <li>Datasheet for the Atmega8: go to http://www.atmel.com/
      and select products-&gt;Microcontrollers -&gt;AVR-8 bit
      RISC-&gt;Documentation-&gt;datasheets <br><a href=
      "../../common/src2/article365/atmega8.pdf">(local copy, pdf,
      2479982 bytes)</a></li>

    </ul>
    <!-- vim: set sw=2 ts=2 et tw=80: -->
  



<!-- BODY_OF_THE_ARTICLE_STOP -->
<!-- 2pdaIgnoreStart -->
<A NAME="talkback">&nbsp;</a>
<h2>Talkback form for this article</h2>
Every article has its own talkback page. On this page you can submit a comment or look at comments from other readers:
<center>
    <table width="250" border=0><tr><td>
    <div class="tbbutton"><A class="nodec" href="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=369">&nbsp;talkback page&nbsp;</a></div>
    </td></tr></table>
</center>

<br clear="all">
<HR size="2" noshade>
<table width="250" border=0><tr><td>
<div class="bbutton"><a class="nodec" href="../../index.shtml">&lt;--, LF Home</a></div>
</td><td>
<div class="bbutton"><a class="nodec" href="index.shtml">Go to the index of this issue</a></div>
</td></tr></table>
<br clear="all">
<HR size="2" noshade>
<!-- ARTICLE FOOT -->
<CENTER><TABLE WIDTH="98%" summary="footer">
<TR><TD ALIGN=CENTER BGCOLOR="#bdc6d5" WIDTH="50%">
<A HREF="../../common/lfteam.html">Webpages maintained by the LinuxFocus Editor team</A>
<BR><FONT COLOR="#1111aa"><a href="../../common/copy.html">&copy; Guido     Socher</a><br>&quot;some rights reserved&quot; see <a href="../../license/index.shtml">linuxfocus.org/license/</a><br><a href="http://www.linuxfocus.org">http://www.LinuxFocus.org</a></FONT>
</TD>
<TD BGCOLOR="#bdc6d5">
<!-- TRANSLATION INFO -->
<font size=2>Translation information:</font>
<TABLE summary="translators">
  <tr><td><font size="2">en --&gt; -- : Guido Socher (<a href="http://linuxfocus.org/~guido/"><font size="1">homepage</font></a>)</font></td></tr>
</TABLE>
</TD>
</TR></TABLE></CENTER>
<p><font size=1>2005-02-28, generated by lfparser version 2.52</font></p>
<!-- 2pdaIgnoreStop -->
</BODY>
</HTML>
