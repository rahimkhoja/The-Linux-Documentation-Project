<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
 <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <META NAME="GENERATOR" CONTENT="lfparser_2.52">
 <META NAME="LFCATEGORY" CONTENT="Hardware">
 <link rel="icon" href="../../common/images/lf-16.png" type="image/png">
 <TITLE>lf365, Hardware: Un Term&oacute;metro Digital o Comunicarte en I2C Con Tu Microcontrolador Atmel</TITLE>
<style type="text/css">
<!--
 td.top {font-family: Arial,Geneva,Verdana,Helvetica,sans-serif; font-size:12 }
 pre { font-family:monospace,Courier }
 pre.code { font-family:monospace,Courier;background-color:#aedbe8; }
 p.cl { color:#EE9500 }
 table.left { margin-right:0.3cm }
 a.nodec { text-decoration:none }
 p.trans { font-size:8pt; text-align:right }
 p.clbox { width:50%; alignment:center; background-color:#FFD700; 
           border-style:none; border-width:medium; border-color:#FFD700; 
           padding:0.5cm;  text-align:center }
 p.code { width:80%; alignment:center; background-color:#aedbe8; 
          border-style:none; border-width:medium; border-color:#aedbe8; 
          padding:0.1cm;  text-align:left }
 p.foot { background-color:#AAAAAA; color:#FFFFFF; border-style:none; 
          border-width:medium; border-color:#AAAAAA; padding:0.5cm ; 
          margin-top:0.1cm; margin-right:1cm; margin-left:1cm; 
          text-align:center }
 div.tbbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   margin: 2px 5px 2px 5px;
   text-align: center;
   width: 20em;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
 div.bbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   float: left;
   margin: 2px 5px 2px 5px;
   text-align: center;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
-->
</style>
 
</HEAD>
<BODY bgcolor="#ffffff" text="#000000">
 <!-- this is generated html code. NEVER use this file for your
 translation work. Instead get the file with the same article number
 and .meta.shtml in its name. Translate this meta file and then
 use lfparser program to generate the final article -->
 <!-- lfparser can be obtained from http://main.linuxfocus.org/~guido/dev/lfparser.html -->

<!-- this is used by a number of tools:
 =LF=AUTHOR: Guido     Socher
 =LF=CAT___: Hardware
 =LF=TITLE_: Un Term&oacute;metro Digital o Comunicarte en I2C Con Tu Microcontrolador Atmel
 =LF=NUMBER: 365
 =LF=ANAME_: article365.shtml
 =LF=PARSER: 2.52
 -->

<!-- 2pdaIgnoreStart -->

<!-- start navegation bar, current, style=2 -->
 <!-- top navegation bar -->
 <TABLE summary="topbar_1" cellspacing="0" cellpadding="0" border="0" align="center" width="90%">
   <TR bgcolor="#2e2292">
     <TD class="top"><TABLE summary="topbar_1_logo" cellspacing="0" cellpadding="0" border="0" width=
       "100%">
         <TR><TD width="319"><a href="../../index.shtml"><IMG src="../../common/images/logolftop_319x45.gif"
           alt="[LinuxFocus-icon]" width="319" height="45" align="left" 
           border="0"></a></TD>

           <TD class="top">
             <TABLE summary="topbar_1_links" width="100%">
               <TR align="right">
                 <TD class="top">
                 
                 <A class="nodec" href="../../index.shtml"><FONT color=
                 "#DDDDDD" size="2">&lt;--</FONT></A> &nbsp;| 
                 <A class="nodec" href="../map.html"><FONT color=
                 "#DDDDDD" size="2">Mapa</FONT></A> &nbsp;| 
                 <A class="nodec" href="../indice.html"><FONT color=
                 "#DDDDDD" size="2">Indice</FONT></A> &nbsp;| 
                 <A class="nodec" href="../Search/index.html"><FONT color=
                 "#DDDDDD" size="2">Busqueda</FONT></A> </TD>
                 
               </TR>

               <TR align="right">
                 <TD class="top">
                   <HR width="100%" noshade size="1">
                 </TD>
               </TR>
             </TABLE>
           </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end top navegation bar -->
 <!-- blue bar -->
 <TABLE summary="topbar_2" cellspacing="0" cellpadding="0" border="0" align="center"
 width="90%">
   <TR bgcolor="#00ffff">
     <TD><IMG src="../../common/images/transpix.gif" width="1" height=
     "2" alt=""></TD>
   </TR>
 </TABLE>
 <!-- end blue bar -->
 <!-- bottom navegation bar -->
 <TABLE summary="topbar_3" cellspacing="0" cellpadding="0" border="0" align="center"
 width="94%">
   <TR bgcolor="#000000">
     <TD>
       <TABLE summary="topbar_3_links" cellspacing="0" cellpadding="1" border="0" width=
       "100%">
         <TR align="center">
           <TD WIDTH="20%"><A class="nodec" href="../News/index.shtml"><FONT color=
           "#FFFFFF">Noticias</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Archives/index.html"><FONT color=
           "#FFFFFF">Arca</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Links/index.html"><FONT color=
           "#FFFFFF">Enlaces</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../aboutus.html"><FONT color=
           "#FFFFFF">Sobre LF</FONT></A> </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end bottom navegation bar -->
<!-- stop navegation bar -->

<!-- SSI_INFO -->

<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfdynahead ver 1.5 --><TABLE ALIGN="right" border=0><TR><TD ALIGN="right"><FONT SIZE="-1" FACE="Arial,Helvetica">Este documento est&aacute; disponible en los siguientes idiomas: <A href="../../English/February2005/article365.shtml">English</a> &nbsp;<A href="../../Castellano/February2005/article365.shtml">Castellano</a> &nbsp;<A href="../../ChineseGB/February2005/article365.shtml">ChineseGB</a> &nbsp;<A href="../../Deutsch/February2005/article365.shtml">Deutsch</a> &nbsp;<A href="../../Francais/February2005/article365.shtml">Francais</a> &nbsp;</FONT></TD></TR></TABLE><br>
 


<!-- SSI_INFO STOP -->
<!-- 2pdaIgnoreStop -->

<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_START -->
<TABLE ALIGN="LEFT" BORDER="0" WIDTH="195" summary="about the author" class="left">
<TR>
<TD>

<img src="../../common/images/Guido-S.gif" alt=
    "[Photo of the Author]" height="164" width="173">
<BR>por  Guido Socher <a href="http://linuxfocus.org/~guido/"><font size="1">(homepage)</font></a>
<BR><BR>
<I>Sobre el autor:</I><BR>
<!-- aboutauthor_start -->
<p>A Guido le gusta Linux porque es realmente un buen sistema para desarrollar
    tu propio hardware.</p>
<!-- aboutauthor_stop -->
<!-- TRANSLATED_TO es -->
<BR><BR><I>Traducido al espa&ntilde;ol por:</I><BR>
Gabriela Gonz&aacute;lez <small>&lt;tradugag(at)yahoo.com&gt;</small>
<br>
<!--
 =LF=TRANSTO=es: Gabriela Gonz&aacute;lez
-->
<!-- TRANSLATED_TO_STOP -->
<!-- INDEX_START -->
<BR><i>Contenidos</i>:
<UL>
  <LI><A HREF="#365lfindex0">Introducci&oacute;n</A></LI>
  <LI><A HREF="#365lfindex1">C&oacute;mo Funciona I2C/TWI</A></LI>
  <LI><A HREF="#365lfindex2">El Plano</A></LI>
  <LI><A HREF="#365lfindex3">El Sensor de la Temperatura</A></LI>
  <LI><A HREF="#365lfindex4">El Circuito</A></LI>
  <LI><A HREF="#365lfindex5">Construyendo la Placa</A></LI>
  <LI><A HREF="#365lfindex6">Colocando Todo Junto</A></LI>
  <LI><A HREF="#365lfindex7">Utilizando la Comunicaci&oacute;n I2C</A></LI>
  <LI><A HREF="#365lfindex8">&iquest;C&uacute;an c&aacute;lido es?</A></LI>
  <LI><A HREF="#365lfindex9">Conclusi&oacute;n</A></LI>
  <LI><A HREF="#365lfindex10">Referencias</A></LI>
  <LI><A HREF="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=365">Formulario de "talkback" para este art&iacute;culo</A></LI>
</UL>

</TD></TR></TABLE>
<!-- INDEX_STOP -->
<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_STOP -->
<!-- HEAD_OF_THE_ARTICLE_START -->
<br>&nbsp;
<table border="0"><tr><td>
<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfPdf ver 0.1 -->
<TABLE style="border-style:outset; border-width:1px" align="right" bgcolor="#ff9616" cellspacing="1"><TR><TD bgcolor="#ff9616">
        <a href="../Archives/lf-2005_02-0365.pdf"><small>PDF</small></a>
        </TD></TR></TABLE>
         

<H2>Un Term&oacute;metro Digital o Comunicarte en I2C Con Tu Microcontrolador Atmel</H2>
 <img src="../../common/images2/article365/title_365.jpg" alt=
    "[Illustration]" hspace="10">
<!-- ABSTRACT OF THE ARTICLE -->
<P><i>Resumen</i>:
<P>
<!-- articleabstract_start -->


    El microcontrolador Atmega8 de Atmel presenta muchos circuitos digitales
    y an&aacute;logos de entrada/salida. Es el dispositivo ideal para
    desarrollar cualquier clase de equipo de medici&oacute;n. <br><br>
    En este art&iacute;culo vemos c&oacute;mo interconectar el microcontrolador
    a un ordenador Linux sobre una interfaz f&iacute;sica RS232 sin el chip extra
    MAX232.

    
<!-- articleabstract_stop -->

<br><!-- HR divider --><center><font color="#8282e0"><b>_________________ _________________ _________________</b></font></center><br>
</td></tr></table>
<!-- HEAD_OF_THE_ARTICLE_STOP -->
<!-- BODY_OF_THE_ARTICLE_START -->


    <A NAME="365lfindex0">&nbsp;</A>
<H2>Introducci&oacute;n</H2>

    Un prerequisito para este art&iacute;culo es que tengas instalado el entorno de programaci&oacute;n GCC AVR
    como se describi&oacute; en mi art&iacute;culo ("Programando el microcontrolador AVR con GCC, libc 1.0.4") <a href=
    "../November2004/article352.shtml"> "Programming the AVR
    microcontroller with GCC, libc 1.0.4"</a>.
    Si quieres evitar dificultades con la instalaci&oacute;n, por supuesto, puedes usar el CD de
    progamaci&oacute;n AVR de <a href=
    "http://shop.tuxgraphics.org/">http://shop.tuxgraphics.org/</a>
    <a href=
    "http://shop.tuxgraphics.org/electronic/microcontroller.html"><img
     src="../../common/images2/article365/linuxavrcd_th.jpg" align=
    "right" width="150" height="213" vspace="4" hspace="4"></a>
    <br>
    <br>
    <br>
    Cuando utilizas un dispositivo tan avanzado como un microcontrolador para
    medir se&ntilde;ales an&aacute;logas o digitales, por supuesto, quieres interfaces
    para evaluar los datos o enviar comandos al
    microcontrolador. En todos los art&iacute;culos presentados aqu&iacute; anteriormente
    siempre utilizamos comunicaci&oacute;n rs232 con el UART (Receptor/Transmisor Universal As&iacute;ncrono)que se encuentra incluido
    en el microcontrolador. El problema es que esto requiere un chip
    MAX232 adicional y 4 condensadores extra.
    Atmel tambi&eacute;n sugiere la requisici&oacute;n de un oscilador de cristal externo
    para que la comunicaci&oacute;n UART funcione de modo confiable. En todo caso, se trata de muchas partes
    extra... &iexcl;y podemos evitarlo!
    <br>
    <br>
    La cantidad de datos a transferir entre el ordenador y el microcontrolador
    es generalmente muy peque&ntilde;a (s&oacute;lo unos pocos bytes). La velocidad, por lo tanto,
    no nos preocupa. Esto hace que el bus/protocolo I2C sea apropiado para esta
    tarea. <br>
    <br>
    I2C (pronunciaci&oacute;n "eye-square-see" o "I cuadrado C" en espa&ntilde;ol) es una interfaz de comunicaci&oacute;n
    bidireccional de dos cables. Fue inventada por Philips y el nombre se encuentra
    protegido. Esta es la raz&oacute;n por la cual otros fabricantes utilizan otro nombre para el
    mismo protocolo. Atmel lo llama I2C "two wire
    interface" (TWI) o "interfaz de dos cables". <br>
    <br>
    Muchos de ustedes podr&iacute;an ya estar utilizando I2C en sus ordenadores
    sin saberlo. Todas las placas madres modernas tienen un bus I2C para leer
    temperaturas, la velocidad del ventilador, informaci&oacute;n acerca de la memoria disponible...
    toda clase de informaci&oacute;n sobre hardware. Este bus I2C lamentablemente no se encuentra en
    la parte externa del ordenador (no hay una conexi&oacute;n
    f&iacute;sica). Por lo tanto, tendremos que inventar algo nuevo.
    <br>
    <br>
    Pero primero veamos c&oacute;mo la "interfaz de dos cables" (=TWI =
    un nombre alternativo para I2C) funciona.

    <A NAME="365lfindex1">&nbsp;</A>
<H2>C&oacute;mo Funciona I2C/TWI</H2>

    La hoja de datos de Atmega8 (ver referencias) ya cuenta con una
    descripci&oacute;n muy detallada que comienza en la p&aacute;gina 160. Por lo tanto
    yo s&oacute;lo presentar&eacute; un resumen aqu&iacute;. Despu&eacute;s de este resumen, t&uacute; podr&aacute;s
    comprender la descripci&oacute;n en la hoja de datos. <br>
    <br>
    En el bus I2C siempre tienes un dispositivo maestro y uno o varios
    dispositivos esclavo. El maestro es el dispositivo que inicia la
    comunicaci&oacute;n y controla el reloj. Los dos cables de este bus
    se llaman SDA (l&iacute;nea de datos) y SCL (l&iacute;nea de reloj). Cada uno de los
    dispositivos del bus deben recibir energ&iacute;a en forma independiente (lo mismo que sucede con
    la comunicaci&oacute;n tradicional rs232). Las dos l&iacute;neas del bus se encuentran normalmente
    conectadas v&iacute;a resistencias ascendentes 4.7K pullup a, logicamente,
    "High" ("Alto") (+5V por 5V ICs). Esto da una conexi&oacute;n el&eacute;ctrica "or" ("o")
    entre todos los dispositivos. Un dispositivo simplemente extrae una l&iacute;nea a
    GND cuando quiere transmitir un 0 o lo deja en "Alto" cuando env&iacute;a
    un 1. <br>
    <br>
    El maestro comienza una comunicaci&oacute;n enviando un patr&oacute;n llamado
    "start condition" ("condici&oacute;n de inicio") y luego se dirige al dispositivo con
    el que quiere hablar. Cada dispositivo del bus tiene una direcci&oacute;n 7 bit &uacute;nica.
    Luego de esto, el maestro env&iacute;a un bit que indica si quiere leer o
    escribir datos. El esclavo ahora reconocer&aacute; que ha comprendido al maestro
    enviando un bit de reconocimiento. En otras palabras,
    ahora hemos visto 9 bits de datos en el bus (7 bits dirigidos +
    bit de lectura + bit de reconocimiento):
<pre class="code">
| start | 7-bit slave adr | read_data bit | wait for ack | ... data comes here
</pre>
    &iquest;Qu&eacute; Sigue Ahora? <br>
    <br>
    Ahora podemos recibir o transmitir datos. Los datos son siempre un m&uacute;ltiplo
    de 8 bits (1 byte) y deben ser reconocidos por un bit de reconocimiento. En
    otras palabras, siempre veremos paquetes de 9-bit en el bus. Cuando la comunicaci&oacute;n
    ha finalizado, el maestro debe transmitir una "stop
    condition" ("condici&oacute;n de finalizaci&oacute;n"). En otras palabras, el maestro debe saber c&uacute;antos datos vendr&aacute;n
    cuando lea datos de un esclavo. No obstante, esto no es un problema
    dado que puedes transmitir esta informaci&oacute;n dentro del protocolo
    del usuario. Usaremos, por ejemplo, el byte cero al final de una
    cadena para indicar que no hay m&aacute;s datos. <br>
    <br>
     Los datos en el cable SDA son v&aacute;lidos mientras que el SCL es 1. Resulta
    as&iacute;:
<pre class="code">
SDA H -\       /---\     /---\          /---\
    L   \-----/     \---/     \--------/     \------....

SCL H ----\     /-\       /-\     /-\    /-\    /-\
    L      \---/   \-----/   \---/   \--/   \--/   \-....


  | START |      1 |       1 |     0 |    1 |    0 |
</pre>
    Una de las mayores ventajas de este protocolo es que no necesitas
    una se&ntilde;al de reloj precisa y s&iacute;ncrona. El protocolo a&uacute;n funciona
    cuando hay un peque&ntilde;o soplido de un magnetr&oacute;n en la se&ntilde;al
    del reloj. <br>
    <br>
     Exactamente esta propiedad es la que hace posible implementar el protocolo I2C
    en una aplicaci&oacute;n de espacio de un usuario sin necesidad de un controlador del
    n&uacute;cleo o hardware especial (como un UART). Fant&aacute;stico, &iquest;no?


    <A NAME="365lfindex2">&nbsp;</A>
<H2>El Plano</H2>

    Como se coment&oacute; anteriormente, no podemos utilizar el bus I2C interno del ordenador pero
    podemos usar cualquier interfaz externa donde podamos enviar y recibir
    datos bits individuales. Simplemente utilizaremos la interfaz de hardware RS232
    de nuestro ordenador. En otras palabras, nuestra interfaz de comunicaci&oacute;n
    sigue siendo la misma de art&iacute;culos anteriores pero ahorramos el hardware
    MAX232, condensadores, etc... <br>
    <br>
    La parte dif&iacute;cil es, por supuesto, implementar el protocolo I2C del
    scratch. Me llev&oacute; 5 semanas aprenderlo y depurarlo pero ahora ya est&aacute; hecho
    y t&uacute; simplemente puedes copiarlo :-). Espero que recuerdes el valor de este
    c&oacute;digo cuando lo uses. <br>
    <br>
    Como ejemplo de aplicaci&oacute;n vamos a construir un term&oacute;metro. Puedes, por supuesto,
    medir algo m&aacute;s o simplemente prender y apagar luces.
    Depende de t&iacute;. <br>
    <br>
    En un segundo art&iacute;culo, vamos a agregar una pantalla local LCD. En otras palabras,
    tendr&aacute;s un term&oacute;metro en donde podr&aacute;s leer la temperatura directamente
    de la pantalla y/o leerla con tu ordenador
    Linux. La pantalla la veremos en un segundo art&iacute;culo a fin de no
    sobrecargar &eacute;ste.

    <table align="right" width="162">
      <tr>
        <td bgcolor="#C5D4F9"><img src=
        "../../common/images2/article365/ntc.jpg" alt="ntc"><br>
        NTCs son peque&ntilde;os, econ&oacute;micos y lo suficientemente apropiados</td>
      </tr>
    </table>

    <A NAME="365lfindex3">&nbsp;</A>
<H2>El Sensor de la Temperatura</H2>

    Ya es posible conseguir sensores calibrados de temperatura
    (algunos ya se comunican con I2C ;-) pero son bastante caros. Los NTCs
    son m&aacute;s baratos y casi tan buenos a&uacute;n sin calibraci&oacute;n
    individual. Si los calibras un poco, entonces es posible
    alcanzar la precisi&oacute;n detr&aacute;s del punto decimal. <br>
    <br>
    Un problema con los NTCs es que son no lineales. Sin embargo, esto es solamente
    un tema de f&iacute;sica semiconductora encontrar la f&oacute;rmula correcta
    para corregir la curva no lineal. El microcontrolador es una peque&ntilde;a computadora
    por lo cual las operaciones matem&aacute;ticas
    no son un problema. Los NTCs son resistencias que dependen de la temperatura. El
valor R del NTC a una temperatura dada es:<br clear="all">

    <center>
      <img src="../../common/images2/article365/Ntcformula.gif"
      alt="ntc formula">
    </center>
    T o Tc es el valor de temperatura que estamos buscando. Rn es el valor
    de resistencia del NTC a 25'C. Puedes comprar NTCs 4k7, 10K,
    ... entonces Rn tendr&aacute; este valor. <br>


    <A NAME="365lfindex4">&nbsp;</A>
<H2>El Circuito</H2>


    <table align="right">
      <tr>
        <td>
          <center>
            <a href=
            "../../common/images2/article365/i2ctemp_schematic.gif">
            <img src=
            "../../common/images2/article365/i2ctemp_schematic_th.gif"
             alt="circuit diagram"></a><br>
            Diagrama del circuito. Haz click en el diagrama para obtener una
            vista detallada.
          </center>
        </td>
      </tr>
    </table>
    Ahora tenemos todo lo que necesitamos para construir un term&oacute;metro digital. Agregamos
    dos sensores NTC, uno para la temperatura interior y otro para la exterior.
    Si quieres, puedes agregar m&aacute;s (conn3, pin PC2 por ejemplo, es gratuito). En el diagrama de
    circuito yo ya agrego los cables necesarios para la conexi&oacute;n de una pantalla
    LCD porque no quiero que construyas un circuito nuevo completo
    para el pr&oacute;ximo art&iacute;culo. <br>
    <br>
    Tambi&eacute;n hay conectado un LED (diodo emisor de luz). No cuesta mucho es realmente
    &uacute;til para una depuraci&oacute;n b&aacute;sica. Yo lo us&eacute;, por ejemplo, para depurar la m&aacute;quina de estado
    I2C cuando desarroll&eacute; la comunicaci&oacute;n I2C entre el ordenador
    y el microcontrolador. Durante la operaci&oacute;n normal, simplemente podemos
    dejarlo parpadeando para indicar que las mediciones son tomadas.
    <br>
    <br>
    De otro modo el circuito es directo. El an&aacute;logo al adaptador digital
    en el microcontrolador se utiliza para medir el voltage en el
    NTC el que entonces ser&aacute; convertido en un valor de
    temperatura. <br>
    <br>
    El Atmega8 tiene dos opciones en lo que se utiliza como referencia de
    voltage para el an&aacute;logo al adaptador digital. Puede utilizar tanto el
    5V (AVcc) como una referencia interna 2.56V. Para las temperaturas internas
    no necesitaremos un rango de temperatura que sea tan grande como
    para el sensor externo. +10'C a +40'C normalmente deber&iacute;a ser
    suficiente. Por lo tanto podemos usar la referencia 2.56V cuando midamos
    el sensor interno. Esto proporciona una alta precisi&oacute;n ya que los
    1024 valores digitales posibles s&oacute;lo se expanden sobre 0-2.56V
    con lo que obtenemos una resoluci&oacute;n de 2.5mV (&iexcl;m&aacute;s precisa que en la mayor&iacute;a de los
    volt&iacute;metros digitales!). <br>
    <br>
    El CD-pin en RS232 es una l&iacute;nea de entrada y se encuentra conectada a
    SDA en el bus I2C. Lo utilizamos para leer datos del
    microcontrolador. DTR y RTS son l&iacute;neas de salida. Cuando el ordenador coloca
    datos bits en la l&iacute;nea SDA entonces simplemente alterna DTR. El maestro
    I2C (aqu&iacute; el ordenador Linux) controla la l&iacute;nea SCL (reloj).
    En otras palabras, la l&iacute;nea reloj es una l&iacute;nea de salida en el rs232.
    <br>
    <br>
    El 78L05 se utiliza para generar un suministro estable de energ&iacute;a y
    referencia de voltage. Puedes utilizar casi cualquier tipo de suministro de energ&iacute;a AC
    o DC entre 7.5V y 12V. 9V es una buena elecci&oacute;n.

    <A NAME="365lfindex5">&nbsp;</A>
<H2>Construyendo la Placa</H2>


    <table align="right" width="202">
      <tr>
        <td bgcolor="#C5D4F9"><a href=
        "http://shop.tuxgraphics.org"><img src=
        "../../common/images2/article365/article365kit_th.jpg" alt=
        "get this kit from the tuxgraphics shop"></a><br>
        tuxgraphics.org vende todas las piezas que se necesitan para este art&iacute;culo
        junto con una placa grabada apropiada.</td>
      </tr>
    </table>
    Por supuesto, puedes reutilizar la placa de prototipo que usamos
    en el art&iacute;culo anterior. Simplemente reconecta el LED al pin 11 y
    agrega todas las cosas nuevas. <br>
    <br>
    Si deseas tener un circuito que luzca bien entonces ser&iacute;a mejor
    usar una placa nueva. Dado que el circuito es mucho m&aacute;s complicado,
    conviene grabar apropiadamente una placa de circuito
    impreso. Despu&eacute;s de leer el art&iacute;culo de Linuxfocus de Iznogood sobre
    gEDA yo tambi&eacute;n decid&iacute; usar gEDA en lugar de Eagle. gschem, la herramienta
    de dibujo esquem&aacute;tica para gEDA es muy buena. No tiene una biblioteca de
    s&iacute;mbolos tan grande como Eagle y tuve que crear el s&iacute;mbolo para
    Atmega8 pero es muy f&aacute;cil de usar y es tan buena como
    Eagle. Un poco problem&aacute;tica es pcb, la herramienta para dibujar
    PCBs. Cuando has utilizado Eagle, primero notar&aacute;s que es imposible
    desconectar las partes de las bandas
    el&aacute;sticas. Para estar seguro de que la banda el&aacute;stica correcta est&aacute; conectada al
    pin correcto, tienes que ejecutar
    Connects-&gt;Optimize rats-nest de una vez. Primero tendr&aacute;s que completar el
    diagrama de circuito y luego construir la placa. La anotaci&oacute;n entre ambos es
    solamente manual. <img src=
    "../../common/images2/article365/i2ctemppcb_topview_position_components.png"
     alt="top view, position of components" align="left"> <br>
    <br>
    Yo us&eacute; la capa pintada de naranja para dibujar. De alg&uacute;n modo, las otras capas
    no generan ninguna salida al imprimir.  El problema es que la capa pintada de
    de color naranja ya se encuentra del lado de la placa
    en donde est&aacute;n las partes. Si escribes texto en esta capa,
    tendr&aacute; que ser duplicado cuando lo imprimas en la placa f&iacute;sica.
    Por lo tanto hice el dise&ntilde;o b&aacute;sico con pcb y todo el resto
    con gimp. <br>
    <br>
    Gracias a <a href=
    "http://shop.tuxgraphics.org">shop.tuxgraphics.org</a> no tendr&aacute;s que
    trabajar con qu&iacute;micos peligrosos ni recorrer la ciudad para
    encontrar los componentes correctos. Ellos venden todas las partes necesarias
    para este art&iacute;culo. De este modo, s&oacute;lo tendr&aacute;s que concentrarte en la parte
    divertida y ensamblar este circuito con &eacute;xito.

    <A NAME="365lfindex6">&nbsp;</A>
<H2>Colocando Todo Junto</H2>

    Cuando ensamblas el circuito, presta atenci&oacute;n a las piezas
    en las que la polaridad es importante: Electrocondensadores, diodo,
    diodos Z, 78L05, LED y el microcontrolador. <br>
    <br>
    Antes de colocar el microcontroladore en el casquillo, debes verificar
    la parte de suministro de energ&iacute;a. Si esta no funciona, t&uacute; no s&oacute;lo obtendr&aacute;s
    lecturas de temperatura incorrectas sino que tambi&eacute;n podr&iacute;as llegar a
    destruir el microcontrolador. Por lo tanto, conecta energ&iacute;a exterior
    (por ejemplo, una bater&iacute;a 9V) y verifica con un volt&iacute;metro que tienes exactamente
    5V en el pin del casquillo del microcontrolador. Como siguiente paso, conecta
    el circuito al puerto rs232 de tu ordenador Linux y ejecuta el programa
     i2c_rs232_pintest con varias combinaciones de
    se&ntilde;ales.
<pre class="code">
i2c_rs232_pintest -d 1 -c 1
i2c_rs232_pintest -d 0 -c 1
i2c_rs232_pintest -d 1 -c 0
</pre>
    Este programa establece los niveles de voltage en los pins RTS (usado como SCL,
    opci&oacute;n -c) y DTR (usado como SDA, opci&oacute;n -d) del puerto
    rs232. El puerto rs232 tiene niveles de voltage de aproximadamente +/- 10V.
    Detr&aacute;s del diodo Z deber&iacute;as medir unicamente -0.7 para un cero
    l&oacute;gico y +4-5V para un uno l&oacute;gico. <br>
    <br>
    Inserta el microcontrolador solamente despu&eacute;s de que tu circuito haya pasado las pruebas
    descriptas anteriormente.

    <A NAME="365lfindex7">&nbsp;</A>
<H2>Utilizando la Comunicaci&oacute;n I2C</H2>

    Descarga (ver referencias) el archivo linuxI2Ctemp tar.gz y
    desempaqu&eacute;talo. La comunicaci&oacute;n I2C est&aacute; implementada en 2 archivos:
<pre class="code">
i2c_avr.c -- the i2c statemachine for the atmega8
i2c_m.c   -- the complete i2c protocol on the linux side
</pre>
    Yo le he dado a atmega8 la direcci&oacute;n esclava "3". Para enviar la cadena
    "hello" ("hola") a atmega8 ejecutar&iacute;as las siguientes funciones
    C:
<pre class="code">
address_slave(3,0); // tell the slave that we will send something
i2c_tx_string("hello");
i2cstop(); // release the i2c bus

on the microcontroller side you would receive this "hello" string with
i2c_get_received_data(rec_buf);
</pre>
    Muy f&aacute;cil. Leer datos del microcontrolador es similar.
    Mira el archivo i2ctemp_avr_main.c para ver c&oacute;mo funciona cuando
    las lecturas de temperaturas est&eacute;n hechas.

    <A NAME="365lfindex8">&nbsp;</A>
<H2>&iquest;C&uacute;an c&aacute;lido es?</H2>

    Para compilar y cargar el c&oacute;digo para el microcontrolador, ejecuta los siguientes
    comandos del paquete de directorio linuxI2Ctemp.
<pre class="code">
make
make load
</pre>
    Compila los dos programas i2c_rs232_pintest y i2ctemp_linux
<pre class="code">
make i2c_rs232_pintest
make i2ctemp_linux
</pre>
    ... o simplemente usa las versiones precompiladas en el "recipiente"
    subdirectorio. <br>
    <br>
    Para leer las temperaturas simplemente ejecuta:
<pre class="code">
i2ctemp_linux
</pre>
    ... e imprimir&aacute; las temperaturas internas y externas. Para hacer que estos datos
    se encuentren disponibles en un sitio web, sugiero no ejecutar directamente
    i2ctemp_linux desde el servidor web porque la comunicaci&oacute;n i2c es muy
    lenta. En cambio, ejec&uacute;talo desde un cron job y escribe desde all&iacute; a un
    archivo html. Un ejemplo de secuencia de comandos se incluye en el archivo
    README del paquete linuxI2Ctemp.

    <A NAME="365lfindex9">&nbsp;</A>
<H2>Conclusi&oacute;n</H2>

    El protocolo I2C requiere muy poco hardware extra y es &oacute;ptimo para
    transmitir o recibir peque&ntilde;as cantidades de datos.
    Esto es exactamente lo que necesitamos cuando queremos comunicarnos con
    nuestro propio hardware de controlador.  &iexcl;Es realmente una muy buena
    soluci&oacute;n! <br>
    <br>
    En este art&iacute;culo he puesto mucho &eacute;nfasis en la parte de hardware.
    Si te gusta este art&iacute;culo entonces escribir&eacute; un segundo en el que
    describo c&oacute;mo funciona el software. Especialmente veremos c&oacute;mo hacer
    la conversi&oacute;n an&aacute;loga a digital y c&oacute;mo funciona la implementaci&oacute;n del
    protocolo I2C. En el pr&oacute;ximo art&iacute;culo tambi&eacute;n podemos agregar una pantalla
    LCD y conversi&oacute;n entre Farenheit y Celsius.

    <A NAME="365lfindex10">&nbsp;</A>
<H2>Referencias</H2>


    <ul>
      <li><b>P&aacute;gina de descargas</b> para este art&iacute;culo: <a href="../../common/src2/article365/index.html">el software linuxI2Ctemp,
      diagramas, actualizaciones de software</a></li>

      <li>C&oacute;mo programar el atmega8 con gcc: <a href=
      "../November2004/article352.shtml">November2004 article
      352</a></li>

      <li>Hoja de Datos para Atmega8: ver http://www.atmel.com/
      y seleccionar products-&gt;Microcontrollers -&gt;AVR-8 bit
      RISC-&gt;Documentation-&gt;datasheets <a href=
      "../../common/src2/article365/atmega8.pdf">(local copy, pdf,
      2479982 bytes)</a></li>

      <li>The tuxgraphics shop. Realmente una gran tienda en l&iacute;nea :-): <a
      href=
      "http://shop.tuxgraphics.org/">shop.tuxgraphics.org</a><br>
       Aqu&iacute; puedes obtener el CD de programaci&oacute;n Linux AVR, todas las piezas
      para este art&iacute;culo, pantallas LCD y microcontroladores.</li>
    </ul>
    <!-- vim: set sw=2 ts=2 et tw=80: -->
  



<!-- BODY_OF_THE_ARTICLE_STOP -->
<!-- 2pdaIgnoreStart -->
<A NAME="talkback">&nbsp;</a>
<h2>Formulario de "talkback" para este art&iacute;culo</h2>
Cada art&iacute;culo tiene su propia p&aacute;gina de "talkback". A trav&eacute;s de esa p&aacute;gina puedes enviar un comentario o consultar los comentarios de otros lectores
<center>
    <table width="250" border=0><tr><td>
    <div class="tbbutton"><A class="nodec" href="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=365">&nbsp;Ir a la p&aacute;gina de "talkback"&nbsp;</a></div>
    </td></tr></table>
</center>

<br clear="all">
<HR size="2" noshade>
<table width="250" border=0><tr><td>
<div class="bbutton"><a class="nodec" href="../../index.shtml">&lt;--, LF Hogar</a></div>
</td><td>
<div class="bbutton"><a class="nodec" href="index.shtml">&Iacute;ndice de este n&uacute;mero</a></div>
</td></tr></table>
<br clear="all">
<HR size="2" noshade>
<!-- ARTICLE FOOT -->
<CENTER><TABLE WIDTH="98%" summary="footer">
<TR><TD ALIGN=CENTER BGCOLOR="#bdc6d5" WIDTH="50%">
<A HREF="../../common/lfteam.html">Contactar con el equipo de LinuFocus</A>
<BR><FONT COLOR="#1111aa"><a href="../../common/copy.html">&copy; Guido     Socher</a><br>&quot;some rights reserved&quot; see <a href="../../license/index.shtml">linuxfocus.org/license/</a><br><a href="http://www.linuxfocus.org">http://www.LinuxFocus.org</a></FONT>
</TD>
<TD BGCOLOR="#bdc6d5">
<!-- TRANSLATION INFO -->
<font size=2>Informaci&oacute;n sobre la traducci&oacute;n:</font>
<TABLE summary="translators">
  <tr><td><font size="2">en --&gt; -- : Guido Socher (<a href="http://linuxfocus.org/~guido/"><font size="1">homepage</font></a>)</font></td></tr>
  <tr><td><font size="2">en --&gt; es: Gabriela Gonz&aacute;lez &lt;tradugag(at)yahoo.com&gt;</font></td></tr>
</TABLE>
</TD>
</TR></TABLE></CENTER>
<p><font size=1>2005-02-28, generated by lfparser version 2.52</font></p>
<!-- 2pdaIgnoreStop -->
</BODY>
</HTML>
