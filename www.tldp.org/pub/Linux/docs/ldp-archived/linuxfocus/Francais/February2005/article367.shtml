<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
 <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <META NAME="GENERATOR" CONTENT="lfparser_2.52">
 <META NAME="LFCATEGORY" CONTENT="KernelCorner">
 <link rel="icon" href="../../common/images/lf-16.png" type="image/png">
 <TITLE>lf367, KernelCorner: Ecris tes propres r&egrave;gles pour NetFilter</TITLE>
<style type="text/css">
<!--
 td.top {font-family: Arial,Geneva,Verdana,Helvetica,sans-serif; font-size:12 }
 pre { font-family:monospace,Courier }
 pre.code { font-family:monospace,Courier;background-color:#aedbe8; }
 p.cl { color:#EE9500 }
 table.left { margin-right:0.3cm }
 a.nodec { text-decoration:none }
 p.trans { font-size:8pt; text-align:right }
 p.clbox { width:50%; alignment:center; background-color:#FFD700; 
           border-style:none; border-width:medium; border-color:#FFD700; 
           padding:0.5cm;  text-align:center }
 p.code { width:80%; alignment:center; background-color:#aedbe8; 
          border-style:none; border-width:medium; border-color:#aedbe8; 
          padding:0.1cm;  text-align:left }
 p.foot { background-color:#AAAAAA; color:#FFFFFF; border-style:none; 
          border-width:medium; border-color:#AAAAAA; padding:0.5cm ; 
          margin-top:0.1cm; margin-right:1cm; margin-left:1cm; 
          text-align:center }
 div.tbbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   margin: 2px 5px 2px 5px;
   text-align: center;
   width: 20em;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
 div.bbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   float: left;
   margin: 2px 5px 2px 5px;
   text-align: center;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
-->
</style>
 
</HEAD>
<BODY bgcolor="#ffffff" text="#000000">
 <!-- this is generated html code. NEVER use this file for your
 translation work. Instead get the file with the same article number
 and .meta.shtml in its name. Translate this meta file and then
 use lfparser program to generate the final article -->
 <!-- lfparser can be obtained from http://main.linuxfocus.org/~guido/dev/lfparser.html -->

<!-- this is used by a number of tools:
 =LF=AUTHOR: Nicolas Bouliane
 =LF=CAT___: KernelCorner
 =LF=TITLE_: Ecris tes propres r&egrave;gles pour NetFilter
 =LF=NUMBER: 367
 =LF=ANAME_: article367.shtml
 =LF=PARSER: 2.52
 -->

<!-- 2pdaIgnoreStart -->

<!-- start navegation bar, current, style=2 -->
 <!-- top navegation bar -->
 <TABLE summary="topbar_1" cellspacing="0" cellpadding="0" border="0" align="center" width="90%">
   <TR bgcolor="#2e2292">
     <TD class="top"><TABLE summary="topbar_1_logo" cellspacing="0" cellpadding="0" border="0" width=
       "100%">
         <TR><TD width="319"><a href="../../index.shtml"><IMG src="../../common/images/logolftop_319x45.gif"
           alt="[LinuxFocus-icon]" width="319" height="45" align="left" 
           border="0"></a></TD>

           <TD class="top">
             <TABLE summary="topbar_1_links" width="100%">
               <TR align="right">
                 <TD class="top">
                 
                 <A class="nodec" href="../../index.shtml"><FONT color=
                 "#DDDDDD" size="2">&lt;--</FONT></A> &nbsp;| 
                 <A class="nodec" href="../map.html"><FONT color=
                 "#DDDDDD" size="2">Carte</FONT></A> &nbsp;| 
                 <A class="nodec" href="../indice.html"><FONT color=
                 "#DDDDDD" size="2">Index</FONT></A> &nbsp;| 
                 <A class="nodec" href="../Search/index.html"><FONT color=
                 "#DDDDDD" size="2">Recherche</FONT></A> </TD>
                 
               </TR>

               <TR align="right">
                 <TD class="top">
                   <HR width="100%" noshade size="1">
                 </TD>
               </TR>
             </TABLE>
           </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end top navegation bar -->
 <!-- blue bar -->
 <TABLE summary="topbar_2" cellspacing="0" cellpadding="0" border="0" align="center"
 width="90%">
   <TR bgcolor="#00ffff">
     <TD><IMG src="../../common/images/transpix.gif" width="1" height=
     "2" alt=""></TD>
   </TR>
 </TABLE>
 <!-- end blue bar -->
 <!-- bottom navegation bar -->
 <TABLE summary="topbar_3" cellspacing="0" cellpadding="0" border="0" align="center"
 width="94%">
   <TR bgcolor="#000000">
     <TD>
       <TABLE summary="topbar_3_links" cellspacing="0" cellpadding="1" border="0" width=
       "100%">
         <TR align="center">
           <TD WIDTH="20%"><A class="nodec" href="../News/index.shtml"><FONT color=
           "#FFFFFF">Nouvelles</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Archives/index.html"><FONT color=
           "#FFFFFF">Archives</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Links/index.html"><FONT color=
           "#FFFFFF">Liens</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../aboutus.html"><FONT color=
           "#FFFFFF">A propos</FONT></A> </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end bottom navegation bar -->
<!-- stop navegation bar -->

<!-- SSI_INFO -->

<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfdynahead ver 1.5 --><TABLE ALIGN="right" border=0><TR><TD ALIGN="right"><FONT SIZE="-1" FACE="Arial,Helvetica">Ce document est disponible en: <A href="../../English/February2005/article367.shtml">English</a> &nbsp;<A href="../../ChineseGB/February2005/article367.shtml">ChineseGB</a> &nbsp;<A href="../../Deutsch/February2005/article367.shtml">Deutsch</a> &nbsp;<A href="../../Francais/February2005/article367.shtml">Francais</a> &nbsp;</FONT></TD></TR></TABLE><br>
 


<!-- SSI_INFO STOP -->
<!-- 2pdaIgnoreStop -->

<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_START -->
<TABLE ALIGN="LEFT" BORDER="0" WIDTH="195" summary="about the author" class="left">
<TR>
<TD>

<img src="../../common/images2/NicolasBouliane.jpg" alt="Photo of Nicolas Bouliane">
<BR>par  Nicolas Bouliane <br> <small>&lt;nib(at)cookinglinux!org&gt;</small>
<BR><BR>
<I>L&acute;auteur:</I><BR>
<!-- aboutauthor_start -->

Nicolas est un jeune guerrier dans la communaut&eacute; du logiciel libre.
Il est accro &agrave; GNU/Linux depuis le jour o&ugrave; il l'a install&eacute; sur son ordinateur en 1998.
Il passe son temps &agrave; &eacute;tudier la couche r&eacute;seau de linux, &agrave; &eacute;crire des logiciels libres
et &agrave; assister &agrave; des conf&eacute;rences sur linux, comme la OLS.
Quant il n'est pas devant son ordinateur, il aime regarder des films de science-fiction,
jouer aux &eacute;checs et &eacute;couter les discours de Richard Stallman.


<!-- aboutauthor_stop -->
<!-- TRANSLATED_TO fr -->
<!-- TRANSLATED_TO_STOP -->
<!-- INDEX_START -->
<BR><i>Sommaire</i>:
<UL>
  <LI><A HREF="#367lfindex0">Description</A></LI>
  <LI><A HREF="#367lfindex1">1.0 Le module iptables</A></LI>
  <LI><A HREF="#367lfindex2">1.1 Structures et fonctions disponibles</A></LI>
  <LI><A HREF="#367lfindex3">1.2 &Agrave; l'int&eacute;rieur du squelette</A></LI>
  <LI><A HREF="#367lfindex4">1.2.1 Initialisation</A></LI>
  <LI><A HREF="#367lfindex5">1.2.2 Fonction save</A></LI>
  <LI><A HREF="#367lfindex6">1.2.3 Fonction print</A></LI>
  <LI><A HREF="#367lfindex7">1.2.4 Fonction final check</A></LI>
  <LI><A HREF="#367lfindex8">1.2.5 Fonction parse</A></LI>
  <LI><A HREF="#367lfindex9">1.2.6 Structure des options</A></LI>
  <LI><A HREF="#367lfindex10">1.2.7 Fonction init</A></LI>
  <LI><A HREF="#367lfindex11">1.2.7 Fonction help</A></LI>
  <LI><A HREF="#367lfindex12">1.2.8 Le fichier d'en-t&ecirc;te 'ipt_ipaddr.h'</A></LI>
  <LI><A HREF="#367lfindex13">1.3 Sommaire du chapitre 1</A></LI>
  <LI><A HREF="#367lfindex14">2.0 Le module netfilter</A></LI>
  <LI><A HREF="#367lfindex15">2.1 Structures et fonctions disponibles</A></LI>
  <LI><A HREF="#367lfindex16">2.2 A l'int&eacute;rieur du squelette</A></LI>
  <LI><A HREF="#367lfindex17">2.2.1 Initialisation</A></LI>
  <LI><A HREF="#367lfindex18">2.2.2 Fonction match</A></LI>
  <LI><A HREF="#367lfindex19">2.2.3 Fonction checkentry</A></LI>
  <LI><A HREF="#367lfindex20">2.3 Sommaire du chapitre 2</A></LI>
  <LI><A HREF="#367lfindex21">3.0 Jouer avec iptables/netfilter</A></LI>
  <LI><A HREF="#367lfindex22">3.1 iptables</A></LI>
  <LI><A HREF="#367lfindex23">3.2 Noyau</A></LI>
  <LI><A HREF="#367lfindex24"> Conclusion </A></LI>
  <LI><A HREF="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=367">Talkback form for this article</A></LI>
</UL>

</TD></TR></TABLE>
<!-- INDEX_STOP -->
<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_STOP -->
<!-- HEAD_OF_THE_ARTICLE_START -->
<br>&nbsp;
<table border="0"><tr><td>
<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfPdf ver 0.1 -->
<TABLE style="border-style:outset; border-width:1px" align="right" bgcolor="#ff9616" cellspacing="1"><TR><TD bgcolor="#ff9616">
        <a href="../Archives/lf-2005_02-0367.pdf"><small>PDF</small></a>
        </TD></TR></TABLE>
         

<H2>Ecris tes propres r&egrave;gles pour NetFilter</H2>
 <img src="../../common/images2/article367.png" alt="[Illustration]" hspace="10">
<!-- ABSTRACT OF THE ARTICLE -->
<P><i>R&eacute;sum&eacute;</i>:
<P>
<!-- articleabstract_start -->

L'interface du couple iptables/netfilter nous permet d'ajouter des fonctionnalit&eacute;s.
Pour ce faire, nous &eacute;crivons des modules du noyau qui s'enregistrent par dessus cette interface.
Donc, suivant la cat&eacute;gorie de la fonctionnalit&eacute;, nous &eacute;crivons un module pour iptables.
En &eacute;crivant notre nouveau module, nous pouvons d&eacute;tecter, transformer, accepter et suivre un
paquet donn&eacute;. En fait, tu peux faire presque tout ce que tu veux, dans ce monde du filtrage.

Attention, une petite erreur dans un module du noyau peu endommager s&eacute;v&egrave;remment ton ordinateur.

<br><br>

Pour rester simple, je vais expliquer un squelette de r&egrave;gle que j'ai &eacute;crit. Comme &ccedil;a,
j'esp&egrave;re qu'il sera plus simple de comprendre le lien entre l'extension et l'interface.
Bon, je suppose que tu connais d&eacute;j&agrave; un peu iptables et que tu sais programmer en langage C.

<br><br>

Cet exemple va te montre comment d&eacute;tecter un paquet en fonction de son adresse IP source et/ou de celle de destination.

<!-- articleabstract_stop -->

<br><!-- HR divider --><center><font color="#8282e0"><b>_________________ _________________ _________________</b></font></center><br>
</td></tr></table>
<!-- HEAD_OF_THE_ARTICLE_STOP -->
<!-- BODY_OF_THE_ARTICLE_START -->



<A NAME="367lfindex0">&nbsp;</A>
<H2>Description</H2>


Les &eacute;tapes g&eacute;n&eacute;rales pour cr&eacute;er un module de filtrage iptables/netfilter sont:
<ul>
  <li> Tu veux d&eacute;tecter une situation particuli&egrave;re.
  </li><li> &Eacute;crire la partie dans l'espace utilisateur, qui va traiter les arguments.
  </li><li> &Eacute;crire la partie dans l'espace noyau, qui va analyser les paquets et dire s'il y a concordance ou pas.
</li></ul>

<A NAME="367lfindex1">&nbsp;</A>
<H2>1.0 Le module iptables</H2>


Le but premier d'une biblioth&egrave;que iptables est d'interagir avec l'utilisateur.
Elle va traiter les arguments que l'utilisateur veut faire passer &agrave; la partie noyau.

<A NAME="367lfindex2">&nbsp;</A>
<H2>1.1 Structures et fonctions disponibles</H2>

Tout d'abord, quelques structures de base.
&lt;<i>iptables/include/iptables.h</i>&gt;<br>
Nous verrons plus tard dans cet article quel est la signification de chaque champ.
<table width="70%"><tbody><tr><td>
<pre class="code">/* Include file for additions: new matches and targets. */
struct iptables_match
{
   struct iptables_match *next;

   ipt_chainlabel name;

   const char *version;

   /* Size of match data. */
   size_t size;

   /* Size of match data relevent for userspace comparison purposes */
   size_t userspacesize;

   /* Function which prints out usage message. */
   void (*help)(void);

   /* Initialize the match. */
   void (*init)(struct ipt_entry_match *m, unsigned int *nfcache);

   /* Function which parses command options; returns true if it
           ate an option */
   int (*parse)(int c, char **argv, int invert, unsigned int *flags,
           const struct ipt_entry *entry,
           unsigned int *nfcache,
           struct ipt_entry_match **match);

   /* Final check; exit if not ok. */
   void (*final_check)(unsigned int flags);

   /* Prints out the match iff non-NULL: put space at end */
   void (*print)(const struct ipt_ip *ip,
            const struct ipt_entry_match *match, int numeric);

   /* Saves the match info in parsable form to stdout. */
   void (*save)(const struct ipt_ip *ip,
           const struct ipt_entry_match *match);

   /* Pointer to list of extra command-line options */
   const struct option *extra_opts;

   /* Ignore these men behind the curtain: */
   unsigned int option_offset;
   struct ipt_entry_match *m;
   unsigned int mflags;
#ifdef NO_SHARED_LIBS
   unsigned int loaded; /* simulate loading so options are merged properly */
#endif
};
</pre>
</td></tr></tbody></table>

<A NAME="367lfindex3">&nbsp;</A>
<H2>1.2 &Agrave; l'int&eacute;rieur du squelette</H2>

<A NAME="367lfindex4">&nbsp;</A>
<H3>1.2.1 Initialisation</H3>


Nous initialisons les champs communs dans la structure 'iptables_match'.

<pre class="code">static struct iptables_match ipaddr
= {
</pre>

'Name' est le nom de fichier de ta biblioth&egrave;que (ie: libipt_ipaddr).<br>
Tu peux donner un autre nom, il est utilis&eacute; pour l'auto-chargement de la biblioth&egrave;que.

<pre class="code">    .name            = "ipaddr",
</pre>

Le champ suivant, 'version', est la version d'iptables. Les deux suivants sont
utilis&eacute;s pour la corr&eacute;lation entre la taille de la structure partag&eacute;e entre l'espace
utilisateur et l'espace noyau.
<pre class="code">    .version         = IPTABLES_VERSION,
    .size            = IPT_ALIGN(sizeof(struct ipt_ipaddr_info)),
    .userspacesize   = IPT_ALIGN(sizeof(struct ipt_ipaddr_info)),
</pre>

'Help' est appel&eacute;e quand l'utilisateur tape 'iptables -m module -h'. 'Parse'
est appel&eacute;e quand tu entres une nouvelle r&egrave;gle, son r&ocirc;le est de valider les
arguments.
Quant &agrave; 'print', elle est appel&eacute;e lorsque la commande 'iptables -L' est tap&eacute;e
pour afficher les r&egrave;gles pr&eacute;c&eacute;demment d&eacute;finies.
<pre class="code">    .help            = &amp;help,
    .init            = &amp;init,
    .parse           = &amp;parse,
    .final_check     = &amp;final_check,
    .print           = &amp;print,
    .save            = &amp;save,
    .extra_opts      = opts
};
</pre>

L'infrastructure iptables peut supporteer de multiples biblioth&egrave;ques partag&eacute;es. Chacune
doit s'enregistrer aupr&egrave;s d'iptables en appelant 'register_match()', qui est d&eacute;finie dans
&lt;<i>iptables/iptables.c</i>&gt;. Cette fonction est appel&eacute;e lorsque le module est charg&eacute;
par iptables.

Pour obtenir plus d'informations: 'man dlopen'.
<pre class="code">void _init(void)
{
   register_match(&amp;ipaddr);
}
</pre>

<A NAME="367lfindex5">&nbsp;</A>
<H3>1.2.2 Fonction save</H3>


Si nous avons un ensemble de r&egrave;gles que nous voulons sauvegarder, iptables fourni la commande 'iptables-save' qui d&eacute;charge toutes
tes r&egrave;gles. Il a &eacute;videmment besoin de l'aide de ton module pour d&eacute;charger tes propres r&egrave;gles. C'est fait en appelant cette
fonction.

<pre class="code">static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
{
   const struct ipt_ipaddr_info *info = (const struct ipt_ipaddr_info *)match-&gt;data;
</pre>
Nous affichons l'adresse source si elle fait partie de la r&egrave;gle.
<pre class="code">   if (info-&gt;flags &amp; IPADDR_SRC) {
      if (info-&gt;flags &amp; IPADDR_SRC_INV)
         printf("! ");
      printf("--ipsrc ");
      print_ipaddr((u_int32_t *)&amp;info-&gt;ipaddr.src);
   }
</pre>
Nous affichons l'adresse de destination si elle fait partie de la r&egrave;gle.
<pre class="code">   if (info-&gt;flags &amp; IPADDR_DST) {
      if (info-&gt;flags &amp; IPADDR_DST_INV)
         printf("! ");
      printf("--ipdst ");
      print_ipaddr((u_int32_t *)&amp;info-&gt;ipaddr.dst);
   }
}
</pre>

<A NAME="367lfindex6">&nbsp;</A>
<H3>1.2.3 Fonction print</H3>

C'est la m&ecirc;me philosophie que la pr&eacute;c&eacute;dente, le but de cette fonction est d'afficher des informations sur les r&egrave;gles.
Elle est appel&eacute;e par 'iptables -L'. Nous verrons plus tard dans cet article le r&ocirc;le de 'ipt_entry_match *match', mais tu as
sans doute d&eacute;j&agrave; une petite id&eacute;e l&agrave;-dessus.

<pre class="code">static void print(const struct ipt_ip *ip,
                  const struct ipt_entry_match *match,
                  int numeric)
{
   const struct ipt_ipaddr_info *info = (const struct ipt_ipaddr_info *)match-&gt;data;

   if (info-&gt;flags &amp; IPADDR_SRC) {
         printf("src IP ");
      if (info-&gt;flags &amp; IPADDR_SRC_INV)
         printf("! ");
      print_ipaddr((u_int32_t *)&amp;info-&gt;ipaddr.src);
   }

   if (info-&gt;flags &amp; IPADDR_DST) {
      printf("dst IP ");
      if (info-&gt;flags &amp; IPADDR_DST_INV)
         printf("! ");
      print_ipaddr((u_int32_t *)&amp;info-&gt;ipaddr.dst);
   }
}
</pre>

<A NAME="367lfindex7">&nbsp;</A>
<H3>1.2.4 Fonction final check</H3>

Cette fonction est une sorte de derni&egrave;re chance pour le test de validation. Elle est appel&eacute;e lorsque l'utilisateur
entre une nouvelle r&egrave;gle, juste apr&egrave;s l'analyse des arguments.
<pre class="code">static void final_check(unsigned int flags)
{
   if (!flags)
      exit_error(PARAMETER_PROBLEM, "ipt_ipaddr: Invalid parameters.");
}
</pre>

<A NAME="367lfindex8">&nbsp;</A>
<H3>1.2.5 Fonction parse</H3>

C'est la fonction la plus importante, car c'est ici que nous v&eacute;rifions si
les arguments sont utilis&eacute;s correctement et que nous stockons les informations
partag&eacute;es avec la partie noyau. Elle est appel&eacute;e chaque fois qu'un argument est
trouv&eacute;, donc si l'utilisateur fourni deux arguments, elle sera appel&eacute;e deux fois
avec le code de l'argument dans la variable 'c'.
<pre class="code">static int parse(int c, char **argv, int invert, unsigned int *flags,
                 const struct ipt_entry *entry,
                 unsigned int *nfcache,
                 struct ipt_entry_match **match)
{
</pre>

Nous utilisons cette structure sp&eacute;ciale pour stocker les informations que nous voulons partager avec la partie noyau. Le pointeur
'Match' est pass&eacute; &agrave; plusieurs fonctions donc nous travaillons sur la m&ecirc;me structure de donn&eacute;es.
Une fois que la r&egrave;gle est charg&eacute;e, ce pointeur est copi&eacute; dans la partie noyau.
Comme &ccedil;a, le module du noyau sait ce que l'utilisateur demande &agrave; analyser (et c'est le but, non?).
<pre class="code">   struct ipt_ipaddr_info *info = (struct ipt_ipaddr_info *)(*match)-&gt;data;
</pre>Chaque arguments correspond &agrave; une simple valeur, donc nous pouvons faire des actions sp&eacute;cifiques suivant les arguments pass&eacute;s.
Nous verrons plus tard dans cet article comment faire correspondre des valeurs aux arguments.
<br>
<pre class="code">   switch(c) {
</pre>Tout d'abord, nous testons si l'argument a &eacute;t&eacute; utilis&eacute; plus d'une fois. Si c'est le cas, nous appelons 'exit_error()'
d&eacute;finie dans &lt;<i>iptables/iptables.c</i>&gt;,
qui sort imm&eacute;diatement avec le code de retour 'PARAMETER_PROBLEM' d&eacute;fini dans &lt;<i>iptables/include/iptables_common.h</i>&gt;
Autrement, nous initialisons 'flags' et 'info-&gt;flags' &agrave; la valeur 'IPADDR_SRC' d&eacute;finie dans notre fichier d'en-t&ecirc;te. Nous verrons ce
fichier d'en-t&ecirc;te plus tard.
<br><br>
Bien que les deux variables drapeaux semblent avoir le m&ecirc;me dessein, ce n'est pas du tout le cas. La port&eacute;e de 'flags' est
seulement cette fonction, et 'info-&gt;flags' est un champ qui fait partie de la structure qui sera partag&eacute;e avec la partie
noyau.
<pre class="code">      case '1':
         if (*flags &amp; IPADDR_SRC)
            exit_error(PARAMETER_PROBLEM, "ipt_ipaddr: Only use --ipsrc once!");
         *flags |= IPADDR_SRC;
         info-&gt;flags |= IPADDR_SRC;
</pre>
Nous v&eacute;rifions si le drapeau inverseur, '!',  a &eacute;t&eacute; introduit, et nous mettons l'information ad&eacute;quate dans 'info-&gt;flags'.<br>
Ensuite, nous appelons 'parse_ipaddr', une fonction interne &eacute;crite pour ce squelette, pour convertir la chaine de l'adresse IP en une
valeur sur 32bits.<br>

<pre class="code">         if (invert)
            info-&gt;flags |= IPADDR_SRC_INV;

         parse_ipaddr(argv[optind-1], &amp;info-&gt;ipaddr.src);
         break;
</pre>

Dans la m&ecirc;me id&eacute;e, nous v&eacute;rifions une utilisation multiple et mettons les drapeaux idoines.
<pre class="code">      case '2':
         if (*flags &amp; IPADDR_DST)
            exit_error(PARAMETER_PROBLEM, "ipt_ipaddr: Only use --ipdst once!");
         *flags |= IPADDR_DST;
         info-&gt;flags |= IPADDR_DST;
         if (invert)
            info-&gt;flags |= IPADDR_DST_INV;

         parse_ipaddr(argv[optind-1], &amp;info-&gt;ipaddr.dst);
         break;

      default:
         return 0;
   }

   return 1;
}
</pre>
<A NAME="367lfindex9">&nbsp;</A>
<H3>1.2.6 Structure des options</H3>

Nous avons dit plus t&ocirc;t que chacun des arguments est reli&eacute; &agrave; une valeur simple.
La structure 'struct option' est le meilleur moyen pour faire cela. Pour plus d'informations
sur cette structure, je te recommande fortement de lire 'man 3 getopt'.
<pre class="code">static struct option opts[] = {
   { .name = "ipsrc",   .has_arg = 1,   .flag = 0,   .val = '1' },
   { .name = "ipdst",   .has_arg = 1,   .flag = 0,   .val = '2' },
   { .name = 0 }
};

</pre>
<A NAME="367lfindex10">&nbsp;</A>
<H3>1.2.7 Fonction init</H3>
Cette fonction init est utilis&eacute;e pour d&eacute;finir des choses sp&eacute;cifiques,
comme le syst&egrave;me de cache de netfilter. Ce n'est pas tr&egrave;s important de savoir pr&eacute;cisemment comment
elle fonctionne pour le moment.
<pre class="code">static void init(struct ipt_entry_match *m, unsigned int *nfcache)
{
   /* Can't cache this */
   *nfcache |= NFC_UNKNOWN;
}

</pre>
<A NAME="367lfindex11">&nbsp;</A>
<H3>1.2.7 Fonction help</H3>

Cette fonction est appel&eacute;e par 'iptables -m match_name -h' pour afficher les arguments utilisables.
<pre class="code">static void help(void)
{
   printf (
            "IPADDR v%s options:\n"
            "[!] --ipsrc <ip>\t\t The incoming ip addr matches.\n"
            "[!] --ipdst <ip>\t\t The outgoing ip addr matches.\n"
            "\n", IPTABLES_VERSION
         );
}

</ip></ip></pre>
<A NAME="367lfindex12">&nbsp;</A>
<H3>1.2.8 Le fichier d'en-t&ecirc;te 'ipt_ipaddr.h'</H3>

C'est dans ce fichier que nous d&eacute;finissons les macros dont nous avons besoin.
<pre class="code">#ifndef _IPT_IPADDR_H
#define _IPT_IPADDR_H
</pre>
Nous avons vu plut&ocirc;t que nous d&eacute;finissons des drapeaux pour certaines valeurs.
<pre class="code">#define IPADDR_SRC   0x01     /* Match source IP addr */
#define IPADDR_DST   0x02     /* Match destination IP addr */

#define IPADDR_SRC_INV  0x10  /* Negate the condition */
#define IPADDR_DST_INV  0x20  /* Negate the condition */
</pre>

La structure 'ipt_ipaddr_info' est celle qui sera copi&eacute;e dans la partie noyau.
<pre class="code">struct ipt_ipaddr {
   u_int32_t src, dst;
};

struct ipt_ipaddr_info {

   struct ipt_ipaddr ipaddr;

   /* Flags from above */
   u_int8_t flags;

};

#endif
</pre>

<A NAME="367lfindex13">&nbsp;</A>
<H2>1.3 Sommaire du chapitre 1</H2>

Dans la premi&egrave;re partie, nous avons discut&eacute; du but
de la biblioth&egrave;que iptables. Nous avons regard&eacute; l'int&eacute;rieur de chaque fonction et comment la
structure 'ipt_ipaddr_info' est utilis&eacute;e pour garder les informations qui seront copi&eacute;es dans
la partie noyau pour une utilisation ult&eacute;rieure. Nous avons regard&eacute; la structure iptables
et comment enregistrer notre nouvelle biblioth&egrave;que.<br>
Tu dois garder &agrave; l'esprit, que ce n'est qu'un squelette d'exemple pour m'aider &agrave; te montrer
comment fonctionne l'interface. Du reste 'ipt_ipaddr_info' et les choses comme &ccedil;a ne font pas partie
d'iptables/netfilter mais de cet exemple.
<A NAME="367lfindex14">&nbsp;</A>
<H2>2.0 Le module netfilter</H2>

L'objet d'un module de d&eacute;tection est d'inspecter chaque paquet re&ccedil;u et de d&eacute;cider s'il
correspond ou non &agrave; nos crit&egrave;res. Le module fait &ccedil;a de cette mani&egrave;re:

<ul>
  <li>Recevoir chaque paquet touchant la table relative au module de d&eacute;termination de correspondance</li>
  <li>Dire &agrave; netfilter si le paquet correspond aux r&egrave;gles de notre module ou pas</li>
</ul>

<A NAME="367lfindex15">&nbsp;</A>
<H2>2.1 Structures et fonctions disponibles</H2>

Tout d'abord quelques structures de base. Celle-ci est d&eacute;finie dans &lt;<i>linux/netfilter_ipv4/ip_tables.h</i>&gt;.

<br> Si tu as envie d'en apprendre plus sur cette structure et celle pr&eacute;c&eacute;demment pr&eacute;sent&eacute;e pour iptables, tu dois lire
 <a href="http://www.netfilter.org/documentation/HOWTO/netfilter-hacking-HOWTO.html">netfilter hacking howto</a> &eacute;crit par Rusty Russell
 et Harald Welte.

<pre class="code">struct ipt_match
{
   struct list_head list;

   const char name[IPT_FUNCTION_MAXNAMELEN];

   /* Return true or false: return FALSE and set *hotdrop = 1 to
           force immediate packet drop. */
   /* Arguments changed since 2.4, as this must now handle
           non-linear skbs, using skb_copy_bits and
           skb_ip_make_writable. */
   int (*match)(const struct sk_buff *skb,
           const struct net_device *in,
           const struct net_device *out,
           const void *matchinfo,
           int offset,
           int *hotdrop);

   /* Called when user tries to insert an entry of this type. */
   /* Should return true or false. */
   int (*checkentry)(const char *tablename,
           const struct ipt_ip *ip,
           void *matchinfo,
           unsigned int matchinfosize,
           unsigned int hook_mask);

   /* Called when entry of this type deleted. */
   void (*destroy)(void *matchinfo, unsigned int matchinfosize);

   /* Set this to THIS_MODULE. */
   struct module *me;
};
</pre>


<A NAME="367lfindex16">&nbsp;</A>
<H2>2.2 A l'int&eacute;rieur du squelette</H2>

<A NAME="367lfindex17">&nbsp;</A>
<H3>2.2.1 Initialisation</H3>


<p>

Nous initialisons les champs communs de la structure 'ipt_match'.


</p><pre class="code">static struct ipt_match ipaddr_match
= {
</pre>
'Name' est la cha&icirc;ne du nom de fichier de ton module (ie: ipt_ipaddr).
<pre class="code">	.name       = "ipaddr",
</pre>

Les champs suivant sont les fonction de rappel que l'interface utilisera. 'Match' est appel&eacute; lorsque le paquet est pass&eacute; &agrave; ton module.
<pre class="code">	.match      = match,
	.checkentry = checkentry,
	.me         = THIS_MODULE,
};
</pre>

La fonction de votre module noyau init doit appeler 'ipt_register_match()' avec un pointeur sur une structure 'struct ipt_match' pour
s'enregistrer aupr&egrave;s de l'interface de netfilter. Cette fonction est appel&eacute;e au chargement du module.
<pre class="code">static int __init init(void)
{
	printk(KERN_INFO "ipt_ipaddr: init!\n");
	return ipt_register_match(&amp;ipaddr_match);
}
</pre>

La fonction suivante est appel&eacute;e au d&eacute;chargement du module. C'est ici que l'on efface nos r&egrave;gles.
<pre class="code">static void __exit fini(void)
{
	printk(KERN_INFO "ipt_ipaddr: exit!\n");
	ipt_unregister_match(&amp;ipaddr_match);
}
</pre>

Nous passons les fonctions qui seront appel&eacute;es au chargemenr et au d&eacute;chargement du module.
<pre class="code">module_init(init);
module_exit(fini);

</pre>

<A NAME="367lfindex18">&nbsp;</A>
<H3>2.2.2 Fonction match</H3>

La couche tcp/ip de linux dispose de 5 hooks netfilter. Lorsqu'un paquet
arrive, la couche le transmet au hook appropri&eacute;, qui le fait passer dans chaque table
qui le compare &agrave; chaque r&egrave;gle. Lorsque c'est au tour de ton module d'avoir le paquet,
il peut faire son travail.
<pre class="code">static int match(const struct sk_buff *skb,
                 const struct net_device *in,
                 const struct net_device *out,
                 const void *matchinfo,
                 int offset,
                 const void *hdr,
                 u_int16_t datalen,
                 int *hotdrop)
{
</pre>
J'esp&egrave;re que tu te rappelles que nous avons fait la partie utilisateur ! :) Maintenant nous associons la structure copi&eacute;e
dans l'espace utilisateur &agrave; la notre.
<pre class="code">	const struct ipt_skeleton_info *info = matchinfo;
</pre>
'skb' contient le paquet que nous voulons examiner. Pour plus d'information sur cette structure puissante
utilis&eacute;e partout dans la couche tcp/ip de linux, Harald Welte a &eacute;crit un excellent
<a href="ftp://ftp.gnumonks.org/pub/doc/skb-doc.html">article (ftp://ftp.gnumonks.org/pub/doc/skb-doc.html)</a> dessus.
<pre class="code">   struct iphdr *iph = skb-&gt;nh.iph;
</pre>
Ici, nous affichons juste des choses amusantes pour voir &agrave; quoi elles ressemblent.
La macro 'NIPQUAD', utilis&eacute;e pour afficher une adresse IP dans un format lisible, est d&eacute;finie dans
&lt;<i>linux/include/linux/kernel.h</i>&gt;
<pre class="code">   printk(KERN_INFO "ipt_ipaddr: IN=%s OUT=%s TOS=0x%02X "
                    "TTL=%x SRC=%u.%u.%u.%u DST=%u.%u.%u.%u "
                    "ID=%u IPSRC=%u.%u.%u.%u IPDST=%u.%u.%u.%u\n",

                    in ? (char *)in : "", out ? (char *)out : "", iph-&gt;tos,
                    iph-&gt;ttl, NIPQUAD(iph-&gt;saddr), NIPQUAD(iph-&gt;daddr),
                    ntohs(iph-&gt;id), NIPQUAD(info-&gt;ipaddr.src), NIPQUAD(info-&gt;ipaddr.dst)
         );
</pre>
Si l'argument '--ipsrc' a &eacute;t&eacute; fourni nous regardons si l'adresse source
correspond avec celle sp&eacute;cifi&eacute;e dans la r&egrave;gle. Nous n'oublions pas de prendre en consid&eacute;ration
le drapeau inverseur: '!'. Si &ccedil;a ne correspond pas, nous retournons le verdict; 0.
<pre class="code">   if (info-&gt;flags &amp; IPADDR_SRC) {
      if ( (ntohl(iph-&gt;saddr) != ntohl(info-&gt;ipaddr.src)) ^ !!(info-&gt;flags &amp; IPADDR_SRC_INV) ) {

         printk(KERN_NOTICE "src IP %u.%u.%u.%u is not matching %s.\n",
                            NIPQUAD(info-&gt;ipaddr.src),
                            info-&gt;flags &amp; IPADDR_SRC_INV ? " (INV)" : "");
         return 0;
      }
   }
</pre>
Ici, nous faisons de m&ecirc;me, sauf que nous regardons l'adresse de destination si l'argument '--ipdst' a &eacute;t&eacute; fourni.
<pre class="code">   if (info-&gt;flags &amp; IPADDR_DST) {
      if ( (ntohl(iph-&gt;daddr) != ntohl(info-&gt;ipaddr.dst)) ^ !!(info-&gt;flags &amp; IPADDR_DST_INV) )  {

         printk(KERN_NOTICE "dst IP %u.%u.%u.%u is not matching%s.\n",
                            NIPQUAD(info-&gt;ipaddr.dst),
                            info-&gt;flags &amp; IPADDR_DST_INV ? " (INV)" : "");
         return 0;
      }
   }
</pre>
Si les deux &eacute;chouent, nous retournons le verdict 1, qui signifie que le paquet correspond.
<pre class="code">   return 1;
}
</pre>


<A NAME="367lfindex19">&nbsp;</A>
<H3>2.2.3 Fonction checkentry</H3>

Checkentry est utilis&eacute;e la plupart du temps comme une derni&egrave;re chance de correspondance.
C'est un peu difficile de comprendre quand a-t-elle &eacute;t&eacute; appel&eacute;e, regarde &ccedil;a <a href="http://www.mail-archive.com/netfilter-devel@lists.samba.org/msg00625.html">post (http://www.mail-archive.com/netfilter-devel@lists.samba.org/msg00625.html)</a>.
C'est aussi expliqu&eacute; dans le netfilter hacking howto.
<pre class="code">static int checkentry(const char *tablename,
                             const struct ipt_ip *ip,
                             void *matchinfo,
                             unsigned int matchsize,
                             unsigned int hook_mask)
{
   const struct ipt_skeleton_info *info = matchinfo;

   if (matchsize != IPT_ALIGN(sizeof(struct ipt_skeleton_info))) {
      printk(KERN_ERR "ipt_skeleton: matchsize differ, you may have forgotten to recompile me.\n");
      return 0;
   }

   printk(KERN_INFO "ipt_skeleton: Registered in the %s table, hook=%x, proto=%u\n",
                    tablename, hook_mask, ip-&gt;proto);

   return 1;
}

</pre>
<A NAME="367lfindex20">&nbsp;</A>
<H2>2.3 Sommaire du chapitre 2</H2>
Dans ce second chapitre,
nous avons couvert le module netfilter et la mani&egrave;re de l'enregistrer
en utilisant une structure sp&eacute;cifique. Ensuite, nous avons
discut&eacute; de la mani&egrave;re de d&eacute;tecter une certaine situation suivant les
crit&egrave;res fournis par la partie utilisateur.

<A NAME="367lfindex21">&nbsp;</A>
<H2>3.0 Jouer avec iptables/netfilter</H2>
Nous avons vu comment &eacute;crire
un nouveau module de r&egrave;gles iptables/netfilter. Maintenant, nous voulons l'ajouter
dans notre noyau pour jouer avec. Ici, je suppose que tu sais comment construire/compiler
une noyau. Premi&egrave;rement, r&eacute;cup&eacute;rons les sources du squelette depuis <a href="../../common/src2/article367/index.html">La
page de t&eacute;l&eacute;chargement pour cet article</a>.
<A NAME="367lfindex22">&nbsp;</A>
<H3>3.1 iptables</H3>

Maintenant, si tu n'as pas les sources d'iptables, tu peux les t&eacute;l&eacute;charger <a href="ftp://ftp.netfilter.org/pub/iptables/">ftp://ftp.netfilter.org/pub/iptables/</a>.
Ensuite, tu dois copier 'libipt_ipaddr.c' dans &lt;<i>iptables/extensions/</i>&gt;.<br><br>


C'est une ligne de &lt;<i>iptables/extensions/Makefile</i>&gt; dans laquelle tu dois ajouter 'ipaddr'.
<pre class="code">PF_EXT_SLIB:=ah addrtype comment connlimit connmark conntrack dscp ecn
esp hashlimit helper icmp iprange length limit <b>ipaddr</b> mac mark
multiport owner physdev pkttype realm rpc sctp standard state tcp tcpmss
tos ttl udp unclean CLASSIFY CONNMARK DNAT DSCP ECN LOG MARK MASQUERADE
MIRROR NETMAP NOTRACK REDIRECT REJECT SAME SNAT TARPIT TCPMSS TOS TRACE
TTL ULOG
</pre>

<A NAME="367lfindex23">&nbsp;</A>
<H3>3.2 Noyau</H3>


Tout d'abord, tu dois copier 'ipt_ipaddr.c'  dans &lt;<i>linux/net/ipv4/netfilter/</i>&gt; et 'ipt_ipaddr.h'
dans &lt;<i>linux/include/linux/netfilter_ipv4/</i>&gt;.
Certain d'entre vous utilisent encore linux 2.4, donc je vais pr&eacute;senter les fichiers &agrave; &eacute;diter des deux versions.<br><br>

Pour 2.4, &eacute;dites &lt;<i>linux/net/ipv4/netfilter/Config.in</i>&gt; et ajoutes la ligne en gras.
<pre class="code"># The simple matches.
  dep_tristate '  limit match support' CONFIG_IP_NF_MATCH_LIMIT $CONFIG_IP_NF_IPTABLES
<b>  dep_tristate '  ipaddr match support' CONFIG_IP_NF_MATCH_IPADDR $CONFIG_IP_NF_IPTABLES</b>
</pre>

Ensuite, &eacute;dites &lt;<i>linux/Documentation/Configure.help</i>&gt; et ajoutes le texte en gras. J'ai copi&eacute; plus de texte afin de te
permettre de trouver o&ugrave; ajouter le tien.
<pre class="code">limit match support
CONFIG_IP_NF_MATCH_LIMIT
  limit matching allows you to control the rate at which a rule can be
  ...<b>
ipaddr match support
CONFIG_IP_NF_MATCH_IPADDR
  ipaddr matching. etc etc.</b>
</pre>

Finalement, tu dois ajouter cette ligne en gras dans &lt;<i>linux/net/ipv4/netfilter/Makefile</i>&gt;.
<pre class="code"># matches
obj-$(CONFIG_IP_NF_MATCH_HELPER) += ipt_helper.o
obj-$(CONFIG_IP_NF_MATCH_LIMIT) += ipt_limit.o
<b>obj-$(CONFIG_IP_NF_MATCH_IPADDR) += ipt_ipaddr.o</b>
</pre>

Maintenant pour 2.6, les fichiers &agrave; &eacute;diter sont &lt;<i>linux/net/ipv4/netfilter/Kconfig</i>&gt; et &lt;<i>linux/net/ipv4/netfilter/Makefile</i>&gt;.

<A NAME="367lfindex24">&nbsp;</A>
<H2> Conclusion </H2>


Il ne te reste plus qu'&agrave; recompiler et ajouter ce que j'ai oubli&eacute; de te dire.<br>
Joyeux hacking!!

<br>
Merci &agrave; Samuel Jean.


<!-- BODY_OF_THE_ARTICLE_STOP -->
<!-- 2pdaIgnoreStart -->
<A NAME="talkback">&nbsp;</a>
<h2>Talkback form for this article</h2>
Every article has its own talkback page. On this page you can submit a comment or look at comments from other readers:
<center>
    <table width="250" border=0><tr><td>
    <div class="tbbutton"><A class="nodec" href="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=367">&nbsp;talkback page&nbsp;</a></div>
    </td></tr></table>
</center>

<br clear="all">
<HR size="2" noshade>
<table width="250" border=0><tr><td>
<div class="bbutton"><a class="nodec" href="../../index.shtml">&lt;--, LF Sommaire</a></div>
</td><td>
<div class="bbutton"><a class="nodec" href="index.shtml">Sommaire de ce num&eacute;ro</a></div>
</td></tr></table>
<br clear="all">
<HR size="2" noshade>
<!-- ARTICLE FOOT -->
<CENTER><TABLE WIDTH="98%" summary="footer">
<TR><TD ALIGN=CENTER BGCOLOR="#bdc6d5" WIDTH="50%">
<A HREF="../../common/lfteam.html">Site Web maintenu par l&acute;&eacute;quipe d&acute;&eacute;dition LinuxFocus</A>
<BR><FONT COLOR="#1111aa"><a href="../../common/copy.html">&copy; Nicolas Bouliane</a><br>&quot;some rights reserved&quot; see <a href="../../license/index.shtml">linuxfocus.org/license/</a><br><a href="http://www.linuxfocus.org">http://www.LinuxFocus.org</a></FONT>
</TD>
<TD BGCOLOR="#bdc6d5">
<!-- TRANSLATION INFO -->
<font size=2>Translation information:</font>
<TABLE summary="translators">
  <tr><td><font size="2">en --&gt; -- : Nicolas Bouliane <small>&lt;nib(at)cookinglinux!org&gt;</small></font></td></tr>
</TABLE>
</TD>
</TR></TABLE></CENTER>
<p><font size=1>2005-02-17, generated by lfparser version 2.52</font></p>
<!-- 2pdaIgnoreStop -->
</BODY>
</HTML>
