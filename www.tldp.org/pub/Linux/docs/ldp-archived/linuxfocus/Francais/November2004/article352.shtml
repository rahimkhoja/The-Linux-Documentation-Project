<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
 <META http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
 <META NAME="GENERATOR" CONTENT="lfparser_2.52">
 <META NAME="LFCATEGORY" CONTENT="Hardware">
 <link rel="icon" href="../../common/images/lf-16.png" type="image/png">
 <TITLE>lf352, Hardware: Programmer les microcontr&ocirc;leurs AVR avec GCC, libc 1.0.4</TITLE>
<style type="text/css">
<!--
 td.top {font-family: Arial,Geneva,Verdana,Helvetica,sans-serif; font-size:12 }
 pre { font-family:monospace,Courier }
 pre.code { font-family:monospace,Courier;background-color:#aedbe8; }
 p.cl { color:#EE9500 }
 table.left { margin-right:0.3cm }
 a.nodec { text-decoration:none }
 p.trans { font-size:8pt; text-align:right }
 p.clbox { width:50%; alignment:center; background-color:#FFD700; 
           border-style:none; border-width:medium; border-color:#FFD700; 
           padding:0.5cm;  text-align:center }
 p.code { width:80%; alignment:center; background-color:#aedbe8; 
          border-style:none; border-width:medium; border-color:#aedbe8; 
          padding:0.1cm;  text-align:left }
 p.foot { background-color:#AAAAAA; color:#FFFFFF; border-style:none; 
          border-width:medium; border-color:#AAAAAA; padding:0.5cm ; 
          margin-top:0.1cm; margin-right:1cm; margin-left:1cm; 
          text-align:center }
 div.tbbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   margin: 2px 5px 2px 5px;
   text-align: center;
   width: 20em;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
 div.bbutton {
   background: #ddd;
   border-right: 1px solid #aaa;
   border-bottom: 1px solid #aaa;
   float: left;
   margin: 2px 5px 2px 5px;
   text-align: center;
   line-height: 1.2em;
   padding: 2px;
   font-size: 12px;
   white-space: nowrap;
   color: #555;
 }
-->
</style>
 
</HEAD>
<BODY bgcolor="#ffffff" text="#000000">
 <!-- this is generated html code. NEVER use this file for your
 translation work. Instead get the file with the same article number
 and .meta.shtml in its name. Translate this meta file and then
 use lfparser program to generate the final article -->
 <!-- lfparser can be obtained from http://main.linuxfocus.org/~guido/dev/lfparser.html -->

<!-- this is used by a number of tools:
 =LF=AUTHOR: Guido Socher
 =LF=CAT___: Hardware
 =LF=TITLE_: Programmer les microcontr&ocirc;leurs AVR avec GCC, libc 1.0.4
 =LF=NUMBER: 352
 =LF=ANAME_: article352.shtml
 =LF=PARSER: 2.52
 -->

<!-- 2pdaIgnoreStart -->

<!-- start navegation bar, current, style=2 -->
 <!-- top navegation bar -->
 <TABLE summary="topbar_1" cellspacing="0" cellpadding="0" border="0" align="center" width="90%">
   <TR bgcolor="#2e2292">
     <TD class="top"><TABLE summary="topbar_1_logo" cellspacing="0" cellpadding="0" border="0" width=
       "100%">
         <TR><TD width="319"><a href="../../index.shtml"><IMG src="../../common/images/logolftop_319x45.gif"
           alt="[LinuxFocus-icon]" width="319" height="45" align="left" 
           border="0"></a></TD>

           <TD class="top">
             <TABLE summary="topbar_1_links" width="100%">
               <TR align="right">
                 <TD class="top">
                 
                 <A class="nodec" href="../../index.shtml"><FONT color=
                 "#DDDDDD" size="2">&lt;--</FONT></A> &nbsp;| 
                 <A class="nodec" href="../map.html"><FONT color=
                 "#DDDDDD" size="2">Carte</FONT></A> &nbsp;| 
                 <A class="nodec" href="../indice.html"><FONT color=
                 "#DDDDDD" size="2">Index</FONT></A> &nbsp;| 
                 <A class="nodec" href="../Search/index.html"><FONT color=
                 "#DDDDDD" size="2">Recherche</FONT></A> </TD>
                 
               </TR>

               <TR align="right">
                 <TD class="top">
                   <HR width="100%" noshade size="1">
                 </TD>
               </TR>
             </TABLE>
           </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end top navegation bar -->
 <!-- blue bar -->
 <TABLE summary="topbar_2" cellspacing="0" cellpadding="0" border="0" align="center"
 width="90%">
   <TR bgcolor="#00ffff">
     <TD><IMG src="../../common/images/transpix.gif" width="1" height=
     "2" alt=""></TD>
   </TR>
 </TABLE>
 <!-- end blue bar -->
 <!-- bottom navegation bar -->
 <TABLE summary="topbar_3" cellspacing="0" cellpadding="0" border="0" align="center"
 width="94%">
   <TR bgcolor="#000000">
     <TD>
       <TABLE summary="topbar_3_links" cellspacing="0" cellpadding="1" border="0" width=
       "100%">
         <TR align="center">
           <TD WIDTH="20%"><A class="nodec" href="../News/index.shtml"><FONT color=
           "#FFFFFF">Nouvelles</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Archives/index.html"><FONT color=
           "#FFFFFF">Archives</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../Links/index.html"><FONT color=
           "#FFFFFF">Liens</FONT></A> </TD>
           <TD WIDTH="5%"><FONT color="#FFFFFF">|</FONT> </TD>
           <TD WIDTH="20%"><A class="nodec" href="../aboutus.html"><FONT color=
           "#FFFFFF">A propos</FONT></A> </TD>
         </TR>
       </TABLE>
     </TD>
   </TR>
 </TABLE>
 <!-- end bottom navegation bar -->
<!-- stop navegation bar -->

<!-- SSI_INFO -->

<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfdynahead ver 1.5 --><TABLE ALIGN="right" border=0><TR><TD ALIGN="right"><FONT SIZE="-1" FACE="Arial,Helvetica">Ce document est disponible en: <A href="../../English/November2004/article352.shtml">English</a> &nbsp;<A href="../../Castellano/November2004/article352.shtml">Castellano</a> &nbsp;<A href="../../Deutsch/November2004/article352.shtml">Deutsch</a> &nbsp;<A href="../../Francais/November2004/article352.shtml">Francais</a> &nbsp;<A href="../../Italiano/November2004/article352.shtml">Italiano</a> &nbsp;<A href="../../Turkce/November2004/article352.shtml">Turkce</a> &nbsp;</FONT></TD></TR></TABLE><br>
 


<!-- SSI_INFO STOP -->
<!-- 2pdaIgnoreStop -->

<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_START -->
<TABLE ALIGN="LEFT" BORDER="0" WIDTH="195" summary="about the author" class="left">
<TR>
<TD>

<img src="../../common/images/Guido-S.gif"
 alt="[Photo of the Author]" height="164" width="173">
<BR>par  Guido Socher <a href="http://linuxfocus.org/%7Eguido/"><font size="1">(homepage)</font></a>
<BR><BR>
<I>L&acute;auteur:</I><BR>
<!-- aboutauthor_start -->
<p>Guido aime Linux car c'est r&eacute;ellement un bon syst&egrave;me pour d&eacute;velopper
son propre mat&eacute;riel.</p>
<!-- aboutauthor_stop -->
<!-- TRANSLATED_TO fr -->
<BR><BR><I>Traduit en Français par:</I><BR>
Iznogood <small>&lt;iznogood /at/ iznogood-factory.org&gt;</small>
<br>
<!--
 =LF=TRANSTO=fr: Iznogood
-->
<!-- TRANSLATED_TO_STOP -->
<!-- INDEX_START -->
<BR><i>Sommaire</i>:
<UL>
  <LI><A HREF="#352lfindex0">Introduction</A></LI>
  <LI><A HREF="#352lfindex1">Installation logicielle: Ce dont vous avez besoin</A></LI>
  <LI><A HREF="#352lfindex2">Installation logicielle de: GNU binutils</A></LI>
  <LI><A HREF="#352lfindex3">Installation logicielle: AVR gcc</A></LI>
  <LI><A HREF="#352lfindex4">Installation logicielle: La biblioth&egrave;que C AVR</A></LI>
  <LI><A HREF="#352lfindex5">Installation logicielle: Le Programmateur</A></LI>
  <LI><A HREF="#352lfindex6">Un petit projet de test</A></LI>
  <LI><A HREF="#352lfindex7">Mat&eacute;riel n&eacute;cessaire</A></LI>
  <LI><A HREF="#352lfindex8">Fabriquer le mat&eacute;riel du programmateur</A></LI>
  <LI><A HREF="#352lfindex9">&Eacute;crire des programmes</A></LI>
  <LI><A HREF="#352lfindex10">Compiler et charger</A></LI>
  <LI><A HREF="#352lfindex11">Quelques binutils int&eacute;ressants</A></LI>
  <LI><A HREF="#352lfindex12">Id&eacute;es et suggestions</A></LI>
  <LI><A HREF="#352lfindex13">R&eacute;f&eacute;rences</A></LI>
  <LI><A HREF="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=352">Talkback form for this article</A></LI>
</UL>

</TD></TR></TABLE>
<!-- INDEX_STOP -->
<!-- SHORT_BIO_ABOUT_THE_AUTHOR_AND_INDEX_STOP -->
<!-- HEAD_OF_THE_ARTICLE_START -->
<br>&nbsp;
<table border="0"><tr><td>
<!-- tr_staticssi include virtual -->
<!-- tr_staticssi exec cmd -->
<!-- addedByLfPdf ver 0.1 -->
<TABLE style="border-style:outset; border-width:1px" align="right" bgcolor="#ff9616" cellspacing="1"><TR><TD bgcolor="#ff9616">
        <a href="../Archives/lf-2004_11-0352.pdf"><small>PDF</small></a>
        </TD></TR></TABLE>
         

<H2>Programmer les microcontr&ocirc;leurs AVR avec GCC, libc 1.0.4</H2>
 <img src="../../common/images2/article352/illustration.gif"
 alt="[Illustration]" height="148" hspace="10" width="208">
<!-- ABSTRACT OF THE ARTICLE -->
<P><i>R&eacute;sum&eacute;</i>:
<P>
<!-- articleabstract_start -->

Le microcontr&ocirc;leur RISC 8 bits AVR d'Atmel est un microcontr&ocirc;leur tr&egrave;s
commun. Ce microcontr&ocirc;leur est un circuit avec une EEPROM, une Ram, un
convertisseur Analogique vers Num&eacute;rique, beaucoup d'entr&eacute;es/sorties
num&eacute;riques, des compteurs, un UART pour les communications RS232 et
bien d'autres choses. <br><br>
Le meilleur est n&eacute;anmoins qu'un environnement complet de programmation
est disponible sous Linux: Vous pouvez programmer ce microcontr&ocirc;leur en
C en utilisant GCC. <br><br>
J'ai d&eacute;j&agrave; &eacute;crit un <a
 href="../../English/March2002/article231.shtml">article</a>
en Mars 2000 sur le m&ecirc;me sujet. Beaucoup de choses ont chang&eacute; dans le
d&eacute;veloppement d'avr-libc et le microcontr&ocirc;leur AT90S4433 utilis&eacute; en
2002 n'est plus fabriqu&eacute; par Atmel. Cet article est donc une mise &agrave;
jour de celui de Mars 2002. Je vais utiliser libc-1.0.4 et le
microcontr&ocirc;leur ATmega8. <br><br>
Cet article n'est qu'une introduction et dans une prochaine s&eacute;rie
d'articles, nous construirons des circuits int&eacute;ressants mais bas&eacute; cette
fois sur l'ATmega8.

<!-- articleabstract_stop -->

<br><!-- HR divider --><center><font color="#8282e0"><b>_________________ _________________ _________________</b></font></center><br>
</td></tr></table>
<!-- HEAD_OF_THE_ARTICLE_STOP -->
<!-- BODY_OF_THE_ARTICLE_START -->

<A NAME="352lfindex0">&nbsp;</A>
<H2>Introduction</H2>

Plusieurs personnes ont &eacute;t&eacute; int&eacute;ress&eacute;es dans la programmation d'un
microcontr&ocirc;leur, article &eacute;crit en 2002. N&eacute;anmoins la premi&egrave;re &eacute;tape
pour installer l'environnement de d&eacute;veloppement et son lancement est le
plus difficile. Si quelque chose ne fonctionne pas correctement, alors
vous n'avez aucune aide pour conna&icirc;tre l'origine du d&eacute;faut. Est-ce le
c&acirc;ble de programmation? Est-ce le circuit qui est en cause? Une
installation incorrecte? Un port parall&egrave;le d&eacute;sactiv&eacute; dans le bios? Les
modules de noyau pour ppdev mal compil&eacute;s? Il peut y avoir un tas de
raisons pour que les choses aillent mal. <a
 href="http://shop.tuxgraphics.org/electronic/microcontroller.html"><img
 src="../../common/images2/article352/linuxavrcd_th.jpg" align="right"
 height="213" width="150"></a> <br>
<br>
Pour rendre l'entr&eacute;e dans le monde excitant des microcontr&ocirc;leurs plus
facile, <a
 href="http://shop.tuxgraphics.org/electronic/microcontroller.html">shop.tuxgraphics.org</a>
vous offre maintenant un CD bootable avec un manuel et le mat&eacute;riel de
programmation. Tout ce dont vous avez besoin est de d&eacute;marrer depuis le
CD et tout est configur&eacute;, pr&ecirc;t &agrave; fonctionner. Aucune installation
logicielle n'est n&eacute;cessaire et rien n'est modifi&eacute; sur votre ordinateur.
<br>
<br>
J'utilise moi aussi ce CD depuis longtemps car les circuits que je
construis survivent &agrave; plusieurs g&eacute;n&eacute;rations de noyaux et
d'installations de logiciels sur mon PC. Si, plus tard, je veux mettre
&agrave; jour quelques logiciels de microcontr&ocirc;leurs, je n'ai alors pas &agrave; me
demander si le fonctionnement de mon environnement de d&eacute;veloppement sur
mon Linux est encore fonctionnel. Je d&eacute;marre simplement depuis le CD et
tout est pr&ecirc;t &agrave; fonctionner.<br>
<br>
Ind&eacute;pendement de ce CD, je vais expliquer l'installation de
l'environnement de d&eacute;veloppement GCC avr dans les paragraphes suivants.
Si vous avez le CD de tuxgraphics continuez alors avec le chapitre "Un
petit projet de test".
<A NAME="352lfindex1">&nbsp;</A>
<H2>Installation logicielle: Ce dont vous avez besoin</H2>

<p>Pour utiliser l'environnement de d&eacute;veloppement GNU C, vous avez
besoin des logiciels suivants:</p>
<table border="1">
  <tbody>
    <tr>
      <td>binutils-2.15.tar.bz2</td>
      <td>Disponibles depuis:<br>
ftp://ftp.gnu.org/gnu/binutils/<br>
ou tout miroir. I.e:<br>
ftp://gatekeeper.dec.com/pub/GNU/binutils/</td>
    </tr>
    <tr>
      <td>gcc-core-3.4.2.tar.bz2</td>
      <td>Disponible depuis: ftp://ftp.gnu.org/gnu/gcc/<br>
ou tout miroir. I.e:<br>
ftp://gatekeeper.dec.com/pub/GNU/gcc/</td>
    </tr>
    <tr>
      <td>avr-libc-1.0.4.tar.bz2.tar</td>
      <td>La biblioth&egrave;que C pour AVR est disponible depuis:
http://savannah.nongnu.org/projects/avr-libc/</td>
    </tr>
    <tr>
      <td>uisp-20040311.tar.bz2</td>
      <td>Le logiciel de programmation AVR est disponible depuis:
http://savannah.nongnu.org/projects/uisp</td>
    </tr>
  </tbody>
</table>
<br>
<br>
Nous allons installer tous les programmes sur /usr/local/avr. Cela
permet de garder le programme s&eacute;par&eacute; de votre compilateur C Linux.
Cr&eacute;ez ce r&eacute;pertoire avec la commande:
<pre class="code">    mkdir /usr/local/avr <br><br>Vous pouvez d&eacute;j&agrave; l'ajouter &agrave; votre PATH:<br>    mkdir /usr/local/avr/bin<br>    export PATH=/usr/local/avr/bin:${PATH}<br></pre>
<A NAME="352lfindex2">&nbsp;</A>
<H2>Installation logicielle de: GNU binutils</H2>

Le paquet binutils fournit tous les utilitaires bas niveau n&eacute;cessaires
pour construire les fichiers objets. J'ai inclus un assembleur AVR
(avr-as), un linker (avr-ld), des outils de traitement de biblioth&egrave;ques
(avr-ranlib, avr-ar), les programmes pour g&eacute;n&eacute;rer les fichiers objets
chargeables dans l'EEPROM du microcontr&ocirc;leur (avr-objcopy), un
d&eacute;sassembleur (avr-objdump) et des utilitaires tels que avr-strip et
avr-size. <br>
<br>
Lancez les commandes suivantes pour construire et installer les
binutils :
<pre class="code">tar jxvf binutils-2.15.tar.bz2<br>cd binutils-2.15/<br>mkdir obj-avr<br>cd obj-avr<br>../configure --target=avr --prefix=/usr/local/avr --disable-nls<br>make<br><br># comme root:<br>make install<br></pre>
<br>
<br>
Ajoutez la ligne /usr/local/avr/lib au fichier /etc/ld.so.conf et
lancez la commande /sbin/ldconfig pour reconstruire le cache linker.
<A NAME="352lfindex3">&nbsp;</A>
<H2>Installation logicielle: AVR gcc</H2>

avr-gcc sera notre compilateur C. <br>
<br>
Lancez la commande suivante pour le construire et l'installer:
<pre class="code">tar jxvf gcc-core-3.4.2.tar.bz2<br>cd gcc-3.4.2<br><br>mkdir obj-avr<br>cd obj-avr<br>../configure --target=avr --prefix=/usr/local/avr --disable-nls --enable-language=c<br><br>make<br><br># comme root:<br>make install<br>   <br></pre>
<A NAME="352lfindex4">&nbsp;</A>
<H2>Installation logicielle: La biblioth&egrave;que C AVR</H2>

La biblioth&egrave;que C est maintenant assez stable compar&eacute;e &agrave; celle que j'ai
pr&eacute;sent&eacute; en Mars 2002. <br>
Lancez la commande suivante pour la construire et l'installer:
<pre class="code">tar jxvf avr-libc-1.0.4.tar.bz2.tar<br>cd avr-libc-1.0.4<br>PREFIX=/usr/local/avr<br>export PREFIX<br>sh -x ./doconf<br>./domake<br><br>cd build<br>#comme root:<br>make install<br>   <br></pre>
<A NAME="352lfindex5">&nbsp;</A>
<H2>Installation logicielle: Le Programmateur</H2>

Le logiciel du Programmateur charge le code objet sp&eacute;cialement pr&eacute;par&eacute;
dans l'EEPROM de notre microcontr&ocirc;leur. <br>
<br>
Le programmateur uisp pour Linux est tr&egrave;s bon. Il peut &ecirc;tre utilis&eacute;
directement depuis un Makefile. Vous avez simplement &agrave; ajouter une
r&egrave;gle "make load", ce qui vous permet de compiler et charger le
logiciel en une passe. <br>
<br>
uisp est install&eacute; comme suit:
<pre class="code">tar jxvf uisp-20040311.tar.bz2.tar<br>cd uisp-20040311<br>./configure --prefix=/usr/local/avr<br>make<br><br># comme root:<br>make install<br>   <br></pre>
<A NAME="352lfindex6">&nbsp;</A>
<H2>Un petit projet de test</H2>

Nous allons d&eacute;buter avec un petit circuit de test que vous pourrez
&eacute;tendre plus tard. <br>
<br>
Ce circuit peut aussi &ecirc;tre utilis&eacute; comme un simple environnement de
test pour du logiciel plus complexe. Vous pouvez facilement tester le
logiciel charg&eacute; et lier des capteurs ou un &eacute;quipement de mesure. <br>
<br>
Notre programme de test, pr&eacute;sent&eacute; ici, ne fera que clignoter une LED. <br>
<img src="../../common/images2/article352/circuit.gif" height="400" width="600">
<br>
<A NAME="352lfindex7">&nbsp;</A>
<H2>Mat&eacute;riel n&eacute;cessaire</H2>

<img src="../../common/images2/article352/avrm8ledtest_circuit.jpg"
 alt="[test circuit]" align="right" height="286" width="300"><br>
Vous avez besoin des composants list&eacute;s dans la table ci-dessous. Bien
qu'il soit un microcontr&ocirc;leur commun, il peut ne pas &ecirc;tre disponible
dans la boutique du coin mais il le sera chez des distributeurs
d'&eacute;lectronique plus gros comme www.conrad.de (allemagne),
www.selectronic.fr (france), digikey.com (US, CA), etc... <br>
Vous pouvez aussi obtenir le kit complet ou seulement le
microcontr&ocirc;leur sur <a href="http://shop.tuxgraphics.org/">shop.tuxgraphics.org</a>
<br clear="all">
<table border="1" width="70%">
  <tbody>
    <tr>
      <td>1 x ATmega8 version DIP, processeur Atmel 8 bit Avr risc.</td>
    </tr>
    <tr>
      <td>1 x 28 broches 7.5mm support de CI<br>
Le support 28 broches est un peu plus difficile &agrave; obtenir. Ces supports
28 broches sont souvent &agrave; 14mm de large mais nous avons besoin d'un
support &agrave; 7.5mm.</td>
    </tr>
    <tr>
      <td>1 x r&eacute;sistance 10K (code couleur: marron,noir,orange)<br>
1 x r&eacute;sistance 1K (code couleur: marron,noir, rouge)<br>
1 x condensateur &eacute;lectrolytique 10uF<br>
Quelques c&acirc;bles<br>
1 x LED<br>
une plaque pr&eacute;-perc&eacute;e<br>
      </td>
    </tr>
    <tr>
      <td>Ce qui suit est n&eacute;cessaire pour le programmateur <small>(ce
n'est pas n&eacute;cessaire si vous avez le "kit de programmation AVR Linux de
tuxgraphics)</small>:<br>
1 x connecteur DB25 &agrave; brancher sur le port parall&egrave;le.<br>
Tout type de connecteur/support &agrave; 5 broches pour le programmateur. Je
recommande l'utilisation de connecteurs tulipes (similaires aux
supports de circuits) et d'en d&eacute;tacher 5 broches.<br>
1 x r&eacute;sistance 220 Ohms (code couleur: rouge, rouge, marron)<br>
3 x r&eacute;sistance 470 Ohms (code couleur: jaune, violet, marron)<br>
      </td>
    </tr>
  </tbody>
</table>
En plus des composants ci-dessus, vous avez besoin d'une alimentation
DC de 5V &eacute;lectroniquement stabilis&eacute;e ou vous pouvez utiliser une pile
de 4.5V comme alimentation. <br>
<br>
Vous avez probablement remarqu&eacute; que nous n'avons pas besoin de quartz.
C'est parce que l'ATmega8 poss&egrave;de maintenant un oscillateur int&eacute;gr&eacute;.
Cet oscillateur peut &ecirc;tre utilis&eacute; lorsque la gestion du temps n'est pas
vitale. Si vous voulez n&eacute;anmoins construire un &eacute;quipement de mesure
pr&eacute;cis ou si vous souhaitez utiliser l'interface UART/RS232 alors, vous
avez besoin d'un quartz. Le type d'oscillateur utilis&eacute; peut &ecirc;tre d&eacute;fini
par les bits fusibles que vous pouvez modifier avec le programmateur.
Par d&eacute;faut (configuration d'usine), l'oscillateur d'1Mhz est actif.
<A NAME="352lfindex8">&nbsp;</A>
<H2>Fabriquer le mat&eacute;riel du programmateur</H2>

Les microcontr&ocirc;leurs AVR permettent la programmation in situ (ISP). <img
 src="../../common/images2/article352/avr_programmer.jpg"
 alt="[Linux AVR programmer]" align="right" height="303" width="300"><br>
Cela signifie que vous n'avez pas besoin de retirer le microcontr&ocirc;leur
de la carte pour le programmer. Vous verrez que vous pouvez obtenir
diff&eacute;rents mat&eacute;riels de programmation pour 50-150 Euro. N&eacute;anmoins, avec
Linux, il est aussi possible de fabriquer un programmateur tr&egrave;s simple
qui fait le travail. Vous avez besoin d'un port parall&egrave;le libre sur
votre ordinateur et du c&acirc;ble suivant. <br>
<br>
Notez que c'est un programmateur am&eacute;lior&eacute; compar&eacute; &agrave; celui pr&eacute;sent&eacute; dans
l'article de Mars 2002. Nous pla&ccedil;ons les r&eacute;sistances de protection dans
le programmateur. Cela permettra de pr&eacute;server un peu d'espace et des
composants sur la carte. Le c&acirc;blage pour le c&acirc;ble de programmation doit
&ecirc;tre comme suit: <br>
<table bgcolor="#cdcdcd" border="1">
  <tbody>
    <tr>
      <th>broche sur pcb</th>
      <th>broche sur AVR</th>
      <th>r&eacute;sistance de protection</th>
      <th>broche sur port parall&egrave;le</th>
    </tr>
    <tr>
      <td>5</td>
      <td>Reset (1)</td>
      <td>--</td>
      <td>Init (16)</td>
    </tr>
    <tr>
      <td>4</td>
      <td>MOSI (17)</td>
      <td>470 Ohms</td>
      <td>D0 (2)</td>
    </tr>
    <tr>
      <td>3</td>
      <td>MISO (18)</td>
      <td>220 Ohms</td>
      <td>Busy (11)</td>
    </tr>
    <tr>
      <td>2</td>
      <td>SCK (19)</td>
      <td>470 Ohms</td>
      <td>Strobe (1)</td>
    </tr>
    <tr>
      <td>1</td>
      <td>GND</td>
      <td>--</td>
      <td>GND (18)</td>
    </tr>
  </tbody>
</table>
<br>
Le c&acirc;ble ne doit pas faire plus de 70cm. <br>
<br>
Les r&eacute;sistances de protection peuvent &ecirc;tre plac&eacute;es dans le connecteur
comme montr&eacute; sur l'image &agrave; droite.
<A NAME="352lfindex9">&nbsp;</A>
<H2>&Eacute;crire des programmes</H2>

L'ATmega8 peut &ecirc;tre programm&eacute; en C pur avec l'aide de gcc. La
connaissance de l'assembleur AVR peut &ecirc;tre utile mais n'est pas
n&eacute;cessaire. <br>
<br>
La libc AVR est fournie avec <a
 href="../../common/src2/article352/avr-libc-user-manual-1.0.4.pdf">avr-libc-user-manual-1.0.4.pdf
(1139921 octets)</a> qui documente toutes les fonctions disponibles en
C. Sur le site d'Atmel (<a href="http://www.atmel.com/">www.atmel.com</a>,
allez dans: avr products -&gt; 8 bit risc-&gt; Datasheets), vous pouvez
y t&eacute;l&eacute;charger la documentation technique compl&egrave;te. Elle d&eacute;crit tous les
registres et comment utiliser le CPU. <br>
<br>
Une chose &agrave; garder en m&eacute;moire lors de l'utilisation d'un
microcontr&ocirc;leur est qu'il ne poss&egrave;de que peu d'octets en m&eacute;moire vive.
Cela signifie que vous ne devez pas d&eacute;clarer de grandes structures de
donn&eacute;es ou des cha&icirc;nes de caract&egrave;re. Votre programme ne doit pas
utiliser des fonctions avec beaucoup de niveaux d'imbrications ou de
r&eacute;cursions. <br>
<br>
Rien de mieux qu'un peu de pratique &agrave; la place des grandes th&eacute;ories.
Nous allons &eacute;crire un programme qui fait clignoter notre LED avec un
intervalle de 0.5 secondes. Pas tr&egrave;s utile mais tr&egrave;s bon pour d&eacute;buter. <br>
<br>
avr-libc a beaucoup chang&eacute;. Avant, vous positionniez un bit sur un port
avec sbi et vous l'effaciez avec cbi. Ces fonctions sont maintenant
obsol&egrave;tes. Je pr&eacute;sente d'abord la "bonne vieille m&eacute;thode":
<pre class="code">    /* defines for future compatibility */<br>    #ifndef cbi<br>    #define cbi(sfr, bit) (_SFR_BYTE(sfr) &amp;= ~_BV(bit))<br>    #endif<br>    #ifndef sbi<br>    #define sbi(sfr, bit) (_SFR_BYTE(sfr) |= _BV(bit))<br>    #endif<br><br>    void main(void)<br>    {<br>          /* INITIALIZE */<br>          /* enable PC5 as output */<br>          sbi(DDRC,PC5);<br><br>          <br>          /* BLINK, BLINK ... */<br>          while (1) {<br>                /* led on, pin=0 */<br>                cbi(PORTC,PC5);<br>                delay_ms(500);<br>                /* set output to 5V, LED off */<br>                sbi(PORTC,PC5);<br>                delay_ms(500);<br>          }<br>    }<br>   <br></pre>
L'exemple suivant fait exactement la m&ecirc;me chose mais utilise la
nouvelle syntaxe:
<pre class="code">    void main(void)<br>    {<br>          /* INITIALIZE */<br>          /* enable PC5 as output */<br>          DDRC|= _BV(PC5);<br><br>          <br>          /* BLINK, BLINK ... */<br><br>          /* PC5 is 5 (see file include/avr/iom8.h) and _BV(PC5) is 00100000 */<br>          while (1) {<br>                /* led on, pin=0 */<br>                PORTC&amp;= ~_BV(PC5);<br>                delay_ms(500);<br>                /* set output to 5V, LED off */<br>                PORTC|= _BV(PC5);<br>                delay_ms(500);<br>          }<br>    }<br>   <br></pre>
Le petit bout de code ci-dessus montre comme il est facile d'&eacute;crire un
programme. Vous voyez seulement le programme principal, la fonction
delay_ms est incluse dans le <a
 href="../../common/src2/article352/avrm8ledtest.c.html">listing
complet (avrm8ledtest.c)</a>. Pour utiliser la broche PC5 comme sortie,
vous avez besoin d'initialiser le bit PC5 dans le registre de direction
de donn&eacute;es pour le port C (DDRC). Apr&egrave;s ceci, vous pouvez mettre PC5 &agrave;
0V avec la fonction cbi(PORTC,PC5) (clear bit PC5) ou &agrave; 5V avec
sbi(PORTC,PC5) (set bit PC5). La valeur de "PC5" est d&eacute;finie dans
iom8.h qui est incluse par io.h. Vous n'avez pas &agrave; vous en inqui&eacute;ter.
Si vous avez d&eacute;j&agrave; &eacute;crit des programmes pour multi-utilisateurs / des
syst&egrave;mes multi-t&acirc;ches tels que Linux, vous savez qu'il ne faut jamais
programmer une boucle sans fin non bloqu&eacute;e. Cela serait une perte de
temps CPU et cela ralentirait de beaucoup le syst&egrave;me. Dans le cas de
l'AVR, c'est diff&eacute;rent. Nous n'avons pas plusieurs t&acirc;ches et il n'y a
pas d'autre programme. Il n'y a m&ecirc;me pas de syst&egrave;me d'exploitation. Il
est consid&eacute;r&eacute; comme normal d'occuper des boucles ind&eacute;finiment.
<A NAME="352lfindex10">&nbsp;</A>
<H2>Compiler et charger</H2>

Avant de d&eacute;marrer, assurez-vous que /usr/local/avr/bin est dans le
PATH. Si n&eacute;cessaire, &eacute;ditez votre .bash_profile ou .tcshrc et ajoutez:
<p class="code">export PATH=/usr/local/avr/bin:${PATH} (pour bash)<br>
setenv PATH /usr/local/atmel/bin:${PATH} (pour tcsh)</p>
Nous utilisons le port parall&egrave;le et uisp pour programmer l'AVR. Uisp
utilise l'interface ppdev du noyau. Vous devez donc avoir les modules
de noyau suivants charg&eacute;s:
<pre class="code">    # /sbin/lsmod<br>    parport_pc<br>    ppdev<br>    parport<br></pre>
Contr&ocirc;lez avec la commande /sbin/lsmod qu'ils sont charg&eacute;s et si ce
n'est pas le cas, chargez-les (comme root) avec:
<pre class="code">    modprobe parport<br>    modprobe parport_pc<br>    modprobe ppdev<br>   <br></pre>
Une bonne id&eacute;e est d'ex&eacute;cuter ces commandes automatiquement au
d&eacute;marrage. Vous pouvez les ajouter comme un script rc (i.e. pour Redhat
/etc/rc.d/rc.local). <br>
Pour utiliser l'interface ppdev comme utilisateur normal, root doit
vous donner l'acc&egrave;s en &eacute;criture en lan&ccedil;ant la commande suivante une
fois
<p class="code">chmod 666 /dev/parport0</p>
Assurez-vous aussi qu'aucun d&eacute;mon d'impression ne fonctionne sur le
port parall&egrave;le. Si vous en avez un qui tourne, arr&ecirc;tez-le avant de
connecter le c&acirc;ble de programmation. Maintenant, tout est pr&ecirc;t pour
compiler et programmer notre microcontr&ocirc;leur.<br>
<br>
Le paquet pour notre programme de test, (<a
 href="../../common/src2/article352/avrm8ledtest-0.1.tar.gz">avrm8ledtest-0.1.tar.gz</a>)
inclut un make file. Tout ce que vous avez &agrave; faire est de saisir:<br>
<br>
make <br>
make load<br>
<br>
Cela compilera et chargera le logiciel. Je ne vais pas entrer dans les
d&eacute;tails de toutes les commandes. Vous pouvez les voir dans le <a
 href="../../common/src2/article352/Makefile.html">Makefile</a>
et elles sont toujours identiques. Je ne peux pas toutes me les
rappeler. J'ai juste besoin de savoir utiliser "make load". Si vous
voulez &eacute;crire un programme diff&eacute;rent, remplacez alors toutes les
occurences de avrm8ledtest dans le Makefile avec le nom de votre
programme.
<A NAME="352lfindex11">&nbsp;</A>
<H2>Quelques binutils int&eacute;ressants</H2>

Quelques binutils sont plus int&eacute;ressant que le processus de compilation
actuel.<br>
Ces utilitaires n'ont n&eacute;anmoins pas beaucoup chang&eacute; depuis Mars 2002.
Jetez un coup d'oeil au chapitre "Quelques "binutils" int&eacute;ressants" sur
<a href="../../Francais/March2002/article231.shtml">l'article231
de Mars 2002</a>.
<A NAME="352lfindex12">&nbsp;</A>
<H2>Id&eacute;es et suggestions</H2>

L'ATmega8 est compatible &agrave; l'AT90S4433 pour la plupart des
utilisations. Vous devez programmer les bits fusible pour utiliser
l'oscillateur externe et les circuits pr&eacute;c&eacute;demment pr&eacute;sent&eacute;s devraient
fonctionner avec quelques changements mineurs. Malheureusement, je n'ai
pas encore le temps de re-tester tous les circuits pour l'ATmega8. Si
vous voulez la s&eacute;curit&eacute;, utilisez l'AT90S4433 pour les vieux articles.
Si vous n'avez pas peur de trouver et r&eacute;gler des probl&egrave;mes, tentez
alors l'ATmega8 avec les vieux articles/circuits. <br>
<br>
Vous avez ici une liste des pr&eacute;c&eacute;dents articles sur des circuits:
<ul>
  <li><a href="../../English/May2002/article236.shtml">Un
panneau de contr&ocirc;le LCD pour votre serveur Linux</a></li>
  <li><a
 href="../../English/November2002/article251.shtml">Alimentation
pilot&eacute;e par micro-contr&ocirc;leur</a></li>
  <li><a
 href="../../English/September2002/article253.shtml">Un
compteur de fr&eacute;quence 1Hz-100Mhz avec afficheur LCD et interface RS232</a></li>
  <li><a href="../../English/March2003/article286.shtml">Affichage
LCD USB sous Linux avec chien de garde et boutons</a></li>
  <li><a href="../../English/July2003/article297.shtml">Construire
un robot autonome d&eacute;tecteur de lumi&egrave;re</a></li>
</ul>
<br>
<br>
Notez que le programmateur pr&eacute;sent&eacute; ici inclus d&eacute;j&agrave; les r&eacute;sistances de
protection qui ont &eacute;t&eacute; plac&eacute;es sur la carte dans les pr&eacute;c&eacute;dents
articles avec des circuits. Pour utiliser le nouveau programmateur avec
les anciennes cartes, vous avez simplement &agrave; remplacer les r&eacute;sistances
de protection sur la carte avec des fils.
<A NAME="352lfindex13">&nbsp;</A>
<H2>R&eacute;f&eacute;rences</H2>

<ul>
  <li>L'AVRlib de Pascal Stang: <a
 href="http://www.procyonengineering.com/avr/avrlib/index.html">http://www.procyonengineering.com/avr/avrlib/index.html</a>
ou <a href="http://hubbard.engr.scu.edu/embedded/avr/avrlib/">http://hubbard.engr.scu.edu/embedded/avr/avrlib/</a></li>
  <li>l'assembleur tavrasm pour Linux: <a
 href="http://www.tavrasm.org/">www.tavrasm.org</a></li>
  <li><b>Tous les logiciels et documents <a href="../../common/src2/article352/index.html">mentionn&eacute;s dans
cet article</a></b></li>
  <li>Le site web d'atmel: <a href="http://www.atmel.com/">www.atmel.com</a></li>
  <li>Les pages d'&eacute;lectronique de la boutique tuxgraphics:
    <a href="http://shop.tuxgraphics.org/">shop.tuxgraphics.org</a>
    <br>
(Vous pouvez y obtenir le CD de programmation AVR pour Linux, les kits
et les microcontr&ocirc;leurs) </li>
</ul>
<!-- vim: set sw=2 ts=2 et tw=80: -->



<!-- BODY_OF_THE_ARTICLE_STOP -->
<!-- 2pdaIgnoreStart -->
<A NAME="talkback">&nbsp;</a>
<h2>Talkback form for this article</h2>
Every article has its own talkback page. On this page you can submit a comment or look at comments from other readers:
<center>
    <table width="250" border=0><tr><td>
    <div class="tbbutton"><A class="nodec" href="http://cgi.linuxfocus.org/cgi-bin/lftalkback?anum=352">&nbsp;talkback page&nbsp;</a></div>
    </td></tr></table>
</center>

<br clear="all">
<HR size="2" noshade>
<table width="250" border=0><tr><td>
<div class="bbutton"><a class="nodec" href="../../index.shtml">&lt;--, LF Sommaire</a></div>
</td><td>
<div class="bbutton"><a class="nodec" href="index.shtml">Sommaire de ce num&eacute;ro</a></div>
</td></tr></table>
<br clear="all">
<HR size="2" noshade>
<!-- ARTICLE FOOT -->
<CENTER><TABLE WIDTH="98%" summary="footer">
<TR><TD ALIGN=CENTER BGCOLOR="#bdc6d5" WIDTH="50%">
<A HREF="../../common/lfteam.html">Site Web maintenu par l&acute;&eacute;quipe d&acute;&eacute;dition LinuxFocus</A>
<BR><FONT COLOR="#1111aa"><a href="../../common/copy.html">&copy; Guido Socher</a><br>&quot;some rights reserved&quot; see <a href="../../license/index.shtml">linuxfocus.org/license/</a><br><a href="http://www.linuxfocus.org">http://www.LinuxFocus.org</a></FONT>
</TD>
<TD BGCOLOR="#bdc6d5">
<!-- TRANSLATION INFO -->
<font size=2>Translation information:</font>
<TABLE summary="translators">
  <tr><td><font size="2">en --&gt; -- : Guido Socher (<a href="http://linuxfocus.org/%7Eguido/"><font size="1">homepage</font></a>)</font></td></tr>
  <tr><td><font size="2">en --&gt; fr: Iznogood &lt;iznogood /at/ iznogood-factory.org&gt;</font></td></tr>
</TABLE>
</TD>
</TR></TABLE></CENTER>
<p><font size=1>2005-01-21, generated by lfparser version 2.52</font></p>
<!-- 2pdaIgnoreStop -->
</BODY>
</HTML>
