<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<TITLE>garl11</TITLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" VLINK="#800080" BGCOLOR="#ffffff">

<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=4 WIDTH=737>
<TR><TD WIDTH="46%" VALIGN="TOP">
      <P><a href="garl10.htm"><IMG SRC="left.gif" WIDTH=36 HEIGHT=34 border="0"></a>
    </TD>
<TD WIDTH="11%" VALIGN="TOP">
      <P ALIGN="CENTER"><a href="garl.htm"><IMG SRC="up.gif" WIDTH=34 HEIGHT=36 border="0"></a>
    </TD>
<TD WIDTH="43%" VALIGN="TOP">
      <P ALIGN="RIGHT"><a href="garl12.htm"><IMG SRC="right.gif" WIDTH=36 HEIGHT=34 border="0"></a>
    </TD>
</TR>
</TABLE>

<FONT FACE="Verdana" SIZE=2><P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=4 COLOR="#000080"><P ALIGN="CENTER">Cap&iacute;tulo 11</P>
</font></B><P><HR><p></P>
<B><U><FONT FACE="Verdana" SIZE=2><P>El Sistema Ficheros en Red (NFS)</P>
</font></u></B><FONT FACE="Verdana" SIZE=2>
<P>NFS, acr&oacute;nimo de Network File System, que nosotros llamaremos Sistema 
  de Ficheros en Red, es probablemente el servicio m&aacute;s complejo de los 
  que se ofrecen usando RPC. Permite acceder a los ficheros remotos exactamente 
  igual que si fueran locales. Esto se hace programando parte de la funcionalidad 
  a nivel del n&uacute;cleo (en el lado del cliente) y la otra parte como un demonio 
  servidor. El acceso a los ficheros es totalmente transparente al cliente, funcionando 
  con muchas arquitecturas de servidores.</P>
<P>NFS ofrece numerosas ventajas:</P>
</FONT><B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#ff0000"><B>o</b></font><FONT FACE="Verdana" SIZE=2> Los datos accedidos por todo tipo de usuarios pueden mantenerse en un nodo central, con clientes que montan los directorios en el momento de arrancar. Por ejemplo, puede mantener todas las cuentas de usuario en una m&aacute;quina, y hacer que las dem&aacute;s monten dichas cuentas en su directorio /home por NFS. Si adem&aacute;s se instala NIS, los usuarios podr&iacute;an entrar y trabajar de forma transparente en cualquiera de las m&aacute;quinas.</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#ff0000"><B>o</b></font><FONT FACE="Verdana" SIZE=2> Los datos que consumen grandes cantidades de espacio de disco pueden mantenerse en un nodo. Por ejemplo, mantener una sola copia de LATEX en lugar de copiarlo en cada nodo.</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#ff0000"><B>o</b></font><FONT FACE="Verdana" SIZE=2> Los datos de administraci&oacute;n pueden tambi&eacute;n mantenerse en un solo nodo. Ya no ser&aacute; necesario usar rcp para instalar el mismo fichero en 20 m&aacute;quinas distintas.</font></P>
<FONT FACE="Verdana" SIZE=2> 
<P>El NFS de Linux es, principalmente, obra de Rick Sladkey,1, pues escribi&oacute; 
  el c&oacute;digo que corresponde al n&uacute;cleo y buena parte del c&oacute;digo 
  del servidor NFS. Este &uacute;ltimo es una modificaci&oacute;n del servidor 
  unfsd que corre en espacio de usuario, escrito originalmente por Mark Shand, 
  y el servidor hnfs (Harris NFS) escrito por Donald Becker.</P>
<P>_____________________________________________<BR>
  1 Puede contactar con Rick en la direcci&oacute;n jrs@world.std.com</P>
<P>&nbsp;</P>
<P>Veamos ahora un poco como funciona NFS: un cliente puede solicitar montar un 
  directorio desde un servidor remoto, de forma similar a como montar&iacute;a 
  un directorio local. Sin embargo, la sintaxis no es exactamente igual. Por ejemplo, 
  para montar el directorio /home del nodo vlager en el directorio /users de vale, 
  el administrador escribir&iacute;a el siguiente comando en vale:2</P>
<DIR> 
  <DIR> 
    <P># mount -t nfs vlager:/home /users</P>
  </DIR>
</DIR>
<P>mount intentar&aacute; conectar con el demonio remoto mountd mediante RPC. 
  El servidor comprobar&aacute; si la m&aacute;quina vale tiene permiso para montar 
  el directorio pedido, y si es as&iacute; retornar&aacute; un descriptor de fichero. 
  Este descriptor se utilizar&aacute; en todas las peticiones que sobre ficheros 
  de /users se realicen posteriormente.</P>
<P>Cuando alguien accede a un fichero remoto, el n&uacute;cleo manda una llamada 
  RPC al programa nfsd (demonio de NFS) del nodo remoto. Esta llamada incluye 
  el descriptor de fichero, el nombre del fichero a acceder y los identificadores 
  de usuario y de grupo del demandante. Estos identificadores se usan para chequear 
  permisos de acceso en la m&aacute;quina remota, con lo que los usuarios de ambas 
  m&aacute;quinas deber&iacute;an ser los mismos.</P>
<P>En varias implementaciones de UNIX, las funcionalidades de cliente y servidor 
  NFS se realizan como demonios de nivel de n&uacute;cleo que se arrancan desde 
  el espacio de usuario al arrancar la m&aacute;quina. Se trata del programa nfsd 
  en el servidor y del programa biod (Block I/O Daemon, o demonio de E/S3 por 
  bloques) en el cliente. Para aumentar el rendimiento, biod realiza E/S as&iacute;ncrona, 
  y a veces corren concurrentemente varios servidores de NFS.</P>
<P>La implementaci&oacute;n de NFS en Linux es algo diferente: el c&oacute;digo 
  de cliente est&aacute; integrado en la capa de sistema de ficheros virtual (VFS) 
  y no requiere control adicional mediante el programa biod. Por otro lado, el 
  c&oacute;digo de servidor corre totalmente en el espacio de usuario, por lo 
  que ejecutar varias copias del nfsd resulta imposible debido a los problemas 
  de sincronizaci&oacute;n que originar&iacute;a.</P>
<P>El mayor problema con el c&oacute;digo NFS de Linux es que el n&uacute;cleo 
  1.0 no puede manejar bloques de memoria de mas de 4Kb, por lo que el c&oacute;digo 
  de red no puede manejar datagramas de un tama&ntilde;o mayor que 3500 octetos 
  una vez eliminadas las cabeceras. Esto significa que las transferencias con 
  servidores NFS que utilicen datagramas grandes por defecto (por ejemplo, los 
  8Kb de SunOS) necesitan ser reducidos artificialmente. Esto produce perdidas 
  de rendimiento en ciertas circunstancias.4 Esta limitaci&oacute;n desapareci&oacute; 
  en los n&uacute;cleos posteriores al 1.1, reescribi&eacute;ndose el c&oacute;digo 
  del cliente para aprovechar la nueva situaci&oacute;n.</P>
<P>_____________________________________________<BR>
  2 Observar que puede omitirse la opci&oacute;n -t nfs, ya que el programa mount 
  sabe por la aparici&oacute;n de los dos puntos (:) que se trata de un sistema 
  NFS.<BR>
  3 N. del T.: E/S es Entrada/Salida<BR>
  4 Como me explic&oacute; Alan Cox: La especificaci&oacute;n de NFS requiere 
  que el servidor guarde cada escritura en disco antes de retornar un reconocimiento 
  al cliente (ACK). Como los n&uacute;cleos de BSD solo manejan</P>
<P>&nbsp;</P>
</FONT> 
<blockquote>
  <p><FONT FACE="Verdana" SIZE=2><a href="garl11.htm#11.1">11.1 Preparaci&oacute;n 
    de NFS</a><br>
    <a href="garl11.htm#11.2">11.2 Montaje de un volumen NFS</a><br>
    <a href="garl11.htm#11.3">11.3 Demonios de NFS</a><br>
    <a href="garl11.htm#11.4">11.4 El fichero exports</a><br>
    <a href="garl11.htm#11.5">11.5 El sistema de automontado en Linux</a></FONT></p>
</blockquote>
<B><U><FONT FACE="Verdana" SIZE=2 COLOR="#008080"><P><a name="11.1"></a>11.1 Preparaci&oacute;n de NFS</P>
</font></u></B><FONT FACE="Verdana" SIZE=2>
<P>Antes de usar NFS, sea en cliente o servidor, debe asegurarse de que el n&uacute;cleo tiene el soporte incluido. Los n&uacute;cleos modernos informan de ello a trav&eacute;s del sistema /proc, con un comando como el siguiente:</P><DIR>
<DIR>

<P>$ cat /proc/filesystems<BR>
minix<BR>
ext2<BR>
msdos<BR>
nodev proc<BR>
nodev nfs</P></DIR>
</DIR>

<P>Si no aparece la palabra nfs, tendr&aacute; que recompilar el n&uacute;cleo con el soporte NFS habilitado. Sobre como configurar el n&uacute;cleo hablamos en la secci&oacute;n "Configuraci&oacute;n del N&uacute;cleo" del cap&iacute;tulo 3.</P>
<P>Con versiones del n&uacute;cleo anteriores a la 1.1, la forma de comprobarlo es intentar montar un sistema NFS de prueba, de la siguiente forma:</P><DIR>
<DIR>

<P># mkdir /tmp/test<BR>
# mount localhost:/etc /tmp/test</P></DIR>
</DIR>

<P>Si el comando mount falla con el mensaje "fs type nfs no supported by kernel" (sistema tipo NFS no soportado por el n&uacute;cleo), deber&aacute; recompilar el n&uacute;cleo habilitando NFS. Otro tipo de errores no implican recompilar el n&uacute;cleo, ya que se producen al no estar corriendo el programa nfsd.</P>
<P>&nbsp;</P>
</FONT><B><U><FONT FACE="Verdana" SIZE=2 COLOR="#008080">
<P><a name="11.2"></a>11.2 Montaje de un volumen NFS</P>
</font></u></B><FONT FACE="Verdana" SIZE=2>
<P>Los vol&uacute;menes NFS5 se montan como los sistemas de ficheros usuales. Se trata de llamar al comando mount con la sintaxis:</P><DIR>
<DIR>

<P># mount -t nfs volumen_nfs directorio_local opciones</P></DIR>
</DIR>

<P>_____________________________________________</P>
<P>5 Hablamos de vol&uacute;menes, y no de sistemas de ficheros, porque no lo son realmente: pueden ser solo directorios de un sistema.</P>
<P>&nbsp;</P>
<P>La parte volumen_nfs se especifica con la sintaxis "nodo_remoto :directorio_remoto".</P>
<P>Dado que esta notaci&oacute;n es propia del NFS, la opci&oacute;n -t nfs resulta redundante.</P>
<P>Hay otras opciones que pueden incluirse en el programa mount, que van tras el modificador -o en la l&iacute;nea de comando o en el campo de opciones de la entrada correspondiente en el fichero /etc/fstab. En ambos casos, las distintas opciones deben separarse por comas.</P>
<P>Las opciones que se especifiquen en la l&iacute;nea de comandos tendr&aacute;n preferencia sobre otras que se indiquen en /etc/fstab.</P>
<P>Una entrada de ejemplo del fichero /etc/fstab podr&iacute;a ser</P><DIR>
<DIR>

<P># volumen directorio tipo opciones<BR>
news:/usr/spool/news /usr/spool/news nfs timeo=14,intr</P></DIR>
</DIR>

<P>Ahora el volumen anterior puede montarse con la orden</P><DIR>
<DIR>

<P># mount news:/usr/spool/news</P></DIR>
</DIR>

<P>Ante la ausencia de una entrada en fstab, las llamadas al programa mount se hacen m&aacute;s inc&oacute;modas. Por ejemplo, puede que tenga que teclear cosas como &eacute;sta, para especificar que se limite el tama&ntilde;o del datagrama a 2 Kb:</P><DIR>
<DIR>

<P># mount moonshot:/home /home -o rsize=2048,wsize=2048</P></DIR>
</DIR>

<P>La lista de todas las opciones v&aacute;lidas para mount se encuentra descrita en la p&aacute;gina de ayuda nfs(5) que viene con la utilidad de montaje de Rick Sladkey, que forma parte del paquete util-linux de Rik Faith. Las opciones m&aacute;s interesantes son las siguientes:</P>
</FONT><B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>rsize=n y wsize=n<BR>
</b></font><FONT FACE="Verdana" SIZE=2>Especifican el tama&ntilde;o de datagrama utilizado por el cliente NFS en las peticiones de lectura y escritura, respectivamente. Por defecto, cada una de ellas vale 1024 octetos, dados los l&iacute;mites del tama&ntilde;o de datagrama UDP ya comentados.</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>timeo=n <BR>
</b></font><FONT FACE="Verdana" SIZE=2>Esta opci&oacute;n establece el tiempo m&aacute;ximo de espera de respuesta a una petici&oacute;n del cliente NFS; en cent&eacute;simas de segundo. Por defecto, este valor es de 0.7 segundos.</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>hard<BR>
</b></font><FONT FACE="Verdana" SIZE=2>Marca el montaje del volumen como f&iacute;sico. Es un valor por defecto.</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>soft<BR>
</b></font><FONT FACE="Verdana" SIZE=2>Hace que el montaje sea solo l&oacute;gico (opuesto al anterior).</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>intr<BR>
</b></font><FONT FACE="Verdana" SIZE=2>Esta opci&oacute;n habilita la posibilidad de que una se&ntilde;al interrumpa una espera por NFS.<BR>
Es &uacute;til para poder abortarla cuando el servidor no responde.</font></P><FONT FACE="Verdana" SIZE=2>
<P>Cuando el cliente realiza una petici&oacute;n al servidor NFS, esperar&aacute; un tiempo m&aacute;ximo (el que se especifica en la opci&oacute;n timeout). Si no hay confirmaci&oacute;n tras ese tiempo (tiempo que se denomina "de expiraci&oacute;n" o timeout) tiene lugar otra espera, "de expiraci&oacute;n secundaria" o minor timeout, en el que la operaci&oacute;n se reintenta pero doblando el tiempo de expiraci&oacute;n inicial. Tras 60 segundos, se retorna a la expiraci&oacute;n principal o major timeout.</P>
<P>Por defecto, la expiraci&oacute;n principal har&aacute; que el cliente env&iacute;e un mensaje a la consola y empiece de nuevo, con una expiraci&oacute;n del doble de tiempo. Potencialmente, esto podr&iacute;a mantenerse eternamente. En este caso se habla de montaje f&iacute;sico o hard-mount. La otra variedad, el montaje l&oacute;gico o soft-mount, genera un mensaje de error de E/S al proceso llamante cuando se produce la expiraci&oacute;n principal. El error no se propaga al proceso hasta que hace una nueva llamada a write(2), por lo que esto, junto con la pol&iacute;tica de escritura desde la cache, hace que no se sepa realmente si una operaci&oacute;n de escritura ha tenido &eacute;xito o no, a menos que el volumen est&eacute; montado de forma f&iacute;sica.</P>
<P>En general, se recomienda el montaje f&iacute;sico salvo en caso de tratarse de informaci&oacute;n no cr&iacute;tica, como la de servidores de FTP o particiones de noticias. En entornos cr&iacute;ticos (por ejemplo, estaciones de trabajo X con dependencia de servidores de aplicaciones X Window) no debe usarse el montaje l&oacute;gico a riesgo de perder las conexiones si en un momento se satura o desactiva la red por alg&uacute;n motivo. Una soluci&oacute;n alternativa a usar montajes f&iacute;sicos es aumentar el valor de la opci&oacute;n timeo, o bien usar montajes f&iacute;sicos pero permitiendo el env&iacute;o de se&ntilde;ales para interrumpir las esperas en caso de necesidad.</P>
<P>Normalmente, el demonio mountd llevar&aacute; de alguna forma un registro de que directorios est&aacute;n montados desde que m&aacute;quinas. El programa showmount, incluido en el paquete de aplicaciones NFS, permite consultar esta informaci&oacute;n. De todas formas, el mountd de Linux aun no lleva estos registros.</P>
<P>&nbsp;</P>
</FONT><B><U><FONT FACE="Verdana" SIZE=2 COLOR="#008080">
<P><a name="11.3"></a>11.3 Demonios de NFS</P>
</font></u></B><FONT FACE="Verdana" SIZE=2>
<P>Si desea proporcionar un servicio NFS a otras m&aacute;quinas, deber&aacute; ejecutar en el servidor los programas nfsd y mountd. Son programas basados en RPC, por lo que no son arrancados desde el inetd, sino lanzados como demonios en tiempo de arranque, y registrados en el mapeador de puertos de RPC. Por lo tanto, debe asegurarse que previamente ha sido lanzado el programa rpc.portmap. Normalmente, esto implica las siguientes l&iacute;neas en los scripts de arranque rc:</P><DIR>
<DIR>

<P>if [ -x /usr/sbin/rpc.mountd ]; then</P><DIR>
<DIR>

<P>/usr/sbin/rpc.mountd; echo -n " mountd"</P></DIR>
</DIR>

<P>fi<BR>
if [ -x /usr/sbin/rpc.nfsd ]; then</P><DIR>
<DIR>

<P>/usr/sbin/rpc.nfsd; echo -n " nfsd"</P></DIR>
</DIR>

<P>fi</P></DIR>
</DIR>

<P>La informaci&oacute;n de propiedad de los ficheros que un servidor NFS proporciona a sus clientes viene dada en valores num&eacute;ricos de identificador de usuario (uid) y de grupo (gid).</P>
<P>Por lo tanto, esto resultar&aacute; &uacute;til si clientes y servidores tienen el mismo mapa de usuarios y grupos, lo que sucede cuando dicho mapa se obtiene en todos los nodos desde un servidor NIS central.</P>
<P>Sin embargo, hay veces que esto no sucede. En lugar de actualizar los uids y gids del cliente para ponerse de acuerdo con los del servidor, puede usarse el demonio ugidd para hacer este trabajo. Utilizando la opci&oacute;n map_daemon explicada despu&eacute;s, se indicar&aacute; a nfsd que establezca una correspondencia entre uid/gid del servidor y del cliente, con la ayuda, en el cliente, de ugidd.</P>
<P>ugidd es un servidor basado en RPC, y se inicia tambi&eacute;n en los scripts rc, con una l&iacute;nea:</P><DIR>
<DIR>

<P>if [ -x /usr/sbin/rpc.ugidd ]; then</P><DIR>
<DIR>

<P>/usr/sbin/rpc.ugidd; echo -n " ugidd"</P></DIR>
</DIR>

<P>fi</P>
<P>&nbsp;</P></DIR>
</DIR>

</FONT><B><U><FONT FACE="Verdana" SIZE=2 COLOR="#008080">
<P><a name="11.4"></a>11.4 El fichero exports</P>
</font></u></B><FONT FACE="Verdana" SIZE=2>
<P>Mientras que las opciones anteriores se aplican a la configuraci&oacute;n del cliente NFS, hay otras opciones que se aplican al servidor, que afectan a su relaci&oacute;n con cada posible cliente. Estas opciones se incluyen en el fichero de sistemas exportados /etc/exports.</P>
<P>Por defecto, mountd no permitir&aacute; a nadie montar directorios de su m&aacute;quina. Para permitir que alg&uacute;n nodo monte un directorio, &eacute;ste debe estar exportado, es decir, especificado en el fichero de exportaci&oacute;n. Un ejemplo de dicho fichero es el siguiente:</P><DIR>
<DIR>

<P># Fichero de exportaci&oacute;n para vlager (/etc/exports)<BR>
/home vale(rw) vstout(rw) vlight(rw)<BR>
/usr/X386 vale(ro) vstout(ro) vlight(ro)<BR>
/usr/TeX vale(ro) vstout(ro) vlight(ro)<BR>
/ vale(rw,no_root_squash)<BR>
/home/ftp (ro)</P></DIR>
</DIR>

<P>&nbsp;</P>
<P>Cada l&iacute;nea define un directorio, y la lista de m&aacute;quinas que pueden acceder a &eacute;l por NFS. Un nombre de m&aacute;quina puede especificarse con su nombre internet completo, aunque tambi&eacute;n se permite el uso de los comodines * y ?, que se interpretan como en el shell de Bourne. Por ejemplo, lab*.prueba.com encaja con cualquier nodo con nombre similar a laboratorio.prueba.com o lab12.prueba.com, etc. Cuando en una l&iacute;nea de /etc/exports no se indique el nombre del nodo, se asume que cualquier m&aacute;quina podr&aacute; montar el directorio (as&iacute; sucede en nuestro ejemplo con /home/ftp).</P>
</FONT><B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>mountd</b></font><FONT FACE="Verdana" SIZE=2> usa la llamada gethostbyaddr(2) para comprobar si el cliente demandante tiene un nombre de los que aparecen en /etc/exports. Con DNS, la llamada retorna el nombre can&oacute;nico con lo que debe evitar usar nombres de alias en el fichero de exportaci&oacute;n6. Si no usa DNS, el nombre devuelto por la llamada anterior ser&aacute; el primer nombre que coincida con el IP del demandante, en el fichero /etc/hosts.</font></P><FONT FACE="Verdana" SIZE=2>
<P>Tras el nombre del nodo autorizado, se puede encerrar entre par&eacute;ntesis un conjunto de opciones separadas por comas. Dichas opciones son:</P>
</FONT><B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>insecure</b></font><FONT FACE="Verdana" SIZE=2> Permitir acceso no autentificado desde ese nodo.</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>unix-rpc</b></font><FONT FACE="Verdana" SIZE=2> Requerir autentificaci&oacute;n RPC del dominio Unix para este nodo. Se trata simplemente de que las peticiones se originen en un puerto reservado (es decir, inferior al 1024). Esta opci&oacute;n est&aacute; activa por defecto.</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>secure-rpc</b></font><FONT FACE="Verdana" SIZE=2> Requerir autentificaci&oacute;n RPC segura para este nodo. Aun no est&aacute; implementado. Se sugiere ver la documentaci&oacute;n de Sun al respecto (v&eacute;ase, "Secure RPC").</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>kerberos</b></font><FONT FACE="Verdana" SIZE=2> Requerir autentificaci&oacute;n Kerberos. Tampoco se ha implementado aun. Se sugiere consultar la documentaci&oacute;n del MIT.</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>root_squash</b></font><FONT FACE="Verdana" SIZE=2> Se trata de una opci&oacute;n de seguridad que deniega acceso a nivel de superusuario, traduciendo el identificador uid recibido (0) al del usuario nobody. Es decir, cualquier petici&oacute;n NFS del usuario root ser&aacute; tomada como si fuera del usuario nobody.</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>no_root_squash</b></font><FONT FACE="Verdana" SIZE=2> Evita la restricci&oacute;n anterior. Es una opci&oacute;n por defecto.</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>ro</b></font><FONT FACE="Verdana" SIZE=2> Monta la jerarqu&iacute;a de ficheros en modo de solo lectura. Es una opci&oacute;n por defecto.</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>rw</b></font><FONT FACE="Verdana" SIZE=2> Monta el directorio con permiso para leer y escribir en &eacute;l.</font></P><FONT FACE="Verdana" SIZE=2>
<P>_____________________________________________<BR>
6 Ver cap&iacute;tulo 6</P>
<P>&nbsp;</P>
</FONT><B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>link_relative</b></font><FONT FACE="Verdana" SIZE=2> Convierte enlaces simb&oacute;licos absolutos (que empiezan con una barra de directorio, "/") en enlaces relativos colocando los prefijos "../ " que sean necesarios para hacer que apunten a la ra&iacute;z del servidor. Esta opci&oacute;n solo tiene sentido cuando se monta un sistema de ficheros completo y no solo un directorio. As&iacute;, si montamos dicho sistema bajo /mnt y existe en /mnt/sub un enlace fichero ! /tmp/fichero se convertir&aacute; a fichero ! ../tmp/fichero logrando as&iacute; que el enlace sirva para algo. Es una opci&oacute;n activa por defecto.</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>link_absolute</b></font><FONT FACE="Verdana" SIZE=2> Deja los enlaces absolutos como estaban (es la opci&oacute;n habitual en servidores NFS de Sun).</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>map_identity</b></font><FONT FACE="Verdana" SIZE=2> La opci&oacute;n map_identity indica al servidor que asuma que el cliente utiliza el mismo mapa de uids y gids que el servidor. Es una opci&oacute;n por defecto.</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>map_daemon</b></font><FONT FACE="Verdana" SIZE=2> Esta opci&oacute;n indica al servidor NFS que no comparte el mapa de usuarios con el del cliente. Con ello, las comparaciones de uids y gids se har&aacute;n mediante una lista de mapeado entre ambos que se construir&aacute; llamando al demonio ugidd del cliente.</font></P><FONT FACE="Verdana" SIZE=2>
<P>&nbsp;</P>
<P>Cualquier error analizando el fichero de exportaciones durante el arranque del servidor nfsd o mountd ser&aacute; enviado a nivel de notificaci&oacute;n (notice) al registro del sistema (syslogd).</P>
<P>Obs&eacute;rvese que los nombres de los nodos se obtienen a partir de las direcciones IP mediante resoluci&oacute;n inversa, con lo que el sistema de resoluci&oacute;n deber&aacute; tener una adecuada configuraci&oacute;n en este punto. Si utiliza BIND y la seguridad le preocupa especialmente, deber&aacute; activar chequeo de nombres falsos (spoofing) en el fichero host.conf.</P>
<P>&nbsp;</P>
</FONT><B><U><FONT FACE="Verdana" SIZE=2 COLOR="#008080">
<P><a name="11.5"></a>11.5 El sistema de automontado en Linux</P>
</font></u></B><FONT FACE="Verdana" SIZE=2>
<P>A veces es ineficiente mantener montados todos los vol&uacute;menes NFS de uso potencial. Una alternativa es usar un demonio de automontado. Se trata de un demonio que autom&aacute;ticamente monta los vol&uacute;menes cuando se necesitan y los desmonta tras un tiempo de inactividad.</P>
<P>Adem&aacute;s, sirve para poder montar los mismos ficheros de un lugar diferente. Por ejemplo, puede mantener varias copias de las utilidades de X Window y a la hora de ser necesitadas, intentar montar cada copia hasta conseguirlo.</P>
<P>El programa de automontado para Linux se llama amd. Ha sido escrito inicialmente por Jan-Simon Pendry para luego encargarse Rick Sladkey de portarlo a Linux. La versi&oacute;n actual es la 5.3.</P>
<P>Explicar el uso de amd excede los objetivos de este cap&iacute;tulo. El mejor manual se encuentra en las fuentes: un fichero texinfo con informaci&oacute;n muy detallada.</P></FONT></BODY>
</HTML>
