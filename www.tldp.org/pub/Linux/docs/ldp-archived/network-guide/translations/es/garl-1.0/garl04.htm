<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<TITLE>garl4</TITLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" VLINK="#800080" BGCOLOR="#ffffff">

<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=4 WIDTH=737>
<TR><TD WIDTH="46%" VALIGN="TOP">
      <P><a href="garl03.htm"><IMG SRC="left.gif" WIDTH=36 HEIGHT=34 border="0"></a>
    </TD>
<TD WIDTH="11%" VALIGN="TOP">
      <P ALIGN="CENTER"><a href="garl.htm"><IMG SRC="up.gif" WIDTH=34 HEIGHT=36 border="0"></a>
    </TD>
<TD WIDTH="43%" VALIGN="TOP">
      <P ALIGN="RIGHT"><a href="garl05.htm"><IMG SRC="right.gif" WIDTH=36 HEIGHT=34 border="0"></a>
    </TD>
</TR>
</TABLE>

<FONT FACE="Verdana" SIZE=2><P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=4 COLOR="#000080"><P ALIGN="CENTER">Cap&iacute;tulo 4</P>
</font></B><P ALIGN="CENTER"><HR>
<B><U><FONT FACE="Verdana" SIZE=2><P>Configuraci&oacute;n del Software Serie</P>
</font></u></B><FONT FACE="Verdana" SIZE=2>
<P>Casi todo el mundo dispone de un PC, pero no siempre hay dinero para gastarlo 
  en un enlace Internet T1. Para conseguir su dosis diaria de noticias y mensajes, 
  mucha gente depende de enlaces SLIP, redes UUCP y BBS, que usan las redes telef&oacute;nicas 
  publicas.</P>
<P>Este cap&iacute;tulo pretende ayudar a todas aquellas personas que dependen 
  del m&oacute;dem para mantener sus comunicaciones. Sin embargo, hay muchos detalles 
  que no podemos abordar, como por ejemplo como configurar el m&oacute;dem para 
  marcar. Todos esos temas est&aacute;n contemplados en el "Serial HOWTO"1 de 
  Greg Hankins2, que es enviado a comp.os.linux.announce regularmente.</P>
</FONT>
<dir> 
    <p><font face="Verdana" size="2"><a href="garl04.htm#4.1">4.1 Software de 
      Comunicaciones con M&oacute;dem</a><br>
      <a href="garl04.htm#4.2">4.2 Introducci&oacute;n a los Dispositivos Serie</a><br>
      <a href="garl04.htm#4.3">4.3 Acceso a los Dispositivos Serie</a><br>
      <a href="garl04.htm#4.4">4.4 Hardware Serie</a></font></p>
</dir>
<B><U><FONT FACE="Verdana" SIZE=2 COLOR="#008080">
<P><a name="4.1"></a>4.1 Software de Comunicaciones con M&oacute;dem</P>
</font></u></B><FONT FACE="Verdana" SIZE=2>
<P>Existen varios paquetes de comunicaciones disponibles para Linux. Muchos de ellos son emuladores de terminal, que permiten a un usuario conectarse a otro ordenador como si estuviera frente a uno de sus terminales. El emulador de terminal tradicional en sistemas UNIX es kermit. Sin embargo resulta algo duro de usar. Hay programas disponibles m&aacute;s c&oacute;modos que soportan agenda telef&oacute;nica y guiones para llamar y entrar en ordenadores remotos. Uno de estos es el minicom, muy parecido a los primitivos programas emuladores de terminal a los que tan acostumbrados est&aacute;n los usuarios de DOS. Hoy tambi&eacute;n existen paquetes de comunicaciones bajo X-11 como por ejemplo seyon.</P>
<P>Adem&aacute;s, existe un buen n&uacute;mero de programas para instalar BBS bajo Linux disponibles para aquellos que quieran ofrecer dicho servicio. Varios de esos paquetes se encuentran en sunsite.unc.edu, en el directorio /pub/Linux/system/Network.</P>
<P>_____________________________________________<BR>
1 N. del T.: Disponible en castellano como SERIE-COMO, en http://lucas.ctv.es/<BR>
2 Disponible en gregh@cc.gatech.edu.</P>
<P>&nbsp;</P>
<P>Aparte de los programas de terminal, hay tambi&eacute;n software que usa la l&iacute;nea serie de forma no interactiva para el transporte de datos hasta su ordenador. Normalmente se invierte bastante m&aacute;s tiempo en visitar un BBS leyendo toda su informaci&oacute;n en la que podemos incluir las noticias y los mensajes, que el que se necesita empleando este tipo de software. La &uacute;nica desventaja es que se requiere mas espacio de disco debido a la transferencia de cierta cantidad de informaci&oacute;n que al usuario le resulta in&uacute;til, y que de forma interactiva no se transmitir&iacute;a.</P>
<P>El compendio de esta clase de software de comunicaciones es UUCP. Este es un conjunto de programas que copian ficheros de una m&aacute;quina a otra, ejecutan programas en un ordenador remoto, etc. Se utiliza frecuentemente para transferir mensajes y noticias (news) entre redes privadas. El paquete UUCP de Ian Taylor, que funciona bajo Linux, ser&aacute; descrito en el cap&iacute;tulo 12 de este libro. Otro tipo de software de comunicaciones no interactivo es el utilizado en Fidonet, para el que tambi&eacute;n podemos encontrar algunos paquetes de software, como ifmail.</P>
<P>SLIP, el protocolo de Internet para l&iacute;nea serie, esta de alg&uacute;n modo a medio camino: permite tanto el uso interactivo como el no interactivo. Mucha gente usa SLIP para telefonear a la red de su campus o alg&uacute;n otro tipo de servidor publico y poder ejecutar sesiones FTP, etc. Sin embargo, SLIP tambi&eacute;n puede ser usado en conexiones permanentes o semipermanentes para uniones de LAN a LAN, aunque esto &uacute;ltimo solo resulta interesante utilizando RDSI u otros enlaces de ancho de banda mayor.</P>
<P>&nbsp;</P>
</FONT><B><U><FONT FACE="Verdana" SIZE=2 COLOR="#008080">
<P><a name="4.2"></a>4.2 Introducci&oacute;n a los Dispositivos Serie</P>
</font></u></B><FONT FACE="Verdana" SIZE=2>
<P>Los dispositivos proporcionados por un n&uacute;cleo UNIX para el acceso a dispositivos serie son llamados normalmente ttys. Esta es una abreviatura de TeletypeTM, quienes eran unos de los mayores productores de terminales en los primeros d&iacute;as de Unix. El t&eacute;rmino se usa actualmente para cualquier terminal de texto. En este cap&iacute;tulo, lo usaremos exclusivamente para referirnos a los dispositivos del n&uacute;cleo.</P>
<P>Linux distingue tres clases de ttys: consolas (virtuales), pseudo terminales (similares a las tuber&iacute;as de doble v&iacute;a, usadas por aplicaciones tales como X11), y dispositivos serie. Estos &uacute;ltimos son considerados tambi&eacute;n como ttys, porque permiten sesiones interactivas sobre conexiones serie, ya sea &eacute;ste un terminal conectado por cable o un ordenador remoto a trav&eacute;s de la l&iacute;nea telef&oacute;nica.</P>
<P>Los ttys tienen cierto n&uacute;mero de par&aacute;metros configurables mediante la llamada al sistema ioctl(2). Muchos de estos par&aacute;metros sirven &uacute;nicamente con dispositivos serie, ya que son estos los que necesitan una mayor flexibilidad para poder manejar la gran variedad de tipos de conexi&oacute;n que son capaces de controlar.</P>
<P>Entre los par&aacute;metros mas destacados para la l&iacute;nea se encuentran la velocidad y la paridad. Pero hay tambi&eacute;n elementos para la conversi&oacute;n de caracteres entre may&uacute;scula y min&uacute;scula, de retorno de carro, de avance de l&iacute;nea, etc. El controlador de tty puede tambi&eacute;n soportar varias l&iacute;neas dedicadas, las cuales hacen que el controlador de dispositivo se comporte de forma diferente. Por ejemplo, el controlador de SLIP para Linux esta implementado como si fuera una l&iacute;nea dedicada.</P>
<P>Existe algo de ambig&uuml;edad sobre como medir la velocidad de la l&iacute;nea. El termino correcto es bit rate, el cual esta relacionado con la velocidad de transferencia de la l&iacute;nea medida en bits por segundo (bps para abreviar). Algunas veces se oye a la gente referirse a ella como velocidad en baudios, lo cual no es muy correcto, ya que estos dos t&eacute;rminos no son sin&oacute;nimos.</P>
<P>La velocidad en baudios se refiere a una caracter&iacute;stica f&iacute;sica de algunos dispositivos serie. En concreto, a la velocidad de reloj a la que se transmiten los impulsos. En cambio, el "bit rate", indica el estado actual de una conexi&oacute;n serie existente entre dos puntos, a saber, el n&uacute;mero medio de bits transferidos por segundo. Es importante saber que estos dos valores suelen ser diferentes, ya que la mayor&iacute;a de los dispositivos codifican mas de un bit por cada impulso el&eacute;ctrico.</P>
<P>&nbsp;</P>
</FONT><B><U><FONT FACE="Verdana" SIZE=2 COLOR="#008080">
<P><a name="4.3"></a>4.3 Acceso a los Dispositivos Serie</P>
</font></u></B><FONT FACE="Verdana" SIZE=2>
<P>Como ocurre con todos los dispositivos de un sistema UNIX, se accede a los puertos serie a trav&eacute;s de ficheros especiales de dispositivo, localizados en el directorio /dev. Cada puerto tiene su fichero de dispositivo. Hay dos tipos de ficheros de dispositivos relacionados con los controladores serie. Dependiendo del fichero por el que se acceda el dispositivo se comportara de forma diferente.</P>
<P>El primer tipo se utiliza para las llamadas entrantes y tiene un n&uacute;mero principal de dispositivo3 igual a 4. Sus ficheros son nombrados ttyS0, ttyS1, etc. El segundo tipo se utiliza para llamadas de salida a trav&eacute;s de un puerto. Sus ficheros son llamados cua0, etc y tienen un n&uacute;mero principal de dispositivo igual a 5.</P>
<P>Los n&uacute;meros secundarios4 son los mismos para los dos tipos. Si tiene su m&oacute;dem en uno cualquiera de los puertos COM1 a COM4, su n&uacute;mero secundario ser&aacute; el n&uacute;mero de puerto COM mas 63. Si su configuraci&oacute;n es diferente a &eacute;sta, como sucede, por ejemplo, en placas que soportan m&uacute;ltiples l&iacute;neas serie, debe en tal caso buscar en el documento COMO-SERIE o SERIAL-HOWTO.</P>
<P>Asumamos que su m&oacute;dem esta en el COM2. En este caso su n&uacute;mero secundario ser&aacute; 65, y su n&uacute;mero principal ser&aacute; 5 para realizar llamadas. Deber&iacute;a existir por ello, un dispositivo cua1 que tuviera dichos n&uacute;meros de dispositivo. A continuaci&oacute;n vemos una lista de ttys serie del directorio /dev. Las columnas 5 y 6 muestran los n&uacute;meros principal y secundario respectivamente.</P><DIR>
<DIR>

<P>$ ls -l /dev/cua*<BR>
crw-rw-rw- 1 root root 5, 64 Nov 30 19:31 /dev/cua0<BR>
crw-rw-rw- 1 root root 5, 65 Nov 30 22:08 /dev/cua1<BR>
crw-rw-rw- 1 root root 5, 66 Oct 28 11:56 /dev/cua2<BR>
crw-rw-rw- 1 root root 5, 67 Mar 19 1992 /dev/cua3</P></DIR>
</DIR>

<P>_____________________________________________<BR>
3 N. del T.: Del ingl&eacute;s major number<BR>
4 N. del T.: Del ingl&eacute;s minor number</P>
<P>&nbsp;</P>
<P>Si no existiesen tales dispositivos, entonces tendr&iacute;a que crearlos. Para ello, convi&eacute;rtase en superusuario y teclee comandos como el siguiente:</P><DIR>
<DIR>

<P># mknod -m 666 /dev/cua1 c 5 65<BR>
# chown root.root /dev/cua1</P></DIR>
</DIR>

<P>Hay quien propone la creaci&oacute;n de un enlace simb&oacute;lico del puerto serie en donde tenga su m&oacute;dem, a un fichero /dev/modem. De esta forma no es necesario recordar el poco intuitivo cua1. Sin embargo, podemos encontrarnos con problemas si empleamos el nombre real del dispositivo en unos programas y el simb&oacute;lico en otros. La explicaci&oacute;n es que las aplicaciones en Unix usan un convenio de ficheros cerrojo para indicar que cierto dispositivo esta siendo utilizado por un proceso y evitar as&iacute; que pueda ser utilizado por otro al mismo tiempo. Por convenio, el nombre del fichero de bloqueo para cua1, es LCK..cua1. El uso de distintos ficheros de dispositivo para el mismo puerto implica que se puede producir ausencia de exclusi&oacute;n mutua en el acceso al puerto si un programa usa un nombre de dispositivo y otro programa usa el otro nombre (el simb&oacute;lico). Esto puede provocar un acceso simult&aacute;neo de ambos procesos al mismo puerto y que, por tanto, ninguna de ellas funcione correctamente.</P>
<P>&nbsp;</P>
</FONT><B><U><FONT FACE="Verdana" SIZE=2 COLOR="#008080">
<P><a name="4.4"></a>4.4 Hardware Serie</P>
</font></u></B><FONT FACE="Verdana" SIZE=2>
<P>Linux soporta, hoy por hoy, una amplia variedad de placas serie que utilizan el est&aacute;ndar RS-232. RS-232 es, en la actualidad, el est&aacute;ndar mas comun para comunicaciones serie en el mundo del PC. Este usa un conjunto de circuitos tanto para transmitir simples bits as&iacute; como para establecer sincronizaci&oacute;n. Pueden utilizarse cables adicionales para se&ntilde;alar la presencia de una portadora y para el control de flujo.</P>
<P>Aunque el control de flujo por hardware es opcional, resulta muy &uacute;til ya que permite a cada una de las dos estaciones se&ntilde;alar cuando esta lista para recibir mas datos, o si la otra estaci&oacute;n debe parar hasta que el receptor procese los datos de entrada. Las l&iacute;neas usadas para esto son las llamadas Clear to Send, despejado para env&iacute;os, (CTS) y Ready to Send, listo para enviar (RTS), respectivamente.</P>
<P>En ordenadores PC, el interfaz RS-232 es controlado generalmente por un chip UART descendiente del chip 16450 de National Semiconductor, o bien de una nueva versi&oacute;n de este: el NSC 16550A5. Algunas marcas (principalmente los m&oacute;dems internos equipados con un chip Rockwell) tambi&eacute;n usan chips completamente diferentes que han sido programados para comportarse como si fueran un 16550.</P>
<P>La principal diferencia entre los 16450 y los 16550 estriba en que el primero tiene un buffer de 1 byte mientras que el segundo lo tiene de 16 bytes. Esto hace al 16450 valido para velocidades m&aacute;ximas de 9600 baudios, mientras que para velocidades superiores se requiere un chip compatible con el 16550. Adem&aacute;s de estos chips, Linux tambi&eacute;n soporta el chip 8250, que era el chip UART original de los PC de IBM.</P>
<P>En la configuraci&oacute;n por defecto, el n&uacute;cleo comprueba los cuatro puertos serie est&aacute;ndar, es decir, del COM1 hasta el COM4, a los que les asignara los n&uacute;meros secundarios desde el 64 hasta el 67, tal y como se ha descrito anteriormente.</P>
<P>Si desea configurar su puerto serie adecuadamente, tendr&iacute;a que incluir la orden setserial de Ted Tso en el fichero de comandos rc.serial, el cual es invocado durante el arranque del sistema desde el fichero de comandos de inicializaci&oacute;n /etc/rc. Este primer fichero, usa setserial para configurar los dispositivos serie del n&uacute;cleo. Un t&iacute;pico fichero de comandos rc.serial tendr&aacute; el siguiente aspecto:</P><DIR>
<DIR>

<P># /etc/rc.serial - guion de configuraci&oacute;n de la l&iacute;nea serie<BR>
#<BR>
# Deteccion de interrupciones libres<BR>
/sbin/setserial -W /dev/cua*<BR>
<BR>
# Configurar dispositivos serie<BR>
/sbin/setserial /dev/cua0 auto_irq skip_test autoconfig<BR>
/sbin/setserial /dev/cua1 auto_irq skip_test autoconfig<BR>
/sbin/setserial /dev/cua2 auto_irq skip_test autoconfig<BR>
/sbin/setserial /dev/cua3 auto_irq skip_test autoconfig<BR>
<BR>
# Muestra la configuraci&oacute;n de dispositivos serie<BR>
/sbin/setserial -bg /dev/cua*</P></DIR>
</DIR>

<P>Si desea conocer mas sobre los par&aacute;metros de setserial, por favor, consulte la documentaci&oacute;n que acompa&ntilde;a al programa.</P>
<P>_____________________________________________<BR>
5 Hab&iacute;a tambi&eacute;n un NSC 16550, pero este chip FIFO nunca funcion&oacute; realmente.</P>
<P>&nbsp;</P>
<P>Si su tarjeta serie no es detectada, o la orden setserial -bg muestra una configuraci&oacute;n incorrecta, tendr&aacute; que forzar la configuraci&oacute;n suministrando expl&iacute;citamente los valores correctos. Est&aacute; comprobado que los m&oacute;dems internos equipados con los chips de Rockwell experimentan este tipo de problemas. As&iacute;, por ejemplo, si se obtiene que el chip de una UART es el NSC 16450, siendo en cambio del tipo NSC 16550, se tendr&aacute; que cambiar la configuraci&oacute;n del puerto implicado de la forma siguiente:</P><DIR>
<DIR>

<P>/sbin/setserial /dev/cua1 auto_irq skip_test autoconfig uart 16550</P></DIR>
</DIR>

<P>Existen opciones similares para forzar los puertos COM, direcciones base, y configuraci&oacute;n de petici&oacute;n de interrupci&oacute;n (IRQ). Por favor consulte la pagina del manual de setserial(8) para mas informaci&oacute;n.</P>
<P>Si su m&oacute;dem soporta control de flujo mediante hardware, aseg&uacute;rese de activarlo. Sorprendentemente, la mayor&iacute;a de los programas de comunicaciones no intentan activarlo por defecto. Por ello, lo mejor es realizarlo manualmente, y la mejor forma de lograrlo es incluirlo en el fichero de comandos rc.serial usando la orden stty:</P><DIR>
<DIR>

<P>$ stty crtscts &lt; /dev/cua1</P></DIR>
</DIR>

<P>Para comprobar si el control de flujo por hardware esta activo use:</P><DIR>
<DIR>

<P>$ stty -a &lt; /dev/cua1</P></DIR>
</DIR>

<P>Este comando le devolver&aacute; el estado de todos los par&aacute;metros de dicho dispositivo. Un par&aacute;metro precedido con un signo menos como en -crtscts significa que ha sido desactivado.</P>
<P>&nbsp;</P></FONT></BODY>
</HTML>
