<HTML>
<HEAD>
<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=windows-1252">
<TITLE>garl9</TITLE>
</HEAD>
<BODY TEXT="#000000" LINK="#0000ff" VLINK="#800080" BGCOLOR="#ffffff">

<TABLE CELLSPACING=0 BORDER=0 CELLPADDING=4 WIDTH=737>
<TR><TD WIDTH="46%" VALIGN="TOP">
      <P><a href="garl08.htm"><IMG SRC="left.gif" WIDTH=36 HEIGHT=34 border="0"></a>
    </TD>
<TD WIDTH="11%" VALIGN="TOP">
      <P ALIGN="CENTER"><a href="garl.htm"><IMG SRC="up.gif" WIDTH=34 HEIGHT=36 border="0"></a>
    </TD>
<TD WIDTH="43%" VALIGN="TOP">
      <P ALIGN="RIGHT"><a href="garl10.htm"><IMG SRC="right.gif" WIDTH=36 HEIGHT=34 border="0"></a>
    </TD>
</TR>
</TABLE>

<FONT FACE="Verdana" SIZE=2><P>&nbsp;</P>
</FONT><B><FONT FACE="Arial" SIZE=4 COLOR="#000080"><P ALIGN="CENTER">Cap&iacute;tulo 9</P>
</font></B><P ALIGN="CENTER"><HR><p></P>
<B><U><FONT FACE="Verdana" SIZE=2><P>Algunas Aplicaciones de Red</P>
</font></u></B><FONT FACE="Verdana" SIZE=2>
<P>Despu&eacute;s de instalar correctamente el IP y el sistema de resoluci&oacute;n, 
  tiene que dedicarse a los servicios que quiera proporcionar a trav&eacute;s 
  de la red. Este cap&iacute;tulo trata la configuraci&oacute;n de algunas sencillas 
  aplicaciones de red, incluyendo el servidor inetd, y los programas de la familia 
  rlogin. El interface de Llamada a Procedimiento Remoto o RPC1, en el que est&aacute;n 
  basados servicios como el Sistema de Ficheros en Red o NFS2 y el Sistema de 
  Informaci&oacute;n de Red o NIS3, tambi&eacute;n ser&aacute; tratado brevemente 
  aqu&iacute;. Las configuraciones de NFS y de NIS, sin embargo, ocupan mas espacio 
  y ser&aacute;n descritas en cap&iacute;tulos aparte. Lo mismo sucede con el 
  correo electr&oacute;nico y el sistema de noticias.</P>
<P>Por supuesto, no podemos cubrir todas las aplicaciones de red en este libro. 
  Si desea instalar alguna no tratada aqu&iacute;, como talk, gopher, o Xmosaic, 
  por favor, refi&eacute;rase a su documentaci&oacute;n.</P>
</FONT>
<dir>
    <p><font face="Verdana" size="2"><a href="garl09.htm#9.1">9.1 El Super-Servidor 
      inetd</a><br>
      <a href="garl09.htm#9.2">9.2 La herramienta de control de acceso tcpd</a><br>
      <a href="garl09.htm#9.3">9.3 Los ficheros services y protocols</a><br>
      <a href="garl09.htm#9.4">9.4 Llamada a Procedimientos Remotos</a><br>
      <a href="garl09.htm#9.5">9.5 Configurar los Comandos r</a></font></p>
</dir>
<B><U><FONT FACE="Verdana" SIZE=2 COLOR="#008080">
<P><a name="9.1"></a>9.1 El Super-Servidor inetd</P>
</font></u></B><FONT FACE="Verdana" SIZE=2>
<P>Frecuentemente, los servicios son llevados a cabo por los llamados demonios. Un demonio es un programa que abre un determinado puerto, y espera a recibir peticiones de conexi&oacute;n.</P>
<P>Si se recibe una petici&oacute;n de conexi&oacute;n, lanza un proceso hijo que aceptara la conexi&oacute;n, mientras el padre contin&uacute;a escuchando a la espera de mas peticiones. Este concepto tiene el inconveniente de que por cada servicio ofrecido, se necesita ejecutar un demonio que escuche las conexiones a un puerto, lo que generalmente significa un desperdicio de recursos de sistema como, por ejemplo, de espacio de intercambio.</P>
<P>Por ello, casi todas las instalaciones UNIX corren un "super-servidor" que crea sockets para varios servicios, y escucha en todos ellos simult&aacute;neamente usando la llamada al sistema select(2). Cuando un nodo remoto requiere uno de los servicios, el super-servidor lo recibe y llama al servidor especificado para ese puerto.</P>
<P>_____________________________________________<BR>
1 N. del T.: Del ingl&eacute;s Remote Procedure Call<BR>
2 N. del T.: Del ingl&eacute;s Network File System<BR>
3 N. del T.: Del ingl&eacute;s Network Information System.</P>
<P>&nbsp;</P>
<P>El super-servidor mas usado es inetd, el demonio Internet. Es iniciado en tiempo de arranque del sistema, y toma la lista de servicios que debe tratar de un fichero de configuraci&oacute;n denominado /etc/inetd.conf. Aparte de esos servidores invocados por inetd, hay varios servicios triviales que el propio inetd se encarga de llevar a cabo, denominados servicios internos. Entre ellos, el chargen que simplemente genera una cadena de caracteres, y el daytime que devuelve la fecha y hora del sistema.</P>
<P>Una entrada de este fichero consiste en una &uacute;nica l&iacute;nea compuesta por los siguientes campos:</P><DIR>
<DIR>

<P>servicio tipo protocolo espera usuario servidor linea_de_comando</P></DIR>
</DIR>

<P>El significado de cada campo es como sigue:</P>
</FONT><B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>servicio</b></font><FONT FACE="Verdana" SIZE=2> Proporciona el nombre del servicio. El nombre del servicio debe ser traducido a un n&uacute;mero de puerto consultando el fichero /etc/services. Este fichero ser&aacute; descrito mas adelante en la secci&oacute;n 9.3.</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>tipo</b></font><FONT FACE="Verdana" SIZE=2> Especifica un tipo de socket, ya sea stream (para protocolos orientados a la conexi&oacute;n) o dgram (para protocolos no orientados a la conexi&oacute;n). Los Servicios basados en TCP deber&aacute;n, por lo tanto, usar siempre stream, mientras que los servicios basados en UDP deber&aacute;n usar siempre dgram.</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>protocolo</b></font><FONT FACE="Verdana" SIZE=2> Indica el protocolo de transporte usado por el servicio. Este debe ser un nombre de protocolo valido que se pueda encontrar en el fichero protocols, tambi&eacute;n descrito mas adelante.</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>espera</b></font><FONT FACE="Verdana" SIZE=2> Esta opci&oacute;n se aplica solo a sockets de tipo dgram. Puede tomar los valores wait o nowait. Si se especifica wait, inetd ejecutara solo un servidor cada vez para el puerto especificado. De otro modo, continuara escuchando por el puerto inmediatamente despu&eacute;s de ejecutar el servidor. Esto es &uacute;til para servidores "single-threaded" que leen todos los datagramas que entran hasta que no llegan mas, y despu&eacute;s acaban. La mayor parte de los servidores RPC son de este tipo y se deber&aacute; por ello especificar wait.<BR>
El otro tipo de servidores, los "multi-threaded", permiten un n&uacute;mero ilimitado de instancias corriendo concurrentemente. Con estos servidores se deber&aacute; especificar nowait. Para sockets de tipo stream se deber&aacute; especificar siempre nowait.</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>usuario</b></font><FONT FACE="Verdana" SIZE=2> Este es el identificador del usuario bajo el que se ejecutara el proceso. Por lo general, &eacute;ste suele ser el usuario root, aunque algunos servicios pueden usar diferentes cuentas. Es una buena idea el aplicar aqu&iacute; el principio del menor privilegio, que indica que uno no deber&iacute;a ejecutar un comando bajo una cuenta privilegiada si el programa no lo requiere para funcionar correctamente. Por ejemplo, el servidor de noticias NNTP se ejecutara como news, mientras que otros servicios que podr&iacute;an significar un riesgo para la seguridad (como tftp o finger ) son normalmente ejecutados como nobody.</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>servidor</b></font><FONT FACE="Verdana" SIZE=2> Proporciona el camino completo del programa servidor a ejecutar. Los servicios internos se indican con la palabra internal.</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>linea_de_comando</b></font><FONT FACE="Verdana" SIZE=2><BR>
Esta es la l&iacute;nea de comando a pasar al servidor. Esto incluye el argumento 0, es decir, el nombre del comando. Normalmente, este ser&aacute; el nombre de programa del servidor, salvo que el programa se comporte de forma distinta cuando se le invoque con un nombre diferente. Este campo se deja vac&iacute;o para los servicios internos.</font></P><FONT FACE="Verdana" SIZE=2>
<P>En la figura 9.1 se muestra un ejemplo de fichero /etc/inetd.conf. La l&iacute;nea del servicio finger esta comentada, de forma que no este disponible. Esto se suele hacer normalmente por razones de seguridad porque podr&iacute;a ser usado por atacantes para obtener nombres de usuarios del sistema.</P>
<P>El tftp tambi&eacute;n se muestra deshabilitado. tftp implementa el Trivial File Transfer Protocol que permite transferir cualquier fichero del sistema que tenga permiso de lectura global sin chequeo de passwords, etc. Esto es especialmente peligroso con el fichero /etc/passwd, sobre todo si no se usa shadow password.</P>
<P>TFTP es usado com&uacute;nmente por clientes y terminales X sin unidad de discos para obtener su software de un servidor de arranque. Si necesita ejecutar tftp por &eacute;sta raz&oacute;n, aseg&uacute;rese de limitar su acci&oacute;n a los directorios de los que los clientes obtendr&aacute;n los ficheros a&ntilde;adiendo esos nombres de directorio a la l&iacute;nea de comando del tftpd. Esto se muestra en la segunda l&iacute;nea tftp del ejemplo.</P>
<P>&nbsp;</P><DIR>
<DIR>

<P>#<BR>
# servicios inetd<BR>
ftp stream tcp nowait root /usr/sbin/ftpd in.ftpd -l<BR>
telnet stream tcp nowait root /usr/sbin/telnetd in.telnetd -b/etc/issue<BR>
#finger stream tcp nowait bin /usr/sbin/fingerd in.fingerd<BR>
#tftp dgram udp wait nobody /usr/sbin/tftpd in.tftpd<BR>
#tftp dgram udp wait nobody /usr/sbin/tftpd in.tftpd /boot/diskless<BR>
login stream tcp nowait root /usr/sbin/rlogind in.rlogind<BR>
shell stream tcp nowait root /usr/sbin/rshd in.rshd<BR>
exec stream tcp nowait root /usr/sbin/rexecd in.rexecd<BR>
#<BR>
# servicios internos inetd<BR>
#<BR>
daytime stream tcp nowait root internal<BR>
daytime dgram udp nowait root internal<BR>
time stream tcp nowait root internal<BR>
time dgram udp nowait root internal<BR>
echo stream tcp nowait root internal<BR>
echo dgram udp nowait root internal<BR>
discard stream tcp nowait root internal<BR>
discard dgram udp nowait root internal<BR>
chargen stream tcp nowait root internal<BR>
chargen dgram udp nowait root internal</P></DIR>
</DIR>

<P>Figura 9.1: Un ejemplo de fichero /etc/inetd.conf.</P>
<P>&nbsp;</P>
</FONT><B><U><FONT FACE="Verdana" SIZE=2 COLOR="#008080">
<P><a name="9.2"></a>9.2 La herramienta de control de acceso tcpd</P>
</font></u></B><FONT FACE="Verdana" SIZE=2>
<P>Ya que abrir un ordenador al acceso en red implica muchos riesgos de seguridad, las aplicaciones est&aacute;n dise&ntilde;adas para protegerse ante varios tipos de ataques. Algunas de &eacute;stas aplicaciones, sin embargo, pueden ser reventadas (lo que quedo bastante demostrado con el RTM Internet worm), o pueden no distinguir entre un nodo seguro cuyas peticiones de un servicio particular deber&iacute;an ser aceptadas, y otro nodo que no lo es y cuyas peticiones deber&iacute;an ser rechazadas. Ya hemos discutido brevemente los servicios finger y tftp mas arriba. As&iacute;, uno podr&iacute;a querer limitar el acceso a esos servicios solamente a los "nodos de confianza", lo cual es imposible con la configuraci&oacute;n usual, donde inetd o proporciona un servicio a todos los clientes, o a ninguno.</P>
<P>Una herramienta &uacute;til para esto es tcpd,4 el denominado demonio envoltorio5. Para los servicios TCP que quiera monitorizar o proteger, &eacute;ste es invocado en lugar del programa servidor. tcpd informa de la petici&oacute;n al demonio syslog, chequea si el nodo remoto esta autorizado para usar ese servicio, y solo si la respuesta es satisfactoria, ejecutara el programa servidor real. Observe que esto no funciona con servicios basados en UDP.</P>
<P>Por ejemplo, para proteger el demonio finger, debe cambiar la l&iacute;nea correspondiente en inetd.conf as&iacute;:</P><DIR>
<DIR>

<P># Proteger el demonio de finger<BR>
finger stream tcp nowait root /usr/sbin/tcpd in.fingerd</P></DIR>
</DIR>

<P>As&iacute;, sin a&ntilde;adir ning&uacute;n control de acceso, esto le har&aacute; parecer al cliente que es la t&iacute;pica configuraci&oacute;n de finger, salvo que toda petici&oacute;n ser&aacute; registrada en la facilidad auth del syslog.</P>
<P>El control de acceso esta implementado mediante dos ficheros llamados /etc/hosts.allow y /etc/hosts.deny. Estos ficheros contienen entradas permitiendo y denegando acceso, respectivamente, para ciertos servicios y nodos. Cuando tcpd trata una petici&oacute;n de un servicio como finger de un nodo cliente denominado biff.foobar.com, busca en hosts.allow y hosts.deny (en &eacute;ste orden) una entrada en la que el servicio y el nodo cliente coincidan. Si la entrada coincidente aparece en hosts.allow, se garantiza el acceso, sin importar lo que haya en hosts.deny. Si la coincidencia se encuentra en hosts.deny, la petici&oacute;n se rechaza cerrando la conexi&oacute;n. Si no hay coincidencia en ninguno, la petici&oacute;n es aceptada.</P>
<P>Las entradas en los ficheros de acceso tienen la siguiente estructura:</P><DIR>
<DIR>

<P>lista_servicios : lista_nodos [:cmd_shell ]</P></DIR>
</DIR>

</FONT><B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>lista_servicios</b></font><FONT FACE="Verdana" SIZE=2> es una lista de nombres de servicios de /etc/services, o la palabra clave ALL. Para especificar todos los servicios excepto finger y tftp, usa "ALL EXCEPT finger, tftp".</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#008000"><B>lista_nodos</b></font><FONT FACE="Verdana" SIZE=2> es una lista de nombres de nodos o direcciones IP, o las palabras clave ALL, LOCAL, o UNKNOWN. ALL hace coincidir todos los nodos mientras que LOCAL hace coincidir todos los nombres de nodos que no contengan un punto6. UNKNOWN hace coincidir todos los nodos cuya b&uacute;squeda de nombre o direcci&oacute;n fallo. Un nombre comenzado por un punto incluye a todos los nodos cuyo dominio es el mismo a ese nombre. Por ejemplo, .foobar.com encajara con biff.foobar.com. Tambi&eacute;n hay formas de especificar direcciones de red IP y n&uacute;meros de subred. Por favor, refi&eacute;rase a la p&aacute;gina del manual de hosts_access(5) para m&aacute;s detalles.</font></P><FONT FACE="Verdana" SIZE=2>
<P>_____________________________________________<BR>
4 Escrita por Wietse Venema, wietse@wzv.win.tue.nl.<BR>
5 N. del T.: Del ingl&eacute;s Wrapper Daemon</P>
<P>&nbsp;</P>
<P>Para denegar acceso a los servicios finger y tftp a todos los nodos menos a los locales, ponga lo siguiente en /etc/hosts.deny, y deje /etc/hosts.allow vac&iacute;o:</P><DIR>
<DIR>

<P>in.tftpd, in.fingerd: ALL EXCEPT LOCAL, .su.dominio</P></DIR>
</DIR>

<P>El campo opcional cmd_shell puede contener un comando de shell para que sea invocado cuando una b&uacute;squeda coincida con la entrada. Esto es &uacute;til para establecer trampas que puedan delatar a atacantes potenciales:</P><DIR>
<DIR>

<P>in.ftpd: ALL EXCEPT LOCAL, .vbrew.com : \<BR>
echo "petici&oacute;n de %d@%h" &gt;&gt; /var/log/finger.log; \<BR>
if [ %h != "vlager.vbrew.com" ]; then \<BR>
   finger -l @%h &gt;&gt; /var/log/finger.log \<BR>
fi</P></DIR>
</DIR>

<P>Los argumentos %h y %d son expandidos por tcpd al nombre del nodo cliente y al nombre del servicio, respectivamente. Refi&eacute;rase a la p&aacute;gina del manual de hosts_access(5) para mas detalles.</P>
<P>&nbsp;</P>
</FONT><B><U><FONT FACE="Verdana" SIZE=2 COLOR="#008080">
<P><a name="9.3"></a>9.3 Los ficheros services y protocols</P>
</font></u></B><FONT FACE="Verdana" SIZE=2>
<P>Los n&uacute;meros de puerto en los que se ofrecen ciertos servicios "est&aacute;ndar" est&aacute;n definidos en el RFC de "N&uacute;meros Asignados"7. Para permitir a los programas cliente y servidor convertir nombres de servicios en estos n&uacute;meros, se almacenan en un fichero llamado /etc/services. </P>
<P>Una entrada se construye as&iacute;:</P><DIR>
<DIR>

<P>servicio puerto /protocolo [aliases]</P></DIR>
</DIR>

<P>Aqu&iacute;, servicio especifica el nombre del servicio, puerto define el puerto por el que se ofrece el servicio, y protocolo define que protocolo de transporte se usa. Com&uacute;nmente, este es udp o tcp. Es posible que un servicio sea ofrecido a mas de un protocolo, lo mismo que es posible ofrecer distintos servicios por el mismo n&uacute;mero de puerto, siempre que el protocolo sea distinto. El campo aliases permite especificar nombres alternativos para el mismo servicio.</P>
<P>_____________________________________________<BR>
6 Normalmente solo los nombres de nodos locales obtenidos de b&uacute;squedas en /etc/hosts no contienen puntos.<BR>
7 N. del T.: A veces se conocen como Well Known Ports, es decir, Puertos Bien Conocidos</P>
<P>&nbsp;</P>
<P>Usualmente, no se necesita cambiar el fichero de servicios que viene con el software de red en su sistema Linux. De todas formas, presentaremos un peque&ntilde;o extracto de ese fichero.</P><DIR>
<DIR>

<P># El fichero services:<BR>
#<BR>
# servicios conocidos (well-known)<BR>
echo 7/tcp # Eco<BR>
echo 7/udp #<BR>
discard 9/tcp sink null # Descartar<BR>
discard 9/udp sink null #<BR>
daytime 13/tcp # Fecha del sistema<BR>
daytime 13/udp #<BR>
chargen 19/tcp ttytst source # Generador de caracteres<BR>
chargen 19/udp ttytst source #<BR>
ftp-data 20/tcp # Protocolo FTP de ficheros (Datos)<BR>
ftp 21/tcp # Protocolo FTP de ficheros (Control)<BR>
telnet 23/tcp # Protocolo de Terminal<BR>
smtp 25/tcp # Protocolo de Correo<BR>
nntp 119/tcp readnews # Protocolo de Noticias<BR>
#<BR>
# servicios UNIX<BR>
exec 512/tcp # rexecd de BSD<BR>
biff 512/udp comsat # Notificacion de correo<BR>
login 513/tcp # login remoto<BR>
who 513/udp whod # who y uptime remotos<BR>
shell 514/tcp cmd # comando remoto, si contrase~na<BR>
syslog 514/udp # registro remoto del sistema<BR>
printer 515/tcp spooler # cola de impresion remota<BR>
route 520/udp router routed # informacion de encaminamiento</P></DIR>
</DIR>

<P>Observe que, por ejemplo, el servicio echo es ofrecido en el puerto 7 tanto para TCP como para UDP, y que el puerto 512 es usado para dos servicios diferentes; el demonio COMSAT (que notifica a los usuarios de correo reci&eacute;n llegado, vea xbiff(1x)), mediante UDP, y la ejecuci&oacute;n remota (rexec(1)), usando TCP.</P>
<P>Ocurre algo similar con el fichero de protocolos: la librer&iacute;a de red necesita una forma de convertir nombres de protocolo _ por ejemplo, los usados en el fichero services_ a n&uacute;meros de protocolo entendibles por el nivel IP en otros nodos. Esto se hace buscando el nombre en el fichero /etc/protocols. Contiene una entrada por l&iacute;nea, cada una con un nombre de protocolo y el n&uacute;mero asociado. Necesitar modificar este fichero es todav&iacute;a mas improbable que tener que hurgar en /etc/services. Le mostramos un fichero ejemplo:</P><DIR>
<DIR>

<P>#<BR>
# Internet (IP) protocols<BR>
#<BR>
ip 0 IP # protocolo internet, pseudo-protocolo<BR>
icmp 1 ICMP # protocolo de mensajes de control<BR>
igmp 2 IGMP # protocolo para mensajes multidestino<BR>
tcp 6 TCP # protocolo de control de transmision<BR>
udp 17 UDP # protocolo de datagramas de usuario<BR>
raw 255 RAW # interfaz IP directa (modo "crudo")<BR>
"</P>
<P>&nbsp;</P></DIR>
</DIR>

</FONT><B><U><FONT FACE="Verdana" SIZE=2 COLOR="#008080">
<P><a name="9.4"></a>9.4 Llamada a Procedimientos Remotos</P>
</font></u></B><FONT FACE="Verdana" SIZE=2>
<P>Un mecanismo muy general para aplicaciones cliente-servidor lo proporciona RPC, el paquete Remote Procedure Call. RPC fue desarrollado por Sun Microsystems, y es una colecci&oacute;n de herramientas y funciones de librer&iacute;a. Ejemplos de aplicaciones construidas sobre RPC son NFS, el sistema de ficheros en red, y NIS, el sistema de informaci&oacute;n de red, que ser&aacute;n presentados en pr&oacute;ximos cap&iacute;tulos.</P>
<P>Un servidor RPC consiste en una colecci&oacute;n de procedimientos a los que el cliente puede llamar enviando una petici&oacute;n RPC al servidor, junto con los par&aacute;metros del procedimiento.</P>
<P>El servidor invocara al procedimiento indicado en nombre del cliente, devolviendo el valor del resultado, si lo hay. Para que sea independiente de la plataforma, todos los datos intercambiados entre el cliente y el servidor son convertidos al formato denominado de Representaci&oacute;n Externa de Datos o XDR8 por el segundo, y convertidos otra vez a la representaci&oacute;n de la m&aacute;quina local por el receptor.</P>
<P>A veces, las mejoras en una aplicaci&oacute;n RPC introducen cambios incompatibles en el interface de llamada a procedimiento. Por supuesto, solo cambiando el servidor dejar&iacute;a de funcionar cualquier aplicaci&oacute;n que todav&iacute;a espere el comportamiento original. Por ello, los programas RPC tienen n&uacute;meros de versi&oacute;n asignados, normalmente empezando con 1, y con cada nueva versi&oacute;n del interface RPC este contador se incrementara. A menudo, un servidor puede ofrecer varias versiones a la vez; entonces los clientes indicaran en sus peticiones mediante el n&uacute;mero de versi&oacute;n que implementaron del servicio desean usar.</P>
<P>_____________________________________________<BR>
8 N. del T.: del ingl&eacute;s eXternal Data Representation</P>
<P>&nbsp;</P>
<P>La comunicaci&oacute;n por red entre servidores y clientes RPC es un poco peculiar. Un servidor RPC ofrece una o mas colecciones de procedimientos; cada conjunto de &eacute;stos es llamado programa, y es identificado un&iacute;vocamente por un n&uacute;mero de programa. En /etc/rpc se suele mantener una lista que mapea nombres de servicios con n&uacute;meros de programa, reproducimos un extracto de &eacute;ste en la figura 9.2.</P><DIR>
<DIR>

<P>#<BR>
# /etc/rpc - servicios variados basados en RPC<BR>
#<BR>
portmapper 100000 portmap sunrpc<BR>
rstatd 100001 rstat rstat_svc rup perfmeter<BR>
rusersd 100002 rusers<BR>
nfs 100003 nfsprog<BR>
ypserv 100004 ypprog<BR>
mountd 100005 mount showmount<BR>
ypbind 100007<BR>
walld 100008 rwall shutdown<BR>
yppasswdd 100009 yppasswd<BR>
bootparam 100026<BR>
ypupdated 100028 ypupdate</P></DIR>
</DIR>

<P>Figura 9.2: Un ejemplo de fichero /etc/rpc.</P>
<P>En redes TCP/IP, los autores de RPC se encontraron con el problema de mapear n&uacute;meros de programa a servicios de red gen&eacute;ricos. Decidieron que cada servidor proporcionar&aacute; ambos, un puerto TCP y otro UDP, para cada programa y para cada versi&oacute;n. Generalmente, las aplicaciones RPC usaran UDP cuando env&iacute;en datos, y solo recaer&aacute;n en TCP cuando los datos a transferir no quepan en un datagrama UDP sencillo.</P>
<P>Por supuesto, los programas clientes tienen que tener una forma de encontrar a que puerto mapea un n&uacute;mero de programa. Usando un fichero de configuraci&oacute;n para esto ser&iacute;a muy inflexible: ya que las aplicaciones RPC no usan puertos reservados, no hay garant&iacute;as de que un puerto originalmente pensado para ser usado por nuestra aplicaci&oacute;n de base de datos no haya sido cogido por alg&uacute;n otro proceso. Por lo tanto, las aplicaciones RPC escogen cualquier puerto que puedan utilizar, y lo registran con el denominado demonio mapeador de puertos9. Este &uacute;ltimo act&uacute;a como un distribuidor de servicios para todos los servidores que corren en su m&aacute;quina: un cliente que desee contactar con un servicio que tiene un n&uacute;mero de programa dado, preguntara primero al mapeador de puertos del nodo del servidor quien devolver&aacute; los n&uacute;meros de puerto TCP y UDP por los que el servicio puede ser accedido.</P>
<P>Este m&eacute;todo tiene como mayor inconveniente que introduce un punto de ruptura &uacute;nico, muy parecido al que crea el demonio inetd en los servicios Berkeley est&aacute;ndar. De todas formas, este caso es un poco mas grave, porque cuando el mapeador de puertos cae, toda la informaci&oacute;n de puertos RPC se pierde; esto normalmente implica que hay que rearrancar todos los servidores RPC manualmente, o rearrancar toda la m&aacute;quina.</P>
<P>En Linux, el mapeador de puertos se llama rpc.portmap y reside en /usr/sbin. Aparte de asegurarse de que es arrancado desde rc.inet2, el mapeador de puertos no necesita mas trabajo de configuraci&oacute;n.</P>
<P>_____________________________________________<BR>
9 N. del T.: Del ingl&eacute;s Portmapper daemon</P>
<P>&nbsp;</P>
</FONT><B><U><FONT FACE="Verdana" SIZE=2 COLOR="#008080">
<P><a name="9.5"></a>9.5 Configurar los Comandos r</P>
</font></u></B><FONT FACE="Verdana" SIZE=2>
<P>Hay varios comandos para ejecutar programas en nodos remotos. Son rlogin, rsh, rcp y rcmd. Todos ellos lanzan un shell en el nodo remoto y permiten al usuario ejecutar comandos. Por supuesto, el cliente necesita tener una cuenta en el nodo en el que se van a ejecutar los comandos. Por ello todos estos comandos llevan a cabo un procedimiento de autorizaci&oacute;n. Normalmente, el cliente indicara el nombre de login del usuario al servidor, el cual requerir&aacute; un password que ser&aacute; validado de la forma habitual.</P>
<P>A veces, sin embargo, es deseable el relajar estos chequeos de autorizaci&oacute;n para ciertos usuarios. Por ejemplo, si usted tiene que entrar frecuentemente en otras m&aacute;quinas de su LAN, tal vez desee ser admitido sin tener que escribir su password cada vez.</P>
<P>Deshabilitar autorizaciones solo es aconsejable en un n&uacute;mero reducido de nodos cuyas bases de datos de passwords est&eacute;n sincronizadas, o para un n&uacute;mero reducido de usuarios privilegiados que necesiten acceder a muchas m&aacute;quinas por razones administrativas. Siempre que desee permitir a gente entrar en su nodo sin tener que especificar un login o password, debe asegurarse de que no permite acceso accidentalmente a nadie mas.</P>
<P>Hay dos formas de deshabilitar chequeos de autorizaci&oacute;n para los comandos r. Una es que el superusuario permita a ciertos o a todos los usuarios el entrar, sin ser preguntados por un password, en ciertos o en todos los nodos (lo cual es ciertamente una mala idea).</P>
<P>Este acceso es controlado por un fichero denominado /etc/hosts.equiv. Este contiene una lista de nodos y nombres de usuarios que son considerados equivalentes a usuarios en el nodo local. Una opci&oacute;n alternativa es que un usuario permita acceso a otros usuarios de ciertos nodos a su cuenta. Estos serian listados en el fichero .rhosts en el directorio home del usuario. Por razones de seguridad, este fichero debe pertenecer al usuario o al superusuario, y no debe ser un enlace simb&oacute;lico, de otro modo ser&aacute; ignorado.10</P>
<P>Cuando un cliente pide un servicio r, su nodo y nombre de usuario son buscados en el fichero /etc/hosts.equiv, y despu&eacute;s en el fichero .rhosts del usuario con cuyo nombre se pretende entrar. Como ejemplo, asumamos que janet esta trabajando en gauss e intenta entrar en la cuenta de joe en euler. A partir de ahora, nos referiremos a Janet como el usuario cliente, y a Joe como el usuario local. Ahora, cuando Janet escriba</P><DIR>
<DIR>

<P>$ rlogin -l joe euler</P></DIR>
</DIR>

<P>en gauss, el servidor primero chequeara en hosts.equiv 11 si a Janet se le puede proporcionar acceso libre y, si esto falla, intentar&aacute; localizarla en el fichero .rhosts del directorio home de joe.</P>
<P>_____________________________________________<BR>
10 En un entorno NFS, podr&iacute;a necesitar darle una protecci&oacute;n de 444, porque el superusuario por lo general esta muy restringido en el acceso a ficheros en discos montados v&iacute;a NFS.</P>
<P>&nbsp;</P>
<P>El fichero hosts.equiv en euler es algo as&iacute;:</P><DIR>
<DIR>

<P>gauss<BR>
euler<BR>
-public<BR>
quark.physics.groucho.edu andres</P></DIR>
</DIR>

<P>Una entrada consiste en un nombre de nodo, seguido opcionalmente por un nombre de usuario. Si aparece un nombre de nodo y nada mas, todos los usuarios de ese nodo ser&aacute;n admitidos en sus cuentas locales sin ninguna comprobaci&oacute;n. En el ejemplo anterior, Janet hubiera sido autorizada a entrar en su cuenta janet si llamaba desde gauss, y lo mismo se aplicar&iacute;a a cualquier otro usuario exceptuando a root. De todas formas, si Janet desea entrar como joe, se le pedir&iacute;a un password como siempre.</P>
<P>Si un nombre de nodo va seguido de un nombre de usuario, como en la ultima l&iacute;nea del fichero ejemplo, a ese usuario se le permite acceso libre de password a todas las cuentas excepto a la cuenta root.</P>
<P>El nombre de nodo tambi&eacute;n puede ir precedido de un signo menos, como en la entrada "-public". Esto requiere autorizaci&oacute;n para todas las cuentas en public, sin importar lo que permitan los usuarios individuales en sus ficheros .rhosts.</P>
<P>El formato del fichero .rhosts es id&eacute;ntico al del hosts.equiv, pero su significado es un poco diferente. Consideremos el siguiente fichero .rhosts de Joe en euler:</P><DIR>
<DIR>

<P>chomp.cs.groucho.edu<BR>
gauss janet</P></DIR>
</DIR>

<P>La primera entrada permite a joe acceso libre cuando entra desde chomp.cs.groucho.edu, pero no afecta a los permisos de ninguna otra cuenta en euler o chomp. La segunda entrada es una peque&ntilde;a variaci&oacute;n de esto en que permite a janet acceso libre a la cuenta de Joe cuando entra desde gauss.</P>
<P>_____________________________________________<BR>
11 Observe que el fichero hosts.equiv no es examinado cuando alguien intenta entrar como root.</P>
<P>&nbsp;</P>
<P>Observe que el nombre de nodo del cliente se obtiene mediante la resoluci&oacute;n inversa de la direcci&oacute;n del que llama a un nombre, de forma que esta caracter&iacute;stica fallar&aacute; con nodos desconocidos para el sistema de resoluci&oacute;n. El nombre de nodo del cliente se considera que coincide con el nombre en los ficheros de nodos en uno de los siguientes casos:</P>
</FONT><B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#ff0000"><B>o</b></font><FONT FACE="Verdana" SIZE=2> El nombre can&oacute;nico del cliente (no un alias) coincide literalmente con el nombre de nodo en el fichero.</font></P>
<B></B><P><FONT FACE="Verdana" SIZE=2 COLOR="#ff0000"><B>o</b></font><FONT FACE="Verdana" SIZE=2> Si el nombre de nodo del cliente es un nombre de dominio completamente cualificado (como el devuelto por el sistema de resoluci&oacute;n cuando se tiene DNS en marcha), y no coincide literalmente con el nombre de nodo en el fichero de nodos, se compara con el nombre de nodo que se forma al expandirlo con el nombre de dominio local.</font></P></BODY>
</HTML>
