<html><head><meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Servicios principales en un sistema UNIX</title><meta name="generator" content="DocBook XSL Stylesheets V1.68.1"><link rel="start" href="index.html" title="Guía Para Administradores de Sistemas GNU/Linux"><link rel="up" href="ch03.html" title="Capítulo 3. Visión general de un sistema GNU/Linux"><link rel="prev" href="ch03s02.html" title="Partes importantes del núcleo"><link rel="next" href="ch04.html" title="Capítulo 4. Visión General del Árbol de Directorios"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Servicios principales en un sistema UNIX</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch03s02.html">Anterior</a> </td><th width="60%" align="center">Capítulo 3. Visión general de un sistema GNU/Linux</th><td width="20%" align="right"> <a accesskey="n" href="ch04.html">Siguiente</a></td></tr></table><hr></div><div class="sect1" lang="es"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2530843"></a>Servicios principales en un sistema UNIX</h2></div></div></div><p> En esta sección se describen algunos de los servicios más importantes en
UNIX, pero sin mucho detalle. Se describirán más profundamente en capítulos
posteriores.  </p><div class="sect2" lang="es"><div class="titlepage"><div><div><h3 class="title"><a name="id2530857"></a><span><strong class="command">init</strong></span></h3></div></div></div><p> El servicio individual más importante en un sistema UNIX es provisto por
<span><strong class="command">init</strong></span>. <span><strong class="command">init</strong></span> es el primer proceso que se
inicia en todo sistema UNIX, siendo la última acción que el núcleo realiza al
arrancar.  Cuando init comienza su ejecución, continúa con el proceso de
arranque del sistema, realizando varias tareas de inicio (chequear y montar
sistemas de archivos, iniciar demonios, etc.).  </p><p> La lista exacta de cosas que <span><strong class="command">init</strong></span> realiza depende del sistema tipo UNIX
con el que estemos trabajando; existen varios para elegir. <span><strong class="command">init</strong></span> normalmente
proporciona el concepto de <em class="glossterm">modo de usuario individual (single user mode)</em>, en el cual nadie puede
iniciar una sesión y root utiliza un intérprete de comandos en la consola; el
modo usual es llamado <em class="glossterm">modo multiusuario (multiuser mode)</em>.
Algunos sistemas UNIX generalizan esto
como <em class="glossterm">niveles de ejecución (run levels)</em>. Así, los modos individual y
multiusuario son considerados dos niveles de ejecución, y pueden existir otros
niveles adicionales para, por ejemplo, ejecutar X-Windows en la consola.
</p><p> GNU/Linux permite tener hasta 10 <em class="glossterm">niveles de ejecución (runlevels)</em> distintos, 0-9,
pero normalmente solo algunos de estos niveles están definidos por defecto. El
nivel de ejecución 0 se define como &#8220;<span class="quote">sistema detenido (system halt)</span>&#8221;. El nivel
de ejecución 1 se define como &#8220;<span class="quote">modo de usuario individual (single user mode)</span>&#8221;.
El nivel de ejecución 6 se define como &#8220;<span class="quote">reinicio del sistema (system reboot)</span>&#8221;.
Los niveles de ejecución restantes dependen de como la distribución particular
de GNU/Linux los haya definido, y varían significativamente entre
distribuciones. Observando el contenido del archivo
<code class="filename">/etc/inittab</code> podemos hacernos una idea de los niveles de
ejecución preestablecidos en nuestro sistema y de como se encuentran definidos.
</p><p> En el funcionamiento normal, <span><strong class="command">init</strong></span> se asegura de que
<span><strong class="command">getty</strong></span> se encuentre trabajando para permitir que los usuarios puedan iniciar una
sesión, y también se encarga de adoptar procesos huérfanos (aquellos cuyo
proceso padre murió; en UNIX <span class="emphasis"><em>todos</em></span> los procesos <span class="emphasis"><em>deben</em></span> estar
en un árbol individual, y por esta razón los procesos huérfanos deben ser
adoptados).  </p><p> Al cerrar el sistema, es <span><strong class="command">init</strong></span> quien se encarga de
matar todos los procesos restantes, desmontar todos los sistemas de archivos, y
por último detener el procesador, además de cualquier otra cosa que haya sido
configurado para hacer.  </p></div><div class="sect2" lang="es"><div class="titlepage"><div><div><h3 class="title"><a name="id2531030"></a>Inicio de sesiones desde terminales</h3></div></div></div><p> El inicio de sesiones desde terminales (a través de líneas serie) y la
consola (cuando no se está ejecutando X-Windows) es suministrado por el programa
<span><strong class="command">getty</strong></span>. <span><strong class="command">init</strong></span> inicia una instancia
independiente de <span><strong class="command">getty</strong></span> por cada terminal en el que está permitido iniciar
sesiones. <span><strong class="command">Getty</strong></span> lee el nombre de usuario y ejecuta el
programa login, el cual se encarga de leer la password. Si el nombre de usuario
y la password son correctas, <span><strong class="command">login</strong></span> ejecuta el intérprete de
comandos.  Al finalizar el intérprete de comandos (en el caso en que, por
ejemplo, el usuario finaliza su sesión; o cuando <span><strong class="command">login</strong></span> finaliza debido a que no
concuerdan el nombre de usuario y la password), <span><strong class="command">init</strong></span> se
entera de este suceso e inicia una nueva instancia de <span><strong class="command">getty</strong></span>.
El núcleo no tiene noción sobre los inicios de sesiones, esto es gestionado
totalmente por los <em class="glossterm">programas del sistema</em>.  </p></div><div class="sect2" lang="es"><div class="titlepage"><div><div><h3 class="title"><a name="id2531112"></a>Syslog</h3></div></div></div><p> El núcleo y muchos <em class="glossterm">programas de sistema</em> producen
mensajes de error, de advertencia y de otros tipos. La mayoría de las veces, es
importante que puedan ser visualizados mas tarde, o tal vez mucho después, por
lo que tales mensajes deben guardarse en un archivo. El programa que realiza
esta tarea es <span><strong class="command">syslog</strong></span>. Syslog puede ser configurado para
ordenar los mensajes en diferentes archivos, de acuerdo a quien lo emite o al
grado de importancia.  Por ejemplo, los mensajes del núcleo son frecuentemente
dirigidos a un archivo separado de los demás, debido a que son más importantes,
y necesitan ser leídos regularmente para detectar problemas.  </p></div><div class="sect2" lang="es"><div class="titlepage"><div><div><h3 class="title"><a name="id2531153"></a>Ejecución periódica de comandos: <span><strong class="command">cron</strong></span> y
<span><strong class="command">at</strong></span></h3></div></div></div><p> Los administradores de sistemas y los usuarios, a menudo necesitan
ejecutar comandos periódicamente. Como ejemplo, supongamos que el administrador
del sistema desea ejecutar un comando que elimine los archivos más antiguos de
los directorios con archivos temporales (<code class="filename">/tmp</code> y
<code class="filename">/var/tmp</code>) para evitar así que el disco se llene, debido a
que no todos los programas eliminan correctamente los archivos temporales que
ellos mismos generan.  </p><p> El servicio <span><strong class="command">cron</strong></span> se configura para que realice la
tarea anterior. Cada usuario tiene un archivo <code class="filename">crontab</code>, en
el cual se listan los comandos que se desea ejecutar y la fecha y hora de
ejecución. El servicio <span><strong class="command">cron</strong></span> se encarga con precisión de
iniciar cada comando, a la fecha y hora adecuada de acuerdo a lo especificado en
cada archivo crontab.  </p><p> El servicio <span><strong class="command">at</strong></span> es similar a <span><strong class="command">cron</strong></span>,
pero este se inicia únicamente una vez: el comando es ejecutado a la hora
especificada, pero esta ejecución no vuelve a repetirse.  </p><p> Se puede encontrar información adicional sobre cron(1), crontab(5), at(1)
y atd(8) en las páginas de manual.  </p></div><div class="sect2" lang="es"><div class="titlepage"><div><div><h3 class="title"><a name="id2531257"></a>Interfaz gráfica de usuario (GUI)</h3></div></div></div><p> UNIX y GNU/Linux no incorporan la interfaz gráfica de usuario dentro del
núcleo; en su lugar, es implementada por programas a nivel de usuario. Esto se
aplica tanto a entornos gráficos como al modo texto.  </p><p> Esta disposición hace que el sistema sea más flexible, pero tiene la
desventaja de que, al ser simple implementar una interfaz de usuario diferente
para cada programa, dificulta el aprendizaje del sistema.  </p><p> El entorno gráfico principalmente utilizado con GNU/Linux se llama
Sistema X-Windows (X para abreviar). X tampoco implementa por sí mismo una
interfaz de usuario, sino solo un sistema de ventanas. Es decir, las
herramientas base con las cuales se puede construir una interfaz gráfica de
usuario. Algunos administradores de ventanas populares son: fvwm, icewm,
blackbox y windowmaker. Existen también dos populares administradores de
escritorios: KDE y Gnome.  </p></div><div class="sect2" lang="es"><div class="titlepage"><div><div><h3 class="title"><a name="id2531300"></a>Redes</h3></div></div></div><p> Una red se construye al conectar dos o más ordenadores para que puedan
comunicarse entre sí. Los métodos actuales de conexión y comunicación son
ligeramente complicados, pero el resultado final es muy útil.  </p><p> Los sistemas operativos UNIX tienen muchas características de red. La
mayoría de los servicios básicos (sistemas de archivos, impresión, copias de
seguridad, etc) pueden utilizarse a través de la red. Aprovechar estas
características puede ayudar a que la administración del sistema sea más fácil
debido a que permiten tener una administración centralizada, a la vez que
disfrutamos de los beneficios de la micro informática y la informática
distribuida, tales como costes más bajos y mejor tolerancia a fallos.  </p><p> De cualquier modo, este libro sólo aborda superficialmente la teoría de
redes; Se puede encontrar información adicional sobre este tema en La Guía De
Administración De Redes con  Linux (<em class="citetitle">Linux Network Administrators' Guide</em>
	<a href="http://www.tldp.org/LDP/nag2/index.html" target="_top">
	http://www.tldp.org/LDP/nag2/index.html</a>), incluyendo una descripción básica de como
operan las redes.  </p></div><div class="sect2" lang="es"><div class="titlepage"><div><div><h3 class="title"><a name="id2531355"></a>Inicio de sesiones a través de la red</h3></div></div></div><p> Los inicios de sesión a través de la red funcionan de un modo un poco
diferente al inicio de sesiones normales. Existe una línea serie física separada
para cada terminal a través de la cual es posible iniciar sesión. Por cada
persona iniciando una sesión a través de la red existe una conexión de red
virtual, y puede haber cualquier número (no hay límite).  

<sup>[<a name="id2531374" href="#ftn.id2531374">2</a>]</sup>

Por lo tanto, no es
posible ejecutar <span><strong class="command">getty</strong></span> por separado por cada conexión virtual posible. Existen
también varias maneras diferentes de iniciar una sesión a través de la red, las
principales en redes TCP/IP son <span><strong class="command">telnet</strong></span> y <span><strong class="command">rlogin</strong></span>.

<sup>[<a name="id2531409" href="#ftn.id2531409">3</a>]</sup>
</p><p> Los inicios de sesión a través de la red tienen, en vez de una cantidad
enorme de <span><strong class="command">getty's</strong></span>, un servicio individual por tipo de inicio de sesión (<span><strong class="command">telnet</strong></span> y <span><strong class="command">rlogin</strong></span>
tienen servicios separados) que "escucha" todos los intentos de inicio de
sesión entrantes. Cuando el servicio advierte un intento de inicio de sesión,
inicia una nueva instancia de si mismo para atender la petición individual; la
instancia original continúa atenta a otros posibles intentos. La nueva instancia
trabaja de manera similar a <span><strong class="command">getty</strong></span>.  </p></div><div class="sect2" lang="es"><div class="titlepage"><div><div><h3 class="title"><a name="id2531513"></a>Sistemas de archivos de red (NFS)</h3></div></div></div><p> Una de las cosas
más útiles que se pueden hacer con los servicios de red es compartir archivos a
través de un <em class="glossterm">sistema de archivos de red</em>. El más utilizado
normalmente para compartir archivos se llama <em class="glossterm">Network File
System</em>, o <em class="glossterm">NFS</em>, desarrollado por Sun
Microsystems.  </p><p> Con un sistema de archivos de red, cualquier operación sobre un archivo
realizada por un programa en una máquina es enviada a través de la red a otra
máquina. Se "engaña" al programa, haciéndole creer que todos los archivos en el
ordenador remoto se encuentran de hecho en el ordenador en el que el programa se
está ejecutando. Con esta manera de trabajar, compartir información es
extremadamente simple, ya que no se requieren modificaciones en el programa.
</p><p> Otra manera muy popular de compartir archivos es a través de Samba
(<a href="http://www.samba.org" target="_top">http://www.samba.org</a>). Este protocolo
(llamado SMB) permite compartir archivos con máquinas Windows a través del
Entorno de Red. También permite compartir impresoras.  </p></div><div class="sect2" lang="es"><div class="titlepage"><div><div><h3 class="title"><a name="id2531573"></a>Correo</h3></div></div></div><p> El correo electrónico es el método más popularmente utilizado para
comunicarse a través del ordenador. Una carta electrónica se almacena en un
archivo con un formato especial, y se utilizan programas de correo especiales
para enviar y leer las cartas.  </p><p> Cada usuario tiene un <em class="glossterm">buzón de correo entrante</em> (un
archivo con formato especial), en donde se almacena todo el correo nuevo. Cuando
alguien  envía un correo, el programa de correo localiza el buzón del
destinatario y agrega la carta al archivo de buzón de correo entrante. Si el
buzón del destinatario se encuentra en otra máquina, la carta es enviada allí,
donde se traslada al buzón de correo como corresponda.  </p><p> El sistema de correo se compone de muchos programas. El transporte del
correo a buzones locales o remotos es realizado por un programa: <em class="glossterm">el
agente de transporte de correo</em> o <em class="glossterm">MTA</em>.
(<span><strong class="command">Sendmail</strong></span> y <span><strong class="command">Smail</strong></span> son dos ejemplos de
esto), mientras que existe un sin número de programas muy variados que los
usuarios utilizan para leer y escribir correos (<em class="glossterm">Estos son conocidos
como agentes de usuario de correo </em>o <em class="glossterm">MUA</em>,
<span><strong class="command">Pine</strong></span> y <span><strong class="command">Elm</strong></span> son ejemplos de esto). Los
archivos de buzones de correo están usualmente ubicados en
<code class="filename">/var/spool/mail</code>.  </p></div><div class="sect2" lang="es"><div class="titlepage"><div><div><h3 class="title"><a name="id2531670"></a>Impresión</h3></div></div></div><p> Solo una persona puede utilizar la impresora en un momento dado, pero
sería antieconómico no compartir impresoras entre los usuarios. La impresora es
por lo tanto administrada por software que implementa una cola de impresión:
todos los trabajos de impresión son colocados dentro de la cola, y una vez que
la impresora termina de imprimir una trabajo, el siguiente es enviado a la
impresora automáticamente. Esto alivia al usuario de la organización de la cola
de impresión y de luchar por el control de la impresora.  </p><p> El software de la cola de impresión también coloca los trabajos de
impresión en disco, es decir, el texto a imprimir es mantenido en un archivo
mientras que el trabajo se encuentre en la cola. Esto permite a los programas de
aplicación entregar rápidamente los trabajos a imprimir al software que
administra la <em class="glossterm">cola de impresión</em>; así, las aplicaciones no
tienen que esperar a que el trabajo (en inglés "job") esté de hecho impreso para
poder continuar su ejecución. Esta forma de trabajar es realmente cómoda, ya que
permite enviar a imprimir una versión de un trabajo y no tener que esperar a que
ésta sea impresa antes de poder hacer una versión nueva completamente revisada.
</p></div><div class="sect2" lang="es"><div class="titlepage"><div><div><h3 class="title"><a name="id2531721"></a>La distribución del sistema de archivos</h3></div></div></div><p> El sistema de archivos está dividido en muchas partes; normalmente en las
líneas de un sistema de archivos raíz con <code class="filename">/bin</code>,
<code class="filename">/lib</code>, <code class="filename">/etc</code>, <code class="filename">/dev</code>,
y otros pocos directorios; un sistema de archivos <code class="filename">/usr</code> con programas y datos que
no tendrán cambios; un sistema de archivos <code class="filename">/var</code> con datos que pueden cambiar
(como los archivos de log); y un sistema de archivos <code class="filename">/home</code>
para todos los archivos personales de los usuarios. Dependiendo de la
configuración del hardware y de las decisiones del administrador del sistema, la
división puede llegar a ser diferente; a pesar de esto, y aunque la división es
aconsejable, es también posible distribuir todos los archivos en un solo sistema
de archivos.  </p><p> En el <a href="ch04.html" title="Capítulo 4. Visión General del Árbol de Directorios">Capítulo 4, <i>Visión General del Árbol de Directorios</i></a> se describe la distribución del sistema de archivos con
algo de detalle; el documento "Estándar de la Jerarquía del Sistema de Archivos
de Linux" cubre este tema más en profundidad.
<sup>[<a name="id2531807" href="#ftn.id2531807">4</a>]</sup>  </p></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id2531374" href="#id2531374">2</a>] </sup>Al menos puede haber muchas. Dado que el ancho de banda es un
recurso escaso, existe aún en la práctica algún límite al
número de inicios de sesión concurrentes a través de una conexión
de red. </p></div><div class="footnote"><p><sup>[<a name="ftn.id2531409" href="#id2531409">3</a>] </sup>Hoy en día muchos administradores de sistemas Linux consideran
que <span><strong class="command">telnet</strong></span> y <span><strong class="command">rlogin </strong></span> son inseguros y
prefieren <span><strong class="command">ssh </strong></span>, el &#8220;<span class="quote">intérprete de comandos
seguro</span>&#8221; que 			encripta el tráfico en la red, haciendo
así bastante menos probable que usuarios malintencionados puedan
&#8220;<span class="quote">espiar</span>&#8221; la 				conexión y obtener datos
sensibles como nombres de usuario y 				passwords. Está
altamente recomendado usar <span><strong class="command">ssh</strong></span> 			en lugar
de <span><strong class="command">telnet</strong></span> o <span><strong class="command">rlogin</strong></span>.  </p></div><div class="footnote"><p><sup>[<a name="ftn.id2531807" href="#id2531807">4</a>] </sup><a href="http://www.pathname.com/fhs/" target="_top">
	http://www.pathname.com/fhs/</a></p></div></div></div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch03s02.html">Anterior</a> </td><td width="20%" align="center"><a accesskey="u" href="ch03.html">Subir</a></td><td width="40%" align="right"> <a accesskey="n" href="ch04.html">Siguiente</a></td></tr><tr><td width="40%" align="left" valign="top">Partes importantes del núcleo </td><td width="20%" align="center"><a accesskey="h" href="index.html">Inicio</a></td><td width="40%" align="right" valign="top"> Capítulo 4. Visión General del Árbol de Directorios</td></tr></table></div></body></html>
