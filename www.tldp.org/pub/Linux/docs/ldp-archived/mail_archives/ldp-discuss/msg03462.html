<!-- MHonArc v2.5.0b2 -->
<!--X-Subject: Re: Fw: Submitted: final draft of HOWTO -->
<!--X-From-R13: Bngevpx Qnyynuna <cnp1Ngvnp.arg> -->
<!--X-Date: Mon, 24 Jul 2000 19:18:05 &#45;0400 (EDT) -->
<!--X-Message-Id: 397CCDEA.F384128C@tiac.net -->
<!--X-Content-Type: text/plain -->
<!--X-Reference: 20000724084842.22838.qmail@nwcst282.netaddress.usa.net -->
<!--X-Head-End-->
<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML//EN">
<html>
<head>
<title>Re: Fw: Submitted: final draft of HOWTO</title>
<link rev="made" href="mailto:pac1@tiac.net">
</head>
<body>
<!--X-Body-Begin-->
<!--X-User-Header-->
<!--X-User-Header-End-->
<!--X-TopPNI-->
<hr>
[<a href="msg03461.html">Date Prev</a>][<a href="msg03463.html">Date Next</a>][<a href="msg03442.html">Thread Prev</a>][<a href="msg03489.html">Thread Next</a>][<a href="maillist.html#03462">Date Index</a>][<a href="threads.html#03462">Thread Index</a>]
<!--X-TopPNI-End-->
<!--X-MsgBody-->
<!--X-Subject-Header-Begin-->
<h1>Re: Fw: Submitted: final draft of HOWTO</h1>
<hr>
<!--X-Subject-Header-End-->
<!--X-Head-of-Message-->
<ul>
<li><em>To</em>: Pal Domokos &lt;<A HREF="mailto:pal.domokos@usa.net">pal.domokos@usa.net</A>&gt;, Bodvar Bjorgvinsson &lt;<A HREF="mailto:bodvar@veda.is">bodvar@veda.is</A>&gt;,       digs &lt;<A HREF="mailto:mjs@nts-online.net">mjs@nts-online.net</A>&gt;, Aaron King &lt;<A HREF="mailto:islandblend@home.com">islandblend@home.com</A>&gt;,       Juan Fuentes &lt;<A HREF="mailto:juan.fuentes@codetel.net.do">juan.fuentes@codetel.net.do</A>&gt;,       Mike Novack &lt;<A HREF="mailto:stepbystepfarm@shaysnet.com">stepbystepfarm@shaysnet.com</A>&gt;,       ngcooper &lt;<A HREF="mailto:ngcooper@wa.freei.net">ngcooper@wa.freei.net</A>&gt;,       &quot;Lonnie R. Mullenix&quot; &lt;<A HREF="mailto:mullenix@wwdb.org">mullenix@wwdb.org</A>&gt;,       Nick Sklavenitis &lt;<A HREF="mailto:sklav@intelerad.com">sklav@intelerad.com</A>&gt;, Sam &lt;<A HREF="mailto:peacemkr@wcc.net">peacemkr@wcc.net</A>&gt;,       &quot;<A HREF="mailto:ldp-discuss@lists.debian.org">ldp-discuss@lists.debian.org</A>&quot; &lt;<A HREF="mailto:ldp-discuss@lists.debian.org">ldp-discuss@lists.debian.org</A>&gt;</li>
<li><em>Subject</em>: Re: Fw: Submitted: final draft of HOWTO</li>
<li><em>From</em>: Patrick Callahan &lt;<A HREF="mailto:pac1@tiac.net">pac1@tiac.net</A>&gt;</li>
<li><em>Date</em>: Mon, 24 Jul 2000 19:14:50 -0400</li>
<li><em>References</em>: &lt;20000724084842.22838.qmail@nwcst282.netaddress.usa.net&gt;</li>
<li><em>Resent-date</em>: Mon, 24 Jul 2000 19:18:05 -0400 (EDT)</li>
<li><em>Resent-from</em>: <A HREF="mailto:ldp-discuss@lists.debian.org">ldp-discuss@lists.debian.org</A></li>
<li><em>Resent-message-id</em>: &lt;tOnFMC.A.EYG.e7Mf5@murphy&gt;</li>
<li><em>Resent-sender</em>: <A HREF="mailto:ldp-discuss-request@lists.debian.org">ldp-discuss-request@lists.debian.org</A></li>
<li><em>Sender</em>: pac1</li>
</ul>
<!--X-Head-of-Message-End-->
<!--X-Head-Body-Sep-Begin-->
<hr>
<!--X-Head-Body-Sep-End-->
<!--X-Body-of-Message-->
<pre>
All of this discussion is in preparation for suggesting specific
additions to the Bash Howto to cover the issue of differing syntax
across processing boundaries in bash.  The point of the back and forth
discussion is to better understand what is really happening and to
develop appropriate example scripts before doing any serious writing.

Paul, Thanks in advance for your response, here's more.

Pal Domokos wrote:
&gt; 
&gt; Hi Patrick,
&gt; 
&gt; Comments to your problem:
&gt; 1. In your first example the $s are missing:
&gt; i=1;j=2
&gt; &gt; &gt; if [ i -eq 1 &amp;&amp; j -eq 2 ]
&gt; &gt; &gt; then
&gt; &gt; &gt;    echo &quot;i=1 and j=2&quot;
&gt; &gt; &gt; else
&gt; &gt; &gt;    echo &quot;i&lt;&gt; 1 or j&lt;&gt; 2&quot;
&gt; &gt; &gt; fi
&gt; (Not that it matters too much...)
&gt; 
Sorry about that.  In an effort to get this to work, I tried a lot of
different variations on syntactic forms, not all of them correct. This
was one of them..  You are right of course, the intended example had the
$i and $j and you are correct that it did not make a difference in the
resulting message for the reason you gave later. 

&gt; 2. Run your program with sh -x and see what it shows:
&gt; $ sh -x a_if.sh
&gt; 
&gt; Why 'if [ $i -eq 1 &amp;&amp; $j -eq 2 ]' does not work?
&gt; &amp;&amp; is for bash, therefore it tries to evaluate both sides of
&gt; the condition, i.e. both sides should be correct in themselves.
&gt; [ $i -eq 1     is obviously not correct.
&gt; 
&gt; Why 'if [ $i -eq 1 -a $j -eq 2 ]' does work?
&gt; -a is an option for test, therefore in this
&gt; case bash passes the whole condition to test and test processes it.
&gt; 
&gt; That's why this also works:
&gt; if [ $1 -eq 1 ] &amp;&amp; [ $2 -eq 1 ]
&gt; (two calls of test)
&gt; 
That's pretty much what I figured. but Oh my that -x is handy.  It
appears to show what bash is evaluating at each step.  What's it doing
exactly, and why can't I find it in the list of options for bash?  does
this feature have a name?


  
My post if you can get through all the verbiage comes to the same
conclusion.
Your more concise version points out that bash is evaluating the
expression [ $i -eq 1 before evaluating &amp;&amp;  is this correct?  Is this
where the message regarding the missing ] is coming from.  What happens
to the rest of the expression, is it just abandoned, because the first
part is &quot;false&quot;?  As a test of this question I modified the test script
yet again:


#!/bin/sh
if [ $1 -eq 1 || $2 -eq 2 ]
then
   echo &quot;i=1 and j=2&quot;
else
   echo &quot;i&lt;&gt; 1 or j&lt;&gt; 2&quot;
fi
 

$ ./a_if.sh 1 1
./a_if.sh: [: missing `]'
./a_if.sh: 1: command not found
i&lt;&gt; 1 or j&lt;&gt; 2   ./a_if.sh 1 1
./a_if.sh: [: missing `]'
./a_if.sh: 1: command not found
i&lt;&gt; 1 or j&lt;&gt; 2   

Note the difference:  bash again complains that the ] is missing from
the part before the || and evaluates the incorrect expression as false. 
because this time we're using || instead of &amp;&amp;, bash continues with the
evaluation in hopes of finding the value true.  In this case a second
error message appears, this one says 1 is an invalid command.  the
evaluation of the second half of the expression attempts to decipher 1
-eq 2 ] as if it were a command.  Of course it fails because 1 is not a
command.

Question:  Is there any legal way to use &amp;&amp; in a test command.  Maybe
something with parenthesis so bash evaluates to something that test can
use?



&gt; Well, I'm not a bash guru but I think this is how it works.
&gt; 
&gt; Cheers,
&gt; Pal
&gt; 


&gt; Patrick Callahan &lt;pac1@tiac.net&gt; wrote:
&gt; &gt; Mike &amp; Penny Novack wrote:
&gt; &gt; &gt;
&gt; &gt; &gt; Because my personal coding style (in any language) is to always
&gt; &gt; &gt; explicitly specify the order of evaluation I never seem to get involved
&gt; &gt; &gt; with these questions. Have you considered what the relative order of
&gt; &gt; &gt; operator precedence might be?. A &quot;condition&quot; is after all only a value
&gt; &gt; &gt; (typically zero =&gt; false, anything else true). Try inserting whatever
&gt; &gt; &gt; serves as &quot;parentheses&quot; around each conditional expression and see what
&gt; &gt; &gt; happens to the evaluation.
&gt; &gt; &gt;
&gt; &gt; &gt; My suspicion is that &quot;-a&quot; and &quot;-o&quot; work because they have lower
&gt; &gt; &gt; precedence than any relation that might appear inside a &quot;condition&quot;.
&gt; &gt; &gt; What happens if you start out example &quot;A&quot; with i=1;j=1 (adjusting the
&gt; &gt; &gt; other items accordingly). Does it now work? That might be the case if
&gt; &gt; &gt; the precedence of &quot;&amp;&amp;&quot; is equal or greater than that of &quot;-eq&quot;.
&gt; &gt; &gt;
&gt; &gt;
&gt; &gt; Mike,
&gt; &gt;
&gt; &gt; That's a great insight.
&gt; &gt;
&gt; &gt; There's some info on how bash handles precedence and the order of
&gt; &gt; evaluation of things in bash. It didn't seem to help but a few
&gt; &gt; experiments clarified what's going on.
&gt; &gt;
&gt; &gt; Its an interesting problem.  Bash the language vs Bash the executor of
&gt; &gt; other commands with different languages.  Where does the line get drawn
&gt; &gt; between various parts of the &quot;language space&quot;.
&gt; &gt;
&gt; &gt; Incidently, this is the exact problem I'm struggling with trying to use
&gt; &gt; the Python - PMW - Tkinter - tkinter - tk packages to build a GUI.  It's
&gt; &gt; difficult to discern which level of interface and which a particular
&gt; &gt; syntic form  applies.  Both bash and python cross linguistic borders.
&gt; &gt; This can make a perfectly ordinary conceptual structure difficult to
&gt; &gt; implement for those not used to the border crossings.  We're accustomed
&gt; &gt; to binding values, types and methods across interfaces, but the
&gt; &gt; resulting syntactic ambiguity when different languages are used on
&gt; &gt; either side of the interface is something to consider.  Something to
&gt; &gt; think about for Bash 3.0:  the problem of binding syntax across an
&gt; &gt; interface.  Has anyone else thought about this?
&gt; &gt;
&gt; &gt; Anyway to get some info on this I tried a few potential variations.  I
&gt; &gt; tried putting the expressions in parenthesis and brackets but that
&gt; &gt; didn't work.
&gt; &gt;
&gt; &gt; if [ ( $1 -eq 1 ) &amp;&amp; ( $2 -eq 1 ) ]
&gt; &gt; if [ [ $1 -eq 1 ] &amp;&amp; [ $2 -eq 1 ] }
&gt; &gt;
&gt; &gt; The problem with bash is that it calls lots of other programs to do
&gt; &gt; things
&gt; &gt; like /etc/bin/test.  I think the &amp;&amp; and || operators exist only in bash
&gt; &gt; and not in test.
&gt; &gt; expressions like [ $1 &amp;&amp; $2 ] work because bash calculates $1 &amp;&amp; $2 and
&gt; &gt; passes the result of the calculation to test.
&gt; &gt; with expressions like [ $1 -eq 1 &amp;&amp; $2 -eq 1 ] bash doesn't do the
&gt; &gt; arithmetic right and what gets passed to test somehow includes the
&gt; &gt; closing bracket, as if it were part of the conditional expression.  it
&gt; &gt; would be interesting to see if test is actually getting passed anything
&gt; &gt; or if the whole test is failing due to a parsing error and returning 1
&gt; &gt; to the if.  In case of an error, if seems to be getting the value false.
&gt; &gt;
&gt; &gt; That seems to be what's going on.
&gt; &gt;
&gt; &gt; one more test revealed a solution
&gt; &gt;
&gt; &gt; if [ $1 -eq 1 ] &amp;&amp; [ $2 -eq 1 ] operated correctly
&gt; &gt;
&gt; &gt; Although you could easily come to the conclusion reading the bash manual
&gt; &gt; that the syntax of an if statement in bash is
&gt; &gt;
&gt; &gt; if [conditional-expression]
&gt; &gt; then
&gt; &gt; fi
&gt; &gt;
&gt; &gt; That's not what really happens.
&gt; &gt;
&gt; &gt; the real syntax of an if command is
&gt; &gt; if bash-condition-expression
&gt; &gt; then
&gt; &gt; fi
&gt; &gt;
&gt; &gt; and [ condition ] is just one kind of bash-conditional-expression.  In
&gt; &gt; fact, [ is a separate program that takes values provided by the shell as
&gt; &gt; arguments.  [  has its own syntax for expressions contained in its
&gt; &gt; arguments and returns a result.  in fact, [ or if you prefer /bin/test
&gt; &gt; just processes its command arguments whatever they are.  before [ gets
&gt; &gt; its arguments, bash applies its rules to whatever is in between the
&gt; &gt; square brackets.  so the expression as originally stated was being
&gt; &gt; evaluated as follows by bash, before passing it as arguments to [.  Bash
&gt; &gt; is probably evaluating the elements of the command line containing the
&gt; &gt; if statement sequentially.
&gt; &gt;
&gt; &gt;
&gt; &gt; [ $1 -eq 1 &amp;&amp; $2 -eq 1 ]
&gt; &gt;
&gt; &gt;   [ 1 -eq 1 &amp;&amp; 1 -e1 1 ]
&gt; &gt;   [ 1 -eq (1 &amp;&amp; 1) -eq 1 ]
&gt; &gt;   [ 1 -eq     1    -eq 1 ]
&gt; &gt;
&gt; &gt; What the error message ./a_if.sh: [: missing `]'  indicates is that bash
&gt; &gt; probably prepared to pass the following to test:
&gt; &gt;
&gt; &gt;    1 -eq 1 -eq ]
&gt; &gt;
&gt; &gt; This is not particularly meaningful as input to test, but that doesn't
&gt; &gt; matter, I think test doesn't even get called.  bash next compained that
&gt; &gt; the open [ of the test command was missing a closing bracket.  The
&gt; &gt; missing bracket is the one bash was preparing to send to or may have
&gt; &gt; actually sent to /bin/test in its arguments.
&gt; &gt;
&gt; &gt; The if statment itself behaves as if it got a false from the whole
&gt; &gt; expression.  Even when an if statment contains garbage, bash continues
&gt; &gt; with the if.
&gt; &gt;
&gt; &gt; #!/bin/sh
&gt; &gt; if ,*&amp;^%$#@!
&gt; &gt; then
&gt; &gt;    echo &quot;garbage is true&quot;
&gt; &gt; else
&gt; &gt;    echo &quot;garbage is false&quot;
&gt; &gt; fi
&gt; &gt;
&gt; &gt; $ ./a_if8.sh
&gt; &gt; ./a_if8.sh: ,*: command not found
&gt; &gt; ./a_if8.sh: ^%0@!: command not found
&gt; &gt; garbage is false
&gt; &gt;
&gt; &gt;
&gt; &gt;
&gt; &gt;
&gt; &gt; -pat
&gt; &gt;
&gt; &gt;
&gt; &gt;
&gt; &gt;
&gt; &gt;
&gt; &gt;  &gt;
&gt; &gt; &gt; Another  language element continues to give me trouble.  It is the
&gt; &gt; &gt; combination of conditions in an if statement, and the tutorial does
&gt; &gt; not
&gt; &gt; &gt; go into enough specifics on this point.
&gt; &gt; &gt;
&gt; &gt; &gt; Using &amp;&amp; to join two &quot;conditions&quot;  does not work as &quot;expected&quot; when
&gt; &gt; the
&gt; &gt; &gt; elements combined with &amp;&amp; and || are not variables, but &quot;conditions&quot;.
&gt; &gt; &gt; There's an element of syntax that I'm missing to make Example A work
&gt; &gt; &gt; correctly, and no reference I've been able to find shows what it is or
&gt; &gt; &gt; explains the difference between &amp;&amp; and || on one hand and -a and -o on
&gt; &gt; &gt; the other.  I think your howto would be an excellent place to get into
&gt; &gt; &gt; this issue.
&gt; &gt; &gt;
&gt; &gt; &gt; Example A:
&gt; &gt; &gt;
&gt; &gt; &gt; #!/bin/sh
&gt; &gt; &gt;
&gt; &gt; &gt; # using &amp;&amp; to join &quot;conditions&quot; as shown does not work properly
&gt; &gt; &gt;
&gt; &gt; &gt; i=1;j=2
&gt; &gt; &gt; if [ i -eq 1 &amp;&amp; j -eq 2 ]
&gt; &gt; &gt; then
&gt; &gt; &gt;    echo &quot;i=1 and j=2&quot;
&gt; &gt; &gt; else
&gt; &gt; &gt;    echo &quot;i&lt;&gt; 1 or j&lt;&gt; 2&quot;
&gt; &gt; &gt; fi
&gt; &gt; &gt;
&gt; &gt; &gt; $ chmod +x a_if.sh
&gt; &gt; &gt; $ ./a_if.sh
&gt; &gt; &gt; ./a_if.sh: [: missing `]'
&gt; &gt; &gt; i&lt;&gt; 1 or j&lt;&gt; 2
&gt; &gt; &gt;
&gt; &gt; &gt; note the error message and incorrect operation in the version of the
&gt; &gt; &gt; script using &amp;&amp; to join two &quot;conditions&quot;
&gt; &gt; &gt;
&gt; &gt; &gt; Example B:
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; #!/bin/sh
&gt; &gt; &gt;
&gt; &gt; &gt; # using -a to join two conditions using &quot;and&quot; does work properly
&gt; &gt; &gt;
&gt; &gt; &gt; i=1;j=2
&gt; &gt; &gt; if [ $i -eq 1 -a $j -eq 2 ]
&gt; &gt; &gt; then
&gt; &gt; &gt;    echo &quot;i=1 and j=2&quot;
&gt; &gt; &gt; else
&gt; &gt; &gt;    echo &quot;i&lt;&gt; 1 or j&lt;&gt; 2&quot;
&gt; &gt; &gt; fi
&gt; &gt; &gt;
&gt; &gt; &gt; Executing
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; $ ./a_if3.sh
&gt; &gt; &gt; not i or not j
&gt; &gt; &gt;
&gt; &gt; &gt;
&gt; &gt; &gt; This use of -a or -o working in the above construct seems to conflict
&gt; &gt; &gt; with the following from the bash manual and from the HOWTO.  I think
&gt; &gt; an
&gt; &gt; &gt; explanation of what is really happening in this case would enhance the
&gt; &gt; &gt; HOWTO.  To most of us from other programming environments $i -eq 1
&gt; &gt; looks
&gt; &gt; &gt; like a condition, so we need an explanation of why the construct as
&gt; &gt; &gt; written in example A does not work while the construct in example B
&gt; &gt; does
&gt; &gt; &gt; not.  I'm assuming the construct works if the conditions are
&gt; &gt; &quot;variables&quot;
&gt; &gt; &gt; and not conditional expressions, at least conditional expressions as
&gt; &gt; &gt; written in Example A:  We need advice on what exact syntax to use to
&gt; &gt; &gt; accomplish the intent expressed in example A.  If &amp;&amp; and || are
&gt; &gt; limited
&gt; &gt; &gt; to being used as operators on variables that's ok.  If there's a way
&gt; &gt; to
&gt; &gt; &gt; write a conditional expression using actual conditional expressions
&gt; &gt; that
&gt; &gt; &gt; will be properly combined using &amp;&amp; or || we'll need an example of that
&gt; &gt; &gt; too.
&gt; &gt; &gt;
&gt; &gt; &gt; What we have in the Bash Reference and the HOWTO does not address this
&gt; &gt; &gt; issue properly, or if it does, the information is not presented in an
&gt; &gt; &gt; order that will allow it to be found easily.
&gt; &gt; &gt;
&gt; &gt; &gt; &amp;&amp;
&gt; &gt; &gt;
&gt; &gt; &gt;        and (logical)
&gt; &gt; &gt;
&gt; &gt; &gt;         if [ $condition1 &amp;&amp; $condition2 ]
&gt; &gt; &gt;         # if both condition1 and condition2 hold true...
&gt; &gt; &gt;
&gt; &gt; &gt; ||
&gt; &gt; &gt;
&gt; &gt; &gt;        or (logical)
&gt; &gt; &gt;
&gt; &gt; &gt;         if [ $condition1 || $condition2 ]
&gt; &gt; &gt;         # if both condition1 or condition2 hold true...
&gt; &gt; &gt;
&gt; &gt;
&gt; &gt;
&gt; &gt; From:
&gt; &gt;                &quot;M. Leo Cooper&quot; &lt;thegrendel@theriver.com&gt;
&gt; &gt;
&gt; 
&gt; &gt; Sun 16:35
&gt; &gt;
&gt; &gt;        Subject:
&gt; &gt;                Submitted: final draft of HOWTO
&gt; &gt;  Resent-From:
&gt; &gt;                ldp-discuss@lists.debian.org
&gt; &gt;            To:
&gt; &gt;                ldp-discuss@lists.linuxdoc.org
&gt; &gt;
&gt; &gt;
&gt; &gt;
&gt; &gt;
&gt; &gt; I have submitted the final draft of my &quot;Advanced Bash-Scripting HOWTO&quot;,
&gt; &gt; version 0.1, to the group by sending it as as a tarballed file
&gt; &gt; attachment
&gt; &gt; to ldp-submit.
&gt; &gt;
&gt; &gt; This document is also downloadable from my web site:
&gt; &gt; <A  HREF="http://personal.riverusers.com/~thegrendel/abs-HOWTO-0.1.tar.gz">http://personal.riverusers.com/~thegrendel/abs-HOWTO-0.1.tar.gz</A>
&gt; &gt;
&gt; &gt; [125 k]
&gt; &gt;
&gt; &gt;
&gt; &gt; The tarball on my site also has the HTML conversion of the document. The
&gt; &gt; document itself is, of course, in Docbook/SGML, thanks to Philippe
&gt; &gt; Martin.
&gt; &gt;
&gt; &gt; Any comments and constructive criticism would be appreciated.
&gt; &gt;
&gt; &gt; Thanks.
&gt; &gt;
&gt; &gt;
&gt; &gt; Mendel
&gt; &gt;
&gt; &gt;
&gt; &gt; --
&gt; &gt; To UNSUBSCRIBE, email to ldp-discuss-request@lists.debian.org
&gt; &gt; with a subject of &quot;unsubscribe&quot;. Trouble? Contact
&gt; listmaster@lists.debian.org
&gt; 
&gt; ____________________________________________________________________
&gt; Get free email and a permanent address at <A  HREF="http://www.netaddress.com/?N=1">http://www.netaddress.com/?N=1</A>


--  
To UNSUBSCRIBE, email to ldp-discuss-request@lists.debian.org
with a subject of &quot;unsubscribe&quot;. Trouble? Contact listmaster@lists.debian.org

</pre>

<!--X-Body-of-Message-End-->
<!--X-MsgBody-End-->
<!--X-Follow-Ups-->
<hr>
<!--X-Follow-Ups-End-->
<!--X-References-->
<!--X-References-End-->
<!--X-BotPNI-->
<ul>
<li>Prev by Date:
<strong><a href="msg03461.html">Thoughts on Open Publication License? (From ESR)</a></strong>
</li>
<li>Next by Date:
<strong><a href="msg03463.html">Feedback</a></strong>
</li>
<li>Previous by thread:
<strong><a href="msg03442.html">Re: Fw: Submitted: final draft of HOWTO</a></strong>
</li>
<li>Next by thread:
<strong><a href="msg03489.html">Re: Submitted: final draft of HOWTO</a></strong>
</li>
<li>Index(es):
<ul>
<li><a href="maillist.html#03462"><strong>Date</strong></a></li>
<li><a href="threads.html#03462"><strong>Thread</strong></a></li>
</ul>
</li>
</ul>

<!--X-BotPNI-End-->
<!--X-User-Footer-->
<!--X-User-Footer-End-->
</body>
</html>
