<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Guide pratique des disquettes d'amorçage</title><link rel="stylesheet" href="style.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.64.1"><meta name="description" content="
Ce document explique comment concevoir et créer ses propres disquettes
d'amorçage et disquettes racines pour Linux. Ces disquettes peuvent être
utilisées comme disques de secours, ou pour l'essai de nouveaux
composants système. Avant de tenter de créer une disquette d'amorçage,
il est recommandé d'avoir un compréhension raisonnable de
l'administration d'un système Linux. Si vous souhaitez juste créer des
disquettes de secours, lisez la .
"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article" lang="fr"><div class="titlepage"><div><div><h1 class="title"><a name="id2393981"></a>Guide pratique des disquettes d'amorçage</h1></div><div><h3 class="subtitle"><i>Version française du <span class="foreignphrase"><i class="foreignphrase">Bootdisk 
HOWTO</i></span></i></h3></div><div><div class="author"><h3 class="author"><span class="firstname">Tom</span> <span class="surname">Fawcett</span></h3><div class="affiliation"><div class="address"><p><tt class="email">&lt;<a href="mailto:fawcett%20CHEZ%20croftj%20POINT%20net">fawcett CHEZ croftj POINT net</a>&gt;</tt></p></div></div></div></div><div><p class="othercredit"><span class="contrib">Adaptation française</span>: <span class="firstname">Mathieu</span> <span class="surname">Decore</span></p><div class="affiliation"><div class="address"><p><tt class="email">&lt;<a href="mailto:mdecore%20CHEZ%20linux%20TIRET%20france%20POINT%20org">mdecore CHEZ linux TIRET france POINT org</a>&gt;</tt></p></div></div></div><div><p class="othercredit"><span class="contrib">Adaptation française (version 3.5)</span>: <span class="firstname">Frank</span> <span class="surname">Pavageau</span></p><div class="affiliation"><div class="address"><p><tt class="email">&lt;<a href="mailto:pavageau%20CHEZ%20imaginet%20POINT%20fr">pavageau CHEZ imaginet POINT fr</a>&gt;</tt></p></div></div></div><div><p class="othercredit"><span class="contrib">Relecture de la version française</span>: <span class="firstname">Guillaume</span> <span class="surname">Hatt</span></p><div class="affiliation"><div class="address"><p><tt class="email">&lt;<a href="mailto:ghatt%20CHEZ%20netcourrier%20POINT%20com">ghatt CHEZ netcourrier POINT com</a>&gt;</tt></p></div></div></div><div><p class="othercredit"><span class="contrib">Préparation de la publication</span>: <span class="firstname">Jean-Philippe</span> <span class="surname">Guérard</span></p><div class="affiliation"><div class="address"><p><tt class="email">&lt;<a href="mailto:jean%20TIRET%20philippe%20POINT%20guerard%20CHEZ%20laposte%20POINT%20net">jean TIRET philippe POINT guerard CHEZ laposte POINT net</a>&gt;</tt></p></div></div></div><div><p class="releaseinfo">Version 4.5.fr.1.0</p></div><div><p class="pubdate">20 juin 2003</p></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="3"><b>Historique des versions</b></th></tr><tr><td align="left">Version 4.5.fr.1.0</td><td align="left">2003-06-20</td><td align="left">MD, GH, JPG</td></tr><tr><td align="left" colspan="3">
        Mise à jour de la version française. Conversion en XML (MD).
    </td></tr><tr><td align="left">Version 4.5</td><td align="left">Janvier 2002</td><td align="left">TF</td></tr><tr><td align="left">Version 4.0</td><td align="left">2000-04-01</td><td align="left">TF</td></tr><tr><td align="left">Version 3.5.fr.1.0</td><td align="left">Juillet 1999</td><td align="left">FP</td></tr><tr><td align="left">Version 3.5</td><td align="left">Juillet 1999</td><td align="left">TF</td></tr></table></div></div><div><div class="abstract"><p class="title"><b>Résumé</b></p><p>
Ce document explique comment concevoir et créer ses propres disquettes
d'amorçage et disquettes racines pour Linux. Ces disquettes peuvent être
utilisées comme disques de secours, ou pour l'essai de nouveaux
composants système. Avant de tenter de créer une disquette d'amorçage,
il est recommandé d'avoir un compréhension raisonnable de
l'administration d'un système Linux. Si vous souhaitez juste créer des
disquettes de secours, lisez la <a href="#distbootdisks" title="1. Disques d'amorce préfabriqués">Section 1, « Disques d'amorce préfabriqués »</a>.
</p></div></div></div><div></div><hr></div><div class="toc"><p><b>Table des matières</b></p><dl><dt><span class="sect1"><a href="#id2436177">1. Préface</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2436221">1.1. Notes</a></span></dt><dt><span class="sect2"><a href="#id2436283">1.2. À faire</a></span></dt><dt><span class="sect2"><a href="#id2435339">1.3. Retours et remerciements</a></span></dt><dt><span class="sect2"><a href="#id2435741">1.4. Politique de distribution</a></span></dt><dt><span class="sect2"><a href="#id2435447">1.5. Notes du traducteur</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2435558">2. Introduction</a></span></dt><dt><span class="sect1"><a href="#id2497320">3. Disques d'amorce et démarrage</a></span></dt><dd><dl><dt><span class="sect2"><a href="#boot">3.1. Démarrage</a></span></dt><dt><span class="sect2"><a href="#id2497845">3.2. Types de disques</a></span></dt></dl></dd><dt><span class="sect1"><a href="#buildroot">4. Construire un système racine</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2498057">4.1. Aperçu</a></span></dt><dt><span class="sect2"><a href="#creatingrootfs">4.2. Création du système de fichiers</a></span></dt><dt><span class="sect2"><a href="#id2498789">4.3. Remplissage du système de fichiers</a></span></dt><dt><span class="sect2"><a href="#PAMNSS">4.4. Utilisation de PAM et NSS</a></span></dt><dt><span class="sect2"><a href="#id2500731">4.5. Modules</a></span></dt><dt><span class="sect2"><a href="#id2500877">4.6. Quelques ultimes détails</a></span></dt><dt><span class="sect2"><a href="#wrappingitup">4.7. C'est dans la poche</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2501037">5. Choisir un noyau</a></span></dt><dt><span class="sect1"><a href="#id2501166">6. Assemblage et fabrication de la ou des disquettes</a></span></dt><dd><dl><dt><span class="sect2"><a href="#usinglilo">6.1. Transfert du noyau avec LILO</a></span></dt><dt><span class="sect2"><a href="#withoutlilo">6.2. Transfert du noyau sans LILO</a></span></dt><dt><span class="sect2"><a href="#ramdiskword">6.3. Mise en place du mot disque mémoire</a></span></dt><dt><span class="sect2"><a href="#id2502074">6.4. Transfert du système racine</a></span></dt></dl></dd><dt><span class="sect1"><a href="#troubleshooting">7. En cas de problème, ou l'agonie de la défaite</a></span></dt><dt><span class="sect1"><a href="#slimfast">8. Réduire la taille du système racine</a></span></dt><dd><dl><dt><span class="sect2"><a href="#high-density">8.1. Augmentez la densité du disque</a></span></dt><dt><span class="sect2"><a href="#id2503120">8.2. Remplacer les utilitaires indispensables par BusyBox</a></span></dt><dt><span class="sect2"><a href="#id2503196">8.3. Changez de shell</a></span></dt><dt><span class="sect2"><a href="#id2503273">8.4. Nettoyez les bibliothèques et binaires</a></span></dt><dt><span class="sect2"><a href="#id2503351">8.5. Déplacez les fichiers non essentiels vers un disque
utilitaire</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2503384">9. Sujets divers</a></span></dt><dd><dl><dt><span class="sect2"><a href="#nonramdiskroot">9.1. Système racine sans disque mémoire</a></span></dt><dt><span class="sect2"><a href="#utilitydisk">9.2. Construire un disque utilitaire</a></span></dt></dl></dd><dt><span class="sect1"><a href="#pros">10. La méthode des pros</a></span></dt><dt><span class="sect1"><a href="#cdrom">11. Créer des CD-ROM amorçables</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2504104">11.1. Qu'est-ce que El Torito ?</a></span></dt><dt><span class="sect2"><a href="#id2504147">11.2. Comment ça marche</a></span></dt><dt><span class="sect2"><a href="#id2504240">11.3. Comment le faire marcher</a></span></dt><dt><span class="sect2"><a href="#id2504424">11.4. Créer des CD-ROM Win9x amorçables</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2504525">12. Foire Aux Questions (FAQ)</a></span></dt><dt><span class="appendix"><a href="#references">A. Ressources et pointeurs</a></span></dt><dd><dl><dt><span class="sect1"><a href="#distbootdisks">1. Disques d'amorce préfabriqués</a></span></dt><dt><span class="sect1"><a href="#id2506177">2. Paquetages de secours</a></span></dt><dt><span class="sect1"><a href="#id2506216">3. LILO : le chargeur Linux</a></span></dt><dt><span class="sect1"><a href="#id2506271">4. Utilisation du disque mémoire</a></span></dt><dt><span class="sect1"><a href="#id2506323">5. Le processus de démarrage de Linux</a></span></dt></dl></dd><dt><span class="appendix"><a href="#id2506475">B. Codes d'erreur du démarrage de LILO</a></span></dt><dt><span class="appendix"><a href="#listings">C. Exemple de contenu de répertoires sur un disque racine</a></span></dt><dt><span class="appendix"><a href="#utilitylist">D. Exemple de contenu des répertoires d'un disque utilitaire</a></span></dt></dl></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2436177"></a>1. Préface</h2></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Note: Ce document peut être obsolète."><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Note]" src="images/note.png"></td><th align="left">Ce document peut être obsolète.</th></tr><tr><td colspan="2" align="left" valign="top"><p>
Si la date sur la page de titre a plus de six mois, vérifiez la page du
Projet de documentation Linux (LDP) <a href="http://www.ibiblio.org/LDP/HOWTO/Bootdisk-HOWTO.html" target="_top">http://www.ibiblio.org/LDP/HOWTO/Bootdisk-HOWTO.html</a> (et 
sa traduction française <a href="http://www.traduc.org/docs/howto/lecture/Bootdisk-HOWTO.html" target="_top">http://www.traduc.org/docs/howto/lecture/Bootdisk-HOWTO.html</a>) au cas où une version plus 
récente s'y trouverait.
</p></td></tr></table></div><p>
Bien que ce document soit lisible dans sa forme texte, il a
<span class="emphasis"><em>bien</em></span> meilleure allure en PostScript, PDF ou HTML en
raison de la typographie utilisée.

</p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2436221"></a>1.1. Notes</h3></div></div><div></div></div><p>
<a class="indexterm" name="id2436233"></a> Graham Chapman
(<tt class="email">&lt;<a href="mailto:grahamc%20CHEZ%20zeta%20POINT%20org%20POINT%20au">grahamc CHEZ zeta POINT org POINT au</a>&gt;</tt>) a
écrit le premier Bootdisk-HOWTO et en a assuré la maintenance jusqu'à la
version 3.1. Tom Fawcett (<tt class="email">&lt;<a href="mailto:fawcett%20CHEZ%20croftj%20POINT%20net">fawcett CHEZ croftj POINT net</a>&gt;</tt>) 
a ajouté beaucoup d'informations pour le support du noyau 2.0, et 
effectue désormais la maintenance du document, depuis la version 3.2 qui 
contient toujours une bonne partie écrite par Chapman.  Chapman a 
disparu de la communauté Linux et personne ne sait actuellement où il se 
trouve.
</p><p>
Les informations contenues dans ce document concernent Linux sur 
plate-forme <span class="trademark">Intel</span>™. Bien des éléments doivent 
pouvoir être appliqués à Linux sur d'autres processeurs, mais nous n'en 
avons pas personnellement l'expérience, ni ne possédons d'informations 
de ce type. Si quelqu'un a expérimenté les disques d'amorce sur d'autres 
plates-formes, qu'il nous contacte.
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2436283"></a>1.2. À faire</h3></div></div><div></div></div><div class="orderedlist"><ol type="1"><li><p>
User-mode-linux (<a href="http://user-mode-linux.sourceforge.net/" target="_top">http://user-mode-linux.sourceforge.net/</a>) semble être un
bon moyen de tester les disquettes d'amorce sans avoir à redémarrer la
machine sans arrêt. Je ne l'ai pas testé. Si quelqu'un l'a fait
fonctionner de manière significative pour fabriquer ses propres
disquettes d'amorce, merci de me le faire savoir.</p></li><li><p>Ré-analyser la distribution de la disquettes d'amorce et
mettre à jour la section « La méthode des pros »
</p></li><li><p>
Trouver jusqu'où la séquence init-getty-login peut être simplifiée, et
la remplacer. Quelque personnes m'ont dit que <span><b class="command">init</b></span>
peut être un lien vers <span><b class="command">/bin/sh</b></span> ; si c'est le cas, et
que cela n'impose pas de grandes modifications, changer les instructions
pour le faire. Cela permettrait d'éliminer l'utilisation de
<span><b class="command">getty</b></span>, <span><b class="command">login</b></span>,
<span><b class="command">gettydefs</b></span>, et sans doute tout ce qui concerne PAM et
NSS.
</p></li><li><p>
Aller à nouveau dans le code source du noyau 2.4 et écrire une
explication détaillée sur la procédure de démarrage et de chargement du
disque mémoire (seulement si je le comprends mieux). Il y a des
fonctionnalités à propos de <span><b class="command">initrd</b></span> et les limitations
concernant les périphériques de démarrage (comme les cartes flash) que
je ne comprends pas encore.
</p></li><li><p>
Supprimer la section qui décrit comment mettre à jour une disquettes
d'amorce. C'est la plupart du temps source de trop de tracas.
</p></li><li><p>
Remplacer la commande <span><b class="command">rdev</b></span> par les mots-clefs
<span><b class="command">LILO</b></span>.
</p></li></ol></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2435339"></a>1.3. Retours et remerciements</h3></div></div><div></div></div><p>
Tout retour, bon ou mauvais, sur le contenu de ce document est le
bienvenu. Nous avons fait de notre mieux pour vérifier que les
instructions et informations ici présentes sont précises et fiables.
Merci de nous signaler toute erreur ou omission.
</p><p>
Nous remercions les nombreuses personnes nous ayant fourni des
corrections et suggestions. Leurs contributions ont permis d'améliorer
ce document bien au delà de ce que nous aurions pu réaliser seuls.
</p><p>
Envoyez vos commentaires, corrections et questions en anglais à l'auteur 
à l'adresse ci-dessus (ou au traducteur pour des problèmes dans la 
version française). Cela ne me dérange pas d'essayer de répondre à vos
questions, mais merci de lire la <a href="#troubleshooting" title="7. En cas de problème, ou l'agonie de la défaite">Section 7, « En cas de problème, ou l'agonie de la défaite »</a>
d'abord.
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2435741"></a>1.4. Politique de distribution</h3></div></div><div></div></div><p><span class="foreignphrase"><i class="foreignphrase">
Copyright © 1995,1996,1997,1998,1999 by Tom Fawcett and Graham
Chapman. This document may be distributed under the terms set forth
in the Linux Documentation Project License at
<a href="http://www.ibiblio.org/LDP/COPYRIGHT.html" target="_top">
http://www.ibiblio.org/LDP/COPYRIGHT.html</a>.  Please contact the
authors if you are unable to get the license.
</i></span></p><p><span class="foreignphrase"><i class="foreignphrase">
Copyright © 1999,2003 by Frank Pavageau and copyright © 
2003 by Mathieu Decore and Guillaume Hatt for the French translation.
This document may be distributed under the terms of the Linux 
Documentation Project License, which is hereby included by reference
<a href="http://www.ibiblio.org/LDP/COPYRIGHT.html" target="_top">http://www.ibiblio.org/LDP/COPYRIGHT.html</a>.
</i></span></p><p><span class="foreignphrase"><i class="foreignphrase">
This is free documentation.  It is distributed in the hope that it will
be useful, but <span class="emphasis"><em>without any warranty</em></span>; without even
the implied warranty of <span class="emphasis"><em>merchantability</em></span> or
<span class="emphasis"><em>fitness for a particular purpose</em></span>.
</i></span></p><p>
Copyright © 1995,1996,1997,1998,1999 Tom Fawcett et Graham
Chapman. Ce document peut être distribué sous les termes de la Licence
du Linux Documentation Project lisible à <a href="http://www.ibiblio.org/LDP/COPYRIGHT.html" target="_top">http://www.ibiblio.org/LDP/COPYRIGHT.html</a>. Merci de 
contacter les auteurs si vous n'arrivez pas à récupérer la licence.
</p><p>
Copyright © 1999 Frank Pavageau et copyright © 2003 
Mathieu Decore et Guillaume Hatt pour la version française. Ce document 
est distribué sous les termes de la licence du Projet de documentation 
Linux (LDP). Cette licence est ci-incluse par référence : <a href="http://www.ibiblio.org/LDP/COPYRIGHT.html" target="_top">http://www.ibiblio.org/LDP/COPYRIGHT.html</a>.
</p><p>
Cette documentation est libre. Elle est distribuée dans l'espoir d'être
utile, mais <span class="emphasis"><em>sans aucune garantie</em></span> ; sans même la
garantie implicite de <span class="emphasis"><em>valeur marchande</em></span> ou de
<span class="emphasis"><em>correspondre à un but particulier</em></span>.
</p><p>
Vous utilisez les informations contenues dans ce document à vos
propres risques. Nous déclinons toute responsabilité quant à son
contenu. L'utilisation des concepts, des exemples ou de tout autre
contenu se fait entièrement à vos propres risques.
</p><p>
Tous les droits sont détenus par leurs propriétaires respectifs, sauf
mention contraire explicite. L'utilisation d'un terme dans ce document
ne constitue pas une limitation à sa validité en tant que marque.
</p><p>
Le fait de citer un produit ou une marque particulière ne constitue
pas un endossement.
</p><p>
Il est fortement conseillé d'effectuer une sauvegarde de votre système
avant une installation importante ainsi qu'à intervalles réguliers.
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2435447"></a>1.5. Notes du traducteur</h3></div></div><div></div></div><p>
Correspondances anglais/français utilisées dans la traduction :
</p><div class="itemizedlist"><ul type="disc"><li><p>I/O : E/S, entrées/sorties.</p></li><li><p>backup : archive.</p></li><li><p>boot loader : chargeur, lanceur.</p></li><li><p>boot : amorce, amorcer, démarrage, démarrer.</p></li><li><p>boot/root disk : disquette d'amorce/racine.</p></li><li><p>dynamic library : bibliothèque partagée.</p></li><li><p>filesystem : système de fichiers, système.</p></li><li><p>inode : i-nœud.</p></li><li><p>library : bibliothèque.</p></li><li><p>loopback device : périphérique de boucle.</p></li><li><p>package : paquetage.</p></li><li><p>path : chemin.</p></li><li><p>ramdisk : disque virtuel en mémoire, disque mémoire.</p></li><li><p>root device : périphérique racine.</p></li><li><p>root : racine.</p></li><li><p>runlevel : niveau d'exécution.</p></li><li><p>swap : pagination.</p></li></ul></div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2435558"></a>2. Introduction</h2></div></div><div></div></div><p>
Les disques d'amorce Linux sont utiles dans nombre de situations,
telles que :
</p><div class="itemizedlist"><ul type="disc"><li><p>Tester un nouveau noyau ;</p></li><li><p>Redémarrer après un problème de disque : tout depuis la
perte d'un secteur d'amorce à l'atterrissage d'une tête de lecture sur
le disque ;
</p></li><li><p>Réparer un système endommagé. Une petite erreur en tant
que root peut rendre le système inutilisable, et il peut alors être
nécessaire de démarrer depuis une disquette pour corriger le problème ;
</p></li><li><p>Mettre à jour des fichiers critiques du système, tels
que <tt class="filename">libc.so</tt>.
</p></li></ul></div><p>
Les disques d'amorce peuvent être obtenus de différentes manières :
</p><div class="itemizedlist"><ul type="disc"><li><p>Utiliser ceux d'une distribution telle que la Slackware.
Cela vous permettra au moins de démarrer ;
</p></li><li><p>Utiliser un paquetage de création de disques de secours,
prévus pour les cas d'urgence ;
</p></li><li><p>Apprendre ce que nécessite le fonctionnement de chaque
type de disque, puis créer les vôtres.
</p></li></ul></div><p>
Certaines personnes choisissent la dernière solution afin de tout
faire eux-mêmes. Ainsi, si quelque chose ne marche plus, ils peuvent
se débrouiller pour corriger le problème. Et c'est un excellent moyen
pour apprendre le fonctionnement d'un système Linux.
</p><p>
Ce document suppose une certaine familiarité avec les concepts
d'administration d'un système Linux. Par exemple, vous devez connaître
les répertoires, les systèmes de fichiers, les disquettes. Vous devez
savoir utiliser <span><b class="command">mount</b></span> et <span><b class="command">df</b></span>, à
quoi servent les fichiers <tt class="filename">/etc/passwd</tt> et
<tt class="filename">fstab</tt> et quelle tête ils ont. Enfin, vous devez
savoir que la plupart des commandes dans ce <span class="foreignphrase"><i class="foreignphrase">howto</i></span> doivent être exécutées
en tant que root.
</p><p>
Créer vos propres disquettes d'amorce à partir de zéro peut être
compliqué. Si vous n'avez pas lu la FAQ Linux et autres documents du
même genre, tels que le <span class="foreignphrase"><i class="foreignphrase">howto</i></span> d'installation Linux et le Guide
d'installation de Linux, vous ne devriez pas essayer de créer des
disques d'amorce. Si vous souhaitez juste créer des disques pour
prévenir les cas urgents, il est <span class="emphasis"><em>bien</em></span> plus simple
d'en récupérer des préfabriqués. Lisez l'appendice <a href="#distbootdisks" title="1. Disques d'amorce préfabriqués">Section 1, « Disques d'amorce préfabriqués »</a> ci-dessous pour savoir où en trouver.
</p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2497320"></a>3. Disques d'amorce et démarrage</h2></div></div><div></div></div><a class="indexterm" name="id2497325"></a><p>
Un disque d'amorce est essentiellement un système Linux miniature et
auto-suffisant contenu sur une disquette. Il doit pouvoir effectuer
nombre d'opérations possibles sur un système Linux de taille
normale. Avant d'essayer d'en créer un, vous devez comprendre les
bases du démarrage de Linux. Nous en faisons ici une présentation qui
devrait suffire à la compréhension de la suite du document. Bien des
détails ou des possibilités ont été omis.
</p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="boot"></a>3.1. Démarrage</h3></div></div><div></div></div><a class="indexterm" name="id2497458"></a><p>
Tous les PC démarrent en exécutant du code situé en mémoire morte (à
savoir, le <span class="acronym">BIOS</span>) afin de charger le secteur situé au
secteur 0, cylindre 0 du <span class="emphasis"><em>disque d'amorce</em></span>. Celui-ci
est habituellement le premier lecteur de disquette (appelé
<span class="emphasis"><em>A:</em></span> sous DOS et <tt class="filename">/dev/fd0</tt> sous
Linux). Le <span class="acronym">BIOS</span> essaye alors d'exécuter ce secteur.
Sur la plupart des disques d'amorce, le secteur 0, cylindre 0 contient :
</p><div class="itemizedlist"><ul type="disc"><li><p>soit le code d'un chargeur tel que
<span><b class="command">LILO</b></span>, qui trouve le noyau, le charge et l'exécute
pour réaliser le démarrage proprement dit,
</p></li><li><p>soit le début du noyau d'un système d'exploitation, tel
que Linux.
</p></li></ul></div><p>
Si un noyau Linux a été copié directement sur une disquette, le
premier secteur du disque sera le premier secteur du noyau Linux
lui-même. Ce premier secteur continuera le démarrage en chargeant le
reste du noyau depuis le périphérique d'amorce.
</p><p>
Une fois que le noyau est complètement chargé, il effectue certaines
initialisations de périphériques ainsi que de ses données internes.  Une
fois qu'il est complètement initialisé, il consulte un endroit
particulier dans son image appelé le <span class="emphasis"><em>mot disque
mémoire</em></span>. Ce mot précise comment et où trouver le système de
fichiers racine.  Un système de fichiers racine est simplement celui qui
est monté en tant que « / ». Il faut dire au noyau où trouver ce système
racine ; s'il ne peut trouver d'image à charger, il s'arrête.
</p><p>
Dans certains cas au démarrage (souvent lors du démarrage depuis une
disquette), le système de fichiers racine est chargé dans un
<span><b class="command">disque mémoire</b></span>, auquel le système accède ensuite en
mémoire comme s'il s'agissait d'un vrai disque. Il y a deux raisons à
un tel chargement en mémoire. Premièrement, la mémoire vive est de
plusieurs ordres de magnitude plus rapide qu'une disquette, et le
système est donc rapide ; deuxièmement, le noyau peut charger un
<span class="emphasis"><em>système de fichiers compressé</em></span> depuis la disquette
et le décompresser en mémoire, permettant ainsi de stocker plus de
fichiers sur la disquette.
</p><p>
Une fois le système de fichiers racine chargé et monté, vous voyez un
message tel que :
</p><pre class="programlisting">
VFS: Mounted root (ext2 filesystem) readonly.
</pre><a class="indexterm" name="id2497605"></a><a class="indexterm" name="id2497616"></a><a class="indexterm" name="id2497628"></a><p>
À ce moment, le système trouve le programme <span><b class="command">init</b></span> dans
le système racine (dans <tt class="filename">/bin</tt> ou
<tt class="filename">/sbin</tt>) et l'exécute. <span><b class="command">init</b></span> lit sa
configuration dans <tt class="filename">/etc/inittab</tt>, cherche une ligne
nommée <span class="emphasis"><em>sysinit</em></span>, et exécute le script indiqué. Le
script <span><b class="command">sysinit</b></span> est en général un fichier du genre
<tt class="filename">/etc/rc</tt> ou <tt class="filename">/etc/init.d/boot</tt>.
Le script est un ensemble de commandes shell qui mettent en place les
services de base du système, tels que :
</p><div class="itemizedlist"><ul type="disc"><li><p>Lancer <span><b class="command">fsck</b></span> sur tous les disques
;</p></li><li><p>Charger les <span class="emphasis"><em>modules</em></span> nécessaires du
noyau ;</p></li><li><p>Lancer la pagination ;</p></li><li><p>Initialiser le réseau ;</p></li><li><p>Monter les disques indiqués dans
<tt class="filename">fstab</tt>.</p></li></ul></div><p>
Ce script appelle lui-même souvent nombre d'autres scripts pour réaliser
une initialisation modulaire. Par exemple, dans la structure SysVinit
habituelle, le répertoire <tt class="filename">/etc/rc.d/</tt> contient une
structure complexe de sous-répertoires dont les fichiers indiquent
comment lancer et arrêter la plupart des services du système. En revanche,
sur un disque d'amorce, le script <span><b class="command">sysinit</b></span> est
souvent très simple.
</p><p>
Quand le script <span><b class="command">sysinit</b></span> se termine, le contrôle
revient à <span><b class="command">init</b></span>, qui entre alors dans le
<span class="emphasis"><em>niveau d'exécution par défaut</em></span>, spécifié dans
<tt class="filename">inittab</tt> par le mot clé
<span class="emphasis"><em>initdefault</em></span>. La ligne du niveau d'exécution indique
en général un programme tel que <span><b class="command">getty</b></span>, responsable de
la gestion des communications par la console ou les
<tt class="filename">tty</tt>. C'est le programme <span><b class="command">getty</b></span>
qui affiche l'invite habituelle <span class="emphasis"><em>login:</em></span>. Lui-même
exécute à son tour le programme <span><b class="command">login</b></span> pour gérer la
validation du login et mettre en place la session de l'utilisateur.
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2497845"></a>3.2. Types de disques</h3></div></div><div></div></div><p>
Après avoir revu les bases du démarrage, nous pouvons définir les
différents types de disques mis en jeu. Ces disques sont classés en
quatre catégories. Ça et là dans le document, on emploie le terme
<span class="emphasis"><em>disque</em></span> pour désigner une disquette, sauf précision
contraire, bien que la majeure partie de la discussion puisse également
s'appliquer à des disques durs.
</p><div class="variablelist"><dl><dt><span class="term">Amorce</span></dt><dd><p>
Un disque contenant un noyau pouvant être amorcé. Il peut
être utilisé pour démarrer le noyau, qui pourra alors charger un
système racine depuis un autre disque. Il est en général nécessaire
d'indiquer au noyau où se trouve ce système racine.
</p><p>
Souvent un disque d'amorce charge le système racine depuis une autre
disquette, mais il est possible de lui indiquer un disque dur d'où il
chargera le système racine à la place. Souvent, c'est dans le but de
tester un nouveau noyau (d'ailleurs, <span><b class="command">make zdisk</b></span> crée
un tel disque d'amorce automatiquement à partir du code source du
noyau).
</p></dd><dt><span class="term">Racine</span></dt><dd><p>
Un disque avec un système de fichiers contenant les
fichiers nécessaires au fonctionnement d'un système Linux. Un tel
disque ne contient pas forcément un noyau ou un chargeur.
</p><a class="indexterm" name="id2497924"></a><p>
Un disque racine peut être utilisé pour faire tourner le système
indépendamment de tout autre disque, une fois le noyau amorcé. En
général le disque racine est copié automatiquement vers un disque
mémoire. Cela permet un accès au disque racine bien plus rapide, et
libère le lecteur pour une disquette d'utilitaires.
</p></dd><dt><span class="term">Amorce/racine</span></dt><dd><p> Un disque contenant à la fois un noyau
<a class="indexterm" name="id2497954"></a>
et un système de fichiers racine. Autrement dit, il contient tout ce
qui est nécessaire au démarrage et au fonctionnement d'un système
Linux sans disque dur. L'avantage de ce type de disque est sa
compacité : tout ce dont on a besoin est sur un seul
disque. Néanmoins, la taille toujours plus importante des programmes
implique une difficulté croissante pour tout faire tenir sur une seule
disquette, même avec de la compression.
</p></dd><dt><span class="term">Utilitaire</span></dt><dd><p> Un disque contenant un système de fichier non destiné
à être monté en tant que racine. Il s'agit d'un disque de données
supplémentaires. Vous pouvez utiliser ce genre de disque pour rajouter
des utilitaires, quand vous en avez trop pour un seul disque amorce.
<a class="indexterm" name="id2497994"></a>
</p></dd></dl></div><p>
En général, lorsque l'on parle de « construire un disque 
d'amorce », c'est de la création des parties amorce (noyau) 
et racine 
(fichiers) qu'il est question, soit en un seul morceau (un seul disque 
amorce/racine), soit séparément (un disque amorce et un racine). 
L'approche la plus flexible pour des disquettes de secours est 
d'utiliser des disquettes amorce et racine séparées, et une ou plusieurs 
disquettes utilitaires pour supporter le trop-plein.
</p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="buildroot"></a>4. Construire un système racine</h2></div></div><div></div></div><p>
Pour créer un système racine, il faut sélectionner les fichiers
nécessaires au système pour fonctionner. Dans cette section nous
décrivons comment créer un <span class="emphasis"><em>système racine
compressé</em></span>. Une option moins courante est de créer un système
non compressé sur une disquette que l'on monte directement ; cette
alternative est décrite dans la <a href="#nonramdiskroot" title="9.1. Système racine sans disque mémoire">Section 9.1, « Système racine sans disque mémoire »</a>.
</p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2498057"></a>4.1. Aperçu</h3></div></div><div></div></div><p>
Un système racine doit contenir tout ce qui est nécessaire au bon
fonctionnement d'un système Linux complet. Pour cela, le disque doit
contenir un système Linux minimum :
</p><div class="itemizedlist"><ul type="disc"><li><p>La structure de base des fichiers ;</p></li><li><p>Un ensemble minimum de répertoires :
<tt class="filename">/dev</tt>, <tt class="filename">/proc</tt>,
<tt class="filename">/bin</tt>, <tt class="filename">/etc</tt>,
<tt class="filename">/lib</tt>, <tt class="filename">/usr</tt>,
<tt class="filename">/tmp</tt> ;
</p></li><li><p>Un ensemble d'utilitaires de base :
<span><b class="command">sh</b></span>, <span><b class="command">ls</b></span>, <span><b class="command">cp</b></span>,
<span><b class="command">mv</b></span>, et cætera ;
</p></li><li><p>Un ensemble minimum de fichiers de 
configuration :
<span><b class="command">rc</b></span>, <tt class="filename">inittab</tt>,
<tt class="filename">fstab</tt>, et cætera ;
</p></li><li><p>Des périphériques : <tt class="filename">/dev/hd*</tt>,
<tt class="filename">/dev/tty*</tt>, <tt class="filename">/dev/fd0</tt>, et cætera ;
</p></li><li><p>Des bibliothèques d'exécution fournissant les fonctions
de base nécessaires aux utilitaires.</p></li></ul></div><p>
Bien sûr, n'importe quel système devient utile dès que l'on peut faire
tourner quelque chose dessus, et une disquette racine ne devient en
général utilisable que lorsque vous pouvez faire quelque chose du genre
:
</p><div class="itemizedlist"><ul type="disc"><li><p>Contrôler un système de fichiers sur un autre disque ;
par exemple, pour contrôler le système racine de votre disque dur, vous
devez pouvoir démarrer Linux depuis un autre disque, telle qu'une
disquette racine. Vous pouvez alors lancer <span><b class="command">fsck</b></span> sur
votre disque racine habituel tant qu'il n'est pas monté ;
</p></li><li><p>Récupérer tout ou partie de votre disque racine initial
à partir d'une sauvegarde en utilisant des utilitaires d'archivage et de
compression tels que <span><b class="command">cpio</b></span>, <span><b class="command">tar</b></span>,
<span><b class="command">gzip</b></span> et <span><b class="command">ftape</b></span>.
</p></li></ul></div><p>
Nous décrirons comment construire un système
<span class="emphasis"><em>compressé</em></span>, ainsi appelé car il est compressé sur
disque et qu'une fois démarré, le noyau le décompresse dans un disque
mémoire.  <a class="indexterm" name="id2498281"></a> Avec un système compressé vous pouvez
faire tenir beaucoup de fichiers (à peu près six méga-octets) sur une
disquette standard de 1440 ko. Puisque le système de fichiers est 
bien
plus gros que la disquette, il ne peut être construit directement sur la
disquette. Il nous faut le construire ailleurs et le compresser avant de
le copier sur la disquette.
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="creatingrootfs"></a>4.2. Création du système de fichiers</h3></div></div><div></div></div><p>
Pour créer un tel système racine, il vous faut un autre périphérique
capable de stocker tous les fichiers avant leur compression. Ce
périphérique doit pouvoir contenir à peu près quatre
méga-octets. Plusieurs solutions s'offrent à vous :
</p><div class="itemizedlist"><ul type="disc"><li><p>Utiliser un <span class="emphasis"><em>disque mémoire</em></span>
(PÉRIPHÉRIQUE = <tt class="filename">/dev/ram0</tt>). Dans ce cas, la mémoire
est utilisée pour simuler un disque physique. Le disque mémoire doit
être suffisamment grand pour contenir un système de fichiers de la bonne
taille. Si vous utilisez <span><b class="command">LILO</b></span>, cherchez dans votre
fichier de configuration (<tt class="filename">/etc/lilo.conf</tt>) une ligne
du type :
</p><pre class="programlisting">
RAMDISK_SIZE = nnn
</pre><a class="indexterm" name="id2498362"></a><p>
qui détermine combien de mémoire peut être au plus allouée à un disque
mémoire. La valeur par défaut est de 4096 ko, ce qui devrait
suffire. Il ne sert probablement à rien de créer un tel disque mémoire
sur une machine possédant moins de 8 Mo de RAM.
</p><p>
Vérifiez que vous avez un périphérique tel que
<tt class="filename">/dev/ram0</tt>, <tt class="filename">/dev/ram</tt> ou
<tt class="filename">/dev/ramdisk</tt>. Si ce n'est pas le cas, créez
<tt class="filename">/dev/ram0</tt> avec mknod (numéro majeur 1, numéro
mineur 0).
</p></li><li><p>Une partition de disque dur inutilisée et assez grande
(plusieurs méga-octets) est aussi une bonne solution.
</p></li><li><p>Utiliser un <span class="emphasis"><em>périphérique de boucle
(loopback)</em></span>, qui permet d'utiliser un fichier comme s'il
s'agissait d'un périphérique normal. Avec un périphérique de boucle,
vous pouvez créer un fichier de 3 méga-octets sur votre disque dur et
construire le système de fichiers dedans.
</p><p>
Tapez <span><b class="command">man losetup</b></span> pour savoir comment utiliser un
périphérique de boucle. Si vous n'avez pas <span><b class="command">losetup</b></span>,
vous pouvez le récupérer, ainsi que des versions compatibles de
<span><b class="command">mount</b></span> et <span><b class="command">umount</b></span>, dans le paquetage
<span class="emphasis"><em>util-linux</em></span> disponible dans le répertoire <a href="ftp://ftp.win.tue.nl/pub/linux-local/utils/util-linux/" target="_top">
ftp://ftp.win.tue.nl/pub/linux-local/utils/util-linux/</a>.
</p><p>
Si vous n'avez pas de périphérique de boucle
(<tt class="filename">/dev/loop0</tt>, <tt class="filename">/dev/loop1</tt>, et cætera)
sur votre système, vous devez en créer un avec <span><b class="command">mknod /dev/loop0
b 7 0</b></span>. Une fois les exécutables <span><b class="command">mount</b></span> et
<span><b class="command">umount</b></span> spéciaux installés, créez un fichier
temporaire sur le disque dur suffisamment grand (par exemple,
<tt class="filename">/tmp/fsfile</tt>). Vous pouvez utiliser une commande du
type :
</p><pre class="programlisting">
dd if=/dev/zero of=/tmp/fsfile bs=1k count=nnn
</pre><p>
pour créer un fichier de <span class="emphasis"><em>nnn</em></span> blocs.
</p><p>
Utilisez le nom du fichier à la place de PÉRIPHÉRIQUE ci-dessous. Quand
vous exécutez une commande <span><b class="command">mount</b></span>, vous devez inclure
l'option <tt class="option">-o loop</tt> pour dire au programme d'utiliser un
périphérique de boucle.  <a class="indexterm" name="id2498559"></a> Par exemple :
</p><pre class="programlisting">
mount -o loop -t ext2 /tmp/fsfile /mnt
</pre><p>
va monter <tt class="filename">/tmp/fsfile</tt> (par périphérique de boucle)
sur le point de montage <tt class="filename">/mnt</tt>. Un coup de
<span><b class="command">df</b></span> le confirmera.
</p></li></ul></div><p>
Après avoir choisi une de ces options, préparez le PÉRIPHÉRIQUE avec :
</p><pre class="programlisting">
dd if=/dev/zero of=PÉRIPHÉRIQUE bs=1k count=4096
</pre><p>
Cette commande initialise à zéro le périphérique. Cette étape est
importante pour la compression ultérieure du système de fichiers, afin
que toutes les portions inutilisées soient remplies de zéros pour une
compression maximum.  Gardez cela à l'esprit si vous déplacez ou effacez
des fichiers sur le système de fichiers. Le système de fichiers va
désallouer correctement les blocs, <span class="emphasis"><em>mais ne va pas les
initialiser à zéro à nouveau </em></span>. Si vous effectuez beaucoup
d'effacements et de copies, votre système de fichiers compressé risque
d'être bien plus grand que nécessaire.
</p><a class="indexterm" name="id2498637"></a><p>
Ensuite, créez le système de fichiers. Le noyau Linux sait charger
automatiquement deux types de système de fichiers dans un disque mémoire
: minix et ext2, avec une préférence pour ext2. Si vous le choisissez,
vous voudrez peut-être utiliser l'option <tt class="option">-i</tt> afin de
créer plus d'i-nœuds que par défaut ; <tt class="option">-i 2000</tt> est une
bonne valeur qui vous évitera de tomber à court d'i-nœuds. Vous pouvez
sinon économiser des i-nœuds en supprimant pas mal de fichiers
<tt class="filename">/dev/</tt> inutiles. <span><b class="command">mke2fs</b></span> crée par
défaut 360 i-nœuds sur une disquette de 1,44 Mo. Je trouve 
120 i-nœuds largement suffisants pour ma disquette racine 
de secours, mais si vous conservez tous les périphériques dans le 
répertoire <tt class="filename">/dev</tt> vous dépasserez facilement les 360.
L'utilisation d'un système racine compressé permet de créer un système
de fichiers plus grand, contenant donc plus d'i-nœuds par défaut, mais
vous pourrez quand même vouloir réduire le nombre de fichiers ou
augmenter le nombre d'i-nœuds.
</p><p>
Vous allez donc taper une commande du genre :
</p><pre class="programlisting">
mke2fs -m 0 -i 2000 <i class="replaceable"><tt>PÉRIPHÉRIQUE</tt></i>
</pre><p>
(Si vous utilisez un périphérique de boucle, le fichier que vous
utilisez doit être indiqué à la place de ce 
<i class="replaceable"><tt>PÉRIPHÉRIQUE</tt></i>. <span><b class="command">mke2fs</b></span> vous 
demandera alors si vous voulez vraiment faire cela ; répondez oui.)
</p><a class="indexterm" name="id2498693"></a><p>
La commande <span><b class="command">mke2fs</b></span> détectera automatiquement l'espace
disponible et se configurera selon ce dernier. Le paramètre <tt class="option">-m 0
</tt> permet de ne pas réserver d'espace pour root, et laisse donc plus
d'espace disponible sur le disque.
</p><p>
Ensuite, montez le périphérique :
</p><pre class="programlisting">
mount -t ext2 PÉRIPHÉRIQUE /mnt
</pre><p>
(Vous devez créer un point de montage <tt class="filename">/mnt</tt> s'il
n'existe pas encore.) Dans les sections suivantes, tous les répertoires
destination sont supposés relatifs à <tt class="filename">/mnt</tt>.
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2498789"></a>4.3. Remplissage du système de fichiers</h3></div></div><div></div></div><p>
Voici un minimum raisonnable de répertoires à créer sur votre système
racine 
<sup>[<a name="id2498799" href="#ftn.id2498799">1</a>]</sup> :
</p><div class="itemizedlist"><ul type="disc"><li><p> <tt class="filename">/dev</tt> : Périphériques, nécessaires
aux E/S ;</p></li><li><p> <tt class="filename">/proc</tt> : Répertoire de base
nécessaire au système de fichiers proc ;</p></li><li><p> <tt class="filename">/etc</tt> : Fichiers de configuration
du système ;</p></li><li><p> <tt class="filename">/sbin</tt> : Exécutables systèmes
critiques ;</p></li><li><p> <tt class="filename">/bin</tt> : Exécutables de base
considérés comme partie intégrante du système ;</p></li><li><p> <tt class="filename">/lib</tt> : Bibliothèques partagées
nécessaires à l'exécution des programmes ;</p></li><li><p> <tt class="filename">/mnt</tt> : Un point de montage pour la
maintenance des autres disques ;</p></li><li><p> <tt class="filename">/usr</tt> : Utilitaires et applications
supplémentaires.</p></li></ul></div><a class="indexterm" name="id2498920"></a><a class="indexterm" name="id2498932"></a><a class="indexterm" name="id2498944"></a><p>
Trois de ces répertoires resteront vides sur les systèmes racine, il
suffit donc de les créer avec <span><b class="command">mkdir</b></span>. Le répertoire
<tt class="filename">/proc</tt> n'est qu'une base sous laquelle le système
proc est placé. <tt class="filename">/mnt</tt> et <tt class="filename">/usr</tt>
ne sont que des points de montage utilisés une fois que le système
amorce/racine tourne. Encore une fois, il suffit de créer ces
répertoires.
</p><p>
Les quatre autres répertoires sont décrits dans les sections suivantes.
</p><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2499001"></a>4.3.1. <tt class="filename">/dev</tt></h4></div></div><div></div></div><p>
<a class="indexterm" name="id2499011"></a>
Tous les systèmes Linux ont besoin d'un répertoire
<tt class="filename">/dev</tt> contenant un fichier spécial par périphérique
accessible au système. Le répertoire en lui-même est normal, et peut
être créé avec <span><b class="command">mkdir</b></span> de la manière habituelle. Les
fichiers spéciaux de périphérique doivent par contre être créés
différemment, à l'aide de la commande <span><b class="command">mknod</b></span>.
</p><p>
Il y a un raccourci par contre : copiez le contenu de votre répertoire
<tt class="filename">/dev</tt> existant, puis supprimez ceux dont vous n'avez
pas besoin. Il suffit juste de copier les fichiers spéciaux avec
l'option <tt class="option">-R</tt>. Cela copie le répertoire sans tenter de
copier le contenu des fichiers. <span class="emphasis"><em>Attention à bien utiliser un R
en majuscule !</em></span> Si vous utilisez l'option en minuscule
<tt class="option">-r</tt>, vous allez vous retrouver en train de copier le
contenu complet de votre disque dur — ou au moins tout ce que pourra en
contenir une disquette ! Prenez donc vos précautions, et utilisez par
exemple les commandes :
</p><pre class="programlisting">
cp -dpR /dev/fd[01]* /mnt/dev
cp -dpR /dev/tty[0-6] /mnt/dev
</pre><p>
en supposant que la disquette est montée sur <tt class="filename">/mnt</tt>.
Les options <tt class="option">dp</tt> demandent la copie des liens symboliques
en tant que lien, plutôt que celle du fichier qui se trouve au bout de
celui-ci, et la conservation des attributs originaux des fichiers, pour
garder les bons propriétaires.
</p><p>
Si vous voulez le faire vous-mêmes, utilisez <span><b class="command">ls -l</b></span>
pour afficher les numéros majeurs et mineurs des périphériques qui vous
intéressent, et créez-les sur la disquette en utilisant
<span><b class="command">mknod</b></span>.
</p><p>
Quelle que soit la manière retenue pour copier les périphériques, il
faut vérifier que tous les périphériques dont vous aurez besoin sont
bien présents sur la disquette de secours. Par exemple,
<span><b class="command">ftape</b></span> utilise les périphériques de bande, qu'il vous
faudra donc tous copier si vous comptez utiliser votre lecteur de bande
depuis le disque amorce.
</p><p>
À noter qu'un i-nœud est nécessaire pour chaque fichier de
périphérique, et que les <span class="emphasis"><em>i-nœuds</em></span> sont parfois une
ressource rare, spécialement sur les systèmes de fichiers sur disquette.
Il n'est donc pas idiot d'enlever du répertoire
<tt class="filename">/dev</tt> de la disquette tous les fichiers de
périphérique dont vous n'avez pas besoin. Bien des périphériques ne sont
clairement pas nécessaires sur des systèmes spécifiques. Par exemple, si
vous n'avez pas de disques SCSI vous pouvez tranquillement enlever tous
les fichiers commençant par <tt class="filename">sd</tt>. De même, si vous ne
comptez pas utiliser de port série vous pouvez supprimer tous les
fichiers commençant par <tt class="filename">ttyS</tt>.
</p><p>
Si, en construisant le système de fichiers, vous obtenez l'erreur :
</p><pre class="programlisting">
No space left on device
</pre><p>
et que la commande <span><b class="command">df</b></span> indique qu'il reste de l'espace
disponible, c'est sans doutes qu'il n'y a plus d'i-nœud disponible.
Un <span><b class="command">df -i</b></span> affichera l'utilisation des i-nœuds.
</p><p>
<span class="emphasis"><em>N'oubliez pas d'inclure les fichiers suivants dans le
répertoire :</em></span> <tt class="filename">console</tt>,
<tt class="filename">kmem</tt>, <tt class="filename">mem</tt>,
<tt class="filename">null</tt>, <tt class="filename">ram0</tt>,
<tt class="filename">tty1</tt>.
</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2499270"></a>4.3.2. <tt class="filename">/etc</tt></h4></div></div><div></div></div><a class="indexterm" name="id2499277"></a><p>
Ce répertoire doit contenir un certain nombre de fichiers de
configuration. Ce qu'il devrait contenir dépend des programmes que vous
avez l'intention d'exécuter. Sur la plupart des systèmes, on peut les
répartir en trois groupes :
</p><div class="orderedlist"><ol type="1"><li><p>Nécessaires à tout moment, par exemple
<tt class="filename">rc</tt>, <tt class="filename">fstab</tt>,
<tt class="filename">passwd</tt> ;</p></li><li><p>Peut-être nécessaires, mais on n'en est pas sûr
;</p></li><li><p>Du bazar oublié là.</p></li></ol></div><p>
Les fichiers non essentiels peuvent être identifiés avec la
commande :
</p><pre class="programlisting">
ls -ltru
</pre><p>
Les fichiers sont classés dans l'ordre inverse de dernière date
d'accès, donc tout fichier qui n'est jamais lu peut être exclu d'une
disquette racine.
</p><p>
Sur mes disquettes racine, je n'ai que 15 fichiers de
configuration. Mon travail se réduit alors à gérer trois groupes de
fichiers :
</p><div class="orderedlist"><ol type="1"><li><p>Ceux que je dois configurer pour un système d'amorce et
racine :
  </p><div class="orderedlist"><ol type="a"><li><p><tt class="filename">rc.d/*</tt> : scripts de démarrage du
système et de changement de niveau d'exécution ;</p></li><li><p><tt class="filename">fstab</tt> : liste des systèmes de
fichiers à monter ;</p></li><li><p><tt class="filename">inittab</tt> : paramètres pour le
processus <span><b class="command">init</b></span>, le premier à être lancé au
démarrage.</p></li><li><p><tt class="filename">gettydefs</tt> : paramètres pour le
processus <span><b class="command">init</b></span>, le premier à être lancé au
démarrage.</p></li></ol></div><p>
</p></li><li><p>Ceux que je dois nettoyer pour un système d'amorce et
racine :
</p><div class="orderedlist"><ol type="a"><li><p><tt class="filename">passwd</tt> : liste des utilisateurs,
des répertoires utilisateurs, et cætera ;</p></li><li><p><tt class="filename">group</tt> : groupes d'utilisateurs
;</p></li><li><p><tt class="filename">shadow</tt> : mots de passe cachés des
utilisateurs. Il se peut que vous n'ayez pas ce fichier
;</p></li><li><p><tt class="filename">termcap</tt> : la base de données de
fonctionnalités des terminaux.</p></li></ol></div><p>
Si la sécurité est importante, <tt class="filename">passwd</tt> et
<tt class="filename">shadow</tt> doivent être nettoyés pour ne pas copier de
mots de passe d'utilisateurs hors du système et pour qu'en cas de
démarrage sur disquette, les logins indésirables soient rejetés.
<a class="indexterm" name="id2499515"></a>
</p><p>
Assurez-vous que <tt class="filename">passwd</tt> contienne au moins
<span class="emphasis"><em>root</em></span>. Si vous comptez donner accès à d'autres
utilisateurs, vérifiez l'existence de leurs répertoires utilisateurs et
de leurs shells.
</p><p>
<tt class="filename">termcap</tt>, la base de données de terminaux, fait en
général plusieurs centaines de kilo-octets. Vous devrez faire du ménage
dans la version de votre disquette d'amorce/racine pour ne conserver que
le ou les terminaux que vous utilisez, ce qui se réduit en général à
l'entrée <span class="emphasis"><em>linux</em></span> ou
<span class="emphasis"><em>linux-console</em></span>.
</p></li><li><p>Le reste. Ils fonctionnent très bien tels quel, je ne
les modifie donc pas.
</p></li></ol></div><p>
Parmi tout cela, je n'ai en réalité que deux fichiers à configurer, et
ils ne doivent contenir qu'étonnamment peu de choses.
</p><div class="itemizedlist"><ul type="disc"><li><p><tt class="filename">rc</tt> doit contenir :
</p><pre class="programlisting">
#!/bin/sh
/bin/mount -av
/bin/hostname Kangaroo
</pre><p>
Vérifiez qu'il est exécutable, qu'il contient bien une ligne
<span><b class="command">#!/bin/sh</b></span> au début et que ce sont les bons
répertoires. Il n'est pas réellement nécessaire de lancer
<span><b class="command">hostname</b></span>, mais cela donne juste une meilleure allure.
</p></li><li><p><tt class="filename">fstab</tt> doit au moins contenir :
</p><pre class="programlisting">
/dev/ram0       /       ext2    defaults
/dev/fd0        /       ext2    defaults
/proc           /proc   proc    defaults
</pre><p>
Vous pouvez copier des lignes de votre vrai <tt class="filename">fstab</tt>, 
mais vous ne devriez pas monter automatiquement de partitions de
votre disque dur ; utilisez le mot clé <span class="emphasis"><em>noauto</em></span> pour
celles-là. Votre disque peut être endommagé ou mort quand vous utilisez
le disque d'amorce.
</p></li></ul></div><p>
Votre <tt class="filename">inittab</tt> doit être modifié pour que la ligne
<span><b class="command">sysinit</b></span> lance <span><b class="command">rc</b></span> ou quelque autre
script basique d'amorce. De plus, si vous ne souhaitez pas que les
utilisateurs se loguent sur les ports série, commentez toutes les
entrées <span><b class="command">getty</b></span> qui font référence à des périphériques
<tt class="filename">ttys</tt> ou <tt class="filename">ttyS</tt> à la fin de la
ligne. Laissez les ports <tt class="filename">tty</tt> pour pouvoir vous
connecter sur la console.
</p><p>
Un fichier <tt class="filename">inittab</tt> minimal contient ce qui suit :
</p><pre class="programlisting">
id:2:initdefault
si::sysinit:/etc/rc
1:2345:respawn:/sbin/getty 9600 tty1
2:23:respawn:/sbin/getty 9600 tty2
</pre><p>
Le fichier <tt class="filename">inittab</tt> décrit ce que va lancer le
système dans divers états, dont le démarrage, le passage en mode multi
utilisateurs, et cætera. Attention aux noms de fichiers référencés dans
<tt class="filename">inittab</tt> ; si <span><b class="command">init</b></span> ne peut
trouver le programme, le disque d'amorce s'arrêtera, et vous n'aurez
peut-être même pas de message d'erreur.
</p><a class="indexterm" name="id2499765"></a><p>
Notez que certains programmes ne peuvent être déplacés en raison
d'autres programmes qui référencent en dur leur position. Par exemple
sur mon système, <tt class="filename">/etc/shutdown</tt> référence en dur
<tt class="filename">/etc/reboot</tt>. Si je déplace
<span><b class="command">reboot</b></span> vers <span><b class="command">/bin/reboot</b></span>, et que je
lance une commande <span><b class="command">shutdown</b></span>, elle va échouer en ne
trouvant pas le fichier <span><b class="command">reboot</b></span>.
</p><a class="indexterm" name="id2499820"></a><p>
Pour le reste, copiez juste tous les fichiers texte de votre répertoire
<tt class="filename">/etc</tt>, ainsi que tous les exécutables présents dans
<tt class="filename">/etc</tt> dont vous n'êtes pas sûr de pouvoir vous
passer. Basez-vous sur l'exemple de l'<a href="#listings" title="C. Exemple de contenu de répertoires sur un disque racine">Annexe C, <i>Exemple de contenu de répertoires sur un disque racine</i></a>.  Il
vous suffira probablement de copier ces fichiers, mais les systèmes
pouvant être très différents, il n'est pas certain que le même ensemble
de fichiers sur votre système soit équivalent aux fichiers listés. La
seule méthode sûre est de partir d'<tt class="filename">inittab</tt> et d'en
déduire ce qui est nécessaire.
</p><p>
La plupart des systèmes utilisent maintenant un répertoire
<tt class="filename">/etc/rc.d/</tt> contenant des scripts shell pour les
différents niveaux d'exécution. Il faut au minimum avoir un script
<span><b class="command">rc</b></span> unique, mais il peut être plus simple de carrément
copier <tt class="filename">inittab</tt> et le répertoire
<tt class="filename">/etc/rc.d</tt> depuis votre système puis de nettoyer les
scripts shell dans le répertoire <tt class="filename">rc.d</tt> pour enlever
tous les traitements inutiles pour un système sur disquette.
</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2499919"></a>4.3.3. <tt class="filename">/bin</tt> et <tt class="filename">/sbin</tt></h4></div></div><div></div></div><p>
<a class="indexterm" name="id2499936"></a>
<a class="indexterm" name="id2499943"></a>
Le répertoire <tt class="filename">/bin</tt> est un endroit pratique pour
tous les utilitaires nécessaires aux opérations de base, tels que
<span><b class="command">ls</b></span>, <span><b class="command">mv</b></span>, <span><b class="command">cat</b></span> et
<span><b class="command">dd</b></span>. Voir l'<a href="#listings" title="C. Exemple de contenu de répertoires sur un disque racine">Annexe C, <i>Exemple de contenu de répertoires sur un disque racine</i></a> pour un
exemple d'ensemble de fichiers pouvant aller dans les répertoires
<tt class="filename">/bin</tt> et <tt class="filename">/sbin</tt>. Il ne contient
aucun des utilitaires nécessaires à la récupération d'une sauvegarde,
tels que <span><b class="command">cpio</b></span>, <span><b class="command">tar</b></span> et
<span><b class="command">gzip</b></span>. C'est parce que je place ceux-ci sur une
disquette utilitaire séparée, pour conserver de la place sur la
disquette d'amorce et racine. Une fois la disquette d'amorce/racine
démarrée, elle est copiée sur le disque mémoire, laissant ainsi le
lecteur de disquette libre pour en monter une autre, la disquette
utilitaire. En général je la monte sur <tt class="filename">/usr</tt>.
</p><p>
La création d'une <span class="emphasis"><em>disquette utilitaire</em></span> est décrite
ci-dessous dans la <a href="#utilitydisk" title="9.2. Construire un disque utilitaire">Section 9.2, « Construire un disque utilitaire »</a> . Il est probablement
souhaitable d'y maintenir une copie des mêmes versions d'utilitaires de
sauvegarde que ceux utilisés pour écrire les sauvegardes, histoire de ne
pas perdre de temps en essayant d'installer des versions qui ne peuvent
pas lire vos bandes de sauvegarde.
</p><p>
<span class="emphasis"><em>Vérifiez que vous y mettez les programmes suivants :</em></span>
<span><b class="command">init</b></span>, <span><b class="command">getty</b></span> ou un équivalent,
<span><b class="command">login</b></span>, <span><b class="command">mount</b></span>, un shell capable de
faire tourner votre script <span><b class="command">rc</b></span>, un lien de
<span><b class="command">sh</b></span> vers le shell en question.
</p><a class="indexterm" name="id2500104"></a><a class="indexterm" name="id2500117"></a><a class="indexterm" name="id2500129"></a><a class="indexterm" name="id2500141"></a></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2500149"></a>4.3.4. <tt class="filename">/lib</tt></h4></div></div><div></div></div><p>
<a class="indexterm" name="id2500159"></a>
<a class="indexterm" name="id2500167"></a>
Vous mettez dans <tt class="filename">/lib</tt> les bibliothèques partagées
et les chargeurs nécessaires. Si les bibliothèques nécessaires ne sont pas
trouvées dans <tt class="filename">/lib</tt>, le système ne pourra pas
démarrer. Avec de la chance, un message vous expliquera pourquoi.
</p><p>
Pratiquement tous les programmes ont au moins besoin de la bibliothèque
<tt class="filename">libc</tt>,
<tt class="filename">libc.so.</tt><span class="emphasis"><em>N</em></span>,
<span class="emphasis"><em>N</em></span> étant le numéro de version courant. Vérifiez
votre répertoire <tt class="filename">/lib</tt>,
<tt class="filename">libc.so.N</tt> est en général un lien symbolique vers un
fichier avec un numéro de version complet :
</p><pre class="programlisting">
% ls -l /lib/libc.so*
-rwxr-xr-x   1 root     root      4016683 Apr 16 18:48 libc-2.1.1.so*
lrwxrwxrwx   1 root     root           13 Apr 10 12:25 libc.so.6 -&gt; libc-2.1.1.so*
</pre><p>
Dans le cas présent, il vous faut <tt class="filename">libc-2.1.1.so</tt>.
Pour trouver les autres bibliothèques nécessaires, il faut lancer la
commande <span><b class="command">ldd</b></span> sur tous les exécutables que vous
prévoyez de mettre sur la disquette. Par exemple :
</p><pre class="programlisting">
% ldd /sbin/mke2fs
libext2fs.so.2 =&gt; /lib/libext2fs.so.2 (0x40014000)
libcom_err.so.2 =&gt; /lib/libcom_err.so.2 (0x40026000)
libuuid.so.1 =&gt; /lib/libuuid.so.1 (0x40028000)
libc.so.6 =&gt; /lib/libc.so.6 (0x4002c000)
/lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x40000000)
</pre><p>
Tous les fichiers à droite sont nécessaires. Le fichier peut en
réalité être un lien symbolique.
</p><p>
Notez que certaines bibliothèques sont <span class="emphasis"><em>assez
grosses</em></span> et ne tiendront pas facilement sur votre système
racine. Par exemple, la <tt class="filename">libc.so</tt> citée précédemment
fait environ 4 méga-octets. Vous devrez probablement nettoyer les
bibliothèques avant de les copier sur votre système racine.
Reportez-vous à la <a href="#slimfast" title="8. Réduire la taille du système racine">Section 8, « Réduire la taille du système racine »</a> pour plus d'informations.
</p><a class="indexterm" name="id2500308"></a><a class="indexterm" name="id2500315"></a><a class="indexterm" name="id2500321"></a><a class="indexterm" name="id2500328"></a><p>
Il faut également inclure dans <tt class="filename">/lib</tt> un chargeur
pour les bibliothèques. Il s'agira soit de <tt class="filename">ld.so</tt>
(pour les bibliothèques a.out), soit de <tt class="filename">ld-linux.so</tt>
(pour les bibliothèques ELF). Les versions  récentes de
<span><b class="command">ldd</b></span> vous indiquent de quel chargeur vous avez besoin,
comme dans l'exemple ci-dessus, mais de plus anciennes versions ne le
font pas forcément. Si vous ne savez pas duquel vous avez besoin,
utilisez la commande <span><b class="command">file</b></span> sur la bibliothèque. Par
exemple :
</p><pre class="programlisting">
% file/lib/libc.so.4.7.2 /lib/libc.so.5.4.33 /lib/libc-2.1.1.so
/lib/libc.so.4.7.2: Linux/i386 demand-paged executable (QMAGIC), stripped
/lib/libc.so.5.4.33: ELF 32-bit LSB shared object, Intel 80386, version 1, stripped
/lib/libc-2.1.1.so: ELF 32-bit LSB shared object, Intel 80386, version 1, not stripped
</pre><p>
Le mot <span class="emphasis"><em>QMAGIC</em></span> indique que
<span class="emphasis"><em>4.7.2</em></span> est pour les bibliothèques a.out, et
<span class="emphasis"><em>ELF</em></span> que <span class="emphasis"><em>5.4.33</em></span> et
<span class="emphasis"><em>2.1.1</em></span> sont pour les ELF.
</p><a class="indexterm" name="id2500417"></a><a class="indexterm" name="id2500423"></a><p>
Copiez le ou les chargeurs dont vous avez besoin sur le système racine
que vous êtes en train de construire. Les bibliothèques et chargeurs
doivent être testés <span class="emphasis"><em>attentivement</em></span> avec les
exécutables inclus. Si le noyau ne peut charger une bibliothèque
nécessaire, il s'arrêtera en général brutalement, sans message d'erreur.
</p></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="PAMNSS"></a>4.4. Utilisation de PAM et NSS</h3></div></div><div></div></div><p>
Votre système peut utiliser des bibliothèques chargées dynamiquement
mais invisibles pour <tt class="filename">ldd</tt>. Si vous ne les incluez pas,
vous risquez de ne pas pouvoir vous connecter ou utiliser votre
disquette d'amorce.
</p><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2500473"></a>4.4.1. PAM (Pluggable Authentication Modules)</h4></div></div><div></div></div><p>
Si votre système utilise PAM (Pluggable Authentication Modules, soit
Modules Externes d'authentification), tenez-en compte dans la
construction de votre disque d'amorce, sans quoi vous ne pourrez pas
vous connecter. En quelques mots, PAM est une méthode modulaire
sophistiquée pour authentifier les utilisateurs et contrôler leur accès
aux services. Pour déterminer simplement si votre système utilise PAM,
cherchez dans le répertoire <tt class="filename">/etc</tt> de votre disque
dur un fichier <tt class="filename">pam.conf</tt> ou un répertoire
<tt class="filename">pam.d</tt> ; si l'un des deux existe, vous devez prévoir
un minimum de support pour PAM. (Vous pouvez aussi lancer
<tt class="filename">ldd</tt> sur votre exécutable <tt class="filename">login</tt>
; si la sortie contient <tt class="filename">libpam.so</tt>, vous avez besoin
de PAM.)
</p><p>
Heureusement, la sécurité est rarement un problème avec les disques
d'amorce étant donné que quiconque avec un accès physique à la
machine peut en général faire tout ce qu'il veut dessus. Vous pouvez
donc complètement désactiver PAM en créant un fichier
<tt class="filename">/etc/pam.conf</tt> simple sur votre système racine
contenant :
</p><pre class="programlisting">
OTHER   auth       optional     /lib/security/pam_permit.so
OTHER   account    optional     /lib/security/pam_permit.so
OTHER   password   optional     /lib/security/pam_permit.so
OTHER   session    optional     /lib/security/pam_permit.so
</pre><p>
Copiez également le fichier
<tt class="filename">/lib/security/pam_permit.so</tt> sur votre système
racine. Cette bibliothèque ne fait qu'environ 8 ko et ne coûte donc
pas grand chose.
</p><p>
Notez bien que cette configuration donne à tous un accès complet aux
fichiers et services de votre machine. Si vous avez des impératifs de
sécurité sur votre disque d'amorce pour une raison ou une autre, vous
devrez copier une partie, voire l'ensemble de la configuration PAM de
votre disque dur vers le système racine. Lisez bien attentivement la
documentation de PAM, et copiez toutes les bibliothèques nécessaires
depuis <tt class="filename">/lib/security</tt> vers votre système racine.
</p><p>
Vous devez aussi inclure <tt class="filename">/lib/libpam.so</tt> sur le
disque racine. Mais vous le saviez déjà puisque vous avez lancé
<span><b class="command">ldd</b></span> sur <tt class="filename">/bin/login</tt> qui vous a
montré cette dépendance.
</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2500624"></a>4.4.2. NSS (Name Service Switch)</h4></div></div><div></div></div><p>
Si vous utilisez <span class="emphasis"><em>glibc</em></span> (appelée aussi
<span class="emphasis"><em>libc6</em></span>), vous devez tenir compte des services de
noms sans quoi vous ne pourrez pas vous connecter. Le fichier
<tt class="filename">/etc/nsswitch.conf</tt> contrôle les recherches dans les
bases de données pour divers services. Si vous ne comptez pas accéder à
des services du réseau (tels que des recherches DNS ou NIS), un simple
fichier <tt class="filename">nsswitch.conf</tt> comme suit suffit :
</p><pre class="programlisting">
passwd:     files
shadow:     files
group:      files
hosts:      files
services:   files
networks:   files
protocols:  files
rpc:        files
ethers:     files
netmasks:   files
bootparams: files
automount:  files
aliases:    files
netgroup:   files
publickey:  files
</pre><p>
Ce fichier spécifie que tous les services ne sont fournis que par des
fichiers locaux de la machine. Vous devez aussi inclure le fichier
<tt class="filename">/lib/libnss_files.so.X</tt>, où X vaut 1 pour une glibc
2.0 et 2 pour une glibc 2.1. Cette bibliothèque est chargée
dynamiquement pour gérer les recherches dans les fichiers.
</p><p>
Si vous comptez accéder au réseau depuis votre disque d'amorce, vous
pouvez créer un fichier <tt class="filename">nsswitch.conf</tt> plus complet.
Voir la page de manuel de <tt class="filename">nsswitch</tt> pour plus de
détails. N'oubliez pas d'inclure un fichier
<tt class="filename">/lib/libnss_</tt><span class="emphasis"><em>service</em></span><tt class="filename">.so.1
</tt>
pour chaque <span class="emphasis"><em>service</em></span> que vous ajoutez.
</p></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2500731"></a>4.5. Modules</h3></div></div><div></div></div><p>
<a class="indexterm" name="id2500738"></a>
Si votre noyau est modulaire, vous devez savoir quels modules vous
voudrez charger depuis votre disque d'amorce une fois le système
démarré. Il vous faudra inclure les modules <span><b class="command">ftape</b></span> et
<span><b class="command">zftape</b></span> si vos sauvegardes sont sur bandes, les
modules pour périphériques SCSI si vous en avez, et éventuellement ceux
pour le support PPP ou SLIP si vous souhaitez accéder au réseau en cas
d'urgence.
</p><a class="indexterm" name="id2500770"></a><p>
Ces modules doivent être placés dans <tt class="filename">/lib/modules</tt>.
Vous devez aussi inclure <span><b class="command">insmod</b></span>,
<span><b class="command">rmmod</b></span> et <span><b class="command">lsmod</b></span>. Si vous souhaitez
charger les modules automatiquement, prenez <span><b class="command">modprobe</b></span>,
<span><b class="command">depmod</b></span> et <span><b class="command">swapout</b></span>. Et si vous
utilisez <span><b class="command">kerneld</b></span>, prenez le avec son fichier de
configuration <tt class="filename">/etc/conf.modules</tt>.
</p><p>
Néanmoins, le principal avantage d'utiliser les modules est que vous
pouvez déplacer les modules non essentiels sur un disque utilitaire et
ne les charger que lorsque c'est nécessaire, ce qui prend alors moins de
place sur le disque racine. Si vous devez gérer beaucoup de
périphériques, il vaut mieux procéder de cette manière plutôt que de
construire un seul gros noyau contenant tous les gestionnaires.
</p><a class="indexterm" name="id2500856"></a><p>
<span class="emphasis"><em>Attention, pour démarrer avec un système de fichiers ext2
compressé, vous devez avoir inclus le support pour disque mémoire et
ext2.</em></span> Ils ne peuvent être installés par des modules.
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2500877"></a>4.6. Quelques ultimes détails</h3></div></div><div></div></div><p>
Certains programmes, tels que <span><b class="command">login</b></span>, se plaignent si
le fichier <tt class="filename">/var/run/utmp</tt> et le répertoire
<tt class="filename">/var/log</tt> n'existent pas.
</p><a class="indexterm" name="id2500905"></a><p>
Donc :
</p><pre class="programlisting">
mkdir -p /mnt/var/{log,run}
touch /mnt/var/run/utmp
</pre><p>
Enfin, après avoir installé toutes les bibliothèques dont vous avez
besoin, lancez <span><b class="command">ldconfig</b></span> pour refabriquer
<tt class="filename">/etc/ld.so.cache</tt> sur le système racine. Le cache
indique au loader où trouver les bibliothèques. Pour refabriquer
<tt class="filename">ld.so.cache</tt>, lancez la commande suivante :
</p><a class="indexterm" name="id2500956"></a><a class="indexterm" name="id2500969"></a><pre class="programlisting">
ldconfig -r /mnt
</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="wrappingitup"></a>4.7. C'est dans la poche</h3></div></div><div></div></div><p>
Une fois le système racine construit, démontez-le, copiez-le dans un
fichier et compressez-le :
</p><pre class="programlisting">
umount /mnt
dd if=PÉRIPHÉRIQUE bs=1k | gzip -v9 &gt; rootfs.gz
</pre><p>
Une fois cette étape effectuée, vous obtenez un fichier
<tt class="filename">rootfs.gz</tt> contenant votre système racine compressé.
Vérifiez sa taille pour être sûr qu'il tient sur une disquette. Si ça
n'est pas le cas vous devrez y retourner pour supprimer certains
fichiers. La <a href="#slimfast" title="8. Réduire la taille du système racine">Section 8, « Réduire la taille du système racine »</a> vous donnera des astuces pour y
arriver.
</p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2501037"></a>5. Choisir un noyau</h2></div></div><div></div></div><p>
<a class="indexterm" name="id2501044"></a>
Vous avez maintenant un système de fichiers racine complet et
compressé. La prochaine étape consiste à construire ou choisir un
noyau. Dans la plupart des cas, vous pouvez copier votre noyau courant
et démarrer la disquette avec. Cependant dans certains cas, vous
voudrez peut-être construire un noyau différent.
</p><p>
La taille peut jouer. Si vous faites une disquette d'amorce/racine
unique, le noyau va être un des plus gros fichiers de la disquette et
il vaut donc mieux essayer d'en réduire la taille au maximum. Pour ce
faire, construisez-le avec le minimum de fonctionnalités nécessaires
au bon fonctionnement du système cible. Cela implique de retirer tout
ce dont vous n'avez pas besoin. Le support réseau est un bon candidat,
tout comme le support pour tout type de disque et de périphérique dont
vous n'avez pas l'usage sur un système lancé par disquette. Comme
indiqué précédemment, votre noyau doit contenir le support pour disque
mémoire et ext2.
</p><p>
Une fois les fonctionnalités nécessaires déterminées, vous devez trouver
ce qu'il faut rajouter. L'utilisation la plus courante d'une disquette
d'amorce/racine est l'examen et la récupération d'un système racine
endommagé, ce qui peut nécessiter le support de certaines
fonctionnalités supplémentaires dans le noyau. Par exemple, si vos
sauvegardes sont stockées sur bande avec <span><b class="command">ftape</b></span> pour
gérer l'accès au lecteur de bande et que vous perdez votre disque racine
ainsi que ceux contenant <span><b class="command">ftape</b></span>, vous ne pourrez plus
récupérer vos sauvegardes depuis les bandes. Vous devrez réinstaller
Linux, rapatrier et réinstaller <span><b class="command">ftape</b></span>, puis essayer
de lire vos sauvegardes.
</p><p>
Ce que je veux dire, c'est que quelle que soit la méthode d'E/S que
vous utilisez au niveau du noyau pour les sauvegardes, elle doit se
trouver aussi sur votre noyau d'amorce.
</p><a class="indexterm" name="id2501128"></a><p>
La procédure de construction d'un noyau est décrite dans la
documentation fournie avec celui-ci. C'est assez simple à suivre, vous
pouvez donc commencer par faire un tour dans
<tt class="filename">/usr/src/linux</tt>. Si vous avez des problèmes pour
construire un noyau, vous ne devriez probablement pas essayer de faire
de disquette d'amorce/racine de toute manière. Pensez à compresser le
noyau avec <span><b class="command">make zImage</b></span>.
</p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2501166"></a>6. Assemblage et fabrication de la ou des disquettes</h2></div></div><div></div></div><p>
Vous avez maintenant un noyau et un système de fichiers compressé. Si
vous construisez un disque d'amorce/racine unique, vérifiez que leur
taille ne dépasse pas celle du disque. Si vous avez un découpage sur
deux disquettes, vérifiez que la taille du système racine ne dépasse
pas celle de la disquette.
</p><p>
Il vous faut choisir entre l'utilisation de <span><b class="command">LILO</b></span> pour
démarrer le noyau du disque d'amorce et la copie du noyau directement
sur la disquette d'amorce, sans <span><b class="command">LILO</b></span>. L'avantage de
<span><b class="command">LILO</b></span> est la possibilité de passer des paramètres au
noyau, ce qui peut être nécessaire pour initialiser votre matériel
(Regardez le fichier <tt class="filename">/etc/lilo.conf</tt> sur votre
machine. S'il existe et contient une ligne du type
<span class="emphasis"><em>append=…</em></span>, vous avez besoin de passer des
paramètres). Son inconvénient est une complexité accrue dans la
construction du disque d'amorce, ainsi qu'une place occupée sur la
disquette légèrement plus importante. Vous devrez configurer un petit
système de fichier séparé que nous appellerons le <span class="emphasis"><em>système
noyau</em></span>, où vous transférerez le noyau ainsi que quelques
autres fichiers nécessaires à <span><b class="command">LILO</b></span>.
</p><a class="indexterm" name="id2501248"></a><a class="indexterm" name="id2501262"></a><a class="indexterm" name="id2501270"></a><p>
Si vous décidez d'utiliser <span><b class="command">LILO</b></span>, continuez la lecture
; si par contre vous voulez copier le noyau directement sur la
disquette, passez directement à la <a href="#withoutlilo" title="6.2. Transfert du noyau sans LILO">Section 6.2, « Transfert du noyau sans LILO »</a>.
</p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="usinglilo"></a>6.1. Transfert du noyau avec LILO</h3></div></div><div></div></div><a class="indexterm" name="id2501306"></a><p>
La première chose à faire est de vérifier que vous avez une version
récente de <span><b class="command">LILO</b></span>. Ensuite, il faut créer un petit
fichier de configuration pour <span><b class="command">LILO</b></span>. Il doit
ressembler à :
</p><pre class="programlisting">
boot      =/dev/fd0
install   =/boot/boot.b
map       =/boot/map
read-write
backup    =/dev/null
compact
image     = NOYAU
label     = Bootdisk
root      =/dev/fd0
</pre><p>
Pour la signification de ces paramètres, voir la documentation
utilisateur de <span><b class="command">LILO</b></span>. Il vous faudra probablement
aussi rajouter une ligne <span class="emphasis"><em>append=…</em></span> à ce fichier,
comme dans le fichier <tt class="filename">/etc/lilo.conf</tt> de votre
disque dur.
</p><a class="indexterm" name="id2501371"></a><p>
Sauvez-le en tant que <tt class="filename">bdlilo.conf</tt>.
</p><p>
Vous devez maintenant créer un petit système de fichier, que nous
appellerons <span class="emphasis"><em>système noyau</em></span>, pour le différencier du
système racine.
</p><p>
Tout d'abord, calculez la taille que celui-ci doit faire. Prenez la
taille de votre noyau en blocs (la taille donnée par <span><b class="command">ls -s
NOYAU</b></span> et
ajoutez 50. Cinquante blocs sont en gros la taille nécessaire aux
i-nœuds ainsi qu'aux autres fichiers. Vous pouvez calculer le nombre
exact si vous voulez, ou simplement utiliser 50. Si vous créez un
ensemble avec deux disques, vous pouvez carrément surestimer l'espace
nécessaire puisque le disque n'est utilisé que par le noyau de toute
manière. Appelez ce nombre <span class="emphasis"><em>BLOCS_NOYAU</em></span>.
</p><a class="indexterm" name="id2501438"></a><p>
Mettez une disquette dans le lecteur (pour simplifier, supposons qu'il
s'agit de <tt class="filename">/dev/fd0</tt>) et créez le système noyau ext2
dessus :
</p><pre class="programlisting">
mke2fs -N 24 -m 0 /dev/fd0 BLOCS_NOYAU
</pre><a class="indexterm" name="id2501470"></a><p>
L'option <tt class="option">-N 24</tt> indique que l'on souhaite 24 i-nœuds,
ce qui est largement suffisant pour ce système de fichiers.  Ensuite,
montez le système, supprimez le répertoire
<tt class="filename">lost+found</tt> et créez des répertoire
<tt class="filename">dev</tt> et <tt class="filename">boot</tt> pour
<span><b class="command">LILO</b></span> :
</p><pre class="programlisting">
mount /dev/fd0 /mnt
rm -rf /mnt/lost+found
mkdir /mnt/{boot,dev}
</pre><p>
Ensuite, créez les périphériques <tt class="filename">/dev/null</tt> et
<tt class="filename">/dev/fd0</tt>. Au lieu de chercher leurs numéros de
périphériques, vous pouvez simplement les copier depuis votre disque
dur avec l'option <tt class="option">-R</tt> :
</p><pre class="programlisting">
cp -R /dev/{null,fd0} /mnt/dev
</pre><p>
<span><b class="command">LILO</b></span> a besoin d'une copie de son chargeur d'amorce,
<tt class="filename">boot.b</tt>, que vous pouvez trouver sur votre disque
dur. Il est d'habitude dans le répertoire <tt class="filename">/boot</tt>.
</p><pre class="programlisting">
cp /boot/boot.b /mnt/boot
</pre><p>
Enfin, copiez le fichier de configuration de <span><b class="command">LILO</b></span> que
vous avez créé précédemment avec votre noyau. Les deux peuvent être
placés dans le répertoire racine :
</p><pre class="programlisting">
cp bdlilo.conf NOYAU /mnt
</pre><p>
Tout ce dont <span><b class="command">LILO</b></span> a besoin est maintenant sur le
système noyau, vous pouvez donc le lancer. Le paramètre
<tt class="option">-r</tt> de <span><b class="command">LILO</b></span> est utilisé pour
installer le chargeur sur une autre racine que la courante :
</p><a class="indexterm" name="id2501622"></a><pre class="programlisting">
lilo -v -C bdlilo.conf -r /mnt
</pre><p>
<span><b class="command">LILO</b></span> doit s'exécuter sans erreur, après quoi le
système noyau devrait ressembler à :
</p><pre class="programlisting">
total 361
  1 -rw-r--r--   1 root     root          176 Jan 10 07:22 bdlilo.conf
  1 drwxr-xr-x   2 root     root         1024 Jan 10 07:23 boot/
  1 drwxr-xr-x   2 root     root         1024 Jan 10 07:22 dev/
358 -rw-r--r--   1 root     root       362707 Jan 10 07:23 vmlinuz
boot:
total 8
  4 -rw-r--r--   1 root     root         3708 Jan 10 07:22 boot.b
  4 -rw-------   1 root     root         3584 Jan 10 07:23 map
dev:
total 0
  0 brw-r-----   1 root     root       2,   0 Jan 10 07:22 fd0
  0 crw-r--r--   1 root     root       1,   3 Jan 10 07:22 null
</pre><a class="indexterm" name="id2501665"></a><p>
Ne vous inquiétez pas si la taille des fichiers n'est pas exactement
la même que la votre.
</p><p>
Laissez maintenant le disque dans le lecteur et allez à la
<a href="#ramdiskword" title="6.3. Mise en place du mot disque mémoire">Section 6.3, « Mise en place du mot disque mémoire »</a>.
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="withoutlilo"></a>6.2. Transfert du noyau sans LILO</h3></div></div><div></div></div><p>
Si vous n'utilisez <span class="emphasis"><em>pas</em></span> <span><b class="command">LILO</b></span>,
transférez le noyau sur le disque d'amorce avec la commande
<span><b class="command">dd</b></span> :
</p><pre class="programlisting">
% dd if=NOYAU of=/dev/fd0 bs=1k
353+1 records in
353+1 records out
</pre><p>
Dans ce exemple, <span><b class="command">dd</b></span> a écrit 353 enregistrements
complets, plus 1 partiel, ce qui signifie que le noyau occupe les 354
premiers blocs de la disquette. Appelez ce nombre
<span class="emphasis"><em>BLOCS_NOYAU</em></span> et pensez à l'utiliser dans la section
suivante.
</p><a class="indexterm" name="id2501746"></a><p>
Enfin, indiquez que le périphérique racine doit être la disquette
elle-même, et que le noyau doit être chargé en lecture/écriture.
</p><pre class="programlisting">
        rdev /dev/fd0 /dev/fd0
        rdev -R /dev/fd0 0
</pre><a class="indexterm" name="id2501774"></a><p>
Attention à bien utiliser un <tt class="option">-R</tt> majuscule dans la
seconde commande <span><b class="command">rdev</b></span>.
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="ramdiskword"></a>6.3. Mise en place du mot disque mémoire</h3></div></div><div></div></div><p>
Le <span class="emphasis"><em>mot disque mémoire</em></span> situé dans l'image du noyau
permet de spécifier où se trouve le système racine, ainsi que d'autres
options. Le mot peut être lu et modifié avec la commande
<span><b class="command">rdev</b></span>, et sa valeur s'interprète de la manière
suivante :
</p><pre class="programlisting">
bits  0-10 :    Décalage jusqu'au début du disque mémoire, en blocs
                de 1024 octets
bits 11-13 :    Inutilisé
bit     14 :    Drapeau indiquant s'il faut charger un disque mémoire
bit     15 :    Drapeau pour faire une pause avant de charger le
                système racine
</pre><p>
Si le bit 15 est mis à 1, le noyau vous demandera au moment du démarrage
de changer la disquette dans le lecteur. C'est nécessaire si vous
utilisez un ensemble de deux disques.  Il y a deux cas, suivant que vous
créez une disquette d'amorce/racine unique ou un ensemble
« amorce+racine » séparé.
</p><div class="orderedlist"><ol type="1"><li><p>
Si vous créez un disque unique, le système racine compressé sera placé
juste après le noyau, et donc le décalage sera le premier bloc libre
(qui doit être au même endroit que <span class="emphasis"><em>BLOCS_NOYAU</em></span>). Le
bit 14 sera mis à 1, et le bit 15 à 0.
</p><a class="indexterm" name="id2501883"></a><p>
Supposons par exemple que vous construisiez un disque unique dont le
système racine doit commencer au bloc 253 (valeur décimale). Le mot
disque mémoire devrait valoir 253 (toujours en décimal) avec le bit 14 à
1 et le bit 15 à 0. Pour calculer sa valeur vous pouvez simplement
additionner les valeurs décimales. 253 + (2^14) = 253 + 16384 = 16637.
Si vous ne comprenez pas d'où sort ce nombre, entrez-le dans une
calculatrice scientifique et convertissez-le en binaire.
</p></li><li><p>
Si vous créez par contre un ensemble de deux disques, le système racine
sera au bloc zéro du second disque, et le décalage sera donc zéro. Le
bit 14 sera mis à 1 tout comme le bit 15. La valeur décimale sera donc
de 2^14 + 2^15 = 49152 dans ce cas.
</p></li></ol></div><a class="indexterm" name="id2501926"></a><a class="indexterm" name="id2501939"></a><a class="indexterm" name="id2501946"></a><p>
Après avoir bien calculé la valeur du mot disque mémoire, écrivez-le
avec <span><b class="command">rdev -r</b></span>. Attention à utiliser la valeur
<span class="emphasis"><em>décimale</em></span>. Si vous utilisez <span><b class="command">LILO</b></span>,
l'argument de <span><b class="command">rdev</b></span> doit être le <span class="emphasis"><em>chemin
d'accès au noyau monté</em></span>, c'est à dire
<tt class="filename">/mnt/vmlinuz</tt> ; si vous avez copié le noyau avec
<span><b class="command">dd</b></span>, utilisez à la place le nom du périphérique du
lecteur de disquette (c'est à dire <tt class="filename">/dev/fd0</tt>).
</p><pre class="programlisting">
rdev -r NOYAU_OU_LECTEUR_DE_DISQUETTE VALEUR
</pre><p>
Si vous avez utilisé <span><b class="command">LILO</b></span>, démontez maintenant la
disquette.
</p><p>
Ne croyez pas ce que dit la page de manuel de
<span><b class="command">rdev</b></span>/<span><b class="command">ramsize</b></span> à propos de la taille
du disque mémoire. Cette page est obsolète. À partir du noyau 2.0, le
mot disque mémoire ne détermine plus la taille du disque mémoire ; au
lieu de cela, ce mot est déterminé à partir du tableau donné au début de
cette section. Pour une explication détaillée, voir le fichier de
documentation <tt class="filename">ramdisk.txt</tt> ou

<a href="http://www.tamacom.com/tour/linux/S/9075.html" target="_top">
http://www.tamacom.com/tour/linux/S/9075.html</a>.
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2502074"></a>6.4. Transfert du système racine</h3></div></div><div></div></div><p>
La dernière étape concerne le transfert du système racine.
</p><div class="itemizedlist"><ul type="disc"><li><p>Si le système racine doit être placé sur le même disque
que le noyau, transférez-le avec <span><b class="command">dd</b></span> et son option
<tt class="option">seek</tt>, qui indique combien de blocs il faut sauter :
</p><pre class="programlisting">
dd if=rootfs.gz of=/dev/fd0 bs=1k seek=BLOCS_NOYAU
</pre></li><li><p>
Si le système racine doit être placé sur un second disque, sortez la
première disquette, mettez la seconde dans le disque, puis transférez-y
le système racine :
</p><pre class="programlisting">
dd if=rootfs.gz of=/dev/fd0 bs=1k
</pre></li></ul></div><p>
Bravo, vous avez fini ! <span class="emphasis"><em>Vous devriez toujours tester un
disque d'amorce avant de le ranger jusqu'à la prochaine
urgence !</em></span> S'il n'arrive pas à démarrer, continuez à lire.
</p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="troubleshooting"></a>7. En cas de problème, ou l'agonie de la défaite</h2></div></div><div></div></div><p>

<a class="indexterm" name="id2502152"></a>

Lorsque l'on crée des disques d'amorce, les premiers essais n'amorcent
souvent pas la machine. En général, la méthode utilisée consiste à
construire le disque racine à partir de composants de votre système
actuel pour essayer d'obtenir que le système de la disquette commence
à afficher des messages sur la console. Une fois qu'il a commencé à
vous parler, la bataille est presque gagnée puisque vous pouvez voir
de quoi il se plaint et corriger les problèmes un à un jusqu'à ce que
le système fonctionne normalement. Si le système s'arrête brutalement
sans explication, il peut être difficile d'en trouver la cause. Pour
que le système en arrive au point où il commence à afficher ses
messages, un certain nombre de composants doivent être présents et
bien configurés. La procédure à suivre pour déterminer les raisons du
silence de votre système est la suivante :
</p><div class="itemizedlist"><ul type="disc"><li><p>Si vous voyez un message du genre :
</p><pre class="programlisting">
Kernel panic: VFS: Unable to mount root fs on XX:YY
</pre><p>
C'est un problème courant qui ne peut avoir que quelques causes. Tout
d'abord, cherchez le périphérique <span class="emphasis"><em>XX:YY</em></span> dans la
liste de codes des périphériques dans le fichier
<tt class="filename">/usr/src/linux/Documentation/devices.txt</tt> ;
s'agit-il du bon périphérique racine ?  Si ce n'est pas le bon, vous
n'avez sans doute pas lancé <span><b class="command">rdev -R</b></span>, ou alors sur la
mauvaise image. Si le code du périphérique est correct, vérifiez
attentivement quels gestionnaires de périphériques ont été compilés dans
le noyau. Assurez-vous que le support pour le lecteur de disquettes, les
disques mémoires et le système de fichiers ext2 sont bien inclus ;
</p></li><li><p>Si vous voyez plusieurs erreurs du genre :
</p><pre class="programlisting">
end_request: I/O error, dev 01:00 (ramdisk), sector NNN
</pre><p>
Il s'agit d'une erreur d'E/S du périphérique disque mémoire, la plupart
du temps à cause du noyau qui tente d'écrire au-delà de la fin du
périphérique. Le disque mémoire est trop petit pour supporter la
totalité du système de fichiers. Vérifiez les message d'initialisation
du noyau pour trouver une ligne du type :
</p><pre class="programlisting">
Ramdisk driver initialized : 16 ramdisks of 4096K size
</pre><p>
Vérifiez la taille du système de fichiers
<span class="emphasis"><em>compressé</em></span>. Si le disque mémoire n'est pas assez
grand, il faut l'agrandir.
</p></li><li><p>Vérifiez que le disque racine contient bien les
répertoires que vous croyez. Il est facile de se tromper de niveau
d'arborescence et de se retrouver avec quelque chose du genre
<tt class="filename">/racine/bin</tt> au lieu de <tt class="filename">/bin</tt>
sur votre disquette racine ;
</p></li><li><p>Vérifiez qu'il y a un <tt class="filename">/lib/libc.so</tt>
avec le même lien que celui présent dans le répertoire
<tt class="filename">/lib</tt> de votre disque dur ;
<a class="indexterm" name="id2502283"></a>
</p></li><li><p>Vérifiez que tous les liens symboliques du répertoire
<tt class="filename">/dev</tt> de votre système actuel existent également sur
le système racine, quand ces liens pointent vers des périphériques inclus
sur la disquette racine. Notamment, les liens vers
<tt class="filename">/dev/console</tt> sont souvent essentiels ;
<a class="indexterm" name="id2502302"></a>
</p></li><li><p>Vérifiez que vous avez inclus les fichiers
<tt class="filename">/dev/tty1</tt>, <tt class="filename">/dev/null</tt>,
<tt class="filename">/dev/zero</tt>, <tt class="filename">/dev/mem</tt>,
<tt class="filename">/dev/ram</tt> et <tt class="filename">/dev/kmem</tt> ;
</p></li><li><p>Vérifiez la configuration de votre noyau : le support
pour toutes les ressources nécessaires jusqu'à l'invite de connexion 
doit être directement inclus et non pas sous forme de modules. 
<span class="emphasis"><em>Le support des disques mémoires et de ext2 doivent donc être 
présents dans le noyau</em></span> ;
</p></li><li><p>Vérifiez que le périphérique racine et le disque mémoire
sont correctement configurés dans le noyau.
</p></li></ul></div><p>
Une fois ces points généraux vérifiés, vous pouvez vous pencher sur
ces points plus précis :
</p><div class="orderedlist"><ol type="1"><li><p>Vérifiez qu'<span><b class="command">init</b></span> est présent en tant
que <tt class="filename">/sbin/init</tt> ou <tt class="filename">/bin/init</tt>,
et qu'il est exécutable ;
</p></li><li><p>Lancez <span><b class="command">ldd init</b></span> pour vérifier les
bibliothèques
<a class="indexterm" name="id2502464"></a>
d'<span><b class="command">init</b></span>. Il n'y a normalement que
<tt class="filename">libc.so</tt>, mais sait-on jamais… Vérifiez que vous
avez bien inclus les bibliothèques et leurs chargeurs ;
</p></li><li><p>Vérifiez que vous avez le bon chargeur pour vos
bibliothèques : <tt class="filename">ld.so</tt> pour a.out et
<tt class="filename">ld-linux.so</tt> pour ELF ;
<a class="indexterm" name="id2502498"></a>
</p></li><li><p>Vérifiez le contenu de <tt class="filename">/etc/inittab</tt>
sur la disquette d'amorce et ses éventuels appels à
<span><b class="command">getty</b></span> (ou tout autre programme du genre, tel que
<span><b class="command">agetty</b></span>, <span><b class="command">mgetty</b></span> ou
<span><b class="command">getty_ps</b></span>).
</p><a class="indexterm" name="id2502554"></a><a class="indexterm" name="id2502567"></a><p>
Comparez-le plusieurs fois avec l'<tt class="filename">inittab</tt> de votre
disque dur. Vérifiez les pages de manuel du programme que vous utilisez
pour être sûr de sa cohérence. <tt class="filename">inittab</tt> peut être le
morceau le plus difficile en raison de sa syntaxe et du contenu qui
dépendent de la version d'<span><b class="command">init</b></span> utilisée et de la
nature du système. La seule manière de s'en débarrasser, c'est de lire
les pages de manuel d'<span><b class="command">init</b></span> et
<tt class="filename">inittab</tt> afin de comprendre exactement ce que fait
le système lorsqu'il démarre. Vérifiez que
<tt class="filename">/etc/inittab</tt> contient bien une entrée concernant
l'initialisation du système. Elle doit contenir une commande lançant le
script d'initialisation du système, qui doit lui aussi exister ;
</p></li><li><p>Comme pour <span><b class="command">init</b></span>, lancez
<span><b class="command">ldd</b></span> sur votre <span><b class="command">getty</b></span> pour voir ses
besoins, et vérifiez que les bibliothèques et chargeurs nécessaires sont
présents sur le système racine ;
</p></li><li><p>Assurez-vous d'avoir inclus un exécutable de shell (par
exemple <span><b class="command">bash</b></span> ou <span><b class="command">ash</b></span>) capable de
faire tourner tous vos scripts <span><b class="command">rc</b></span> ;
<a class="indexterm" name="id2502684"></a>
</p></li><li><p>Si vous avez un fichier
<tt class="filename">/etc/ld.so.cache</tt> sur le disque de secours,
refabriquez-le (le fichier, pas le disque).
<a class="indexterm" name="id2502703"></a>
</p></li></ol></div><p>
Si <span><b class="command">init</b></span> démarre et que vous obtenez un message du type :
</p><pre class="programlisting">
Id xxx respawning too fast: disabled for 5 minutes
</pre><a class="indexterm" name="id2502736"></a><p>
cela provient d'<span><b class="command">init</b></span> et indique généralement que
<span><b class="command">getty</b></span> ou <span><b class="command">login</b></span> meurt aussitôt
après son lancement.
</p><a class="indexterm" name="id2502773"></a><a class="indexterm" name="id2502786"></a><a class="indexterm" name="id2502798"></a><p>
Vérifiez les exécutables de <span><b class="command">getty</b></span> et
<span><b class="command">login</b></span>, et les bibliothèques dont ils dépendent.
Vérifiez que les appels depuis <tt class="filename">/etc/inittab</tt> sont
corrects. Si vous obtenez d'étranges messages de
<span><b class="command">getty</b></span>, cela peut signifier que les arguments dans
<tt class="filename">/etc/inittab</tt> sont faux. Les options des programmes
<span><b class="command">getty</b></span> sont variables ; on signale que les arguments
sont parfois incompatibles entre deux versions
d'<span><b class="command">agetty</b></span>.
</p><a class="indexterm" name="id2502863"></a><p>
Si vous obtenez une invite de login et qu'après avoir entré un nom de
login valide, le système vous en demande un autre aussitôt, le problème
peut venir de PAM ou NSS. Lisez la <a href="#PAMNSS" title="4.4. Utilisation de PAM et NSS">Section 4.4, « Utilisation de PAM et NSS »</a>.  Le
problème peut aussi venir du fait que vous utilisez les <span class="emphasis"><em>mots
de passe cachés</em></span> et que vous n'avez pas copié le fichier
<tt class="filename">/etc/shadow</tt> sur votre disque d'amorce.
</p><a class="indexterm" name="id2502906"></a><p>
Si vous essayez de lancer un exécutable tel que <span><b class="command">df</b></span>
présent sur votre disque de secours, mais n'obtenez qu'un message du
type : <span class="emphasis"><em>df: not found</em></span>, vérifiez deux chose : (1) que
le répertoire contenant le binaire est bien dans votre PATH, et (2) que
vous avez les bibliothèques (et chargeurs) nécessaires au programme.
</p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="slimfast"></a>8. Réduire la taille du système racine</h2></div></div><div></div></div><p>
Parfois un système racine est trop gros pour tenir sur une disquette,
même après compression. Voici quelques techniques pour réduire sa
taille, citées par ordre décroissant d'efficacité :
</p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="high-density"></a>8.1. Augmentez la densité du disque</h3></div></div><div></div></div><p>
Par défaut, les disquettes sont formatées à 1440 ko, mais des formats
plus denses existent. <tt class="filename">fdformat</tt> peut formater des
disques avec les tailles suivantes : 1600, 1680, 1722, 1743, 1760, 1840
et 1920. Lisez la page de manuel de <tt class="filename">fdformat</tt> ainsi
que <tt class="filename">/usr/src/linux/Documentation/devices.txt</tt>.
</p><p>
Mais quelles densités/géométries votre machine peut-elle supporter ? Voici des
réponses (légèrement modifiées) de Alain Knaff, l'auteur de
<span><b class="command">fdutils</b></span>.
</p><div class="blockquote"><table border="0" width="100%" cellspacing="0" cellpadding="0" class="blockquote" summary="Block quote"><tr><td width="10%" valign="top"> </td><td width="80%" valign="top"><p>
C'est plus le problème du <span class="acronym">BIOS</span> que du format physique
des disquettes. Si le <span class="acronym">BIOS</span> décide que tous les
numéros de secteurs supérieurs à 18 sont non valides, alors on ne peut
pas y faire grand chose. En effet, à moins de désassembler le
<span class="acronym">BIOS</span>, le seul moyen de trouver la bonne valeur est en
tâtonnant. Quoiqu'il en soit, si le <span class="acronym">BIOS</span> supporte les
disques ED (grande densité : 36 secteurs/piste et 2,88 Mo), il y a des
chances pour que les disquettes de 1722 ko soient également supportées.
</p><p>
Les disquettes super-formatées avec plus de 21 secteurs par piste ne
sont vraisemblablement pas amorçables : en fait, celles qui 
utilisent des secteurs de tailles non standard (1024 octets par 
secteur au lieu de 512, par exemple) ne sont vraisemblablement pas 
démarrables. Il devrait être malgré tout possible d'écrire un programme 
de démarrage du secteur pour contourner cela. Si je me souviens bien, le 
programme <span><b class="command">DOS 2m</b></span> en est capable, ainsi que les 
programmes <span><b class="command">XDF</b></span> de <span class="acronym">OS/2</span>.
</p><p>
Certains <span class="acronym">BIOS</span> clament artificiellement que tout
secteur supérieur à 18 est certainement défectueux. Comme les disquettes
de 1722 ko utilisent des secteurs supérieurs à 21, elles ne devraient
pas être amorçables. Le meilleur moyen de tester serait de formater une
disquette DOS ou syslinux en 1722 ko et de la rendre amorçable. Si 
vous utilisez <span><b class="command">LILO</b></span>, n'utilisez pas l'option
<tt class="option">linear</tt> (sans quoi <span><b class="command">LILO</b></span> penserait que
le format par défaut de la disquette est de 18 secteurs par piste, et la
disquette ne démarrera pas même si le <span class="acronym">BIOS</span> la
supporte).
</p></td><td width="10%" valign="top"> </td></tr><tr><td colspan="2" align="right" valign="top">--<span class="attribution">Alain Knaff</span></td><td width="10%" valign="top"> </td></tr></table></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2503120"></a>8.2. Remplacer les utilitaires indispensables par BusyBox</h3></div></div><div></div></div><p>
La plupart de l'espace disque d'un système de fichiers est consommé par
des utilitaires indispensables tels que <span><b class="command">cat</b></span>,
<span><b class="command">chmod</b></span>, <span><b class="command">cp</b></span>, <span><b class="command">dd</b></span>,
<span><b class="command">df</b></span>, et cætera. Le projet <span class="emphasis"><em>BusyBox</em></span>
permet de fournir un remplacement à ces utilitaires indispensables.
BusyBox fournit un seul fichier monolithique exécutable,
<span><b class="command">/bin/busybox</b></span>, d'environ 150 ko, qui implémente les
fonctions de ces utilitaires. Vous pouvez créer des liens symboliques à
partir de différents programmes vers cet exécutable ;
<span><b class="command">busybox</b></span> voit comment il a été appelé et invoque le
code correcte. BusyBox inclut même un shell basique. BusyBox est
disponible sous forme de paquetage binaire pour plusieurs distributions,
et le code source est disponible sur le site de BusyBox.
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2503196"></a>8.3. Changez de shell</h3></div></div><div></div></div><p> Certains shells populaires sous Linux, tels que
<span><b class="command">bash</b></span> et <span><b class="command">tcsh</b></span>, sont gros et
nécessitent de nombreuses bibliothèques. Si vous n'utilisez pas le shell
de BusyBox, vous devriez quand même songer à remplacer le shell.
D'autres options plus légères existent, telles que
<span><b class="command">ash</b></span>, <span><b class="command">lsh</b></span>, <span><b class="command">kiss</b></span>
et <span><b class="command">smash</b></span>, bien plus petites et nécessitant peu (ou
pas) de bibliothèques. La plupart de ces shells de remplacement sont
disponibles sur
<a href="http://www.ibiblio.org/pub/Linux/system/shells/" target="_top">
http://www.ibiblio.org/pub/Linux/system/shells/</a>.
Vérifiez que le shell que vous utilisez sait faire tourner les commandes
de tous les scripts <span><b class="command">rc</b></span> que vous incluez sur le disque
d'amorce.  <a class="indexterm" name="id2503264"></a>
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2503273"></a>8.4. Nettoyez les bibliothèques et binaires</h3></div></div><div></div></div><p>
De nombreux binaires et bibliothèques restent non nettoyés (ils
contiennent les informations pour le déboguage). Si vous lancez
<span><b class="command">file</b></span> sur ces fichiers, il vous indiquera
<span class="emphasis"><em>not stripped</em></span> si c'est le cas. Lorsque vous copiez
des binaires sur votre système racine, une bonne habitude à prendre est
d'utiliser :
</p><pre class="programlisting">
objcopy --strip-all ORIGINE DESTINATION
</pre><a class="indexterm" name="id2503306"></a><a class="indexterm" name="id2503318"></a><a class="indexterm" name="id2503331"></a><p>
Et lorsque vous copiez des bibliothèques :
</p><pre class="programlisting">
objcopy --strip-debug ORIGINE DESTINATION
</pre></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2503351"></a>8.5. Déplacez les fichiers non essentiels vers un disque
utilitaire</h3></div></div><div></div></div><p>
Si certains binaires ne sont pas immédiatement nécessaires au démarrage
ou au login, vous pouvez les déplacer sur un disque utilitaire. Lisez la
<a href="#utilitydisk" title="9.2. Construire un disque utilitaire">Section 9.2, « Construire un disque utilitaire »</a> pour les détails. Vous pouvez aussi
déplacer les modules vers un disque utilitaire.
<a class="indexterm" name="id2503374"></a>
</p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2503384"></a>9. Sujets divers</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="nonramdiskroot"></a>9.1. Système racine sans disque mémoire</h3></div></div><div></div></div><p>
<a class="indexterm" name="id2503402"></a>
La <a href="#buildroot" title="4. Construire un système racine">Section 4, « Construire un système racine »</a> explique comment construire un système
racine compressé chargé en mémoire lors du démarrage du système. Cette
méthode qui présente beaucoup d'avantages est souvent utilisée.
Néanmoins, certains systèmes possédant peu de mémoire ne peuvent se
permettre d'utiliser de la RAM pour un disque mémoire, et doivent donc
utiliser un système racine monté directement depuis la disquette.
</p><p>
De tels systèmes sont en réalité plus faciles à construire que les
systèmes racines compressés car on peut les créer directement sur
disquette plutôt que de passer par un autre périphérique
intermédiaire, et ne nécessitent pas de compression. Nous indiquerons
les différences de procédure par rapports aux instructions
précédentes. Si vous choisissez cette méthode, rappelez-vous bien que
vous aurez <span class="emphasis"><em>beaucoup moins d'espace disque</em></span> disponible.
</p><div class="orderedlist"><ol type="1"><li><p>Calculez la taille disponible pour les fichiers racines.
</p><p>
Si vous construisez un système d'amorce/racine unique, vous devez
arriver à faire tenir tous les blocs du noyau ainsi que tous les blocs
du système racine sur un seul disque.
</p></li><li><p>À l'aide de <span><b class="command">mke2fs</b></span>, créez un système
racine de la bonne taille sur une disquette.
</p></li><li><p>Remplissez le système comme décrit précédemment.
</p></li><li><p>Après cela, démontez le système et transférez-le vers un
fichier sur le disque, mais <span class="emphasis"><em>sans le compresser</em></span>.
</p></li><li><p>Transférez le noyau sur une disquette comme décrit
précédemment. Lorsque vous calculerez le mot disque mémoire, mettez le
bit 14 à 0 pour indiquer que le système racine ne doit pas être chargé
en mémoire. Lancez la commande <span><b class="command">rdev</b></span> indiquée.
<a class="indexterm" name="id2503514"></a>
<a class="indexterm" name="id2503526"></a>
<a class="indexterm" name="id2503533"></a>
</p></li><li><p>Transférez le système racine comme précédemment.
</p></li></ol></div><p>
Vous pouvez prendre quelques raccourcis. Si vous construisez un système
avec deux disques, vous pouvez construire le système de fichiers racine
directement sur le second disque au lieu de le transférer sur le disque
dur puis à nouveau sur la disquette. De même, si vous construisez un
disque d'amorce/racine unique et si vous utilisez
<span><b class="command">LILO</b></span>, vous pouvez créer un système de fichiers
<span class="emphasis"><em>unique</em></span> sur toute la disquette contenant le noyau,
les fichiers de <span><b class="command">LILO</b></span> et les fichiers racine, avant de
simplement lancer <span><b class="command">LILO</b></span> comme dernière étape.
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="utilitydisk"></a>9.2. Construire un disque utilitaire</h3></div></div><div></div></div><p>
<a class="indexterm" name="id2503601"></a>
Construire un disque utilitaire est assez facile : créez simplement
un système de fichiers sur une disquette formatée et copiez les
fichiers dessus. Pour l'utiliser depuis un disque d'amorce, montez-le
manuellement une fois le système démarré.
</p><p>
Les instructions précédentes indiquent qu'un disque utilitaire peut être
monté en tant que <tt class="filename">/usr</tt>. Dans ce cas, les binaires
doivent être placés dans un répertoire <tt class="filename">/bin</tt> du
disque utilitaire, afin d'être référencés si vous mettez
<tt class="filename">/usr/bin</tt> dans votre chemin. Les bibliothèques
supplémentaires nécessaires aux binaires sont à placer dans
<tt class="filename">/lib</tt> sur le disque utilitaire.
</p><p>
Il faut penser à plusieurs choses lorsque l'on crée un disque
utilitaire :
</p><div class="orderedlist"><ol type="1"><li><p>Ne placez pas de binaires ou de bibliothèques essentiels
pour le système sur le disque utilitaire, puisqu'il ne sera montable qu'une
fois le système démarré ;
</p></li><li><p>Vous ne pouvez pas utiliser de lecteur de disquette et
de lecteur de bande sur port disquette en même temps. Ce qui veut dire
que si votre lecteur de bande est sur un port disquette, vous ne pourrez
pas y accéder tant que votre disque utilitaire sera monté ;
</p></li><li><p>L'accès aux fichiers du disque utilitaire sera lent.
</p></li></ol></div><p>
L' <a href="#utilitylist" title="D. Exemple de contenu des répertoires d'un disque utilitaire">Annexe D, <i>Exemple de contenu des répertoires d'un disque utilitaire</i></a> montre ce que peut contenir un tel
disque. Voici quelques idées de fichiers qui peuvent vous être utiles :
programmes de diagnostic et de manipulation de disques
(<span><b class="command">format</b></span>, <span><b class="command">fdisk</b></span>) et systèmes de
fichiers (<span><b class="command">mke2fs</b></span>, <span><b class="command">fsck</b></span>,
<span><b class="command">debugfs</b></span>, <tt class="filename">isofs.o</tt>), un éditeur de
texte léger (<span><b class="command">elvis</b></span>, <span><b class="command">jove</b></span>), des
utilitaires de compression et archivage (<span><b class="command">gzip</b></span>,
<span><b class="command">tar</b></span>, <span><b class="command">cpio</b></span>,
<span><b class="command">afio</b></span>), de gestion de bande (<span><b class="command">mt</b></span>,
<span><b class="command">ftmt</b></span>, <span><b class="command">tob</b></span>,
<span><b class="command">taper</b></span>), de communication (<tt class="filename">ppp.o</tt>,
<tt class="filename">slip.o</tt>, <span><b class="command">minicom</b></span>) et de gestion
de périphériques (<span><b class="command">setserial</b></span>,
<span><b class="command">mknod</b></span>).
</p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pros"></a>10. La méthode des pros</h2></div></div><div></div></div><p>
Vous avez peut-être remarqué comme les disques d'amorce utilisés par
les principales distributions comme Slackware, RedHat ou Debian
paraissent plus sophistiqués que ce que décrit ce document. Les
disques d'amorce de distribution professionnelles se basent sur les
mêmes principes que ceux décrits ici, mais utilisent diverses astuces
pour satisfaire aux besoins supplémentaires de leurs disques
d'amorce. Tout d'abord, ils doivent pouvoir fonctionner sur une grande
variété de matériel et doivent donc pouvoir interagir avec
l'utilisateur et charger divers gestionnaires de
périphériques. Ensuite, ils doivent pouvoir travailler avec beaucoup
d'options d'installation différentes, de manière plus ou moins
automatique. Enfin, les disques d'amorce des distributions combinent
en général la possibilité d'installer le système avec celle de le
réparer.
</p><a class="indexterm" name="id2503874"></a><p>
Certains disques d'amorce utilisent une fonctionnalité appelée
<span><b class="command">initrd</b></span> (<span class="emphasis"><em>initial ramdisk</em></span>, ou
<span class="emphasis"><em>disque mémoire initial</em></span>). Cette fonctionnalité est
apparue aux alentours de la version 2.0.x et permet au noyau de démarrer
en deux étapes. Quand le noyau commence son démarrage, il charge une
première image de disque mémoire depuis le disque d'amorce. Ce disque
mémoire initial est un système racine contenant un programme à exécuter
avant le chargement du vrai système racine. Ce programme inspecte en
général l'environnement et/ou demande à l'utilisateur de sélectionner
diverses options de démarrage, telles que le périphérique sur lequel on
va trouver le vrai disque racine. En général, il charge des modules
supplémentaires ne faisant pas partie du noyau. Quand ce programme
initial se termine, le noyau charge la vraie image racine et continue
son démarrage normalement. Pour plus d'information sur
<span><b class="command">initrd</b></span>, lisez
<tt class="filename">/usr/src/linux/Documentation/initrd.txt</tt> et <a href="ftp://elserv.ffm.fgan.de/pub/linux/loadlin-1.6/initrd-example.tgz" target="_top">
ftp://elserv.ffm.fgan.de/pub/linux/loadlin-1.6/initrd-example.tgz</a>.
</p><p>
Vous trouverez ci-dessous des résumés sur la manière dont les disques
d'installation de chaque distribution semblent marcher, après étude de
leurs systèmes de fichiers et/ou code source. Nous ne garantissons pas
l'exactitude des informations, ni qu'elles n'ont pas changé depuis les
versions indiquées.
</p><p>
Slackware (v.3.1) utilise un démarrage direct avec
<span><b class="command">LILO</b></span> semblable à la description de la <a href="#usinglilo" title="6.1. Transfert du noyau avec LILO">Section 6.1, « Transfert du noyau avec LILO »</a>.  Le disque d'amorce de la Slackware affiche un
message de démarrage (<span class="emphasis"><em>Welcome to the Slackware Linux
bootkernel disk!</em></span>) en utilisant le paramètre
<tt class="option">message</tt> de <span><b class="command">LILO</b></span>. Ce message indique
à l'utilisateur d'entrer une ligne  de paramètres de démarrage si
nécessaire. Après le démarrage, un système  racine est chargé depuis une
seconde disquette. L'utilisateur lance un  script de configuration
(<span><b class="command">setup</b></span>) qui démarre l'installation. Au lieu
d'utiliser  un noyau modulaire, Slackware fournit un certain nombre de
noyaux différents, et c'est à l'utilisateur de fournir celui qui
correspond à sa configuration matérielle.
</p><p>
RedHat (v.4.0) utilise aussi un démarrage avec <span><b class="command">LILO</b></span>.
Il charge un disque mémoire compressé sur le premier disque, qui fait
tourner une version personnalisée d'<span><b class="command">init</b></span>. Ce
programme demande quels gestionnaires utiliser puis charge des fichiers
supplémentaires depuis un autre disque si nécessaire.
</p><p>
Debian (v.1.3) possède probablement le groupe de disques d'installation
le plus sophistiqué. Il utilise le chargeur <span><b class="command">SYSLINUX</b></span>
pour choisir différentes options de chargement, puis utilise une image
<span><b class="command">initrd</b></span> pour guider l'utilisateur dans l'installation.
Il semble utiliser à la fois des versions personnalisées
d'<span><b class="command">init</b></span> et du shell.
</p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="cdrom"></a>11. Créer des CD-ROM amorçables</h2></div></div><div></div></div><p>
Cette section a été écrite avec la contribution de Rizwan Mohammed Darwe
(rizwan CHEZ clovertechnologies POINT com).
</p><p>
Cette section suppose que vous êtes familier avec la procédure et le
fonctionnement de l'écriture de CD sous Linux. Considérez ceci comme
une référence rapide pour inclure la possibilité de démarrer à partir du
CD que vous allez graver. La CD-Writing-HOWTO devrait vous donner plus
de détails.
</p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2504104"></a>11.1. Qu'est-ce que El Torito ?</h3></div></div><div></div></div><p>
À partir des plates-formes x86, plusieurs <span class="acronym">BIOS</span> ont
commencé à accepter les CD amorçables. Les rustines pour 
<span><b class="command">mkisofs</b></span> sont basés sur le standard appelé 
« El Torito ». En deux mots, El Torito est une 
spécification qui indique le format qu'un CD doit respecter, afin de 
pouvoir démarrer directement sur celui-ci.
</p><p>
La spécification « El Torito » dit que 
<span class="emphasis"><em>tout</em></span> lecteur de CD-ROM devrait fonctionner (SCSI ou 
EIDE) si le <span class="acronym">BIOS</span> est compatible El Torito. Sauf que 
cela n'a été testé qu'avec des lecteurs EIDE, car aucun contrôleur SCSI 
testé ne semble supporter El Torito. La carte mère doit impérativement 
être compatible El Torito. Comment savoir si votre carte mère 
est compatible El Torito ? Eh bien les cartes mères compatibles 
offrent le choix de démarrer à partir du disque dur, de la disquette, du 
réseau ou du CD-ROM.
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2504147"></a>11.2. Comment ça marche</h3></div></div><div></div></div><p>
Le standard El Torito fonctionne en faisant apparaître le lecteur de CD,
à travers les appels <span class="acronym">BIOS</span>, comme un lecteur de
disquettes normal. De cette façon vous mettez simplement n'importe
quelle image de la taille d'une disquette (exactement 1440 ko pour une
disquette de 1,44 Mo) quelque part sur le système de fichiers ISO. Dans
l'en-tête du système de fichiers ISO vous placez un pointeur vers cette
image. Le <span class="acronym">BIOS</span> va alors récupérer cette image à
partir du CD et agit comme si il démarrait à partir du lecteur de
disquettes. Cela permet à une disquette de démarrage 
<span><b class="command">LILO</b></span>, par exemple, d'être utilisée simplement comme
si c'était une vraie disquette.
</p><p>
En général, les 1,44 (ou 2,88 si supportés) premiers Mo du CD-ROM
contiennent une image de la disquette créée par vous. Cette image est
traitée comme une disquette par le <span class="acronym">BIOS</span> et démarrée
par celui-ci. (Avec comme conséquence, lors du démarrage à partir de la
disquette virtuelle, que votre lecteur original <span class="emphasis"><em>A:</em></span>
(<tt class="filename">/dev/fd0</tt>) ne sera plus accessible, mais vous
pouvez toujours essayer <tt class="filename">/dev/fd1</tt>).
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2504240"></a>11.3. Comment le faire marcher</h3></div></div><div></div></div><p>
D'abord, il faut créer un fichier, disons <tt class="filename">boot.img</tt>,
qui est l'image exacte de la disquette que vous voulez démarrer via le
CD-ROM. Ce doit être une disquette de démarrage 1,44 Mo. La commande
suivante permet de la créer :
</p><pre class="programlisting">
dd if=/dev/fd0 of=boot.img bs=10k count=144
</pre><p>
en supposant que la disquette se trouve dans le lecteur
<span class="emphasis"><em>A:</em></span>.
</p><p>
Placez cette image quelque part dans la hiérarchie qui sera la source du
système de fichiers iso9660. C'est une bonne idée de mettre tous les
fichiers relatifs au démarrage dans leur propre répertoire
(<tt class="filename">boot/</tt> sous la racine du système de fichiers
iso9660, par exemple).
</p><p>
Avertissement : Votre disquette de démarrage <span class="emphasis"><em>doit</em></span>
charger un <span class="emphasis"><em>initial ramdisk</em></span> via
<span><b class="command">LILO</b></span>, et pas le disque mémoire du noyau ! Ceci est du
au fait que lorsque le noyau démarre, l'émulation
<span class="acronym">BIOS</span> du CD comme disquette est limitée et va échouer.
<span><b class="command">LILO</b></span> va charger le disque mémoire en utilisant les
appels disques <span class="acronym">BIOS</span>, et l'émulation fonctionne
normalement.
</p><p>
La spécification El Torito requiert également la création d'un
<span class="emphasis"><em>catalogue de démarrage</em></span>. Il s'agit d'un fichier de
2048 octets qui n'a pas grand intérêt à part qu'il est nécessaire. 
La correction réalisée par l'auteur de <span><b class="command">mkisofs</b></span> permet 
la création automatique de ce catalogue de démarrage, mais vous devez 
spécifier où ce catalogue doit se trouver dans la hiérarchie du système 
de fichiers iso9660. En général c'est une bonne idée de le mettre au 
même endroit que l'image de démarrage, et de l'appeler 
<tt class="filename">boot.catalog</tt>. La commande pour créer le système de 
fichiers iso9660 dans le fichier <tt class="filename">bootcd.iso</tt> est 
alors :
</p><pre class="programlisting">
mkisofs -r -b boot/boot.img -c boot/boot.catalog -o bootcd.iso .
</pre><p>
L'option <tt class="option">-b</tt> précise l'image de démarrage à utiliser
(notez que le chemin est relatif à la racine du disque iso9660), et
l'option <tt class="option">-c</tt> est pour le fichier catalogue de démarrage.
L'option <tt class="option">-r</tt> va mettre les propriétaires et droits des
fichiers appropriés (voir la page de manuel de
<span><b class="command">mkisofs</b></span>). Le « . » à la fin dit de prendre comme source
le répertoire courant.
</p><p>
Maintenant gravez le CD avec la commande habituelle et le voilà prêt à
démarrer.
</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2504424"></a>11.4. Créer des CD-ROM Win9x amorçables</h3></div></div><div></div></div><p>
La première chose à faire est de récupérer une image amorçable utilisée
par le CD source. Mais vous ne pouvez pas vous contenter de monter 
le CD sous Linux et d'utiliser <span><b class="command">dd</b></span> pour copier les 
1440 premiers kilo-octets vers une disquette ou 
un fichier <tt class="filename">boot.img</tt>. Au lieu de cela, vous devez 
simplement amorcer votre système à partir du CD-ROM source.
</p><p>
Lorsque vous démarrez le CD Win98 vous vous retrouvez à l'invite
<span class="emphasis"><em>A:</em></span>, qui est en fait le disque mémoire. Et
<span class="emphasis"><em>D:</em></span> ou <span class="emphasis"><em>Z:</em></span> où se trouvent tous 
les fichiers d'installation. En utilisant la commande DOS
<span><b class="command">diskcopy</b></span>, copiez l'image <span class="emphasis"><em>A:</em></span> dans
le vrai lecteur de disquettes, qui est maintenant 
<span class="emphasis"><em>B:</em></span>. La commande suivante permet de le faire :
</p><pre class="programlisting">
diskcopy A: B:
</pre><p>
Cela fonctionne exactement comme <span><b class="command">dd</b></span>. Vous pouvez
essayer de démarrer à partir de ce disque fraîchement créé pour tester
si le processus de démarrage est similaire à celui du CD source. Ensuite
faites le <span><b class="command">dd</b></span> habituel de cette disquette vers un fichier
comme <tt class="filename">boot.img</tt> et le reste sera comme d'habitude.
</p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2504525"></a>12. Foire Aux Questions (FAQ)</h2></div></div><div></div></div><div class="qandaset"><dl><dt>Q : <a href="#id2504534">
Je démarre depuis mes disques d'amorce/racine et rien ne se
passe. Que faire ?
</a></dt><dt>Q : <a href="#id2504559">
Comment fonctionne le disque d'amorce
Slackware/Debian/RedHat ?
</a></dt><dt>Q : <a href="#id2504581">
Comment utiliser des disquettes de haute densité (&gt; 1440 ko) ? 
Comment savoir quelles densités fonctionneront avec mon lecteur de 
disquette ?
</a></dt><dt>Q : <a href="#id2504613">
Comment augmenter la taille de mes disques mémoire ?
</a></dt><dt>Q : <a href="#id2504728">
Comment faire des CD-ROM amorçables ?
</a></dt><dt>Q : <a href="#id2504753">
Comment faire des disquettes LS-120 amorçables ?
</a></dt><dt>Q : <a href="#id2504863">
Comment faire un disque d'amorce avec un gestionnaire pour XYZ ?
</a></dt><dt>Q : <a href="#id2505004">
Comment mettre à jour le noyau de ma disquette d'amorce ?
</a></dt><dt>Q : <a href="#id2505059">
Comment mettre à jour ma disquette racine avec de nouveaux
fichiers ?
</a></dt><dt>Q : <a href="#id2505130">
Comment retirer LILO pour pouvoir redémarrer DOS ?
</a></dt><dt>Q : <a href="#id2505245">
Comment puis-je démarrer si j'ai perdu mon noyau et
mon disque d'amorce ?
</a></dt><dt>Q : <a href="#id2505394">
Comment faire des copies supplémentaires des disquettes
d'amorce/racine ?
</a></dt><dt>Q : <a href="#id2505526">
Comment puis-je démarrer sans avoir à taper 
« ahaxxxx=nn,nn,nn » à chaque fois ?
</a></dt><dt>Q : <a href="#id2505738">
Au démarrage, j'obtiens l'erreur « A: cannot execute 
B ». Pourquoi ?
</a></dt><dt>Q : <a href="#id2505871">
Mon noyau gère les disques mémoires, mais les initialise à 0 ko
</a></dt></dl><table border="0" summary="Q and A Set"><col align="left" width="1%"><tbody><tr class="question"><td align="left" valign="top"><a name="id2504534"></a><a name="id2504536"></a><b>Q :</b></td><td align="left" valign="top"><p>
Je démarre depuis mes disques d'amorce/racine et rien ne se
passe. Que faire ?
</p></td></tr><tr class="answer"><td align="left" valign="top"><b>R :</b></td><td align="left" valign="top"><p>
Voir la section précédente <a href="#troubleshooting" title="7. En cas de problème, ou l'agonie de la défaite">Section 7, « En cas de problème, ou l'agonie de la défaite »</a>.
</p></td></tr><tr class="question"><td align="left" valign="top"><a name="id2504559"></a><a name="id2504561"></a><b>Q :</b></td><td align="left" valign="top"><p>
Comment fonctionne le disque d'amorce
Slackware/Debian/RedHat ?
</p></td></tr><tr class="answer"><td align="left" valign="top"><b>R :</b></td><td align="left" valign="top"><p>
Voir la section précédente <a href="#pros" title="10. La méthode des pros">Section 10, « La méthode des pros »</a>.
</p><p>
</p></td></tr><tr class="question"><td align="left" valign="top"><a name="id2504581"></a><a name="id2504583"></a><b>Q :</b></td><td align="left" valign="top"><p>
Comment utiliser des disquettes de haute densité (&gt; 1440 ko) ? 
Comment savoir quelles densités fonctionneront avec mon lecteur de 
disquette ?
</p></td></tr><tr class="answer"><td align="left" valign="top"><b>R :</b></td><td align="left" valign="top"><p>
Voir dans la section précédente <a href="#high-density" title="8.1. Augmentez la densité du disque">Section 8.1, « Augmentez la densité du disque »</a> les
commentaires de Alain Knaff à ce sujet. C'est la réponse la plus
crédible que je connaisse.
</p></td></tr><tr class="question"><td align="left" valign="top"><a name="id2504613"></a><a name="id2504615"></a><b>Q :</b></td><td align="left" valign="top"><p>
Comment augmenter la taille de mes disques mémoire ?
</p></td></tr><tr class="answer"><td align="left" valign="top"><b>R :</b></td><td align="left" valign="top"><p>
Cela devrait être mieux expliqué dans le texte, mais je met une réponse
ici pour l'instant.
</p><p>
D'abord, <span class="emphasis"><em>n'essayez pas</em></span> d'utiliser
<span><b class="command">rdev</b></span> ou <span><b class="command">ramsize</b></span> pour faire cela,
quoi qu'en disent leurs documentations. Le mot disque mémoire ne
détermine plus la taille des disques mémoires.
</p><p>
Ensuite, gardez à l'esprit que les disques mémoires sont actuellement
dynamiques ; lorsque vous définissez la taille d'un disque mémoire vous
n'allouez pas de mémoire, vous précisez juste de combien il peut
grandir. N'ayez pas peur de choisir une taille inutilement trop grande
(par exemple 8 ou même 16 Mo). L'espace RAM n'est pas utilisé tant que
vous n'en n'avez pas besoin. Vous pouvez définir ces limites  de
plusieurs façons différentes :
</p><div class="orderedlist"><ol type="1"><li><p>Utilisez le paramètre <tt class="option">ramdisk_size=NNN</tt>
en ligne de commande. Vous pouvez soit le rentrer à la main soit
utiliser une commande comme
<span class="emphasis"><em>append="ramdisk_size=NNN"</em></span> avec
<span><b class="command">LILO</b></span> ;</p></li><li><p>Si vous utilisez <span><b class="command">LILO</b></span>, vous pouvez
utiliser une option du noyau comme <tt class="option">ramdisk=8192K</tt> dans
le fichier <tt class="filename">lilo.conf</tt> ;</p></li><li><p>Changez l'option de configuration du noyau
<span class="emphasis"><em>CONFIG_BLK_DEV_RAM_SIZE</em></span> et recompilez votre
noyau.</p></li></ol></div></td></tr><tr class="question"><td align="left" valign="top"><a name="id2504728"></a><a name="id2504730"></a><b>Q :</b></td><td align="left" valign="top"><p>
Comment faire des CD-ROM amorçables ?
</p></td></tr><tr class="answer"><td align="left" valign="top"><b>R :</b></td><td align="left" valign="top"><p>
Voir la section précédente <a href="#cdrom" title="11. Créer des CD-ROM amorçables">Section 11, « Créer des CD-ROM amorçables »</a>.
</p></td></tr><tr class="question"><td align="left" valign="top"><a name="id2504753"></a><a name="id2504755"></a><b>Q :</b></td><td align="left" valign="top"><p>
Comment faire des disquettes LS-120 amorçables ?
</p></td></tr><tr class="answer"><td align="left" valign="top"><b>R :</b></td><td align="left" valign="top"><p>
Comme je n'ai pas de lecteur de disquettes LS-120, les informations qui
suivent sont un résumé fourni par David Cinege du Linux Router Project.
</p><p>
Le LS-120 est un lecteur de disquettes IDE. Il est compatible à la fois
avec les disquettes 3,5 » et les nouvelles disquettes de 120 Mo. Depuis
Linux 2.0.31, celles-ci sont complètement supportées. Pour être capable de
démarrer à partir de ces disquettes, vous devez avoir un
<span class="acronym">BIOS</span> qui autorise le LS-120 à être traité comme
lecteur 0 (alors que les lecteurs IDE commencent normalement à 80). Si
vous n'avez pas le support du <span class="acronym">BIOS</span>, vous pouvez
acheter une petite carte IDE FloppyMAX de Promise Technologies pour
combler ce manque.
</p><p>
Le chargeur du noyau n'aime pas le LS-120, et meurt instantanément. Les
disques 2m non plus ne l'aiment pas et ne démarreront pas. Les
disquettes de 1,44 à 1,74 Mo fonctionnent bien.
<span><b class="command">SYSLINUX</b></span> fonctionne avec les disquettes de 120 Mo à
partir de la version 1.32. Vous auriez intérêt à partitionner la
disquette et utiliser ext2 ou minix, au lieu de
<span><b class="command">SYSLINUX</b></span>, sauf si vous avez besoin d'une
compatibilité MS-DOS.
</p><p>
<span><b class="command">LILO</b></span> fonctionne bien avec des disquettes de 120 Mo.
Voici un <tt class="filename">lilo.conf</tt> simple :
</p><pre class="programlisting">
         boot=/dev/hda
         compact
         disk=/dev/hda bios=0
         install=/floppy/boot.b
         map=/floppy/map
         image=/floppy/linux
         label=Linux
         append="load_ramdisk=1"
         initrd=/floppy/root.bin
         ramdisk=8192
</pre><p>
La ligne <span class="emphasis"><em>disk=/dev/hda bios=0</em></span> est la ruse pour
démarrer à partir du LS-120.
</p></td></tr><tr class="question"><td align="left" valign="top"><a name="id2504863"></a><a name="id2504865"></a><b>Q :</b></td><td align="left" valign="top"><p>
Comment faire un disque d'amorce avec un gestionnaire pour XYZ ?
</p></td></tr><tr class="answer"><td align="left" valign="top"><b>R :</b></td><td align="left" valign="top"><p>
Le plus simple est d'obtenir un noyau Slackware depuis le site miroir
de Slackware le plus proche. Les noyaux Slackware sont des noyaux
génériques contenant le plus de gestionnaires pour le plus de
périphériques différents possibles. Si vous avez un contrôleur SCSI
ou IDE, vous avez de bonnes chances de trouver un gestionnaire
correspondant dans le noyau Slackware.
</p><p>
Allez dans le répertoire <tt class="filename">a1</tt> et sélectionnez un
noyau SCSI ou IDE suivant votre type de contrôleur. Vérifiez dans le
fichier <tt class="filename">xxxxkern.cfg</tt> correspondant au noyau choisi
qu'il contient bien les gestionnaires que vous voulez. Si c'est le cas,
le noyau correspondant devrait pouvoir démarrer votre ordinateur.
Récupérez le fichier <tt class="filename">xxxxkern.tgz</tt> et copiez-le sur
votre disquette d'amorce comme indiqué dans la section sur la
fabrication des disques d'amorce.
</p><a class="indexterm" name="id2504925"></a><p>
Vous devez ensuite vérifier le périphérique racine indiqué dans le
noyau, en utilisant la commande :
</p><pre class="programlisting">
rdev zImage
</pre><p>
<span><b class="command">rdev</b></span> vous montrera alors le périphérique actuellement
configuré dans le noyau. Si ce n'est pas celui que vous voulez, utilisez
<span><b class="command">rdev</b></span> pour le changer. Par exemple, le noyau que j'ai
essayé pointait sur <tt class="filename">/dev/sda2</tt>, mais ma partition
racine SCSI est sur <tt class="filename">/dev/sda8</tt>. Pour utiliser une
disquette racine, vous devrez lancer la commande :
</p><pre class="programlisting">
rdev zImage /dev/fd0
</pre><p>
Si vous voulez aussi savoir comment configurer un disque racine
Slackware, cela dépasse le cadre de ce HOWTO, et je vous suggère donc
de consulter le Guide d'installation de Linux ou de récupérer la
distribution Slackware. Voir l'<a href="#references" title="A. Ressources et pointeurs">Annexe A, <i>Ressources et pointeurs</i></a> de ce HOWTO.
</p></td></tr><tr class="question"><td align="left" valign="top"><a name="id2505004"></a><a name="id2505007"></a><b>Q :</b></td><td align="left" valign="top"><p>
Comment mettre à jour le noyau de ma disquette d'amorce ?
</p></td></tr><tr class="answer"><td align="left" valign="top"><b>R :</b></td><td align="left" valign="top"><p>
<a class="indexterm" name="id2505019"></a>
Copiez simplement le noyau sur votre disquette d'amorce à l'aide de la
commande <span><b class="command">dd</b></span> s'il s'agit d'une disquette d'amorce sans
système de fichier, ou par la commande <span><b class="command">cp</b></span> pour un
disque d'amorce/racine. Reportez-vous à la <a href="#boot" title="3.1. Démarrage">Section 3.1, « Démarrage »</a> de ce
HOWTO pour les détails de création d'un disque d'amorce. Le processus
décrit s'applique aussi bien à la mise à jour d'un noyau sur le disque
d'amorce.
</p></td></tr><tr class="question"><td align="left" valign="top"><a name="id2505059"></a><a name="id2505062"></a><b>Q :</b></td><td align="left" valign="top"><p>
Comment mettre à jour ma disquette racine avec de nouveaux
fichiers ?
</p></td></tr><tr class="answer"><td align="left" valign="top"><b>R :</b></td><td align="left" valign="top"><p>
<a class="indexterm" name="id2505074"></a>
Le plus simple est de recopier le système de fichiers depuis le disque
racine vers le PÉRIPHÉRIQUE que vous avez utilisé (comme dans la
section précédente <a href="#creatingrootfs" title="4.2. Création du système de fichiers">Section 4.2, « Création du système de fichiers »</a>
). Montez ensuite le système de fichiers et modifiez-le. Vous
devez vous souvenir d'où partait votre système racine et du nombre de
blocs qu'il occupait :
</p><pre class="programlisting">
dd if=/dev/fd0 bs=1k skip=DEBUTRACINE count=BLOCS | \
        gunzip &gt; PÉRIPHÉRIQUE
mount -t ext2 PÉRIPHÉRIQUE /mnt
</pre><p>
Une fois les modifications effectuées, recommencez comme précédemment
(dans la <a href="#wrappingitup" title="4.7. C'est dans la poche">Section 4.7, « C'est dans la poche »</a>)
et retransférez le système racine sur le disque. Vous ne devriez pas
avoir à retransférer le noyau ou à recalculer le mot disque mémoire si
vous ne changez pas la position de départ du nouveau système de
fichiers.
</p></td></tr><tr class="question"><td align="left" valign="top"><a name="id2505130"></a><a name="id2505132"></a><b>Q :</b></td><td align="left" valign="top"><p>
Comment retirer <span><b class="command">LILO</b></span> pour pouvoir redémarrer DOS ?
</p></td></tr><tr class="answer"><td align="left" valign="top"><b>R :</b></td><td align="left" valign="top"><p>
<a class="indexterm" name="id2505149"></a>
<a class="indexterm" name="id2505162"></a>
Ce n'est pas réellement un problème de disque d'amorce, mais il est
souvent posé. Sous Linux, vous pouvez lancer :
</p><pre class="programlisting">
/sbin/lilo -u
</pre><p>
Vous pouvez aussi utiliser la commande <span><b class="command">dd</b></span> pour copier
la sauvegarde effectuée par <span><b class="command">LILO</b></span> sur le secteur
d'amorce. Reportez-vous à la documentation de <span><b class="command">LILO</b></span> si
vous voulez essayer.
</p><p>
Sous DOS et Windows vous pouvez utiliser la commande DOS :
</p><pre class="programlisting">
FDISK /MBR
</pre><p>
<span class="acronym">MBR</span> signifie Master Boot Record (Enregistrement
d'amorce Maître), et il remplace le secteur de démarrage avec une
version propre du <span class="acronym">DOS</span>, sans modifier la table de
partitions. Certains puristes n'apprécient pas cette méthode, mais même
l'auteur de <span><b class="command">LILO</b></span>, Werner Almesberger, le suggère.
C'est facile et ça marche.
</p></td></tr><tr class="question"><td align="left" valign="top"><a name="id2505245"></a><a name="id2505247"></a><b>Q :</b></td><td align="left" valign="top"><p>
Comment puis-je démarrer si j'ai perdu mon noyau <span class="emphasis"><em>et</em></span>
mon disque d'amorce ?
</p></td></tr><tr class="answer"><td align="left" valign="top"><b>R :</b></td><td align="left" valign="top"><p>
Si vous n'avez pas de disque d'amorce sous la main, le plus simple est
d'obtenir un noyau Slackware pour votre type de contrôleur de disque
(IDE ou SCSI) comme décrit précédemment dans « Comment faire
un disque d'amorce avec un gestionnaire pour XYZ ? ». Vous
pouvez alors démarrer votre ordinateur avec ce noyau, puis réparer les
dommages éventuels.
</p><p>
Le noyau que vous récupérerez peut ne pas avoir comme périphérique
racine ce que vous souhaitez comme disque et partition. Par exemple, le
noyau générique SCSI de Slackware utilise <tt class="filename">/dev/sda2</tt>
comme périphérique racine, alors que ma partition racine Linux se trouve
être <tt class="filename">/dev/sda8</tt>. Dans ce cas il faut changer le
périphérique racine.
</p><p>
Vous pouvez changer les paramètres de périphérique racine et disque
mémoire du noyau même si vous n'avez que le noyau, et un autre système
d'exploitation tel que DOS.
</p><p>
<span><b class="command">rdev</b></span> modifie les paramètres du noyau en changeant les
valeurs à un décalage fixé dans le fichier du noyau, et vous pouvez donc
faire de même si vous avez un éditeur hexadécimal disponible sous
quelque système d'exploitation fonctionnant encore — par exemple,
Norton Utilities Disk Editor sous DOS. Vous devez alors vérifier puis
éventuellement modifier les valeurs dans le noyau, aux décalages
suivants :
</p><pre class="programlisting">
HEX     DEC  DESCRIPTION
0x01F8  504  Octet de poids faible du mot disque mémoire
0x01F9  505  Octet de poids fort du mot disque mémoire
0x01FC  508  Numéro mineur du périphérique racine : voir ci-dessous
0X01FD  509  Numéro majeur du périphérique racine : voir ci-dessous
</pre><p>
L'interprétation du mot disque mémoire était décrite dans la
précédente <a href="#ramdiskword" title="6.3. Mise en place du mot disque mémoire">Section 6.3, « Mise en place du mot disque mémoire »</a>.
</p><p>
Les numéros majeurs et mineurs de périphérique doivent correspondre au
périphérique à partir duquel le système racine sera monté. Certaines
valeurs utiles parmi lesquelles vous pouvez choisir sont :
</p><pre class="programlisting">
DEVICE        MAJEUR MINEUR
/dev/fd0           2      0   1er lecteur de disquette
/dev/hda1          3      1   partition 1 sur le 1er disque IDE
/dev/sda1          8      1   partition 1 sur le 1er disque SCSI
/dev/sda8          8      8   partition 8 sur le 1er disque SCSI
</pre><p>
Une fois ces valeurs mises en place, vous pouvez écrire le fichier sur
une disquette en utilisant soit Norton Utilities Disk Editor, soit un
programme appelé <span><b class="command">rawrite.exe</b></span>. Ce programme est inclus
dans toutes les distributions. C'est un programme DOS qui écrit
directement un fichier sur le disque, en commençant à partir du secteur
d'amorce, au lieu de l'écrire dans le système de fichiers. Si vous
utilisez Norton Utilities, vous devez écrire le fichier sur un disque
physique en commençant au début du disque.
</p></td></tr><tr class="question"><td align="left" valign="top"><a name="id2505394"></a><a name="id2505396"></a><b>Q :</b></td><td align="left" valign="top"><p>
Comment faire des copies supplémentaires des disquettes
d'amorce/racine ?
</p></td></tr><tr class="answer"><td align="left" valign="top"><b>R :</b></td><td align="left" valign="top"><p>
Les supports magnétiques se détériorant avec le temps, vous devriez
conserver plusieurs copies de votre disque de secours, au cas où
l'original ne serait plus lisible.
</p><p>
Le plus simple pour copier une disquette quelle qu'elle soit, y compris
une disquette d'amorce ou utilitaire, est d'utiliser la commande
<span><b class="command">dd</b></span> pour copier le contenu de la disquette originale
vers un fichier de votre disque dur, puis de réutiliser la même commande
pour recopier le fichier vers une nouvelle disquette. Notez que vous
n'avez pas besoin de monter la disquette, et ne devriez pas le faire,
car <span><b class="command">dd</b></span> utilise l'interface directe du périphérique.
</p><p>
Pour copier l'original, entrez la commande :
</p><pre class="programlisting">
dd if=<i class="replaceable"><tt>NOMPÉRIPHÉRIQUE</tt></i> of=<i class="replaceable"><tt>NOMFICHIER</tt></i>
</pre><p>
où <i class="replaceable"><tt>NOMPÉRIPHÉRIQUE</tt></i> est le nom du périphérique
du lecteur de disquette et <i class="replaceable"><tt>NOMFICHIER</tt></i> le nom 
du fichier de sortie (sur le disque dur).
</p><p>
Ne pas mettre le paramètre <tt class="option">count</tt> permet à
<span><b class="command">dd</b></span> de copier la disquette en entier (2880 blocs 
en haute densité).
</p><p>
Pour recopier le fichier résultant sur une nouvelle disquette, insérez
celle-ci et entrez la commande inverse :
</p><pre class="programlisting">
dd if=<i class="replaceable"><tt>NOMFICHIER</tt></i> of=<i class="replaceable"><tt>NOMPÉRIPHÉRIQUE</tt></i>
</pre><p>
À noter que la discussion précédente suppose que vous n'avez qu'un
seul lecteur de disquette. Si vous en avez deux du même type, vous
pouvez copier les disquettes à l'aide d'une commande du type :
</p><pre class="programlisting">
dd if=/dev/fd0 of=/dev/fd1
</pre></td></tr><tr class="question"><td align="left" valign="top"><a name="id2505526"></a><a name="id2505528"></a><b>Q :</b></td><td align="left" valign="top"><p>
Comment puis-je démarrer sans avoir à taper 
« ahaxxxx=nn,nn,nn » à chaque fois ?
</p></td></tr><tr class="answer"><td align="left" valign="top"><b>R :</b></td><td align="left" valign="top"><p>
<a class="indexterm" name="id2505539"></a>
Quand un périphérique disque ne peut pas être détecté automatiquement,
il faut fournir au noyau une chaîne de paramètres de commande du
périphérique, telle que :
</p><pre class="programlisting">
aha152x=0x340,11,3,1
</pre><p>
Cette chaîne peut être fournie de différentes manières grâce à
<span><b class="command">LILO</b></span> :
</p><div class="itemizedlist"><ul type="disc"><li><p>
En l'entrant sur la ligne de commande à chaque démarrage du système avec 
<span><b class="command">LILO</b></span>. C'est assez ennuyeux ;
</p></li><li><p>
En utilisant le mot clé <span class="emphasis"><em>lock</em></span> de 
<span><b class="command">LILO</b></span> pour lui faire stocker la ligne de commande 
comme ligne de commande par défaut, ce qui fera utiliser à 
<span><b class="command">LILO</b></span> les mêmes options à chaque démarrage ;
</p></li><li><p>
En utilisant la directive <span class="emphasis"><em>append=</em></span> dans le fichier 
de configuration de <span><b class="command">LILO</b></span>. Attention à encadrer la 
chaîne de paramètres avec des guillemets.
</p></li></ul></div><p>
Par exemple, une ligne de commande utilisant la chaîne ci-dessus
serait :
</p><pre class="programlisting">
zImage aha152x=0x340,11,3,1 root=/dev/sda1 lock
</pre><p>
Cela passerait la chaîne de paramètres pour le périphérique tout en
demandant au noyau d'utiliser <tt class="filename">/dev/sda1</tt> comme
périphérique racine et de sauvegarder la ligne de commande pour la
réutiliser pour tous les démarrages futurs.
</p><p>
Un exemple de directive <span class="emphasis"><em>APPEND</em></span> peut être :
</p><pre class="programlisting">
APPEND = "aha152x=0x340,11,3,1"
</pre><p>
Attention, la chaîne de paramètres ne doit PAS être entourée de
guillemets sur la ligne de commande, mais DOIT l'être dans la
directive <span class="emphasis"><em>APPEND</em></span>.
</p><p>
Notez aussi que pour que la chaîne de paramètres soit utilisée, le noyau
doit contenir le gestionnaire pour ce type de disque. Si ce n'est pas le
cas, personne n'écoutera la chaîne de paramètres, et vous devrez
reconstruire le noyau pour inclure le gestionnaire requis. Pour plus de
détails sur la reconstruction du noyau, rendez-vous dans
<tt class="filename">/usr/src/linux</tt> et lisez le
<tt class="filename">README</tt>, ou lisez la FAQ Linux et le HOWTO
Installation. Vous pouvez aussi obtenir un noyau générique pour votre
type de disque et l'installer.
</p><p>
Il est fortement recommandé aux lecteurs de lire la documentation de
<span><b class="command">LILO</b></span> avant de faire des expériences d'installation de
<span><b class="command">LILO</b></span>. Une utilisation imprudente de la directive
<span class="emphasis"><em>BOOT</em></span> peut endommager des partitions.
</p></td></tr><tr class="question"><td align="left" valign="top"><a name="id2505738"></a><a name="id2505740"></a><b>Q :</b></td><td align="left" valign="top"><p>
Au démarrage, j'obtiens l'erreur « A: cannot execute 
B ». Pourquoi ?
</p></td></tr><tr class="answer"><td align="left" valign="top"><b>R :</b></td><td align="left" valign="top"><p>
<a class="indexterm" name="id2505750"></a>
Il existe plusieurs utilitaires qui référencent en dur le nom d'autres
programmes. Ça n'arrive pas tout le temps, mais cela peut expliquer
pourquoi un exécutable peut ne pas être trouvé sur votre système même si
vous l'y voyez. Vous pouvez vérifier si un programme donné est référencé
en dur dans un autre en utilisant la commande <span><b class="command">strings</b></span>
et en passant son résultat par <span><b class="command">grep</b></span>.
</p><p>
On trouve comme exemples connus de référence en dur :
</p><div class="itemizedlist"><ul type="disc"><li><p>
<span><b class="command">shutdown</b></span> dans certaines versions référence
<tt class="filename">/etc/reboot</tt> en dur, et <span><b class="command">reboot</b></span>
doit donc être placé dans le répertoire <tt class="filename">/etc</tt> ;
</p></li><li><p>
<span><b class="command">init</b></span> a posé des problèmes à au moins une personne,
pour qui le noyau ne trouvait pas <span><b class="command">init</b></span>.
</p></li></ul></div><p>
Pour corriger ces problèmes, vous pouvez soit déplacer les programmes
vers le répertoire attendu, soit changer les fichiers de configuration
(par exemple <tt class="filename">inittab</tt>) pour référencer le bon
répertoire. En cas de doute, mettez les programmes dans le même
répertoire que sur votre disque dur, et utilisez les mêmes fichiers
<tt class="filename">inittab</tt> et <tt class="filename">/etc/rc.d</tt> que sur
celui-ci.
</p></td></tr><tr class="question"><td align="left" valign="top"><a name="id2505871"></a><a name="id2505874"></a><b>Q :</b></td><td align="left" valign="top"><p>
Mon noyau gère les disques mémoires, mais les initialise à 0 ko
</p></td></tr><tr class="answer"><td align="left" valign="top"><b>R :</b></td><td align="left" valign="top"><p>
Quand cela arrive, un message du noyau apparaîtra au moment du
démarrage, du type :
</p><a class="indexterm" name="id2505885"></a><pre class="programlisting">
Ramdisk driver initialized : 16 ramdisks of 0K size
</pre><p>
C'est probablement parce que la taille a été fixée par les paramètres
du noyau à 0 au moment du démarrage. Cela peut être dû à un paramètre
oublié dans le fichier de configuration de <span><b class="command">LILO</b></span> :
</p><pre class="programlisting">
ramdisk= 0
</pre><p>
Certaines vieilles distributions l'incluaient dans des exemples de
fichiers de configuration de <span><b class="command">LILO</b></span>, et servaient à
écraser les paramètres antérieurs du noyau. Si vous trouvez une telle
ligne, supprimez-la.
</p><p>
Attention, si vous essayez d'utiliser un disque mémoire dont la taille
est de 0 ko, le comportement est imprévisible et peut conduire à une
panique (panic) du noyau.
</p></td></tr></tbody></table></div></div><div class="appendix" lang="fr"><h2 class="title" style="clear: both"><a name="references"></a>A. Ressources et pointeurs</h2><p>
Lorsque vous récupérez un paquetage, prenez toujours la dernière
version, sauf si vous avez de bonnes raisons pour ne pas le faire.
</p><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="distbootdisks"></a>1. Disques d'amorce préfabriqués</h2></div></div><div></div></div><p>
Ce sont les sources des disques d'amorce des distributions.
<span class="emphasis"><em>Merci d'utiliser un site miroir pour réduire la charge sur ces
machines.</em></span>
</p><div class="itemizedlist"><ul type="disc"><li><p>
<a href="http://distro.ibiblio.org/pub/Linux/distributions/slackware/slackware-current/bootdisks/" target="_top">Disques
d'amorce Slackware</a>, <a href="http://distro.ibiblio.org/pub/Linux/distributions/slackware/slackware-current/rootdisks/" target="_top">disques
racines</a> et <a href="http://www.slackware.com/getslack/" target="_top">sites
miroirs Slackware </a> ;
</p></li><li><p>
<a href="ftp://ftp.redhat.com/pub/redhat/linux/current/en/os/i386/images/" target="_top">Disques 
d'amorce RedHat</a> et <a href="http://www.redhat.com/mirrors.html" target="_top">sites miroirs Red 
Hat</a> ;
</p></li><li><p>
<a href="ftp://ftp.debian.org/debian/dists/stable/main/disks-i386/current/" target="_top">
Disques d'amorce Debian</a> et <a href="ftp://ftp.debian.org/debian/README.mirrors.html" target="_top">sites miroirs
Debian</a>.
</p></li><li><p>
<a href="http://www.linux-mandrake.com/en/ftp.php3" target="_top">Téléchargements
Mandrake</a>.
</p></li></ul></div><p>
En plus des disques d'amorce des distributions, les images de disques de
secours suivantes sont disponibles. Sauf précision contraire, elles sont
disponibles dans le répertoire <a href="http://www.ibiblio.org/pub/Linux/system/recovery/!INDEX.html" target="_top">
http://www.ibiblio.org/pub/Linux/system/recovery/!INDEX.html</a>.
</p><div class="itemizedlist"><ul type="disc"><li><p>
<span class="acronym">RIP</span> est un système de démarrage/secours qui existe en
plusieurs versions : une qui va sur une disquette de 1,44 Mo et une qui
va sur un CD-ROM. Il supporte les grands fichiers et plusieurs programmes
pour la maintenance des disques et le secours. Il supporte ext2, ext3,
iso9660, msdos, ntfs, reiserfs, ufs et vfat. RIP est disponible sur
<a href="http://www.tux.org/pub/people/kent-robotti/looplinux/rip/index.html" target="_top">http://www.tux.org/pub/people/kent-robotti/looplinux/rip/index.html</a> ;
</p></li><li><p>
<span class="acronym">tomsrtbt</span>, par Tom Oehser, est un disque
d'amorce/racine unique à base de noyau 2.0, avec de nombreux programmes
de support et fonctionnalités. Il support IDE, SCSI, les bandes, les
adaptateurs réseaux, PCMCIA et plus encore. Environ 100 programmes
utilitaires et autres outils sont inclus, pour réparer et récupérer les
disques. Le paquetage contient aussi des scripts pour désassembler et
reconstruire les images afin de pouvoir ajouter des compléments si
nécessaire ;
</p></li><li><p>
<span class="acronym">rescue02</span>, par John Comyns, est un disque de secours à
base de noyau 1.3.84, qui supporte IDE, Adaptec 1542 et NCR53C7,8xx. Il
est à base de binaires ELF mais contient suffisamment de commandes pour
être utilisé sur n'importe quel système. Certains modules peuvent être
chargés après le démarrage pour d'autres cartes SCSI. Il ne fonctionnera
probablement pas sur les systèmes avec 4 Mo de RAM car il utilise
un disque mémoire de 3 Mo ; </p></li><li><p><span class="acronym">resque_disk-2.0.22</span>, par Sergei
Viznyuk, est un disque d'amorce/racine complet basé sur le noyau 2.0.22,
comprenant le support pour IDE, de nombreux contrôleurs SCSI, et
ELF/a.out. Il contient aussi nombre de modules et d'utilitaires pour
réparer et récupérer un disque dur ;
</p></li><li><p>
les images de <span class="acronym">cramdisk</span>, à base de noyau 2.0.33,
disponibles pour machines à 4 et 8 Mo de mémoire. Elles contiennent
l'émulation mathématique et le réseau (PPP et script dialin, NE2000,
3C509), ou le support pour lecteur ZIP sur port parallèle. Ces images de
disquettes peuvent démarrer un 386 avec 4 Mo de RAM. Le support de
MSDOS est inclus, ce qui fait que vous pouvez les récupérer sur le
réseau vers une partition DOS.
</p><p>
<a href="http://www.ibiblio.org/pub/Linux/system/recovery/images" target="_top">http://www.ibiblio.org/pub/Linux/system/recovery/images</a>
</p></li></ul></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2506177"></a>2. Paquetages de secours</h2></div></div><div></div></div><p>
Plusieurs paquetages de création de disques de secours existent sur
www.ibiblio.org. Vous précisez à ces paquetages un ensemble de fichiers
à inclure, et le logiciel automatise (à divers degrés) la création d'un
disque d'amorce. Voir <a href="http://www.ibiblio.org/pub/Linux/system/recovery/!INDEX.html" target="_top">
http://www.ibiblio.org/pub/Linux/system/recovery/!INDEX.html</a>
pour plus d'informations. <span class="emphasis"><em>Vérifiez bien les dates des
fichiers</em></span> : certains paquetages n'ont pas été mis à jour
depuis des années et ne supportent pas la création d'un système racine
compressé sur disque mémoire. À notre connaissance, Yard est le seul
paquetage le permettant.
</p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2506216"></a>3. LILO : le chargeur Linux</h2></div></div><div></div></div><p>
<a class="indexterm" name="id2506224"></a> 
Écrit par Werner Almesberger. Excellent chargeur d'amorce, dont la
documentation comprend des informations sur le contenu du secteur
d'amorce et les premières étapes du processus de démarrage.
</p><p>
Ftp depuis <a href="ftp://tsx-11.mit.edu/pub/linux/packages/lilo/" target="_top">ftp://tsx-11.mit.edu/pub/linux/packages/lilo/</a>. Il est 
aussi disponible sur Metalab et ses miroirs.
</p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2506271"></a>4. Utilisation du disque mémoire</h2></div></div><div></div></div><p>
<a class="indexterm" name="id2506280"></a>
La documentation fournie avec le noyau Linux contient une excellente
description de la manière dont fonctionne le nouveau code de disque
mémoire. Voir
<tt class="filename">/usr/src/linux/Documentation/ramdisk.txt</tt>. C'est
écrit par Paul Gortmaker, et cela comprend une section sur la création d'un
disque mémoire compressé.
</p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2506323"></a>5. Le processus de démarrage de Linux</h2></div></div><div></div></div><p>
<a class="indexterm" name="id2506332"></a>
Pour plus de détails sur le processus de démarrage de Linux, voici
quelques pointeurs :
</p><div class="itemizedlist"><ul type="disc"><li><p>
Le Linux System Administrators' Guide (Guide des Administrateurs
Systèmes Linux) contient une section sur le démarrage. Voir <a href="http://www.traduc.org/docs/guides/lecture/sag/" target="_top">http://www.traduc.org/docs/guides/lecture/sag/</a> ;
</p></li><li><p>
La « Technical overview » (Description technique
succincte) de <span><b class="command">LILO</b></span> <a href="http://www.ibiblio.org/pub/Linux/system/boot/lilo/lilo-t-21.ps.gz" target="_top">http://www.ibiblio.org/pub/Linux/system/boot/lilo/lilo-t-21.ps.gz</a>
décrit d'une manière extrêmement poussée le processus de démarrage, d'un
point de vue technique et bas niveau, jusqu'au moment où le noyau est
lancé ;
</p></li><li><p>
Le code source est le guide ultime. Ci-dessous se trouvent quelques
fichiers du noyau relatifs au processus de démarrage. Si vous avez le
code source du noyau Linux, vous pouvez les trouver sous
<tt class="filename">/usr/src/linux</tt> sur votre machine ; sinon, Shigio
Yamaguchi <tt class="email">&lt;<a href="mailto:shigio%20CHEZ%20wafu%20POINT%20netgate%20POINT%20net">shigio CHEZ wafu POINT netgate POINT net</a>&gt;</tt> a
un très sympathique navigateur hypertexte pour le noyau à <a href="http://www.tamacom.com/tour/linux/index.html" target="_top">http://www.tamacom.com/tour/linux/index.html</a>. Voici 
quelques fichiers correspondants :
</p><div class="variablelist"><dl><dt><span class="term">arch/i386/boot/bootsect.S,setup.S</span></dt><dd><p>
 Contient le code assembleur pour le secteur d'amorce.
 </p></dd><dt><span class="term">arch/i386/boot/compressed/misc.c</span></dt><dd><p>
 Contient le code pour décompresser le noyau.
 </p></dd><dt><span class="term">arch/i386/kernel/</span></dt><dd><p>
 Répertoire contenant le code d'initialisation du noyau. setup.c
 contient le mot disque mémoire.
 </p></dd><dt><span class="term">drivers/block/rd.c</span></dt><dd><p>
 Contient le gestionnaire de disque mémoire. Les procédures rd_load et
 rd_load_image chargent des blocs depuis un périphérique vers un disque
 mémoire. La procédure identify_ramdisk_image détermine le type de
 système de fichiers trouvé, et s'il est compressé.
 </p></dd></dl></div></li></ul></div></div></div><div class="appendix" lang="fr"><h2 class="title" style="clear: both"><a name="id2506475"></a>B. Codes d'erreur du démarrage de LILO</h2><a class="indexterm" name="id2506482"></a><p>
Les questions sur ces erreurs sont posées si souvent sur Usenet que nous
les incluons ici en tant que service public. Ce résumé est extrait de la
Documentation Utilisateur de <span><b class="command">LILO</b></span> de Werner
Almesberger, disponible sur <a href="http://www.ibiblio.org/pub/Linux/system/boot/lilo/lilo-u-21.ps.gz" target="_top">http://www.ibiblio.org/pub/Linux/system/boot/lilo/lilo-u-21.ps.gz</a>.
</p><p>
Quand <span><b class="command">LILO</b></span> se charge, il affiche le mot
<span><b class="command">LILO</b></span>. Chaque lettre est imprimée avant ou après
l'exécution d'une action spécifique. Si <span><b class="command">LILO</b></span> échoue à
un moment donné, les lettres affichées jusque là peuvent être utilisées
pour identifier le problème.
</p><div class="variablelist"><dl><dt><span class="term">(rien)</span></dt><dd><p>
Aucun morceau de <span><b class="command">LILO</b></span> n'a été chargé. Soit
<span><b class="command">LILO</b></span> n'est pas installé, soit la partition sur
laquelle son secteur d'amorce se trouve n'est pas active.
</p></dd><dt><span class="term">L</span></dt><dd><p>
Le premier morceau du chargeur d'amorce a été chargé et démarré, mais
il ne peut charger le second morceau. Les codes d'erreur à deux
chiffres indiquent le type de problème. (Voir également la section
« Codes d'erreur disque ».) Ce cas indique en 
général une panne de périphérique ou une incohérence de géométrie (c'est 
à dire de mauvais paramètres disques).
</p></dd><dt><span class="term">LI</span></dt><dd><p>
Le premier morceau du chargeur d'amorce a pu charger le second
morceau, mais n'a pas réussi à l'exécuter. Cela peut être causé par
une incohérence de géométrie ou par le déplacement de /boot/boot.b
sans lancer l'installateur de carte.
</p></dd><dt><span class="term">LIL</span></dt><dd><p>
Le second morceau du chargeur d'amorce a été démarré, mais il ne
trouve pas la table de descripteurs dans le fichier carte. C'est en
général dû à une panne de périphérique ou une incohérence de
géométrie.
</p></dd><dt><span class="term">LIL?</span></dt><dd><p>
Le second morceau du chargeur d'amorce a été chargé à un adresse
incorrecte. C'est en général causé par une subtile incohérence de
géométrie, ou par le déplacement de <tt class="filename">/boot/boot.b</tt>
sans lancer l'installateur de carte.
</p></dd><dt><span class="term">LIL-</span></dt><dd><p>
La table de descripteurs est corrompue. Cela peut être dû à une
incohérence de géométrie ou au déplacement de
<tt class="filename">/boot/map</tt> sans lancer l'installateur.
</p></dd><dt><span class="term">LILO</span></dt><dd><p>
Tous les éléments de <span><b class="command">LILO</b></span> ont été correctement chargés.
</p></dd></dl></div><p>
Si le <span class="acronym">BIOS</span> signale une erreur lorsque
<span><b class="command">LILO</b></span> essaye de charger une image d'amorce, le code
d'erreur correspondant est affiché. Ces codes vont de
<span class="emphasis"><em>0x00</em></span> à <span class="emphasis"><em>0xbb</em></span>. Reportez-vous au
Guide Utilisateur de <span><b class="command">LILO</b></span> pour leur explication.
</p></div><div class="appendix" lang="fr"><h2 class="title" style="clear: both"><a name="listings"></a>C. Exemple de contenu de répertoires sur un disque racine</h2><p>
<a class="indexterm" name="id2506738"></a>
Voici le contenu d'un exemple de système racine et d'une disquette
utilitaire.
</p><pre class="programlisting">
 /:
 drwx--x--x   2 root     root         1024 Nov  1 15:39 bin
 drwx--x--x   2 root     root         4096 Nov  1 15:39 dev
 drwx--x--x   3 root     root         1024 Nov  1 15:39 etc
 drwx--x--x   4 root     root         1024 Nov  1 15:39 lib
 drwx--x--x   5 root     root         1024 Nov  1 15:39 mnt
 drwx--x--x   2 root     root         1024 Nov  1 15:39 proc
 drwx--x--x   2 root     root         1024 Nov  1 15:39 root
 drwx--x--x   2 root     root         1024 Nov  1 15:39 sbin
 drwx--x--x   2 root     root         1024 Nov  1 15:39 tmp
 drwx--x--x   7 root     root         1024 Nov  1 15:39 usr
 drwx--x--x   5 root     root         1024 Nov  1 15:39 var
 /bin:
 -rwx--x--x   1 root     root        62660 Nov  1 15:39 ash
 -rwx--x--x   1 root     root         9032 Nov  1 15:39 cat
 -rwx--x--x   1 root     root        10276 Nov  1 15:39 chmod
 -rwx--x--x   1 root     root         9592 Nov  1 15:39 chown
 -rwx--x--x   1 root     root        23124 Nov  1 15:39 cp
 -rwx--x--x   1 root     root        23028 Nov  1 15:39 date
 -rwx--x--x   1 root     root        14052 Nov  1 15:39 dd
 -rwx--x--x   1 root     root        14144 Nov  1 15:39 df
 -rwx--x--x   1 root     root        69444 Nov  1 15:39 egrep
 -rwx--x--x   1 root     root          395 Nov  1 15:39 false
 -rwx--x--x   1 root     root        69444 Nov  1 15:39 fgrep
 -rwx--x--x   1 root     root        69444 Nov  1 15:39 grep
 -rwx--x--x   3 root     root        45436 Nov  1 15:39 gunzip
 -rwx--x--x   3 root     root        45436 Nov  1 15:39 gzip
 -rwx--x--x   1 root     root         8008 Nov  1 15:39 hostname
 -rwx--x--x   1 root     root        12736 Nov  1 15:39 ln
 -rws--x--x   1 root     root        15284 Nov  1 15:39 login
 -rwx--x--x   1 root     root        29308 Nov  1 15:39 ls
 -rwx--x--x   1 root     root         8268 Nov  1 15:39 mkdir
 -rwx--x--x   1 root     root         8920 Nov  1 15:39 mknod
 -rwx--x--x   1 root     root        24836 Nov  1 15:39 more
 -rws--x--x   1 root     root        37640 Nov  1 15:39 mount
 -rwx--x--x   1 root     root        12240 Nov  1 15:39 mt
 -rwx--x--x   1 root     root        12932 Nov  1 15:39 mv
 -r-x--x--x   1 root     root        12324 Nov  1 15:39 ps
 -rwx--x--x   1 root     root         5388 Nov  1 15:39 pwd
 -rwx--x--x   1 root     root        10092 Nov  1 15:39 rm
 lrwxrwxrwx   1 root     root            3 Nov  1 15:39 sh -&gt; ash
 -rwx--x--x   1 root     root        25296 Nov  1 15:39 stty
 -rws--x--x   1 root     root        12648 Nov  1 15:39 su
 -rwx--x--x   1 root     root         4444 Nov  1 15:39 sync
 -rwx--x--x   1 root     root        19712 Nov  1 15:39 touch
 -rwx--x--x   1 root     root          395 Nov  1 15:39 true
 -rws--x--x   1 root     root        19084 Nov  1 15:39 umount
 -rwx--x--x   1 root     root         5368 Nov  1 15:39 uname
 -rwx--x--x   3 root     root        45436 Nov  1 15:39 zcat
 /dev:
 lrwxrwxrwx   1 root     root            6 Nov  1 15:39 cdrom -&gt; cdu31a
 brw-rw-r--   1 root     root      15,   0 May  5  1998 cdu31a
 crw-------   1 root     root       4,   0 Nov  1 15:29 console
 crw-rw-rw-   1 root     uucp       5,  64 Sep  9 19:46 cua0
 crw-rw-rw-   1 root     uucp       5,  65 May  5  1998 cua1
 crw-rw-rw-   1 root     uucp       5,  66 May  5  1998 cua2
 crw-rw-rw-   1 root     uucp       5,  67 May  5  1998 cua3
 brw-rw----   1 root     floppy     2,   0 Aug  8 13:54 fd0
 brw-rw----   1 root     floppy     2,  36 Aug  8 13:54 fd0CompaQ
 brw-rw----   1 root     floppy     2,  84 Aug  8 13:55 fd0D1040
 brw-rw----   1 root     floppy     2,  88 Aug  8 13:55 fd0D1120
 brw-rw----   1 root     floppy     2,  12 Aug  8 13:54 fd0D360
 brw-rw----   1 root     floppy     2,  16 Aug  8 13:54 fd0D720
 brw-rw----   1 root     floppy     2, 120 Aug  8 13:55 fd0D800
 brw-rw----   1 root     floppy     2,  32 Aug  8 13:54 fd0E2880
 brw-rw----   1 root     floppy     2, 104 Aug  8 13:55 fd0E3200
 brw-rw----   1 root     floppy     2, 108 Aug  8 13:55 fd0E3520
 brw-rw----   1 root     floppy     2, 112 Aug  8 13:55 fd0E3840
 brw-rw----   1 root     floppy     2,  28 Aug  8 13:54 fd0H1440
 brw-rw----   1 root     floppy     2, 124 Aug  8 13:55 fd0H1600
 brw-rw----   1 root     floppy     2,  44 Aug  8 13:55 fd0H1680
 brw-rw----   1 root     floppy     2,  60 Aug  8 13:55 fd0H1722
 brw-rw----   1 root     floppy     2,  76 Aug  8 13:55 fd0H1743
 brw-rw----   1 root     floppy     2,  96 Aug  8 13:55 fd0H1760
 brw-rw----   1 root     floppy     2, 116 Aug  8 13:55 fd0H1840
 brw-rw----   1 root     floppy     2, 100 Aug  8 13:55 fd0H1920
 lrwxrwxrwx   1 root     root            7 Nov  1 15:39 fd0H360 -&gt; fd0D360
 lrwxrwxrwx   1 root     root            7 Nov  1 15:39 fd0H720 -&gt; fd0D720
 brw-rw----   1 root     floppy     2,  52 Aug  8 13:55 fd0H820
 brw-rw----   1 root     floppy     2,  68 Aug  8 13:55 fd0H830
 brw-rw----   1 root     floppy     2,   4 Aug  8 13:54 fd0d360
 brw-rw----   1 root     floppy     2,   8 Aug  8 13:54 fd0h1200
 brw-rw----   1 root     floppy     2,  40 Aug  8 13:54 fd0h1440
 brw-rw----   1 root     floppy     2,  56 Aug  8 13:55 fd0h1476
 brw-rw----   1 root     floppy     2,  72 Aug  8 13:55 fd0h1494
 brw-rw----   1 root     floppy     2,  92 Aug  8 13:55 fd0h1600
 brw-rw----   1 root     floppy     2,  20 Aug  8 13:54 fd0h360
 brw-rw----   1 root     floppy     2,  48 Aug  8 13:55 fd0h410
 brw-rw----   1 root     floppy     2,  64 Aug  8 13:55 fd0h420
 brw-rw----   1 root     floppy     2,  24 Aug  8 13:54 fd0h720
 brw-rw----   1 root     floppy     2,  80 Aug  8 13:55 fd0h880
 brw-rw----   1 root     disk       3,   0 May  5  1998 hda
 brw-rw----   1 root     disk       3,   1 May  5  1998 hda1
 brw-rw----   1 root     disk       3,   2 May  5  1998 hda2
 brw-rw----   1 root     disk       3,   3 May  5  1998 hda3
 brw-rw----   1 root     disk       3,   4 May  5  1998 hda4
 brw-rw----   1 root     disk       3,   5 May  5  1998 hda5
 brw-rw----   1 root     disk       3,   6 May  5  1998 hda6
 brw-rw----   1 root     disk       3,  64 May  5  1998 hdb
 brw-rw----   1 root     disk       3,  65 May  5  1998 hdb1
 brw-rw----   1 root     disk       3,  66 May  5  1998 hdb2
 brw-rw----   1 root     disk       3,  67 May  5  1998 hdb3
 brw-rw----   1 root     disk       3,  68 May  5  1998 hdb4
 brw-rw----   1 root     disk       3,  69 May  5  1998 hdb5
 brw-rw----   1 root     disk       3,  70 May  5  1998 hdb6
 crw-r-----   1 root     kmem       1,   2 May  5  1998 kmem
 crw-r-----   1 root     kmem       1,   1 May  5  1998 mem
 lrwxrwxrwx   1 root     root           12 Nov  1 15:39 modem -&gt; ttyS1
 lrwxrwxrwx   1 root     root           12 Nov  1 15:39 mouse -&gt; psaux
 crw-rw-rw-   1 root     root       1,   3 May  5  1998 null
 crwxrwxrwx   1 root     root      10,   1 Oct  5 20:22 psaux
 brw-r-----   1 root     disk       1,   1 May  5  1998 ram
 brw-rw----   1 root     disk       1,   0 May  5  1998 ram0
 brw-rw----   1 root     disk       1,   1 May  5  1998 ram1
 brw-rw----   1 root     disk       1,   2 May  5  1998 ram2
 brw-rw----   1 root     disk       1,   3 May  5  1998 ram3
 brw-rw----   1 root     disk       1,   4 May  5  1998 ram4
 brw-rw----   1 root     disk       1,   5 May  5  1998 ram5
 brw-rw----   1 root     disk       1,   6 May  5  1998 ram6
 brw-rw----   1 root     disk       1,   7 May  5  1998 ram7
 brw-rw----   1 root     disk       1,   8 May  5  1998 ram8
 brw-rw----   1 root     disk       1,   9 May  5  1998 ram9
 lrwxrwxrwx   1 root     root            4 Nov  1 15:39 ramdisk -&gt; ram0
 ***  Je n'ai inclus de périphériques que pour les partitions IDE que
 ***  j'utilise. Si vous utilisez du SCSI, prenez les périphériques
 ***  /dev/sdXX à la place.
 crw-------   1 root     root       4,   0 May  5  1998 tty0
 crw-w-----   1 root     tty        4,   1 Nov  1 15:39 tty1
 crw-------   1 root     root       4,   2 Nov  1 15:29 tty2
 crw-------   1 root     root       4,   3 Nov  1 15:29 tty3
 crw-------   1 root     root       4,   4 Nov  1 15:29 tty4
 crw-------   1 root     root       4,   5 Nov  1 15:29 tty5
 crw-------   1 root     root       4,   6 Nov  1 15:29 tty6
 crw-------   1 root     root       4,   7 May  5  1998 tty7
 crw-------   1 root     tty        4,   8 May  5  1998 tty8
 crw-------   1 root     tty        4,   9 May  8 12:57 tty9
 crw-rw-rw-   1 root     root       4,  65 Nov  1 12:17 ttyS1
 crw-rw-rw-   1 root     root       1,   5 May  5  1998 zero
 /etc:
 -rw-------   1 root     root          164 Nov  1 15:39 conf.modules
 -rw-------   1 root     root          668 Nov  1 15:39 fstab
 -rw-------   1 root     root           71 Nov  1 15:39 gettydefs
 -rw-------   1 root     root          389 Nov  1 15:39 group
 -rw-------   1 root     root          413 Nov  1 15:39 inittab
 -rw-------   1 root     root           65 Nov  1 15:39 issue
 -rw-r--r--   1 root     root          746 Nov  1 15:39 ld.so.cache
 -rw-------   1 root     root           32 Nov  1 15:39 motd
 -rw-------   1 root     root          949 Nov  1 15:39 nsswitch.conf
 drwx--x--x   2 root     root         1024 Nov  1 15:39 pam.d
 -rw-------   1 root     root          139 Nov  1 15:39 passwd
 -rw-------   1 root     root          516 Nov  1 15:39 profile
 -rwx--x--x   1 root     root          387 Nov  1 15:39 rc
 -rw-------   1 root     root           55 Nov  1 15:39 shells
 -rw-------   1 root     root          774 Nov  1 15:39 termcap
 -rw-------   1 root     root           78 Nov  1 15:39 ttytype
 lrwxrwxrwx   1 root     root           15 Nov  1 15:39 utmp -&gt; ../var/run/utmp
 lrwxrwxrwx   1 root     root           15 Nov  1 15:39 wtmp -&gt; ../var/log/wtmp
 /etc/pam.d:
 -rw-------   1 root     root          356 Nov  1 15:39 other
 /lib:
 -rwxr-xr-x   1 root     root        45415 Nov  1 15:39 ld-2.0.7.so
 lrwxrwxrwx   1 root     root           11 Nov  1 15:39 ld-linux.so.2 -&gt; ld-2.0.7.so
 -rwxr-xr-x   1 root     root       731548 Nov  1 15:39 libc-2.0.7.so
 lrwxrwxrwx   1 root     root           13 Nov  1 15:39 libc.so.6 -&gt; libc-2.0.7.so
 lrwxrwxrwx   1 root     root           17 Nov  1 15:39 libcom_err.so.2 -&gt; libcom_err.so.2.0
 -rwxr-xr-x   1 root     root         6209 Nov  1 15:39 libcom_err.so.2.0
 -rwxr-xr-x   1 root     root       153881 Nov  1 15:39 libcrypt-2.0.7.so
 lrwxrwxrwx   1 root     root           17 Nov  1 15:39 libcrypt.so.1 -&gt; libcrypt-2.0.7.so
 -rwxr-xr-x   1 root     root        12962 Nov  1 15:39 libdl-2.0.7.so
 lrwxrwxrwx   1 root     root           14 Nov  1 15:39 libdl.so.2 -&gt; libdl-2.0.7.so
 lrwxrwxrwx   1 root     root           16 Nov  1 15:39 libext2fs.so.2 -&gt; libext2fs.so.2.4
 -rwxr-xr-x   1 root     root        81382 Nov  1 15:39 libext2fs.so.2.4
 -rwxr-xr-x   1 root     root        25222 Nov  1 15:39 libnsl-2.0.7.so
 lrwxrwxrwx   1 root     root           15 Nov  1 15:39 libnsl.so.1 -&gt; libnsl-2.0.7.so
 -rwx--x--x   1 root     root       178336 Nov  1 15:39 libnss_files-2.0.7.so
 lrwxrwxrwx   1 root     root           21 Nov  1 15:39 libnss_files.so.1 -&gt; libnss_files-2.0.7.so
 lrwxrwxrwx   1 root     root           14 Nov  1 15:39 libpam.so.0 -&gt; libpam.so.0.64
 -rwxr-xr-x   1 root     root        26906 Nov  1 15:39 libpam.so.0.64
 lrwxrwxrwx   1 root     root           19 Nov  1 15:39 libpam_misc.so.0 -&gt; libpam_misc.so.0.64
 -rwxr-xr-x   1 root     root         7086 Nov  1 15:39 libpam_misc.so.0.64
 -r-xr-xr-x   1 root     root        35615 Nov  1 15:39 libproc.so.1.2.6
 lrwxrwxrwx   1 root     root           15 Nov  1 15:39 libpwdb.so.0 -&gt; libpwdb.so.0.54
 -rw-r-r---   1 root     root       121899 Nov  1 15:39 libpwdb.so.0.54
 lrwxrwxrwx   1 root     root           19 Nov  1 15:39 libtermcap.so.2 -&gt; libtermcap.so.2.0.8
 -rwxr-xr-x   1 root     root        12041 Nov  1 15:39 libtermcap.so.2.0.8
 -rwxr-xr-x   1 root     root        12874 Nov  1 15:39 libutil-2.0.7.so
 lrwxrwxrwx   1 root     root           16 Nov  1 15:39 libutil.so.1 -&gt; libutil-2.0.7.so
 lrwxrwxrwx   1 root     root           14 Nov  1 15:39 libuuid.so.1 -&gt; libuuid.so.1.1
 -rwxr-xr-x   1 root     root         8039 Nov  1 15:39 libuuid.so.1.1
 drwx--x--x   3 root     root         1024 Nov  1 15:39 modules
 drwx--x--x   2 root     root         1024 Nov  1 15:39 security
 /lib/modules:
 drwx--x--x   4 root     root         1024 Nov  1 15:39 2.0.35
 /lib/modules/2.0.35:
 drwx--x--x   2 root     root         1024 Nov  1 15:39 block
 drwx--x--x   2 root     root         1024 Nov  1 15:39 cdrom
 /lib/modules/2.0.35/block:
 drwx------   1 root     root         7156 Nov  1 15:39 loop.o
 /lib/modules/2.0.35/cdrom:
 drwx------   1 root     root        24108 Nov  1 15:39 cdu31a.o
 /lib/security:
 -rwx--x--x   1 root     root         8771 Nov  1 15:39 pam_permit.so
 ***  Répertoires bases pour les montages
 /mnt:
 drwx--x--x   2 root     root         1024 Nov  1 15:39 cdrom
 drwx--x--x   2 root     root         1024 Nov  1 15:39 floppy
 /proc:
 /root:
 -rw-------   1 root     root          176 Nov  1 15:39 .bashrc
 -rw-------   1 root     root          182 Nov  1 15:39 .cshrc
 -rwx--x--x   1 root     root          455 Nov  1 15:39 .profile
 -rw-------   1 root     root         4014 Nov  1 15:39 .tcshrc
 /sbin:
 -rwx--x--x   1 root     root        23976 Nov  1 15:39 depmod
 -rwx--x--x   2 root     root       274600 Nov  1 15:39 e2fsck
 -rwx--x--x   1 root     root        41268 Nov  1 15:39 fdisk
 -rwx--x--x   1 root     root         9396 Nov  1 15:39 fsck
 -rwx--x--x   2 root     root       274600 Nov  1 15:39 fsck.ext2
 -rwx--x--x   1 root     root        29556 Nov  1 15:39 getty
 -rwx--x--x   1 root     root         6620 Nov  1 15:39 halt
 -rwx--x--x   1 root     root        23116 Nov  1 15:39 init
 -rwx--x--x   1 root     root        25612 Nov  1 15:39 insmod
 -rwx--x--x   1 root     root        10368 Nov  1 15:39 kerneld
 -rwx--x--x   1 root     root       110400 Nov  1 15:39 ldconfig
 -rwx--x--x   1 root     root         6108 Nov  1 15:39 lsmod
 -rwx--x--x   2 root     root        17400 Nov  1 15:39 mke2fs
 -rwx--x--x   1 root     root         4072 Nov  1 15:39 mkfs
 -rwx--x--x   2 root     root        17400 Nov  1 15:39 mkfs.ext2
 -rwx--x--x   1 root     root         5664 Nov  1 15:39 mkswap
 -rwx--x--x   1 root     root        22032 Nov  1 15:39 modprobe
 lrwxrwxrwx   1 root     root            4 Nov  1 15:39 reboot -&gt; halt
 -rwx--x--x   1 root     root         7492 Nov  1 15:39 rmmod
 -rwx--x--x   1 root     root        12932 Nov  1 15:39 shutdown
 lrwxrwxrwx   1 root     root            6 Nov  1 15:39 swapoff -&gt; swapon
 -rwx--x--x   1 root     root         5124 Nov  1 15:39 swapon
 lrwxrwxrwx   1 root     root            4 Nov  1 15:39 telinit -&gt; init
 -rwx--x--x   1 root     root         6944 Nov  1 15:39 update
 /tmp:
 /usr:
 drwx--x--x   2 root     root         1024 Nov  1 15:39 bin
 drwx--x--x   2 root     root         1024 Nov  1 15:39 lib
 drwx--x--x   3 root     root         1024 Nov  1 15:39 man
 drwx--x--x   2 root     root         1024 Nov  1 15:39 sbin
 drwx--x--x   3 root     root         1024 Nov  1 15:39 share
 lrwxrwxrwx   1 root     root           10 Nov  1 15:39 tmp -&gt; ../var/tmp
 /usr/bin:
 -rwx--x--x   1 root     root        37164 Nov  1 15:39 afio
 -rwx--x--x   1 root     root         5044 Nov  1 15:39 chroot
 -rwx--x--x   1 root     root        10656 Nov  1 15:39 cut
 -rwx--x--x   1 root     root        63652 Nov  1 15:39 diff
 -rwx--x--x   1 root     root        12972 Nov  1 15:39 du
 -rwx--x--x   1 root     root        56552 Nov  1 15:39 find
 -r-x--x--x   1 root     root         6280 Nov  1 15:39 free
 -rwx--x--x   1 root     root         7680 Nov  1 15:39 head
 -rwx--x--x   1 root     root         8504 Nov  1 15:39 id
 -r-sr-xr-x   1 root     bin          4200 Nov  1 15:39 passwd
 -rwx--x--x   1 root     root        14856 Nov  1 15:39 tail
 -rwx--x--x   1 root     root        19008 Nov  1 15:39 tr
 -rwx--x--x   1 root     root         7160 Nov  1 15:39 wc
 -rwx--x--x   1 root     root         4412 Nov  1 15:39 whoami
 /usr/lib:
 lrwxrwxrwx   1 root     root           17 Nov  1 15:39 libncurses.so.4 -&gt; libncurses.so.4.2
 -rw-r-r---   1 root     root       260474 Nov  1 15:39 libncurses.so.4.2
 /usr/sbin:
 -r-x--x--x   1 root     root        13684 Nov  1 15:39 fuser
 -rwx--x--x   1 root     root         3876 Nov  1 15:39 mklost+found
 /usr/share:
 drwx--x--x   4 root     root         1024 Nov  1 15:39 terminfo
 /usr/share/terminfo:
 drwx--x--x   2 root     root         1024 Nov  1 15:39 l
 drwx--x--x   2 root     root         1024 Nov  1 15:39 v
 /usr/share/terminfo/l:
 -rw-------   1 root     root         1552 Nov  1 15:39 linux
 -rw-------   1 root     root         1516 Nov  1 15:39 linux-m
 -rw-------   1 root     root         1583 Nov  1 15:39 linux-nic
 /usr/share/terminfo/v:
 -rw-------   2 root     root         1143 Nov  1 15:39 vt100
 -rw-------   2 root     root         1143 Nov  1 15:39 vt100-am
 /var:
 drwx--x--x   2 root     root         1024 Nov  1 15:39 log
 drwx--x--x   2 root     root         1024 Nov  1 15:39 run
 drwx--x--x   2 root     root         1024 Nov  1 15:39 tmp
 /var/log:
 -rw-------   1 root     root            0 Nov  1 15:39 wtmp
 /var/run:
 -rw-------   1 root     root            0 Nov  1 15:39 utmp
 /var/tmp:
</pre></div><div class="appendix" lang="fr"><h2 class="title" style="clear: both"><a name="utilitylist"></a>D. Exemple de contenu des répertoires d'un disque utilitaire</h2><a class="indexterm" name="id2507246"></a><pre class="programlisting">
 total 579
 -rwxr-xr-x   1 root     root        42333 Jul 28 19:05 cpio
 -rwxr-xr-x   1 root     root        32844 Aug 28 19:50 debugfs
 -rwxr-xr-x   1 root     root       103560 Jul 29 21:31 elvis
 -rwxr-xr-x   1 root     root        29536 Jul 28 19:04 fdisk
 -rw-r-r---   1 root     root       128254 Jul 28 19:03 ftape.o
 -rwxr-xr-x   1 root     root        17564 Jul 25 03:21 ftmt
 -rwxr-xr-x   1 root     root        64161 Jul 29 20:47 grep
 -rwxr-xr-x   1 root     root        45309 Jul 29 20:48 gzip
 -rwxr-xr-x   1 root     root        23560 Jul 28 19:04 insmod
 -rwxr-xr-x   1 root     root          118 Jul 28 19:04 lsmod
 lrwxrwxrwx   1 root     root            5 Jul 28 19:04 mt -&gt; mt-st
 -rwxr-xr-x   1 root     root         9573 Jul 28 19:03 mt-st
 lrwxrwxrwx   1 root     root            6 Jul 28 19:05 rmmod -&gt; insmod
 -rwxr-xr-x   1 root     root       104085 Jul 28 19:05 tar
 lrwxrwxrwx   1 root     root            5 Jul 29 21:35 vi -&gt; elvis
</pre></div><div class="footnotes"><br><hr width="100" align="left"><div class="footnote"><p><sup>[<a name="ftn.id2498799" href="#id2498799">1</a>] </sup>
La structure de répertoires présentée ici concerne une disquette racine
seule.  Les vrais systèmes Linux obéissent à un ensemble de règles bien plus
complexes et contrôlées, appelé le <a href="http://www.pathname.com/fhs/2.2/" target="_top">Filesystem Hierarchy 
Standard</a>, pour déterminer où les fichiers doivent aller.
</p></div></div></div></body></html>
