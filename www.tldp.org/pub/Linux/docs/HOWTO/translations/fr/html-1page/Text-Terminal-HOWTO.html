<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.21">
 <TITLE>HOWTO Terminal Texte pour Linux</TITLE>
</HEAD>
<BODY>
<H1>HOWTO Terminal Texte pour Linux</H1>

<H2>David S. Lawyer 
<A HREF="mailto:bf347@lafn.org">mailto:bf347@lafn.org</A>, traduit par
Julien Garnault 
<A HREF="mailto:judge@club-internet.fr">mailto:judge@club-internet.fr</A></H2>v1.09, 28 Novembre 1999
<HR>
<EM>Ce document explique ce que sont les terminaux en mode texte, comment ils
fonctionnent, comment les installer et les configurer, et fournit des
informations sur la manière de les réparer. Cela peut être utile même si vous
n'avez pas le manuel du terminal. Bien qu'il soit écrit pour de vrais
terminaux reliés à un système Linux, certaines informations de ce manuel sont
applicables à l'émulation de terminal et peuvent être utiles pour des
systèmes différents de Linux.</EM>
<HR>
<H2><A NAME="intro"></A> <A NAME="s1">1. Introduction</A></H2>

<P>Pour tenter d'installer un terminal rapidement, voyez 
<A HREF="#quick_install">installation rapide</A>.</P>

<H2><A NAME="ss1.1">1.1 Copyright, marques déposées, avertissement et crédits</A>
</H2>



<H3>Copyright</H3>


<P>Copyright 1998-9 par David S. Lawyer.
Veuillez copier et distribuer librement ce document (par la vente ou le don).
Contactez le mainteneur pour les corrections et les changements mineurs.
Sinon, vous pouvez créer et distribuer des travaux dérivés à la condition que
vous :</P>
<P>
<OL>
<LI>envoyez le travail dérivé (dans le format le plus adapté, en sgml par
exemple) au LDP (Linux Documentation Project) ou un equivalent pour poster 
sur internet. Si ce n'est pas le LDP, dites au LDP ou il est trouvable. A 
part pour une traduction, envoyez une copie a l'url precedente du mainteneur
donnée dans la derniere version.
</LI>
<LI>donniez une licence au travail dans l'esprit de cette licence, ou que
vous utilisiez la GPL. Incluez une notice concernant le copyright et au moin
un pointeur vers la licence utilisée.
</LI>
<LI>donniez un crédit total aux précédent auteurs et contributeurs majeurs.</LI>
</OL>
</P>
<P>Si vous considerez faire un travail dérivé autre qu'une traduction, il est 
requis d'en discuter avec le mainteneur courant.</P>

<H3>Avertissement</H3>


<P>Bien que je n'ai pas tenté de vous induire sciemment en erreur, il y a
sûrement un certain nombre d'erreurs dans ce document. Veuillez me les
signaler. Puisque c'est une documentation libre, il devrait être évident que
je ne peux pas être tenu légalement responsable des erreurs commises.</P>

<H3>Marques déposées</H3>


<P>Si certains mots représentent des marques déposées, le contexte devrait
indiquer clairement à qui elles appartiennent. Par exemple, "MS Windows NT"
implique que "Windows NT" appartient à Microsoft (MS). Mac est fabriqué par
Apple Computer. Les marques déposées appartiennent à leurs propriétaires
respectifs.</P>

<H3>Crédits</H3>


<P>La majeure partie de la section "Connexion physique" provient du Howto Serial
v.&nbsp;1.11 de Greg Hankins (avec sa permission). Sa partie&nbsp;: "Comment 
configurer un terminal connecté à mon PC&nbsp;?" a été incorporée dans la 
version 1.00 en des endroits variés. v1.09 a 25 changements (et corrections
d'erreurs) suggérés par Alessandro Rubini qui a passé en revu ce HOWTO.</P>
<P>Pour la traduction en français, j'aimerais remercier Xavier Glattard, qui a
entrepris le début de la traduction et que j'ai reprise en cours ; ainsi que
Guillaume Allègre et Jean-Luc Cassel qui ont fait un énorme travail de
relecture.</P>
<P>Pour ma part (Julien Garnault) Je remercie Olivier Tharan qui a fait du très
bon travail. Ce qui m'a permis de reprendre ce HOWTO sans trop de problemes.</P>

<H2><A NAME="ss1.2">1.2 Plans pour l'avenir : vous pouvez m'aider</A>
</H2>


<P>Veuillez me signaler toute erreur dans les faits, les opinions, la logique,
l'orthographe, la grammaire, la clarté, les liens, etc. Mais d'abord, si la
date est vieille de plus de quelques mois, vérifiez que vous avez la dernière
version. Veuillez m'envoyer toutes les informations que vous pensez être
pertinentes pour ce document. [ NdT : cela s'applique aussi pour la version
française ! ]</P>
<P>À partir de la version 1.00, j'ai tenté pour la première fois d'aider les
gens à configurer des terminaux sans recourir à un manuel de terminal. Il en
faudrait bien plus à cet égard. Une manière de résoudre ce problème serait
que les fabricants de terminaux mettent leurs manuels sur Internet. Je vous
suggère de les encourager à le faire. Fournir des informations sur la
configuration de la plupart des terminaux dans ce HOWTO est une tâche
décourageante. Il y a beaucoup de terminaux différents, mais il y a bien
moins de modèles qu'il n'y en avait dans les années 1980, la tâche n'est donc
pas totalement impossible à réaliser.</P>
<P>Veuillez m'envoyer tous les manuels de terminaux que vous pourriez avoir en
trop, surtout sur les terminaux fabriqués dans les dix dernières années (mais
j'accepterai aussi les manuels plus anciens). De plus, vous pourriez écrire
quelque chose sur un certain type de terminal pour l'annexe D : Notes par nom
de marque.</P>

<H2><A NAME="ss1.3">1.3 Nouvelles versions de ce HOWTO</A>
</H2>


<P>Les nouvelles versions du HOWTO seront disponibles à la navigation Internet
et au téléchargement sur les sites miroirs du LDP (Linux Documentation
Project). Voyez 
<A HREF="http://metalab.unc.edu/LDP/mirrors.html">http://metalab.unc.edu/LDP/mirrors.html</A> pour
avoir une liste de ces miroirs. Divers formats sont disponibles. Si vous
voulez chercher rapidement la date de la dernière version, allez à 
<A HREF="http://metalab.unc.edu/LDP/HOWTO/Text-Terminal-HOWTO.html">http://metalab.unc.edu/LDP/HOWTO/Text-Terminal-HOWTO.html</A>. (NdT : le
miroir officiel en France est 
<A HREF="http://www.freenix.org/unix/linux/HOWTO/Text-Terminal-HOWTO.html">http://www.freenix.org/unix/linux/HOWTO/Text-Terminal-HOWTO.html</A>.)</P>

<H2><A NAME="related_howtos"></A> <A NAME="ss1.4">1.4 HOWTOs connexes</A>
</H2>


<P>
<UL>
<LI>Le HOWTO Serial possède des informations sur les cartes série
multiports utilisées à la fois pour les terminaux et les racks de modems. Il
possède des informations techniques sur le port série, notamment pour le
dépanner.</LI>
<LI>Le HOWTO Modem</LI>
<LI>Le HOWTO Serial-Programming</LI>
<LI>Le HOWTO Xterminal (non maintenu). Il se trouve à 
<A HREF="http://metalab.unc.edu/pub/Linux/docs/HOWTO/unmaintained/mini/Xterminal">http://metalab.unc.edu/pub/Linux/docs/HOWTO/unmaintained/mini/Xterminal</A></LI>
</UL>
</P>

<H2><A NAME="ss1.5">1.5 Terminologie utilisée dans ce document</A>
</H2>


<P>Configuration veut dire la même chose que mise en place (NdT : j'ai utilisé
le mot "configuration" tout au long du document). Alors que les commandes
Linux possèdent des options (avec le symbole -), les options dans un sens
plus vaste sont d'autres types de choix. L'installation au sens large
comprend la configuration du matériel et du logiciel. Une affirmation que je
pense être vraie (mais qui peut ne pas l'être) se termine par deux points
d'interrogation : ?? Si vous êtes sûr de l'affirmation, dites-le moi.</P>

<H2><A NAME="ss1.6">1.6 Qu'est-ce qu'un terminal ?</A>
</H2>


<P>Un terminal consiste en un écran et un clavier qu'on utilise pour communiquer
à distance avec un ordinateur (hôte). On l'utilise comme s'il s'agissait d'un
ordinateur personnel mais le terminal est éloigné de l'ordinateur hôte (à
l'autre bout de la pièce ou même à l'autre bout du monde). Les programmes
s'exécutent sur l'ordinateur hôte mais les résultats s'affichent sur l'écran
du terminal. Sa capacité de calcul est relativement faible (sinon ce serait
un ordinateur et non un terminal). Cette capacité de calcul est en général
limitée à la capacité d'afficher ce qu'on lui envoie (il est possible que
ceci comprenne des graphiques plein écran) et la capacité d'envoyer à l'hôte
ce qui est tapé au clavier.</P>
<P>Dans les temps éloignés des gros ordinateurs, du milieu des années 1970 au
milieu des années 1980, la plupart des gens utilisaient des terminaux pour
communiquer avec les ordinateurs. Ils y tapaient des programmes, les
faisaient tourner, écrivaient des documents, envoyaient des commandes
d'impression, etc. Un câble reliait le terminal à l'ordinateur (souvent de
manière indirecte). On l'appelait terminal puisqu'il était situé à une
extrémité terminale de ce câble.</P>
<P>Si vous utilisez Linux (sauf pour une utilisation avec X Window) avec un
moniteur et un clavier vous savez déjà ce qu'est un terminal parce que vous
en utilisez un (ou plus précisément un "terminal virtuel"). Le moniteur (avec
le clavier) s'appelle console, mais il émule un terminal. Dans X Window :
xterm, rxvt et zterm émulent des terminaux.</P>
<P>Un vrai terminal est différent d'un moniteur parce que c'est un montage
électronique différent. Un terminal texte est souvent relié au port série de
l'ordinateur par l'intermédiaire d'un long câble. Ainsi, contrairement à un
moniteur qui est le plus souvent situé juste à côté de l'ordinateur, un
terminal peut se situer à une distance assez grande de son ordinateur hôte.
La carte vidéo à l'intérieur d'un ordinateur stocke l'image vidéo qui
apparaît sur l'écran du moniteur. Pour un terminal, l'équivalent de cette
carte vidéo est construite à l'intérieur même du terminal mais puisque les
terminaux texte sont souvent monochromes sans beaucoup de graphiques, les
capacités de cette "carte vidéo" sont plutôt faibles. De plus, la plupart des
terminaux texte n'ont pas de souris.</P>
<P>Dans la terminologie client-serveur en réseau, on pourrait penser que le
terminal est le client et l'ordinateur hôte le serveur. Certains ont appelé
le terminal un "client léger". Mais ce n'est pas vraiment un "client" et
l'hôte n'est pas vraiment un "serveur". Le seul "service" fourni par l'hôte
est de recevoir chaque lettre tapée au clavier et de réagir à ceci comme un
ordinateur le ferait. Le terminal ressemble à une fenêtre donnant sur
l'ordinateur comme l'est un moniteur (et son clavier).  Vous avez sûrement
déjà utilisé des terminaux virtuels dans Linux (en pressant Alt(gauche)-F2, 
etc.). Un vrai terminal est la même chose que lancer un terminal virtuel 
mais vous le lancez sur l'écran du terminal plutôt que de partager le 
moniteur. Par rapport à l'utilisation d'un terminal virtuel sur la console 
(moniteur), ceci permet à une autre personne de s'asseoir devant le terminal 
réel et d'utiliser l'ordinateur en même temps que d'autres personnes.</P>

<H2><A NAME="s2">2. Types de terminaux</A></H2>



<H2><A NAME="ss2.1">2.1 Terminaux passifs</A>
</H2>


<P>Il y a plusieurs définitions contradictoires pour un "terminal passif" mais à
mesure que le temps passe, de plus en plus de terminaux sont appelés passifs.
Ce document couvre principalement les terminaux texte qui n'affichent que du
texte à l'écran. On pourrait l'appeler "HOWTO Terminaux Passifs" mais dans
certains articles de magazine, tout terminal, quelle que soit son
intelligence, même ceux qui présentent une interface graphique complète
(GUI), sont appelés passifs. Si tous les terminaux sont "passifs" il n'y a
plus de raison d'ajouter le mot "passif" derrière le mot terminal (sauf dans
un baratin commercial pour vendre des ordinateurs ou similaires en tant que
terminaux "intelligents"). À cause de la signification ambiguë de "terminal
passif", ce n'est pas considéré ici comme un type de terminal.</P>

<H2><A NAME="ss2.2">2.2 Terminaux texte</A>
</H2>


<P>Pour un terminal texte, un flux d'informations à double sens entre
l'ordinateur et le terminal se forme sur le câble les reliant tous les deux.
Ce flux est constitué d'octets ASCII où chaque octet représente généralement
un caractère.  Les octets tapés au clavier vont vers l'ordinateur et la
plupart des octets venant de l'ordinateur sont affichés sur l'écran du
terminal. Des octets spéciaux (ou des séquences d'octets) de l'ordinateur
indiquent au terminal où déplacer le curseur, ce qu'il faut effacer, où
démarrer et arrêter le soulignement et/ou le clignotement et/ou le gras, etc.
Il y a souvent des centaines de commandes spéciales et beaucoup de terminaux
peuvent même changer leur police.</P>
<P>La communication utilise des caractères (lettres) encodées avec un tableau de
codes correspondant au jeu de caractères en cours d'utilisation. En général,
les 128 premiers octets sur les 256 octets possibles utilisent les codes
ASCII. Les terminaux pour des systèmes de type Unix sont normalement
connectés aux ordinateurs par un câble qui se déroule entre les ports série
asynchrones (RS-232-C = EIA-232-D) de l'ordinateur hôte et du terminal.
Quelquefois la connexion se fait par modem ou grâce à un serveur de
terminaux, etc.</P>
<P>D'autres noms pour les terminaux texte sont "terminal série", "terminal à
cellule de caractère", "terminal ASCII/ANSI", "terminal asynchrone",
"terminal de données", "terminal vidéo" et "terminal d'affichage vidéo"
(VDT). Dans les jours anciens, "unité d'affichage vidéo" (VDU) était utilisé
pour les terminaux mais en toute rigueur, ceci exclut le clavier.</P>
<P>Le "mode par blocs" était exclusivement utilisé par les vieux terminaux des
minis IBM mais beaucoup de terminaux modernes possèdent aussi cette capacité
(qui n'est pas beaucoup utilisée). Les caractères que vous tapez sont retenus
temporairement dans la mémoire du terminal (et peuvent parfois être édités
grâce à un éditeur résidant dans le terminal). Alors quand la touche envoi
(ou autre) est pressée, un bloc de caractères (parfois juste une ligne de
caractères) est envoyé tout d'un coup à l'ordinateur. Le mode par blocs (à la
fin 1998) n'est pas supporté par Linux. Voyez la section 
<A HREF="#block">mode par blocs</A>.</P>

<H2><A NAME="ss2.3">2.3 Terminaux graphiques</A>
</H2>


<P>Jusqu'à un certain degré certains symboles ASCII peuvent fournir du graphisme
aux terminaux texte. On peut faire des flèches &lt;--- et dessiner des boîtes
avec _ et |. Avec des ensembles spéciaux de caractères graphiques, on peut en
faire encore plus. Aucun de ceux-ci ne sont vraiment des terminaux
graphiques.  Cependant, le terme "terminal graphique" est quelquefois donné à
tous les terminaux texte puisque le texte est une forme limitée de
graphique.
<A NAME="vector_graphics"></A> </P>
<P>Il y a deux types de base pour l'affichage graphique : rastérisé et vectorisé
(rarement utilisé). Les graphiques rastérisés (en mode point par point)
affichent des points sur l'écran sur des lignes de balayage horizontal par
l'intermédiaire d'un faisceau d'électrons (ou en activant des pixels ou
points sur un écran plat). Les affichages à graphisme vectoriel sont
généralement destinés à des écrans monochromes qui n'ont pas de points. Ils
utilisent une électronique intelligente pour tracer des lignes et des courbes
avec un faisceau d'électrons qui peut se déplacer dans n'importe quelle
direction (à tout endroit et avec tout angle).  Les graphiques vectoriels
affichent des lignes de grande qualité sans zigzags mais sont à la fois rares
et chers. Les graphiques rastérisés sont utilisés de manière
quasi-universelle de nos jours. Pour les PC, les images codées en format
graphique vectoriel sont quelquefois utilisées mais sont traduites en format
graphique rastérisé pour l'affichage (avec une baisse de qualité pour
l'image).</P>

<H3>Terminaux graphiques sur ligne série</H3>


<P>La plus grande partie de ce document s'applique aussi à ceux-ci. La plupart
de ceux-ci peuvent aussi fonctionner comme des terminaux texte. Les
protocoles pour de tels terminaux graphiques sont : Tektronix Vector
Graphics, ReGIS (DEC), Sixel (DEC) et NAPLPS (North American Presentation
Level Protocol Syntax, syntaxe de protocole au niveau présentation d'Amérique
du Nord).</P>

<H3>Terminaux graphiques rapides (d'autres noms leur sont souvent donnés)</H3>


<P>Ceux-ci ne sont pas couverts par ce document. Un terminal qui mérite qu'on
l'appelle intelligent est un terminal graphique qui peut afficher rapidement
des graphiques plein écran comme un moniteur de PC. Il aura aussi une souris.
Les octets qu'on lui envoie représentent souvent des bits pour des images (et
souvent des graphiques). Il utilisera souvent une connexion à grande vitesse
vers son ordinateur hôte en utilisant de la paire torsadée ou un câble
coaxial. Les terminaux X Window font partie de ces modèles. Voyez le lien
vers le HOWTO XTerminal référencé en 
<A HREF="#related_howtos">HOWTOs connexes</A></P>
<P>Pour afficher une interface graphique MS-Windows il y a plusieurs types
d'interfaces et de terminaux : WinTerm en est un, il utilise le logiciel
WinFrame de Citrix. Un autre est Hydra de Microsoft (nom de code), basé en
partie sur le code de Citrix, aussi connu comme "Serveur de Terminal Windows"
qui fonctionne avec la version 4 ou supérieure de Windows NT. Citrix utilise
son protocole ICA et a créé un supplément à Hydra nommé pICAsso pour que les
terminaux WinFrame (ICA) puissent utiliser le système ICA. Hydra est aussi
multi-utilisateurs. Il y a aussi le "Terminal Personnel Multiconsole" de
Unbounded Technologies et Tektronix possédait son interface
multi-utilisateurs mais supportera désormais Hydra. Un article de magazine en
1997 a appelé Winterm un "terminal passif" mais il est vraiment intelligent.
De tels terminaux sont souvent appelés "clients légers", mais certains
clients légers sont plus que de simples terminaux puisqu'on peut leur faire
exécuter du code Java, etc.</P>

<H2><A NAME="ss2.4">2.4 Network Computers (NC, ordinateurs de réseau)</A>
</H2>


<P>Ce ne sont ni de vrais ordinateurs ni de vrais terminaux mais quelque chose
entre les deux. Un type de Network Computers (NC) est un ordinateur avec un
processeur mais pas de disque dur.  Il est entièrement graphique et se
connecte à un ordinateur serveur. Il est différent d'un terminal puisque le
programme qu'il fait tourner s'exécute sur son propre processeur. Du code
Java peut lui être envoyé pour être exécuté. IBM appelle ceci une "station
réseau" (Network Station). Ils devraient fonctionner sur des réseaux IP et
pourraient fonctionner avec un serveur sous Linux. Wintel a fabriqué un
"NetPC" qui, à la différence du NC, est presque un ordinateur PC. Cependant,
il n'a pas de disque amovible et les utilisateurs ne peuvent pas installer
leur propre logiciel ou obtenir des copies de quoi que ce soit.</P>
<P>Bien que les promoteurs des NCs et des terminaux graphiques similaires aient
prévu de remplacer des millions de PCs, cela n'est pas encore arrivé. L'une
des raisons principales est que les PCs ont vu leurs prix chuter dans les
dernières années et sont souvent moins chers que les NCs. Ainsi pour les
terminaux, les terminaux texte sont encore prédominants.</P>

<H2><A NAME="ss2.5">2.5 Émulation sur un PC</A>
</H2>


<P>Puisqu'un PC possède un écran et un clavier (comme un terminal) mais possède
aussi plus de puissance de calcul, il est facile d'utiliser une partie de
cette puissance de calcul pour que le PC se comporte comme un terminal texte.
C'est ce que l'on appelle "l'émulation de terminal". Ils émulent en général
des terminaux texte.  Voyez 
<A HREF="#term_emulation">émulation de terminal</A></P>

<H2><A NAME="quick_install"></A> <A NAME="s3">3. Installation rapide</A></H2>


<P>Voici une procédure rapide pour installer un terminal sans passer par une
procédure de 
<A HREF="#setup_">mise en place</A> à la fois pour le terminal
et l'ordinateur hôte. Cela ne fonctionnera probablement pas bien s'il se
trouve que le terminal a été configuré de manière incompatible avec
l'ordinateur. Si vous ne comprenez pas tout ceci vous devrez consulter
d'autres parties de ce document pour plus d'informations.</P>
<P>Pour installer un terminal, regardez d'abord dans <CODE>/etc/termcap</CODE> ou
<CODE>terminfo.src</CODE> pour y trouver une entrée le concernant (voir 
<A HREF="#termcap2">terminfo et termcap (détaillé)</A>). Déterminez sur quel
port série vous le brancherez et quelle est le nom tty pour ce port (par
exemple, <CODE>ttyS1</CODE>, voyez 
<A HREF="#dev_names">noms de périphériques</A>).  En tant qu'utilisateur root, éditez <CODE>/etc/inittab</CODE>
et ajoutez une commande getty à côté des autres commandes getty. Le format de
la commande getty dépend du programme getty que vous utilisez. <CODE>agetty</CODE>
(simplement appelé <CODE>getty</CODE> dans la distribution Debian) est le plus simple
(pas de fichier de configuration). Voyez le fichier "<CODE>info</CODE>" ou la page de
manuel de getty.  Pour les paramètres de getty, utilisez le nom terminfo (ou
termcap) de votre terminal, comme vt100. Entrez une vitesse de transmission
supportée par le terminal. Si vous mettez la vitesse trop haut vous aurez
peut-être besoin d'utiliser le 
<A HREF="#flow_control">contrôle de flux</A>.</P>
<P>Connectez alors physiquement le port série principal du terminal au port
série choisi de l'ordinateur avec un câble null-modem et allumez le terminal.
N'espérez pas que la plupart des câbles tout prêts soient câblés correctement
pour gérer le contrôle de flux matériel. Assurez-vous que la vitesse de
transmission du terminal est la même que celle que vous avez donnée à getty
et que son paramètre "bits de données" est 8.  Alors, sur la console de
l'ordinateur tapez "init q" pour faire prendre en compte les changements que
vous avez faits au fichier inittab. Vous devriez maintenant voir une invite
de login sur le terminal. Sinon, appuyez sur la touche retour chariot du
terminal. Si cela ne fonctionne pas, continuez de lire ce document et/ou
voyez 
<A HREF="#trouble-shoot">régler les problèmes</A>.</P>

<H2><A NAME="s4">4. Pourquoi utiliser un terminal ?</A></H2>



<H2><A NAME="ss4.1">4.1 Introduction sur le fait d'utiliser un terminal</A>
</H2>


<P>Les PC sont de nos jours si puissants qu'un seul PC peut souvent supporter
plusieurs personnes à la fois en train de l'utiliser, surtout s'ils exécutent
des tâches faibles en charge telles que l'édition de texte, l'entrée de
données, etc. Une manière de faire ceci est de relier un certain nombre de
terminaux à un seul PC (ordinateur hôte) par l'intermédiaire de modems ou de
connexions directes par câble. Pour ce faire, il est mieux d'avoir un système
d'exploitation multi-utilisateurs tel que Linux, comma ca chaque utilisateur
sur un terminal peut utiliser l'ordinateur independemment. On a appelé cela 
le "partage de temps" (time sharing) mais ce n'est pas une terminologie 
correcte de nos jours puisque l'informatique "distribuée" sur un réseau est 
aussi une sorte de partage de temps. On pourrait mieux le décrire comme de 
l'informatique "centralisée". Mais l'ordinateur central peut être connecté au 
reste du monde par un réseau afin que les utilisateurs des terminaux puissent 
envoyer du courrier électronique, naviguer sur Internet avec le navigateur 
"lynx", etc. Ce n'est donc pas vraiment "centralisé" non plus.</P>
<P>On a rarement utilisé des terminaux avec des PC parce que les systèmes
d'exploitation populaires qui les ont utilisés (Windows, DOS et Mac) n'ont
pas été multi-utilisateurs jusqu'en 1998 (c'est le cas pour MS Windows NT) et
ne pouvaient pas auparavant tres bien accepter de terminaux. Maintenant que 
Linux, système d'exploitation multi-utilisateurs, est disponible pour les PC,
l'utilisation de terminaux avec des PC devient envisageable. L'inconvénient
est que les terminaux texte ne sont pas assez perfectionnés pour supporter le
type d'interface graphique utilisateur (GUI) que bien des utilisateurs
d'ordinateur attendent de nos jours.</P>

<H2><A NAME="ss4.2">4.2 Une réduction du coût du matériel ?</A>
</H2>


<P>Quand les ordinateurs (même les PCs) étaient relativement chers,
l'utilisation de terminaux tirait les coûts du matériel vers le bas de
manière significative. Maintenant, avec les PCs bon marché, les économies sur
les coûts sont un problème. Voici ce que j'ai écrit il y a des années quand
les PCs étaient plus chers. C'est encore vrai maintenant, mais d'une moindre
mesure.</P>
<P>Si plusieurs personnes utilisent le même ordinateur en même temps, il y a une
diminution de la quantité de matériel nécessaire pour le même niveau de
service. Une façon de faire des économies est due au partage du code. Les
fichiers des applications sur les disques durs sont partagés, de même que les
bibliothèques partagées en mémoire (même si les gens font tourner des
programmes différents, à condition qu'ils utilisent certaines fonctions
identiques dans leur code). Une autre façon d'économiser est due à la
réduction du pic de charge. Le matériel d'un seul PC peut être inactif la
plupart du temps pendant que les gens entrent les informations lentement,
réfléchissent, discutent ou s'éloignent de leur bureau. Avoir plusieurs
personnes sur le même ordinateur à la fois fait bon usage d'une bonne partie
de ce temps d'inactivité qui, sinon, serait gâché.</P>
<P>Ces économies sont substantielles. On peut estimer grossièrement (en
utilisant la théorie des statistiques) que pour neuf personnes (huit
terminaux et une console), le PC partagé n'a besoin que d'environ trois fois
plus de capacité (en mémoire, espace disque, puissance processeur, etc.)
qu'un PC unique afin de fournir le même niveau de service par personne. Le
coût par utilisateur du matériel de calcul pour un tel système partagé
devrait donc être trois fois moindre. Cependant, le coût du système
d'affichage (écrans, claviers, électronique vidéo, etc.) est à peu près le
même dans les deux cas.  Les terminaux induisent cependant un surcoût :
l'équipement de l'ordinateur hôte avec des ports série supplémentaires.</P>
<P>Pour faire une comparaison honnête avec les PC, les terminaux devraient avoir
les mêmes capacités que les moniteurs de PC. Malheureusement, les terminaux
graphiques couleur pour Linux (X Window) avec des communications à grande
vitesse est un marché de niche avec des prix élevés, et par conséquent dans
ce cas les économies en coût de matériel risquent d'être inexistantes. Pour
les terminaux texte, par contre, on fera des économies, surtout si on obtient
les terminaux à bas prix.</P>

<H2><A NAME="ss4.3">4.3 Contrôle des logiciels</A>
</H2>


<P>En informatique centralisée, les logiciels (et les mises à jour des
logiciels) ne doivent être installés que sur un seul ordinateur hôte au lieu
de plusieurs. La personne qui s'occupe de cet ordinateur peut contrôler les
logiciels qui y sont installés. Ceci est avantageux si la personne qui
contrôle l'ordinateur hôte fait du bon travail et connaît les besoins et
préférences des autres utilisateurs. On peut empêcher les utilisateurs de
jouer à des jeux ou de naviguer sur Internet en n'installant pas les
logiciels (ou bien en en restreignant l'accès). Que le contrôle centralisé
soit désirable ou non dépend de chaque situation.</P>

<H2><A NAME="ss4.4">4.4 Mises à jour du matériel</A>
</H2>


<P>Avec les terminaux, les mises à jour du matériel de l'ordinateur ne prennent
place que sur un ordinateur au lieu de plusieurs. Ceci économise un effort
d'installation. Alors que le coût du matériel pour la mise à jour de
l'ordinateur hôte sera plus important que pour un PC simple (puisque l'hôte a
besoin de plus de puissance de calcul qu'un PC), le coût sera bien moindre
que de mettre à jour le materiel d'un nombre de PC qu'on utiliserait à la 
place des terminaux.</P>

<H2><A NAME="ss4.5">4.5 Autres avantages des terminaux</A>
</H2>


<P>
<UL>
<LI>L'élimination du bruit des ventilateurs et des disques durs, à
condition que les terminaux ne soient pas proches de l'ordinateur.</LI>
<LI>Les utilisateurs des terminaux peuvent partager des données et des
fichiers et peuvent s'envoyer du courrier électronique. C'est la même chose
qu'un réseau local.</LI>
</UL>
</P>

<H2><A NAME="ss4.6">4.6 Désavantages majeurs des terminaux</A>
</H2>


<P>
<UL>
<LI>Les terminaux texte ne disposent pas d'affichage graphique rapide (ou
de graphiques haute résolution) bien qu'ils utilisent souvent des jeux de
caractères graphiques pour dessiner des boîtes, etc. Ce manque limite les
logiciels qu'on peut utiliser dessus.</LI>
<LI>Si l'ordinateur hôte s'arrête, plus personne ne peut utiliser les
terminaux non plus (sauf si on peut se connecter sur un ordinateur hôte qui
attend cela).</LI>
</UL>
</P>

<H2><A NAME="ss4.7">4.7 Les terminaux texte sont-ils obsolètes ?</A>
</H2>


<P>Les terminaux texte représentent une technologie obsolète parce que pour un
matériel légèrement plus cher, on pourrait construire un terminal intelligent
(avec la même qualité d'affichage). Ceci n'a pas toujours été le cas puisque
aux alentours de 1980 la mémoire coûtait des milliers de francs par
méga-octet. Maintenant avec de la mémoire et des processeurs à bas prix, on
pourrait faire un terminal texte intelligent pour une augmentation du coût du
matériel de seulement 10 à 20 %.</P>
<P>Les raisons pour lesquelles les terminaux texte ne sont pas encore obsolètes
sont :</P>
<P>
<UL>
<LI>Il n'y a pas d'interface normalisée satisfaisante pour des terminaux
graphiques intelligents. Le système MS Hydra fonctionne avec Windows NT,
alors que X Window n'est pas aussi efficace qu'il devrait être (et les
terminaux X Window sont trop chers).</LI>
<LI>Beaucoup de gens n'ont pas besoin de graphiques plein écran.</LI>
<LI>Les terminaux texte sont peu coûteux et mettent en théorie plus de
temps à devenir obsolètes, mais peuvent cependant donner accès à un
ordinateur bien plus récent (et plus puissant).</LI>
<LI>Puisque le fonctionnement d'un terminal texte (en opposition à un
terminal entièrement graphique) ne consomme pas beaucoup de ressources sur un
PC moderne, on peut faire tourner beaucoup de terminaux sur un seul PC de
manière efficace.</LI>
</UL>
</P>

<H2><A NAME="overview"></A> <A NAME="s5">5. Vue d'ensemble du fonctionnement des terminaux (sous Linux)</A></H2>


<P>Voir aussi la section 
<A HREF="#HowTermsWorkDetail">quelques détails sur le fonctionnement des terminaux</A>.</P>

<H2><A NAME="dev_names"></A> <A NAME="ss5.1">5.1 Noms de périphériques</A>
</H2>


<P>Chaque terminal est relié à un port série sur l'ordinateur hôte (souvent un
simple PC). Les ports ont les noms suivants : ttyS0, ttyS1, ttyS2, etc. Ils
sont représentés par des fichiers spéciaux dans le répertoire /dev (device :
périphérique). /dev/ttyS0 correspond au COM1 sous DOS ou Windows. ttyS1 est
le COM2, etc. Voyez 
<A HREF="#devices_">fichiers spéciaux pour les terminaux</A> pour plus de détails sur ceux-ci et les "périphériques" connexes
tels que cua.</P>

<H2><A NAME="ss5.2">5.2 Se logger / se délogger</A>
</H2>


<P>Quand l'ordinateur hôte démarre il lance le programme getty (voyez le HOWTO
Serial 4.1 et 7.2) sur chaque port série qui y possède un terminal (ainsi
qu'il est spécifié dans le fichier /etc/inittab). Le programme getty lance le
programme "login" pour que les gens puissent se logger. Une invite "login:"
apparaît à l'écran. Les gens sur le terminal se loggent (après avoir donné
leur mot de passe) et ont alors accès à l'ordinateur. Quand il est temps
d'éteindre le terminal, on se délogge en général et on éteint le terminal.
Voyez 
<A HREF="#login_restr">restrictions sur le login</A> à propos de la
restriction sur les logins (avec la permission pour l'utilisateur root de se
logger sur un terminal).</P>

<H2><A NAME="half_duplex"></A> <A NAME="ss5.3">5.3 Half/Full Duplex</A>
</H2>


<P>Si on regarde quelqu'un taper sur un terminal, les lettres tapées
apparaissent simultanément sur l'écran. Une personne naïve pourrait penser
que ce qu'on tape est envoyé directement du clavier à l'écran avec une copie
dirigée vers l'ordinateur (de manière half-duplex, voir le paragraphe
suivant). Ce qui se passe généralement est que ce qui est tapé au clavier est
envoyé directement à l'ordinateur hôte uniquement qui en retour renvoie au
terminal chaque caractère qu'il reçoit (ce qu'on appelle full-duplex). Dans
certains cas (comme les mots de passe ou des commandes brutes d'éditeurs) les
lettres tapées ne sont pas renvoyées.</P>
<P>Full-duplex veut dire qu'il y a deux liens de communications
unidirectionnels. Le full-duplex est la norme de fait sur les terminaux. Le
half-duplex est la moitié d'un duplex, ce qui veut dire qu'il n'y a qu'un
lien de communication unidirectionnel. Ce lien doit être partagé par les
communications allant dans les deux directions et on ne peut utiliser qu'une
direction à la fois. Dans ce cas l'ordinateur n'est pas en mesure de répéter
les caractères que vous tapez (et que vous lui envoyez) et par conséquent le
terminal doit aussi envoyer directement sur son écran chaque caractère que
vous tapez. Certains terminaux possèdent un mode de fonctionnement
half-duplex qui est rarement utilisé.</P>

<H2><A NAME="ss5.4">5.4 Mémoire du terminal</A>
</H2>


<P>L'image sur un tube à électrons s'évanouira presque instantanément à moins
qu'elle ne soit réaffichée fréquemment sur l'écran par un faisceau
d'électrons lancés sur la face du tube. Puisque que le texte envoyé à un
terminal doit rester sur l'écran, l'image de l'écran doit être stockée dans
les puces mémoire du terminal et le faisceau d'électrons doit balayer l'écran
de façon répétée (disons 60 fois par seconde) pour maintenir l'image. Voyez
<A HREF="#term_mem_detail">mémoire du terminal</A> pour plus de détails.</P>

<H2><A NAME="ss5.5">5.5 Commandes pour le terminal</A>
</H2>


<P>Le terminal est sous le contrôle de l'ordinateur. L'ordinateur envoie au
terminal non seulement du texte pour afficher ce dernier sur l'écran mais
aussi des commandes que le terminal exécute. Ce sont des 
<A HREF="#control_codes">codes de contrôle</A> (octets) et des 
<A HREF="#esc_seq">séquences d'échappement</A>. Par exemple, le code de
contrôle CR (retour chariot) déplace le curseur sur le côté gauche de
l'écran. Une certaine séquence d'échappement (plusieurs octets dans lesquels
le premier octet est le code de contrôle d'"échappement") peut déplacer le
curseur à l'emplacement de l'écran spécifié par les paramètres placés dans la
séquence d'échappement.</P>
<P>Les 
<A HREF="#early_terms">premiers terminaux</A> n'avaient que peu de
telles commandes mais les terminaux modernes en ont des centaines.
L'apparence de l'affichage peut être modifiée à certains endroits : fort,
faible, souligné, clignotant et vidéo inverse. Un haut-parleur dans un
terminal peut émettre un "cliquetis" quand une touche est pressée ou émettre
un bip si une erreur s'est produite. Les touches de fonctions peuvent être
programmées pour des utilisations spéciales. Des polices variées peuvent
exister. On peut faire défiler l'affichage vers le haut ou vers le bas. On
peut effacer des parties spécifiques de l'affichage. On peut utiliser divers
types de contrôle de flux pour arrêter le flux de données quand les octets
sont envoyés au terminal plus rapidement que le terminal ne peut le
supporter. Il y en a bien plus, que vous découvrirez en parcourant une notice
de terminal très technique ou à travers les liens Internet de la 
<A HREF="#esc_seq_list">liste des séquences d'échappement</A>.</P>

<H2><A NAME="ss5.6">5.6 Manque de normalisation résolu par Terminfo</A>
</H2>


<P>Alors que les terminaux faits pour les États-Unis utilisaient tous le même
code ASCII pour l'alphabet (sauf les terminaux IBM qui utilisaient EBCDIC),
il n'utilisaient malheureusement pas tous les mêmes séquences d'échappement.
Ceci s'est produit même après que plusieurs normes ANSI (et ISO) aient été
établies puisque ces normes n'ont jamais été suffisamment matures. De plus,
les vieux terminaux n'avaient pas les possibilités des nouveaux terminaux.
Ceci pouvait poser des problèmes. Par exemple, l'ordinateur pouvait envoyer
une séquence d'échappement à un terminal lui disant de séparer l'écran en
deux fenêtres de taille spécifiée, sans réaliser que le terminal était
incapable de le faire.</P>
<P>Pour surmonter ces problèmes une base de données appelée "termcap"
(maintenant "terminfo") a été mise en place. Cette base de données réside
dans certains fichiers sur l'ordinateur et en une partie (quelquefois le
fichier entier) pour chaque modèle de terminal. Pour chaque modèle (comme le
VT100) une liste des capacités est fournie, avec une liste de certaines
séquences d'échappement disponibles et ce qu'elles font. Par exemple 
blink=\E5m veut dire que pour faire clignoter le curseur, il faut envoyer 
au terminal&nbsp;: Escape 5 m. Voyez la section 
<A HREF="#termcap2">termcap et terminfo (détaillés)</A> pour plus de détails. Les 
applications peuvent utiliser cette base de données en appelant
certaines fonctions de la bibliothèque C. Un grand ensemble de tels
programmes (il y en a plus de 200) est appelé "ncurses" et ils sont listés
sur la page de manuel de "ncurses".</P>

<H2><A NAME="ss5.7">5.7 L'interface</A>
</H2>


<P>La variable d'environnement TERM décrit le type de terminal que Linux croit
que vous utilisez. Certaines applications l'utilisent pour regarder les
capacités dans la base de données terminfo et par conséquent TERM doit être
positionnée correctement. Mais que l'ordinateur connaisse les capacités du
terminal n'est qu'une partie du chemin vers une interface correcte.</P>
<P>Pour que les octets affluent de l'ordinateur vers le terminal, le terminal
doit être configuré pour recevoir les octets à la même vitesse (en bits par
seconde) qu'ils sont envoyés du terminal. Si on configure le terminal pour
recevoir à 19200 bauds et que l'ordinateur envoie des caractères à 9600
bauds, on ne verra à l'écran que des parasites (ou peut-être rien du tout).
On sélectionne la vitesse de transmission pour un terminal (ainsi que bien
d'autres possibilités) à partir des menus de "configuration" (set-up) sur le
terminal.  La plupart des terminaux possèdent un grand nombre d'options dans
leurs menus de "configuration" (voyez  
<A HREF="#term_conf_details">configuration du terminal (détaillée)</A>). Le port série de l'ordinateur
a aussi des options et ces options doivent être configurées d'une manière
compatible (voyez 
<A HREF="#comp_conf_details">configuration de l'ordinateur (détaillée)</A>).</P>

<H2><A NAME="ss5.8">5.8 Émulation</A>
</H2>


<P>La plupart des terminaux de nos jours possèdent plus d'une émulation
(personnalité ou "mode de terminal"). Les numéros de modèles des terminaux
fabriqués autrefois par DEC (Digital Equipment Corporation, maintenant
Compaq) commencent par VT (par exemple, VT100). Bien d'autres terminaux
différents des VT100 peuvent être configurés pour émuler un VT100. Wyse est
un grand fabricant de terminaux et la plupart de leurs terminaux peuvent
émuler des terminaux DEC divers comme les VT100 et les VT220. Par conséquent
si vous voulez, disons, utiliser un terminal VT320 vous pouvez soit utiliser
un vrai VT320 en personnalité "naturelle" soit utiliser un autre terminal
capable d'émuler un VT320. Les personnalités "naturelles" ont en général plus
de capacités donc, toutes choses étant égales par ailleurs, c'est la
meilleure option à utiliser.</P>
<P>Le type d'émulation le plus courant est d'utiliser un PC comme si c'était un
terminal vt100 (ou identique). Les programmes chargés dans la mémoire du PC
permettent ceci. Dans Linux (sauf si vous êtes dans X Window) le moniteur du
PC (appelé la console) émule un terminal de type "Linux" (proche du vt100).
Même certaines fenêtres dans X Window émulent des terminaux. Voyez 
<A HREF="#term_emulation">émulation de terminal</A>.</P>

<H2><A NAME="ss5.9">5.9 La console</A>
</H2>


<P>Sur un PC, le moniteur est appelé la console. Elle émule un terminal de type
"Linux". On se logge dessus via un terminal virtuel. Voyez 
<A HREF="#console_dev">la console : /dev/tty?</A>. Elle reçoit des messages du
noyau concernant la progression du démarrage (boot) et de l'arrêt de la
machine. On peut faire en sorte que les messages allant normalement sur la
console aillent sur le terminal. Pour ceci, vous devez patcher et recompiler
le noyau à la main, sauf pour les noyaux 2.2 (et plus) pour lesquels il
s'agit d'une option de configuration. Voyez 
<A HREF="#term_as_console">faire qu'un terminal devienne la console</A>.</P>

<H2><A NAME="devices_"></A> <A NAME="s6">6. Fichiers spéciaux pour les terminaux tels que /dev/tty</A></H2>


<P>"tty" est l'abréviation de "Teletype". Les premiers terminaux étaient des
télétypes (comme machine à écrire pilotée à distance). Voyez la sous-section
<A HREF="#teletype">télétypes</A>. On trouve une liste des périphériques
Linux (ce qui se trouve dans le répertoire /dev) dans "Linux Allocated
Devices" (en français "Périphériques référencés sous Linux"), normalement
inclus dans les sources du noyau. Il "décrit" à quoi sert un périphérique en
un mot ou deux mais ne vous dit pas comment l'utiliser.</P>

<H2><A NAME="ss6.1">6.1 Terminaux sur port série</A>
</H2>


<P>L'ordinateur considère chaque port série comme un "périphérique". On
l'appelle parfois périphérique terminal puisqu'à un moment les terminaux
représentaient une utilisation courante des ports série.
Pour chacun de ces ports série, il existe un fichier spécial dans le répertoire
/dev (device : périphérique). /dev/ttyS0 est le fichier spécial pour le port
série connu sous le nom COM1 dans le monde DOS/Windows. Pour envoyer du texte
à un terminal vous pouvez rediriger la sortie standard de certains programmes
en ligne de commande vers le fichier spécial approprié. Par exemple en tapant
"echo test > /dev/ttyS1" à l'invite de commandes, le mot "test" devrait être
envoyé sur le terminal sur ttyS1 (COM2) à condition que vous ayez la
permission d'écrire sur /dev/ttyS1. De même, taper "cat mon_fichier >
/dev/ttyS0" enverra le contenu du fichier mon_fichier sur COM1 (ttyS0).</P>
<P>En plus de ttyS0 (/dev/ttyS0), ttyS1, ttyS2, etc. (le "S" veut dire port
Série) il y a aussi une série de "cua" : cua0, cua1, cua2, etc. cua0
correspond au même port que ttyS0, etc. Le "cu" dans cua veut dire CalloUt
(appel sortant). Les séries ttyS sont conformes à Posix alors que
l'utilisation de cua peut permettre l'ouverture d'un port dont les lignes de
contrôles du modem affirment qu'il n'est pas prêt. À partir du noyau 2.2 cua
est obsolète et un message d'avertissement est affiché quand vous essayez de
l'utiliser (bien qu'il fonctionne encore). Pendant les dernières années, il
n'était présent dans Linux que pour assurer une compatibilité ascendante. Un
programmeur peut faire en sorte que ttyS se comporte comme cua, et donc cua
n'est pas vraiment utile.</P>

<H2><A NAME="ss6.2">6.2 Pseudo-terminaux</A>
</H2>


<P>Les pseudo-terminaux n'ont pas de connecteur physique sur l'ordinateur. 
On les utilise pour émuler un port série. Ils n'ont pas d'adresses E/S (IO)
ni d'IRQ. Par exemple, si
quelqu'un se connecte grâce à telnet sur votre ordinateur à travers un
réseau, il peut se trouver connecté au périphérique /dev/ptyp2 (un port de
pseudo-terminal). Dans X Window, le programme d'émulation de terminal, xterm
(ou rxvt), utilise des pseudo-terminaux. Les programmes pour les
radioamateurs sous Linux les utilisent aussi. Avec certaines applications, il
est possible d'attacher deux ou plus de deux pseudo-terminaux sur le même
port série physique.</P>
<P>Les pseudo-terminaux vont par deux comme ttyp3 et ptyp3. La série pty... est
le terminal maître ou contrôleur et la série tty... est l'esclave. ttyq5 est
aussi un pseudo-terminal comme l'est ttysc (``c'' est un chiffre
hexadécimal).  Plus précisément, les pseudo-terminaux maîtres sont
/dev/pty[p-s]N et les esclaves correspondants sont
/dev/tty[p-s]N où N est un chiffre hexadécimal entre 0 et f.
L'esclave /dev/ttyp agit comme un port série pour une application, elle peut 
y lire et y écrire. Cependant, l'application communique vraiment avec 
quelque soit le programme qui ecrit et lit au maitre /dev/pty correspondant.
Aussi le maitre et l'esclave sont vraiment le meme "port" mais un est utilisé 
par l'application et l'autre par un programme réseau (ou l'équivalent) qui 
envoit (et récupère) des données au (et du) "port".</P>
<P>La norme Unix98 n'utilise pas les conventions ci-dessus, mais utilise à la
place un "pty maître" qui est /dev/ptmx. Celui-ci peut fournir un pty à la
demande. Les détails sur l'utilisation des pseudo-terminaux avec d'autres 
programmes programmes se trouvent dans quelques pages de manuels, mais un 
manuel dédié seulement aux pseudo-terminaux est nécéssaire pour Linux.
D'autres unix-like ont une telle page nommée "pty - pseudo terminal driver".</P>

<H2><A NAME="ss6.3">6.3 Le terminal contrôlant /dev/tty</A>
</H2>


<P>/dev/tty est le terminal contrôlant (s'il y en a un) le processus en cours. 
Pour déterminer uels ttys sont attachés à quels processus, utilisez la
commande "ps -a" à l'invite de commandes (la ligne de commandes). Regardez la 
colonne "tty". Pour le processus shell que vous utilisez, /dev/tty est le 
terminal que vous utilisez à l'instant. Tapez "tty" à l'invite de commandes 
pour voir lequel c'est (voyez la page de manuel tty(1)). /dev/tty est quelque 
chose semblable à un lien vers le nom de périphérique du terminal en cours 
avec certaines possibilités supplémentaires pour les programmeurs en C&nbsp;: 
voyez la page de manuel tty(4).</P>

<H2><A NAME="ss6.4">6.4 "Terminaux" /dev/ttyIN</A>
</H2>


<P>N représente un entier. L'une des utilisations possibles de ces terminaux
dans Linux est le paquet du pilote ISDN (RNIS) : isdn4linux. La série ttyIN
ressemble à ttySN. Il y a aussi une série cuiN qui ressemble à cuaN. Les
séries ttyI et cui émulent des modems et on peut leur envoyer des commandes
de modems.</P>

<H2><A NAME="console_dev"></A> <A NAME="ss6.5">6.5 La console : /dev/ttyN</A>
</H2>


<P>Dans Linux le moniteur du PC est en général appelé la console et on lui associe
plusieurs fichiers spéciaux de périphériques : tty0, tty1, tty2, etc. Quand
vous vous loggez vous êtes sur le tty1. Pour aller sur le tty2(sur le meme 
ecran) appuyez sur Alt-F2, pour tty3 appuyez sur Alt(Gauche)-F3. Ces 
(tty1, tty2, tty3, etc.) sont appellés "terminaux virtuels". tty0 est juste un 
alias pour le terminal virtuel courant et c'est celui ou sont envoyés les 
messages du système. Aussi, les messages seront affichés sur la console 
(moniteur) sans se coucier de quel terminal virtuel est affiché.</P>
<P>Vous pouvez vous logger sur différents terminaux virtuels et ainsi avoir 
plusieurs sessions différentes tournant en même temps sur l'ordinateur. Seuls 
le système et l'utilisateur root peuvent écrire dans  /dev/tty0 à laquelle 
/dev/console est quelquefois liée. Pour plus d'informations sur la console, 
voyez 
<A HREF="#console_">la console Linux</A>.</P>

<H2><A NAME="ss6.6">6.6 Créer un périphérique avec "mknod"</A>
</H2>


<P>Le répertoire /dev est installé avec beaucoup de fichiers spéciaux de
périphériques. Si vous avez besoin de quelque chose non présent dans ce
répertoire, vous pouvez essayer de le créer avec la commande "mknod". Voyez
la page de manuel de ttys(4) pour savoir comment le faire pour les ports
série.  Pour utiliser <CODE>mknod</CODE> vous devez connaître les numéros de
périphériques mineur et majeur. Vous pourriez déduire les numéros dont vous
avez besoin en utilisant la commande "<CODE>ls -l</CODE>" dans le répertoire /dev.
Elle affichera les numéros majeur et mineur des fichiers spéciaux existants.</P>

<H2><A NAME="HowTermsWorkDetail"></A> <A NAME="s7">7. Quelques détails sur le fonctionnement des terminaux</A></H2>


<P>Si vous ne connaissez presque rien sur les terminaux, je vous suggère de lire
en premier 
<A HREF="#intro">introduction</A> et de lire aussi 
<A HREF="#overview">survol du fonctionnement des terminaux</A>.</P>

<H2><A NAME="term_mem_detail"></A> <A NAME="ss7.1">7.1 Mémoire du terminal</A>
</H2>


<P>L'écran du terminal se rafraîchit peut-être 60 fois par seconde à partir
d'une image stockée dans la mémoire du terminal. Pour un PC l'image du
moniteur est stockée dans la mémoire de la carte vidéo à l'intérieur de
l'ordinateur mais pour un terminal, l'équivalent de la carte vidéo est à
l'intérieur du terminal. Pour un terminal texte le stockage d'une image
utilise peu de mémoire. Au lieu de placer chaque point (pixel) sur l'écran en
mémoire, ce qui demande le stockage d'à peu près 250.000 points, on utilise
une méthode de stockage bien plus efficace.</P>
<P>Un écran rempli de texte peut être représenté dans la mémoire du terminal par
des octets ASCII, un pour chaque caractère à l'écran. Un écran entier ne
prend qu'environ 2 K octets ASCII. Pour afficher ces caractères, le terminal
doit aussi connaître l'image (la forme) de chacun des presque 100 caractères
ASCII imprimables. L'image d'un caractère n'occupant que, disons, 15 octets,
on n'a besoin que d'environ 1,5 K de mémoire pour les images de tous les
caractères ASCII (la police). Ce texte ASCII et la mémoire de la police sont
balayés pour que l'image résultante soit affichée à l'écran environ 60 fois
par seconde.  C'est une forme de mémoire partagée où l'image unique d'une
lettre telle que la lettre e est partagée par toutes les nombreuses lettres e
qui apparaissent sur un écran rempli de texte. Une faible demande en mémoire
impliquait des coûts réduits pour produire des moniteurs au début des années
1980 quand le coût de la mémoire était plusieurs milliers de fois plus
important qu'il ne l'est actuellement (ce qui représentait à l'époque
plusieurs dollars par kilo-octet).</P>

<H2><A NAME="early_terms"></A> <A NAME="ss7.2">7.2 Les premiers terminaux</A>
</H2>


<P>Les premiers terminaux ressemblaient à des machines à écrire contrôlées à
distance qui ne pouvaient "afficher" (imprimer sur du papier) que le flux de
caractères que leur envoyait l'ordinateur. Les premiers modèles étaient
appelés 
<A HREF="#teletype">télétypes</A>. Le nom "tty" n'est que
l'abréviation de "Teletype". Les premiers terminaux étaient capables de faire
un saut de ligne et un retour chariot comme une machine à écrire et faire
tinter une sonnette quand un caractère sonnette (bell) était reçu. À cause du
manque de possibilités significatives, ce sont les premiers terminaux à avoir
reçu l'appellation "simple" (dumb). Ce genre d'interface terminale
(l'utilisation d'un type de terminal appelé "dumb") est quelque fois utilisé
de nos jours quand l'ordinateur ne peut pas déterminer avec quelle sorte de
terminal il communique.</P>

<H2><A NAME="ss7.3">7.3 Séquences d'échappement et codes de contrôle (introduction)</A>
</H2>


<P>Les terminaux possèdent beaucoup de possibilités dont certaines sont toujours
présentes ; pour les autres, l'ordinateur doit envoyer des commandes au
terminal afin de modifier ou activer ces possibilités. Mettre en oeuvre
toutes ces possibilités sous le contrôle d'un ordinateur nécessite la mise en
place de codes spéciaux pour que l'ordinateur puisse dire au terminal ce
qu'il doit faire. Il y a deux grandes sortes de codes : les séquences
d'échappement et les code de contrôle (caractères de contrôle). Il y a bien
plus de séquences d'échappement que de codes de contrôle.</P>

<H3><A NAME="control_codes"></A> Codes de contrôle</H3>


<P>Les codes de contrôle (ou caractères de contrôle) sont constitués des 32
premiers octets de l'alphabet ASCII. Ils comprennent les codes suivants :
retour chariot (curseur à l'extrémité gauche), saut de ligne (curseur une
ligne vers le bas), retour en arrière, caractère d'échappement, tabulation et
sonnette. Ils ne s'impriment normalement pas sur l'écran. Il y a souvent une
commande que vous pouvez envoyer à votre terminal qui fera qu'ils seront
affichés quand le terminal les recevra. On l'appelle parfois "Contrôles
d'affichage" ou "Moniteur". Si vous faites ceci, l'affichage aura l'air
légèrement dans le désordre puisque les séquences d'échappement, qui
commencent toutes par le caractère de contrôle ESC (escape, échappement), ne
seront plus exécutées. Les mots qui devraient apparaître en haut ou en bas de
l'écran apparaîtront à d'autres endroits. Les séquences d'échappement pour
repositionner le curseur s'afficheront sur l'écran mais le curseur ne se
déplacera pas vers la destination indiquée par la séquence d'échappement.</P>

<H3><A NAME="esc_seq"></A> Séquences d'échappement</H3>


<P>Puisque qu'il n'y pas assez de codes de contrôle pour tout faire (et pour une
raison ou pour une autre, ils ne sont pas tous utilisés), on utilise de
nombreuses séquences d'échappement. Elles sont constituées du caractère de
contrôle d'échappement (ESC) suivi d'une séquence de caractères ordinaires.
En recevant un caractère d'échappement, le terminal examine les caractères
suivants pour interpréter la séquence et exécuter la commande voulue par
l'ordinateur. Une fois que la fin d'une séquence valide est reconnue, les
caractères suivants s'affichent simplement à l'écran (sauf s'il s'agit de
codes de contrôle ou de séquences d'échappement supplémentaires). Certaines
séquences d'échappement peuvent prendre des paramètres (ou arguments) comme
les coordonnées écran pour déplacer le curseur. Les paramètres font partie de
la séquence d'échappement. Une 
<A HREF="#esc_seq_list">liste des séquences d'échappement</A> se trouve sur le Web pour certains terminaux, mais
c'est un peu brutal.</P>
<P>Une liste des séquences d'échappement pour votre terminal devrait se trouver
dans le "manuel du programmeur" de votre terminal. À part pour de très vieux
terminaux, il devrait y avoir deux ou trois cents séquences. Si vous n'avez
pas de manuel, ce n'est pas facile de les trouver. Certaines séquences sont
disponibles sur Internet. Un lien possible est 
<A HREF="#esc_seq_list">liste des séquences d'échappement</A>. En cherchant une séquence sur
Internet (comme ESC[5m) vous pouvez tomber sur une longue liste.</P>
<P>Une autre façon de déterminer certaines séquences est de trouver la section
termcap (terminfo) du terminal et de la décoder mentalement. Voyez 
<A HREF="#termcap2">terminfo et termcap (détails)</A> dans ce document et/ou le
<A HREF="#termcap_docs">manuel termcap</A> sur Internet. Malheureusement,
la section termcap (terminfo) d'un terminal ne liste souvent pas toutes les
séquences d'échappement disponibles sur le terminal, mais heureusement, les
plus importantes sont en général présentes.</P>

<H2><A NAME="display_attributes"></A> <A NAME="ss7.4">7.4 Attributs d'affichage et cookies magiques</A>
</H2>


<P>Les terminaux possèdent diverses méthodes pour générer des attributs de
caractères tels que gras, vidéo inverse, soulignement, etc. L'utilisateur ne
devrait pas s'inquiéter de la manière dont c'est géré, sauf que cela peut
poser des problèmes pour certains vieux terminaux et il y a quelquefois une
option à ce sujet dans le menu de configuration des terminaux plus récents.</P>
<P>La méthode des cookies magiques (magic cookie) est dépassée. C'est la méthode
la plus simple (et la pire) pour définir des attributs : l'utilisation d'un
octet particulier pour démarrer un attribut et un autre pour indiquer la fin
de cet attribut. Par exemple, un octet magique "démarrer le soulignement" est
placé juste devant le premier mot à souligner. Ces octets supplémentaires
sont placés dans la mémoire de la page écran, comme les octets pour les
caractères qui s'affichent normalement. Ceci peut cependant fausser le
décompte du nombre de caractères par ligne puisque les caractères de cookies
magiques non imprimables sont mélangés avec les autres caractères
imprimables. Ceci peut dans certains cas poser des problèmes.</P>
<P>Une méthode plus efficace, qui utilise plus de mémoire, est d'associer un
caractère d'attribut (ou un demi-caractère, etc.) à chaque caractère affiché.
Cette méthode est utilisée par les cartes vidéo PC (pour le texte) pour les
moniteurs PC courants.</P>

<H2><A NAME="s8">8. Possibilités spéciales de certains terminaux</A></H2>



<H2><A NAME="ss8.1">8.1 Couleur</A>
</H2>


<P>Bien que le terminal monochrome courant ne soit pas un terminal couleur, il
peut avoir un affichage en "couleur" fixe autre que blanc comme vert ou
ambre.  Tous les terminaux possèdent le noir (faisceau d'électrons éteint =
luminosité nulle). Un véritable terminal couleur peut modifier la couleur du
texte et du fond avec plusieurs couleurs différentes alors qu'un terminal
monochrome ne peut modifier que la luminosité d'une couleur donnée.</P>
<P>Cependant, changer la luminosité, etc. offre bien des possibilités. Par
exemple, un terminal noir et blanc (monochrome) peut avoir du blanc, du gris
et du noir en variant la luminosité. Certains mots peuvent être en noir sur
un fond légèrement gris tandis que d'autres sont mis en valeur par du noir
sur fond blanc. En plus il y a du blanc sur noir, du soulignement et du
clignotement.</P>
<P>La couleur fonctionne comme la couleur sur un moniteur d'ordinateur ou un
écran de télévision. Le tube possède trois couleurs de points, chacune étant
contrôlée par son propre faisceau d'électrons (il y a trois faisceaux).  Le
monochrome a par définition une meilleure résolution puisqu'il ne dépend pas
de points fixés en permanence à l'écran. Pour les terminaux texte la seule
utilisation de la couleur permet de différencier le texte et cet avantage ne
vaut pas toujours le coût d'une résolution moins bonne. Le monochrome peut
donc être meilleur puisqu'il est aussi moins cher.</P>

<H2><A NAME="ss8.2">8.2 Sessions multiples</A>
</H2>


<P>Pour les sessions doubles, le terminal possède deux ports série de statut
égal. Chaque port est connecté au port série d'un ordinateur différent. Ainsi
on peut se logger sur deux ordinateurs différents, chaque session s'affichant
dans une fenêtre de l'écran séparé en deux. Autrement, chaque session peut
s'exécuter en plein écran et on utilise une touche "rapide" (hot key) pour
accéder directement à une session (ou une même touche pour basculer). On
pourrait aussi se connecter sur deux ports série différents sur le même
ordinateur et se logger deux fois (de manière identique aux "terminaux
virtuels" sur la console). Le programme "screen" pourra faire tourner sur
n'importe quel terminal (session unique) relié à un ordinateur unique deux
"sessions" ou plus.</P>

<H2><A NAME="ss8.3">8.3 Port imprimante/auxiliaire</A>
</H2>


<P>Beaucoup de terminaux possèdent un connecteur à l'arrière pour un tel port.
Il peut s'appeler "Aux" ou "Printer", etc. Certains ports d'imprimantes sont
destinés aux imprimantes parallèle alors que d'autres sont destinés aux
imprimantes série.  Si une imprimante est connectée au port imprimante ou
auxiliaire, alors l'appui sur certaines touches imprime l'écran. On peut
aussi faire imprimer tout ce qui s'affiche à l'écran. Si le port est un port
auxiliaire, on peut le connecter à un autre ordinateur et avoir des sessions
doubles comme ci-dessus.  Cependant, la mémoire vidéo à l'intérieur du
terminal peut ne pas retenir les deux sessions et vous pouvez avoir besoin de
rafraîchir l'écran en basculant sur l'autre session. Il n'y aura peut-être
pas de touche rapide non plus mais on pourra peut-être programmer une touche
de fonction pour accomplir cette tâche. Il existe de nombreuses combinaisons
de touches et de séquences d'échappement pour contrôler un tel port. Voyez
<A HREF="#printer_esc">échappement de l'imprimante</A>.</P>
<P>Il y a un programme appelé <CODE>vtprint</CODE> qui est fait pour envoyer un travail
d'impression à votre terminal en vue de l'imprimer sur une imprimante reliée
au terminal. Sa page Web est <CODE>
<A HREF="http://people.qualcomm.com/garrett/vtprint">http://people.qualcomm.com/garrett/vtprint</A></CODE>. Il est aussi inclus
(en 1998) dans la distribution Debian de Linux. <CODE>xprt</CODE> (aussi dans Debian)
semble faire une chose identique, mais seulement pour les terminaux X Window
??</P>

<H2><A NAME="pages_"></A> <A NAME="ss8.4">8.4 Pages</A>
</H2>


<P>Beaucoup de terminaux permettent le stockage de plus d'une page dans leur
mémoire vidéo. Quelquefois la taille de la page est la même que celle de
l'écran, mais elle est parfois plus grande, ce qui fait que le défilement
révèlera les parties invisibles de la page. Quand quelqu'un regarde un écran,
il peut y avoir du texte caché sur la même page au-dessus ou en dessous de
l'affichage. En plus, s'il y a plus d'une seule page, il peut y avoir du
texte caché sur ces autres pages. Une utilisation possible de ces pages
concerne les terminaux qui supportent les sessions doubles. Chaque session
peut avoir sa propre page et on peut basculer de l'une à l'autre simplement.</P>
<P>Même si vous avez un terminal à page unique avec la taille de la page égale à
ce qui est affiché sur l'écran, vous verrez encore d'autres pages d'un
fichier (etc.) tant que l'hôte envoie des données au terminal. L'un des
avantages de stocker des pages supplémentaires dans la mémoire du terminal
est que vous pouvez y accéder instantanément sans attendre une seconde ou
presque qu'elles soient transmises depuis l'hôte.</P>
<P>Les pages multiples sont supportées par ncurses. Faites-moi savoir si vous 
en connaissez. Il y a un programme commercial appelé "Multiscreen" qui 
les supporte mais il n'est sûrement pas pour Linux&nbsp;?? Il parait que 
Multiscreen fait partie de SCO et fait quelque chose dans le genre des 
terminaux virtuels sur une console PC Linux. Le programme Linux "screen" 
fait semblant d'avoir des pages multiples mais elles sont stockées sur 
l'ordinateur et vous ne pouvez avoir qu'une fenêtre-page pour chaque 
programme en cours.</P>

<H2><A NAME="char_sets"></A> <A NAME="ss8.5">8.5 Jeux de caractères</A>
</H2>


<P>Un jeu de caractères est normalement représenté par une liste (ou table ou
tableau) de caractères accompagnée du code d'octet assigné à chaque
caractère. Les codes d'un octet vont de 0 à 255 (00 à FF en hexadécimal).
Dans MS-DOS, les tables de jeux de caractères sont appelées "pages de code".
Vous devriez examiner une telle table si vous n'êtes pas familier avec
celles-ci. Elles sont parfois incluses dans les manuels d'imprimantes et de
terminaux mais peuvent être difficiles à trouver.</P>
<P>L'ASCII est l'un des jeux de caractères les plus courants utilisés sur les
terminaux texte. C'est un code sur 7 bits mais qui peut être converti en 8
bits si le premier bit (bit de haut rang)  est toujours positionné à 0. D'autres jeux de caractères
sont en général disponibles (sauf sur de très vieux terminaux où le seul
choix est l'ASCII). La première moitié de la plupart des jeux de caractères
sont les caractères ASCII traditionnels et la deuxième moitié (les caractères
avec le bit de haut rang  mis à 1) appartiennent
à une grande variété de jeux de caractères. Les jeux de caractères sont
souvent des normes ISO. Pour obtenir des jeux de caractères spécialisés sur
un terminal, vous devrez certainement télécharger une police logicielle pour
ce jeu de caractères dans la mémoire du terminal.</P>
<P>À côté de l'ASCII, il y a d'autres jeux de caractères courants, tous en 8
bits. CP est l'abréviation des jeux de caractères de page de codes (Code
Page) inventés par IBM : CP-437 (ECS DOS), CP-850 (Latin 1 multilingue -- pas
le même que ISO Latin-1), ISO-8859-1 (Latin-1), ANSI (dérivé de Latin-1). MS
Windows utilise ANSI alors qu'Internet utilise souvent Latin-1.  Il y a
plusieurs jeux de caractères ISO-8859 en plus de Latin-1.  Ceux-ci
comprennent le grec (-7), l'arabe (-6), l'Europe de l'Est (-2) et le russe
(-5). Il y en a bien d'autres. Par exemple, KOI8-R est plus souvent utilisé
pour le russe que ISO-8859-5. Unicode est un jeu de caractères très grand
dans lequel chaque caractère est représenté sur deux octets au lieu d'un
seul.</P>
<P>Voici plus d'informations sur les ensembles de caractères :</P>
<P>
<UL>
<LI>Pages de manuel : ASCII et latin1</LI>
<LI>Les HOWTOs pour diverses langues (sûrement écrits dans cette langue
spécifique). Voyez "Cyrillic" pour le russe.</LI>
<LI> 
<A HREF="http://www.cc.columbia.edu/kermit/charsets.html">http://www.cc.columbia.edu/kermit/charsets.html</A> pour une
liste courte des divers noms de jeux de caractères.</LI>
<LI> 
<A HREF="http://www.pku.edu.cn/on_line/w3html/International/Overview.html">http://www.pku.edu.cn/on_line/w3html/International/Overview.html</A> pour
des informations sur les jeux de caractères et Internet.</LI>
<LI> 
<A HREF="http://www.w3.org/International/O-charset-lang.html">Langues, pays et jeux de caractères</A></LI>
<LI> 
<A HREF="http://vancouver-webpages.com/multilingual/">Utiliser plusieurs langues en HTML</A></LI>
</UL>
</P>
<P>Une fois que vous aurez le nom (ou le numéro) du jeu de caractères qui vous
intéresse, vous pouvez chercher plus d'informations dessus sur Internet.</P>

<H2><A NAME="ss8.6">8.6 Polices</A>
</H2>


<P>La plupart des terminaux fabriqués après le milieu des années 1980 peuvent
accepter des polices logicielles téléchargées. Ceci veut dire qu'ils peuvent
afficher quasiment n'importe quel jeu de caractères à condition que vous
trouviez la police logicielle pour celui-ci. Si vous ne pouvez pas trouver la
police logicielle nécessaire, vous pouvez toujours créer la vôtre. Un éditeur
de polices libre pour effectuer ceci s'appelle BitFontEdit (écrit par
l'auteur de ce document) et se trouvait (en 1998) à<BR> Europe : 
<A HREF="http:/www.funet.fi/pub/culture/russian/comp/cyril-term/">http:/www.funet.fi/pub/culture/russian/comp/cyril-term/</A><BR>
Amérique du Nord : 
<A HREF="ftp://cs.utk.edu/pub/shuford/BitFontEdit.tar.gz">ftp://cs.utk.edu/pub/shuford/BitFontEdit.tar.gz</A></P>

<H2><A NAME="ss8.7">8.7 Claviers et touches spéciales</A>
</H2>


<P>Les claviers des terminaux ont souvent un certain nombre de touches qu'on ne
trouve pas sur un clavier de PC. Peu (ou pas du tout) de terminaux actuels
auront toutes ces touches et la plupart auront des touches supplémentaires
qui ne sont pas listées ici. Certains d'entre eux possèdent un grand nombre
de touches à usage spécial comme les terminaux faits pour les caisses
enregistreuses. Il y a souvent bien plus de significations pour les touches
que ce qui est décrit ici puisque ces touches ont souvent une signification
étendue quand on les utilise avec d'autres touches (comme les touches shift
et control).</P>
<P>
<UL>
<LI>BREAK (interruption) envoie un bit 0 très long (intervalle = +12 V) de
durée de 300 à 700 millisecondes vers l'hôte. L'hôte peut l'interpréter comme
une interruption si stty a positionné brkint ou l'ignorer si ignbrk est
positionné.
</LI>
<LI>NO SCROLL (pas de défilement) arrête le défilement de l'écran comme le
fait ^S. Presser la touche à nouveau reprend le défilement. Utilise des
signaux de contrôle de flux pour faire ceci.
</LI>
<LI>REPEAT (répétition) si on la maintient avec une autre touche, force la
sortie répétée de cette autre touche même si l'option de répétition
automatique est désactivée.
</LI>
<LI>LINE FEED (saut de ligne) envoie le caractère de saut de ligne ^J à
l'hôte. Rarement utilisée.
</LI>
<LI>SET-UP (configuration) permet la configuration manuelle du terminal par
l'intermédiaire de menus. Quelquefois désactivée à dessein en plaçant un bloc
en dessous pour qu'on ne puisse pas la presser. Parfois il faut appyer sur
une autre touche en même temps comme Shift ou Control. Voyez 
<A HREF="#enter_setup">entrer dans le mode de configuration</A>.
</LI>
<LI>LOCAL déconnecte le terminal de l'hôte. En local, ce qu'on tape va
directement à l'écran. Utile pour faire des tests.
</LI>
<LI>RETURN (retour chariot) est la même chose que la touche "Entrée" sur un
PC. Elle envoie en général un retour chariot à l'hôte qui est normalement
traduit en un caractère nouvelle ligne par le pilote de périphériques de
l'hôte. Sur certains terminaux on peut le configurer pour qu'il envoie autre
chose.
</LI>
<LI>F1, F2, ... ou PF1, PF2, ... sont des touches de fonction qu'on peut
généralement programmer pour envoyer une séquence d'octets (caractères).
Voyez 
<A HREF="#funct_keys">touches de fonction</A></LI>
</UL>
</P>

<H2><A NAME="term_emulation"></A> <A NAME="s9">9. Émulation de terminal ; la console</A></H2>



<H2><A NAME="ss9.1">9.1 Émulation de terminal</A>
</H2>



<H3>Introduction à l'émulation de terminal</H3>


<P>Puisqu'un PC possède un écran et un clavier (comme un terminal) mais possède
aussi bien plus de puissance de calcul, il est facile d'utiliser une partie
de cette puissance de calcul pour que le PC se comporte comme un terminal
texte. Voici un type d'émulation de terminal. Un autre type d'émulation de
terminal est de configurer un vrai terminal pour qu'il émule un terminal de
modèle ou de marque différents. Pour ce faire, sélectionnez l'émulation
désirée (que le jargon Wyse appelle "personnalité") à partir du menu de
paramétrage du terminal. Cette section parle du premier type d'émulation :
l'émulation d'un terminal sur un PC.</P>
<P>Les logiciels d'émulation sont disponibles pour MS Windows et sont
intégrés dans les versions récentes de MS Windows. La plupart des logiciels
Linux ne peuvent émuler que des VT100, VT102 ou VT100/ANSI. Si vous en
trouvez d'autres, dites-le moi. Puisque la plupart des PC possèdent des
moniteurs couleur mais que les VT100 et VT102 ont été faits pour des
terminaux monochromes, l'émulation ajoute en général des possibilités de
gestion de couleurs (et un choix de couleurs). Parfois l'émulation n'est pas
parfaite à 100 % mais ceci ne crée en général que peu de problèmes. Pour
utiliser un Macintosh pour émuler un terminal, voyez le mini-Howto :
Mac-Terminal.</P>

<H3><A NAME="term_not_for_emulation"></A> N'utilisez pas TERM pour l'émulation</H3>


<P>Certaines personnes ont pensé, de manière incorrecte, qu'ils pouvaient faire un émulateur sur la
console Linux (le moniteur) en positionnant la variable d'environnement TERM
sur le type de terminal qu'elles aimeraient émuler. Ceci ne fonctionne pas.
La valeur de TERM ne fait qu'indiquer à l'application le terminal que vous
utilisez. Ainsi elle n'a pas besoin de vous le demander directement. Si vous
êtes sur le moniteur du PC, c'est un terminal de type "Linux" et vous ne
pouvez rien y faire. Vous devez donc positionner TERM à "Linux".</P>
<P>Si vous mettez autre chose, vous racontez des bobards à votre application. En
conséquence, elles interpréteront certaines séquences d'échappement provenant
de la console de manière incorrecte, ce qui donnera une interface corrompue.
Puisque la console Linux se comporte presque comme un terminal vt100, elle
pourrait encore fonctionner correctement si vous indiquiez que c'est un vt100
(ou tout autre terminal qui ressemble à un vt100). Cela doit marcher la 
plupart du temps, mais il suffit d'une fois pour qu'il y ait une erreur quand 
vous editez ou equivalent.</P>

<H3>Programmes de communications (appels téléphoniques)</H3>


<P>Un programme d'émulation est souvent couplé à un programme d'appel par modem
(comme Minicom, Seyon ou Kermit) pour que l'on puisse (par exemple) appeler
par téléphone des bibliothèques publiques pour utiliser leurs catalogues et
index (ou même lire des articles de magazine). Seyon ne s'utilise qu'avec X
Window et peut émuler des terminaux Tektronix 4014. Des émulateurs existent
pour DOS comme <CODE>telix</CODE> et <CODE>procomm</CODE> et fonctionnent aussi bien. Les
terminaux émulés sont souvent les vieux VT100, VT102 ou ANSI (comme VT100).</P>

<H3>Émulation sous X Window</H3>


<P>Xterm (obsolète ??) peut fonctionner sous X Window et permet d'émuler un
VT102, VT220 ou Tektronix 4014. Il y a aussi une émulation xterm (bien qu'il
n'y ait pas de terminal physiques qui s'appelle "xterm"). Si vous n'avez pas
besoin de l'émulation Tektronix 4014 (un terminal avec des vecteurs
graphiques ; voyez 
<A HREF="#vector_graphics">terminaux graphiques</A>)
vous pouvez utiliser <CODE>eterm</CODE>. Les prédécesseurs de <CODE>eterm</CODE> sont
<CODE>rxvt</CODE> et <CODE>xvt</CODE>. <CODE>eterm</CODE> supporte les pixmaps en fond de fenêtre.</P>
<P>Pour les alphabets différents de Latin, kterm permet l'émulation de terminal
Kanji (ou tout autre alphabet non Latin) alors que xcin est fait pour le
chinois. Il y a aussi l'émulateur 9term. Il semble que ce soit plus qu'un
simple émulateur puisqu'il possède un éditeur intégré et des barres de
défilement.  Il a été fait pour Plan 9, un système d'exploitation à la Unix
de AT&amp;T.</P>

<H3>Les vrais terminaux sont mieux</H3>


<P>Sauf si vous utilisez X Window avec un grand affichage, il est plus agréable
d'utiliser un vrai terminal que de l'émuler. Il coûte en général moins cher,
a une meilleur résolution pour le texte et n'a pas de lecteurs de disques qui
font des bruits agaçants.</P>

<H2><A NAME="ss9.2">9.2 Tester l'émulation du terminal</A>
</H2>


<P>Pour la série des terminaux VT il y a un programme de test : <CODE>vttest</CODE> pour
aider à déterminer si un terminal se comporte correctement comme un vt53,
vt100, vt102, vt220, vt320, vt420, etc. Il n'y a pas de documentation mais il
a des menus et est facile à utiliser. Pour le compiler lancez le script
configure et ensuite tapez "make". On peut le charger à : 
<A HREF="ftp://ftp.clark/net:/pub/dickey/vttest/">ftp://ftp.clark/net:/pub/dickey/vttest/</A>. Un autre site de chargement
est : 
<A HREF="http://metalab.unc.edu/pub/Linux/utils/console/">http://metalab.unc.edu/pub/Linux/utils/console/</A>.</P>

<H2><A NAME="console_"></A> <A NAME="ss9.3">9.3 La console Linux</A>
</H2>


<P>La console d'un système PC sous Linux est le moniteur de l'ordinateur. Il
émule un terminal de type "Linux". Il n'y a pas moyen (sauf si vous voulez
passer des jours à réécrire le code du noyau) pour le faire émuler autre
chose. Positionner la variable d'environnement TERM à un type de terminal
différent de "Linux" n'aboutira pas à l'émulation de cet autre terminal. Vous
n'obtiendrez qu'une interface corrompue puisque vous avez déclaré faussement
(par l'intermédiaire de la variable TERM) que votre "terminal" est d'un type
différent de ce qu'il est. Voyez la section 
<A HREF="#term_not_for_emulation">n'utilisez pas TERM pour l'émulation</A>.</P>
<P>L'émulation "Linux" est souple et possède des possibilités qui vont bien
au-delà de celles du terminal vt102 qu'il était censé émuler. Celles-ci
comprennent la possibilité d'utiliser des fontes personnalisées et de
reconfigurer facilement le clavier (sans modifier le code source et
recompiler le noyau comme il faut le faire dans le cas d'un terminal réel).
Ces possibilités supplémentaires se trouvent dans le logiciel de pilotage de
la console et non dans le logiciel d'émulation mais le résultat fait qu'on
dirait que ces possibilités font partie de l'émulation.</P>
<P>Beaucoup de commandes existent (voyez le HOWTO Keyboard-and-Console) pour
utiliser ces possibilités supplémentaires. Les vrais terminaux, qui
n'utilisent ni codes de balayages (scancodes) ni carte VGA, ne peuvent
malheureusement pas utiliser la plupart de ces possibilités. On peut
recompiler Linux pour qu'un terminal reçoive les messages qui vont
normalement sur la console. Voyez 
<A HREF="#term_as_console">transformer un terminal en console</A>.</P>

<H2><A NAME="flow_control"></A> <A NAME="s10">10. Contrôle de flux (prise de contact)</A></H2>


<P>Le contrôle de flux (= prise de contact (handshaking) = ralentissement)
permet d'empêcher un flux d'octets trop rapide de dépasser un terminal, un
ordinateur, un modem ou un autre périphérique. Le dépassement est le fait
qu'un périphérique ne puisse pas traiter ce qu'il reçoit assez rapidement et
ainsi perd des octets et/ou fait d'autres erreurs sérieuses. Ce que fait le
contrôle de flux est d'arrêter le flux d'octets jusqu'à ce que le terminal
(par exemple) soit prêt à recevoir des octets supplémentaires. Le contrôle de
flux envoie un signal pour arrêter le flux dans la direction opposée au flux
des données qu'il veut arrêter. Le contrôle de flux doit être lancé à la fois
sur le terminal et sur l'ordinateur.</P>
<P>Il y a deux types de contrôle de flux : matériel et logiciel (Xon/Xoff ou
DC1/DC3). Le contrôle de flux matériel utilise des fils de signaux dédiés
comme RTS/CTS ou DTR/DSR alors que le contrôle de flux logiciel se signale en
envoyant les octets de contrôle DC1 ou DC3 dans les fils de données normaux.
Pour le contrôle de flux matériel, le câble doit être câblé correctement.</P>
<P>Le flux des octets de données dans le câble entre deux ports série est
bidirectionnel, il y a donc deux flux (et deux fils) différents à considérer
:</P>
<P>
<OL>
<LI>le flux de données de l'ordinateur vers le terminal</LI>
<LI>le flux de données du clavier du terminal vers l'ordinateur</LI>
</OL>
</P>

<H2><A NAME="ss10.1">10.1 Pourquoi le contrôle de flux est-il nécessaire ?</A>
</H2>


<P>Vous pouvez vous demander : "Pourquoi ne pas envoyer les données à une
vitesse suffisamment petite pour que le périphérique ne soit pas dépassé et
que le contrôle de flux ne soit ainsi plus nécessaire ?" Ceci est possible
mais c'est en général bien plus lent que d'envoyer les données plus
rapidement et d'utiliser le contrôle de flux. Une raison à ceci est qu'on ne
peut pas positionner la vitesse du port série à n'importe quelle vitesse
comme 14.500, puisqu'un nombre limité de choix est disponible. Le meilleur
choix est de sélectionner une vitesse légèrement plus élevée que ce que peut
soutenir le périphérique et d'utiliser ensuite le contrôle de flux pour que
les choses fonctionnent correctement.</P>
<P>Si on décide de ne pas utiliser le contrôle de flux, la vitesse doit alors
être suffisamment basse pour pallier à la pire des situations. Pour un
terminal, cela arrive quand on envoie des séquences d'échappement pour
effectuer des tâches complexes qui prennent plus de temps qu'à l'accoutumée.
Dans le cas d'un modem (avec la compression de données mais pas de contrôle
de flux) la vitesse de l'ordinateur au modem doit être suffisamment basse
pour que cette même vitesse soit utilisable sur la ligne téléphonique,
puisque dans le pire des cas les données sont aléatoires et ne peuvent être
compressées. Si on ne pouvait pas utiliser de contrôle de flux, la vitesse
(avec la compression de données activée) ne serait pas plus rapide que si on
n'utilisait pas de compression du tout.</P>
<P>Les buffers (mémoires tampons) aident à gérer les situations catastrophes de
courte durée. Le tampon stocke les octets qui arrivent trop rapidement pour
être traités tout d'un coup, et les garde pour les traiter plus tard.</P>

<H2><A NAME="padding"></A> <A NAME="ss10.2">10.2 Remplissage</A>
</H2>


<P>Une autre manière de gérer une situation "catastrophe" (sans utiliser de
contrôle de flux ni de tampon) est d'ajouter un groupe de nulls (octets de
valeur zéro) aux séquences d'échappement. Quelquefois on utilise des DEL à la
place, à condition qu'ils n'aient pas d'autre fonction. Voyez 
<A HREF="#rec_del">reconnaître DEL</A>.</P>
<P>La séquence d'échappement permet au terminal de commencer à faire quelque
chose, et pendant que le terminal est occupé à le faire, il reçoit une
poignée de nulls qu'il ignore. Quand il reçoit le dernier null, il a terminé
sa tâche et est prêt pour la commande suivante. C'est ce qu'on appelle le
remplissage de zéros (null padding). Ces nulls étaient autrefois appelés des
"caractères de remplissage". Ces nulls sont ajoutés simplement pour "perdre"
du temps, mais ce n'est pas tout à fait perdu puisque le terminal est en
général occupé à faire autre chose pendant que les nulls sont reçus. On
utilisait beaucoup cette méthode dans le passé avant que le contrôle de flux
ne devienne populaire. Pour être efficace, il fallait ajouter le nombre exact
de nulls et trouver la bonne valeur est difficile. On le faisait souvent par
essais successifs et tâtonnements puisque les manuels de terminaux n'étaient
pas de grand secours. Si le contrôle de flux ne fonctionne pas correctement
ou n'est pas implémenté, le remplissage est une solution. Certaines options
de la commande <CODE>stty</CODE> concernent le remplissage.</P>

<H2><A NAME="ss10.3">10.3 Débordement d'un port série</A>
</H2>


<P>On peut se demander comment le débordement est possible sur un port série
puisqu'à la fois les ports série d'envoi et de réception servant à la
transmission d'octets de données sont paramétrés pour la même vitesse (en
bits/s) comme 19200. La raison est que bien que l'électronique du port série
récepteur peut gérer la vitesse du flux arrivant, le matériel/logiciel qui
prend et traite les octets du port série ne peut pas toujours se débrouiller
avec une vitesse de flux élevée.</P>
<P>L'une des causes de ceci est que le tampon matériel du port série est assez
petit. Les anciens ports série avaient une taille de tampon matériel d'un
octet seulement (à l'intérieur de la puce UART). Si cet unique octet de
données reçu dans le tampon n'est pas enlevé (pris) par des instructions CPU
avant que l'octet suivant n'arrive, cet octet est perdu (le tampon est
débordé). Les UART récents, par exemple la plupart des 16550A, possèdent des
tampons de 16 octets (mais peuvent être paramétrés pour émuler un tampon d'un
octet) et sont moins susceptibles d'être débordés. On peut le paramétrer pour
envoyer une interruption quand le nombre d'octets dans son tampon atteint 1,
4, 8 ou 14 octets. C'est le travail d'une autre puce dans l'ordinateur
(généralement la puce principale CPU pour un ordinateur) de retirer ces
octets entrants de ce petit tampon matériel et de les traiter (ainsi que
d'effectuer d'autres tâches).</P>
<P>Quand le contenu de ce petit tampon matériel de réception atteint la limite
spécifiée (un octet pour les vieux UART) une interruption est levée.
L'ordinateur interrompt alors ce qu'il était en train de faire et une routine
fait une vérification pour déterminer ce qui vient de se passer. Il détermine
finalement qu'il doit retirer un octet (ou plusieurs) du tampon du port
série. Il prend cet (ces) octet(s) et les met dans un tampon plus grand (un
autre tampon pour le port série) que le noyau maintient dans la mémoire
principale. Pour le tampon de transmission, le matériel série génère une
interruption quand le tampon est vide (ou presque vide) pour dire à la CPU de
mettre quelques octets supplémentaires dans ce tampon afin de les envoyer.</P>
<P>Les terminaux possèdent aussi des ports série et des tampons similaires à
ceux de l'ordinateur. Puisque le flux de données des octets vers le terminal
est en général plus grand que le flux dans la direction opposée du clavier
vers l'ordinateur hôte, le terminal a plus de chance de souffrir du
débordement. Bien sûr, si vous utilisez un ordinateur comme terminal (par
émulation), il est à son tour sujet au débordement.</P>
<P>Les situations risquées où le débordement est très probable sont : 1. quand
un autre processus a désactivé les interruptions (pour un ordinateur), 2.
quand le tampon du port série dans la mémoire principale (ou dans celle du
terminal) est prête à déborder.</P>

<H2><A NAME="ss10.4">10.4 Arrêt de l'envoi</A>
</H2>


<P>Quand le récepteur est sur le point d'être débordé par les octets entrants,
il envoie un signal à l'expéditeur pour arrêter l'envoi.  C'est le contrôle
de flux et les signaux de contrôle de flux sont toujours envoyés dans la
direction opposée au flux de données qu'ils contrôlent (bien que ce ne soit
pas dans le même canal ou le même fil). Ce signal peut être soit un caractère
de contrôle (^S = DC3 = Xoff) envoyé comme un octet de données ordinaire sur
la ligne de données (signalement dans la bande), soit une transition de
tension du positif au négatif dans le fil de signal dtr-vers-cts (ou autre ;
signalement hors-bande). L'utilisation de Xoff est appelée "contrôle de flux
logiciel" et l'utilisation du saut de tension dans un fil de signal dédié (à
l'intérieur du câble) est appelée contrôle de flux matériel.</P>

<H2><A NAME="keybrd_lock"></A> <A NAME="ss10.5">10.5 Blocage du clavier</A>
</H2>


<P>Avec les terminaux, le cas le plus commun "d'arret d'envoi", est quand 
le terminal ne peut pas suivre avec les caractères qui lui sont envoyés
et qui en conclut par un "arret" du PC. Un autre cas, est quand quelqu'un 
presse control-S. Un autre cas un peu moin commun, est l'opposé, quand le PC 
ne peut plus suivre votre vitesse de frappe et dit au terminal d'arrêter 
l'envoi. Le terminal "bloque" le clavier et un message ou une lumière devrait 
vous informer que le clavier est bloqué. Tout ce que vous tapez sur
un clavier bloqué est ignoré. </P>
<P>Le terme "bloqué" est aussi quelque fois utilisé pous les cas où l'on dit 
à l'ordinateur d'arrêter d'envoyer à un terminal. Le clavier n'est pas
bloqué, afin que tout ce que vous tapez soit envoyé à l'ordinateur, mais
puisque l'ordinateur ne peut rien vous renvoyer, les caractères que vous
tapez ne s'affichent pas sur l'écran et il peut sembler que le clavier est
bloqué. Le défilement est bloqué (scroll lock) mais le clavier n'y est pas.</P>

<H2><A NAME="ss10.6">10.6 Reprendre l'envoi</A>
</H2>


<P>Quand le récepteur a rattrapé son retard dans le traitement et est prêt à
recevoir plus d'octets de données il envoie un signal à l'envoyeur. Pour le
contrôle de flux logiciel ce signal est le caractère de contrôle ^Q = DC1 =
Xon qui est envoyé sur la ligne de données normale. Pour le contrôle de flux
matériel la tension dans une ligne de signal passe de négative (niée) à
positive (affirmée). Si on dit à un terminal de reprendre la transmission le
clavier est alors débloqué et prêt à être utilisé.</P>

<H2><A NAME="hdw_flow_control"></A> <A NAME="ss10.7">10.7 Contrôle de flux matériel (RTS/CTS, etc.)</A>
</H2>


<P>Certains terminaux anciens n'offrent pas de contrôle de flux matériel alors
que d'autres offraient un assortiment varié de broches diverses sur le port
série pour le faire. Pour une liste des differentes borches, aller voir 
<A HREF="#null_modem_pinout">Brochage standard d'un cable null-modem</A>.
La broche la plus en vogue actuellement semble être la
broche DTR (ou les broches DTR et DSR ensemble).</P>

<H3>Contrôle de flux RTS/CTS, DTR et DTR/DSR</H3>


<P>Les PC Linux utilisent RTS/CTS mais le contrôle de flux DTR/DSR (utilisé par
certains terminaux) se comporte de la même manière. Le contrôle de flux DTR
(dans une seule direction et aussi utilisé par certains terminaux) n'est que
la partie DTR du contrôle de flux DTR/DSR.</P>
<P>RTS/CTS utilise les broches RTS et CTS sur le connecteur série (EIA-232). RTS
veut dire "Request To Send" (demande d'envoyer). Quand cette broche reste en
position haute (tension positive) sur le récepteur cela veut dire&nbsp;:
continuez de m'envoyer des données. Si RTS passe en position basse (la
tension devient négative), cela nie "demande d'envoyer", ce qui veut dire :
arrêtez d'envoyer. Quand le récepteur est prêt à recevoir plus de données, il
relance RTS, demandant à l'autre côté de reprendre l'envoi. Pour les
ordinateurs et les terminaux (tous les deux des équipements terminaux) la
broche RTS envoie le signal de contrôle de flux à la broche CTS (Clear To
Send, prêt à envoyer) de l'autre côté du câble. C'est-à-dire que la broche
RTS à un bout du câble est reliée à la broche CTS à l'autre bout du câble.</P>
<P>Pour un modem (équipement de connexion) le principe est différent puisque la
broche RTS du modem reçoit le signal et sa broche CTS l'envoie. Alors que
ceci peut sembler déroutant, il y a des raisons historiques correctes pour
l'expliquer, raisons qui sont trop compliquées pour en discuter ici.</P>
<P>Les terminaux disposent en général du contrôle de flux DTR ou DTR/DSR. Le
contrôle de flux DTR est le même que le contrôle de flux DTR/DSR mais il est
unidirectionnel et la broche DSR n'est pas utilisée. En ce qui concerne le
contrôle de flux DTR/DSR sur un terminal, le signal DTR est comme le signal
envoyé de la broche RTS, et la broche DSR est simplement comme la broche CTS.</P>

<H3>Etablir une connexion avec le contrôle de flux DTR ou DTR/DSR</H3>


<P>Certains terminaux n'utilisent que le contrôle de flux DTR. C'est un contrôle de
flux unidirectionnel uniquement pour empêcher le terminal d'être dépassé. Il
ne protège pas l'ordinateur de quelqu'un qui tape trop vite pour que
l'ordinateur puisse gérer la situation. Dans un câble null modem classique la
broche DTR du terminal est reliée à la broche DSR de l'ordinateur. Linux, par
contre, ne supporte pas le contrôle de flux DTR/DSR (bien que des pilotes
pour des cartes multiports peuvent supporter le contrôle de flux DTR/DSR). Un
moyen de contourner ce problème est simplement de relier la broche DTR à la
broche CTS sur l'ordinateur et d'activer le contrôle de flux RTS/CTS (stty
crtscts).  Le fait que ce soit unidirectionnel ne changera rien tant que
l'hôte n'est pas dépassé par votre vitesse de frappe et ne lâche RTS en une
vaine tentative pour bloquer votre clavier. Voyez 
<A HREF="#keybrd_lock">blocage du clavier</A>. Pour obtenir le contrôle de flux DTR/DSR (si
votre terminal supporte ce type de contrôle de flux bidirectionnel) vous
faites ce qui est décrit ci-dessus. Mais vous connectez aussi la broche DSR
sur le terminal à la broche RTS sur l'ordinateur. Vous êtes alors protégé si
vous tapez trop rapidement.</P>

<H3>L'ancienne prise de contact RTS/CTS est différente</H3>


<P>Ce qui est déroutant est que l'utilisation d'origine de RTS veut dire à peu
près le contraire de l'explication précédente ci-dessus. La signification
d'origine est : je demande à vous envoyer (I Request To Send to you). Cette
requête était destinée à être envoyée d'un terminal (ou d'un ordinateur) vers
un modem qui, s'il décidait d'accorder la requête, renvoyait un CTS
affirmatif à partir de sa broche CTS vers la broche CTS de l'ordinateur :
vous êtes autorisé à m'envoyer (You are Cleared To Send to me). Notez qu'au
contraire du contrôle de flux RTS/CTS bidirectionnel du modem, ceci ne
protège le flux que dans une direction : de l'ordinateur (ou du terminal)
vers le modem.</P>
<P>Pour de vieux terminaux, RTS peut avoir cette signification et devient
positif quand le terminal doit envoyer des données. L'utilisation ci-dessus
est une forme de contrôle de flux puisque si le modem veut que l'ordinateur
arrête d'envoyer il lâche CTS (connecté au CTS de l'ordinateur) et
l'ordinateur arrête d'envoyer.</P>

<H3>Canal inversé</H3>


<P>Les vieux terminaux à sortie papier peuvent avoir une broche de canal inversé
(comme la broche 19) qui se comporte comme la broche RTS dans le contrôle de
flux RTS/CTS. Cette broche passera aussi en négatif s'il n'y a plus de papier
ou de ruban. Il est souvent possible de relier cette broche à la broche CTS
de l'ordinateur hôte. Il peut y avoir un petit interrupteur pour positionner
la polarité de ce signal.</P>

<H2><A NAME="ss10.8">10.8 Est-ce que le contrôle de flux matériel est fait par le matériel ?</A>
</H2>


<P>Certains pensent que le contrôle de flux matériel est fait par le matériel
mais (sauf si vous utilisez une carte série intelligente avec plusieurs ports
série) c'est en réalité votre système d'exploitation qui s'en charge. Les
puces UART et le matériel associé ne connaissent en général rien du contrôle
de flux matériel. Quand un signal de contrôle de flux matériel est reçu, le
fil du signal inverse la polarité. Ce changement d'état est enregistré dans 
un registre de port série qui est vérifié par le pilote série avant de mettre 
les octets dans les tampons materiels de 16 octets. Si le fil du 
control de flux dit "stop", il n'y a plus d'octets ajoutés et le flux sortant 
des lignes séries s'arrete. </P>
<P>Il y'a un autre moyen qui aurait pu être implementer depuis que la polarité 
s'inverse, le materiel aurait pu être configuré pour envoyer un signal 
éléctrique d'interruption au processeur. Alors le processeur arreterait ce 
qu'il était en train de faire, se brancherait a un sous-programme de service 
du pilote série, verifierait les registres dans lesquels le port serie a laissé des traces pour trouver ce qui s'est passé, et fais un rapport, pour ne pas 
redémarrer le flux apres que le sous programme de service soit quitté. Cela doit être un peu plus efficace, mais il semble que Linux n'agisse pas comme ca.
A mon avis.</P>
<P>Noter qu'avec l'une ou l'autre des methodes, le flux d'octets s'arrette 
quasiment instantanement. Cependant tous les octets (jusqu'à 16) qui étaient 
déjà dans le tampon de transmission matériel du port série seront encore 
transmis. Utiliser un control de flux logiciel requiert que chaque octet 
arrivant soit verifié pour voir si c'est un octet "eteint". Ces octets sont 
retardés en passant à travers le tampon de réception de 16 octets. Si l'octet 
"éteint" était le premier octet dans ce tampon, il pourrait y avoir une 
attente le temps que 15 octets soient reçus. Alors les 16 octets lus seraient 
obtenus et l'octet "éteint" trouvé. Cette attente supplementaire n'arrive pas 
avec un control de flux materiel.</P>

<H2><A NAME="ss10.9">10.9 Obsolète ?? Contrôle de flux ETX/ACK ou ENQ/ACK</A>
</H2>


<P>Ceci est aussi du contrôle de flux matériel et nécessite un pilote de
périphérique qui sait le traiter. Les octets sont envoyés par paquets (grâce
au port série asynchrone), chaque paquet étant terminé par un caractère de
contrôle ETX (End of Text, fin de texte). Quand le terminal reçoit un ETX il
attend jusqu'à ce qu'il soit prêt à recevoir le paquet suivant et retourne
alors un ACK (Acknowledge, acquittement). Quand l'ordinateur reçoit le ACK,
il envoie le paquet suivant. Et ainsi de suite. Ceci n'est pas supporté par
Linux ?? Certains terminaux HP utilisent la même méthode mais utilisent ENQ
au lieux de ETX.</P>

<H2><A NAME="cable"></A> <A NAME="s11">11. Connexion physique</A></H2>


<P>Les cartes multiports permettent de relier plusieurs terminaux (ou modems) à
un ordinateur. On peut relier un terminal à son ordinateur hôte soit par une
connexion directe par câble, soit par un modem, ou encore par l'intermédiaire
d'un serveur de terminaux.</P>

<H2><A NAME="ss11.1">11.1 Cartes d'entrées/sorties multiports (adaptateurs)</A>
</H2>


<P>On peut acheter des cartes série supplémentaires qui possèdent plusieurs
ports série, et qu'on appelle "cartes multiports". Ces cartes ne sont pas
détaillées dans ce HOWTO mais on en parle beaucoup dans le HOWTO Serial. Une
société qui fait des prix en dessous de la moyenne est 
<A HREF="http://www.byterunner.com/cgi-bin/goto.cgi?FILE=iocards.html">ByteRunner</A>.</P>

<H2><A NAME="ss11.2">11.2 Connexion directe par câble</A>
</H2>


<P>La manière la plus simple de relier un terminal à un ordinateur hôte est par
l'intermédiaire d'une connexion directe vers un port série de l'ordinateur.
La plupart des PC possèdent deux ports série, mais la souris en utilise en
général un. Vous pouvez aussi utiliser quelques infos dans cette section 
pour connecter un ordinateur a un autre(par le port série). 
Pour le port EIA-232, vous avez besoin d'un câble null modem qui
croise les fils de transmission et de réception. Si vous voulez faire du
contrôle de flux matériel, vous utiliserez sûrement la broche DTR (ou les
broches DTR et DSR ensemble).</P>
<P>Assurez-vous que vous avez le bon type de câble. Un câble null modem acheté
dans un magasin d'ordinateurs peut être bon (s'il est assez long), mais ne
fonctionnera probablement pas bien pour le contrôle de flux matériel. Ce
genre de câble peut être étiqueté comme un câble pour imprimante série.
Voyez ceci pour vous aider à déterminer si vous devez 
<A HREF="#buy_or_make_cable">acheter ou fabriquer</A> votre propre câble.
Assurez-vous que vous utilisez votre port série, la prise mâle DB25 ou DB9,
et non pas votre port parallèle (prise DB25 femelle ou Centronics).</P>

<H3>Schéma de brochage des câbles null modem (3, 4 ou 5 conducteurs)</H3>


<P>Ces 3 diagrammes sont pour les vrais terminaux textes. Mais vous pouvez les 
utiliser pour connecter 2 PC si vous remplacer RTS par DTR et CTS par DSR. 
(N'utilisez pas 4 conducteurs pour PC à PC). Pour les terminaus, si vous 
n'avez que le contrôle de flux DTR (unidirectionnel), vous pouvez
éliminer le fil RTS-vers-DSR. Si vous n'avez pas de contrôle de flux
matériel, vous pouvez alors aussi éliminer le fil CTS-vers-DTR. Alors, si
vous avez deux paires torsadées, vous pouvez utiliser deux fils pour la masse
du signal comme indiqué à 
<A HREF="#twist_pair_kludge">une astuce qui utilise du câble en paire torsadée</A>. Pour un connecteur DB25 sur votre PC,
vous avez besoin de&nbsp;:</P>
<P>
<PRE>
 
  PC DB25 mâle                         Terminal DB25
    TxD   Transmit Data       2 --> 3       RxD   Receive Data
    RxD   Receive Data        3 &lt;-- 2       TxD   Transmit Data
    SG    Signal Ground       7 --- 7       SG    Signal Ground
    CTS   Clear To Send       5 &lt;-- 20      DTR   Data Terminal Ready  
    RTS   Request To Send     4 --> 6       DSR   Data Set Ready
</PRE>
</P>
<P>Si vous avez un connecteur DB9 sur votre PC, essayez le schéma suivant&nbsp;:</P>
<P>
<PRE>
       PC DB9                                  Terminal DB25 
    RxD   Receive Data        2 &lt;-- 2            TxD   Transmit Data
    TxD   Transmit Data       3 --> 3       RxD   Receive Data
    SG    Signal Ground       5 --- 7       SG    Signal Ground
    CTS   Clear To Send       8 &lt;-- 20      DTR   Data Terminal Ready  
    RTS   Request To Send     7 --> 6       DSR   Data Set Ready   **
</PRE>
</P>
<P>Si vous avec un connecteur DB9 sur tous vos ports séries et terminal&nbsp;:</P>
<P>
<PRE>
       PC DB9                                  Terminal DB25 
    RxD   Receive Data        2 &lt;-- 3            TxD   Transmit Data
    TxD   Transmit Data       3 --> 2       RxD   Receive Data
    SG    Signal Ground       5 --- 5       SG    Signal Ground
    CTS   Clear To Send       8 &lt;-- 4       DTR   Data Terminal Ready  
    RTS   Request To Send     7 --> 6       DSR   Data Set Ready   **
</PRE>
</P>
<P>Les schémas ci-dessus n'ont pas de lignes de contrôle de modem, soyez donc
sûr de donner une option "local" à getty (ce qui est équivalent à "stty
clocal"). De plus si vous avez besoin du contrôle de flux matériel il doit
être activé du côté de votre ordinateur (utilisez le drapeau -h avec agetty)
(équivalent à "stty crtscts").</P>

<H3><A NAME="null_modem_pinout"></A> Brochage d'un câble null modem standard (7 connecteurs)</H3>


<P>Les 3 diagrammes suivants montrent des câbles null modem "standards" 
complets. Si vous en achetez un, il risque d'être câblé de cette manière. Ils
fonctionneront pour les terminaux en utilisant le contrôle de flux logiciel
(Xon/Xoff), ou sans contrôle de flux. Cependant, ils ne fonctionnent pas pour
le contrôle de flux matériel de terminal puisque la plupart des vrais 
terminaux supportent le contrôle de flux DTR ou DTR/DSR (prise de contact) 
mais que Linux ne le fait pas.</P>
<P>
<PRE>
PC DB25 mâle                            Terminal DB25
TxD   Transmit Data         2 --> 3     RxD   Receive Data
RxD   Receive Data          3 &lt;-- 2     TxD   Transmit Data
RTS   Request To Send       4 --> 5     CTS   Clear To Send
CTS   Clear To Send         5 &lt;-- 4     RTS   Request To Send
DSR   Data Set Ready        6
                            |
DCD   Carrier Detect        8 &lt;-- 20    DTR   Data Terminal Ready
SG    Signal Ground         7 --- 7     SG    Signal Ground
                                  6     DSR   Data Set Ready
                                  |
DTR   Data Terminal Ready  20 --> 8     DCD   Carrier Detect
</PRE>

<A NAME="DB_pin-out"></A> </P>
<P>Autrement, voici un câble null modem DB9-DB25 (ne fonctionnera pas avec la
prise de contact matérielle des terminaux ; voir ci-dessus) :</P>
<P>
<PRE>
PC DB9                                  Terminal DB25
RxD   Receive Data          2 &lt;-- 2     TxD   Transmit Data
TxD   Transmit Data         3 --> 3     RxD   Receive Data
                                  6     DSR   Data Set Ready
                                  |
DTR   Data Terminal Ready   4 --> 8     DCD   Carrier Detect
GND   Signal Ground         5 --- 7     GND   Signal Ground
DCD   Carrier Detect        1
                            |
DSR   Data Set Ready        6 &lt;-- 20    DTR   Data Terminal Ready
RTS   Request To Send       7 --> 5     CTS   Clear To Send
CTS   Clear To Send         8 &lt;-- 4     RTS   Request To Send
RI    Ring Indicator        9 (pas nécessaire)
</PRE>
</P>
<P>(Oui, les broches 2 et 3 <EM>ont vraiment</EM> des significations opposées dans
les connecteurs DB9 et DB25 !)</P>
<P>Voici comment connecter 2 DB9 ensemble en null-modem (mais le flux de control 
DTR ne marchera pas)&nbsp;:</P>
<P>
<PRE>
PC DB9                                  Terminal DB25
RxD   Receive Data          2 &lt;-- 3     TxD   Transmit Data
TxD   Transmit Data         3 --> 2     RxD   Receive Data
                                  6     DSR   Data Set Ready
                                  |
DTR   Data Terminal Ready   4 --> 1     DCD   Carrier Detect
GND   Signal Ground         5 --- 5     GND   Signal Ground
DCD   Carrier Detect        1
                            |
DSR   Data Set Ready        6 &lt;-- 4     DTR   Data Terminal Ready
RTS   Request To Send       7 --> 8     CTS   Clear To Send
CTS   Clear To Send         8 &lt;-- 7     RTS   Request To Send
RI    Ring Indicator        9 (pas nécessaire)
</PRE>
</P>

<P>L'utilisation des deux connexions ci-dessus fournit des signaux de contrôle
de modem complets et de même nous permettent de positionner "stty -clocal".
On doit alors allumer le terminal en premier (pour lancer DTR) avant de
pouvoir ouvrir le port de manière normale par getty, etc. Mais il risque d'y
avoir des problèmes si vous n'allumez pas le terminal en premier (voyez 
<A HREF="#fast_respawn">getty se relance trop rapidement</A>). Pour cette
raison, on devrait utiliser "stty clocal" qui est la valeur par défaut
(ignore les lignes de contrôle du modem) et les fils supplémentaires dans ces
câbles ne servent alors à rien d'utile.</P>
<P>Dans les jours anciens où il n'était pas si facile d'ignorer les signaux de
contrôle du modem, etc., on utilisait "l'astuce" suivante pour les câbles qui
n'avaient pas les fils pour le contrôle de modem : du côté ordinateur du
connecteur, on reliait RTS et CTS ensemble, et on connectait aussi DSR, DCD
et DTR ensemble. De cette manière, quand l'ordinateur avait besoin d'un
certain signal de prise de contact pour continuer, il l'obtenait (par erreur)
de lui-même.</P>

<H3>Limitations de longueur</H3>


<P>Un câble de plus de 15 mètres environ (50 pieds) peut ne pas fonctionner
correctement à grande vitesse. Des longueurs bien plus grandes fonctionnent
parfois correctement, surtout si la vitesse est basse et/ou le câble est de
type basse capacitance et/ou l'électronique de la partie réception est très
sensible. On dit que sous certaines conditions idéales à 9600 bauds, un câble
de 1000 pieds (300 mètres) fonctionne correctement. Une manière de couvrir de
longues distances est d'installer un pilote de ligne près de chaque port
série afin de convertir des signaux asymétriques en symétriques (et
inversement)  et d'utiliser ensuite du câblage en paire torsadée. Mais les pilotes de
lignes sont chers.</P>

<H3>Câbles pour le contrôle de flux matériel </H3>


<P>Si vous voulez faire du contrôle de flux matériel (prise de contact) vous
aurez certainement besoin de fabriquer votre propre câble (ou de le faire
faire). Bien sûr, si les connecteurs à chaque extrémité d'un câble usagé
s'enlèvent, vous pouvez le reconnecter. Voyez 
<A HREF="#db_conn_install">installation de connecteurs DB</A>. Vous devrez déterminer si oui ou non
le terminal utilise la broche DTR pour cela, et sinon, quelle(s) broche(s) il
utilise. Les menus de configuration peuvent vous donner des indices là-dessus
puisqu'il peut y avoir une option pour activer la "prise de contact DTR" (ou
le contrôle de flux), ce qui implique bien sûr qu'il utilise la broche DTR.
Il peut aussi utiliser la broche DSR. Voyez 
<A HREF="#hdw_flow_control">contrôle de flux matériel</A> pour une explication détaillée. Des
terminaux anciens peuvent ne rien fournir pour faire du contrôle de flux
matériel.</P>

<H3>Astuces sur les câbles</H3>


<P>Un câble "droit" normal ne fonctionnera pas sauf si vous l'utilisez comme
câble d'extension couplé soit à un câble null modem, soit à un adaptateur
null modem. Assurez-vous que les connecteurs au bout du câble se brancheront
dans les connecteurs matériels. On peut utiliser du câble de téléphone qui a
au moins 4 conducteurs (et peut-être en paire torsadée). Un câble
d'ordinateur spécial de basse capacitance, blindé, est mieux.</P>

<H3><A NAME="twist_pair_kludge"></A> Une bidouille qui utilise un câble en paire torsadée</H3>


<P>Bien qu'aucun signal EIA-232 ne soit stabilisé pour de la paire torsadée on
peut tenter d'utiliser un câble en paire torsadée. Utilisez une paire pour la
transmission et l'autre pour la réception. Pour faire ceci connectez le
signal de terre à un fil sur chacune de ces deux paires. Une partie seulement
du signal de terre passe dans le fil désiré mais ça peut aider. À cause de
l'inductance plus faible du circuit en paire torsadée (comparée au courant de
retour de masse par un autre chemin), un peu plus de courant de retour
(terre) se massera sur le chemin désiré que ce qu'on pourrait attendre des
seuls calculs de résistances. Ceci est surtout vrai à des fréquences plus
élevées puisque l'impédance d'induction augmente avec la fréquence. La courbe
rectangulaire du port série contient des harmoniques de haute fréquence.</P>

<H3>Mise à la terre du câble</H3>


<P>La broche 1 (d'une prise DB25) devrait être reliée à la masse du châssis (qui
est aussi la masse de la terre) mais sur les ports série économiques il peut
n'être connecté à rien du tout. Un connecteur 9 broches n'est même pas relié
à la masse du châssis. La masse du signal est la broche&nbsp;7 et est en
général reliée à la masse du châssis. Cela veut dire qu'une partie du courant
du signal passera dans les fils de masse de l'installation électrique du
bâtiment (indésirable). Les blindages de câbles sont sensés n'être mis à la
terre qu'à une seule extrémité du câble, mais il peut être mieux de relier
les deux extrémités à la terre puisqu'il est mieux d'avoir du courant dans le
blindage que dans l'installation électrique du bâtiment&nbsp;??</P>

<H2><A NAME="ss11.3">11.3 Connexion sur un modem</A>
</H2>


<P>En utilisant une combinaison terminal-modem (sans ordinateur) on peut se
connecter à des BBS. Certains BBS (comme free-nets) permettent un accès à
Internet grâce au navigateur texte lynx qui fonctionnera sur les terminaux
texte. Ainsi avec un vieux terminal et un modem externe, on peut se connecter
à Internet. Si on se connecte à un ordinateur hôte sur lequel on a un compte,
on peut parfois y stocker ses fichiers (ou ses téléchargements).</P>

<H3>Appeler à l'extérieur à partir d'un terminal</H3>


<P>Au lieu de relier un terminal (ou un ordinateur émulant un terminal)
directement à un ordinateur hôte en utilisant un câble, il peut être relié à
l'hôte par l'intermédiaire d'une ligne téléphonique (ou d'une liaison
spécialisée dédiée) avec un modem à chaque bout de la ligne. Le terminal (ou
l'ordinateur) appellera en général un ordinateur hôte avec une ligne
téléphonique.</P>
<P>La plupart des gens utilisent un PC et un modem pour appeler vers
l'extérieur. Le PC peut posséder un terminal relié à un port série et la
personne sur le terminal peut appeler par l'intermédiaire du PC. La connexion
d'un vrai terminal directement sur le modem externe est plus difficile car le
vrai terminal n'est pas très intelligent et ne donne pas autant de retour à
l'utilisateur. Pour appeler à l'extérieur, beaucoup de terminaux peuvent
stocker un ou plusieurs numéros de téléphone comme des messages qu'on peut
leur "paramétrer". Ces numéros sont envoyés au modem en pressant certaines
touches de fonction. Beaucoup de modems peuvent aussi stocker des numéros de
téléphone.  La séquence d'initialisation du modem doit précéder le numéro de
téléphone. Quande un autre modem répond à un appel sortant a l'autre bout de 
la ligne téléphonique, l'ordinateur hote sur ceux modem doit lancer un 
programme getty pour vous puissiez vous connectez.</P>

<H3>On peut appeler un terminal</H3>


<P>Il est courant pour un ordinateur faisant tourner Linux de se faire appeler
par téléphone. L'appelant obtient une invite de login et se logge. À première
vue, il peut sembler étrange qu'un terminal simple (relié à aucun ordinateur)
puisse accepter un appel entrant, mais il le peut. Une des raisons possibles
de faire ainsi est d'économiser les factures de téléphone quand les tarifs ne
sont pas symétriques. Votre terminal doit être configuré pour un appel
entrant&nbsp;: mettez le modem derrière votre terminal en mode réponse
automatique (auto answer, registre S0 mis à 2 répondra à la deuxième
sonnerie). Vous allumez le terminal et le modem avant d'attendre un appel et
quand l'appel arrive vous obtenez une invite de login et vous vous loggez.</P>
<P>L'ordinateur hôte qui appelle votre terminal doit faire quelque chose
d'inhabituel. Aussitôt que votre modem répond, il doit lancer login (getty).
Un hôte peut faire ceci en lançant le programme Linux "callback", parfois
appelé "cb". Le callback (ou rappel) c'est l'ordinateur A qui appelle
l'ordinateur B, B raccroche et rappelle A. C'est ce que vous voulez si vous
utilisez l'ordinateur A pour émuler un terminal. Dans le cas d'un vrai
terminal cette tâche peut être trop complexe et par conséquent l'hôte
n'utilise que la partie retour du programme callback. Le fichier de
configuration de callback doit être configuré correctement sur l'hôte.
Callback appelle le terminal et ensuite dit à mgetty de lancer un login sur
ce port. Mgetty lui-même (au début 1998) ne sait gérer que les appels
entrants mais on travaille sur l'incorporation de possibilités de rappel
automatique et le rendre ainsi capable de gérer les appels sortants. Au début
de 1999, cela ne semblait pas avoir été réalisé.</P>

<H2><A NAME="ss11.4">11.4 Connexion à un serveur de terminaux</A>
</H2>


<P>Une utilisation possible est de connecter beaucoup de terminaux (ou des
modems) à un réseau à haut débit qui permet la connexion à des ordinateurs
hôtes. Bien sûr le serveur de terminaux doit avoir la puissance de calcul et
les logiciels pour faire tourner des protocoles réseau, il ressemble donc à
un ordinateur. Le serveur de terminaux peut interagir avec l'utilisateur et
demander sur quel ordinateur il veut se connecter, etc. ou il peut le
connecter sans rien demander. On peut parfois envoyer des travaux à une
imprimante à travers un serveur de terminaux.</P>
<P>Un PC de nos jours a suffisamment de puissance de calcul pour agir comme un
serveur de terminaux pour des terminaux texte sauf que chaque port série
devrait avoir sa propre interruption matérielle. Les PC ne possèdent que peu
d'interruptions libres à cette fin et puisqu'elles sont configurées en dur on
ne peut pas en créer davantage par logiciel. Une solution est d'utiliser une
carte série multiport avancée qui possède son propre système d'interruptions
(ou sur les modèles de plus bas prix, partage l'une des interruptions du PC
entre un certain nombre de ports). Voyez le HOWTO Serial pour plus
d'informations sur de telles cartes. Si un tel PC fait tourner Linux avec
getty tournant sur beaucoup de ports série on peut le considérer comme un
serveur de terminaux s'il est relié à d'autres PC sur un réseau et si son
travail est principalement de transférer les données et de gérer les
interruptions du port série tous les 14 octets (ou à peu près). On utilise
parfois un logiciel appelé "radius".</P>
<P>De nos jours les vrais serveurs de terminaux servent plus que de simples
terminaux. Ils servent aussi des PC qui émulent des terminaux, et sont
parfois reliés à des racks de modems reliés à des lignes téléphoniques.
Certains contiennent parfois des modems intégrés. Si un terminal (ou un PC en
émulant un) est relié directement à un modem, le modem à l'autre bout de la
ligne devrait être relié à un serveur de terminaux. Dans certains cas le
serveur de terminaux par défaut s'attend à ce que l'appelant utilise des
paquets PPP, quelque chose que les vrais terminaux texte ne génèrent pas.</P>

<H2><A NAME="ss11.5">11.5 Types de connecteurs et d'adaptateurs</A>
</H2>


<P>Un connecteur est plus ou moins relié de façon permanente à l'extrémité d'un
câble ou à une unité matérielle. Il y a deux types de connexions de base : 1.
DBxx avec des broches et 2. des connecteurs modulaires de type téléphone.</P>
<P>Un adaptateur ressemble à peu près à un connecteur mais il possède deux
extrémités. C'est comme un câble qui est si court qu'il ne reste plus de
partie câblée du tout -- il ne reste que des connecteurs différents sur
chaque extrémité. L'adaptateur se branche de chaque côté. Il permet de relier
entre eux deux connecteurs incompatibles en s'interposant entre les deux.
Quelquefois le but de l'adaptateur est d'interchanger les fils.  Évidemment,
on peut utiliser un câble spécial (éventuellement fait maison) pour remplacer
pour cet adaptateur.</P>

<H3>Sexe des connecteurs / adaptateurs</H3>


<P>Les connecteurs (ou un côté des adaptateurs) sont soit mâles soit femelles.
Les connecteurs qui ont des broches sont mâles et ceux qui ont des "trous"
sont femelles. Pour les connecteurs modulaires, ceux qui ont les contacts
visibles sont les fiches tandis que ceux qui ont les contacts à l'intérieur
(pas facile à voir) sont les prises.  Les fiches sont mâles ; les prises sont
femelles (NdT : mais en français on dit aussi prise pour un connecteur mâle).</P>

<H3>Types d'adaptateurs</H3>


<P>Il y a trois type d'adaptateurs de base : les null modem, les changeurs de
genre et les adaptateurs de ports. Certains adaptateurs effectuent plus d'une
fonction parmi ces trois fonctions.</P>
<P>
<UL>
<LI>adaptateur null modem : croise certaines connexions, comme un câble
null modem.
</LI>
<LI>changeur de genre : change le sexe d'une extrémité d'un câble. Deux
connecteurs du même sexe peuvent maintenant être reliés l'un à l'autre.
</LI>
<LI>adaptateur de port : va d'un type de connecteur à un autre (DB9 vers
DB25, etc.).
</LI>
</UL>
</P>

<H3><A NAME="db_conn"></A> Connecteurs DB</H3>


<P>Pour savoir comment installer un connecteur DB à l'extrémité d'un câble,
voyez 
<A HREF="#db_conn_install">installer des connecteurs DB</A>.
Ceux-ci sont disponibles en 9 ou 25 broches. Les spécifications EIA-232
demandent des 25 broches mais puisque la plupart de ces broches ne sont pas
utilisées sur les ports série ordinaires, 9 broches sont suffisantes. Voyez
<A HREF="#DB_pin-out">DB9-DB25</A> pour la signification des brochages.
Les broches sont en général numérotées si vous regardez de suffisamment près
ou si vous utilisez une loupe grossissante.</P>

<H3><A NAME="rj_conn"></A> Connecteurs modulaires RJ</H3>


<P>Ceux-ci ressemblent à des connecteurs de téléphone modernes mais ne sont
parfois pas compatibles avec les connecteurs téléphoniques. Voyez aussi 
<A HREF="#rj_conn_install">installer des connecteurs RJ</A>. Il peut y avoir 6,
8 ou 10 conducteurs. RJ11/14 est une fiche de téléphone à 4-6 conducteurs.
Une fiche qui lui ressemble est un connecteur MMJ (6 conducteurs) utilisé sur
certains modèles tardifs de terminaux VT (et autres). MMJ possède une
languette décalée et n'est pas compatible avec RJ11/14. Cependant, certains
connecteurs ont été fabriqués et sont compatibles à la fois avec MMJ et
RJ11/14. Le brochage MMJ est : 1-DTR, 2-TXD, 3-TXD GND, 4-RXD GND, 5-RXD,
6-DSR.</P>
<P>Un câble null modem avec des connecteurs MMJ (ou RJ11/14) reliera : 1-6, 2-5
et 3-4. Notez qu'un tel câble supporte le contrôle de flux DTR/DSR qui n'est
pas (encore) supporté par Linux. Faire vous-même votre propre câble null
modem à 6 conducteurs est très simple si vous comprenez que le câble
téléphonique à 4 conducteurs de votre mur à votre téléphone, utilisé dans des
centaines de millions d'habitations, est aussi un câble null modem.
Trouvez-en un et câblez votre câble de la même façon.</P>
<P>Si vous étalez un tel câble (ou le câble null modem de votre terminal) à plat
sur le sol (sans torsion) vous noterez que les deux fiches aux extrémités ont
leurs contacts dorés dirigés tous les deux vers le haut (ou tous les deux
vers le bas). Bien que ce soit symétrique, c'est aussi null modem si vous y
réfléchissez un peu. On pourrait associer un petit nombre de ces câbles avec
des coupleurs en ligne et tout fonctionnera correctement car chaque coupleur
en ligne est aussi un adaptateur null modem. Deux périphériques null modem en
série donnent une connexion directe.</P>
<P>RJ45 et RJ48 sont des fiches téléphoniques à 8 conducteurs (ou 10 conducteurs
pour certaines applications informatiques). Ceux à 10 conducteurs sont
légèrement plus larges et ne rentreront pas dans des fiches à 8 conducteurs.
On les utilise à la fois pour des câbles téléphoniques plats et des câbles à
paire torsadée ronds. L'extrémité du connecteur côté câble peut être
différent pour les câbles plats et ronds et à la fois RJ45 et RJ48 peuvent
avoir 8 ou 10 conducteurs, donc assurez-vous que vous choisissez le bon. RJ48
possède un taquet supplémentaire ce qui fait qu'une fiche RJ48 ne rentrera
pas dans une prise RJ45 (mais une fiche RJ45 rentrera dans une prise RJ48).
On les utilise sur certaines cartes série multiports et dans les réseaux.
Voici les numéros de broches pour une prise à 8 conducteurs :</P>
<P>
<PRE>
  Fiche                          Prise
  (En regardant à                (En regardant la
   l'extrémité d'un câble)        cavité dans un mur)
     .__________.                   .__________.
     | 87654321 |                   | 12345678 |
     |__.    .__|                   |__.    .__|
        |____|                         |____|
</PRE>
</P>

<H2><A NAME="ss11.6">11.6 Fabriquer ou modifier un câble</A>
</H2>



<H3><A NAME="buy_or_make_cable"></A> Acheter ou fabriquer ?</H3>


<P>Vous pouvez essayer d'acheter un câble null modem court. On les étiquette
souvent comme des câbles d'imprimantes série (mais les imprimantes série ne
sont pas très en vogue de nos jours, ni les câbles associés).
Malheureusement, ils ne fonctionneront probablement pas pour le contrôle de
flux matériel. Assurez-vous que les connecteurs sur les extrémités du câble
conviendront aux connecteurs sur votre ordinateur et votre terminal.</P>
<P>Mais si vous avez besoin de câbles plus longs pour relier des terminaux ou si
vous avez besoin du contrôle de flux matériel, comment obtenez-vous les bons
câbles ? Les bons câbles longs tout prêts peuvent s'avérer difficiles à
trouver (vous pouvez tenter de les chercher sur Internet), surtout si vous
voulez utiliser un minimum (disons 4) de conducteurs. Une option est de les
faire faire spécialement, ce qui risque d'être relativement cher bien que
vous puissiez trouver quelqu'un pour le faire à des prix à peine plus élevés
que ceux tout prêts (c'est ce que j'ai fait). Une autre alternative est de
fabriquer le vôtre. Ceci peut nécessiter des outils spéciaux. Si vous pouvez
en trouver, du câble d'occasion peut s'avérer faire une bonne affaire mais
vous devrez probablement recâbler les connecteurs. La plupart des connecteurs
livrés avec les câbles courts sont moulés de manière permanente sur le câble
et ne peuvent pas être recâblés mais la plupart des câbles faits sur mesure
ou à la main possèdent des connecteurs qu'on peut recâbler. L'avantage de
fabriquer votre propre câble est que les compétences que vous acquérerez
seront utiles si un câble se casse (ou devient mauvais) ou si vous devez
fabriquer un autre câble en vitesse.</P>

<H3>Numéros de broches</H3>


<P>Les numéros des broches devraient être gravées sur la partie plastique du
connecteur. Chaque broche devrait avoir un numéro juste à côté. Vous aurez
peut-être besoin d'une loupe grossissante pour les lire.</P>

<H3><A NAME="db_conn_install"></A> Installer des connecteurs DB sur les extrémités des câbles</H3>


<P>Voyez 
<A HREF="#db_conn">connecteurs DB</A> pour une courte description de
ces connecteurs. Malheureusement, la plupart des câbles achetés de nos jours
possèdent des connecteurs moulés à chaque extrémité qu'on ne peut pas
modifier. Si vous fabriquez des câbles ou en modifiez un existant, vous
devrez apprendre à connaître les broches. Il y en a deux sortes : soudées et
serties.</P>
<P>Les broches serties nécessitent un outil de sertissage spécial et aussi un
outil "d'insertion/extraction". Mais une fois que vous avez les outils,
fabriquer et modifier un câble est plus rapide que de les souder. Si vous
reliez deux fils à la même broche (nécessaire aussi si vous voulez relier une
broche connectée à une autre broche) alors la soudure est plus rapide (pour
ces broches). C'est dû au fait que les broches serties ne peuvent prendre
qu'un fil à la fois, alors que les broches soudées peuvent accepter plus d'un
fil par broche.</P>
<P>Pour insérer des broches serties, poussez-les simplement à la main ou avec
l'outil. Enlever une broche avec l'outil est un peu difficile. Ces
instructions seront mieux compréhensibles si vous avez à la fois l'outil et
les fils devant vous.  Vous devez mettre l'embout de l'outil autour de
l'arrière de la broche et l'insérer aussi profond que possible dans le trou
(environ 1 cm 1/2.). Certains outils ont une marque (comme un tout petit
trou) pour indiquer jusqu'où l'insérer.  L'embout de l'outil devrait avoir un
creux taillé en pointe pour que vous puissiez placer l'embout autour du fil
en le mettant là où le creux est plus large que le fil. L'outil peut avoir
deux embouts. Celui qui est le plus difficile à mettre autour du fil est
aussi celui qui enlève le fil le plus facilement puisqu'il enveloppe presque
complètement le fil.</P>
<P>Avec l'embout proprement inséré, tirez à la fois doucement à la fois sur
l'outil et sur le fil. Si ça ne vient pas, l'outil n'a sûrement pas été
inséré correctement, poussez-le alors plus en avant ou bien tournez-le dans
une position différente (ou les deux). Vous auriez peut-être dû utiliser
l'autre embout qui entoure mieux la broche. En utilisant cet outil, on peut
facilement convertir un câble droit en câble null modem, etc.</P>
<P>Vous pouvez avoir des problèmes en utilisant l'outil
d'"insertion/extraction". Si les outils ne s'insèrent pas sur le derrière de
la broche, il se peut que la broche n'ait pas été sertie correctement sur le
fil et tienne plus du carré que du rond, etc. Si une broche commence à sortir
mais ne se redresse pas en entier, la broche peut être tordue. Regardez-la
sous une loupe grossissante. Redresser une broche avec une pince à épiler
peut endommager le plaquage en or. Parfois une broche coincée peut être
poussée au dehors avec le bout d'une lame de tournevis épaisse (ou quelque
chose de semblable) mais si vous poussez trop fort vous pouvez agrandir le
trou en plastique ou tordre la broche.</P>
<P>N'essayez pas de souder sauf si vous savez ce que vous faites ou avez lu
comment le faire.</P>

<H3><A NAME="rj_conn_install"></A> Installer des connecteurs RJ</H3>


<P>Ce sont des connecteurs modulaires de téléphones, dont une sorte est utilisée
pour la plupart des téléphones ordinaires. Mais il y a beaucoup de sortes
différentes (voyez 
<A HREF="#rj_conn">connecteurs modulaires RJ</A>).</P>
<P>Ils ne sont pas faciles à réutiliser. Vous pourriez retirer les fils, pousser
à l'intérieur un outil pointu qui relèverait les contacts dorés et réutiliser
le connecteur. Il y a des outils de sertissage spéciaux qu'on utilise pour
les installer ; un outil différent pour chaque sorte.</P>
<P>Si vous n'avez pas d'outil de sertissage, l'installation est quand même
possible (mais difficile) en utilisant un petit tournevis (et peut-être un
marteau). Poussez les fils du câble à l'intérieur et ensuite poussez chaque
contact doré vers le bas assez fort avec le petit tournevis qui passera juste
entre les stries isolantes entre les contacts. Vous pouvez l'abîmer si vous
n'utilisez pas un tournevis avec une tête qui a presque la même épaisseur que
les contacts ou si le tournevis glisse du contact alors que vous le poussez
vers le bas. Vous pouvez aussi utiliser un petit marteau pour faire
contrepoids sur le tournevis (poussez d'abord à la main).</P>
<P>Assurez-vous de ne pas abîmer le "levier d'extraction" sur le connecteur
quand vous poussez sur les contacts. Ne le posez pas simplement sur une table
en poussant les contacts. Il est préférable de mettre une cale (d'environ 1
mm d'épaisseur) qui se placera parfaitement dans la crevasse entre le levier
et le corps. Pour une telle cale vous pouvez utiliser du bristol épais,
plusieurs cartes téléphoniques ou du bois. Puisque le dessous du connecteur
(que vous mettrez sur la table) n'est pas droit (à cause du "levier
d'extraction"), assurez-vous que le dessus de la table est recouvert de
quelque chose de mou (comme un morceau de carton) pour aider à supporter le
connecteur qui n'est pas droit. Encore mieux  : vous pourriez mettre une
autre cale d'un millimètre sous les 6 premiers millimètres du connecteur en
le supportant juste en dessous de la partie visible des contacts. Un dessus
de table mou ne peut pas faire de mal non plus. Une autre méthode (je n'ai
jamais fait cela) est de mettre le connecteur dans un étau mais faites
attention à ne pas casser le connecteur.</P>
<P>En comparaison de l'utilisation d'un outil de sertissage, l'installation
comme indiqué ci-dessus prend beaucoup plus de temps et est plus sujette aux
erreurs mais c'est quelquefois plus expéditif et bien moins cher que
d'acheter un outil spécial si vous n'avez qu'un ou deux connecteurs à
installer.</P>

<H2><A NAME="setup_"></A> <A NAME="s12">12. Mise en place (configuration) en général</A></H2>



<H2><A NAME="ss12.1">12.1 Introduction à la configuration</A>
</H2>


<P>La configuration (mise en place) nécessite à la fois de stocker la
configuration dans la mémoire non volatile du terminal et de mettre des
commandes dans les fichiers de démarrage (sur votre disque dur) qui se
lanceront à chaque fois que l'ordinateur est allumé (ou peut-être aussi à
chaque changement de niveau d'exécution). Cette section donne une vue
d'ensemble de la configuration et couvre la configuration des principales
options de communication à la fois pour le terminal et pour l'ordinateur. Les
deux grandes sections suivantes couvrent la configuration du terminal (voyez
<A HREF="#term_conf_details">mise en place du terminal</A> et de
l'ordinateur (voyez 
<A HREF="#comp_conf_details">détails de la mise en place de l'ordinateur (configuration)</A>.</P>

<H2><A NAME="term_conf_ov"></A> <A NAME="ss12.2">12.2 Vue d'ensemble de la mise en place (configuration) du terminal</A>
</H2>


<P>Quand un terminal est installé il est nécessaire de configurer le terminal
physique en sauvant (dans sa mémoire non volatile qui n'est pas perdue
lorsque l'on éteint le terminal) les caractéristiques qu'il aura au
démarrage. Vous pouvez avoir de la chance et avoir un terminal qu'on a déjà
configuré correctement pour votre installation de sorte que peu ou aucune
configuration sur le terminal ne soit nécessaire.</P>
<P>Il y a deux façons simples de configurer un terminal. L'une est de s'asseoir
devant le terminal et de parcourir un ensemble de menus de configuration.
Une autre est d'envoyer des séquences d'échappement au terminal à partir de
l'ordinateur hôte. Avant que vous n'envoyiez quoi que ce soit au terminal
(comme les séquences d'échappement ci-dessus), ses options d'
<A HREF="#commun_config">interface de communication</A> comme la vitesse de
transmission doivent être configurées pour correspondre à celles de
l'ordinateur. On ne peut faire ceci qu'en s'asseyant devant le terminal
puisqu'il faut configurer la communication correctement avant que
l'ordinateur et le terminal ne puissent se "parler". Voyez 
<A HREF="#term_conf_details">configuration du terminal</A>.</P>

<H2><A NAME="ss12.3">12.3 Vue d'ensemble de la mise en place (configuration) de l'ordinateur</A>
</H2>


<P>À part peut-être l'envoi de séquences d'échappement à partir de l'ordinateur
pour configurer le terminal, il faut configurer l'ordinateur lui-même pour
gérer le terminal. Si vous avez de la chance tout ce que vous avez à faire
est d'ajouter une commande "getty" dans le fichier /etc/inittab pour qu'une
invite "login:" soit envoyée au terminal quand l'ordinateur démarre. Voyez
<A HREF="#getty_">getty (dans /etc/inittab)</A> pour plus de détails.</P>
<P>L'ordinateur communique avec le terminal en utilisant un logiciel de pilote
de périphérique (qui fait partie du noyau). Le pilote de périphérique série
possède une configuration par défaut et est aussi configuré en partie
(parfois en totalité) par le programme getty avant de lancer "login" sur
chaque terminal. Cependant, des configurations supplémentaires sont souvent
nécessaires en utilisant des programmes appelés "stty" et "setserial". Ces
programmes (si besoin est) doivent être lancés à chaque fois que l'ordinateur
démarre puisque la configuration est perdue à chaque fois que l'ordinateur
s'éteint. Voyez 
<A HREF="#comp_conf_details">détails de la mise en place de l'ordinateur (configuration)</A>.</P>

<H2><A NAME="ss12.4">12.4 Beaucoup d'options</A>
</H2>


<P>Il y a énormément d'options de configuration dans lesquelles vous pourrez
piocher. Les options de communication doivent être correctes ou le terminal
ne fonctionnera pas du tout. D'autres options peuvent être incorrectes, mais
ne causeront pas de problèmes puisque les possibilités qu'elles introduisent
ne sont pas utilisées. Par exemple, si vous n'avez pas d'imprimante reliée au
terminal, la manière dont sont positionnés les paramètres de configuration de
l'imprimante dans le terminal n'a aucun effet. Cette dernière affirmation
n'est pas correcte à 100 %.  Supposez que vous n'avez pas d'imprimante mais
que l'ordinateur envoie (par erreur) au terminal une commande pour rediriger
tous les caractères (les données) de l'ordinateur vers l'imprimante
uniquement. Alors rien ne s'affichera sur l'écran et votre terminal sera
mort. Certains terminaux possèdent une option de configuration pour informer
le terminal qu'aucune imprimante n'est présente. Dans ce cas le terminal
ignorera toute commande qui redirigerait la sortie vers "l'imprimante" et le
problème ci-dessus n'arrivera jamais. Cependant, ceci n'apporte pas beaucoup
d'aide puisqu'il y a beaucoup d'autres commandes erronnées qu'on peut envoyer
à votre terminal et qui sèmeront vraiment la pagaille. Cela arrivera sûrement
si vous envoyez un fichier binaire au terminal par accident.</P>
<P>Dans certains cas un paramètrage incorrect ne causera aucun problème jusqu'à
ce qu'il vous arrive de lancer une application peu connue qui attend du
paramètre qu'il soit positionné d'une certaine façon. Certaines options ne
concernent que l'apparence de l'affichage et le terminal fonctionnera
correctement si elles sont mal positionnées mais ne sera pas aussi beau à
regarder.</P>
<P>Certaines options ne concernent que le terminal et n'ont pas besoin d'être
positionnées sur l'ordinateur. Par exemple : voulez-vous des lettres noires
sur un fond clair ? C'est plus agréable à l'oeil qu'un fond noir. Une touche
qu'on appuie doit-elle se répéter ? Est-ce que l'écran doit défiler quand une
ligne dépasse le bord droit de l'écran ? Est-ce que les touches doivent
émettre un cliquetis ?</P>

<H2><A NAME="commun_config"></A> <A NAME="ss12.5">12.5 Options de l'interface de communication</A>
</H2>


<P>Certains paramètres (options) de communication concernent à la fois le
terminal et l'ordinateur et doivent être positionnés exactement à l'identique
sur les deux : vitesse, parité, bits/caractères et contrôle de flux. D'autres
options de communication ne sont positionnées que sur le terminal (et
uniquement certaines d'entre elles sont essentielles pour établir une
communication). D'autres encore comme l'adresse et l'interruption (IRQ) du
port physique ttyS ne sont positionnées que sur l'ordinateur en utilisant la
commande "setserial". Jusqu'à ce que toutes les options essentielles
ci-dessus soient paramétrées de manière compatible on ne pourra pas faire de
communication série satisfaisante (et sûrement pas de communication du tout)
entre le terminal et l'ordinateur. Pour le terminal, on doit positionner ces
options à la main avec des menus sur chaque terminal (ou en utilisant une
sorte de cartouche spéciale sur chaque terminal). L'ordinateur hôte est
configuré en lançant des commandes à chaque démarrage de l'ordinateur (ou
quand les gens se loggent). Quelquefois le programme getty (qu'on trouve dans
le fichier /etc/inittab) qui démarre le processus login s'occupera de ceci
pour l'ordinateur. Voyez 
<A HREF="#getty_">getty (dans /etc/inittab)</A>.</P>
<P>Les paramètres à la fois pour l'ordinateur et le terminal sont :</P>
<P>
<UL>
<LI>
<A HREF="#speed">vitesse (bits/seconde)</A></LI>
<LI>
<A HREF="#parity_">parité</A></LI>
<LI>
<A HREF="#ch_size">bits par caractère</A></LI>
<LI>
<A HREF="#flow_control">contrôle de flux</A></LI>
</UL>
</P>
<P>Certains paramètres essentiels au terminal seul sont : </P>
<P>
<UL>
<LI>
<A HREF="#port_select">sélection du port</A> </LI>
<LI>Positionner la communication en full duplex (=FDX sur les terminaux Wyse)</LI>
</UL>
 </P>
<P>Si le programme 
<A HREF="#getty_">getty (dans /etc/inittab)</A> ne peut
pas paramétrer la partie côté ordinateur de la manière dont vous le désirez,
vous aurez alors besoin d'utiliser l'une des commandes 
<A HREF="#stty_setserial">stty et setserial</A> (ou les deux).</P>

<H3><A NAME="speed"></A> Vitesse</H3>


<P>Elle doit être identique à la fois sur le terminal et l'ordinateur. La
vitesse est en bits/seconde (bps ou vitesse en bauds). Utilisez la vitesse la
plus grande qui fonctionne sans erreurs. Autoriser le contrôle de flux peut
rendre possible des vitesses plus élevées. Il se peut qu'on puisse configurer
deux vitesses sur le terminal : transmission et réception, qu'on abrège
parfois en T et R. On leur donne en général la même valeur puisque stty dans
Linux ne semble pas encore avoir l'option de les positionner différemment.
(Il y a une option pour faire ceci avec la commande "stty" mais en réalité il
semble qu'elle leur donne la même valeur.) Les vitesses courantes sont 300,
600, 1200, 2400, 4800, 9600, 19200, 38400 ... Les vitesses basses (comme 600)
sont faites pour les imprimantes et les terminaux à sortie papier.</P>

<H3><A NAME="parity_"></A> La parité et devriez-vous l'utiliser ?</H3>


<P>Pour une définition, voyez 
<A HREF="#parity_def">la parité expliquée</A>.
La parité désactivée est souvent la valeur par défaut. Pour activer la
parité, vous devez à la fois l'activer et ensuite sélectionner une parité
paire ou impaire.  Cela ne fait probablement pas de différence si c'est pair
ou impair. Pour les terminaux il y a parfois des paramètres de parité pour la
transmission et la réception. Vous devriez positionner les deux à la même
valeur puisque stty sur l'ordinateur ne permet pas un paramétrage différent.
Le port série du PC ne peut pas habituellement supporter differentes parités.
Certains terminaux ne sont pas capables de positionner la parité de
réception et ignoreront simplement tout bit de parité reçu. Sur certains
terminaux plus anciens, si vous utilisez 8 bits de données par octet, la
parité ne fonctionnera pas puisqu'il n'y a pas de place au niveau matériel
pour le bit de parité supplémentaire.</P>
<P>Est-ce vous devriez utiliser la parité ? Il est bon de disposer de la parité,
bien qu'elle ne soit pas strictement nécessaire. Si vous n'avez pas de
parité, vous pourrez avoir une lettre incorrecte ici ou là et finirez par
corriger des fautes d'orthographe qui n'existent pas vraiment. Cependant, la
parité a un coût. D'abord, elle est plus compliquée à configurer puisqu'en
général par défaut il n'y a pas de parité. Ensuite, la parité diminuera la
vitesse avec laquelle les octets traversent le câble puisqu'il y aura un bit
supplémentaire par octet. Ceci peut ou peut ne pas diminuer la vitesse
effective.</P>
<P>Par exemple, un terminal à sortie papier est en général limité par la
mécanique du processus d'impression. L'augmentation des octets/seconde quand
l'ordinateur (sa puce UART) est en train de transmettre ne conduit qu'à plus
de signaux "d'arrêt" de contrôle de flux pour permettre au mécanisme
d'impression de rattraper le rythme. À cause des attentes supplémentaires
dues au contrôle de flux, la vitesse effective n'est pas meilleure sans
parité qu'avec. La situation est identique pour certains terminaux : après
avoir mis en place la parité il peut y avoir moins d'attente due au contrôle
de flux par unité de temps ce qui résulte en plus de bits/seconde (en
moyenne). Cependant, à cause des bits de parité ajoutés, le nombre
d'octets/seconde (en moyenne) reste le même.</P>
<P>Une possibilité est d'installer les terminaux sans parité. Ensuite si on
remarque des erreurs de parité, on peut l'activer plus tard. Pour détecter
des erreurs possibles sans parité, regardez des erreurs de frappe que vous ne
pensez pas avoir faites. Si vous détectez une telle erreur, rafraichissez
l'écran (retransmettez de l'ordinateur). Si l'erreur s'en va, c'est alors
sûrement une erreur de parité. Si trop d'erreurs surviennent (comme plus
d'une par quelques centaines d'écrans), il faut faire une action corrective
comme : activer la parité et/ou réduire la vitesse et/ou utiliser un câble
plus court/meilleur. Activer la parité ne réduira pas le nombre d'erreurs
mais vous signalera quand une erreur s'est produite.</P>
<P>La politique opposée est d'activer la parité dès le départ. Ensuite si on ne
voit jamais d'erreur de parité (des symboles d'erreur sur l'écran), sur une
période de temps raisonnable, disons un mois ou deux, on peut la désactiver
sans danger.</P>

<H3><A NAME="ch_size"></A> Bits/caractère</H3>


<P>C'est la taille d'un caractère (le nombre de bits de données par caractère,
en excluant tout bit de parité).  Pour l'ASCII, c'est 7, mais c'est 8 pour
les jeux de caractères ISO. Si vous n'allez utiliser que des caractères
ASCII, sélectionnez alors 7 bits puisqu'il est plus rapide de transmettre 7
bits que 8. Certains vieux terminaux n'afficheront que des caractères 7 bits.</P>

<H3>Quel contrôle de flux (prise de contact) ?</H3>


<P>Il faut choisir entre le contrôle de flux "matériel" (par exemple dtr/cts) et
"logiciel" (Xon/Xoff). (le menu du terminal Adds utilise de manière
incorrecte "Xon/Xoff" pour indiquer tout type de contrôle de flux.) Bien que
le contrôle de flux matériel soit plus rapide (si les deux fils
supplémentaires nécessaires sont présents dans le câble et si le terminal le
supporte) dans la plupart des cas Xon/Xoff devrait fonctionner correctement.
Certaines personnes disent qu'elles ont résolu des problèmes dérangeants
(voir ci-dessous) en passant au contrôle de flux matériel mais le contrôle de
flux logiciel a bien fonctionné sur les autres installations (et chez moi
personnellement).</P>
<P>Si vous utilisez le contrôle de flux logiciel (Xon/Xoff) et avez des
utilisateurs qui ne le savent pas, ils peuvent alors envoyer par accident un
Xoff à l'hôte et bloquer leur terminal. Pendant qu'il est bloqué, ils peuvent
très bien taper frénétiquement en une vaine tentative pour le débloquer.
Quand alors Xon est enfin envoyé pour rétablir la communication, tout ce qui
a été tapé à toute vitesse est exécuté, peut-être avec des résultats
inattendus. Ils ne risquent pas ceci avec le contrôle de flux matériel.
Voyez 
<A HREF="#flow_control">contrôle de flux</A> pour une explication
sur le contrôle de flux.</P>

<H3><A NAME="port_select"></A> Sélection du port</H3>


<P>Puisque la plupart des terminaux possèdent deux connecteurs ou plus derrière
eux, il est en général possible de dire que l'un de ces connecteurs sera
relié à l'ordinateur et de dire que l'autre connecteur sera le port
imprimante. Il peut y avoir un nom à côté du connecteur (regardez-le bien) et
ce nom (comme Aux ou Serial 2, ou Modem) peut être donné à la connexion vers
l'hôte principal ou vers l'imprimante (ou autre).</P>

<H2><A NAME="ss12.6">12.6 Essai rapide</A>
</H2>


<P>Bien que tout ce qui est au-dessus puisse sembler très compliqué, faire
fonctionner un terminal est souvent assez simple. La section 
<A HREF="#quick_install">installation rapide</A> décrit une manière simple
d'essayer de le faire. Mais si cela ne fonctionne pas ou si vous voulez
améliorer l'affichage, vous avez besoin d'en lire plus.</P>

<H2><A NAME="term_conf_details"></A> <A NAME="s13">13. Détails de la mise en place (configuration) du terminal</A></H2>


<P>À part la prochaine sous-section qui décrit l'envoi de séquences
d'échappement au terminal, cette section présente principalement les détails
de la configuration du terminal à la main en s'asseyant devant le terminal et
en se déplaçant entre différents menus. Si vous ne l'avez pas encore fait,
vous devriez lire 
<A HREF="#term_conf_ov">vue d'ensemble de la mise en place (configuration) d'un terminal</A>.  C'est mieux si vous avez le manuel du
terminal, mais même si vous ne l'avez pas il y a ici des informations
concernant beaucoup d'options que vous serez peut-être amené à configurer.</P>
<P>Les paramètres de communication tels que la vitesse d'envoi doivent
toujours être configurés sur le terminal puisque si vous ne le faites pas ici
on ne peut pas communiquer avec le terminal. Une fois que la communication est
établie vous avez deux choix pour effectuer le reste de la configuration du
terminal. Vous pouvez continuer à faire la configuration à la main sur le
terminal et sauver les résultats dans la mémoire permanente du terminal ou
vous pouvez le faire en envoyant des séquences d'échappement au terminal à
partir de l'ordinateur à chaque fois que le terminal est allumé.</P>
<P>Si vous savez comment mettre en place et sauver une bonne configuration dans
le terminal ce peut être la meilleure façon. Si vous ne savez pas, vous pouvez
simplement envoyer la chaîne d'initialisation de terminfo à votre terminal à
chaque fois que vous utilisez le terminal. Peut-être que ne rien faire vous
donnera quand même un terminal utilisable. Vous (ou une application) pouvez
toujours changer les choses en envoyant certains séquences d'échappement au
terminal.</P>

<H2><A NAME="ss13.1">13.1 Envoyer des séquences d'échappement au terminal</A>
</H2>


<P>Une fois que l'interface de communication est en place, le reste de la
configuration des terminaux peut parfois être fait en envoyant des séquences
d'échappement aux terminaux depuis l'ordinateur. Si vous avez un grand nombre
de terminaux, il peut être utile d'écrire (ou de trouver) un script shell pour
faire ceci de manière automatique. Il peut (ou non) y avoir une commande à
envoyer au terminal pour lui dire de sauver sa configuration en cours dans sa
mémoire permanente pour qu'elle soit présente la prochaine fois qu'on allumera
le terminal.</P>
<P>Il y a une manière simple d'envoyer ces séquences d'échappement et une manière
compliquée. Avec la manière simple, vous ne regardez jamais les séquences
d'échappement mais envoyez des commandes qui trouvent toutes seules la
séquence d'échappement appropriée dans la base de données terminfo et
l'envoient. Malheureusement, toutes les séquences d'échappement que vous avez
besoin d'envoyer ne sont pas toujours dans la base de données terminfo. Ainsi
la manière plus compliquée (mais peut-être meilleure) est d'envoyer
directement les séquences d'échappement.</P>
<P>Pour cette méthode compliquée vous aurez besoin d'un manuel avancé. Les vieux
manuels de terminaux comprenaient autrefois une liste détaillée de séquences
d'échappement mais les manuels récents n'en ont généralement pas. Pour les
trouver vous devrez peut-être acheter un autre manuel intitulé "manuel du
programmeur" (ou similaire) qui n'est pas fourni avec le terminal. Une 
<A HREF="#esc_seq_list">liste de séquences d'échappement</A> de certains
terminaux est sur Internet mais c'est une liste brute et sûrement incomplète.</P>
<P>Même sans manuel ou autre, vous pouvez quand même envoyer des commandes pour
configurer le terminal en utilisant les programmes "tput" et "setterm". Voyez
<A HREF="#term_settings">changer les paramètres du terminal</A>. Vous
pourriez simplement envoyer une chaîne d'initialisation au terminal à partir
de l'entrée terminfo si la chaîne d'initialisation configure le terminal
comme vous le désirez. Voyez 
<A HREF="#init_string">chaîne d'initialisation</A>.  Excepté si vous pensez envoyer ces séquences de
l'ordinateur au terminal à chaque fois que vous allumez ce dernier, vous
devez sauver ces paramètres dans la mémoire permanente du terminal.</P>

<H2><A NAME="ss13.2">13.2 Configuration des vieux terminaux</A>
</H2>


<P>Sur les vieux terminaux, cherchez sur le clavier des noms juste au-dessus de
la rangée supérieure du pavé numérique. S'ils existent, ces noms peuvent
représenter l'action des touches en mode configuration. Certains vieux
terminaux peuvent n'avoir qu'un menu de configuration (setup). Certains
encore plus anciens possèdent des interrupteurs physiques. Dans certains cas
toutes les touches ne sont pas bien nommées mais peuvent être bien cachées.
Bien sûr, si vous activez quelque chose en basculant un interrupteur, c'est
"sauvegardé" et vous n'avez pas besoin de sauver le paramètre en mémoire
permanente.</P>

<H2><A NAME="enter_setup"></A> <A NAME="ss13.3">13.3 Entrer dans le mode de configuration</A>
</H2>


<P>Pour sélectionner des options (configurer) sur le terminal, vous devez
d'abord entrer en mode "setup" et ensuite sélectionner des options
(c'est-à-dire configurer) en utilisant des menus stockés dans le terminal et
affichés sur l'écran. Pour ce faire, le terminal n'a même pas besoin d'être
relié à un ordinateur. La manière d'entrer en mode de configuration est
expliquée dans le manuel du terminal, mais voici quelques indices qui peuvent
aider&nbsp;:</P>
<P>S'il y a une touche "setup", essayez de l'enfoncer. Essayez aussi en appuyant
sur la touche "Shift" en même temps.</P>
<P>
<UL>
<LI>Wyse : essayez d'abord la touche "Shift" + "Select" ; ensuite remplacez
Shift par Ctrl dans tout ce qui est au-dessus.
</LI>
<LI>VT, Dorio : F3 peut être la touche de configuration. Sur les VT420 et
modèles postérieurs cette touche peut avoir été reprogrammée pour faire autre
chose, alors éteignez le terminal. Quand vous remettrez le courant, appuyez
sur la touche F3 dès que vous obtenez un message initial à l'écran.
</LI>
<LI>IBM : 3151 : Ctrl-ScrollLock. 3153 : Ctrl-Moins_du_pavé_numérique (ou
pareil que pour le 3151).
</LI>
</UL>
</P>
<P>Pour vous déplacer dans les menus de configuration, utilisez les touches
fléchées. Utilisez Retour, Espace ou une touche spéciale ("toggle" sur les
vieux terminaux) pour sélectionner quelque chose. Pour sortir du mode de
configuration choisissez exit dans un menu (ou sur certains vieux terminaux
appuyez de nouveau sur la touche setup).</P>

<H2><A NAME="ss13.4">13.4 Options de communication</A>
</H2>


<P>Pour que le terminal fonctionne, il faut paramétrer correctement la vitesse,
la parité, le nombre de bits par caractère et le mode de communication. Un
contrôle de flux incorrect peut être la cause de la perte ou de la corruption
des données affichées à l'écran. On a parlé des options de communication
essentielles (à la fois pour le terminal et pour l'ordinateur) dans une autre
section : voyez 
<A HREF="#commun_config">interface de communication</A>.
La liste suivante fournit quelques liens dans cette section, ainsi que des
options de communication supplémentaires positionnées uniquement sur le
terminal.</P>
<P>
<UL>
<LI>
<A HREF="#speed">Vitesse (bits/seconde)</A> (vitesse de
transmission) : 9600, 19200, etc.
</LI>
<LI>
<A HREF="#parity_">Parité</A> : aucune, paire, impaire, marque,
espace
</LI>
<LI>
<A HREF="#ch_size">Bits par caractère</A> {Données} : 7 ou 8
</LI>
<LI>
<A HREF="#flow_control">Contrôle de flux</A> ou prise de contact
{Hndshk} : aucun, Xon-Xoff, ou matériel (DTR, etc)

<UL>
<LI>Prise de contact du récepteur {Rcv Hndshk} protège les données
reçues par le terminal en envoyant des signaux de contrôle de flux à
l'hôte.
</LI>
<LI>Prise de contact de l'émetteur {Xmt Hndshk} est une protection
des données transmises par le terminal. Le terminal reçoit des
signaux de contrôle de flux (et bloque/débloque le clavier). Comprend
"Xon/Xoff entrant".</LI>
</UL>

</LI>
<LI>Nombre de bits d'arrêt :  1 ou 2. Voyez 
<A HREF="#byte_seq">séquence de tension pour un octet</A>
</LI>
<LI>Niveau de contrôle de flux {Rcv Hndshk Level} {{Xoff à ...}} : le
contrôle de flux enverra un "arrêt" quand ce nombre d'octets sera dépassé
dans le tampon du terminal.
</LI>
<LI>
<A HREF="#half_duplex">Mode de communication</A> {Comm} : 
<A HREF="#half_duplex">Full Duplex {FDX}, Half Duplex {HDX}</A> {{Local Echo}},
<A HREF="#local_mode">Mode Local</A> {{Online/Local}}
</LI>
<LI>Limite du taux de transmission (vitesse) {Xmt Lim} : limite le taux de
transmission au nombre de cps (caractères par seconde) spécifié même si la
vitesse est plus grande.
</LI>
<LI>Limite du taux de touches de fonction : comme ci-dessus mais pour les
messages de touches de fonction.
</LI>
<LI>
<A HREF="#port_select">Sélection du port</A> : quel connecteur
physique va à l'hôte {Host Port} ?</LI>
</UL>
</P>

<H2><A NAME="ss13.5">13.5 Sauver la configuration</A>
</H2>


<P>Votre configuration doit être sauvée dans la mémoire permanente du terminal
pour être en place la prochaine fois que vous allumez le terminal. Si vous
manquez à cette sauvegarde, les nouveaux paramètres seront perdus quand vous
éteindrez le terminal. Avant de vous fatiguer à configurer un terminal,
assurez-vous que vous savez sauvegarder les paramètres. Sur les terminaux
modernes la commande de sauvegarde se fait grâce à un menu. Dans certains
vieux terminaux, seul le manuel vous indique comment sauver. Pour beaucoup
d'entre eux, pressez Ctrl-S pour sauver.</P>

<H2><A NAME="set_up_pars"></A> <A NAME="ss13.6">13.6 Paramètres/options de configuration</A>
</H2>


<P>Voyez la 
<A HREF="http://www.pericom-usa.com/twdocs/doc/twusec7.htm">page de configuration</A> de Teemworld pour avoir une description d'un
grand nombre de ces paramètres utilisés en émulation de terminaux.
L'émulation est souvent légèrement différente du terminal réel.</P>
<P>Ce qui suit dans cette section décrit certaines options disponibles dans les
menus de configuration de beaucoup de terminaux. Les options sont aussi
appelées paramètres ou capacités. Beaucoup d'options sont parfois appelées
"modes". Paramétrer des options est souvent appelé "configurer". On peut
paramétrer beaucoup de ces options en envoyant certaines séquences
d'échappement au terminal. Des modèles et marques différents de terminaux ont
des options variées et la même option peut avoir des noms différents (qu'on
ne donnera pas tous ici). Les noms abrupts utilisés par Wyse sont entourés de
{...}. Les noms utilisés principalement pour les terminaux VT sont entourés
de {{...}}.</P>

<H2><A NAME="ss13.7">13.7 Émulation {Personnalité} {{Modes de terminaux}}</A>
</H2>


<P>La plupart des terminaux modernes peuvent émuler plusieurs autres terminaux.
Le terminal peut sûrement faire plus si on le fait s'émuler lui-même (en fait
sans émulation) {personnalité native}. Quelque fois il y deux émulations
différentes pour le même modèle de terminal. Par exemple, VT220-7 émule un
VT220 avec 7 bits par octet alors que VT220-8 émule un VT220 avec 8 bits par
octet (256 caractères possibles).</P>
<P>Des vieux modèles de terminaux possèdent en général moins de possibilités que
les modèles plus récents. Supposez qu'on veuille émuler un vieux terminal
tout en gardant certaines possibilités avancées du modèle de terminal plus
récent devant lequel on s'assied. Ceci est parfois possible (jusqu'à un
certain niveau). Cette possibilité est parfois appelée {Enhance} (ou Enhanced
??).</P>

<H2><A NAME="ss13.8">13.8 Options d'affichage</A>
</H2>



<H3>Taille de cellule de caractère{Char Cell}</H3>


<P>C'est la taille de la cellule dans laquelle tient un caractère. On la mesure
en pixels (= petits points). Plus il y a de points, meilleure est la
résolution. 10x16 représente 10 points de large sur 16 points de haut (16
lignes et 10 colonnes). Notez que la notation est inversée par rapport à la
notation de la dimension des matrices qui donnent les lignes (la hauteur)
d'abord. De même, la cellule de caractère comprend les lignes et les colonnes
allouées à l'espace entre des caractères adjacents, donc la taille de la
cellule qui définit les bords d'un caractère réel peut être plus petite.</P>

<H3>Colonnes / lignes</H3>


<P>En général il y a 80 colonnes et 24 ou 25 lignes. Ceci veut dire qu'il peut y
avoir jusqu'à 80 caractères sur une ligne de l'écran. Beaucoup de terminaux
possèdent une option de 132 caractères par colonne mais, sauf si vous avez un
grand écran, les petits caractères peuvent être difficiles à lire. {{Activer
le mode 132 colonnes}}</P>

<H3>Curseur</H3>


<P>On peut paramétrer le curseur pour qu'il apparaisse comme un rectangle (=
bloc) {Blk}. D'autres options sont le souligné {Line} ou le clignotement. Je
préfère un bloc non clignotant {Steady} puisqu'il est suffisamment grand pour
qu'on le trouve rapidement sans qu'il y a ait de clignotement distrayant. Si
vous le rendez invisible (une option sur certains terminaux) il disparaîtra
mais les nouveaux caractères apparaîtront à l'écran au fur et à mesure que
vous tapez sous le curseur invisible.</P>

<H3>Attributs d'affichage (cookies magiques)</H3>


<P>Les 
<A HREF="#display_attributes">attributs d'affichage</A> peuvent être
soit des cookies magiques soit des octets d'attributs assignés à chaque
caractère. Pour les cookies magiques, il y a une limite à leur étendue : leur
effet s'étend-il jusqu'à la fin de la ligne ou jusqu'à la fin de la page ? Il
est mieux d'utiliser des octets d'attributs (qui peuvent en réalité être des
demi-octets = petits bouts).</P>

<H3>Caractères de contrôle d'affichage {Monitor} </H3>


<P>Ils peuvent avoir des noms variés tels que "contrôles d'affichage".
Désactivés (par défaut), ils veulent dire "interpréter les caractères de
contrôle". Quand on les active, vous voyez les séquences d'échappement de
l'hôte (que vous ne voyez jamais à l'écran en temps normal). Pour que ces
séquences soient visualisées d'un coup sur une ligne, le terminal ne les
interprète pas, sauf la séquence CR LF, qui crée une nouvelle ligne. Voyez
<A HREF="#control_codes">codes de contrôle</A>.</P>

<H3>Largeur/hauteur double</H3>


<P>Certains terminaux peuvent afficher des caractères en largeur et/ou en
hauteur double. Cette possibilité est rarement nécessaire. En changeant une
ligne en largeur double (DW = Double Width) la moitié gauche (RH = Right
Half) est poussée à l'extérieur de l'écran et il faut se poser la question de
l'effacer ou non. "Préserver" veut dire garder la moitié gauche des lignes en
largeur double. En mode hauteur double, il peut être nécessaire d'envoyer
chacune de ces lignes deux fois (la deuxième fois une ligne plus bas) pour
obtenir une ligne en hauteur double à l'écran.</P>

<H3>Vidéo inverse {Display} (Fond clair/foncé)</H3>


<P>La vidéo normale consiste en des lettres (premier plan) claires (blanches,
vertes, ambre) sur un fond foncé (noir). La vidéo inverse {Display Light} est
le contraire : du texte noir sur un fond clair. Cela est plus commode pour
les yeux (sauf si la pièce est sombre).</P>

<H3>Ligne d'état</H3>


<P>Une ligne d'état est une ligne en haut ou en bas de l'écran qui affiche des
informations sur l'application en cours d'utilisation. Elle est souvent mise
en valeur d'une certaine manière. Avec une telle ligne d'état, une
application peut envoyer au terminal une séquence d'échappement spéciale qui
veut dire que le texte qui suit concerne la ligne d'état. Cependant, beaucoup
d'applications n'utilisent pas cette possibilité et à la place simulent une
ligne d'état réelle en positionnant directement le curseur. L'utilisateur de
base qui le regarde ne voit pas la différence.</P>

<H3>Pendant le changement 80/132 : effacer ou préserver&nbsp;?</H3>


<P>En basculant le nombre de colonnes de 80 à 132 (ou l'inverse), est-ce que les
données affichées dans le format précédent doivent être effacées ou
préservées ? {80/132 Clr} {{Screen Width Change}}. La manière dont vous
positionnez cette option ne devrait pas faire de différence puisque si une
application utilise 132 colonnes, elle devrait positionner cette option
correctement grâce à une séquence d'échappement.</P>

<H2><A NAME="ss13.9">13.9 Options liées aux pages</A>
</H2>


<P>Pour qu'un terminal Wyse puisse accéder à plusieurs pages dans la mémoire
d'affichage, il faut activer {Multipage}.</P>

<H3>Taille de la page</H3>


<P>La mémoire du terminal peut être divisée en un certain nombre de pages. Voyez
<A HREF="#pages_">pages</A> et 
<A HREF="#pages_def">pages (définition)</A> pour une explication sur les pages. Vous pouvez partitionner
la mémoire de pages en un certain nombre de pages de taille déterminée. Les
applications Linux ne semblent pas utiliser les pages pour le moment, il ne
devrait donc pas y avoir de différence au niveau de la configuration.</P>

<H3>Couplage (du curseur et de l'affichage)</H3>


<P>La mémoire du terminal peut être divisée en un certain nombre de pages. Voyez
<A HREF="#pages_">pages</A> et 
<A HREF="#pages_def">pages (2)</A> pour
avoir une explication sur les pages. Quand on déplace le curseur à un endroit
en mémoire vidéo qui n'est pas affichée à cet instant (comme une autre page,
ou sur la même page mais à un endroit non affiché à l'écran), est-ce que
l'affichage doit suivre pour que l'on voie la nouvelle position du curseur ?
Si c'est le cas, c'est ce qu'on appelle le "couplage". En ce qui concerne le
mouvement du curseur dans la même page, il y a le "couplage vertical" et le
"couplage horizontal". En ce qui concerne le mouvement vers une autre page,
il y a le "couplage de page".</P>

<H2><A NAME="ss13.10">13.10 Faire un rapport et répondre</A>
</H2>


<P>Le terminal donnera son identité et son état, ou enverra un message
pré-enregistré en réponse à certaines séquences d'échappement.</P>

<H3>Message de réponse (chaîne)</H3>


<P>Vous pouvez écrire un message court pendant la configuration qui peut être
envoyé de manière optionnelle à l'hôte durant le démarrage ou être envoyé à
l'hôte en réponse à une demande de l'hôte (peut-être le caractère de contrôle
ENQ (enquire, demande)).</P>

<H3>Réponse automatique</H3>


<P>Si ce paramètre est positionné, envoie le message de réponse à l'hôte durant
le démarrage sans que l'hôte le demande. Est-ce qu'un processus "getty"
quelconque cherchent ce message ??</P>

<H3>Réponse cachée</H3>


<P>Si ce paramètre est positionné, il ne laissera personne voir le message de
réponse (sauf bien sûr l'ordinateur hôte). S'il faut le modifier, désactivez
"réponse cachée" et le message précédemment caché sera détruit pour que vous
puissiez alors entrer un nouveau message (mais vous ne verrez pas le message
précédent).</P>

<H3>Numéro ID du terminal {ANSI ID} </H3>


<P>Le terminal envoie cette réponse à la réception d'une demande d'identité.</P>

<H2><A NAME="ss13.11">13.11 Options du clavier</A>
</H2>



<H3>Clic de touche</H3>


<P>Quand ce paramètre est positionné, la pression de n'importe quelle touche
provoque un cliquetis (émis par un minuscule haut-parleur dans le clavier).
Ces cliquetis ennuient certaines personnes et je pense qu'il est mieux de
désactiver cette option.</P>

<H3>Verrouillage majuscule {Keylock}</H3>


<P>Quand la touche de verrouillage majuscule est enfoncée, les touches
alphabétiques doivent-elles être les seules à générer des caractères en
majuscule ? Si le paramètre est positionné à {Caps} ou majuscule uniquement
(upper-case-only), alors l'appui sur une touche numérique avec le
verrouillage majuscules tapera le chiffre en question. Pour obtenir le
symbole au-dessus du chiffre il faudra appuyer sur la touche shift à la main.
C'est le mode normal.  S'il est positionné sur {Shift} toutes les touches
tapent alors le caractère "décalé" quand le verrouillage majuscules est
enfoncé (l'appui sur la touche 5 devrait afficher % sans devoir appuyer sur
Shift, etc.) NdT : sur les claviers français, c'est l'inverse, les chiffres
étant normalement obtenus en appuyant sur la touche Shift.</P>

<H3>Répétition automatique {Repeat}</H3>


<P>Si on maintient une touche enfoncée, celle-ci est "tapée" de manière répétée.
Cela est pratique pour taper répétitivement le même caractère pour créer une
ligne à travers une page.</P>

<H3>Sonnette de marge</H3>


<P>Quand le curseur arrive à 8 colonnes du bord droit de l'écran, une sonnette
sonne (comme sur une vieille machine à écrire). Quasiment tous les éditeurs
créeront automatiquement une ligne nouvelle si nécessaire (pas besoin
d'appuyer sur la touche entrée), par conséquent cette possibilité est
rarement nécessaire.</P>

<H3>Redéfinir les touches</H3>


<P>Le code envoyé à l'hôte quand on appuie sur une touche correspond normalement
au code ASCII de cette touche (et dépend aussi des touches Shift et Control).
Sur certains terminaux vous pouvez faire en sorte que n'importe quelle touche
envoie n'importe quel code. C'est-à-dire que vous pouvez complètement
redéfinir le clavier en configurant le terminal de cette façon. Cela peut
être utile pour certaines langues étrangères et pour les claviers Dvorak etc.
qui vous permettent de taper plus rapidement.</P>

<H3>Touche de coin (uniquement pour les Wyse)</H3>


<P>Les terminaux Wyse possèdent une touche près du coin inférieur gauche qu'on
peut configurer pour des fonctions variées. Elle peut être appelée
"Funct", "Compose Character", "Alt", "Hold" or "Scroll Lock". Les modèles
récents n'ont pas toutes les options suivantes&nbsp;:  
Quand on la met sur {Hold} (arrêt du défilement, No-Scroll), elle permet 
d'arrêter le flux de données (en utilisant le contrôle de flux) vers le 
terminal. L'appui à nouveau sur cette touche redonne un flux normal. Quand 
on la met sur {Compose} elle permet de générer un nombre limité de caractères 
non-latins prédéfinis. Quand on la met sur Meta, cela en fait une touche 
Meta qui positionne le bit de haut rang sur chaque octet. Quand on la met 
sur {Funct} (et qu'on l'enfonce), chaque touche alphanumérique enfoncée 
envoie un octet préfixe (SOH) et un octet suffixe (CR) qui encadrent le 
code de l'octet ASCII. Quand on la met sur {Kpd Compose} (et qu'on l'enfonce) 
alors la frappe d'un nombre décimal sur le pavé numérique (suivi de "entrée") 
envoie le même chiffre en hexadécimal ??</P>

<H3>Envois grâce au pavé numérique ou aux touches fléchées</H3>


<P>On peut configurer le pavé numérique (le rectangle de touches presque toutes
numériques à la droite de la partie principale du clavier) pour envoyer des
codes spéciaux qui feront certaines choses dans certaines applications. Idem
pour les touches fléchées. Il y a donc un mode "normal" où elles envoient ce
qui est marqué sur la touche (ou la séquence d'échappement normale pour une
touche fléchée) et un mode "application" où une séquence d'échappement
spéciale est envoyée. Dans certains cas il y a un mode numérique
"hexadécimal" qui ressemble au mode numérique à la différence que 6 touches
non numériques envoient les lettres A à F. On peut ainsi taper par exemple
"B36F" sur le pavé numérique.</P>

<H3>Qu'envoient les touches Shift+Del et Shift+Backspace ?</H3>


<P>Selon la manière dont les touches sont configurées Shift-Del envoie parfois
le caractère de contrôle CAN et Shift-Backspace envoie parfois DEL.</P>

<H3>Codes de balayage PC</H3>


<P>Les terminaux récents peuvent émuler un clavier de PC en envoyant des codes
de balayage PC (voyez le Keyboard-and-Console-HOWTO) au lieu de codes ASCII.
Cela pourrait être utilisé si vous étiez directement relié à un PC sous
DOS/Windows. Positionnez {Keycode} sur {Scan}. L'émulation du "PCTerm" DEC
devrait faire la même chose et même plus. Un port série sous Linux ne peut
pas s'occuper de tels codes de balayage.</P>

<H3>Caractères alternés</H3>


<P>Certaines touches peuvent contenir des lettres alternatives. Quand on
positionne les touches sur "machine à écrire" (Typewriter) elles envoient ce
qu'elles enverraient normalement sur une machine à écrire. Quand on les
positionne sur autre chose, les caractères alternatifs sont envoyés.</P>

<H2><A NAME="ss13.12">13.12 Signification des codes de contrôle reçus</A>
</H2>



<H3>Nouvelle ligne automatique {Newline}</H3>


<P>Dans ce cas "nouvelle ligne" veut dire une ligne nouvelle démarrant sur le
bord gauche en dessous de la ligne en cours. Sous Linux et en C "nouvelle
ligne" (NL) peut avoir une signification différente : le caractère de saut de
ligne LF qu'on appelle aussi nouvelle ligne ou NL. C'est parce que dans les
fichiers texte Linux, le caractère LF veut dire "une nouvelle ligne commence
ici" et donc on l'appelle NL. Normalement, un LF (NL) envoyé à un terminal ne
fait que descendre le curseur d'une ligne par rapport à l'endroit où il se
trouvait et ne donne pas une nouvelle ligne.</P>
<P>Si le paramètre Auto New Line (nouvelle ligne automatique) est positionné, la
situation "normale" ci-dessus est annulée et une nouvelle ligne physique est
créée sur l'écran en recevant un LF de l'hôte. C'est exactement ce qu'on veut
sous Linux. Sauf que (quand Auto New Line est positionné) la touche Retour
(ou Entrée) envoie une séquence CR LF à l'hôte (pour les Wyse et les VT100,
mais pour les VT420 ??). Puisque Linux utilise LF comme marqueur de "nouvelle
ligne" dans les fichiers, Linux n'aimerait recevoir qu'un LF (et pas un CR
LF). L'option "New Line" est par conséquent rarement utilisée. À la place,
les traductions nécessaires sont effectuées par le pilote du port série par
défaut. C'est comme si on envoyait la commande "stty onlcr icrnl" mais vous
n'avez pas besoin de le faire puisque c'est le comportement par défaut.</P>

<H3>Saut de ligne automatique {Rcv CR}</H3>


<P>Cela est simplement un autre type de "nouvelle ligne automatique". Quand un
caractère CR (retour chariot) est reçu, une action LF (saut de ligne) est
ajoutée ce qui résulte en l'affichage d'une nouvelle ligne. Puisque Linux
marque les fins de lignes par LF, cette option n'est pas utilisée.</P>

<H3><A NAME="rec_del"></A> Reconnaître DEL (seulement pour Wyse ??) ou NULL</H3>


<P>Si ce paramètre est désactivé, tout caractère DEL reçu par le terminal est
ignoré. S'il est activé, DEL effectue un retour en arrière destructif. Les
caractères NULL sont en général ignorés dans n'importe quel cas. Les
caractères DEL et NULL sont parfois utilisés ensemble pour faire du
remplissage. Voyez 
<A HREF="#padding">Remplissage</A>.</P>

<H2><A NAME="ss13.13">13.13 Où va le nouveau texte</A>
</H2>



<H3>Passage à la ligne</H3>


<P>On l'appelle aussi passage automatique (Auto Wrap, Auto Wraparound).
Qu'arrive-t-il quand on atteint le bord droit de l'écran (colonne 80, etc.)
et que l'hôte n'a pas envoyé de caractère retour (ou autre) ? Si le passage à
la ligne est activé, le reste de la ligne s'affiche alors sur la ligne
suivante, etc. Sinon, le reste de la ligne est perdu et n'est pas affiché à
l'écran. Toute application qui se respecte devrait envoyer des caractères
"retour" pour que le passage s'effectue avant d'atteindre le bord de l'écran.
Cependant une commande de copie brute (et d'autres situations) peut ne pas le
faire, il est donc en général mieux de positionner le passage à la ligne.</P>
<P>Pour un écran de 80 colonnes, la plupart des terminaux ne passent à la ligne
que si le 81ème caractère venant de l'hôte est un caractère graphique
(imprimable). Cela autorise les cas où le 81ème caractère venant de l'hôte
peut être un "retour" ou "nouvelle ligne" (caractères non graphiques) qui
veut dire que l'application gère bien le passage à la ligne et le terminal
n'a pas besoin d'intervenir.</P>

<H3>Défilement</H3>


<P>Le défilement {Scrl} est quand toutes les lignes de l'écran se déplacent vers
le haut ou vers le bas. On parle aussi de "panoramique" (pan), ce qui
comprend un mouvement sur les côtés. Dans le défilement ordinaire, les lignes
disparaissent vers le bas ou vers le haut de l'écran et de nouvelles lignes
envoyées par l'hôte apparaissent sur le bord opposé (haut ou bas). Il y en a
trois sortes : doux, par sauts ou instantané. Le défilement instantané n'est
pas vraiment un défilement puisqu'il y a remplacement instantané d'une page
écran par une nouvelle (bien que certaines lignes du nouvel écran puissent
provenir de l'écran précédent). Le défilement par sauts est quand les
nouvelles lignes arrivent en sautillant les unes après les autres [ NdT : en
fait, elles arrivent une à la fois, mais la tentation était trop forte ;-) ].
Le défilement doux {Smth} est quand le texte se déplace à une vitesse
soutenue vers le haut ou vers le bas. Si la vitesse de défilement douce est
suffisamment lente, on peut lire les lignes qui apparaissent alors qu'elles
sont encore en train de bouger (en mouvement).</P>
<P>Le défilement doux sur les terminaux lents était utile autrefois puisqu'on
pouvait continuer à lire alors que l'affichage défilait. Mais avec les
vitesses de transfert plus rapides, le défilement par sauts est si rapide
qu'on ne perd que peu de temps en attendant l'apparition du nouvel affichage.
Puisque la lecture d'un texte qui défile prend légèrement plus de temps que
la lecture d'un texte fixe, on peut en fait perdre plus de temps si on
sélectionne un défilement doux.</P>
<P>Si on désactive le défilement automatique {Autoscrl}, le nouveau texte venant
de l'hôte doit aller quelque part, alors il est mis en haut de l'affichage.
Si l'ancien texte n'est pas effacé, le nouveau texte se mélange (de façon
insensée) à l'ancien. Si le vieux texte est effacé, le nouveau texte sort
alors de son contexte. Conservez donc le défilement automatique.</P>

<H3>Nouvelle page ?</H3>


<P>Voyez 
<A HREF="#pages_">pages</A> et 
<A HREF="#pages_def">pages (définition)</A> pour avoir une explication sur les pages. Quand la page
courante est pleine (la dernière ligne est terminée), est-ce que la page doit
défiler, ou est-ce qu'une nouvelle page doit être créée (laissant la page
précédente stockée dans la mémoire d'affichage du terminal)&nbsp;? Si le
paramètre {Autopage} est positionné, une nouvelle page est créée. Puisque
vous n'utilisez probablement pas les pages, vous devriez sûrement désactiver
ce paramètre.</P>

<H2><A NAME="funct_keys"></A> <A NAME="ss13.14">13.14 Touches de fonction</A>
</H2>


<P>Ce sont les touches nommées F1, F2, etc. Sur les vieux terminaux elles
s'appellent peut-être PF1, PF2, etc. où le P veut dire (P)rogrammable.
Certains claviers ont les deux. On peut programmer (redéfinir) ces touches
pour envoyer une chaîne d'octets définie par l'utilisateur. On peut souvent
les "programmer" facilement en utilisant un certain menu de configuration
{FKey}. Sur certains terminaux, on peut aussi spécifier où la chaîne est
envoyée quand on appuie sur la touche. En mode "normal" l'appui sur la touche
ressemble à la frappe d'une chaîne au clavier. En mode "local" l'appui sur la
touche envoie la chaîne au terminal (comme si le terminal était en mode
local). On peut utiliser cela pour envoyer des séquences d'échappement au
terminal pour le configurer d'une manière spéciale. En mode "lointain" la
chaîne est toujours envoyée sur le port série vers l'ordinateur hôte (même si
le terminal est en mode local).</P>

<H2><A NAME="ss13.15">13.15 Options en mode par blocs</A>
</H2>


<P>Certaines options ne concernent que le cas du 
<A HREF="#block">mode par blocs</A>. Cette option est utile puisqu'elle fournit des formulaires et retire
une charge à l'hôte en transmettant par rafales. Mais c'est plus compliqué à
configurer et ce n'est donc pas beaucoup utilisé.</P>

<H3>Affichage de formulaires</H3>


<P>En mode par blocs, certaines parties de l'écran concernent le texte des
formulaires et sont donc protégées en écriture "Prot" {WPRT}. Des options
peuvent faire que les caractères dans ces parties apparaissent assombris, en
vidéo inverse {WPRT Rev} et/ou soulignés {WPRT Undrln}.  {WPRT Intensity}
(l'intensité) peut être sombre, normale ou même vierge (invisible).</P>

<H3>Envoi par blocs</H3>


<P>Est-ce que le texte protégé en écriture (le texte d'origine du formulaire)
doit être envoyé à l'hôte lors de la transmission d'un bloc : {Send All} ou
est-ce que le texte protégé en écriture est aussi protégé en lecture : {Send
Erasable} ?</P>

<H3>Partie à envoyer</H3>


<P>Doit-on envoyer l'écran entier ou simplement la partie qui défile ?  {Send
Area}. L'envoi doit-il s'arrêter quand la position courante du curseur est
atteinte ? Si {Xfer Term} est mis sur Cursor, seules les données sur l'écran
jusqu'au curseur sont envoyées.</P>

<H3>Délimiteur de bloc / de page</H3>


<P>Quel est le symbole de délimitation à ajouter à un bloc de données ?  {Blk
End} ou à la fin d'une page {Send Term}inaison.</P>

<H2><A NAME="ss13.16">13.16 Blocages</A>
</H2>


<P>Il y a divers types de blocages. L'un est le clavier bloqué à cause du
contrôle de flux. Voyez 
<A HREF="#keybrd_lock">blocage du clavier</A>. Un
autre blocage {Feature Lock} est celui qui empêche l'ordinateur hôte de
modifier la configuration du terminal en envoyant certaines séquences
d'échappement au terminal. Placer un tel verrou peut provoquer des
comportements inattendus quand les applications enverront des séquences
d'échappement qui seront ignorées par le terminal. Tous les paramètres de
configuration ne sont pas verrouillés. Sauf si vous avez une bonne raison de
le faire, vous ne devriez pas activer de tels verrous.</P>
<P>Un blocage de touche de fonction empêchera l'ordinateur de redéfinir ce
qu'envoie une touche de fonction programmable. Vous voudrez utiliser cela si
vous avez programmé quelque chose d'important dans les touches de fonction.</P>

<H2><A NAME="ss13.17">13.17 Économiseur d'écran {Scrn Saver}</A>
</H2>


<P>On l'appelle aussi "CRT Saver" (NdT : ce qui revient au même). Ceci éteint
(ou diminue la luminosité) de l'écran quand le terminal n'est pas utilisé
pendant un certain temps. La durée de vie de l'écran est prolongée et cela
peut économiser de l'énergie. L'appui sur une touche permettra en général de
retrouver l'écran et peut "exécuter" cette touche donc il est préférable
d'appuyer sur la touche Shift etc.</P>

<H2><A NAME="ss13.18">13.18 Imprimante</A>
</H2>


<P>Pour les Wyse, s'il n'y a pas d'imprimante reliée, désactivez {Printer
Attached}. Ce n'est pas essentiel de faire ceci, mais si vous le faites toute
séquence d'échappement envoyant du texte à l'imprimante (au lieu du terminal)
sera ignorée.</P>
<P>Paramétrer le port de l'imprimante est à peu près la même chose (en général
plus simple) que de paramétrer les communications sur le port principal. Il y
a quelques options spécifiques à l'imprimante. Est-ce une imprimante série ou
parallèle ? Si c'est parallèle, on doit la désigner comme telle dans la
configuration et la connecter sur le port parallèle du terminal (s'il y en a
un). Doit-on envoyer un FF (saut de page) à l'imprimante à la fin d'un
travail d'impression ? Si {Print Term} est mis sur FF, c'est ce qui se
passera.</P>

<H2><A NAME="comp_conf_details"></A> <A NAME="s14">14. Détails de la configuration de l'ordinateur</A></H2>


<P>Il faut éditer plusieurs fichiers pour configurer l'ordinateur pour gérer le
terminal. Si vous avez de la chance, vous ne devrez éditer que /etc/inittab.
On fait ce travail d'édition à partir de la console (ou de n'importe quel
terminal qui fonctionne).</P>

<H2><A NAME="getty_"></A> <A NAME="ss14.1">14.1 Getty (dans /etc/inittab)</A>
</H2>


<P>Afin de lancer un processus de login sur un port série quand l'ordinateur
démarre (ou change de niveau d'exécution) une commande getty doit être placée
dans le fichier /etc/inittab. Getty permet de faire fonctionner (GET) un
terminal (TTY). Chaque terminal a besoin de sa commande getty. Il y a aussi
au moins une commande getty pour la console dans chaque fichier /etc/inittab.
Trouvez-la et ajoutez-y les commandes getty pour les vrais terminaux. Ce
fichier peut contenir des lignes d'exemples de commandes getty pour les
terminaux texte mises en commentaire, et donc tout ce qu'il vous reste à
faire est d'enlever les commentaires (enlevez le # au début de la ligne) et
de modifier quelques arguments.</P>
<P>Les arguments autorisés dépendent du getty que vous utilisez&nbsp;:</P>
<P>Les deux meilleurs getty pour les terminaux reliés de manière directe sont :</P>
<P>
<UL>
<LI>agetty (qu'on appelle parfois simplement getty) : très facile à
configurer.  Pas de fichiers de configuration. Voyez 
<A HREF="#agetty_">Agetty</A> ;
</LI>
<LI>Voyez 
<A HREF="#getty_ps">getty (fait partie du paquet getty_ps)</A>
;</LI>
</UL>
</P>
<P>Les deux gettys plus appropriés pour les modems (évitez-les pour les
terminaux) sont :</P>
<P>
<UL>
<LI>mgetty : le meilleur pour les modems ; fonctionne avec les terminaux mais
inférieur ;
</LI>
<LI>uugetty : uniquement pour les modems, fait partie du paquet getty_ps ;</LI>
</UL>
 </P>
<P>Un getty simple à utiliser uniquement pour les logins sur la console :</P>
<P>
<UL>
<LI>mingetty : uniquement pour les consoles.</LI>
</UL>
 </P>
<P>Si vous n'avez pas le getty que vous désirez, cherchez-le dans d'autres
distributions et utilisez le programme <CODE>alien</CODE> pour le convertir entre
paquets RPM et Debian. Le code source sur 
<A HREF="http://metalab.unc.edu/pub/Linux/system/serial/">Metalab (logiciels série)</A>.</P>
<P>Si vous n'utilisez pas les lignes de contrôle du modem (par exemple si vous
n'utilisez que les 3 conducteurs minimums : transmission, réception et masse
commune) vous devriez le faire savoir à getty en utilisant un drapeau
"local". Le format de celui-ci dépend du getty que vous utilisez.</P>

<H3><A NAME="agetty_"></A> Agetty (peut s'appeler getty)</H3>


<P>Un exemple de ligne dans /etc/inittab :</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
S1:23:respawn:/sbin/getty -L 19200 ttyS1 vt102
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>S1 vient de ttyS1. 23 veut dire que getty est lancé en entrant dans les
niveaux d'exécution 2 ou 3. respawn veut dire que si getty est tué, il se
relancera automatiquement.  /sbin/getty est la commande getty. Le -L veut
dire Local (ignorer les signaux de contrôle du modem). -h (non montré dans
l'exemple) permet le contrôle de flux matériel (même chose que stty crtscts).
19200 est la vitesse de transmission. ttyS1 veut dire /dev/ttyS1 (COM2 sous
MS-DOS). vt102 est le type de terminal et ce getty donnera cette valeur à la
variable d'environnement TERM. Il n'y a pas de fichiers de configuration.
Tapez "init q" sur la ligne de commande après avoir édité la ligne de getty
et vous devriez apercevoir une invite de login.</P>

<H3>La détection de parité de Agetty</H3>

<P>Le programme <CODE>agetty</CODE> détectera automatiquement la parité configurée dans
le terminal. Excpté si vous utilisez 8bit d'octet de données avec 1-bit de 
parité. Si vous utilisez <CODE>stty</CODE> pour fixer la parité, <CODE>agetty</CODE> la
désactivera automatiquement puisqu'il veut que le bit de parité passe comme
si c'était un bit de donnée. C'est parce qu'il a besoin d'obtenir le dernier
bit (qui peut être un bit de parité) pendant que vous tapez votre nom de
login afin d'auto-détecter la parité.  Donc, si vous utilisez la parité, ne
l'activez que du côté du terminal et laissez <CODE>agetty</CODE> la détecter
automatiquement et la positionner sur l'ordinateur. Si votre terminal
supporte la parité en réception, l'invite de login sera brouillée jusqu'à ce
que vous tapiez quelque chose et que getty positionne la parité. L'invite
brouillée repoussera les visiteurs etc. qui essaient de se logger. Cela peut
être exactement ce que vous voulez.</P>
<P>Il y a parfois des problèmes avec l'autodetection de parité. Cela arrive 
car après la première frappe de votre login, <CODE>agetty</CODE> utilise le programme 
<CODE>login</CODE> pour finir de vous loguer. Si le premier essai de login échoue, 
<CODE>login</CODE> se relance pour s'occuper des éssais futurs de login (incluant 
l'écriture de votre login). Le problème est que seulement agetty peut detecter 
la parité tandis que le programme <CODE>login</CODE> ne le fait pas. Donc, si vous 
remontez dans le programme <CODE>login</CODE> pour quelque raison que ce soit et que 
la parité n'a pas encore été détectée, vous etes en difficulté tant que le 
programme <CODE>login</CODE> ne peut pas detecter la parité. Avec une mauvaise parité, 
<CODE>login</CODE> ne peut pas lire correctement ce que vous écrivez et vous ne pouvez 
pas vous loguez. Si votre terminal supporte la réception de parité, vous 
continuerez à voir un écran brouillé.</P>
<P>On peut arriver dans cette "boucle de login" de plusieurs façons. Supposez que 
vous tapez une ou deux lettres seulement pour votre login et que vous tapez 
Entrée. Si ces lettres ne sont pas suffisantes pour la detection de parité, 
alors <CODE>login</CODE> se lancera avant que la parité soit detectée. Quelque fois ce 
problème arrive si vous n'avez pas le terminal allumé et connecté quand 
<CODE>agetty</CODE> démarre pour la première fois. Si vous restez bloqué dans cette 
"boucle de login", une solution est d'attendre à peu près une minute, le temps 
qu'agetty se relance dû au "timeout".</P>

<H3><A NAME="parity_8-bit"></A> La parité d'Agetty avec des octets de données de 8-bit</H3>

<P>Malheureusement, <CODE>agetty</CODE> ne peut pas detecter cette parité. Il (fin 1999) 
n'y a pas d'options pour desactiver l'auto-detection de parité et cela 
detectera les parités incorrects. Le résultat est que le processus de login 
sera brouillé et la parité sera mal reglé. Ainsi il ne parait pas faisable 
d'essayer d'utiliser des octets de données de 8-bit avec parité.</P>

<H3><A NAME="getty_ps"></A> getty (fait partie de getty_ps)</H3>


<P>(Ceci est tiré du vieux Serial-HOWTO de Greg Hankins).<BR> Ajoutez des
entrées pour <CODE>getty</CODE> pour utiliser votre terminal dans le fichier de
configuration <CODE>/etc/gettydefs</CODE> si elles ne sont pas déjà présentes :</P>
<P>
<PRE>
# 38400 bps Dumb Terminal entry
DT38400# B38400 CS8 CLOCAL # B38400 SANE -ISTRIP CLOCAL #@S @L login: #DT38400

# 19200 bps Dumb Terminal entry
DT19200# B19200 CS8 CLOCAL # B19200 SANE -ISTRIP CLOCAL #@S @L login: #DT19200

# 9600 bps Dumb Terminal entry
DT9600# B9600 CS8 CLOCAL # B9600 SANE -ISTRIP CLOCAL #@S @L login: #DT9600
</PRE>
</P>
<P>Si vous voulez, vous pouvez faire en sorte que <CODE>getty</CODE> affiche des choses
intéressantes dans la bannière de login. Dans mes exemples, je fais afficher
le nom du système et la ligne série. Vous pouvez ajouter d'autres choses :</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
@B    la vitesse courante (évaluée au moment où @B est rencontré).
@D    la date courante, au format MM/JJ/AA.
@L    la ligne série à laquelle est attaché getty.
@S    le nom du système.
@T    l'heure courante, au format HH:MM:SS (24 heures).
@U    le nombre d'utilisateurs actuellement loggés. C'est le compte
      du nombre d'entrées dans le fichier /etc/utmp qui possèdent
      un champ ut_name non nul.
@V    la valeur de VERSION, donnée dans les fichiers de valeurs par
      défaut.
Pour afficher un caractère '@', utilisez soit '\@', soit '@@'.
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Quand vous avez fini d'éditer <CODE>/etc/gettydefs</CODE>, vous pouvez vérifier
que la syntaxe est correcte en faisant :</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
linux# getty -c /etc/gettydefs
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Assurez-vous qu'il n'y a pas de fichier de configuration <CODE>getty</CODE> ou
<CODE>uugetty</CODE> pour le port série auquel est attaché votre terminal
(<CODE>/etc/default/{uu}getty.ttyS</CODE><EM>N</EM> ou
<CODE>/etc/conf.{uu}getty.ttyS</CODE><EM>N</EM>), car cela entrera sûrement en
conflit avec le lancement de <CODE>getty</CODE> sur un terminal. Enlevez le fichier
s'il existe.</P>
<P>Éditez le fichier <CODE>/etc/inittab</CODE> pour lancer <CODE>getty</CODE> sur le port
série (en mettant les informations correctes pour votre environnement --
port, vitesse et type de terminal par défaut) :</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
S1:23:respawn:/sbin/getty ttyS1 DT9600 vt100
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Relancez <CODE>init</CODE> :</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
linux# init q 
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>À ce point, vous devriez voir une invite de login sur votre terminal. Vous
devrez peut-être appuyer sur Retour pour que le terminal soit attentif.</P>

<H3>mgetty</H3>


<P>Le "m" veut dire modem. Ce programme est d'abord destiné aux modems et en
mi-1999 ne fonctionnait pas toujours très bien pour les terminaux texte.  Il
est très mal documenté pour les terminaux et vous devrez parcourir beaucoup
de documentation sur les modems pour déterminer comment l'utiliser pour un
terminal. Regardez les dernières lignes de /etc/mgetty/mgetty.config pour
avoir un exemple de la configuration d'un terminal. [Note du relecteur : je
le trouve au contraire bien documenté (janvier 1999) dans man mgetty : un
mgetty -r -s 9600 /dev/ttyS0 (par exemple) est suffisant. Le -r indique que
la connexion est directe (sans modem).] Ceci sera, espérons-le, réparé dans
le futur. Il serait bien d'avoir le même getty à la fois pour les terminaux
et les modems mais mgetty nécessite quelques améliorations avant de convenir
pour les deux utilisations.</P>

<H2><A NAME="stty_setserial"></A> <A NAME="ss14.2">14.2 Stty et Setserial</A>
</H2>


<P>Il y a à la fois une commande "stty" et une commande "setserial" pour
configurer les ports série. Certains (ou tous les) paramètres stty
nécessaires peuvent être positionnés grâce à getty et il peut ne pas être
nécessaire d'utiliser setserial ; l'utilisation de ces deux commandes peut
donc ne pas être nécessaire. Celles-ci (stty et setserial) paramètrent
différents aspects du port série. Stty en fait la plupart tandis que
setserial configure la partie bas niveau comme les interruptions et les
adresses de ports. Pour "sauvegarder" les paramètres, ces commandes doivent
être écrites dans certains fichiers (scripts shell) qui sont lancés à chaque
démarrage de l'ordinateur. Les distributions de Linux fournissent souvent un
script shell qui lance <CODE>setserial</CODE> mais en fournissent rarement un qui
lance <CODE>stty</CODE> tant qu'on en aura rarement besoin..</P>

<H2><A NAME="set_serial"></A> <A NAME="ss14.3">14.3 Setserial</A>
</H2>



<H3>Introduction</H3>


<P>N'utilisez jamais <CODE>setserial</CODE> avec des portables (PCMCIA). <CODE>setserial</CODE>
est un programme vous permettant d'indiquer au logiciel pilote l'adresse
d'entrée/sortie du port série, quelle interruption (IRQ) est positionnée dans
le matériel du port, le type d'UART que vous possédez, etc. Il peut aussi
vous montrer comment le pilote est configuré à ce moment. En plus, il peut
faire des requêtes au matériel (si certaines options sont données). </P>
<P>Si vous avez seulement un ou deux ports séries, ils seront bien configuré 
sans utiliser setserial. Autrement (ou si il y'a des problèmes avec ce port série) vous devrez utiliser setserial. En plus du manuel de <CODE>setserial</CODE>, 
regardez les informations dans <CODE>/usr/doc/setserial.../</CODE> ou autre. 
Cela devrait vous indiquer comment setserial se comporte dans votre 
distribution de Linux.</P>
<P><CODE>Setserial</CODE> est souvent lancé automatiquement au démarrage par un script
shell. Il ne fonctionnera que si le module série est chargé. Si vous devez
pour une raison ou pour une autre décharger le module série plus tard, les
modifications faites précédemment par <CODE>setserial</CODE> seront oubliées.
<CODE>Setserial</CODE> doit donc être re-lancé pour les prendre en compte à nouveau.
En plus de le lancer avec un script de démarrage, quelque chose semblable à
<CODE>setserial</CODE> se lance quand le module série est chargé. Ainsi quand vous
regardez les messages de démarrage sur l'écran il pourra vous sembler être
lancé deux fois, et en fait c'est ce qui s'est passé.</P>
<P>Setserial peut régler le temps que le port restera actif après qu'il soit
fermé (pour sortir les caractères qui sont encore dans leurs buffers dans
la RAM principale). C'est necéssaire pour un taux de transferts de 1200 baud
ou plus bas. C'est aussi necéssaire pour des vitesses plus rapides si il y'a
beaucoup de "contrôle de flux" en attente.</P>
<P>Si votre port série est Plug-and-Play, vous devrez peut-être consulter
d'autres HOWTOs, comme Plug-and-Play et Serial.</P>
<P>Avec les bonnes options, <CODE>setserial</CODE> peut chercher (à une adresse
d'entrée/sortie donnée) un port série mais vous devez deviner l'adresse
d'entrée/sortie. Si vous lui demandez de chercher /dev/ttyS2 par exemple, il
ne cherchera qu'à l'adresse où il pense trouver ttyS2. Si vous dites à
setserial que ttyS2 est à une adresse différente, alors il cherchera à cette
adresse, etc. Voyez 
<A HREF="#probing_ss">Recherche</A>.</P>
<P>Setserial ne positionne pas lui-même les IRQ ou les adresses d'entrée/sortie
dans le matériel du port série. Ceci est fait soit avec des
cavaliers, soit par plug-n-play. Vous devez dire à setserial les valeurs mêmes
qui ont été configurées dans le matériel. N'inventez pas simplement des 
valeurs dont vous pensez qu'elles font joli en les soumettant à setserial. 
Cependant, si vous connaissez les adresses d'entrée/sortie mais pas l'IRQ, 
vous pouvez demander à setserial de tenter de déterminer l'IRQ.</P>
<P>Vous pouvez voir une liste des commandes possibles et utilisables (mais pas
les options à une lettre telles que -v pour verbeux -- que vous devriez
normalement utiliser pour déboguer) en tapant simplement <CODE>setserial</CODE> sans
argument. Notez que setserial nomme une adresse d'entrée/sortie un "port". Si
vous tapez :</P>
<P>
<PRE>
setserial -g /dev/ttyS*
</PRE>
</P>
<P>vous verrez quelques informations sur la manière dont ce pilote de
périphériques est configuré pour vos ports. Ajoutez un "v" à l'option "-g"
pour en voir plus. Mais ceci ne vous dira pas si le matériel dispose vraiment
de ces valeurs. En fait, vous pouvez lancer setserial et assigner une adresse
d'entrée/sortie purement fictive, n'importe quelle IRQ, et tout type d'UART
que vous aimeriez avoir. Alors, la prochaine fois que vous lancerez
"setserial ...", il affichera ces valeurs fausses sans se plaindre. Notez que
les assignations faites par setserial sont perdues quand le PC est éteint
donc il est en général lancé automatiquement quelque part à chaque fois que
Linux est démarré.</P>

<H3><A NAME="probing_ss"></A> Recherche</H3>


<P>Afin de tenter de trouver si vous avez un certain type de matériel série,
vous devez d'abord savoir (ou deviner) son adresse d'entrée/sortie (ou le
pilote de périphérique doit en avoir une adresse d'entrée/sortie, sûrement
positionnée précédemment par setserial). Pour tenter de détecter le matériel
physique, utilisez l'option -v (verbeux) et la commande <CODE>autoconfig</CODE> de
<CODE>setserial</CODE>. Si le message résultant montre un type d'UART tel que 16550A,
alors tout est bon pour vous. Si par contre il affiche un type d'UART
"<CODE>unknown</CODE>" (inconnu), alors il n'y a sûrement pas de port série du tout à
cette adresse d'entrée/sortie. Certains ports série bon marché ne
s'identifient pas correctement donc si vous voyez "<CODE>unknown</CODE>" vous avez
peut-être quand même un port série à cet endroit.</P>
<P>En plus de faire une auto-détection sur le type d'UART, setserial peut aussi
déterminer automatiquement les IRQs, mais ceci ne fonctionne pas toujours
bien non plus. Dans les versions de setserial >= 2.15, votre dernier test de
recherche peut être sauvé et placé dans le fichier de configuration
<CODE>/etc/serial.conf</CODE> qui sera utilisé au prochain démarrage de Linux. Le
script qui lance <CODE>setserial</CODE> au démarrage ne fait généralement pas de
recherche, mais vous pouvez le modifier pour qu'il le fasse. Voyez la section
suivante.</P>

<H3>Linux peut-il configurer les périphériques série automagiquement ?</H3>


<P>Oui, mais... Votre distribution doit deja le faire au démarrage. Mais vous pouvez le customiser. C'est facile à faire avec setserial &lt; 2.15. Ajoutez 
simplement quelques lignes au fichier qui lance setserial au démarrage. 
Voyez 
<A HREF="#old_sets_script">vieille méthode de configuration :  édition d'un script</A>. Par exemple, pour ttyS3 vous ajouteriez :</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
/sbin/setserial /dev/ttyS3 auto_irq skip_test autoconfig
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>au fichier qui lance setserial au démarrage. Faites ceci pour chaque port
série que vous voulez auto-configurer. Assurez-vous de donner un nom de
périphérique qui existe vraiment sur votre machine. Dans certains cas ca ne 
marchera pas bien à cause du matériel, donc vous pouvez lui assigner un
irq et/ou un type d'uart. Par exemple:
<BLOCKQUOTE><CODE>
<PRE>
/sbin/setserial /dev/ttyS3 irq 5 uart 16550A skip_test
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Pour les versions >= 2.15 (à condition que votre distribution ait inclus la
modification, Redhat ne l'a pas fait), il est plus difficile de le faire
puisque le fichier qui lance setserial au démarrage, /etc/init.d/setserial ou
autre n'a pas été prévu pour être édité par l'utilisateur. Il peut ne pas y
avoir de commentaires utiles comme il y en avait dans les versions
précédentes.</P>

<H3><A NAME="sets_boot_time"></A> Configuration au démarrage</H3>


<P>Quand le noyau charge le module série (ou si le "module" est intégré au
noyau) alors seuls <CODE>ttyS{0-3}</CODE> sont auto-détectés et le pilote est
configuré avec les IRQs 4 et 3 (peu importe la configuration réelle du
matériel). Vous le voyez sur un message au démarrage comme si <CODE>setserial</CODE>
avait été lancé. Si vous utilisez 3 ports ou plus, ceci peut engendrer des
conflits d'IRQ.</P>
<P>Pour régler de tels conflits en donnant à setserial les vraies IRQs (ou pour
d'autres raisons) il peut y avoir un fichier quelque part qui lance
<CODE>setserial</CODE> à nouveau. Ceci se passe tôt pendant le démarrage avant que
n'importe quel processus utilise le port série. En fait, votre distribution
peut avoir configuré les choses pour que le programme setserial se lance
automatiquement à partir d'un script au démarrage. On peut trouver plus
d'informations pour gérer cette situation dans /usr/doc/setserial.../ ou
autre.</P>

<H3>Nouvelle méthode de configuration en utilisant /etc/serial.conf</H3>


<P>les versions inferieurs à la 2.15 de <CODE>setserial</CODE>, la façon pour 
le configurer était d'édité le script shell qui lancait setserial 
au démarrage. Avec la version 2.15 (1999) de <CODE>setserial</CODE> le 
script shell n'est pas édité mais est lancé au démarrage et obtient 
ses données à partir d'un fichier de configuration: /etc/serial.conf. 
Mais on n'édite normalement jamais /etc/serial.conf. À la place, 
utilisez simplement <CODE>setserial</CODE> sur la ligne de commande.</P>
<P>Normalement, ce que vous avez modifié avec la commande setserial est sauvé
dans le fichier de configuration (serial.conf) quand vous éteignez
(normalement) ou que vous redémarrez. Ceci ne fonctionne que si
"###AUTOSAVE###" ou similaire se trouve sur la première ligne de serial.conf.
Si vous devez utiliser <CODE>setserial</CODE> de manière expérimentale et qu'il ne
fonctionne pas correctement, alors n'oubliez pas de le relancer pour que les
paramètres expérimentaux ne soient pas sauvés par erreur. Le fichier le plus
couramment utilisé pour lancer setserial au démarrage (en restant conforme
avec le fichier de configuration) est maintenant /etc/init.d/setserial
(Debian) ou /etc/init.d/serial (Redhat), ou etc., mais ne devrait normalement
pas être édité non plus.</P>
<P>Pour désactiver un port, utilisez <CODE>setserial</CODE> pour le positionner à "uart
none". Le format de /etc/serial.conf apparaît être comme celui des paramètres
placés après "setserial" sur la ligne de commande avec une ligne pour chaque
port. Si vous n'utilisez pas autosave, vous pouvez éditer /etc/serial.conf à
la main. Pour la version 2.15, la distribution Debian installe le système
avec la sauvegarde automatique activée, mais Redhat 6.0 avait simplement un
fichier /usr/doc/setserial-2.15/rc.serial que vous deviez déplacer dans
/etc/init.d/.</P>
<P>BOGUE : en juillet 1999 il un bogue/problème puisqu'avec ###AUTOSAVE### seuls
les paramètres de setserial affichés par "setserial -G /dev/ttyS?" (où ? vaut
0, 1, 2, ...) sont sauvés mais pas les autres paramètres. Ceci n'affecte
qu'une minorité d'utilisateurs puisque les paramètres non sauvés sont de
toute façon rarement utilisés. Cela a été rapporté comme un bogue et peut
être réparé maintenant.</P>
<P>Afin de forcer les paramètres courants positionnés par setserial à être
sauvés dans le fichier de configuration (serial.conf) sans éteindre la
machine, faites ce qui se passe normalement quand vous éteignez : lancez le
script shell <CODE>/etc/init.d/{set}serial stop</CODE>. La commande "stop"
sauvera la configuration courante mais les ports série continueront de
fonctionner correctement.</P>
<P>Dans certains cas vous pouvez avoir l'ancienne et nouvelle méthode d'installé 
mais heureusement juste une d'elles se lance au démarrage.
Debian étiquette les fichiers obsolètes avec "...pre-2.15".</P>

<H3><A NAME="old_sets_script"></A> Ancienne méthode de configuration : édition d'un script</H3>


<P>Avant la version 2.15 (1999) il n'y avait pas /etc/setserial.conf pour configurer setserial.
Ainsi vous devez chercher un fichier qui lance setserial au 
démarrage et l'édité. S'il n'existe pas, vous devez en créer un (ou placer
les commandes dans un fichier qui se lance tôt au démarrage). Si un tel
fichier est utilisé en ce moment, il se trouve sûrement dans l'arborescence
/etc. Mais Redhat &lt;6.0 l'a mis dans /usr/doc/setserial/ bien que vous deviez le
déplacer dans l'arborescence /etc avant de l'utiliser. Vous pouvez utiliser
"locate" pour essayer de trouver un tel fichier. Par exemple, vous pouvez
taper : locate "*serial*".</P>
<P>Ce que pouvez chercher peut s'appeler rc.serial ou 0setserial (Debian). Si un
tel fichier est fourni, il devrait contenir un certain nombre d'exemples
commentés. En décommentant certains d'entre eux et/ou en les modifiant, vous
devriez pouvoir configurer les choses correctement. Assurez-vous que vous
utilisez un chemin valide pour <CODE>setserial</CODE>, et un nom de périphérique
valide. Vous pouvez faire un test en exécutant ce fichier à la main (tapez
simplement son nom en tant que super-utilisateur) pour voir si ça fonctionne
bien. Un test comme celui-ci est bien plus rapide que de faire des
redémarrages à répétition pour avoir le bon résultat. Bien sûr, vous pouvez
aussi tester une commande <CODE>setserial</CODE> unique en la tapant simplement sur
la ligne de commande.</P>
<P>Le script <CODE>/etc/rc.d/rc.serial</CODE> était couramment utilisé dans le passé.
La distribution Debian a utilisé <CODE>/etc/rc.boot/0setserial</CODE>. Un autre
fichier qui a été utilisé est <CODE>/etc/rc.d/rc.local</CODE> mais ce n'est pas
une bonne idée car il peut ne pas être lancé assez tôt. On a indiqué que
d'autres processus peuvent essayer d'ouvrir le port série avant l'exécution
de rc.local, ce qui entraîne des échecs de communication série.</P>

<H3>IRQs</H3>


<P>Par défaut, ttyS0 et ttyS2 partagent l'IRQ 4, tandis que ttyS1 et ttyS3
partagent l'IRQ 3. Le partage des interruptions série n'est permis que si :
1. vous avez un noyau 2.2 ou supérieur, 2. vous avez compilé le support
pour le faire et 3. votre matériel série le supporte. Voyez le HOWTO Série,
sur le partage des interruptions et les noyaux 2.2 et plus.</P>
<P>Si vous n'avez que deux ports série, ttyS0 et ttyS1, cela fonctionne encore
puisque les conflits de partage d'IRQ n'existent pas pour des périphériques
non existants.</P>
<P>Si vous ajoutez un modem interne et gardez ttyS0 et ttyS1, vous devriez alors
tenter de trouver une IRQ non utilisée et la positionner à la fois sur votre
port série (ou carte modem) et ensuite utiliser setserial pour l'assigner à
votre pilote de périphérique. Si l'IRQ 5 n'est pas utilisée par une carte
son, ce peut être une IRQ utilisable pour un modem. Pour positionner l'IRQ de
manière matérielle vous devrez peut-être utiliser isapnp, un BIOS PnP ou
modifier Linux pour le rendre PnP. Pour vous aider à déterminer quelles IRQs
sont disponibles, tapez "man setserial" et cherchez, disons "IRQ 11".</P>



<H2><A NAME="stty_"></A> <A NAME="ss14.4">14.4 Stty</A>
</H2>



<H3>Introduction</H3>


<P><CODE>stty</CODE> effectue la plupart de la configuration du port série mais puisque
les applications (et le programme getty) la gèrent souvent, vous n'aurez
peut-être pas besoin de l'utiliser souvent. C'est pratique si vous avez des
problèmes ou voulez voir comment le port est paramétré. Essayez de taper
``stty -a'' sur votre terminal/console pour voir les paramètres actuels.
Essayez aussi de taper la commande sans le -a (all = tout) pour obtenir une
liste courte qui montre les paramètres différents de la normale. N'essayez
pas d'apprendre tous les réglages à moins de vouloir devenir un gourou du
port série. La plupart des valeurs par défaut conviennent et certains
réglages ne sont nécessaires que pour certains terminaux non-intelligents et
obsolètes fabriqués dans les années 1970 (Mais pas après)</P>
<P>Alors que <CODE>setserial</CODE> ne travaille qu'avec les ports série réels, stty
s'utilise à la fois pour les ports série et pour les terminaux virtuels comme
l'interface texte standard de Linux sur un moniteur de PC. Pour le moniteur
de PC, la plupart des paramètres de stty n'ont pas de signification. Le
changement de la vitesse de transmission, etc. ne semble pas faire grand
chose.</P>
<P>Voici quelques uns des items que stty peut configurer : vitesse
(bits/seconde), parité, bits par octet, nombre de bits de stop, enlever
le 8ème bit ?, signaux de contrôle du modem, contrôle de flux, signal
d'arrêt, délimiteurs de fin de ligne, changer la casse, remplissage, sonner
si le tampon déborde ?, écho, permettre à des tâches de fond d'écrire sur le
terminal ?, définir des caractères spéciaux (de contrôle, comme quelle touche
presser pour faire une interruption).  Voyez la page de manuel de <CODE>stty</CODE>
ou la page info pour plus de détails.  Voyez aussi la page de manuel :
<CODE>termios</CODE> qui couvre les mêmes options que stty mais (en mi-1999) couvre
des possibilités que la page de manuel de stty ne mentionne pas. Pour
l'utilisation de certains caractères spéciaux, voyez 
<A HREF="#stty_chars">caractères spéciaux (de contrôle)</A>.</P>
<P>Avec certaines implémentations de getty (paquet getty_ps), les commandes
qu'on enverrait normalement à stty sont entrées dans un fichier de
configuration getty : /etc/gettydefs. Même sans ce fichier de configuration,
la ligne de commande de getty devrait suffire pour paramètrer les choses de
sorte que vous n'ayez pas besoin de stty.</P>
<P>On peut écrire des programmes en C qui modifient la configuration de stty
etc. Regarder la documentation pour ce faire peut aider quelqu'un à mieux
comprendre l'utilisation des commandes stty (et ses nombreux arguments
possibles). Le Serial-Programming-HOWTO est utile. La page de manuel de
termios contient la description de la structure au sens langage C (de type
termios) qui stocke la configuration de stty dans la mémoire de l'ordinateur.
Bien des noms de drapeaux dans cette structure C sont quasiment les mêmes (et
font la même chose) que les arguments de la commande stty.</P>

<H3>Utilisation de stty pour un terminal "étranger"</H3>


<P>L'utilisation de <CODE>stty</CODE> pour inspecter ou configurer le terminal que vous
utilisez est facile. Faire ca pour terminal (étranger) different ou un port 
série est délicat. Par exemple, supposons que êtes sur le moniteur du
PC (tty1) et vouliez utiliser <CODE>stty</CODE> pour le port série ttyS2. Vous devez
utiliser l'opérateur de redirection &lt;. D'abord, soyez prévenu que s'il y a
un terminal sur ttyS2 et un shell tourne sur ce terminal, ce que vous verrez
alors sera décevant et une tentative de le paramétrer sera infructueuse.
Voyez 
<A HREF="#2_term_interfaces">deux interfaces sur un terminal</A>
pour comprendre ceci.</P>
<P>Tapez ``stty -a &lt; /dev/ttyS2'' pour regarder les paramètres de ttyS2.
Utilisez le même opérateur de redirection &lt; pour paramétrer ttyS2.
Cela fait de ttyS2 l'entrée standard de stty. Ca donne au programme stty
un lien vers le "fichier" ttyS2 donc il doit le "lire". Mais au lieu de lire
les octets envoyés vers ttyS2 comme on pourrait le prévoir, il utilise le lien
pour trouver les paramètres de configuration du port donc il devrait les lire 
ou les changer. Certaines personnes tentent d'utiliser ``stty ... &gt; /dev/ttyS2'' 
pour paramétrer le terminal. Ceci ne le fera pas. À la place, il prendra le
message normal affiché par la commande stty pour le terminal sur lequel vous
êtes (tty1) et envoie ce message à ttyS2 mais ne change aucun paramètre pour
ttyS2.</P>
<P>Arrive un autre problème avec l'opérateur de redirection. Quelques fois quand on 
essaye d'utiliser stty, la commande s'arrette et rien ne se passe ( vous n'avez 
pas de prompt pour une autre commande, même après avoir frapper &lt;entrée&gt;).
C'est probablement due au port étant bloqué car il attend une ligne de controle
modem pour être déclaré. Par exemple, tant que vous n'avez pas parametrer "clocal" 
pour ignorer les lignes de controles modem, Alors si il n'y a pas de signal CD 
de déclaré, le port ne s'ouvrira pas et stty ne fonctionnera pas. Une situation 
similaire doit exister pour le control de flux materiel. Si le cable du port n'a 
pas de fils pour la broche qui doit être déclaré donc il n'y a pas besoin 
d'arreter l'attente.</P>
<P>Une façon à essayer pour se passer de cette attente, est d'utiliser un programme 
sur le port qui le forcera à être opérationnel même si les lignes de controles 
disent le contraire. Ainsi heureusement, ce programme doit parametrer le port 
donc il n'a plus besoin du signal de controle pour ouvrir: clocal ou -crtscts.
Pour se servir de "minicom" pour faire ca, il faut le reconfigurer pour un autre 
ttyS, etc, et le redémarrer. Puisque vous avez à reconfigurer minicom, c'est plus 
simple de redémarrer le PC.  </P>
<P>Les versions à partir de 1.17 (pas encore sortie en mi-1999) n'auront plus
besoin de la redirection (&lt;) mais à la place utiliseront ``stty ... -F
/dev/ttyS2'' (ou --file au lieu de -F), etc. Cela devrait forcer le port à s'ouvrir 
et eviter le second problème de redirection.</P>

<H3><A NAME="2_term_interfaces"></A> Deux interfaces sur un terminal</H3>


<P>En utilisant un shell (tel que bash) avec l'édition de la ligne de commande
activée, il y a deux interfaces de terminal différentes (ce que vous voyez
quand vous tapez stty -a). Quand vous tapez sur la ligne de commande vous
avez une interface "brute" temporaire (mode brut, ou "raw") où chaque
caractère est lu par l'éditeur de ligne de commande au moment où vous le
tapez. Une fois que vous appuyez sur la touche &lt;entrée&gt;, l'éditeur de
ligne de commande sort et l'interface du terminal est modifiée en interface
nominale "améliorée" (mode amélioré ou "cooked") pour le terminal. Ce mode
amélioré dure jusqu'à ce que l'invite suivante soit envoyée au terminal.
Notez qu'on ne tape jamais rien dans ce mode "amélioré" mais ce qui a été tapé 
en mode raw passe en mode amélioré dès qu'on a tapé sur la touche &lt;entrée&gt;.</P>
<P>Quand une invite est envoyée au terminal, le terminal passe du mode
"amélioré" au mode "brut" (comme il le fait quand vous démarrez un éditeur
puisque vous démarrez l'éditeur de ligne de commande). Les paramètres pour le
mode "brut" ne sont basés que sur les paramètres de base pris à partir du
mode "amélioré". Le mode brut garde ces paramètres mais modifie plusieurs
autres paramètres afin de passer en mode "brut". Il n'est pas du tout basé
sur les paramètres utilisés dans le mode "brut" précédent. Ainsi si on
utilise stty pour modifier les paramètres du mode brut, de tels paramètres
seront perdus dès qu'on appuiera sur la touche &lt;entrée&gt; sur le terminal
qu'on suppose avoir "configuré".</P>
<P>Maintenant, quand on utilise tape stty pour regarder l'interface du terminal,
on peut avoir une vue soit du mode amélioré, soit du mode brut. Vous devez
trouver lequel vous regardez. Si vous utilisez stty à partir d'un autre
terminal pour vous occuper d'un terminal  qui affiche une ligne de commande,
vous aurez la vue du mode brut. Tout changement effectué ne le sera que pour
le mode brut et sera perdu quand quelqu'un appuiera sur &lt;entrée&gt; sur le
terminal que vous avez tenté de "paramétrer". Mais si vous tapez une commande
stty sur votre terminal (sans utiliser &lt; pour la redirection) et ensuite
tapez sur &lt;entrée&gt;, c'est une histoire différente. &lt;entrée&gt; met
le terminal en mode amélioré. Vos modifications seront sauvées et seront
toujours présentes quand le terminal reviendra en mode brut (sauf, bien sûr,
si c'est un paramètre non permis en mode brut).</P>
<P>Cette situation peut créer des problèmes. Par exemple, supposez que vous
corrompez votre interface de terminal et que pour la récupérer vous alliez
sur un autre terminal et tapiez "stty sane &lt;dev/ttyS1" pour la récupérer.
Ceci ne fonctionnera pas ! Bien sûr vous pouvez essayer de taper "stty sane
..." sur le terminal corrompu mais vous ne pouvez pas voir ce qui est tapé.
Tout ce qui précède ne s'applique pas aux terminaux non-intelligents mais aux
terminaux virtuels utilisés sur un moniteur de PC ainsi que sur les terminaux
fenêtrés sous X. En d'autres termes, ceci s'applique à presque tout le monde
qui utilise Linux. Heureusement, un fichier qui lance stty au démarrage
s'occupera certainement d'un terminal (ou d'un port série sans terminal)
n'ayant aucun shell tournant dessus, donc il n'y a pas de problème.</P>

<H3><A NAME="stty_where"></A> Où mettre la commande stty ?</H3>


<P>Si vous avez besoin que <CODE>stty</CODE> configure l'interface série à chaque fois
que l'ordinateur démarre, vous devez mettre la commande <CODE>stty</CODE> dans un
fichier qui sera exécuté à chaque démarrage de l'ordinateur (de Linux). Il
devrait être lancé avant l'utilisation du port série (ce qui comprend le
lancement de getty sur le port). Il y a de nombreux endroits disponibles pour
le mettre. S'il est mis à plus d'un endroit et que vous n'en connaissez (ou
rappelez) qu'un, il y aura sûrement un conflit. Assurez-vous donc de
documenter ce que vous faites.</P>
<P>Un bon endroit pour placer cette commande serait dans le même fichier qui
lance setserial quand le système démarre. L'emplacement dépend des distributions 
et des versions. Il semblerait mieux de la placer après la
commande setserial pour que la partie de bas niveau soit faite en premier.
Si vous avez un répertoire dans le /etc où tous les fichiers sont éxecutés au 
démarrage (System V Init), ainsi vous pourriez créer un fichier nommé "stty" dans ce but.</P>

<H2><A NAME="termcap1"></A> <A NAME="ss14.5">14.5 Terminfo et Termcap (bref)</A>
</H2>


<P>Voyez 
<A HREF="#termcap2">Terminfo et Termcap (en détails)</A> pour une
discussion plus détaillée sur terminfo. Beaucoup d'applications que vous
lancez utilisent la base de données terminfo (anciennement termcap). Celle-ci
possède une entrée (ou fichier) pour chaque modèle ou type (tel que le vt100)
de terminal et indique ce que le terminal peut faire, quels codes envoyer
pour diverses actions, et quels codes envoyer au terminal pour l'initialiser.</P>
<P>Puisque beaucoup de terminaux (et de PC aussi) peuvent émuler d'autres
terminaux et possèdent des "modes" d'opération variés, il peut y avoir
plusieurs entrées terminfo parmi lesquelles choisir pour un terminal physique
donné. Ils auront en général des noms similaires. Le dernier paramètre de
getty (à la fois pour agetty et getty_ps) devrait être le nom terminfo du
terminal (ou de l'émulation de terminal) que vous utilisez (comme vt100).</P>
<P>La base terminfo fait plus que simplement spécifier de quoi le terminal est
capable et de donner les codes à envoyer au terminal pour le faire faire
certaines choses. Elle spécifie à quoi "gras" ressemblera (sera-ce en vidéo
inverse ou en intensité forte), comment sera le curseur, si les lettres
seront noires, blanches ou d'une autre couleur, etc. En terminologie PC on
appelle ceci des "préférences". Elle spécifie les codes d'initialisation à
envoyer au terminal (analogues aux chaînes d'initialisation qu'on envoie aux
modems). Linux n'envoie pas automatiquement de telles chaînes au terminal.
Voyez 
<A HREF="#init_string">chaîne d'initialisation</A>. Si vous n'aimez
pas l'affichage à l'écran ni son comportement, vous devrez peut-être éditer
(et ensuite mettre à jour) le fichier terminfo (ou termcap). Voyez 
<A HREF="#tic">compilateur terminfo (tic)</A> sur la manière de faire la mise à
jour.</P>

<H2><A NAME="ss14.6">14.6 Positionner TERM et TERMINFO</A>
</H2>


<P>Voici deux variables d'environnement pour les terminaux : TERM et TERMINFO,
mais vous ne devriez rien avoir à faire avec elles. TERM doit toujours être
positionnée au nom du terminal que vous utilisez (comme vt100). Si vous ne 
connaissez pas son type (nom), voyez 
<A HREF="#term_name">quel est le  nom terminfo de mon terminal ?</A>. TERMINFO contient le chemin vers la base 
de données terminfo, mais peut ne pas être nécessaire si la base de données 
est dans un endroit prédéfini (ou TERMINFO peut être positionné 
automatiquement par un fichier qui est livré avec votre distribution de Linux). 
Vous voudrez voir 
<A HREF="#tc_compiled_locs"> Emplacement des bases de  données compilées</A>.</P>
<P>Heureusement, le programme getty positionne en général TERM pour vous juste
avant le login. Il utilise juste le type de terminal qui a été spécifié sur 
la ligne de commande de getty (dans /etc/inittab). Cela permet aux applications 
de trouver le nom de votre terminal et ensuite de regarder les capacités du 
terminal dans la base de données terminfo. Voyez 
<A HREF="#term_var">variable TERM</A> pour plus de détails sur TERM.</P>
<P>Si votre base de données terminfo ne peut pas être trouvée, vous verrez un
message d'erreur à ce propos sur votre terminal. Si cela arrive il est temps
de vérifier où réside terminfo et de positionner TERMINFO si nécessaire. Vous
pouvez découvrir où se trouve la base de données terminfo en cherchant un
fichier terminfo courant comme "vt100" avec la commande "locate".
Assurez-vous que votre terminal est dans cette base de données. Un exemple de
positionnement de TERMINFO : export TERMINFO=/usr/share/terminfo (mettez ceci
dans /etc/profile ou autre). Si les données concernant votre terminal dans
cette base de données ne vous conviennent pas, vous devrez l'éditer. Voyez
<A HREF="#termcap1">terminfo et termcap (bref)</A>.</P>

<H3><A NAME="term_name"></A> Quel est le nom terminfo de mon terminal ?</H3>


<P>Vous avez besoin du nom exact afin de positionner la variable d'environnement
TERM ou pour renseigner <CODE>getty</CODE>. Le même nom doit être utilisé à la fois
par la base termcap et la base terminfo, vous n'avez donc besoin de le
trouver qu'une seule fois. Un terminal dispose généralement d'alias mais si
vous trouvez plus d'un nom, utilisez le premier.</P>
<P>Pour le trouver, essayez de regarder le fichier /etc/termcap... (si vous
l'avez). Sinon, regardez soit dans l'arborescence terminfo (voyez ref
id="tc_compiled_locs" name="emplacement des bases de données compilées">),
soit essayez de trouver le fichier de code source de terminfo (voyez ref
id="tc_source_loc" name="emplacements du code sources des bases de
données">).</P>

<H2><A NAME="ss14.7">14.7 Fichier /etc/ttytype rarement nécessaire</A>
</H2>


<P>Le fichier de configuration /etc/ttytype est utilisé pour faire la
correspondance entre /dev/ttySn et les noms de terminaux comme dans terminfo.
tset l'utilise, mais si la variable d'environnement TERM est déjà positionnée
correctement, alors ce fichier n'est pas nécessaire. Puisque le getty de
Linux positionne TERM pour chaque tty, vous n'avez pas besoin de ce fichier.
Dans d'autres systèmes Unix comme FreeBSD, le fichier /etc/ttys fait la
correspondance entre les ttys et bien plus de choses, comme la commande getty
appropriée, et la catégorie de connexion (comme "dialup"). Un exemple de
ligne pour le ttytype sous Linux&nbsp;: vt220 ttyS1</P>

<H2><A NAME="login_restr"></A> <A NAME="ss14.8">14.8 Restrictions sur les logins</A>
</H2>


<P>Par défaut, l'utilisateur root ne peut pas se logger à partir d'un terminal.
Pour permettre cela vous devez créer (ou éditer) le fichier /etc/securetty en
suivant la page de manuel "securetty". Mais cette utilisation est spécifique 
à la distribution, la Suse n'utilise pas /etc/securetty.  Pour restreindre les logins de
certains utilisateurs et/ou de certains terminaux etc., éditez
/etc/login.access (cela remplace le vieux fichier /etc/usertty ??).
/etc/login.defs détermine si /etc/securetty doit être utilisé et peut être
édité afin que /etc/securetty ne soit pas nécessaire (ou utilisé).
/etc/porttime restreint les heures auxquelles certains ttys et utilisateurs
peuvent utiliser l'ordinateur. S'il y a trop de tentatives de login ratées
pour un utilisateur, cet utilisateur peut se voir interdire l'accès au
système. Voyez la page de manuel "faillog" sur la manière de contrôler cela.</P>

<H2><A NAME="ss14.9">14.9 Lancer des commandes uniquement si TERM=mon_terminal</A>
</H2>


<P>Il y a parfois des commandes qu'on ne veut exécuter au démarrage que pour un
certain type de terminal. Faire cela pour la commande stty ne pose pas de
problèmes puisque l'on utilise l'opérateur de redirection &lt; pour spécifier le
terminal vers lequel la commande est destinée. Mais quid des alias de shell
ou des fonctions&nbsp;? Vous aurez envie de créer une fonction pour la
commande ls qui mettra en couleur la liste des répertoires uniquement sur des
terminaux couleur ou sur la console. Pour les terminaux monochromes vous
voudrez le même nom de fonction (mais un corps de fonction différent) qui
utilisera des symboles à la place du codage par couleurs. Où mettre de telles
définitions de fonctions qui doivent être différentes pour des terminaux
différents ?</P>
<P>Vous pouvez les mettre à l'intérieur d'opérateurs "if" dans /etc/profile qui
est lu au départ à chaque fois que quelqu'un se logge. L'opérateur
confitionnel "if" définit certaines fonctions etc., seulement si le terminal
est d'un type spécifique.</P>

<H3><A NAME="ls_color"></A> Exemple pour la fonction ls</H3>


<P>Bien que la plupart de ce que fait cet opérateur if puisse être fait dans le
fichier de configuration de dircolors, voici un exemple dans le cas du shell
bash&nbsp;:</P>
<P>
<HR>
<PRE>
if [ "$TERM" = linux ]; then
    eval `dircolors`;
elif [ "$TERM" = vt220 ]; then
    ls () { command ls -F $* ; }
# pour exporter la fonction ls():
    declare -xf ls
else echo "De /etc/profile : terminal de type $TERM inconnu"
fi
</PRE>
<HR>
</P>

<H2><A NAME="termcap2"></A> <A NAME="s15">15. Terminfo et Termcap (en détails)</A></H2>



<H2><A NAME="ss15.1">15.1 Introduction à Terminfo</A>
</H2>


<P>Terminfo (anciennement termcap) est une base de données des capacités des
terminaux et plus. Pour chaque (enfin presque) modèle de terminal elle
indique aux applications ce que le terminal est capable de faire. Elle
indique quelles séquences d'échappement (ou caractère de contrôle) envoyer au
terminal afin de faire des choses telles que déplacer le curseur vers un
nouvel endroit, effacer une partie de l'écran, faire défiler l'écran, changer
de mode, changer l'apparence (couleurs, luminosité, clignotement,
soulignement, vidéo inverse, etc.). À partir de 1980 environ, beaucoup de
terminaux supportaient plus d'une centaine de commandes (certaines d'entre
elles prenant des paramètres numériques).</P>
<P>La façon dont terminfo donne les information a un programme est par les fonctions 
"ncurses" que le programmeur met dans un programme C. Par exemple si un programme 
veut bouger le curseur à la ligne 3, colonne 6, il appelle simplement: move(3,6). 
La fonction move() (faisant partie de ncurses) sait comment faire pour votre 
terminal (elle peut lire terminfo). Donc il envoit la sequence d'échappement 
appropriée au terminal qui lui fait faire ce mouvement.</P>
<P>Les abréviations terminfo sont en général plus longues que celles de termcap
et il est ainsi plus facile de deviner ce qu'elles veulent dire. Les pages de
manuel de terminfo sont plus détaillées (et incluent les anciennes
abréviations de termcap). Ainsi, sauf si vous êtes déjà obligé de travailler
avec termcap, il est suggéré que vous utilisiez les fichier terminfo.</P>

<H2><A NAME="database"></A> <A NAME="ss15.2">15.2 Base de données terminfo</A>
</H2>



<H3>Introduction</H3>


<P>La base de données terminfo est compilée et possède ainsi une partie source
et une partie compilée. La vieille base de données termcap ne possède qu'une
partie source mais cette source peut, grâce à une seule commande, être à la
fois convertie en source terminfo et ensuite compilée. Vous pouvez ainsi vous
en tirer sans avoir le source terminfo puisque le source termcap peut créer
la base terminfo compilée. Pour voir un affichage de la base de données pour
le terminal que vous utilisez actuellement (y compris un moniteur de PC),
tapez "infocmp" et vous devriez voir le "fichier" source terminfo
correspondant.</P>
<P>Pour voir si votre terminal (disons vt100) est dans la base de données
terminfo, tapez "locate vt100". Si vous ne connaissez pas le nom de votre
terminal, explorez la liste des fichiers dans la base de données compilée ou
voyez 
<A HREF="#term_name">quel est le nom terminfo de mon terminal ?</A>.</P>

<H3>Où se trouve la base de données ?</H3>



<H3><A NAME="tc_compiled_locs"></A> Emplacements de la base de données compilée </H3>


<P>Le fait de taper "locate vt100" peut vous indiquer /usr/lib/terminfo/v/vt100,
/usr/share/terminfo/v/vt100, /home/vous/.terminfo/v/vt100 et/ou
/etc/terminfo/v/vt100. Tout ceci sont des localisations possibles des
fichiers terminfo compilés. Quoique le répertoire /etc/terminfo ne soit pas 
l'emplacement standard pour ca, avoir quelques types de terminal a cet endroit 
peut être pratique au cas ou le répertoire /usr ne soit pas accessible. 
Par exemple, /usr peut être placé sur un disque ou une partition qui n'ait pas 
pue être montée. Normalement, les applications qui utilisent votre base de donnée 
terminfo principale sont capables de les trouver si il est mis dans au moin un des 
emplacements mentionnés avant. Autrement la variable d'environnement TERMINFO 
devrait être positionnée sur le chemin vers cette base de données.  Exemple :
TERMINFO=/usr/share/terminfo.</P>
<P>Si le terminfo compilé se trouve à plus d'un endroit, tout se passe en
général bien jusqu'à ce que quelqu'un récupère un ou plusieurs fichiers
terminfo (d'une distribution plus récente, d'Internet, en éditant la plus
vieille, etc.). Le nouveau terminfo doit être placé à tous les emplacements
existants (ou les emplacements redondants doivent être abolis). Si vous ne
vous assurez pas que c'est fait, alors plusieurs applications peuvent se
retrouver à chercher et utiliser les anciennes données terminfo (boguées) qui
existent encore à un emplacement "traditionnel".</P>

<H3><A NAME="tc_source_loc"></A> Emplacements du code source des bases de données</H3>


<P>Le code source que vous utilisez peut résider dans /etc/termcap et/ou dans
terminfo.src (ou un autre nom). Voyez les pages de manuel : terminfo(5) ou
termcap(5) pour voir le format nécessaire pour créer (ou modifier) ces
fichiers source. Le fichier terminfo.src peut se trouver en divers endroits
sur votre ordinateur ou peut ne pas être inclus dans votre distribution
Linux.  Utilisez la commande locate pour essayer de le trouver. Il est
disponible pour téléchargement (sous le nom termtypes.ti) à 
<A HREF="http://sagan.earthspace.net/terminfo">http://sagan.earthspace.net/terminfo</A>.</P>

<H3><A NAME="tic"></A> Compilateur terminfo (tic)</H3>


<P>Les données des fichiers sources sont compilées avec le programme "tic" qui
est capable de faire les conversions entre les formats termcap et terminfo.
Vous pouvez ainsi créer une base de données terminfo compilée à partir d'un
source termcap. Le programme d'installation utilisé pour installer Linux a
probablement installé les fichiers compilés sur votre disque dur donc vous ne
devez rien compiler sauf si vous modifiez /etc/termcap (ou terminfo.src).
"tic" installera automatiquement les fichiers compilés résultant dans un
répertoire terminfo prêt à être utilisé par les applications.</P>

<H3><A NAME="infocmp"></A> Regardez votre terminfo</H3>


<P>C'est une bonne idée de jeter un coup d'oeil à votre entrée terminfo pour le
terminal que vous utilisez (le code source, bien sûr) et de lire les
commentaires. Une manière rapide de l'inspecter sans les commentaires est de
taper simplement "infocmp". Mais les commentaires pourront vous dire des
choses spéciales sur le terminal comme la manière dont vous devez le
configurer pour qu'il fonctionne correctement avec la base de données
terminfo.</P>

<H3>Effacer des données non nécessaires</H3>


<P>Afin d'économiser de l'espace disque, on peut effacer toute la base de
données à part les types de terminaux que l'on possède (ou dont on pourrait
avoir besoin dans le futur). N'effacez aucun termcap pour un "terminal Linux"
(la console) ou les entrées xterm si vous utilisez X Window. Le type de
terminal "dumb" peut être nécessaire quand une application ne peut pas
déterminer le type de terminal que vous utilisez. Cela économiserait de
l'espace disque si les programmes d'installation n'installaient les terminfo
que pour les terminaux que vous possédez et que vous puissiez obtenir un
termcap pour un nouveau terminal sur Internet en quelques secondes.</P>

<H2><A NAME="ss15.3">15.3 Bogues dans les fichiers terminfo existants (et dans le matériel)</A>
</H2>


<P>Malheureusement, il y a un certain nombres de bogues dans les fichiers
terminfo et termcap. En plus, bien des définitions ne sont pas complètes et
ne définissent pas certaines capacités disponibles sur les terminaux. Parfois
vous pouvez vous en tirer sans modifier terminfo mais dans d'autres cas vous
devez le modifier ou peut-être utiliser une autre émulation qui possède un
bon terminfo.</P>
<P>Le mauvais état des fichiers terminfo fournis est dû à un certain nombre de
raisons. L'une d'entre elles est que durant les années 1980, quand on en a
écrit beaucoup (souvent au format termcap), les applications n'utilisaient
les capacités avancées des terminaux. Ainsi, si une telle capacité n'était
pas dans le fichier termcap (ou terminfo), personne ne se plaignait.
Aujourd'hui, les programmes tels que vim utilisent la "colorisation
contextuelle" et minicom utilise le code de caractère graphique du terminal.
Ceux-ci ont souvent besoin de plus de définitions à ajouter à l'ancien
termcap. Ceci peut (ou peut ne pas) avoir déjà été fait.</P>
<P>La plupart des terminaux avaient des bogues matériels (dans leur programme
interne) qui étaient parfois "réparés" en modifiant le termcap. Ensuite, le
fabricant pouvait envoyer des puces de remplacement qui réparaient le bogue.
Tous les propriétaires ne passaient pas leur temps à obtenir les puces de
remplacement. Ainsi il peut y avoir deux terminfos ou plus pour votre
terminal, selon les puces qu'il possède. Cette situation n'était pas toujours
notée dans le termcap et un seul termcap peut être fourni avec Linux.
Certains bogues matériels présents pour des capacités qui n'étaient quasiment
jamais utilisées dans le passé n'ont sûrement jamais été réparés. De plus,
certaines bogues matériels rapportés peuvent ne jamais avoir été réparés
puisqu'ils n'étaient pas très importants à l'époque ou que la société est
décédée, etc.</P>

<H2><A NAME="ss15.4">15.4 Modification des fichiers terminfo</A>
</H2>


<P>Pour faire ceci vous avez besoin du manuel de votre terminal indiquant les
séquences d'échappement qu'il utilise. Les manuels récents des années 1990 ne
les montrent pas souvent. Vous avez aussi besoin d'un manuel terminfo (ou
similaire). Par exemple, afin d'ajouter des capacités graphiques vous devez
assigner des valeurs aux variables terminfo : enacs, rmacs et smacs en
éditant un fichier source. Alors en utilisant "tic" vous pouvez le compiler.
"tic" devrait placer automatiquement le fichier terminfo compilé dans le
répertoire correct réservé à cet usage.</P>
<P>Si vous voulez trouver un meilleur terminfo pour un certain terminal que
celui qui est fourni, vous pouvez essayer de chercher sur Internet (mais ce
que vous y trouverez peut être pire). Si votre nouvelle entrée terminfo est
meilleure que l'ancienne et semble stable (vous l'avez utilisée pendant un
moment sans problèmes) vous devriez en envoyer une copie au mainteneur de
terminfo comme indiqué au début du fichier source de terminfo (ou termcap).</P>

<H2><A NAME="init_string"></A> <A NAME="ss15.5">15.5 Chaîne d'initialisation</A>
</H2>


<P>Dans le terminfo sont souvent incluses des chaînes d'initialisation qu'on
peut envoyer au terminal pour l'initialiser. Cela peut modifier l'apparence
de l'écran, changer le mode dans lequel se trouve le terminal et/ou faire que
le terminal émule un autre terminal. Une chaîne d'initialisation n'est pas
envoyée automatiquement au terminal pour l'initialiser. On pourrait espérer
que le programme getty le fasse mais s'il le faisait, on pourrait faire un
changement de configuration sur le terminal et ce changement ne serait pas
pris en compte parce que la chaîne d'initialisation l'annulerait
automatiquement. Vous devez utiliser une commande sur la ligne de commande
(ou dans un script shell) pour envoyer la chaîne d'initialisation telle
quelle. De telles commandes sont : "tset", "tput init" ou "setterm
-initialize". Parfois il n'y a pas besoin d'envoyer la chaîne
d'initialisation puisque le terminal peut se configurer correctement quand il
est allumé (en utilisant les options et préférences qu'on a sauvées dans la
mémoire permanente du terminal).</P>

<H2><A NAME="term_var"></A> <A NAME="ss15.6">15.6 Variable TERM</A>
</H2>


<P>La variable d'environnement TERM devrait être initialisée au nom de terminal
que vous utilisez. Si TERM n'a pas encore été positionnée et que vous ne
connaissez pas le nom de votre terminal, voyez 
<A HREF="#term_name">quel est le nom terminfo de mon terminal ?</A>. Elle est normalement positionnée par
le paramètre terminal_type passé au programme getty (regardez-le dans le
fichier /etc/inittab). Ce nom doit se trouver dans la base de données
terminfo. Tapez simplement "set" sur la ligne de commande pour voir quelle
valeur a TERM (ou tapez : tset -q). Sur la console (moniteur) TERM est
positionné à "linux" qui représente le moniteur du PC émulant un modèle de
terminal fictif appelé "linux". Puisque "linux" est proche d'un terminal
vt100 et que beaucoup de terminaux le sont aussi, l'appellation "linux"
fonctionnera parfois comme un recours temporaire sur un terminal texte.</P>
<P>Si on peut connecter plus d'un type de terminal sur le même port
(/dev/tty...) (par exemple, si un commutateur permet à différents types de
terminaux d'utiliser le même port série, ou si le port est relié à un modem
que des personnes appellent depuis différents types de terminaux) alors TERM
doit être positionné à chaque fois que quelqu'un se connecte sur le port
série. Il y a souvent une séquence d'échappement de requête pour que
l'ordinateur puisse demander au terminal de quel type il est. Une autre façon
est de demander à l'utilisateur de taper (sélectionner) le type de terminal
qu'il ou elle utilise.  Vous aurez peut-être besoin d'utiliser tset ou
d'écrire un petit script shell pour gérer cela.</P>
<P>
<A NAME="tset"></A>  Une manière est d'utiliser "tset" (voir la page de manuel).
tset essaie de déterminer le nom du terminal à partir du terminal que vous
utilisez. Il regarde ensuite les données dans terminfo et envoie une chaîne
d'initialisation à votre terminal. Il peut aussi positionner la valeur de
TERM. Par exemple, un utilisateur appelle et se logge. Le script de login
.profile est exécuté et il contient la commande suivante : eval `tset -s
?vt100`. Ceci fait que : on demande à l'utilisateur s'il ou elle utilise un
vt100. L'utilisateur répond oui ou bien tape le type de terminal réel qu'il
ou elle utilise. tset envoie ensuite la chaîne d'initialisation et positionne
TERM à ce nom (type) de terminal.</P>

<H2><A NAME="termcap_docs"></A> <A NAME="ss15.7">15.7 Documents sur terminfo/termcap</A>
</H2>


<P>
<UL>
<LI>pages de manuel de terminfo(5) (la meilleure) et/ou termcap(5).  
<A HREF="http://www.delorie.com/gnu/docs/termcap/termcap_toc.html">Le manuel Termcap</A> (2ème éd.) par Richard M. Stallman est un manuel GNU qui est
quelque peu obsolète depuis qu'il n'inclut plus terminfo.
</LI>
<LI>les fichiers : terminfo.src et /etc/termcap possèdent des informations
sur les diverses versions des fichiers termcap, les conventions de nommage
pour les terminaux et des codes de capacités spéciales nommées u6-u9. Si vous
ne les avez pas, allez à 
<A HREF="http://sagan.earthspace.net/terminfo">http://sagan.earthspace.net/terminfo</A>
</LI>
<LI>"Termcap et Terminfo" est un livre publié par O'Reilly en 1988.
</LI>
</UL>
</P>

<H2><A NAME="s16">16. Utilisation du terminal</A></H2>



<H2><A NAME="ss16.1">16.1 Introduction à l'utilisation du terminal</A>
</H2>


<P>Cette section parle du contrôle de l'interface terminal-ordinateur et/ou du
changement de configuration du terminal pendant son utilisation. Elle
explique (ou pointe vers des explications sur) la manière dont l'utilisateur
d'un terminal peut contrôler et inspecter l'interface, et comment utiliser
diverses commandes fournies par le pilote de périphérique. Elle n'explique
pas comment utiliser les nombreuses applications, shells ou la plupart des
utilitaires Linux. Deux commandes utilisées couramment sur un terminal sont :</P>
<P>
<UL>
<LI>clear (pour effacer l'écran)
</LI>
<LI>reset (pour réinitialiser le terminal)
</LI>
</UL>
</P>

<H2><A NAME="ss16.2">16.2 Démarrer le terminal</A>
</H2>


<P>Évidemment il faut allumer le terminal pour qu'il fonctionne. Si vous ne
voyez pas d'invite de login, appuyez sur la touche "Retour" (ou "Entrée")
plusieurs fois. Saisissez ensuite le nom de votre compte (suivi d'un
retour/entrée) et votre mot de passe quand on vous le demande (suivi aussi
d'un retour/entrée). Prenez garde à ne pas tout taper en lettres majuscules.
Si vous le faites, l'ordinateur peut croire que vous avez un vieux terminal
qui ne peut pas transmettre de lettres minuscules et le pilote série peut se
configurer pour n'envoyer que des lettres majuscules au terminal.</P>
<P>Si rien ne se passe, assurez-vous que l'ordinateur hôte va bien. Si
l'ordinateur hôte est éteint (pas de courant), ce que vous tapez sur le
clavier du terminal peut apparaître à l'écran puisque les broches de
transmission et de réception sur l'ordinateur peuvent être reliées ensemble,
ce qui fait que les caractères sont retournés par un ordinateur "éteint". Si
vous ne pouvez pas vous logger quand l'ordinateur fonctionne, voyez 
<A HREF="#trouble-shoot">résolution des problèmes</A>.</P>

<H2><A NAME="ss16.3">16.3 Pilote de périphérique (série) du terminal</A>
</H2>


<P>En tapant sur la ligne de commande, le shell (tel que le shell Bash) lit ce
que vous tapez et y réagit. Ce que vous tapez passe d'abord par la partie
pilote de terminal de votre système d'exploitation. Ce pilote peut traduire
certains caractères (comme changer le caractère "retour" généré par la touche
"retour" en un caractère "nouvelle ligne" pour les fichiers Linux). Il
reconnaît aussi certains codes de contrôle que vous pourriez taper au clavier
comme ^C pour interrompre l'exécution d'un programme. Il retourne normalement
ce que vous tapez à l'écran. On peut utiliser 
<A HREF="#stty_">stty</A>
pour configurer le comportement de ce terminal, ce qui comprend l'arrêt de
tout ou partie de cette fonctionnalité.</P>

<H2><A NAME="ss16.4">16.4 Problèmes avec les éditeurs</A>
</H2>


<P>Il peut y avoir quelques problèmes pendant l'utilisation d'emacs et de vi sur
certains terminaux.</P>

<H3>Emacs et ^S,^Q</H3>


<P>Si le contrôle de flux logiciel est présent, la commande ^S dans Emacs
bloquera l'affichage. La commande ^Q débloquera l'affichage. La solution 
est de relier cette commande à une autre touche dans le fichier de
configuration de Emacs.</P>

<H3><A NAME="vi_k_keys"></A> Vi et les touches curseur</H3>


<P>Vi utilise la touche ESC comme commande pour sortir du mode d'insertion. Si
on appuie sur une touche fléchée (touche de curseur) une séquence
d'échappement (démarrant par le caractère ESC) est envoyée à l'hôte. Vi doit
faire la différence entre ces deux significations d'ESC. Un vi intelligent
(comme vim) doit être capable de détecter la différence en regardant le
temps entre la touche ESC et celle qui suit. Si il s'agit d'un court délai, 
c'est comme si une touche curseur avait été pressée. Utilisez "help cursor-keys" 
dans vim pour en savoir plus.</P>
<P>Il y'a une autre façon d'arranger ça.Sur les terminaux VT on peut faire en sorte 
que la touche flèche gauche envoie soit ESC [ D soit ESC O D. Les autres touches 
fléchées sont similaires mais utilisent A, B et C au lieu de D. Si vous avez 
des problèmes, choisissez ESC [ D puisque le "O" dans l'autre alternative peut 
être interprétée comme une commande d'"ouverture de ligne". Le "[" devrait être 
interprété par vi pour dire qu'une touche fléchée a été pressée. ESC [ D sera 
envoyé à condition que le "mode application touches fléchées" (Cursor Key Application
Mode) n'ait pas été activé. ESC [ D est normalement la valeur par défaut donc
tout devrait être correct. Sauf que de nombreux termcaps contiennent une
chaîne (pas la chaîne d'initialisation) qui positionne ce que vous voulez
éviter : "Mode Application". Les éditeurs peuvent envoyer cette chaîne au
terminal quand ils démarrent. Là, vous avez des problèmes.</P>
<P>Cette chaîne possède le code termcap "ks" (smkx dans terminfo) qui veut dire
activer les touches de fonctions (et similaires, incluant les touches
fléchées). Une application active ces touches en envoyant la chaîne "ks" au
terminal. La personne qui a écrit le termcap a conclu que si une application
voulait activer ces touches, elles devraient être mises en "Mode Application"
puisque c'est une "application", mais vous ne voulez pas cela.</P>
<P>La console Linux n'a pas de chaîne "ks" pour que vous ne tombiez pas dans ce
piège sur la console. Pour d'autres terminaux vous aurez besoin d'éditer
termcap (ou terminfo) ou d'utiliser une autre entrée termcap. Vous devez
modifier non seulement la chaîne "ks" mais aussi les définitions termcap de
ce qu'elle envoie : kd, kl, kr, ku. Lancez ensuite tic pour l'installer.</P>
<P>Pour vim (VI aMélioré) il y a une manière de le configurer pour qu'il
fonctionne correctement avec ESC O D (pour que vous ne deviez pas éditer
termcap) : cherchez "vt100-cursor-keys" dans l'aide de vim. Vous pouvez
lancer "gitkeys" et ensuite appuyer sur les touches fléchées pour voir ce
qu'elles envoient mais on peut les configurer pour qu'elles envoient autre
chose quand vous êtes dans un éditeur.</P>

<H2><A NAME="ss16.5">16.5 Corruption du ls en couleur</A>
</H2>


<P>Si <CODE>ls</CODE> met en l'air l'émulation de votre terminal avec la possibilité de
couleur, arrêtez-la. <CODE>ls --color</CODE> et <CODE>ls --colour</CODE> utilisent la
possibilité de couleur. Certaines installations font que <CODE>ls</CODE> utilise la
couleur par défaut. Vérifiez dans <CODE>/etc/profile</CODE>, etc. s'il y a des
alias pour <CODE>ls</CODE>. Voyez 
<A HREF="#ls_color">exemple de fonction ls</A>
pour savoir comment faire pour que ls soit en couleur sur la console et en
noir et blanc sur les terminaux.</P>

<H2><A NAME="ss16.6">16.6 L'affichage se bloque (terminal bloqué)</A>
</H2>


<P>Les symptômes d'un terminal bloqué sont que ce que vous tapez ne s'affiche
pas sur le terminal (ou dans certains cas s'affiche mais ne fait rien). Si ce
que vous tapez est invisible (ou ne fait rien) tapez ^Q pour relancer le flux
(si le contrôle de flux l'a stoppé). Le blocage peut aussi venir de
:<BR> 
<A HREF="#sent_bin">envoi d'un binaire au terminal</A> ou 
<A HREF="#abnormal_exit">un programme s'est terminé de façon anormale</A><BR> Si vous n'avez fait ni l'un ni l'autre, votre programme
peut alors être boggé ou vous avez intéragi de manière fatale avec lui.</P>
<P>Si vous voulez quitter le programme que vous avez lancé et que vous ne pouvez
pas le faire par les méthodes normales (certains programmes ont des touches
spéciales que vous devez taper pour sortir) essayez de le tuer à partir d'un
autre terminal en utilisant "top" ou "kill". Si le processus refuse de
s'arrêter, vous pouvez essayer de lui envoyer un signal 9 à partir de top qui
devrait le forcer à s'arrêter. Le type de sortie forcée "9" peut laisser
certains fichiers temporaires qui traînent ainsi qu'une interface corrompue.
Tuer le shell de login devrait relancer getty avec une nouvelle invite de
login.</P>
<P>
<A NAME="ctrl-s"></A>  Les personnes débutantes sous Linux peuvent sans le faire
exprès appuyer sur Ctrl-S (^S) (ou la touche "Arrêt Défil") qui bloque
l'écran de manière mystérieuse (bien que ce soit ce que cette touche est
supposée faire si vous utilisez le contrôle de flux logiciel). Pour retrouver
une interaction normale avec l'écran, pressez Ctrl-Q (^Q). Notez que tout ce
qui est tapé durant le "blocage" est exécuté mais vous n'en verrez rien avant
d'appuyer sur ^Q. Ainsi quand il est bloqué, ne tapez rien de spécial qui
pourrait effacer des fichiers etc. L'un des arguments en faveur du contrôle
de flux matériel est qu'il empêche de tels blocages.</P>

<H2><A NAME="corrupt_interface"></A> <A NAME="ss16.7">16.7 Interface du terminal corrompue</A>
</H2>


<P>Cela inclut le cas de l'"affichage bloqué" = "terminal stoppé net" de la
section précédente.</P>

<H3>Symptômes</H3>


<P>Quand l'affichage ne semble pas correct, ou quand ce que vous tapez ne
s'affiche pas correctement (si même un affichage se produit), ou que rien ne
se passe quand vous tapez une commande, il y a des chances que vous soyez en
face d'une corruption de l'interface du terminal. Dans les cas rares où la
partie matérielle du port série elle-même serait corrompue, le seul remède
peut être de basculer l'interrupteur (éteindre le PC et redémarrer). Le
problème peut provenir de choses telles qu'un bogue dans le programme que
vous utilisez, une panne matérielle (ce qui inclut un défaut matériel obscur
avec lequel vous pouvez normalement vivre) ou peut-être une configuration
incorrecte. Si tout fonctionnait correctement mais que ça va soudainement
mal, il se peut que l'interface ait été corrompue par une de vos actions.
Vous pouvez avoir fait l'une de ces trois erreurs :</P>
<P>
<UL>
<LI>
<A HREF="#sent_bin">Envoyer des données binaires au terminal</A></LI>
<LI>
<A HREF="#abnormal_exit">Stopper un programme de manière anormale</A> </LI>
<LI>
<A HREF="#ctrl-s">Taper Ctrl-S par erreur</A> </LI>
</UL>
</P>

<H3><A NAME="sent_bin"></A> Envoyer des données binaires au terminal</H3>


<P>Votre terminal modifiera ses caractéristiques si on lui envoie certaines
séquences d'échappement ou des caractères de contrôle. Si vous essayez par
inadvertance d'afficher un fichier binaire, il peut contenir par hasard de
telles séquences qui peuvent placer votre terminal dans un mode de
fonctionnement étrange voire le rendre inutilisable. Visualisez ou éditez
toujours un fichier binaire avec des programmes faits à cet effet pour que
cela n'arrive pas. La plupart des éditeurs et des afficheurs manipuleront les
binaires de la bonne manière afin de ne pas corrompre l'interface. Certains
peuvent afficher un message vous avertissant qu'ils ne peuvent éditer du
binaire. Par contre, l'utilisation de "cat ...." ou "cp .... /dev/tty.." où
.... est un fichier binaire enverra le binaire au terminal et risque
fortement de générer des problèmes.</P>
<P>La corruption peut aussi arriver en utilisant un programme de communication
où un ordinateur distant peut envoyer des données binaires à l'écran. Il y a
de nombreuses autres façons pour lesquelles ces problèmes peuvent arriver,
alors soyez-y préparé. Même un fichier qu'on prend pour un fichier ASCII peut
contenir des codes de contrôle indésirables.</P>
<P>Pour résoudre ce problème, ré-initialisez le terminal. Vous pouvez essayer de
taper soit "reset" soit "setterm -reset" (bien que vous ne puissiez pas voir
ce que vous tapez). Ceci enverra la chaîne de ré-initialisation à partir de
l'entrée du terminal dans la base terminfo. Si la configuration correcte a
été sauvée à l'intérieur du terminal, alors l'appui sur certaine(s) touche(s)
(peut-être en mode de configuration) peut retrouver ce paramétrage. Vous
voudrez alors ensuite encore utiliser "reset" pour envoyer la chaîne
d'initialisation si vous l'utilisez pour configurer votre terminal.</P>

<H3><A NAME="abnormal_exit"></A> Terminer un programme de façon anormale</H3>


<P>De grandes applications (comme des éditeurs) utilisent souvent les commandes
stty (ou autres) dans leur code pour modifier de manière temporaire la
configuration stty pendant que vous utilisez ce programme. Cela peut mettre
le pilote de périphérique en mode "brut" pour que chaque caractère que vous
tapez aille directement à l'application. L'écho de retour que fait le pilote
est désactivé pour que tout ce que vous voyez à l'écran vienne directement de
l'application. Ainsi de nombreuses commandes de contrôle (comme ^C) peuvent
ne pas fonctionner dans certaines applications.</P>
<P>Quand vous quittez de telles applications, celle-ci remet d'abord en place
les paramètres stty aux valeurs qu'ils avaient avant le démarrage de
l'application. Si vous quittez le programme de manière anormale (vous pouvez
deviner que ça s'est passé ainsi quand ce que vous tapez ne s'affiche plus à
l'écran) vous risquez d'être encore en mode "brut" sur la ligne de commande.</P>
<P>Pour sortir du mode brut et revenir aux paramètres stty normaux, tapez "stty
sane". Cependant, vous devez taper ceci juste après un "retour" et le
terminer par un "retour". Mais l'appui sur la touche "retour" ne donne pas le
résultat escompté puisque le code "retour" n'est plus traduit en caractères
nouvelle ligne que le shell attend. Tapez donc simplement nouvelle ligne (^J)
à la place de "retour". L'interface de terminal "sane" peut ne pas être
exactement la même que d'habitude mais elle fonctionne en général. "stty
sane" peut aussi être utile pour sortir d'une interface corrompue par
d'autres causes.</P>

<H2><A NAME="stty_chars"></A> <A NAME="ss16.8">16.8 Caractères (de contrôle) spéciaux</A>
</H2>


<P>Un certain nombre de caractères de contrôle que vous pouvez taper au clavier
sont "attrapés" par le pilote de terminal et effectuent diverses tâches. Pour
voir ces commandes de contrôle tapez : stty -a et regardez les lignes 2 à 4.
Elles sont expliquées de manière vague dans les pages de manuel de stty. On
peut modifier les caractères ou les désactiver en utilisant la commande stty.
Ainsi vos caractères de contrôle peuvent différer de ceux décrits ci-dessous.
On les utilise pour l'édition de la ligne de commande, l'interruption, le
défilement et pour se déplacer sur le caractère suivant de manière
transparente.</P>

<H3>Édition de la ligne de commande</H3>


<P>Alors que le pilote de terminal possède quelques commandes pour l'édition de
la ligne de commande, certains shells possèdent un vrai éditeur intégré
(comme "readline" dans le shell Bash). Un tel éditeur est normalement activé
par défaut donc vous n'avez besoin de rien faire pour l'activer. S'il est
disponible vous ne devez pas apprendre les commandes suivantes bien qu'elles
fonctionnent souvent en plus de l'éditeur de lignes de commande. Les plus
importantes à apprendre sont ^C (interruption), ^D et comment arrêter le
défilement.</P>
<P>
<UL>
<LI>Delete-key (touche d'effacement, que stty montre comme ^?) efface le
dernier caractère</LI>
<LI>^U détruit (efface) la ligne</LI>
<LI>^W efface un mot en arrière</LI>
<LI>^R réaffiche la ligne. Utile principalement sur les terminaux à sortie
papier ??</LI>
</UL>
</P>

<H3>Interruption (et Quit, Suspend, EOF, Flush)</H3>


<P>
<UL>
<LI>^C interrompt. Quitte le programme et vous remet sur l'invite de la
ligne de commande.</LI>
<LI>^/ quitte. Comme l'interruption ^C mais plus faible. Fait aussi
générer un fichier "core" (dont vous n'avez probablement pas l'utilité) dans
votre répertoire de travail).</LI>
<LI>^Z suspend. Stoppe le programme et le met en tâche de fond. Tapez fg
pour le relancer.</LI>
<LI>^D fin de fichier. S'il est tapé sur l'invite de la ligne de commande,
quitte le shell et va là où vous étiez avant que le shell démarre.</LI>
<LI>^O chasser. Pas implémenté sur Linux. Envoie la sortie vers /dev/null.</LI>
</UL>
</P>

<H3>Arrêt et reprise du défilement</H3>


<P>Si ce que vous désirez voir défile hors du bas de l'écran, vous pouvez
empêcher cela en envoyant un signal d'arrêt "stop" (^S ou Xoff) à l'hôte (à
condition que le 
<A HREF="#flow_control">contrôle de flux</A> Xon-Xoff
soit activé). Envoyez un signal de départ "start" (^Q ou Xon) pour reprendre.
Certains terminaux possèdent une touche "Pas de défilement" qui enverra de
manière alternée Xoff et Xon ou peut-être enverra des signaux de contrôle de
flux matériel ?? Voici ce que font ctrl-S (^S) et ctrl-Q (^Q) :</P>
<P>
<UL>
<LI> ^S arrête le défilement (Xoff)</LI>
<LI> ^Q reprend le défilement (Xon)</LI>
</UL>
</P>
<P>Si vous voulez à la fois arrêter le défilement et quitter, utilisez ^C. Si
vous voulez arrêter le défilement pour faire autre chose mais voulez garder
le programme qui générait la sortie en mémoire pour que vous puissiez
reprendre le défilement plus tard, utilisez ^Z pour suspendre.</P>
<P>Une méthode de défilement différente est d'envoyer la sortie dans un tube
vers un afficheur comme more, less ou most. Cependant, la sortie peut ne pas
être la sortie standard mais peut être la sortie d'erreur que l'afficheur ne
reconnaît pas. Pour résoudre ceci vous pouvez utiliser une redirection "2>&amp;1"
pour que l'afficheur fonctionne correctement. Il est souvent plus simple
d'utiliser simplement ^S et ^Q sauf si vous devez défiler en arrière.</P>
<P>Sur une console PC (qui émule un terminal), vous pouvez défiler en arrière en
utilisant Shift-PageHaut. Cela est fréquemment nécessaire puisque le
défilement est souvent trop rapide à arrêter en utilisant ^S. Une fois que
vous avez défilé en arrière Shift-PageBas défilera en avant à nouveau.</P>

<H3>Prendre littéralement en compte le caractère suivant</H3>


<P>^V envoie le caractère tapé suivant (en général un caractère de contrôle)
directement au pilote de périphérique sans action ou interprétation. En
retour deux caractères ASCII comme ^C sont affichés.</P>

<H2><A NAME="ss16.9">16.9 Visualiser des fichiers Latin-1 sur un terminal 7 bits</A>
</H2>


<P>Certains fichiers texte sont au format Latin1 sur 8 bits (voyez 
<A HREF="#char_sets">ensembles de caractères</A>). Si vous avez un terminal qui
n'affiche pas les caractères Latin1 (ou sur lequel on n'a pas sélectionné
l'ensemble de caractères Latin1), un symbole de boulet s'affichera comme un
7, etc. En visualisant des pages de manuel (elles sont en Latin1) vous pouvez
passer l'option -7 à man afin de traduire les 7, etc. à quelque chose proche
d'un boulet (en ASCII). Y a-t-il des afficheurs qui font ces traductions ??</P>

<H2><A NAME="ss16.10">16.10 Inspection de l'interface</A>
</H2>


<P>Ces utilitaires vous fourniront des informations sur l'interface du terminal
:</P>
<P>
<UL>
<LI>gitkeys : montre quel(s) octet(s) chaque touche envoie à l'hôte.</LI>
<LI>tty : montre à quel port tty vous êtes connecté.</LI>
<LI>set : montre la valeur de TERM (le nom de l'entrée terminfo)</LI>
<LI>stty -a : montre tous les paramètres stty.</LI>
<LI>setserial -g /dev/tty?? (remplissez les ??) montre le type d'UART,
l'adresse du port et le numéro d'IRQ.</LI>
<LI>infocmp : montre l'entrée de terminfo en cours (moins de commentaires)</LI>
</UL>
</P>

<H2><A NAME="term_settings"></A> <A NAME="ss16.11">16.11 Modifier les paramètres du terminal</A>
</H2>


<P>Les paramètres du terminal sont normalement positionnés une fois quand le
terminal est installé en utilisant les procédures de configuration du manuel
du terminal. Cependant, certains paramètres peuvent être modifiés alors que
le terminal est en cours d'utilisation. Vous ne donnez normalement aucune
commande "stty" ou "setserial" quand le terminal est en cours d'utilisation
car elles causeront certainement des problèmes à l'interface du terminal.
Cependant, vous pouvez faire certaines modifications à l'apparence de l'écran
du terminal ou à son comportement sans détruire l'intégrité de l'interface.
Parfois ces modifications sont faites automatiquement par les applications et
donc vous ne devriez pas avoir besoin de vous en occuper.</P>
<P>Une méthode directe pour effectuer de telles modifications est d'utiliser la
touche de configuration (ou autre) sur le terminal et ensuite d'utiliser les
menus pour faire les modifications. Pour cela, vous aurez besoin de bien
connaître le terminal. Les trois autres méthodes envoient une séquence
d'échappement de l'ordinateur vers le terminal pour faire les modifications.
Ces trois exemples montrent des méthodes différentes pour faire cela en
positionnant la vidéo inverse :</P>
<P>
<OL>
<LI>setterm -reverse</LI>
<LI>tput -rev</LI>
<LI>echo ^[[7m</LI>
</OL>
</P>

<H3><A NAME="setterm_"></A> setterm</H3>


<P>C'est la commande la plus facile à utiliser. Elle utilise des options longues
(mais n'utilise pas les -- normaux devant). Elle consulte la base de données
terminfo pour déterminer le code à envoyer. Vous pouvez modifier la couleur,
la luminosité, la coupure de ligne, la vitesse de répétition du clavier,
l'apparence du curseur etc.</P>

<H3><A NAME="tput"></A> tput</H3>


<P>La commande "tput" est similaire à "setterm" mais au lieu d'utiliser des mots
ordinaires comme arguments, vous devez utiliser les abréviations utilisées
par terminfo. Beaucoup d'abréviations sont relativement laconiques et
difficiles à retenir.</P>

<H3>echo</H3>


<P>Dans l'exemple "echo ^[[7m" pour positionner la vidéo inverse,
^[ est le caractère d'échappement. Pour le taper, tapez ^V^[ (ou ^V
suivi de la touche ESC). Pour utiliser cette méthode "echo" vous devez
trouver quel code utiliser à partir d'un manuel de terminal ou à partir de
terminfo ou termcap. Il est plus facile d'utiliser setterm ou tput si vous
tapez sur la ligne de commande. Puisque "echo ..." s'exécutera plus vite
(puisqu'il ne fait de requête), il est bon pour être utilisé dans les scripts
shell lancés au démarrage, etc.</P>

<H3>Sauver les modifications</H3>


<P>Quand vous éteignez le terminal les modifications que vous avez faites seront
perdues (sauf si vous les avez sauvées dans la mémoire permanente du terminal
en allant dans le mode configuration et en les sauvant). Si vous voulez les
utiliser à nouveau sans devoir les retaper, mettez les commandes dans un
script shell ou créez une fonction shell. Lancez-la ensuite quand vous voulez
faire les modifications. Une manière de rendre les modifications
semi-permanentes est de mettre ces commandes dans un fichier lancé à chaque
fois que vous vous loggez ou que vous démarrez l'ordinateur.</P>

<H2><A NAME="term_as_console"></A> <A NAME="ss16.12">16.12 Faire d'un terminal une console</A>
</H2>


<P>C'est aussi ce que l'on appelle une "console série". Beaucoup de messages en
provenance du système ne sont normalement envoyés que sur la console (Le moniteur). 
On peut aussi voir sur un terminal certains messages envoyés sur la console durant le
démarrage après un démarrage réussi en tapant la commande : dmesg. Si le
démarrage ne réussit pas, ceci ne sera d'aucun utilité. Il est possible de
modifier le noyau Linux pour qu'un terminal serve de console et reçoive tous
les messages de Linux destinés à la console. Malheureusement, les messages du
BIOS (qui s'affiche sur le moniteur quand un PC est démarré) seront perdus puisqu'ils 
ne seront pas affichés sur le terminal.</P>
<P>Creer une "console série" veut dire que la console (dans la forme d'un terminal)
se trouve maintenant sur un port série. Bien sûr, elle n'aura pas les couleurs, 
les fontes, les capacités graphiques, ni les possibilités de redéfinition 
du clavier de la vraie console du PC.</P>
<P>Avant le noyau 2.2, vous deviez patcher le noyau à la main. À partir du noyau
2.2, le support est inclus dans le noyau à condition que ce dernier ait été
configuré pour cela. Ces deux cas sont traités dans les deux sous-sections
suivantes :</P>

<H3>Pour les noyaux 2.2 et supérieurs</H3>


<P>Les instructions pour faire une console série sont incluses dans la
documentation livrée avec le code source dans le fichier :
serial-console.txt. Normalement, le périphérique /dev/console est un lien
vers tty0 (la console PC). Pour une console série vous créez un nouveau
/dev/console qui est un vrai périphérique (et non pas un lien vers autre
chose).  Vous devez aussi inclure une déclaration à propos de la console
série dans /etc/lilo.conf et ensuite lancer lilo. C'est parce que
l'équivalent de "setserial" doit être lancé pour configurer votre console
série avant le chargement du noyau. Voyez la documentation ci-mentionnée pour
plus de détails.</P>

<H3>Pour les noyaux antérieurs à 2.2</H3>


<P>Le Linux Journal d'avril 1997 avait un article sur la façon d'appliquer une
rustine au noyau. Vous ajoutez quelques #define au début de
src/linux/drivers/char/console.c :</P>
<P>
<PRE>
&lt;item> #define CONFIG_SERIAL_ECHO
&lt;item> #define SERIAL_ECHO_PORT 0x2f8  /* Serial port address  */

Ce qui suit n'était pas dans l'article de Linux Journal. Dans les noyaux 2.+
(et précédents&nbsp;??) vous avez aussi besoin de positionner la vitesse
d'émission (sauf si 9600 est convenable). Cherchez ces deux lignes&nbsp;:

serial_echo_outb(0x00, UART_DLM); /* 9600 baud */
serial_echo_outb(0x0c, UART_DLL);

Changez 0x0c dans la ligne ci-dessus en (selon la vitesse que vous
désirez)&nbsp;:

115200 baud: 0x01      19200 baud: 0x06        2400 baud: 0x30
 57600 baud: 0x02       9600 baud: 0x0c        1200 baud: 0x60
 38400 baud: 0x03       4800 baud: 0x18
</PRE>
</P>
<P>Si vous utilisez la console pour sélectionner quel système d'exploitation
démarrer (avec LILO), mais que vous voudriez le faire à partir d'un terminal,
vous devez ajouter une ligne au fichier /etc/lilo.conf. Voyez la page de
manuel de lilo.conf et cherchez la chaîne "serial=".</P>

<H3>Puis-je lancer Linux sans moniteur (console PC) ?</H3>


<P>Oui, en utilisant un terminal et en le faisant passer pour une console comme
indiqué ci-dessus. Vous aurez sans doute quand même besoin d'une carte
graphique puisque la plupart des BIOS en ont besoin pour démarrer le PC.
Votre BIOS peut aussi avoir besoin d'un clavier pour démarrer, ou bien il
peut avoir une option grâce à laquelle vous pouvez indiquer au BIOS qu'il n'a
pas besoin de clavier.</P>

<H2><A NAME="ss16.13">16.13 Sessions multiples</A>
</H2>


<P>Le paquet "<CODE>screen</CODE>" lance des sessions multiples un peu comme les
terminaux virtuels sur la console&nbsp;: voyez 
<A HREF="#console_dev">la console : /dev/tty?</A>. Cependant, ce n'est pas comme les "pages" (
<A HREF="#pages_">section sur les pages</A>) puisque l'image des pages est
stockée sur l'ordinateur hôte et non à l'intérieur du terminal comme elles le
sont avec les "pages".</P>

<H2><A NAME="ss16.14">16.14 Se délogger</A>
</H2>


<P>Pour vous délogger, tapez soit "logout", soit "exit". Dans certains cas votre
demande sera refusée, mais on devrait vous dire pourquoi. L'une des raisons
du refus est que vous n'êtes pas sur le même shell que celui avec lequel vous
vous êtes loggé. Une autre manière de vous délogger est d'appuyer sur ^D.
Puisqu'on utilise aussi ^D à d'autres fins, vous ne voudrez pas forcément que
cette touche vous délogge. Si vous positionnez la variable IGNOREEOF dans le
shell Bash, alors ^D ne vous déloggera plus.</P>

<H2><A NAME="ss16.15">16.15 Discuter entre terminaux, espionner</A>
</H2>


<P>Si deux personnes loggées par l'intermédiaire de terminaux sur le même
ordinateur hôte désirent discuter ensemble, ils peuvent utiliser les
programmes "write" ou "talk". Sur Internet, on peut discuter en utilisant le
navigateur "lynx".</P>
<P>Pour espionner ce qu'une autre personne fait sur son terminal, utilisez le
programme "ttysnoop". Dans "ttysnoop", les deux terminaux ont le même état et
tout ce qui est tapé sur l'un des deux claviers apparaît sur les deux écrans
(au même endroit). Donc si vous espionnez et ne voulez pas être détecté, vous
ne devriez rien taper. On peut utiliser ttysnoop pour s'entraîner avec un
professeur et un étudiant assis côte à côte, chacun sur son terminal. Le
professeur peut regarder ce que tape l'étudiant et peut corriger les erreurs
en tapant correctement. L'étudiant peut regarder ce que tape le professeur et
ensuite le répéter lui-même. C'est comme s'ils utilisaient un seul terminal,
les deux personnes ayant leurs mains sur le clavier en même temps.</P>

<H2><A NAME="trouble-shoot"></A> <A NAME="s17">17. Résoudre les problèmes (logiciels)</A></H2>


<P>Si vous suspectez que le problème soit matériel, voyez la section 
<A HREF="#repair_">réparation et diagnostic</A>. Si le problème concerne le
port série lui-même, voyez le Serial-HOWTO.</P>
<P>Voici une liste des problèmes possibles :</P>
<P>
<UL>
<LI>
<A HREF="#term_OK">Le terminal fonctionne-t-il ?</A> Soupçonnez que
le terminal est en panne.</LI>
<LI>
<A HREF="#flow_ctrl_ng">Texte manquant</A> Soit passe au-dessus
d'une partie du texte soit affiche correctement du texte puis se bloque</LI>
<LI>
<A HREF="#fast_respawn">Getty se relance trop rapidement</A>
(message d'erreur sur la console)</LI>
<LI>
<A HREF="#after_login">Ne fonctionne pas juste après le login</A></LI>
<LI>
<A HREF="#cant_login">Ne peut pas se logger</A> mais l'invite de
login est OK.</LI>
<LI>
<A HREF="#garbled">Invite de login embrouillée</A></LI>
<LI>
<A HREF="#blank_">Aucun signe d'une invite de login</A></LI>
</UL>
</P>
<P>Il y a deux cas dans lesquels le terminal se comporte mal. L'un arrive quand
il a fonctionné correctement et s'est mis à mal fonctionner tout à coup.
C'est ce dont on parle dans la sous-section suivante. L'autre cas arrive
quand les choses vont mal juste après l'installation du terminal. Dans ce
cas, vous pouvez passer à la section suivante.</P>

<H2><A NAME="term_was_ok"></A> <A NAME="ss17.1">17.1 Le terminal fonctionnait correctement</A>
</H2>


<P>Quand un terminal qui fonctionnait correctement ne tourne tout d'un coup pas
bien, il est souvent facile de déceler le problème. Si vous réfléchissez à ce
qui s'est passé récemment cela vous donnera certainement un indice quant à la
cause du problème.</P>
<P>Le problème peut être évident comme un message d'erreur au démarrage du
terminal. S'il émet un bruit, il a sûrement besoin d'une réparation. Voyez
<A HREF="#repair_">réparation et diagnostics</A>. D'abord, réflechissez à
ce que vous avez fait ou modifié récemment car c'est sûrement la cause du
problème. Est-ce que le problème est apparu juste après l'installation d'un
nouveau logiciel ou après une modification de configuration ?</P>
<P>Si le terminal ne répond pas correctement (s'il répond tout court) à ce que
vous tapez, vous avez peut-être une 
<A HREF="#corrupt_interface">interface de terminal corrompue</A>.</P>

<H2><A NAME="trouble-shoot_new"></A> <A NAME="ss17.2">17.2 Terminal nouvellement installé</A>
</H2>


<P>Si vous venez de relier un terminal à votre ordinateur en suivant les
instructions et qu'il ne fonctionne pas, cette section vous concerne. Si un
terminal qui fonctionnait correctement auparavant ne fonctionne plus, voyez
<A HREF="#term_was_ok">le terminal fonctionnait</A>. Si vous présumez que
le port série de votre ordinateur est défectueux, vous pouvez essayer de
lancer un programme de test et de diagnostics sur ce port. À présent (juin
1998) il semble que Linux ne dispose pas encore d'un tel programme de
diagnostics et vous devrez donc lancer les diagnostics sous MS DOS/Windows.
Il y a quelques programmes pour surveiller les diverses lignes série comme
DTR, CTS, etc. et qui peuvent vous aider. Voyez 
<A HREF="#serial_mon">surveillance/diagnostic série</A>.</P>
<P>Une manière est d'abord de voir si le terminal fonctionne en essayant de
copier un fichier vers le terminal (cp mon_fichier /dev/ttyS?) dans la
situation la plus simple. Ceci implique la désactivation des lignes de
contrôle du modem et à une vitesse qui ne nécessite pas de contrôle de flux
(assurez-vous que le contrôle de flux matériel est désactivé). Si cette copie
fonctionne, compliquez alors un petit peu la situation et voyez si ça
fonctionne encore, etc., etc. Quand le problème apparaît juste après avoir
fait une modification, alors ce changement est sûrement la cause du problème.
En fait, il est plus efficace (mais plus compliqué) de sauter de la situation
simple à à peu près la moitié de la configuration finale pour que le test
élimine à peu près la moitié des causes possibles restantes pour le problème.
Répétez alors cette méthode pour le test suivant. De cette manière il ne
faudrait que dix tests environ pour trouver la cause sur un millier de causes
possibles. Vous devriez vous écarter un peu de cette méthode en vous basant
sur des intuitions et des indices.</P>

<H2><A NAME="term_OK"></A> <A NAME="ss17.3">17.3 Est-ce que le terminal va bien ?</A>
</H2>


<P>Un bon terminal démarre en général en affichant quelques mots à l'écran. Si
ces mots ne donnent aucun message d'erreur, le terminal va probablement bien.
S'il n'y aucun signe de courant (aucune lumière n'est allumée, etc.),
réenfoncez le câble d'alimentation des deux côtés. Assurez-vous qu'il y ait
du courant sur la prise murale (ou au bout du cordon d'alimentation). Essayez
un autre cordon si vous en avez un. Assurez-vous que le terminal est allumé
et que son fusible n'a pas sauté. Un écran blanc (ou sombre) peut parfois
être réparé simplement en tournant les molettes de luminosité et de contraste
ou par une touche de clavier dans le mode de configuration.  Si cela ne
fonctionne toujours pas, voyez 
<A HREF="#repair_">réparations et diagnostics</A> pour avoir des astuces sur la réparation du terminal.</P>
<P>Si le terminal démarre correctement, mais que vous soupçonnez qu'il y ait un
problème, mettez-vous en "mode local" où il fonctionnera comme une machine à
écrire et essayez de taper. Voyez 
<A HREF="#local_mode">mode local</A>.</P>

<H2><A NAME="flow_ctrl_ng"></A> <A NAME="ss17.4">17.4 Texte manquant</A>
</H2>


<P>Si le texte s'affiche normalement sur le terminal puis s'arrête sans avoir
terminé (au milieu d'un mot, etc.) ou si des morceaux de texte manquent, vous
avez sûrement un problème avec le contrôle de flux. Si vous ne pouvez pas
trouver tout de suite ce qui le cause, baissez la vitesse. Si cela l'arrange,
c'est sûrement un problème de contrôle de flux. Il se peut que le contrôle de
flux ne fonctionne pas du tout à cause d'un manque de configuration correcte
ou à cause d'un câblage incorrect (pour le contrôle de flux matériel). Voyez
<A HREF="#flow_control">contrôle de flux</A>.</P>
<P>Si des caractèrs isolés manquent, le port série est peut-être dépassé par une
vitesse trop élevée. Essayez une vitesse plus petite.</P>
<P>Si vous utilisez une vitesse de transmission en dessous de 1200 (très lente,
principalement utilisée par les anciens terminaux à copie papier et les
imprimantes) et que le texte est tronqué, alors le problème peut provenir du
pilote de périphériques série. Voyez le Printing-HOWTO à la section
"périphériques série" sur la manière de régler ceci.</P>

<H2><A NAME="fast_respawn"></A> <A NAME="ss17.5">17.5 Getty se relance trop rapidement</A>
</H2>



<H3>Module série non chargé</H3>


<P>Utilisez la commande "lsmod" pour voir si le module série est chargé.</P>

<H3>Pas de tension de contrôle du modem</H3>


<P>Si getty ne peut pas ouvrir et/ou utiliser un port à cause du manque de
tension de contrôle de modem positive sur l'une des broches, alors getty peut
se terminer. Alors, grâce aux instructions dans inittab, getty se relance et
essaie encore, uniquement pour être terminé à nouveau, etc. etc. Vous pouvez
voir un message d'erreur indiquant que, à cause de getty qui se relance trop
rapidement, il a été temporairement désactivé. Essayez d'utiliser l'option
"local" dans getty et/ou de vérifier les paramètres et les tensions de
contrôle du modem.</P>

<H3><A NAME="key_shorted"></A> Touche enfoncée</H3>


<P>Une autre cause possible du relancement de getty est qu'une touche du clavier
soit enfoncée, ce qui donne le même résultat que si la touche était maintenue
appuyée en continu. Avec la répétition automatique activée, ceci "tape" des
milliers de caractères à l'invite de login. Cherchez un écran rempli de
caractères identiques (dans certains cas avec deux caractères différents ou
plus).</P>

<H2><A NAME="after_login"></A> <A NAME="ss17.6">17.6 Échec après le login</A>
</H2>


<P>Si vous pouvez vous logger correctement mais ne pouvez utiliser le terminal
il se peut que le démarrage du shell de login ait reconfiguré le terminal
(avec des paramètres incorrects) à cause d'une commande que quelqu'un a mise
dans l'un des fichiers qui sont lancés quand vous vous loggez, et qu'un shell
soit lancé. Ces fichiers comprennent /etc/profile et &nbsp;/.bashrc. Cherchez une
commande commençant par "stty" ou "setserial" et assurez-vous qu'elle est
correcte. Même si elle est correcte dans un fichier d'initialisation, elle
peut être repositionnée de manière incorrecte dans un autre fichier
d'initialisation que vous ne soupçonnez pas. Des méthodes pour revenir sur le
système afin de le réparer et d'utiliser un autre terminal ou console est
d'utiliser une disquette de secours ou de taper : "linux single" à l'invite
de LILO qui vous mettra en mode utilisateur unique sans lancer les fichiers
de démarrage.</P>

<H2><A NAME="cant_login"></A> <A NAME="ss17.7">17.7 Impossible de se logger</A>
</H2>


<P>Si vous obtenez une invite de login mais pas de réponse (ou peut-être une
réponse embrouillée) à vos tentatives de login, une cause possible est que la
communication se fait mal dans un sens du terminal vers l'ordinateur. Cela
peut être dû à un connecteur/câble mauvais ou mal câblé. Si vous
n'utilisez pas encore l'option "local" de getty, faites-le afin de désactiver
les lignes de contrôle du modem. Voyez 
<A HREF="#getty_">getty (dans /etc/inittab)</A>. Vous pourriez aussi désactiver le contrôle de flux matériel
(stty -crtscts) s'il était activé. Si cela fonctionne maintenant
correctement, alors soit les lignes de contrôle de votre modem sont câblées
de manière incorrecte, soit il y a une erreur dans votre configuration.
Certains terminaux permettent le positionnement de valeurs différentes (comme
la vitesse de transmission) pour envoyer et recevoir, de sorte que la
réception soit bonne mais pas l'envoi.</P>
<P>Vous devriez aussi (sur la console) essayer "stty &lt; /dev/ttyS1" (si vous
utilisez ttyS1) pour vérifier qu'il est configuré correctement. Il sera
souvent en mode brut (et c'est sûrement bon) avec -icanon et -echo, etc. Si
le terminal est configuré de manière incorrecte en half-duplex (HDX), alors
une partie des caractères que vous voyez quand vous tapez viennent du
terminal lui-même. Si les caractères sont doublés, alors les échos de
l'ordinateur sont bons et vous pouvez passer en full-duplex pour corriger
ceci. Mais si vous êtes en half-duplex et que vous ne voyez que ce qui semble
être des "échos" normaux, ils ne viennent donc pas de l'ordinateur comme ils
devraient le faire.</P>
<P>Si vous obtenez un message qui ressemble à "login failed" (le login a échoué)
alors, si vous n'avez fait aucune erreur en tapant ou dans votre mot de
passe, il peut y avoir des restrictions sur les logins qui ne vous permettent
pas de vous logger. Malheureusement, ce message peut ne pas vous dire
pourquoi la tentative a échoué. Voyez 
<A HREF="#login_restr">restrictions sur les logins</A>.</P>

<H2><A NAME="garbled"></A> <A NAME="ss17.8">17.8 Invite de login embrouillée</A>
</H2>


<P>Ceci peut-être à cause de l'utilisation d'un jeu de caractères incorrect, des
erreurs de transmission dues à des vitesses de connexion trop élevées, des
vitesses de connexion incompatibles, des parités incompatibles ou un nombre
de bits par octet incorrect. Si c'est une variété de caractères étranges vous
avez un jeu de caractères incorrect ou un bit de haut rang est positionné par
erreur. Si les mots ont des fautes d'orthographe, essayez une vitesse de
transmission plus basse. Pour les incompatibilités de vitesse de
transmission, de parité ou de bits/caractère, vous voyez beaucoup d'erreurs
"character error" identiques (erreur de caractère) qui représentent le fait
qu'un vrai caractère ne peut être affiché correctement à cause d'une erreur
dans la parité ou la vitesse de transmission.</P>
<P>Si vous utilisez agetty (souvent nommé simplement getty), le programme agetty
détectera et positionnera la parité et/ou les bits/caractère si vous tapez
quelque chose. Essayez-le avec un retour chariot pour voir si cela répare
quelque chose.</P>

<H2><A NAME="blank_"></A> <A NAME="ss17.9">17.9 Aucun signe d'une quelconque invite de login</A>
</H2>


<P>Cela arrive quand rien ne se passe du tout sur le terminal, mais que le
terminal semble fonctionner correctement. L'une des premières choses à faire
est de s'assurer que toutes les connexions câblées sont fermes et reliées au
bon connecteur à la fois sur l'ordinateur et sur le terminal. D'autres causes
comprennent du matériel ou des câbles défectueux (les câbles doivent être des
null-modem), getty ne tournant pas, une différence de vitesse de
transmission, un terminal en mode local, etc. À ce point, deux possibilités
d'approche sont (vous pouvez en suivre plus d'une à la fois) :</P>
<P>
<UL>
<LI>
<A HREF="#consoleD">diagnostiquer les problèmes à partir de la console</A></LI>
<LI>
<A HREF="#measure_volts">mesurer les tensions</A></LI>
</UL>
</P>

<H3><A NAME="consoleD"></A> Diagnostiquer les problèmes à partir de la console</H3>


<P>Sur la console (ou sur un autre terminal qui fonctionne), utilisez "top" ou
"ps -al" pour voir si getty fonctionne sur le port. Ne le confondez pas avec
d'autres programmes getty qui tournent sur d'autres ports ou sur les consoles
virtuelles. Vous n'obtiendrez pas d'invite de login si getty ne tourne pas.</P>
<P>Un test possible est de tenter la copie d'un court fichier vers le terminal
(une bonne idée serait d'essayer cela au début du processus d'installation
avant de configurer getty). Utilisez la commande Linux de copie comme ceci :
cp nom_fichier /dev/ttyS1. Si cela ne fonctionne pas, utilisez stty pour
rendre l'interface aussi simple que possible en désactivant tout (comme le
contrôle de flux matériel : -crtscts ; la parité, et les signaux de contrôle
du modem : clocal). Assurez-vous que les vitesses de transmission et le
nombre de bits par octet sont les mêmes. Si rien ne se passe, vérifiez que le
port est vivant avec un voltmètre grâce à la section suivante.</P>

<H3><A NAME="measure_volts"></A> Mesure des tensions</H3>


<P>Si vous disposez d'un voltmètre à portée de main, vérifiez qu'il y a une
tension négative (-4v à -15v) sur la broche 3 (réception de données) du côté
du terminal sur le câble null modem. La borne positive du voltmètre devrait
être reliée à une bonne terre (les connecteurs métalliques sur les extrémités
des câbles ne sont souvent pas reliés à la terre). S'il n'y a pas de tension
négative, vérifiez-la sur la broche de transmission (TxD) sur l'ordinateur
(voyez 
<A HREF="#DB_pin-out">DB9-DB25</A> pour le brochage). Si elle est
présente là mais pas sur la broche de réception (RxD) du terminal, alors le
câble est mauvais (connexion flottante, câble cassé ou le câble n'est pas
null modem).  S'il n'y a pas de tension du côté de l'ordinateur, le port
série de l'ordinateur est mort. Testez-le avec un programme de diagnostics ou
remplacez-le.</P>
<P>Si le port série est vivant, vous pouvez lui envoyer un fichier (avec les
contrôles de modem désactivés) et voyez si quelque chose y arrive. Pour
vérifier qu'un signal est transmis avec un voltmètre analogique, regardez
l'aiguille à -12 V quand la ligne est inactive. Commencez ensuite à envoyer
un fichier (ou lancez getty). Vous devriez voir l'aiguille revenir à zéro et
bouger autour de 0 alors qu'elle mesure des moyennes de courte distance sur
le flux de données. Vous pouvez aussi le voir sur l'échelle de courant
alternatif à condition que votre voltmètre dispose d'une capacité pour
bloquer les tensions continues quand vous êtes sur l'échelle alternative.
S'il n'en a pas, alors le -12 V continu en inactif donnera une lecture
alternative erronée. Sans voltmètre, vous pourriez relier un périphérique que
vous savez en bon état (comme un autre terminal ou un modem externe) au port
série et voir s'il fonctionne correctement.</P>

<H2><A NAME="ss17.10">17.10 Ralentissement: Pauses de quelques secondes entre l'affichage des caractères</A>
</H2>

<P>Vous avez surement mal parametrer les interruptions: Voyez les sections du Serial-HOWTO
commençant par "Ralentissement:".</P>

<H2><A NAME="serial_mon"></A> <A NAME="ss17.11">17.11 Surveillance et diagnostics du port série</A>
 </H2>


<P>Quelques programmes Linux surveilleront les lignes de contrôle du modem et
indiqueront si elles sont positives (1) ou négatives (0).</P>
<P>
<UL>
<LI>statserial (dans la distribution Debian)</LI>
<LI>serialmon (ne surveille pas RTS, CTS, DSR mais indique les autres
fonctions)</LI>
<LI>modemstat (ne fonctionne que sur les consoles PC Linux. Fonctionnera en
concordance avec la ligne de commande)</LI>
</UL>
</P>
<P>Vous les avez peut-être déjà. Sinon, allez à 
<A HREF="http://metalab.unc.edu/pub/Linux/system/serial/">logiciels série</A>. En
les utilisant, gardez à l'esprit que ce que vous voyez est l'état des lignes
sur l'ordinateur hôte. La situation sur le terminal sera différente puisque
certains fils sont souvent manquants des câbles alors que d'autres fils se
croisent. En juin 1998, je ne connais aucun programme de diagnostic sous
Linux pour le port série.</P>

<H2><A NAME="local_mode"></A> <A NAME="ss17.12">17.12 Mode local</A>
</H2>


<P>En mode local, le terminal se déconnecte de l'ordinateur et se comporte comme
une machine à écrire (sauf qu'il n'imprime pas sur papier mais sur l'écran).
En revenant en ligne, le terminal se reconnecte à l'ordinateur vous
permettant de reprendre les activités au point où vous vous étiez arrêté
quand vous êtes passé en mode "local". Ceci est utile à la fois pour tester
le terminal et à des fins éducatives. En mode local vous pouvez taper des
séquences d'échappement (en commençant par la touche ESC) et observer ce
qu'elles font. Si le terminal ne fonctionne pas correctement en mode local,
il est quasiment certain qu'il ne fonctionnera pas mieux quand il sera relié
à l'ordinateur. Si vous n'êtes pas vraiment sûr de ce que fait une séquence
d'échappement, vous pouvez l'essayer en mode local. Vous pouvez aussi
l'utiliser pour essayer un terminal qui est à vendre. Pour aller en mode
local vous devez d'abord entrer en mode de configuration et ensuite
sélectionner "local" dans un menu (ou presser une certaine touche). Voyez
<A HREF="#enter_setup">aller dans le mode de configuration</A>.</P>

<H2><A NAME="ss17.13">17.13 Équipement de test électrique pour le port série</A>
</H2>



<H3>Gadgets d'évasion etc.</H3>


<P>Alors qu'un multimètre (utilisé comme voltmètre) peut être tout ce dont vous
avez besoin pour quelques terminaux, un équipement de test spécial simple a
été fait pour tester les lignes des ports série. Certains s'appellent
"évasion ..." (breakout, NdT) où évasion veut dire sortir des conducteurs
d'un câble. Ces gadgets possèdent quelques connecteurs et s'insèrent dans le
câble série. Certains possèdent des points de tests pour y relier un
voltmètre. Certains possèdent des LEDs qui s'allument quand certaines lignes
de contrôle sont activées (allumées). D'autres encore possèdent des cavaliers
pour que vous puissiez relier n'importe quel fil à n'importe quel fil.
Certains possèdent des interrupteurs.</P>
<P>Radio Shack vend (en 1998), un "expert de RS-232" ou "testeur de ligne
RS-232" qui vérifie TD, RD, CD, RTS, CTS, DTR, et DSR. Une lumière verte veut
dire "allumé" (+12 V) alors que rouge veut dire "éteint" (-12 V). Ils vendent
aussi une "boîte de cavaliers série RS-232" qui permet de relier les broches
de la manière dont vous le souhaitez.</P>

<H3>Mesurer des tensions</H3>


<P>N'importe quel voltmètre ou multimètre, même les moins chers qu'on vend pour
environ 60 F, devraient fonctionner correctement. Essayer d'utiliser d'autres
méthodes pour tester la tension est compliqué. N'utilisez pas de diode
électroluminescente (LED) sauf si on lui adjoint une résistance en série pour
réduire la tension sur la diode. On utilise une résistance de 470 ohms pour
une diode de 20 mA (mais toutes les diodes ne font pas 20 mA). La diode ne
s'allumera que pour une certaine polarité pour que vous puissiez tester les
tensions positives ou négatives. Personne ne fait un tel gadget pour tester
automatiquement les circuits ?? Les sondes logiques peuvent être endommagées
si vous essayez de les utiliser puisque les tensions TTL pour lesquelles
elles sont faites ne sont que de 5 volts. Tenter d'utiliser une ampoule
incandescente de 12 V n'est pas une bonne idée. Cela ne vous montrera pas la
polarité et à cause du courant de sortie limité de l'UART, l'ampoule ne
s'allumera probablement pas.</P>
<P>Pour mesurer la tension sur un connecteur femelle, vous pouvez enfoncer un
trombone déplié dans l'ouverture désirée. Le diamètre du trombone ne doit pas
être plus grand que les broches afin de ne pas abîmer le contact. Mettez une
pince croco (ou autre) sur le trombone pour vous connecter.</P>

<H3>Goûter la tension</H3>


<P>En dernier recours, si vous n'avez pas d'équipement de test et voulez risquer
d'être choqué (ou même électrocuté) vous pouvez toujours goûter à la tension.
Avant de toucher à l'une des broches de test avec votre langue, testez-les
pour vous assurez qu'il n'y a pas de haute tension sur elles. Prenez les deux
broches (à la fois) dans une main pour voir si ça vous fait de l'effet.  Si
ce test vous choque, vous n'aurez sûrement pas envie d'utiliser votre langue.</P>
<P>Pour tester du 12 V, léchez un doigt et tenez-y une broche de test. Mettez
l'autre broche de test sur votre langue. Si la broche sur votre langue est
positive, il y aura un goût reconnaissable. Vous pouvez d'abord essayer ceci
avec des piles 4,5 V pour savoir quel goût ça aura.</P>

<H2><A NAME="repair_"></A> <A NAME="s18">18. Réparations et diagnostics</A></H2>


<P>La réparation d'un terminal possède beaucoup en commun avec la réparation
d'un moniteur et/ou d'un clavier. Parfois les diagnostics intégrés au
terminal vous indiqueront à l'écran ce qui ne va pas. Sinon, par les
symptômes, on peut souvent isoler le problème à l'une des choses suivantes :
clavier défectueux, écran mort, panne de l'électronique numérique du
terminal. Il est mieux d'avoir un manuel de service, mais même si vous n'en
avez pas, beaucoup de terminaux peuvent encore être réparés.</P>

<H2><A NAME="repair_info"></A> <A NAME="ss18.1">18.1 Livres et sites Web sur la réparation</A>
</H2>



<H3>Livres</H3>


<P>Bigelow, Stephen J. : Troubleshooting &amp; Repairing Computer Monitors, 2ème
édition, McGraw-Hill, 1997. Ne couvre pas l'électronique de génération des
caractères ni le clavier.</P>

<H3>Sites Web</H3>


<P>La FAQ 
<A HREF="http://www.repairfaq.org">http://www.repairfaq.org</A> du groupe de nouvelles
sci.electronics.repair est longue et complète, bien qu'elle ne couvre pas les
terminaux en soi. Voyez la section "Moniteurs d'ordinateurs et vidéos"
("Computer and Video Monitors", NdT). La plupart de ces informations peuvent
s'appliquer aux terminaux ainsi que dans les sections "tester les capacités",
"tester les transformateurs", etc. Peut-être que dans le futur, les
"informations" de réparation de ce HOWTO consisteront principalement en des
liens vers la FAQ ci-dessus (ou un document identique).  Une autre source
d'informations est l'
<A HREF="http://www.cs.utk.edu/~shuford/terminal/repair_hints_news.txt">archive de réparations de Shuford</A>, archive de posts dans des groupes
de nouvelles sur la réparation des terminaux.</P>

<H2><A NAME="ss18.2">18.2 Sécurité</A>
</H2>


<P>Les écrans utilisent de très hautes tensions jusqu'à 30000 volts pour la
couleur (un peu moins pour le noir et blanc). Faites attention de ne pas
toucher cette tension si l'écran est allumé et le couvercle retiré. Cela ne
vous tuera probablement pas même si vous le faites puisque la somme de
courant qu'il peut fournir est limité. Mais il est possible que cela vous
brûle gravement et vous choque, etc. Les hautes tensions peuvent passer à
travers des couches d'air et traverser certains isolants, alors gardez vos
mains à une distance sûre. Vous devriez remarquer le câble à haute tension
bien isolé connecté à un bout du tube d'images. Même quand l'écran est
éteint, il reste suffisamment de tension résiduelle sur la connexion du câble
au tube d'images pour vous donner un certain choc. Pour décharger cette
tension quand l'écran est débranché, utiliser un tournevis (poignée isolée)
avec la lame en métal relié au câble de masse du tube d'images par un fil
cavalier. N'utilisez pas la masse du chassis.</P>
<P>Les tensions plus basses (quelques centaines de volts) peut être encore plus
dangereuses parce qu'elles ne sont pas limitées en courant. Elles sont même
encore plus dangereuses si vos mains sont mouillées ou si vous portez un
bracelet de montre en métal, un anneau ou autre. Dans certains cas rares, des
gens en sont morts alors faites attention. Les tensions plus faibles de
seulement quelques volts sur les circuits numériques sont relativement sûrs
mais ne touchez à rien (sauf avec un outil bien isolé) sauf si vous savez ce
que vous faites.</P>

<H2><A NAME="ss18.3">18.3 Apparence de l'affichage</A>
</H2>


<P>Si l'affichage est trop faible, augmentez la luminosité et/ou le contraste en
utilisant les molettes à l'extérieur de l'unité (si elles existent). Si la
largeur, la hauteur ou le centrage sont incorrects, il y a souvent des
molettes de contrôle pour ceux-ci. Sur certains terminaux anciens, on doit
presser une touche fléchée (ou autre) en mode de configuration.</P>
<P>Vous aurez peut-être besoin d'enlever le couvercle pour faire des
ajustements, surtout sur les modèles anciens. Vous pourriez arranger les
choses pour qu'un grand miroir soit en face du terminal afin de voir
l'affichage dans le miroir tout en faisant les ajustements. Ce qu'il faut
tourner peut se trouver sur un circuit imprimé. Alors qu'un tournevis
(peut-être avec une tête Phillips) peut être tout ce dont vous avez besoin,
les bobines peuvent nécessiter certains outils spéciaux d'alignement de
télévisions (clés en plastique, etc.). Le nom abrégé de l'ajustement devrait
être imprimé sur le circuit imprimé. Par exemple, voici de tels noms :</P>
<P>
<UL>
<LI>V-Size ajuste la hauteur verticale (taille)</LI>
<LI>H-Size ajuste largeur horizontale (taille). Ce peut-être une bobine.</LI>
<LI>V-Pos ajuste la position verticale</LI>
<LI>H-Pos ajuste la position horizontale</LI>
<LI>V-Lin ajuste la linéarité verticale (à utiliser si la largeur des
lignes de balayage diffère en haut et en bas de l'écran)</LI>
<LI>V-Hold ajuste le maintien vertical (à utiliser si l'écran défile de
manière incontrôlable)</LI>
<LI>Bright ajuste la luminosité (une molette extérieure peut aussi exister)</LI>
<LI>Sub-Bright ajuste la luminosité du mode d'intensité atténuée (souvent
le mode normal : plus faible que le mode gras ou fort).</LI>
</UL>
</P>
<P>Changer la linéarité peut modifier la taille et donc il peut être nécessaire
de la réajuster. Un terminal qui a été stocké pendant quelque temps peut
avoir un petit rectangle d'affichage sur l'écran entouré d'un grand bord
noir. S'il est difficile à ajuster, attendez un peu avant de l'ajuster
puisqu'il va en récupérer un peu avec l'utilisation (les bords noirs vont
rétrécir).</P>

<H2><A NAME="ss18.4">18.4 Diagnostiquer</A>
</H2>



<H3>Le terminal a émis un bruit</H3>


<P>Si le terminal a émis un bruit juste avant de tomber en panne (ou quand vous
l'allumez juste après qu'il est tombé en panne), ce bruit est un indice de ce
qui ne va pas. Si vous entendez un crépitement ou voyez/sentez de la fumée,
éteignez immédiatement le terminal pour empêcher des dommages
supplémentaires. Le problème est sûrement dans l'alimentation en haute
tension de plusieurs milliers de volts. Enlevez le couvercle et si le point
faible n'est pas évident, rallumez-le pendant une courte période de temps
dans une pièce peu éclairée et regardez les arcs électriques. Le câble à
haute tension (qui court entre le transformateur et le côté du tube d'images)
peut avoir une isolation défectueuse qui provoque des arcs avec la terre.
Réparez-le avec de l'isolant haute tension, ou du chatterton électrique
spécial fait pour, disons, 10000 volts.</P>
<P>Le transformateur (haute tension) peut ne faire qu'un cliquetis ou un
crépitement faible quand il tombe en panne. Vous pouvez ne pas l'entendre
jusqu'à ce que vous éteigniez le terminal pendant un moment pour le reposer
et l'allumiez ensuite à nouveau. Pour déterminer la provenance du bruit, vous
pouvez utiliser un morceau de tube en caoutchouc (comme on en utilise dans
les voitures) comme stéthoscope pour écouter. Mais pendant que vous écoutez
le son, le terminal souffre de plus de dommages alors essayez de le trouver
rapidement (mais pas rapide au point de risquer d'être électrocuté).</P>
<P>Un court-circuit dans l'alimentation peut faire sauter un fusible avec un
bruit "pop". Le remplacement d'un fusible éclaté peut ne pas résoudre le
problème car le même court-circuit peut faire éclater le fusible à nouveau.
Recherchez les points noircis à cause d'une chaleur trop importante et testez
ces composants. Les transistors de puissance court-circuités peuvent faire
éclater le fusible. On peut les tester avec un vérificateur de transistors ou
même avec un ohmmètre. Utilisez une petite échelle d'ohms sur un ohmmètre
pour que la tension appliquée par l'ohmmètre soit faible. Ceci réduira les
dommages possibles sur les composants sains causés par ce test de tension.</P>
<P>Si le terminal a été exposé à l'humidité, en étant stocké dans un endroit
humide ou près d'une cuisine avec la vapeur de la cuisine, une solution peut
être de sécher l'unité. Chauffer un transformateur "en panne" avec un
sèche-cheveux pendant quelques minutes peut le ranimer.</P>

<H3>Le terminal n'a émis aucun bruit</H3>


<P>Un écran vide peut être causé par une personne qui a tourné le contrôle de
luminosité au plus bas niveau ou par l'âge. La chose à faire alors est de
vérifier les câbles pour voir si les connexions sont mal faites ou cassées.
S'il n'y a pas de signe de courant, mettez un nouveau cordon d'alimentation
après vous être assuré que la prise de courant murale délivre du courant.</P>
<P>Si vous soupçonnez le clavier, essayez-le sur un autre terminal du même type
ou mettez un bon clavier. Manipulez les extrémités du câble du clavier et la
prise. Les fils à l'intérieur du câble peuvent casser, surtout vers leurs
extrémités. Si la cassure est vérifiée en bougeant le câble (et en alternant
la panne et la bonne marche du terminal en même temps que le mouvement), il
faut alors soit obtenir un nouveau câble, soit couper le câble et ressouder
les cassures, etc.</P>
<P>L'une des premières choses à faire si le clavier fonctionne est de mettre le
terminal en 
<A HREF="#local_mode">mode local</A>. Si cela fonctionne en
local, alors le problème vient sûrement de la connexion à l'ordinateur hôte
(ou d'une interface incorrecte) ou dans les puces UART du terminal.</P>
<P>En inspectant avec attention les circuits, on peut souvent trouver la cause
du problème. Regardez les changements de couleurs, les craquelures, etc. Un
problème intermittent peut se révéler en appuyant sur les composantes avec un
stylo à bille (pas la partie métallique, bien sûr). Une cassure de la partie
conductrice d'un circuit imprimé peut parfois être révélée en tordant le
circuit. De la soudure qui semble avoir fait une goutte ou un joint avec un
peu de soudure peut avoir besoin d'être refaite. La soudure peut faire
chauffer les transistors (et d'autres composants) et les endommager, utilisez
donc un puits de chaleur si c'est faisable.</P>
<P>Si vous avez une marque de terminal connue, vous pouvez chercher des posts
sur les groupes de nouvelles sur l'Internet pour trouver les types de
problèmes les plus fréquents pour votre terminal et peut-être des
informations sur la manière de les réparer.</P>
<P>Pour voir si l'électronique numérique fonctionne, essayez (en utilisant un
bon clavier) de taper sur le mauvais terminal. Essayez de lire cela en tapant
sur un bon terminal (ou sur la console) en utilisant la commande de copie ou
avec un programme de communication avec les terminaux comme Minicom. Vous
aurez peut-être besoin d'appuyer sur la touche retour chariot afin d'envoyer
une ligne. On peut demander l'identité, etc. du mauvais terminal à partir
d'un autre terminal. Cela montrera si la communication dans les deux sens
fonctionne.</P>

<H2><A NAME="ss18.5">18.5 Messages d'erreur à l'écran</A>
</H2>


<P>Vous avez de la chance si vous voyez un message d'erreur à l'écran. Cela
arrive en général quand vous allumez pour la première fois le terminal.</P>

<H3>Erreur de clavier</H3>


<P>Ceci veut dire en général que le clavier n'est pas branché, ou que la
connexion est branlante. Pour des problèmes plus sérieux, voyez 
<A HREF="#keyboards_">claviers</A>.</P>

<H3>Erreur de somme de contrôle en NVR</H3>


<P>La NVR est la mémoire non volatile (Non-Volatile RAM, NdT). Ceci veut dire
que la NVR, où sont stockées les informations de configuration, est
corrompue. Le terminal fonctionnera sûrement encore mais la configuration qui
avait été sauvegardée la dernière fois que quelqu'un a configuré le terminal
a sûrement été perdue. Essayez de refaire la configuration et de la sauver.
Cela a des chances de fonctionner. Sur certains terminaux très vieux (début
des années 1980) il y avait un CMOS alimenté sur pile pour sauver la
configuration donc dans ce cas le problème peut venir d'une pile morte.
Parfois la puce EEPROM (pas besoin de pile) devient mauvaise après trop de
sauvegardes. On aura du mal à en trouver. Si vous ne pouvez pas la réparer
vous êtes soit bloqué avec la configuration par défaut ou vous pouvez envoyer
des séquences d'échappement au terminal quand vous le démarrez ou quand vous
essayez de le configurer.</P>

<H2><A NAME="ss18.6">18.6 Capacités</A>
</H2>


<P>Les capacités électrolytiques possèdent une coquille de métal et peuvent
faiblir ou tomber en panne s'ils restent inutilisés pendant des années.
Parfois le fait de laisser le terminal allumé pendant un certain temps peut
aider à les restaurer en partie. Si vous le pouvez, faites faire de
l'exercice aux terminaux que vous avez en stock en les allumant pendant
quelques instants chaque année ou tous les deux ans.</P>

<H2><A NAME="keyboards_"></A> <A NAME="ss18.7">18.7 Claviers</A>
</H2>



<H3>Interchangeabilité</H3>


<P>Les claviers pour terminaux ne sont pas les mêmes que les claviers pour PC.
La différence ne réside pas seulement dans la disposition des touches mais
aussi dans les codes générés quand on presse une touche. De plus, les
claviers pour diverses marques et modèles de terminaux ne sont pas toujours
interchangeables. On obtient parfois un clavier "incompatible" qui fonctionne
en partie sur un terminal. Toutes les touches ASCII fonctionneront
correctement, mais les touches spéciales pour la configuration et la pause ne
fonctionneront pas correctement.</P>

<H3>Comment ils fonctionnent</H3>


<P>La plupart des claviers font simplement un contact entre deux conducteurs
quand vous appuyez sur une touche. L'électronique à l'intérieur d'une puce
dans le clavier convertit l'établissement de ce contact en un code envoyé à
travers le câble externe du clavier. Au lieu d'avoir un fil (ou conducteur)
séparé allant de chaque touche à la puce, le principe suivant est utilisé.
Numérotez les conducteurs disons de 1 à 10 et de A à J. Par exemple : le
conducteur 3 conduit à plusieurs touches et le conducteur B conduit à
plusieurs touches, mais seule une touche a les deux conducteurs qui la
rejoignent. Quand cette touche est pressée, un court-circuit est établi entre
3 et B. La puce ressent ce court-circuit et sait quelle touche a été pressée.
Un tel principe réduit le nombre de conducteurs nécessaire (et réduit le
nombre de broches nécessaires sur la puce). C'est un principe similaire à ce
qu'on appelle un commutateur croisé (crossbar).</P>

<H3><A NAME="2chars"></A> L'appui sur une touche affiche deux caractères différents</H3>


<P>Si, à cause d'un défaut, les conducteurs 3 et 4 sont court-circuités alors
l'appui sur la touche 3-B court-circuitera aussi 4 et B et la puce croira que
les touches 3-B et 4-B ont été pressées à la fois. Ceci fera sûrement
afficher deux caractères différents alors que tout ce que vous souhaitiez
était un caractère.</P>

<H3>Claviers modernes contre anciens</H3>


<P>Alors que le clavier moderne et le type ancien se ressemblent beaucoup, la
mécanique d'opération est différente. Les vieux possèdent des contacts de
touches individuels sous le capuchon de chaque touche, chaque contact étant
inclus dans une enveloppe en plastique dur. Les claviers modernes utilisent
de grandes feuilles (membranes) en plastique souple de la taille du clavier.
Une feuille de plastique avec des trous est prise en sandwich entre deux
autres feuilles de plastique contenant des circuits imprimés (comprenant des
points de contact). Quand vous appuyez sur une touche, les deux feuilles
"imprimées" sont pressées l'une contre l'autre à un certain point, ce qui
ferme les contacts imprimés sur les feuilles à ce point.</P>

<H3>Le clavier ne fonctionne pas du tout</H3>


<P>Si aucune touche ne fonctionne, essayez un autre clavier (si vous en avez un)
pour vérifier que le clavier est effectivement le problème. La cause la plus
probable est un fil cassé à l'intérieur du cordon (câble) le reliant au
terminal. La position la plus probable de la cassure est à l'une des
extrémités du cordon. Essayez de manipuler les extrémités du cordon tout en
tapant sur une touche pour voir si ça fonctionne de manière intermittente.
Si vous trouvez un point endommagé, vous pouvez couper attentivement le
cordon avec un couteau à l'endroit du point endommagé et épisser le
conducteur cassé. Parfois une simple goutte de soudure fera l'affaire.
Scellez le cordon avec du chatterton ou de la colle.</P>

<H3>L'appui sur b affiche bb, etc. (affichage en double)</H3>


<P>Si tous les caractères apparaissent en double il n'y a sûrement pas de
problèmes avec le clavier. En revanche, votre terminal a sûrement été
configuré de manière incorrecte en semi-duplex (HDX ou echo local = oui) et
chaque caractère que vous tapez est renvoyé à la fois depuis l'électronique à
l'intérieur de votre terminal et depuis votre ordinateur hôte. Si les deux
caractères ne sont pas les mêmes, il peut y avoir un court-circuit à
l'intérieur de votre clavier. Voyez  
<A HREF="#2chars">un appui affiche deux caractères différents</A>.</P>

<H3>Le clavier tape tout seul</H3>


<P>Si une touche est court-circuitée il est probable qu'elle tapera un grand
nombre de fois le même caractère si la répétition automatique est activée. Si
plus d'une touche est court-circuitée, alors la répétition de séquences de
quelques caractères sera tapée. Cela peut amener getty à se relancer trop
rapidement si cela arrive à l'invite de login. Voyez 
<A HREF="#key_shorted">touche court-circuitée</A>. La solution est de nettoyer les contacts
grâce à 
<A HREF="#clean_keys">nettoyage des contacts du clavier</A>.</P>

<H3>Liquide versé sur le clavier</H3>


<P>Si de l'eau ou du liquide aqueux a été versé sur le clavier (ou s'il a été
exposé à la pluie, une rosée forte ou à l'humidité), certaines touches ne
fonctionneront pas correctement. L'humidité peut faire un court-circuit sur
une touche (comme si on appuyait dessus tout le temps) et vous pourrez voir
l'écran se remplir avec cette lettre si la répétition automatique est
activée. S'il est devenu humide et ensuite séché en partie (ou en totalité),
certaines touches pourront ne pas fonctionner à cause de dépôts sur la
surface des contacts. Sur les types de claviers modernes, on peut facilement
séparer les feuilles de plastique à l'intérieur et les sécher/nettoyer. Pour
les plus anciens, on peut les laisser sécher au soleil ou au four (basse
température). Quand c'est sec il faudra peut-être nettoyer les contacts comme
expliqué ci-dessous.</P>

<H3><A NAME="clean_keys"></A> Nettoyage des contacts du clavier</H3>



<H3>Claviers avec membrane</H3>


<P>Sur certains claviers récents, les feuilles de plastique (membranes) sont
faciles à enlever pour les inspecter et les nettoyer si nécessaire. Vous
n'avez besoin d'enlever que quelques vis pour séparer le clavier en deux et
obtenir les feuilles. Sur certains vieux clavier IBM les feuilles ne peuvent
pas être enlevées sans casser beaucoup de taquets en plastique qu'il faudra
réparer à la colle afin de les remettre (probablement pas la peine de les
réparer). Un tel clavier peut parfois fonctionner en tordant, tournant et/ou
pesant sur l'assemblage contenant les feuilles de plastique.</P>

<H3>Claviers avec contacts individuels</H3>


<P>Ce qui suit concerne les vieux claviers qui possèdent des contacts séparés en
plastique dur pour chaque touche. Avant de faire tout le travail de nettoyage
des contacts électriques essayez d'abord de tourner le clavier tête en bas et
bougez les mauvaises touches. Ceci peut aider à déloger les saletés, surtout
si vous pressez la touche fortement et rapidement pour faire une vibration.
(NdT : bien secouer le clavier régulièrement fait effectivement tomber toutes
les saletés, miettes de pain, etc. et fait du bien au clavier !) Il est
souvent utile d'enfoncer la touche et de l'agiter de bord à bord.</P>
<P>Souvent on peut enlever les capuchons de touches en les découvrant vers le
haut en utilisant un petit tournevis comme levier tout en empêchant une
inclinaison excessive avec un doigt. Il existe un outil spécial appelé
extracteur de touches mais vous pouvez vous en passer. (Attention : les
capuchons de touches sur les claviers modernes ne se découvrent pas.) Le
capuchon de touche peut basculer un peu et branler alors qu'il se détache. Il
peut même s'envoler et atterrir par terre. Vous avez alors deux choix sur le
nettoyage des contacts : utiliser un vaporisateur de nettoyant de contact
directement au-dessus du contact de la touche, ou séparer le contact de
touche et le nettoyer. Un tout autre choix est de remplacer le contact de
touche par un nouveau ou un d'occasion.</P>
<P>La vaporisation directe d'un nettoyant de contacts ou autre (obtenu dans un
magasin d'électronique) au-dessus du contact de la touche est la méthode la
plus rapide mais peut ne pas fonctionner et peut aussi endommager le
plastique. Avant de vaporiser, nettoyez la surface près des supports de
contacts. Avec le clavier branché (ou en connectant un ohmmètre sur les
contacts de touches) utilisez le tube livré avec le vaporisateur pour
injecter du nettoyant à l'intérieur du contact de touche. Ne laissez pas le
liquide de nettoyage s'en aller dans les touches voisines où il pourrait
amasser de la poussière et s'infiltrer (avec la poussière) dans les contacts
de touches adjacents. Si vous faites cette erreur, vous pourriez réparer une
touche et abimer les touches voisines. Si cela arrive, faites immédiatement
bouger les touches adjacentes affectées jusqu'à ce qu'elles fonctionnent
correctement.</P>
<P>Vous pouvez basculez le clavier pour que le nettoyant coule à l'intérieur
des contacts. Pour le terminal CIT101e avec un clavier Alps, ceci implique de
basculer la rangée des chiffres vers le plafond. Faites bouger le contact de
touche vers le haut et vers le bas avec un stylo ou le manche d'un petit
tournevis pour éviter d'avoir du liquide nettoyant toxique sur votre peau (ou
portez des gants).  Finalement retournez le clavier tête en bas tout en
bougeant la touche pour enlever le nettoyant qui reste. Plus vous injecterez
de nettoyant plus vous serez sûr de réparer la touche mais vous aurez aussi
plus de chances d'endommager le plastique ou de contaminer les touches
adjacentes, utilisez donc ce que vous jugez nécessaire pour faire le travail.
Une fois que la touche fonctionne correctement, bougez-la de haut en bas
encore un peu et testez-la une demi-minute plus tard, etc.  pour vous assurer
qu'elle fonctionne encore correctement.</P>
<P>Parfois une touche fonctionne très bien quand les contacts à l'intérieur sont
saturés de liquide de nettoyant de contacts, mais quand le liquide sèche
quelques minutes plus tard, le dépôt résultant sur les contacts empêche un
contact correct et la touche fonctionne avec des ratés (si elle fonctionne).
Faire bouger la touche alors que le liquide sèche à l'intérieur peut aider
les choses. Certaines touches possèdent des contacts presque scellés à
l'intérieur et donc peu de nettoyant pour contact atteint les contacts. Le
nettoyant qui arrive effectivement sur les contacts peut apporter la
contamination (le nettoyage autour du haut des touches avant la vaporisation
peut aider à minimiser cet effet).</P>
<P>Si vous devez désassembler le contact de touche, inspectez-le d'abord pour
voir comment il est installé et se sépare. Parfois on peut enlever le
capuchon du contact sans enlever le contact du clavier. Pour ce faire,
découvrez (ou tirez) le haut du contact de touche après avoir retiré les
taquets en plastique fin qui le retiennent. Ne tirez pas trop fort ou vous
pourriez casser le plastique fin. Si vous ne pouvez faire cela, vous devrez
peut-être dessouder le contact et l'enlever afin de le séparer (ou de le
remplacer). Une fois que le contact a été séparé, vous pourrez ne pas encore
voir les contacts si les surfaces des contacts sont prises en sandwich (qui
se touchent presque). Vous pouvez mettre du nettoyant pour contact sur les
contacts en soulevant légèrement les surfaces conductrices et en injectant du
nettoyant entre elles. Il peut y avoir une sorte d'attache maintenant les
surfaces de contact ensemble qui doit être enlevée avant de soulever ces
surfaces. Avec du nettoyant sur les contacts, faites-les bouger. Faire
basculer le clavier ou le retourner peut aider. Prenez garde de ne pas perdre
de petites parties car elles peuvent s'envoler en l'air quand vous enlevez un
contact de touche.</P>

<H2><A NAME="s19">19. Annexe A : généralités</A></H2>



<H2><A NAME="ss19.1">19.1 Liste des commandes Linux pour les terminaux</A>
</H2>



<H3>Envoyer une commande à un terminal</H3>


<P>
<UL>
<LI>
<A HREF="#setterm_">setterm</A> : options longues</LI>
<LI>
<A HREF="#tput">tput</A> : options courtes</LI>
<LI>tset : ne fait que l'initialisation</LI>
<LI>clear : efface l'écran</LI>
<LI>reset : envoie une chaîne de réinitialisation</LI>
</UL>
</P>

<H3>Configuration du pilote de périphériques pour les terminaux</H3>


<P>
<UL>
<LI>
<A HREF="#set_serial">Setserial</A> :</LI>
<LI>
<A HREF="#stty_">Stty</A></LI>
</UL>
</P>

<H3>Terminfo</H3>


<P>
<UL>
<LI>
<A HREF="#tic">Compilateur Terminfo (tic)</A> : compilateur et
traducteur pour terminfo
</LI>
<LI>toe : montre la liste des terminaux pour lesquels vous avez des
fichiers terminfo
</LI>
<LI>
<A HREF="#infocmp">infocmp</A> : compare ou affiche des entrées
terminfo
</LI>
</UL>
</P>

<H3>Autres</H3>


<P>
<UL>
<LI>gitkeys : montre quels octets chaque touche envoie à l'hôte.</LI>
<LI>tty : montre sur quel port tty vous êtes connecté.</LI>
<LI>set (ou tset -q) : montre la valeur de TERM, le nom de l'entrée
terminfo</LI>
<LI>
<A HREF="#tset">tset</A> : positionne TERM de manière interactive et
fait l'initialisation</LI>
</UL>
</P>

<H2><A NAME="ss19.2">19.2 Internet et les livres</A>
</H2>



<H3><A NAME="internet"></A> Information sur le terminal sur l'Internet</H3>


<P>
<UL>
<LI>
<A HREF="http://www.cs.utk.edu/~shuford/terminal_index.html">Site Web de Shuford</A> à l'université du Tennessee possède beaucoup
d'informations utiles sur les terminaux texte ;</LI>
<LI>
<A HREF="http://www.boundless.com/textterm/">Boundless</A> a
racheté la partie terminaux VT et Dorio chez DEC. Pour obtenir des
spécifications, choisissez les liens ADDS, VT ou DORIO. Choisissez ensuite un
lien "data sheet". Ensuite, sur la feuille de données, sélectionnez le lien
"Go to Specs".</LI>
<LI>
<A HREF="http://www.wyse.com/service/support/kbase/wyseterm.asp">Wyse</A> est un grand fabricant de terminaux. Pour les nouveaux modèles,
voyez 
<A HREF="http://www.wyse.com/terminal/">terminaux Wyse</A>. Voyez
aussi 
<A HREF="http://www.wyse.com/service/faq/wysetter.htm">vieilles spécifications des terminaux Wyse</A></LI>
<LI>
<A HREF="http://www.pericom-usa.com/twdocs/doc/twproae.htm">Séquences d'échappement ; Amérique du Nord</A> ou 
<A HREF="http://www.pericom.co.uk/teemworld/doc/twproae.htm">séquences d'échappement ; Europe</A> est une liste de séquences d'échappement (et codes
de contrôles) pour certaines émulations de terminal (qui comprend les VT 100,
300, 420 et Wyse) ;</LI>
<LI>comp.terminals est le groupe de nouvelles pour les terminaux.</LI>
</UL>
</P>

<H3>Livres liés aux terminaux</H3>


<P>
<UL>
<LI>port série EIA-232, voir 
<A HREF="#RS232_books">Livres sur EIA-232 (RS-232)</A>.</LI>
<LI>réparations, voir 
<A HREF="#repair_info">livres et sites Web sur la réparation</A>.</LI>
<LI>base de données Terminfo, voir 
<A HREF="#termcap_docs">documents Termcap</A></LI>
</UL>
</P>

<H3>Livres consacrés entièrement aux terminaux</H3>


<P>Autant que je sache, il n'existe pas de livre satisfaisant sur les terminaux
texte (sauf si vous vous intéressez aux terminaux antiques des années 70).</P>
<P>
<UL>
<LI>Handbook of Interactive Computer Terminals par Duane E. Sharp ; Reston
Publishing Co. 1977. (quasiment obsolète)</LI>
<LI>Communicating with Display Terminals par Roger K. deBry ; McGraw-Hill
1985.  (principalement sur les terminaux synchrones IBM)</LI>
</UL>
</P>
<P>Le "HANDBOOK..." présente les spécifications brèves de plus de cent modèles
différents de vieux terminaux fabriqués au début des années 1970 par plus de
60 sociétés différentes. Il explique aussi comment ils fonctionnent
physiquement mais montre de manière incorrecte un diagramme pour un écran qui
utilise une déviation électrostatique du faisceau d'électrons (même dans les
années 1970). Ce livre explique un certain nombre de concepts techniques
avancés comme le "balayage au hasard" et le "principe de pénétration de la
couleur".</P>
<P>Le livre "COMMUNICATING..." au contraire du "Handbook..." ignore les détails
physiques et électroniques des terminaux. Il possède un chapitre entier sur
l'explication des nombres binaires (qui n'est pas nécessaire dans un livre
sur les terminaux puisque cette information est largement disponible par
ailleurs). Il semble couvrir principalement les vieux terminaux IBM (surtout
les 3270) dans les modes de fonctionnement en bloc et synchrone. Il est de
peu d'utilité pour les terminaux ANSI utilisés couramment de nos jours sur
les systèmes de type Unix. Bien qu'il en parle un peu, il ne montre les
différents systèmes de câblage utilisés pour les relier aux ports série.</P>

<H3>Livres possédant des chapitres sur les terminaux</H3>


<P>Ces chapitres ne couvrent presque rien sur les terminaux eux-mêmes et leurs
capacités. Par contre, ces chapitres couvrent plutôt la manière de configurer
l'ordinateur (et le pilote de terminal) pour qu'il fonctionne avec les
terminaux. À cause des différences entre les systèmes Unix, la plupart des
informations ne s'appliquent pas à Linux.</P>
<P>
<UL>
<LI>Unix Power Tools by Jerry Peck et. al.  O'Reilly 1998.  Ch. 5 :
configuration de votre terminal, Ch. 41 : paramètres du terminal et de la
ligne série, Ch. 42 : problèmes avec les terminaux</LI>
<LI>Advanced Programming in the Unix Environment par W. Richard Stevens
Addison-Wesley, 1993. Ch. 11 : entrées/sorties avec le terminal, Ch. 19 :
pseudo-terminaux</LI>
<LI>Essential System Administration par Aleen Frisch, 2ème édition.
O'Reilly, 1998. Ch. 11 : terminaux et modems.</LI>
</UL>
</P>
<P>Le livre "UNIX POWER TOOLS" possède trois chapitres courts sur les terminaux
texte. Il couvre moins de choses que ce HOWTO mais donne plus d'exemples pour
vous aider.</P>
<P>Le livre "ADVANCED PROGRAMMING...", dans le chapitre 11, ne couvre que le
pilote de périphériques du système d'exploitation pour s'occuper des
terminaux. Il explique les paramètres qu'on donne à la commande stty pour
configurer le terminal.</P>
<P>Le chapitre du livre "ESSENTIAL SYSTEM..." en dit plus sur les terminaux que
sur les modems. Il semble bien écrit.</P>

<H2><A NAME="ss19.3">19.3 Systèmes non Linux</A>
</H2>


<P>La configuration de l'ordinateur hôte pour les terminaux sur des systèmes
d'exploitation différents de Linux est en général largement différente que
sous Linux. Voici quelques liens vers des manuels en ligne pour les systèmes
de type Unix :</P>
<P>
<UL>
<LI>
<A HREF="http://www2.sco.com:1996/HANDBOOK/serial_terminal_adding.html">Ajouter des terminaux série</A> pour SCO OpenServer dans le manuel de SCO OpenServer.</LI>
<LI>
<A HREF="http://www.software.hp.com/OS_transition/DOCS/PERIPH/TERMS3.HTM">Configuration des terminaux et modems</A> pour HP-UX de Hewlett-Packard.</LI>
</UL>
 </P>

<H2><A NAME="esc"></A> <A NAME="s20">20. Annexe B : terminologie des commandes de séquences d'échappement</A></H2>


<P>On les appelle parfois "séquences de contrôle". Cette section du
Text-Terminal HOWTO est incomplète (et pourra ne jamais être complète car il
y a un grand nombre de séquences de contrôle). Cette section sert de
référence et appartient peut-être vraiment à ce qu'on pourrait appeler
"Text-Terminal-Programming-HOWTO" (HOWTO sur la programmation d'un terminal
texte).</P>
<P>Un exemple de séquence d'échappement ANSI normale est ESC[5B qui déplace le
curseur vers le bas de cinq lignes. ESC est le caractère d'échappement. Le
paramètre 5 est inclus dans la séquence. Si c'était 7 le curseur bougerait
vers le bas de sept lignes, etc. Il est facile de comprendre l'explication
suivante pour la séquence : "déplacer le curseur vers le bas de x lignes :
ESC[xB". Mais un jargon de commande tel que : "requête d'attribut pour
périphérique tertiaire" est moins compréhensible. Cette section essaiera
d'expliquer une partie du jargon utilisé dans les commandes de séquences
d'échappement. Une liste complète (comprenant les codes de séquences
d'échappement pour la norme ANSI) est un projet "qu'on voudrait bien faire".
Puisque beaucoup de séquences d'échappement font la même chose que ce qui est
fait en configurant le terminal avec 
<A HREF="#set_up_pars">options de configuration</A>, de telles options en séquences d'échappement ne seront pas
répétées ici.</P>

<H2><A NAME="esc_seq_list"></A> <A NAME="ss20.1">20.1 Liste de séquences d'échappement</A>
</H2>


<P>Pour avoir une liste de nombreuses séquences d'échappement (mais pas toutes)
pour divers terminaux, voyez 
<A HREF="http://www.pericom-usa.com/twdocs/doc/twproae.htm">séquences d'échappement ; Amérique du Nord</A> ou 
<A HREF="http://www.pericom.co.uk/teemworld/doc/twproae.htm">séquences d'échappement ; Europe</A>. On utilise celles-ci pour émuler un terminal et
elles ne sont pas toujours les mêmes que sur le vrai terminal correspondant.
Une liste pour les VT (non maintenue) se trouve à 
<A HREF="http:/www.cs.ruu.nl/wais/html/na-dir/emulators-faq/part3.html">FAQ Émulateurs</A>. Cherchez "VT".</P>

<H2><A NAME="ss20.2">20.2 Codes de contrôle 8 bits</A>
</H2>


<P>Table des codes de contrôle 8 bits DEC (en hexadécimal). Fonctionne sur les
VT2xx ou plus récents. CSI est le code le plus courant.</P>
<P>
<PRE>
ACRONYME        NOM_COMPLET                     HEXA    REMPLACE
IND     Index (une ligne vers le bas)           84      ESC D
NEL     Ligne Suivante                          85      ESC E
RI      Index Inverse (une ligne vers le haut)  8D      ESC M
SS2     Décalage Simple 2                       8E      ESC N
SS3     Décalage Simple 3                       8F      ESC O
DCS     Chaîne de Contrôle Périphérique         90      ESC P
CSI     Introduction Séquence de Contrôle       9B      ESC [
ST      Terminaison de Chaîne                   9C      ESC \
</PRE>
</P>


<H2><A NAME="printer_esc"></A> <A NAME="ss20.3">20.3 Échappement pour l'imprimante</A>
</H2>


<P>
<UL>
<LI>Auto Print on/off (impression automatique oui/non) : Activée (on), les
données venant de l'hôte sont aussi envoyées sur le port imprimante du
terminal (et sont aussi affichées sur l'écran du terminal).</LI>
<LI>Print Controller on/off (contrôleur d'impression oui/non) : Activée
(on), les données venant de l'hôte ne sont envoyées qu'à l'imprimante (rien
ne s'affiche sur l'écran du terminal).</LI>
</UL>
</P>

<H2><A NAME="ss20.4">20.4 Rapports</A>
</H2>


<P>Ces séquences sont en général des requêtes envoyées de l'hôte pour demander
un rapport du terminal. Le terminal répond en envoyant un rapport (en fait
une autre séquence d'échappement) à l'hôte qui y a intégré certaines valeurs
indiquant à l'hôte l'état en cours du terminal. Dans certains cas un rapport
peut être envoyé à l'hôte même s'il n'a pas été demandé. Ceci arrive parfois
quand on quitte la configuration. Par défaut aucun rapport non sollicité ne
devrait être envoyé.</P>
<P>
<UL>
<LI>Request for Status (Report Operating Status) (Demande d'état, rapporter
l'état d'opération) : la signification des réponses du VT100 est soit "je
vais bien", soit "je ne vais pas bien"</LI>
<LI>Request for Device Attributes (demande des attributs du périphérique) :
le "périphérique" est en général l'imprimante. Y a-t-il une imprimante ?
Est-elle prête ?</LI>
<LI>Request for Tertiary Device Attributes (pour les VT) (demande des
attributs des périphériques tertiaires) : la réponse est le rapport qui a été
entré pendant la configuration. Le périphérique tertiaire est le troisième
périphérique (l'imprimante ou le périphérique sur le port auxiliaire ??).  Le
premier périphérique peut être l'ordinateur hôte et le deuxième périphérique
le terminal.</LI>
<LI>Request for Terminal Parameters (demande des paramètres du terminal) :
quelle est la parité, la vitesse de transmission, la largeur d'octets, etc.
Cette demande n'a pas l'air d'avoir beaucoup de sens, puisque si l'hôte ne
connaissait pas déjà ces données, il ne pourrait pas communiquer avec le
terminal ou envoyer une réponse.</LI>
</UL>
 </P>

<H2><A NAME="ss20.5">20.5 Mouvements du curseur</A>
</H2>


<P>Le curseur se trouve à l'endroit où le prochain caractère reçu de l'hôte sera
affiché. La plupart des mouvements de curseur sont compréhensibles. "index
cursor" (indexer le curseur) veut dire déplacer le curseur vers le bas d'une
ligne. Les mouvements du curseur peuvent être relatifs à la position en cours
comme "déplacer de 4 espaces vers la gauche" ou absolus comme "déplacer à la
rangée 3, colonne 39". Le mouvement absolu s'appelle "positionnement direct
du curseur" ou "adressage direct du curseur".</P>
<P>La position d'origine est rangée 1, colonne 1 (l'origine de l'index est 1).
Mais l'emplacement de cette position d'origine à l'écran n'est pas clair. Si
"mode d'origine du curseur", équivalent à "mode d'origine relatif", est
choisi, l'origine se trouve en haut de la partie défilante (pas forcément le
haut de l'écran). Si le "mode d'origine absolu" est choisi (même chose que
désactiver l'un des deux modes de la phrase précédente) alors l'origine se
situe dans le coin en haut à gauche de l'écran. Sur certains terminaux
anciens si le "mode d'origine du curseur" est activé, cela veut dire que
c'est relatif. </P>

<H2><A NAME="pages_def"></A> <A NAME="ss20.6">20.6 Pages (définition)</A>
</H2>


<P>Voyez 
<A HREF="#pages_">pages</A> pour avoir une explication sur les
pages. Il y a un certain nombre de séquences d'échappement pour s'occuper
des pages. Le texte peut être copié d'une page à une autre et on peut
déplacer le curseur de page en page. Le passage d'une page à l'autre peut ou
peut ne pas être automatique&nbsp;: quand l'écran est plein (page 1), alors
les données supplémentaires venant de l'hôte vont sur la page 2. Le curseur
peut n'être que sur une page à la fois et les caractères envoyés au terminal
vont là. Si cette page n'est pas affichée, le nouveau texte sera reçu par le
terminal et ira en mémoire d'affichage, mais vous ne le verrez pas (jusqu'à
ce qu'on passe à cette page sur le terminal).</P>

<H2><A NAME="s21">21. Annexe C : communications série sur EIA-232 (RS-232)</A></H2>



<H2><A NAME="ss21.1">21.1 Introduction aux communications série</A>
</H2>


<P>(Une grande partie de cette section se trouve maintenant dans le
Serial-HOWTO.) Les terminaux texte sur les systèmes de type Unix (et sur les
PC) sont connectés en général sur un port série asynchrone 232 d'un
ordinateur. C'est en général un port RS-232-C, EIA-232-D ou EIA-232-E. Ces
trois ports sont à peu près identiques. Le préfixe originel RS est devenu EIA
(Electronics Industries Association) et plus tard EIA/TIA après que EIA se
soit alliée avec TIA (Telecommunications Industries Association). La
spécification EIA-232 décrit aussi les communications synchrones mais le
matériel qui supporte les communications synchrones manque quasiment toujours
sur les PC. La désignation RS est obsolète mais est toujours utilisée. On
utilisera EIA dans cet article.</P>
<P>Le port série représente plus qu'un simple connecteur physique au dos d'un
ordinateur ou d'un terminal. Il comprend l'électronique associée qui doit
produire des signaux conformes à la spécification EIA-232. Le connecteur
standard possède 25 broches, dont la plupart sont inutilisées. Un connecteur
différent ne possède que neuf broches. Une broche est utilisée pour envoyer
des octets de données et une autre pour en recevoir. Une autre broche est la
masse commune du signal. Les autres broches "utiles" sont principalement
utilisées à des fins de signalisation avec une tension négative régulière
voulant dire "éteint" et une tension positive régulière voulant dire
"allumé".</P>
<P>La puce UART (émetteur-récepteur asynchrone universel) fait la plus grande
partie du travail. Aujourd'hui, les possibilités de cette puce sont en
général incluses dans une autre puce.</P>

<H2><A NAME="ss21.2">21.2 Tensions</A>
</H2>



<H3>Tension pour un bit</H3>


<P>Sur le port série EIA-232, les tensions sont bi-polaires (positives ou
négatives par rapport à la masse) et devraient être de l'ordre de 12 volts en
amplitude (certaines font 5 ou 10 volts). Sur les broches d'émission et de
réception +12 volts représente le bit 0 (parfois appelé "espace") et -12
volts est le bit 1 (parfois appelé "marque"). On appelle cela la logique
inversée puisque normalement le bit 0 est à la fois faux et négatif alors que
le 1 est normalement vrai et positif. Bien que les broches de transmission et
réception soient en logique inversée, d'autres broches (les lignes de
contrôle du modem) sont en logique normale avec une tension positive étant
vraie et une tension négative étant fausse. La tension zéro n'a aucune
signification (sauf qu'elle veut dire en général que l'unité est éteinte).</P>
<P>Une étendue de tensions est permise. Les spécifications disent que
l'amplitude d'un signal transmis devrait être entre 5 et 15 volts mais ne
doit jamais dépasser 25 volts. Toute tension reçue en dessous de 3 volts est
indéfinie (mais certains terminaux considèreront qu'une tension plus basse
est valide). On voit parfois des affirmations erronnées selon lesquelles la
tension est communément 5 volts (ou même 3 volts) mais c'est en général 11-12
volts. Si vous utilisez un port EIA-422 sur un ordinateur Macintosh comme un
EIA-232 (cela demande un câble spécial) ou un EIA-423 alors la tension sera
vraiment 5 volts. La discussion ici suppose que c'est 12 volts. Il y a
beaucoup de confusion à propos des tensions sur Internet.</P>
<P>Notez que la logique d'ordinateur normale n'est que de quelques volts (à une
époque, la norme était 5 volts), et que si vous essayez d'utiliser un
équipement de test fait pour tester une logique d'ordinateur en 3-5 volts
(TTL) sur les 12 volts d'un port série, cela peut endommager l'équipement de
test.</P>

<H3><A NAME="byte_seq"></A> Séquence de tension pour un octet</H3>


<P>La broche de transmission (TxD) est maintenue à -12 V (marque) comme inactive
quand rien n'est envoyé. Pour commencer un octet elle passe à +12 V (espace)
pour le bit de départ et reste à +12 V pendant la durée (période) du bit de
départ. Après vient le bit de bas niveau de l'octet de données. Si c'est un
bit 0 rien ne change et la ligne reste à +12 V pendant une autre période de
bit.  Après vient le bit suivant, etc. Finalement, un bit de parité peut être
envoyé et ensuite un bit de stop de -12 V (marque). La ligne reste à -12 V
(inactive) jusqu'au prochain bit de départ. Notez qu'il n'y a pas de retour à
0 volts et il n'y a donc pas de moyen simple (sauf avec un signal de
synchronisation) pour dire où finit un bit et où commence le bit suivant dans
le cas où deux bits consécutifs ont la même polarité (tous les deux zéro ou
tous les deux un).</P>
<P>Un deuxième bit de stop serait aussi à -12 V, identique au premier bit de
stop. Puisqu'il n'y a pas de signal pour marquer la frontière entre ces deux
bits, le seul effet du deuxième bit de stop est que la ligne doit rester
inactive à -12 V deux fois plus longtemps. Le récepteur n'a aucun moyen de
faire la différence entre un deuxième bit de stop et un temps d'inactivité
plus long entre les octets. Ainsi les communications fonctionnent bien si une
extrémité utilise un bit de stop et l'autre extrémité utilise deux bits de
stop, mais n'utiliser qu'un bit de stop est visiblement plus rapide. Dans de
rares cas, un bit de stop et demi est utilisé. Ceci veut dire que la ligne
est gardée à -12 V pendant une période de temps et demie (comme un bit de
stop 50 % plus long que la normale).</P>

<H2><A NAME="parity_def"></A> <A NAME="ss21.3">21.3 La parité expliquée</A>
</H2>


<P>Les caractères sont normalement transmis sur 7 ou 8 bits (de données). Une
parité supplémentaire peut (ou peut ne pas) y être ajoutée, ce qui donne un
octet de longueur 7, 8 ou 9 bits. Certains émulateurs de terminaux et
terminaux anciens n'autorisent pas 9 bits. Certains interdisent 9 bits si on
utilise deux bits de stop (puisque cela ferait beaucoup trop de bits : 12
bits au total).</P>
<P>On peut mettre une parité impaire, paire, ou pas de parité (les parités
marque et espace peuvent être des options sur certains terminaux). Avec une
parité impaire, le bit de parité est sélectionné de telle sorte que le nombre
de bit 1 dans un octet, en comprenant le bit de parité, soit impair. Si un
tel octet se détériore par l'inversion d'un bit, le résultat est un octet
illégal de parité paire. Cette erreur sera détectée et si c'est un octet
arrivant au terminal, un symbole caractère d'erreur apparaîtra à l'écran. La
parité paire fonctionne de manière similaire avec tous les octets légaux
(comprenant le bit de parité) ayant un nombre de bit 1 pair. Pendant la
configuration, le nombre de bits par caractère signifie en général le nombre
de bits de données par octet (7 pour de l'ASCII pur et 8 pour les divers
codes de caractères ISO).</P>
<P>Une "marque" est un bit 1 (ou un 1 logique) et un "espace" est un bit 0 (ou
un 0 logique). Pour la parité marque, le bit de parité est toujours un bit 1.
Pour la parité espace c'est toujours un bit 0. La parité marque ou espace ne
fait que gâcher de la bande passante et devrait être évitée autant que
possible. "Pas de parité" veut dire qu'aucun bit de parité n'est ajouté. Pour
les terminaux qui n'autorisent pas les octets de 9 bits, il faut sélectionner
"pas de parité" pour utiliser des codes de caractères sur 8 bits puisqu'il
n'y a pas de place pour le bit de parité.</P>

<H2><A NAME="ss21.4">21.4 Formation d'un octet (encadrement)</A>
</H2>


<P>Dans la transmission en série des octets par les ports EIA-232, le bit de bas
niveau est toujours envoyé en premier. Les ports série sur les PC utilisent
des communications asynchrones quand il y a un bit de départ et un bit de
stop pour marquer le début et la fin d'un octet. On appelle cela
l'encadrement et l'octet encadré s'appelle parfois un cadre. Au final, 9, 10
ou 11 bits sont envoyés par octet, 10 étant le nombre le plus courant. 8-N-1
veut dire 8 bits de données, pas de parité, 1 bit de stop. Ceci fait en tout
10 bits si on compte le bit de départ. Un bit de stop est utilisé quasiment
partout. À 110 bits/seconde (et parfois à 300 bits/seconde) deux bits de stop
étaient autrefois utilisés mais maintenant le deuxième bit de stop n'est
utilisé que dans des situations très inhabituelles (ou par erreur puisqu'il
semble encore fonctionner correctement de cette manière).</P>

<H2><A NAME="ss21.5">21.5 Limitations de EIA-232</A>
</H2>



<H3>Basses vitesses et courtes distances</H3>


<P>Le port série EIA-232 traditionnel est à basse vitesse de manière inhérente,
et est sérieusement limité en taille (distance). Les publicités disent
souvent "grande vitesse" mais cela ne peut fonctionner à grande vitesse que
sur de très courtes distances comme pour un modem situé juste à côté de
l'ordinateur. Tous les fils utilisent un retour de masse commun et donc la
technologie en paire torsadée (nécessaire à de grandes vitesses) ne peut être
utilisée sans matériel supplémentaire. Cependant certains ordinateurs
possèdent des interfaces plus modernes. Voyez 
<A HREF="#non_232">successeurs de EIA-232</A>.</P>
<P>Il est parfois décevant que la norme RS-232 de 1969 n'ait pas utilisé la
technologie en paire torsadée qui aurait pu fonctionner à peu près 100 fois
plus rapidement. Les paires torsadées sont utilisées dans les câbles
téléphoniques depuis la fin du 19ème siècle. En 1888 (il y a plus de 100 ans)
la "conférence sur le câble" a rapporté son attachement à la paire torsadée
(pour les systèmes téléphoniques) et a avancé ses avantages. Mais plus de 80
ans après cette approbation par la "conférence du câble", RS-232 n'a pas
réussi à l'utiliser. Puisque RS-232 était au départ faite pour connecter un
terminal à un modem basse vitesse situé tout près, le besoin de grande
vitesse et d'une longueur de transmission plus élevée n'a apparemment pas été
perçu.</P>

<H3><A NAME="non_232"></A> Successeurs de EIA-232</H3>


<P>Un certain nombre de normes EIA ont été établies pour des vitesses plus
élevées et des distances plus grandes en utilisant la technologie en paire
torsadée (équilibrée). Une transmission équilibrée peut parfois être une
centaire de fois plus rapide que EIA-232 non équilibrée. Pour une vitesse
donnée, la distance (longueur maximale du câble) peut être beaucoup de fois
plus grande avec de la paire torsadée. Mais les PC continuent d'être
fabriqués avec l'EIA-232 "obsolète" puisque que cela fonctionne correctement
avec les modems reliés aux lignes téléphoniques lentes, et cela fonctionne
correctement avec les souris.</P>
<P>Une exception reste l'ordinateur Macintosh d'Apple avec son GeoPort
EIA-232/EIA-422 qui fournit de la paire torsadée (équilibrée) pour la
transmission et la réception. Il utilise un petit connecteur rond "mini-DIN".
Il fournit aussi du EIA-232 traditionnel mais seulement à 5 volts (ce qui
reste du EIA-232 légal). Cependant, à cause du fait que les Mac coûtent plus
cher que les PC, on les utilise rarement comme ordinateur hôte pour des
terminaux. Certains terminaux récents utilisent l'EIA-423 mais cela reste
comme de l'EIA-232 non équilibré et on peut les relier à un port EIA-232. Cet
EIA-423 ne fait que 5 volts, mais les spécifications donnent des vitesses
plus élevées que pour EIA-232 (qui ne sera d'aucune aide sur une grande
distance où c'est le non-équilibrage qu cause les interférences).</P>
<P>L'EIA-530-A (équilibré mais peut aussi être non équilibré) à 2 Mbits/s
(équilibré) était fait pour remplacer EIA-232 mais on en a peu installé. Elle
utilise le même connecteur à 25 broches que EIA-232. L'interface série à
grande vitesse (HSSI = EIA-612/613, High Speed Serial Interface) utilise un
connecteur à 50 broches et monte à peu près à 50 Mbits/s mais la distance est
limitée à seulement quelques mètres. Le Bus Série Universel (USB, Universal
Serial Bus) est construit dans des puces PCI. Il fait 12 Mbits/s sur une
paire torsadée avec un connecteur à 4 broches (2 câbles fournissent le
courant) mais il est aussi limité à des distances courtes d'au plus 5 mètres
(cela dépend de la configuration).</P>

<H3>Pilotes de lignes</H3>


<P>Pour un terminal texte, les vitesses de EIA-232 sont suffisamment rapides
mais la longueur de câble utilisable est souvent trop courte. La technologie
équilibrée pourrait résoudre ce problème. La méthode courante pour obtenir
une communication équilibrée avec un terminal texte est d'installer deux
pilotes de ligne dans la liaison série pour convertir du non équilibré en
équilibré (et vice-versa). Ce sont des appareils spécialisés et ils sont
chers si on les achète neufs.</P>

<H2><A NAME="sync"></A> <A NAME="ss21.6">21.6 Synchronisation et synchrone</A>
</H2>



<H3>Comment on synchronise l'"asynchrone"</H3>


<P>Dans EIA-232 il n'y a que deux états sur le fil de transmission (ou de
réception) : marque (-12 V) ou espace (+12 V). Il n'y a pas d'état à 0 V.
Ainsi une séquence de bits à 1 est tranmise avec uniquement du -12 V stable
sans marqueur d'aucune sorte entre les bits. Pour que le récepteur détecte
les bits individuels il doit toujours disposer d'un signal d'horloge qui est
synchronisé avec l'horloge de l'émetteur. De telles horloges génèrent un
"top" synchronisé avec chaque bit transmis (ou reçu).</P>
<P>En transmission asynchrone, la synchronisation est faite en encadrant chaque
octet d'un bit de départ et d'un bit de stop (fait par le matériel). Le
récepteur attend sur la ligne un bit de départ et quand il en détecte un il
lance son top d'horloge. Il utilise ce top d'horloge pour mesurer le temps de
lecture des 7, 8 ou 9 prochains bits. (C'est en fait un petit peu plus
compliqué que cela puisqu'on prend en général plusieurs mesures pour un bit,
ce qui demande des tops supplémentaires.) Ensuite le bit de stop est lu,
l'horloge s'arrête et le récepteur attend le bit de départ suivant. Ainsi
l'asynchrone est en fait synchronisé pendant la réception d'un seul octet
mais il n'y a pas de synchronisation entre un octet et l'octet suivant.</P>

<H3>Définir l'asynchrone par rapport au synchrone</H3>


<P>L'asynchrone signifie "non synchrone". En pratique, un signal asynchrone
représente ce que le port série asynchrone envoie et reçoit qui est un flux
d'octets, chacun d'entre eux étant délimité par un bit de départ et un bit de
stop. Le synchrone est à peu près tout le reste. Mais ceci n'explique pas les
concepts de base.</P>
<P>En théorie, synchrone veut dire que les octets sont envoyés à vitesse
constante l'un après l'autre en accord sur un top d'horloge. Il y a souvent
un fil ou un canal séparé pour envoyer le top d'horloge. Les octets
asynchrones peuvent être envoyés n'importe quand avec des intervalles de
temps variés entre les octets (comme quelqu'un qui tape des caractères sur un
clavier).</P>
<P>Il y a des situations limites qu'on doit classer comme synchrones ou
asynchrones. Le port série asynchrone envoie souvent des octets dans un flux
constant qui en ferait un cas synchrone mais comme il y aura encore les bits
de départ et de stop (ce qui permet de les envoyer de manière indéterminée)
on l'appelle asynchrone. Un autre cas est quand les octets de données (sans
auncun bit de départ ou de stop) forment des paquets avec un espacement
erratique entre un paquet et le suivant. On l'appelle synchrone puisque les
octets à l'intérieur de chaque paquet doit être transmis de manière
synchrone.</P>

<H3>Communication synchrone</H3>


<P>Ne vous-êtes vous jamais demandé ce qu'on faisait de toutes les broches
inutilisées sur un connecteur 25 broches pour le port série ? La plupart
d'entre eux sont utilisés dans une communication synchrone qu'on implémente
rarement sur les PC. Il y a des broches pour les signaux de temporisation de
synchronisation ainsi que pour un canal inverse synchronisé. La spécification
EIA-232 est donnée à la fois pour les communications synchrones et
asynchrones mais les PC utilisent une puce UART (Émetteur Récepteur
Asynchrone Universel) comme un 16450, un 16550A ou un 16550 et ne peuvent
faire de la synchronisation. Pour faire du synchrone on a besoin d'une puce
USART ou équivalente où le "S" veut dire synchrone. Puisque le synchrone est
un marché de niche, un port série synchrone est sûrement assez cher.</P>
<P>À côté de la partie synchrone de EIA-232, il y a plusieurs autres normes EIA
synchrones. Pour EIA-232, trois broches sur le connecteur sont réservées pour
les signaux d'horloge (de temporisation). Parfois c'est le rôl du modem de
générer certains signaux de temporisation rendant l'utilisation de
communications synchrones impossibles sans un modem synchrone (ou sans
appareil qu'on appelle "éliminateur de modem synchrone" qui fournit les
signaux de temporisation).</P>
<P>Bien que peu de ports série soient synchrones, la communication synchrone
prend souvent place sur les lignes téléphoniques en utilisant des modems qui
utilisent la correction d'erreurs V.42. Ceci enlève les bits de départ et de
stop et place les octets de données dans des paquets ce qui donne une
opération synchrone sur la ligne téléphonique.</P>

<H2><A NAME="block"></A> <A NAME="ss21.7">21.7 Mode par blocs</A>
</H2>



<H3>Introduction au mode par blocs</H3>


<P>Le mode par blocs est rarement utilisé sous Linux. En mode par blocs, quand
quelqu'un tape sur un terminal, le résultat est sauvé dans la mémoire du
terminal et n'est pas envoyé immédiatement à l'ordinateur hôte. De tels
terminaux possèdent souvent des possibilités d'édition intégrées. Quand
l'utilisateur appuie sur certaines touches (comme la touche envoi), ce qui a
été sauvegardé dans la mémoire du terminal est envoyé à l'ordinateur hôte.
Cependant les éditeurs vi et emacs sous Linux réagissent instantanément à
l'appui de certaines touches, mais, dans la situation ci-dessus, si on appuie
sur de telles touches, rien ne se passera puisque rien n'est envoyé quand on
appuie sur une touche. Ainsi l'utilisation d'un terminal en mode par blocs ne
permettra pas l'utilisation de tels programmes interactifs. La vieille
interface vers les minis IBM utilise le mode par blocs (voyez 
<A HREF="#ibm_">terminaux IBM</A>) et donc beaucoup de terminaux IBM ne fonctionnent
qu'en mode par blocs et sont aussi synchrones (voyez la section 
<A HREF="#sync">synchronisation et synchrone</A>).</P>

<H3>Types de modes par blocs, formulaires</H3>


<P>Le mode par blocs peut lui-même avoir divers sous-modes comme "page" (une
page à la fois) et "ligne" (une ligne à la fois). Certains terminaux
possèdent à la fois les modes de transmissions par blocs et les modes
traditionnels par caractères, et on peut passer d'un mode à l'autre. Les
terminaux asynchrones possédant des modes par blocs sont parmi les HP2622A,
VT130, VT131, VT330, VT340 et Visual500. Beaucoup de modèles de terminaux
plus récents peuvent émuler le mode par blocs. Les modes par blocs peuvent
comprendre une possibilité de formulaires où l'ordinateur hôte envoie un
formulaire au terminal.  L'utilisateur le remplit alors et envoie la touche
envoi qui ne renvoie que les données du formulaire à l'ordinateur hôte. Le
formulaire lui-même (pas les données) est affiché à l'écran dans des champs
protégés qui ne sont pas transmis à l'hôte.</P>

<H3>Efficacité</H3>


<P>Les modes par blocs enlèvent une bonne partie de la charge sur l'ordinateur
hôte, surtout si le matériel de l'ordinateur hôte est fait pour les modes par
blocs (comme c'est/c'était le cas sur les minis IBM). En mode caractère,
chaque caractère tapé est envoyé immédiatement sur le port série et en
général génère une interruption sur l'ordinateur hôte. L'hôte qui reçoit
l'octet doit arrêter tout ce qu'il fait et va chercher ce caractère depuis le
matériel du port. Même avec des UART qui possèdent des tampons matériels
FIFO, le délai matériel ne représente normalement que le temps de
transmission de 3 octets, donc une interruption est générée à chaque
caractère tapé.</P>
<P>En vrai mode par blocs, un bloc de caractères long est reçu en n'utilisant
qu'une interruption. Si on utilise le mode par blocs avec des ports série
FIFO asynchrones, une interruption n'est nécessaire que tous les 14 octets
puisqu'ils ont des tampons matériels de 16 octets. Ainsi la plus grande
partie de la charge et du coût de la gestion des interruptions est éliminée
et l'ordinateur a plus de temps à consacrer à d'autres tâches quand on
utilise le mode par blocs.</P>
<P>On fait des économies significatives en mode par blocs si le terminal est
relié à son hôte par l'intermédiaire d'un réseau. Sans le mode par blocs,
chaque caractère (octet) tapé est envoyé dans son propre paquet avec tous les
octets d'enveloppe (40 dans un paquet TCP/IP comme ceux utilisés sur
l'Internet). En mode par blocs, un grand nombre de caractères est envoyé dans
un seul paquet.</P>

<H2><A NAME="RS232_books"></A> <A NAME="ss21.8">21.8 Livres sur EIA-232 (RS-232)</A>
</H2>


<P>(Note : le premier couvre bien plus que EIA-232 uniquement.)</P>
<P>
<UL>
<LI>Black, Uyless D.: Physical Layer Interfaces &amp; Protocols, IEEE Computer
Society Press, Los Alamitos, CA, 1996.</LI>
<LI>Campbell, Joe: The RS-232 Solution, 2nd ed., Sybex, 1982.</LI>
<LI>Putnam, Byron W.: RS-232 Simplified, Prentice Hall, 1987.</LI>
<LI>Seyer, Martin D.: RS-232 Made Easy, 2nd ed., Prentice Hall, 1991.</LI>
</UL>
</P>

<H2><A NAME="ss21.9">21.9 Logiciels série</A>
</H2>


<P>Voyez 
<A HREF="ftp://metalab.unc.edu/pub/Linux/system/serial/">logiciels série</A> pour les logiciels Linux sur les ports série avec
getty et les moniteurs de ports.</P>

<H2><A NAME="s22">22. Annexe D : Notes classées par marque</A></H2>


<P>Voici des notes classées par marque qui étaient trop spécifiques à un certain
terminal pour être mises autre part dans ce HOWTO. Si vous avez des
informations à apporter pour un terminal particulier qui n'est pas couvert
autre part, elles pourraient se trouver ici. Divers modèles et marques ont
souvent beaucoup de choses en commun qu'on ne doit écrire qu'à un endroit. Il
serait bien d'avoir, pour chaque modèle de terminal, un grand nombre de liens
vers les documentations se rapportant à ce modèle (avec les séquences
d'échappement). Il y a tellement de modèles de terminaux qu'une telle tâche
serait relativement pénible et moi, David Lawyer (en 1998), n'ai aucunement
l'intention de tenter cette aventure. Si les fabricants de terminaux
mettaient au moins leurs manuels à disposition sur Internet, alors tout ceci
ne serait pas nécessaire.</P>

<H2><A NAME="ss22.1">22.1 CIT</A>
</H2>


<P>Les terminaux CIT ont été fabriqués au Japon dans les années 1980 pour CIE
Terminals. On a cessé de les importer à la fin des années 1980. La société,
CIE, fabrique encore des imprimantes CItoh (en 1997) mais n'a pas de pièces
détachées pour ses terminaux arrêtés. Ernie au (714) 453-9555 à Irvine,
Californie, vendait (en 1997) certaines pièces pour les modèles 224, 326,
etc. mais n'a rien pour les 80 et 101. (Le document que vous lisez à l'heure
actuelle a été principalement écrit sur le 101e.)</P>
<P>Pour sauver les paramètres de configuration pressez ^S en mode Set-Up. cit80
: contraste : molette à l'arrière du terminal, cit101e : luminosité :
utilisez les touches fléchées haut/bas en mode Set-Up.</P>

<H2><A NAME="ibm_"></A> <A NAME="ss22.2">22.2 Terminaux IBM</A>
</H2>


<P>Ne confondez pas les terminaux IBM avec les moniteurs IBM PC. Beaucoup de
terminaux IBM n'utilisent pas l'ASCII mais à la place un code EBCDIC sur 8
bits. On dit que dans EBCDIC l'ordre de transmission des bits est inversée
par rapport à la normale avec le bit de haut rang en premier. Les normes de
communication avec les minis IBM sont un type de communication synchrone en
mode par blocs (envoie de grands paquets de caractères). Deux normes sont
"BISYNC" et "SNA" (qui comprend des normes de réseau). Beaucoup de leurs
terminaux sont reliés avec du câble coaxial (RG62A/U) et les personnes naïves
peuvent penser que le connecteur "BNC" sur le terminal est pour l'Ethernet
(mais ce n'est pas le cas).</P>
<P>Alors que ce système IBM est en réalité plus efficace que ce qui est
normalement utilisé sous Linux, les terminaux possédant ces caractéristiques
IBM ne fonctionneront pas sous Linux. Cependant, certains terminaux IBM sont
des terminaux ASCII asynchrones et devraient fonctionner sous Linux sur des
PC. Les modèles 31xx peuvent fonctionner à l'exception que 317x et 319x ne
sont pas des terminaux ASCII. Avant d'acquérir un terminal IBM, assurez-vous
qu'il y a une entrée termcap (ou terminfo) pour celui-ci. S'il n'y en a pas,
il ne fonctionnera probablement pas sous Linux. Même s'il y a une entrée
terminfo, il peut ne pas fonctionner. Par exemple, il y a une entrée termcap
pour les 327x mais le 3270 est un terminal synchrone EBCDIC.</P>
<P>Les modèles 3270 comprennent le 3278 (fin des années 1970), le 3279 avec la
couleur et les graphiques, et le contrôleur de terminal 3274 (à peu près
comme le 3174). On peut les utiliser à la fois pour BISYNC et SNA. Le 3290 a
un écran séparé (séparé en quartiers).</P>
<P>Les terminaux synchrones IBM ne sont pas directement reliés au mini IBM mais
sont reliés à un "contrôleur de terminaux" (qu'on appelle parfois "contrôleur
de cluster" ou "contrôleur de communications"). Certains de ces contrôleurs
peuvent convertir un signal synchrone en asynchrone et donc dans ce cas on
pourrait relier indirectement un terminal synchrone à un ordinateur hôte de
type Unix par son port série. Mais il reste un problème majeur qui est la
transmission par blocs. Voyez la section 
<A HREF="#block">mode par blocs</A>.</P>

<H3>IBM 3153</H3>


<P>On dit que le port Aux est DCE et utilise un câble droit.</P>

<H2><A NAME="teletype"></A> <A NAME="ss22.3">22.3 Teletypes</A>
</H2>


<P>Ce sont des antiquités et ils représentent les terminaux les plus anciens.
Ils ressemblent à des machines à écrire télécommandées mais sont grands et
font du bruit. Fabriqués par Teletype Corp., les premiers modèles ont été
faits dans les années 1920 et devancent l'ordinateur de plus de 30 ans. Les
premiers modèles utilisaient des relais électro-mécaniques et des
distributeurs rotatifs au lieu d'électronique. Leur code Baudot n'avait que 5
bits par caractère comparé à l'ASCII sur 7 bits. Voyez le livre "Small
Computer Systems Handbook" par Sol Libes, Hayden Books, 1978 : pp. 138-141
("Teletypes").</P>

<H2><A NAME="ss22.4">22.4 VT (DEC)</A>
</H2>


<P>Digital Equipment Corporation a fabriqué les modèles VT renommés avec le
VT100 couramment émulé. En 1995 ils ont vendu leur partie terminaux à
SunRiver qui s'appelle maintenant Boundless Technologies. On trouvera plus
d'informations sur le 
<A HREF="http://www.cs.utk.edu/~shuford/terminal_index.html">site Web de Shuford</A>. Les informations sur les produits actuels sont disponibles sur le
site Web de Boundless. Voyez 
<A HREF="#internet">informations sur Internet</A>.</P>
<P>VT220 : certains possèdent un connecteur BNC pour la sortie vidéo (pas pour
l'entrée). Parfois les gens croient à tort que c'est pour une liaison
Ethernet.</P>
<P>VT520 : il supporte le contrôle de flux DTR/DSR complet.</P>

<H2><A NAME="ss22.5">22.5 Wyse</A>
</H2>


<P>Wyse possède certaines FAQ pour les terminaux dont les numéros sont
en-dessous de 100 (comme le WY60). Voyez 
<A HREF="http://www.wyse.com/service/faq/wysetterl.htm">http://www.wyse.com/service/faq/wysetterl.htm</A>. Pour les spécifications
de terminaux plus récents voyez 
<A HREF="http://www.wyse.com/terminal/">http://www.wyse.com/terminal/</A>.</P>

<H3>Wyse 99-GT</H3>


<P>Voici les menus de configuration du Wyse99GT (fin des années 1980). Notez que
TERM veut dire "terminaison" (caractère) et non "terminal".</P>
<P>
<PRE>
Configuration du terminal WYSE 99-GT telle qu'utilisée à l'université
      d'Irvine, Californie par David Lawyer, avril 1990

                        F1 DISP:
COLUMNS=80              LINES=24                CELL SIZE=10 X 13
STATUS LINE=STANDARD    BACKGROUND=DARK         SCROLL SPEED=JUMP
SCREEN SAVER=OFF        CURSOR=BLINK BLOCK      DISPLAY CURSOR=ON
ATTRIBUTE=CHAR          END OF LINE WRAP=ON     AUTO SCROLL=ON
----------------------------------------------------------------------------
                        F2  GENERAL: 
PERSONALITY=VT 100      ENHANCE=ON              FONT LOAD=OFF
COMM MODE=FULL DUPLEX   RCVD CR=CR              SEND ACK=ON
RESTORE TABS=ON         ANSWERBACK MODE=OFF     ANSWERBACK CONCEAL=OFF 
WIDTH CHANGE CLEAR=OFF  MONITOR=OFF             TEST=OFF
----------------------------------------------------------------------------
                        F3 KEYBRD:
KEYCLICK=OFF            KEYLOCK=CAPS            KEY REPEAT=ON
RETURN=CR               ENTER=CR                FUNCT KEY=HOLD
XMT LIMIT=NONE          FKEY XMT LIMIT=NONE     BREAK=170MS
LANGUAGE=US             MARGIN BELL=OFF         PRINTER RCV=OFF
----------------------------------------------------------------------------
                        F4 COMM:
DATA/PRINTER=AUX/MODEM    MDM RCV BAUD RATE=9600  MDM XMT BAUD RATE=9600
MDM DATA/STOP BITS=8/1    MDM RCV HNDSHAKE=NONE   MDM XMT HNDSHAKE=NONE
MDM PARITY=NONE           AUX BAUD RATE=9600      AUX DATA/STOP BITS=8/1
AUX RCV HNDSHAKE=NONE     AUX XMT HNDSHAKE=NONE   AUX PARITY=NONE
(Il y a un port principal (Modem=MDM) et un port auxiliaire (AUX)
----------------------------------------------------------------------------
                        F5 MISC 1:
WARNING BELL=ON         FKEY LOCK=OFF           FEATURE LOCK=ON
KEYPAD=NUMERIC          DEL=DEL/CAN             XFER TERM=EOS
CURSOR KEYS=NORMAL      MARGIN CTRL=0           DEL FOR LOW Y=ON
GIN TERM=CR             CHAR MODE=MULTINATIONAL
----------------------------------------------------------------------------
                        F6 MISC 2:
LOCAL=OFF               SEND=ALL                PRINT=NATIONAL
PORT=EIA DATA           SEND AREA=SCREEN        PRINT AREA=SCREEN
DISCONNECT=60 MSEC      SEND TERM=NONE          PRINT TERM=NONE
PRINT MODE=NORMAL       VT100 ID=VT100          POUND=US
----------------------------------------------------------------------------
F7 TABS: Vous devriez voir plusieurs caractères "T" séparés par 8 points.
    Sinon, appuyez sur backspace.
F8 F/KEYS: Vous ne verrez normalement pas de définition pour les touches de
    fonction ici (sauf si quelqu'un les a définies et sauvées). Ceci veut
    dire qu'elles génèreront normalement leurs valeurs par défaut (pas
    affichées ici). &lt;ctrl>&lt;F5> montre la "définition par l'utilisateur" de la
    touche F5, etc.  F9 A/BACK: Normally not defined: ANSWERBACK =
F10 EXIT: La sélection de "DEFAULT ALL" rendra les paramètres par défaut
    définis en usine.
</PRE>
</P>
<P>Astuces sur l'utilisation du Guide de l'Utilisateur du WY-99GT :</P>
<P>Notez qu'on peut trouver une grande partie de ce qui manque dans ce guide
dans le Guide du Programmeur WY-99GT. L'émulation (personnalité) VT100
s'appelle ANSI et utilise les codes de touches ANSI comme indiqué à la page
A-10 et plus, bien que le clavier soit en ASCII. Un sous-titre sur la page
A-13 "clavier ASCII" s'applique aussi au VT100 parce qu'il a un sur-titre
"Touches ANSI..." quelques pages avant. Mais tous les titres sur le clavier
ASCII ne concernent pas le VT100 puisqu'ils tombent dans un sur-titre de
personnalité non ANSI qu'on peut trouver quelques pages auparavant. L'annexe
H est le "guide de commandes ANSI" sauf pour la personnalité VT52 (ANSI)
qu'on trouve dans l'annexe G.</P>

<H3>Wyse 150</H3>


<P>Quand on sort du menu de configuration avec F12, l'appui sur espace change de
"non" à "oui" pour sauver la configuration. La phrase à gauche de ce non/oui
parle d'"alignement vertical" et n'a rien à faire avec ce non/oui pour sauver
la configuration (interface de menu confuse).</P>
<P>Fin du HOWTO Text-Terminal</P>

</BODY>
</HTML>
