<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.21">
 <TITLE>Vesafb mini-HOWTO</TITLE>
</HEAD>
<BODY>
<H1>Vesafb mini-HOWTO</H1>

<H2>Alex Buell, <CODE>alex.buell@tahallah.demon.co.uk</CODE></H2>v0.5, 2 August 1998
<HR>
<EM>Ce document décrit l'utilisation du gestionnaire vesafb sous Linux pour
un pc comprenant une carte graphique conforme aux spécifications VESA 2.0.</EM>
<HR>
<H2><A NAME="s1">1. Remerciements</A></H2>

<P>Merci aux personnes dont les noms suivent pour avoir aidé à l'amélioration
du HOWTO vesafb.</P>
<P>
<UL>
<LI>Jeff Noxon <CODE>jeff@planetfall.com</CODE></LI>
<LI>Francis Devereux <CODE>f.devereux@cs.ucl.ac.uk</CODE></LI>
<LI>Andreas Ehliar <CODE>ehliar@futurniture.se</CODE></LI>
<LI>Martin McCarthy <CODE>marty@ehabitat.demon.co.uk</CODE></LI>
<LI>Simon Kenyon <CODE>simon@koala.ie</CODE></LI>
<LI>David Ford <CODE>david@kalifornia.com</CODE></LI>
<LI>Chris Black <CODE>cblack@cmpteam4.unil.ch</CODE></LI>
<LI>N Becker <CODE>nbecker@fred.net</CODE></LI>
<LI>Bob Tracy <CODE>rct@gherkin.sa.wlk.com</CODE></LI>
<LI>Marius Hjelle <CODE>marius.hjelle@roman.uib.no</CODE></LI>
<LI>Aaron Tiensivu <CODE>tiensivu@pilot.msu.edu</CODE></LI>
</UL>
</P>
<P>et bien sûr l'auteur du pilote:</P>
<P>
<UL>
<LI>Gerd Knorr <CODE>kraxel@cs.tu-berlin.de</CODE></LI>
<LI>Geert Uytterhoeven <CODE>Geert.Uytterhoeven@cs.kuleuven.ac.be</CODE></LI>
<LI>Martin Mares <CODE>mj@ucw.cz</CODE></LI>
<LI>S'il y en a d'autres, qu'ils lèvent la main. :o) </LI>
</UL>
</P>

<H2><A NAME="s2">2. Vesafb, quès acco ?</A></H2>

<P>Vesafb est un gestionnaire de mémoire vidéo sur compatible PC dédié aux cartes 
cartes graphiques conformes aux spécifications VESA 2.0. Son fonctionnement est
lié de près aux gestionnaires de mémoire vidéo génériques du noyau.</P>
<P>Vesafb permet le recours aux modes graphiques sur PC pour l'utilisation des
consoles textes en point par point. Vesafb autorise également l'affichage d'un
logo et c'est vraisemblablement ce pour quoi vous voulez vous en servir :o)</P>
<P>On ne peut malheureusement pas utiliser vesafb avec des cartes VESA 1.2.
En effet, ces cartes n'utilisent pas l'adressage linéaire. Quelqu'un écrira
peut-ètre un gestionnaire de périphériques vesafb12 pour ce type de cartes, 
mais cela consommera de la mémoire par ailleurs précieuse pour le noyau. :o(</P>
<P>Il existe cependant un moyen détourné d'accéder aux fonctionnalités VESA 2.0
sur une carte VESA 1.2. Peut-ètre pouvez vous charger depuis le DOS un 
programme de type TSR qui, utilisé conjointement avec loadlin, aidera à 
configurer la carte pour les modes graphiques voulus. Cela ne marchera pas 
toujours. Ainsi, certaines cartes de chez Cirrus Logic, telles les VLB 54xx, 
se retrouvent à une position en mémoire ( par exemple entre 15 et 16 Mo ) qui 
en interdit l'utilisation sur les systèmes munis de plus de 32 Mo de mémoire. 
Ce n'est pas rédhibitoire si l'on dispose d'un BIOS permettant de ne pas 
affecter de mémoire entre 15 et 16 Mo ( "Memory Hole" ) mais il m'a semblé 
comprendre que Linux n'aime pas ça. Si l'expérience vous tente, vous pouvez 
essayer UNIVBE ( disponible sur l'Internet ).</P>

<H2><A NAME="s3">3. Qu'est-ce qu'un gestionnaire de mémoire graphique ?</A></H2>

<P>Ce gestionnaire fournit une abstraction du matériel graphique. Il
reproduit le tampon mémoire de certains composants vidéo et offre aux
applications l'accés au matériel via une interface bien définie. Ainsi, les
logiciels n'ont plus à se préoccuper des détails de bas-niveau [ Traduit 
approximativement de /usr/src/linux/Documentation/fb/framebuffer.txt ]</P>

<H2><A NAME="s4">4. Comment fais-je fonctionner le gestionnaire vesafb ?</A></H2>

<P>[NB : les informations qui suivent sont basées sur mon expérience concernant 
le noyau Linux 2.1.112 sur un P75+ muni d'une carte ATI VideoExpress avec 2Mo 
de mémoire vidéo. N'hésitez pas à me faire part de vos expériences 
particulières. ]</P>
<P>A supposer que vous utilisiez menuconfig, vous devrez passer par les étapes
suivantes :</P>
<P>Dans le menu "Code maturity level options" :
<UL>
<LI>  Prompt for development and/or incomplete code/drivers </LI>
</UL>

[ceci peut changer dans les futurs noyaux. Ce HOWTO sera alors modifié] </P>
<P>Dans le menu "Console drivers" :</P>
<P>
<UL>
<LI> VGA Text Console</LI>
<LI> Video Selection Support</LI>
<LI> Support for frame buffer devices (experimental)</LI>
<LI> VESA VGA Graphic console</LI>
<LI> Advanced Low Level Drivers</LI>
<LI> Choisissez les gestionnaires Mono, 2bpp, 4bpp, 8bpp, 16bpp, 24bpp et 
32bpp .</LI>
<LI> VGA character/attributes support</LI>
</UL>
</P>
<P>Le support des composants VGA (en mode texte) - vgafb - appartenait à la liste 
ci-dessus mais il en a été supprimé en raison de son obsolescence. Il 
disparaitra sous peu. Sélectionnez plutôt "VGA Text Console".</P>
<P>Vérifiez bien que le support "Mac variable bpp packed pixel" n'est pas activé.
[ En 2.2.111, il semblerait qu'il le soit si "Advanced Low Level Drivers" 
l'est ].</P>
<P>Assurez vous que rien n'est modularisé. [J'ai des doutes quand aux possibilités
de modularisation de l'ensemble - les précisions seront les bienvenues]</P>
<P>Recompilez le noyau, modifiez l'/etc/lilo.conf de façon à ajouter le paramètre
VGA=ASK, lancez lilo. Ceci vous permettra de choisir le mode graphique que vous
voulez.</P>
<P>Redémarrez le noyau et essayez comme test d'entrer 0301 au prompt VGA. Vous 
devriez vous retrouver en 640x480 sur 256 couleurs avec un délicieux petit logo
de pingouin.</P>
<P>Maintenant que ça fonctionne, il vous reste à essayer les différents modes
VESA ( cf ci-dessous ), à choisir celui que vous préférez et à le figer via
le paramètre "VGA=toto" du lilo.conf. Pour cela, après avoir fait votre choix,
cherchez sa représentation décimale dans les tables qui suivent et utilisez ce
nombre. Par exemple, pour du 1280 par 1024 en 256 couleurs, vous utiliserez
"VGA=775". N'oubliez pas de relancer lilo. C'est tout. Pour davantage 
d'informations sur le sujet, reportez vous aux HOWTO sur LILO et Loadlin.</P>

<H2><A NAME="s5">5. De quels modes VESA puis-je me servir ?</A></H2>

<P>Cela dépend de votre carte graphique,  en particulier 
de la quantité de mémoire dont elle dispose. A vous de voir quels
sont les modes qui fonctionnent le mieux.</P>
<P>La table suivante fournit les numéros des modes que vous pouvez passer à
l'invite VGA ( en fait les indices se sont vus ajouter 0x200 afin de s'y
retrouver plus facilement dans la table ).</P>
<P>
<PRE>
Couleurs | 640x480 800x600 1024x768 1280x1024 1600x1200
---------+---------------------------------------------
256      |  0301    0303     0305     0307      031C
32,768   |  0310    0313     0316     0319      031D
65,536   |  0311    0314     0317     031A      031E
16.8M    |  0312    0315     0318     031B      031F
</PRE>
</P>
<P>La même chose en décimal :</P>
<P>
<PRE>
Couleurs | 640x480 800x600 1024x768 1280x1024 1600x1200
---------+---------------------------------------------
256      |   769     771      773      775       796
32,768   |   784     787      790      793       797
65,536   |   785     788      791      794       798
16.8M    |   786     789      792      795       799
</PRE>
</P>
<P>[L'auteur apprécierait fortement de recevoir les codes 03xx pour les modes
manquants, i.e. 1152x900]</P>

<H2><A NAME="s6">6. Existe-t-il un serveur X11 adapté à vesafb ? </A></H2>

<P>Oui. Si pour une raison ou une autre votre serveur habituel digère mal vesafb,
vous devrez utiliser la version XF86_FBdev. Téléchargez X332servonly.tgz
depuis 
<A HREF="http://wwwxfree86.org">http://wwwxfree86.org</A> ou un de ses mirroirs, 
décompressez le, effectuez
les modifications nécessaires dans le fichier xc/config/cf/xf86site.def et
décommentez le #define relatif à XF68FBDevServer. Ne prétez pas attention à ce 
qui se rapporte à m68k. L'architecture PC est supportée. Compilez le tout, il 
y en a pour un moment. Ooommmm...</P>
<P>Il n'y a pas encore actuellement de binaire XF86_FBdev disponible tel quel mais
Debian y travaille et les versions libc5/glibc devraient sortir. </P>
<P>Certains ont signalé que X11 n'est pas exploitable sur certaines cartes lorsque
le gestionnaire vesafb est activé. Si vous vous retrouvez dans ce cas, essayez
le dernier serveur XF86_FBdev pour X11. </P>
<P>Ce gestionnaire, utilisé avec vesafb, peut permettre de faire fonctionner X11  
avec certains chipsets à des résolutions qui ne seraient pas autrement 
supportées par quelque serveur X que ce soit ( ex. MGA G-200 ).  </P>
<P>Esperons que les problèmes de support des cartes graphiques avec X11 seront 
résolus par les versions à venir.</P>

<H2><A NAME="s7">7. Vesafb peut-il être modularisé ?</A></H2>

<P>En ce qui concerne le 2.1.112, vesafb ne peut être compilé en tant que module.
D'ailleurs, après modularisation, on ne verrait rien à l'écran jusqu'à ce que
l'on effectue un modprobe sur vesafb. Il est donc surement plus sage pour
l'instant de le laisser dans le noyau, des fois que le boot ne se déroule pas
correctement.</P>

<H2><A NAME="s8">8. Divers</A></H2>

<P>Les infos données ici sont valables pour la version 2.1.112 du noyau. Ce HOWTO
sera mis à jour selon l'avancement du développement du noyau. N'hésitez pas à
transmettre à l'auteur vos commentaires et approfondissements.</P>
<P>A noter : le défilement en arrière ne fonctionne pas encore. </P>

</BODY>
</HTML>
