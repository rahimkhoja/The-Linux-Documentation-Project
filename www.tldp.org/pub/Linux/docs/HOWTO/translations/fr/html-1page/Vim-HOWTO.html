<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.21">
 <TITLE>HOWTO de l'éditeur ViM couleur (Vi aMélioré, avec coloration syntaxique)</TITLE>
</HEAD>
<BODY>
<H1>HOWTO de l'éditeur ViM couleur (Vi aMélioré, avec coloration syntaxique)</H1>

<H2>Al Dev (Alavoor Vasudevan) 
<A HREF="mailto:alavoor@yahoo.com">alavoor@yahoo.com</A>;<BR>
Version française par Arnaud Launay,
<CODE>
<A HREF="mailto:asl@launay.org">asl@launay.org</A></CODE></H2>v14.0, 16 Août 2000
<HR>
<EM>Ce document est un guide pour configurer très rapidement l'éditeur couleur ViM
sur les systèmes Linux ou Unix. Les informations présentées ici augmenteront la
productivité du programmeur puisque l'éditeur ViM supporte la coloration
syntaxique et les fontes grasses qui augmentent la « lisibilité » du code. La
productivité d'un programmeur est accrue de 2 à 3 fois avec un éditeur couleur
comme ViM.
Les informations de ce document s'appliquent à tous les systèmes d'exploitation
sous lesquels Vim fonctionne, c'est-à-dire Windows 95/NT, Apple Mac, et toutes
les versions d'Unix telles que Linux, FreeBSD, Solaris, HPUX, AIX, SCO, Ultrix,
Sinix, BSD, SCO, etc. (ce qui revient à dire, à peu près tous les OS de la
planète !).</EM>
<HR>
<H2><A NAME="s1">1. Introduction</A></H2>

<P>L'éditeur ViM signifie « Vi iMproved » (Vi amélioré). Vi est l'éditeur le plus
populaire et le plus puissant du monde Unix. Son nom vient de l'abbréviation
éditeur <I><B>Vi</B></I>suel. Un éditeur visuel comme Vi était un grand
progrès par rapport aux éditeurs en ligne comme 'ed' (ou 'ex'). Les éditeurs
'ed' et 'ex' sont toujours disponibles sous Linux : voyez 'man ed' et 'man ex'.</P>
<P>Un bon éditeur augmentera la productivité du programmeur. Vim supporte la
coloration syntaxique du code ainsi que différentes fontes, normales,
grasses ou italiques. Les éditeurs couleurs comme ViM augmentent la productivité du
programmeur de 2 à 3 fois ! Les programmeurs peuvent lire le code beaucoup plus
rapidement si la syntaxe du code est colorées et mise en évidence.</P>

<H2><A NAME="avant"></A> <A NAME="ss1.1">1.1 Avant d'installer </A>
</H2>

<P>Avant d'installer ViM, référez vous aux notes relevant de l'OS et aux
informations sur la compilation et l'usage de ViM sur -
<UL>
<LI> Allez ici et regardez les fichiers os_*.txt 
<A HREF="http://cvs.vim.org/cgi-bin/cvsweb/vim/runtime/doc">http://cvs.vim.org/cgi-bin/cvsweb/vim/runtime/doc</A></LI>
</UL>
</P>
<P>Si vous n'avez pas le paquetage ViM (RPM, DEB, tar, zip) alors chargez le code
source par ftp sur le site officiel de ViM
<UL>
<LI>La page maison de ViM est sur 
<A HREF="http://www.vim.org">http://www.vim.org</A></LI>
<LI>Le site miroir US est sur 
<A HREF="http://www.us.vim.org">http://www.us.vim.org</A></LI>
<LI>Le site FTP est sur 
<A HREF="ftp://ftp.vim.org/pub/vim">ftp://ftp.vim.org/pub/vim</A></LI>
<LI>Ou utilisez un des miroirs sur 
<A HREF="ftp://ftp.vim.org/pub/vim/MIRRORS">ftp://ftp.vim.org/pub/vim/MIRRORS</A></LI>
</UL>
</P>

<H2><A NAME="ss1.2">1.2 Installer ViM sous RedHat Linux</A>
</H2>

<P>Pour utiliser ViM, installez les paquetages rpm suivants sous RedHat -
<HR>
<PRE>
        rpm -i vim*.rpm
Ou comme ceci -
        rpm -i vim-enhanced*.rpm
        rpm -i vim-X11*.rpm
        rpm -i vim-common*.rpm
        rpm -i vim-minimal*.rpm
</PRE>
<HR>

Vous pouvez voir la liste des fichiers ViM que rpm a installé par
<HR>
<PRE>
        rpm -qa | grep ^vim | xargs rpm -ql | less
ou
        rpm -qa | grep ^vim | awk '{print "rpm -ql " $1 }' | /bin/sh | less
</PRE>
<HR>
</P>
<P>Et regardez la sortie en utilisant j, k, CTRL+f, CTRL+D, CTRL+B, CTRL+U ou les
touches fléchées, page up/down. Voyez aussi 'man less'.</P>

<P>Notez que les paquetages RPM pour RedHat Linux utilisent une interface Motif.
Si vous avez installé les librairies GTK sur votre système, vous pouvez
envisager de recompiler ViM à partir du source code afin de bénéficier d'une
interface graphique propre. Pour les informations sur la compilation du code de
ViM, voyez « installer ViM sur Unix » plus bas.</P>

<H2><A NAME="ss1.3">1.3 Installer ViM sous GNU Debian Linux</A>
</H2>

<P>Pour installer ViM sous Debian Linux (GNU Linux), identifiez vous en tant que superutilisateur et lorsque vous êtes connecté à Internet tapez -
<HR>
<PRE>
apt-get install vim vim-rt
</PRE>
<HR>

Cela chargera la dernière version de ViM, l'installera, le configurera, et
supprimera les fichiers .deb chargés. Le premier paquetage listé est
ViM, l'éditeur standard, compilé avec support pour X11, vim-rt est le
vim-runtime, c'est-à-dire les fichiers de syntaxe et d'aide.</P>

<H2><A NAME="ss1.4">1.4 Installer ViM sous Unix</A>
</H2>

<P>Pour les autres versions d'Unix comme Solaris, HPUX, AIX, Sinix, SCO,
récupérez les fichiers sources (voyez 
<A HREF="#avant">avant</A>
)
<HR>
<PRE>
        zcat vim.tar.gz | tar -xvf -
        cd vim-5.6/src
        ./configure --enable-gui=motif
        make
        make install
</PRE>
<HR>
</P>

<H2><A NAME="ss1.5">1.5 Installer ViM sous Microsoft Windows 95/NT</A>
</H2>

<P>Pour Windows 95/NT, récupérez les fichiers zip et installez-les en cliquant
sur setup. Vous devez charger DEUX fichiers zip -
<UL>
<LI> Fichier contenant le runtime <B>vim*rt.zip</B></LI>
<LI> Fichier de commande ViM <B>vim*56.zip</B> dont la version est la 5.6</LI>
</UL>
</P>
<P>Récupérez ces deux fichiers (voir 
<A HREF="#avant">avant</A>
)</P>
<P>Décompactez les fichiers zip en utilisant Winzip 
<A HREF="http://www.winzip.com">http://www.winzip.com</A>. Les deux fichiers zip (vim*rt.zip et
vim*56.zip) doivent être décompressés dans le même répertoire, disons
<B>c:\vim</B>.</P>
<P>Pour Windows 95/98, ajoutez la variable d'environnement VIM dans autoexec.bat
en ajoutant cette ligne -
<HR>
<PRE>
set VIM=c:\vim\vim56
</PRE>
<HR>
</P>
<P>Pour Windows NT, ajoutez la variable d'environnement dans le dialogue
<B>Control Panel | System | Environment | System Properties</B> :
<HR>
<PRE>
VIM=c:\vim\vim56
</PRE>
<HR>
</P>
<P>La variable VIM doit pointer là où vous avez installé le répertoire vim56.
Vous pouvez aussi ajouter l'emplacement de gvim.exe à votre PATH.</P>
<P>Il est probable que vous deviez vous déconnecter et vous réidentifier pour
avoir les bonnes variables. À l'invite MSDOS tapez -
<HR>
<PRE>
        set vim
</PRE>
<HR>
</P>
<P>Et vous devriez voir - VIM=c:\vim\vim56</P>
<P>Créez un raccourci sur votre bureau en copiant/collant de
c:\vim\vim56\gvim.exe. Copiez le fichier gvimrc_example vers $VIM\_gvimrc.
Dans mon cas, il s'agit de c:\vim\vim56\_gvimrc.</P>

<H2><A NAME="ss1.6">1.6 Installer ViM sous VMS</A>
</H2>


<H3>Charger les fichiers</H3>

<P>Vous aurez besoin des archives Unix et extra pour construire vim.exe pour VMS.
Pour utiliser toute la puissance de ViM vous aurez également besoin des
fichiers runtime. Prenez ces fichiers (voir 
<A HREF="#avant">avant</A>
).</P>
<P>Vous pouvez charger des exécutables précompilés sur 
<A HREF="http://www.polarfox.com/vim">http://www.polarfox.com/vim</A>.</P>
<P>Les auteurs de ViM VMS sont -
<UL>
<LI>
<A HREF="mailto: zoltan.arpadffy@essnet.se    "> zoltan.arpadffy@essnet.se  </A></LI>
<LI>
<A HREF="mailto: arpadffy@altavista.net    "> arpadffy@altavista.net  </A></LI>
<LI>
<A HREF="mailto:  cec@gryphon.gsfc.nasa.gov    ">  cec@gryphon.gsfc.nasa.gov  </A></LI>
<LI>
<A HREF="mailto: BNHunsaker@chq.byu.edu    "> BNHunsaker@chq.byu.edu  </A></LI>
<LI>
<A HREF="mailto: sandor.kopanyi@altavista.net    "> sandor.kopanyi@altavista.net  </A></LI>
</UL>
</P>

<H3>Compiler</H3>

<P>Décompactez les archives Unix et Extra dans un même répertoire. Dans le
sous-répertoire &lt;.SRC> vous devriez trouver le fichier make OS_VMS.MMS. En
éditant ce fichier vous pourrez choisir les versions des caractères, des
interfaces et du débogage. Il y a également des options additionnelles
concernant les supports pour Perl, Python et Tcl.</P>
<P>Vous aurez besoin soit de l'utilitaire DECSET mms ou du clone disponible
gratuitement appellé mmk (VMS n'a pas d'utilitaire make en distribution
standard). Vous pouvez récupérer mmk sur http://www.openvms.digital.com/freeware/MMK/</P>
<P>Si vous avez MMS sur votre système, la commande</P>
<P>>    mms /descrip=os_vms.mms</P>
<P>construira votre version personnalisée de ViM.
La commande équivalente pour mmk est :</P>
<P>>    mmk /descrip=os_vms.mms</P>

<H3>Déploiement</H3>

<P>ViM utilise une structure de répertoires spéciale pour les fichiers de
documentation et d'utilisation :</P>
<P>
<HR>
<PRE>
   vim (ou autre)
    |- tmp
    |- vim55
    |----- doc
    |----- syntax
    |- vim56
    |----- doc
    |----- syntax
    vimrc    (fichiers système rc)
    gvimrc
</PRE>
<HR>
</P>
<P>Utilisez :
<HR>
<PRE>
>       define/nolog device:[leading-path-here.vim]       vim
>       define/nolog device:[leading-path-here.vim.vim56] vimruntime
>       define/nolog device:[leading-path-here.tmp]       tmp
</PRE>
<HR>

pour que vim.exe puisse trouver ses fichiers de documents, ses types de
fichiers et de syntaxe, et pour spécifier un répertoire où les fichiers
temporaires seront placés. Copiez le sous-répertoire « runtime » de la
distribution vim dans vimruntime.</P>
<P>Note : les variables $VIMRUNTIME et $TMP sont optionnelles. Lisez en plus sur
:help runtime.</P>

<H3>Usage pratique</H3>

<P>Habituellement vous devrez faire tourner une seule version de ViM sur votre
système, il est donc suffisant de dédier un seul répertoire à ViM.
Copiez toute la structure des répertoires de runtime dans la position de
déploiement. Ajoutez les lignes suivantes à votre LOGIN.COM (dans le
répertoire SYS$LOGIN). Définissez la variable $VIM en tant que :</P>
<P>
<HR>
<PRE>
>       $ define VIM device: &lt;path>
</PRE>
<HR>
</P>
<P>Configurez quelques symboles :</P>
<P>
<HR>
<PRE>
>       $ ! vi lance ViM en mode caractère
>       $ vi*m  :== mcr device:&lt;path>VIM.EXE

>       $ !gvi lance ViM en mode GUI
>       $ gv*im :== spawn/nowait mcr device:&lt;path>VIM.EXE -g
</PRE>
<HR>
</P>
<P>Créez les fichiers .vimrc et .gvimrc dans votre répertoire personnel
(SYS$LOGIN).</P>
<P>La méthode la plus simple est de renommer les fichiers d'exemples. Vous pouvez
laisser le fichier de menu (MENU.VIM) et les fichiers vimrc et gvimrc dans le
répertoire original $VIM. Ce sera la configuration par défaut pour tous les
utilisateurs, mais ceux-ci pourront apporter leurs propres modifications à la
configuration via les fichiers .vimrc et .gvimrc de leur répertoire personnel.
Ceci devrait marcher sans problème.</P>
<P>Note : Rappellez-vous, les fichiers systèmes rc (défaut pour tous les
utilisateurs) n'ont pas de&nbsp;«&nbsp;.&nbsp;»&nbsp;final. Ainsi, les fichiers systèmes rc sont :</P>
<P>
<HR>
<PRE>
>       VIM$:vimrc
>       VIM$:gvimrc
>       VIM$:menu.vim
</PRE>
<HR>

et les fichiers utilisateurs personnalisés sont :
<HR>
<PRE>
>       sys$login:.vimrc
>       sys$login:.gvimrc
</PRE>
<HR>
</P>
<P>Vous pouvez vérifier que tout fonctionne et est à la bonne place avec la
commande&nbsp;:version.</P>
<P>
<HR>
<PRE>
Exemple de LOGIN.COM :

>       $ define/nolog VIM RF10:[UTIL.VIM]
>       $ vi*m  :== mcr VIM:VIM.EXE
>       $ gv*im :== spawn/nowait mcr VIM:VIM.EXE -g
>       $ set disp/create/node=192.168.5.223/trans=tcpip
</PRE>
<HR>
</P>
<P>Note : Cette configuration devrait être suffisante si vous travaillez sur un
serveur seul ou dans un environnement clusterisé, mais si vous désirez
utiliser ViM en tant qu'éditeur internoeuds, il suffit de définir le
«&nbsp;chemin&nbsp;» complet :</P>
<P>
<HR>
<PRE>
>       $ define VIM "&lt;server_name>[""user password""]::device:&lt;path>"
>       $ vi*m :== "mcr VIM:VIM.EXE"
</PRE>
<HR>
</P>
<P>par exemple :</P>
<P>
<HR>
<PRE>
>       $ define VIM "PLUTO::RF10:[UTIL.VIM]"
>       $ define VIM "PLUTO""ZAY mypass""::RF10:[UTIL.VIM]" ! si un pass est nécessaire
</PRE>
<HR>

Vous pouvez aussi utiliser la variable $VIMRUNTIME pour pointer sur la bonne
version de ViM si vous avez plusieurs versions installées en même temps. Si
$VIMRUNTIME n'est pas défini ViM prendra la valeur de la variable $VIM. Vous
pourrez trouver plus d'informations sur la variable $VIMRUNTIME en tapant
:help runtime en commande ViM.</P>

<H3>Questions sur le mode GUI</H3>

<P>VMS n'est pas un environnement X window natif, vous ne pouvez donc pas lancer
ViM en mode GUI « juste comme ça ». Mais ce n'est pas trop compliqué d'obtenir
un ViM fonctionnel.</P>
<P>
<HR>
<PRE>
1) Si vous travaillez sur la console X VMS.
   Lancez ViM avec la commande :

>       $ mc device:&lt;path>VIM.EXE -g

ou tapez :gui en commande à l'invite ViM. Pour plus d'infos tapez :help gui

2) Si vous travaillez sur un autre environnement X window comme Unix ou une
console VMS X distante. Configurez votre affichage sur cet hôte avec :

>       $ set disp/create/node=&lt;addresse IP>/trans=&lt;nom-transport>

et lancez ViM comme au point 1. Vous pourrez trouver plus d'aide dans la
documentation VMS ou tapez: help set disp à l'invite VMS.
   Exemples :

>       $ set disp/create/node=192.168.5.159             ! transport par défaut DECNet
>       $ set disp/create/node=192.168.5.159/trans=tcpip ! réseau TCP/IP
>       $ set disp/create/node=192.168.5.159/trans=local ! affichage sur le même noeud
</PRE>
<HR>
</P>
<P>Note : Vous ne devez en définir qu'un. Pour plus d'infos tapez $help set disp à
l'invite VMS.</P>

<H2><A NAME="ss1.7">1.7 Installer ViM sous OS/2</A>
</H2>

<P>Lisez les notes de version de ViM sur OS/2, voyez 
<A HREF="#avant">avant</A>
.</P>
<P>Pour le moment il n'y a pas de version PM native de la version GUI de ViM ; la
version OS/2 est une application en console. Néanmoins, il y a maintenant une
version Win32s-compatible GUI, qui devrait être utilisable par les
utilisateurs de Warp4 (qui supporte Win32s) dans une session Win-OS/2. Les
notes de ce fichier se réfèrent à la version console native.</P>
<P>Pour utiliser ViM, vous aurez besoin de l'environnement de lancement emx (au
moins la version 0.9b). Elle est généralement disponible en tant que (demandez le à
Archie) :
<HR>
<PRE>
    emxrt.zip     emx runtime package
</PRE>
<HR>
</P>

<H2><A NAME="ss1.8">1.8 Installer ViM sur Apple Macintosh</A>
</H2>

<P>Lisez les notes de version de ViM sur Mac, voyez 
<A HREF="#avant">avant</A>
.</P>
<P>L'auteur de ViM sur Mac (de l'ancienne version 3.0) est
<HR>
<PRE>
Eric Fischer
5759 N. Guilford Ave
Indianapolis IN 46220 USA
</PRE>
<HR>

Écrivez à
<A HREF="mailto: enf@pobox.com   "> enf@pobox.com  </A></P>
<P>Rapport de Bogue Mac.
Lorsque vous avez à rapporter tout changement spécifique au Mac, bogue ou
option, incluez l'adresse suivante dans le champ « To: » ou « Copy To: ».
<A HREF="mailto:  dany.stamant@sympatico.ca          ">  dany.stamant@sympatico.ca  </A></P>
<P>ViM compile sans ajout avec le projet CodeWarrior en utilisant CodeWarrior 9.
Si vous utilisez une version plus récente (CW Pro) vous devrez convertir le
projet avant toute chose.
Pour compiler ViM pour Macs 68k vous devrez ouvrir la ressource « size » dans
ResEdit et activer le bouton « High level events aware » pour avoir un
copier/coller fonctionnel.
Vous devrez augmenter la partition de mémoire à au moins 1024 koctets pour
éviter à ViM de se crasher faute de mémoire suffisante.</P>

<H2><A NAME="s2">2. Configurez les fichiers d'initialisation de ViM</A></H2>

<P>Pour permettre la coloration syntaxique, vous DEVEZ copier le fichier vimrc
dans votre répertoire personnel. Il ajoutera également le menu « Syntax » pour
la commande gvim. Vous pouvez cliquer sur le menu Syntax et sélectionner le
langage approprié, comme C++, Perl, Java, SQL, ESQL, etc.
<HR>
<PRE>
cd $HOME
cp /usr/doc/vim-common-5.7/gvimrc_example  ~/.gvimrc
cp /usr/doc/vim-common-5.7/vimrc_example  ~/.vimrc
</PRE>
<HR>

Les commentaires du .vimrc commencent avec les apostrophes (").
Vous pouvez personnaliser vim en éditant le fichier $HOME/.vimrc et en
rajoutant les lignes suivantes :
<HR>
<PRE>
set guifont=8x13bold
"set guifont=9x15bold
"set guifont=7x14bold
"set guifont=7x13bold
</PRE>
<HR>

Il est <B>extrêmement</B> recommandé que vous mettiez les compteurs
« tabstop » et « shiftwidth » à 4.
Le compteur « tabstop » est le nombre d'espaces que TAB ajoutera lorsque vous
éditerez sous vim. Le compteur « shiftwidth » est le nombre d'espaces qui
décaleront les lignes en tapant les commandes vi ">>" ou "&lt;&lt;". Référez vous
au tutorial de Vim 
<A HREF="#Tutoriel Vim">Tutoriel Vim</A>
 pour plus de détails.
Pour mettre en place tabstop et shiftwidth :
<HR>
<PRE>
set tabstop=4
set shiftwidth=4
set nowrapscan
set ignorecase
</PRE>
<HR>
</P>
<P>Pour voir la liste des fontes disponibles sous Linux/Unix voyez la commande
<B>xlsfonts</B>. Tapez -
<HR>
<PRE>
        bash$ xlsfonts | less
        bash$ xlsfonts | grep -i bold | grep x
        bash$ man xlsfonts
</PRE>
<HR>
</P>


<H2><A NAME="ss2.1">2.1 Paramètres du Xdefaults</A>
</H2>

<P>Vous pouvez configurer quelques-unes des propriétés de Vim dans le fichier
Xdefaults.</P>
<P><B> ATTENTION : </B><I>Ne mettez pas <B>Vim*geometry</B>, il coincerait
les menu gvim, utilisez plutôt <B>Vim.geometry</B> à la place.</I></P>
<P>Éditez votre $HOME/.Xdefaults et ajoutez les lignes suivantes :
<HR>
<PRE>
! GVim super couleurs.
Vim*useSchemes:         all
Vim*sgiMode:            true
Vim*useEnhancedFSB:     true
Vim.foreground:         Black
!Vim.background:        lightyellow2
Vim*background:         white
! N'utilisez PAS Vim*geometry, il coincerait les menu gvim,
! utilisez Vim.geometry. Un astérisque entre Vim et geometry n'est pas autorisé.
! Vim.geometry: widthxheight
Vim.geometry:           88x40
!Vim*font:              -misc-fixed-medium-r-normal--20-200-75-75-c-100-iso8859-15-*5
Vim*menuBackground: yellow
Vim*menuForeground: black
</PRE>
<HR>

Afin que ces changements soient pris en compte, tapez :
<HR>
<PRE>
        xrdb -merge $HOME/.Xdefaults
        man xrdb
</PRE>
<HR>
</P>
<P>Vous pouvez aussi éditer votre fichier &nbsp;/.gvimrc pour changer les couleurs de
fond :
<HR>
<PRE>
        gvim $HOME/.gvimrc
Les meilleures couleurs de fond sont jaune clair ou blanc.
        highlight Normal guibg=lightyellow
</PRE>
<HR>
</P>

<H2><A NAME="ss2.2">2.2 Fichier vimrc d'exemple</A>
</H2>

<P>Vous pouvez changer des paramètres comme la couleur, les fontes grasses ou
normales dans le fichier gvimrc. Il est <B>extrêmement</B> recommandé de
configurer la couleur de fond au jaune clair ou blanc. Les ergonomistes disent
que la meilleure couleur de fond est le jaune clair ou le blanc. Vous pouvez
changer la variable «&nbsp;guibg&nbsp;» comme suit :
<HR>
<PRE>
        highlight Normal guibg=lightyellow
</PRE>
<HR>
</P>
<P>Le fichier d'exemple de vim-5.5/runtime/vimrc_example est celui-ci :
<BLOCKQUOTE><CODE>
<PRE>
" Un exemple de fichier vimrc.
"
" Mainteneur :  Bram Moolenaar &lt;Bram@vim.org>
" Dernières modifications : 9 Sep 1999
"
" Pour l'utiliser, copiez le dans
"     pour Unix et OS/2 :  ~/.vimrc
"            pour Amiga :  s:.vimrc
" pour MS-DOS and Win32 :  $VIM\_vimrc

set nocompatible        " Utilise les défauts Vim (bien mieux !)
set bs=2                " autorise l'effacement de tout en mode insertion
set ai                  " toujours utiliser l'autoindentation
set backup              " Conserver un fichier de sauvegarde
set viminfo='20,\"50    " Lit/écrit un fichier .viminfo, ne sauve pas plus
                        " de 50 lignes de registres
set history=50          " Conserve 50 lignes d'historique des commandes
set ruler               " Montre toujours la position du curseur

" Pour l'interface Win32: retirez l'option 't' de 'guioptions': pas d'entrée menu tearoff
" let &amp;guioptions = substitute(&amp;guioptions, "t", "", "g")

" N'utilise pas le mode Ex, utilise Q pour le formatage
map Q gq

" p en mode Visuel remplace le texte sélectionné par le registre "".
vnoremap p &lt;Esc>:let current_reg = @"&lt;CR>gvdi&lt;C-R>=current_reg&lt;CR>&lt;Esc>

" Active la coloration syntaxique lorsque le terminal dispose de couleurs
" Active aussi la coloration de la dernière chaîne recherchée.
if &amp;t_Co > 2 || has("gui_running")
  syntax on
  set hlsearch
endif

" Ne lance la partie suivante que si le support des autocommandes a été inclus
" lors de la compilation
if has("autocmd")

 " Dans les fichiers textes, toujours limiter la longueur du texte à 78
 " caractères
 autocmd BufRead *.txt set tw=78

 augroup cprog
  " Supprime toutes les autocommandes cprog
  au!

  " Lors du début d'édition d'un fichier :
  "   Pour les fichiers C et C++ active le formatage des
  "   commentaires et l'indentation C
  "   Pour les autres fichiers, les désactive.
  "   Ne pas changer l'ordre, il est important que la ligne
  "   avec * arrive avant.
  autocmd FileType *      set formatoptions=tcql nocindent comments&amp;
  autocmd FileType c,cpp  set formatoptions=croql cindent comments=sr:/*,mb:*,el:*/,://
 augroup END

 augroup gzip
  " Supprime toutes les autocommandes gzip
  au!

  " Active l'édition des fichiers gzippés
  " Active le mode binaire avant de lire le fichier
  autocmd BufReadPre,FileReadPre        *.gz,*.bz2 set bin
  autocmd BufReadPost,FileReadPost      *.gz call GZIP_read("gunzip")
  autocmd BufReadPost,FileReadPost      *.bz2 call GZIP_read("bunzip2")
  autocmd BufWritePost,FileWritePost    *.gz call GZIP_write("gzip")
  autocmd BufWritePost,FileWritePost    *.bz2 call GZIP_write("bzip2")
  autocmd FileAppendPre                 *.gz call GZIP_appre("gunzip")
  autocmd FileAppendPre                 *.bz2 call GZIP_appre("bunzip2")
  autocmd FileAppendPost                *.gz call GZIP_write("gzip")
  autocmd FileAppendPost                *.bz2 call GZIP_write("bzip2")

  " Après la lecture du fichier compressé : décompresse le texte dans le
  " buffer avec "cmd"
  fun! GZIP_read(cmd)
    let ch_save = &amp;ch
    set ch=2
    execute "'[,']!" . a:cmd
    set nobin
    let &amp;ch = ch_save
    execute ":doautocmd BufReadPost " . expand("%:r")
  endfun

  " Après l'écriture du fichier compressé : compresse le fichier écrit avec "cmd"
  fun! GZIP_write(cmd)
    if rename(expand("&lt;afile>"), expand("&lt;afile>:r")) == 0
      execute "!" . a:cmd . " &lt;afile>:r"
    endif
  endfun

  " Avant l'ajout au fichier compressé : décompresser le fichier avec "cmd"
  fun! GZIP_appre(cmd)
    execute "!" . a:cmd . " &lt;afile>"
    call rename(expand("&lt;afile>:r"), expand("&lt;afile>"))
  endfun

 augroup END

 " Ce qui suit est désactivé, car il change la liste de sauts. On ne peut pas utiliser
 " CTRL-O pour revenir en arrière dans les fichiers précédents plus d'une fois.
 if 0
  " Lors de l'édition d'un fichier, saute toujours à la dernière position du curseur.
  " Ceci doit se trouver après les commandes de décompression.
   autocmd BufReadPost * if line("'\"") &amp;&amp; line("'\"") &lt;= line("$") | exe "normal `\"" | endif
 endif

endif " has("autocmd")
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H2><A NAME="ss2.3">2.3 Fichier gvimrc d'exemple</A>
</H2>

<P>L'exemple de gvimrc de vim-5.5/runtime/gvimrc_example ressemble à
celui-ci :
<HR>
<PRE>
" Un exemple de fichier gvimrc.
" Ces commandes sont exécutées lors du lancement de l'interface graphique.
"
" Mainteneur :  Bram Moolenaar &lt;Bram@vim.org>
" Dernières modifications : 2 Fév 1999
"
" Pour l'utiliser, copiez le dans
"      pour Unix et OS/2 :  ~/.gvimrc
"             pour Amiga :  s:.gvimrc
"  pour MS-DOS and Win32 :  $VIM\_gvimrc

" Passe les commandes externes par un tuyau au lieu d'un pseudo-tty
"set noguipty

" Active la fonte X11 à utiliser
" set guifont=-misc-fixed-medium-r-normal--14-130-75-75-c-70-iso8859-1

" Rend la ligne de commande de 2 lignes plus grande
set ch=2

" Permet le shift-insert fonctionnel comme dans les Xterm
map &lt;S-Insert> &lt;MiddleMouse>
map! &lt;S-Insert> &lt;MiddleMouse>

" Ne fait ceci que pour Vim de version 5.0 et ultérieures.
if version >= 500

  " J'aime avoir des chaînes éclairées dans les commentaires C
  let c_comment_strings=1

  " Active la coloration syntaxique.
  syntax on

  " Active la coloration de la chaîne recherchée.
  set hlsearch

  " Pour la version Win32, on a "K" qui cherche le keyword dans un fichier d'aide
  "if has("win32")
  "  let winhelpfile='windows.hlp'
  "  map K :execute "!start winhlp32 -k &lt;cword> " . winhelpfile &lt;CR>
  "endif

  " Cache le pointeur de souris lorsque l'on tape
  set mousehide

  " Utilise des couleurs sympathiques
  " Le fond pour le texte normal est en gris clair
  " Le texte sous la dernière ligne est en gris sombre
  " Le curseur est gris
  " Les constantes ne sont pas soulignées mais ont un fond légèrement plus clair
  highlight Normal guibg=grey90
  highlight Cursor guibg=Green guifg=NONE
  highlight NonText guibg=grey80
  highlight Constant gui=NONE guibg=grey95
  highlight Special gui=NONE guibg=grey95

endif
</PRE>
<HR>
</P>

<H2><A NAME="s3">3. Fichier d'initialisation de la coloration syntaxique</A></H2>


<H2><A NAME="ss3.1">3.1 Méthode automatique</A>
</H2>

<P>La section ci-dessous provient d'une session gvim en tapant « :help syntax » -
<HR>
<PRE>
bash$ gvim un_test
:help syntax
</PRE>
<HR>

Cliquez sur le menu Window=>Close_Others pour fermer les autres fenêtres.
Utilisez ensuite CTRL+] du menu «&nbsp;Procédures de chargement de syntaxe&nbsp;» qui
vous emmènera sur la bonne entrée. Utilisez CTRL+T pour revenir en arrière.</P>
<P>Si un type de fichier que vous désirez utiliser n'est pas encore détecté, il y
a deux moyens pour l'ajouter. Il vaut mieux ne pas modifier le fichier
<I>$VIMRUNTIME/filetype.vim</I>. Il sera réécrit lors de l'installation
d'une nouvelle version de ViM.
Crééz un fichier dans $HOME/vim/myfiletypes.vim et ajoutez lui ces lignes -
<HR>
<PRE>
" Nom du fichier : $HOME/vim/mestypesdefichiers.vim
" mestypesdefichiers
augroup filetype
        au! BufRead,BufNewFile *.mine   set filetype=mine
        au! BufRead,BufNewFile *.xyz    set filetype=drawing
        au! BufRead,BufNewFile *.prc    set filetype=plsql
augroup END
</PRE>
<HR>
</P>
<P>Ajoutez ensuite une ligne à vos fichiers $HOME/.vimrc et $HOME/.gvimrc pour
initialiser la variable «&nbsp;mestypesdefichiers&nbsp;» au nom de ce fichier.
(<B>ATTENTION : </B> Vous DEVEZ mettre ceci dans les deux fichiers vimrc et
gvimrc pour que ceci fonctionne. Exemple :
<HR>
<PRE>
&lt;code>
        let myfiletypefile = "~/vim/myfiletypes.vim"
</PRE>
<HR>
</P>
<P><B>NOTE : </B> Assurez vous que vous initialisez bien «&nbsp;mestypesdefichiers&nbsp;»
avant de passer à la détection du type de fichier. Ceci doit intervenir avant
toute commande « :filetype on » ou « :syntax on ».</P>
<P>Votre fichier sera alors parcouru après l'intallation des autocommandes de
type de fichier par défaut. Ceci vous permet de passer outre tous les
paramètres par défaut, en utilisant « :au! » pour supprimer les autocommandes de
type de fichier existant pour le même schéma. Seule l'autocommande pour
parcourir le fichier scripts.vim est donné plus tard. Ceci vous permettra de
vous assurer que les autocommandes dans « mestypesdefichiers » sont utilisées
avant de vérifier le contenu du fichier.</P>

<H2><A NAME="ss3.2">3.2 Méthode manuelle</A>
</H2>

<P>Au lieu d'utiliser un menu « Syntax » vous pouvez lire manuellement le fichier
de syntaxe. Éditez le fichier avec gvim et donnez la commande « so » à : (en mode
d'échappement). Par exemple :
<HR>
<PRE>
        gvim foo.pc
        :so $VIM/syntax/esqlc.vim
</PRE>
<HR>

Les fichiers de syntaxe sont dans /usr/share/vim/syntax/*.vim. Vim supporte
plus de 120 fichiers de syntaxe différents pour divers langages comme C++,
PERL, VHDL, JavaScript, etc., et énormément d'autres !</P>
<P>Chaque fichier de syntaxe supporte une ou plusieurs extensions de fichiers par
défaut, par exemple, le fichier de syntaxe JavaScript supporte l'extension
*.js. Si vous utilisez une extension qui crée un conflit avec un autre fichier
de syntaxe par défaut (comme ajouter du JavaScript à un fichier *.html) vous
pourrez alors charger le fichier de syntaxe additionnel avec la commande :so
$VIM/syntax/javascript.vim. Pour éviter d'avoir à le taper, vous pouvez créer
un lien symbolique par :
<HR>
<PRE>
        ln -s $VIM/syntax/javascript.vim js
        gvim foo.html  (... this file contains javascript functions and HTML)
        :so js
</PRE>
<HR>
</P>


<H2><A NAME="s4">4. Usage de ViM</A></H2>

<P>Vous pouvez utiliser ViM sous deux modes, l'un avec interface graphique et
l'autre sans. Pour utiliser l'interface graphique utilisez la commande :
<HR>
<PRE>
        gvim foo.cpp
</PRE>
<HR>

Pour utiliser le mode non-graphique utilisez :
<HR>
<PRE>
        vim foo.cpp
ou le mode ancien
        vi foo.cpp
</PRE>
<HR>
</P>
<P>Il est très recommandé que vous utilisiez toujours gvim à la place de vim, car
le mode GUI avec les couleurs augmentera réellement votre productivité.</P>
<P>Le mode GUI gvim permet ce qui suit :
<UL>
<LI> vous pouvez marquer le texte en utilisant la souris pour faire des
copier/couper/coller ;</LI>
<LI> vous pouvez utiliser la barre de menu qui a les boutons File, Edit,
Window, Tools, Syntax et Help ;</LI>
<LI> également dans un futur proche dans gvim - une seconde barre de menu
affichera la liste des fichiers en cours d'édition, et vous pourrez changer
entre les fichiers en cliquant sur leur nom, à moins que vous n'utilisiez les
commandes vi - :e#, :e#1, :e#2, :e#3, :e#4, etc. pour sélectionner les
fichiers.</LI>
</UL>
</P>

<H2><A NAME="s5">5. Compagnons Vi</A></H2>

<P>En général ViM est utilisé en conjonction avec d'autres outils puissants comme
<B>ctags</B> et <B>gdb</B>. <B>ctags</B> est très rapide pour la
navigation au milieu de millions de lignes de code « C/C++ » et <B>gdb</B> est
pour le déboguage de code « C/C++ ».
Une brève introduction à ces deux commandes indispensables sera donnée dans ce
chapitre.</P>
<P><B>ctags</B> est la commande la plus puissante pour coder en C, C++, Java,
Perl, scripts shell Korn/Bourne ou Fortran. Les développeurs utilisent
intensivement <B>ctags</B> pour naviguer au travers de milliers de
fonctions à l'intérieur de programmes C/C++. Voyez `man ctags' sous Unix.
Il est <B>très important</B> que vous appreniez comment utiliser ctags pour
développer des programmes en C, C++, Java, etc. La navigation est la tâche
simple la plus importante lors de développement en C ou C++. L'utilisation de
ctags peut vous aider à rapidement lire le code en sautant de la ligne d'appel
à la fonction appellée, en s'enfonçant dans les appels de fonctions imbriquées,
et en remontant de la fonction la plus imbriquée jusqu'à la fonction
principale.
Vous pouvez aller et revenir de fonction en fonction très rapidement.</P>
<P>Sans NAVIGATION vous serez complètement perdu ! <B>ctags</B> est comme le
COMPAS magnétique nécessaire aux programmeurs.</P>
<P>Utilisation de <B>ctags</B> :
<HR>
<PRE>
        ctags *.cpp
        gvim -t foo_function
        gvim -t main
</PRE>
<HR>

Ceci éditera le fichier programme C++ qui contient la fonction foo_function()
et placera directement le curseur sur la première ligne de la fonction
foo_function(). La deuxième commande vous placera sur la ligne contenant la
définition de la fonction main().</P>
<P>À l'intérieur de l'éditeur ViM, vous pouvez sauter à une fonction en tapant :
(double point) tag nom_de_la_fonction comme ci dessous :
<HR>
<PRE>
        :tag fonction_exemple
</PRE>
<HR>

Ceci placera le curseur sur la première ligne de fonction_exemple().</P>
<P>Si vous voulez sauter dans la fonction à partir de la ligne du fichier
contenant le nom de la fonction, placez le curseur juste avant le nom de la
fonction et tapez <B>CTRL+]</B> (tapez la touche de contrôle et le crochet
gauche simultanément).
<HR>
<PRE>
                // code d'exemple
                switch(id_number) {
                        Case 1:
                                if ( foo_function( 22, "abcef") == 3 )
                                    ^
                                    |
                                    |
                                    |
                  Placez le curseur ici (juste avant foo_function) et tapez CTRL+]
                  Ceci vous emmènera à la fonction nommée "foo_function".
                  Pour revenir à cette ligne tapez CTRL+t
</PRE>
<HR>

Pour revenir à la ligne d'appel tapez <B>CTRL+t</B> (la touche de contrôle
et la lettre 't' simultanément). Continuez à appuyer sur <B>CTRL+t</B> pour
inverser et revenir à la première ligne où vous avez commencé la navigation.
C'est-à-dire que vous pouvez conserver pressées <B>CTRL+]</B> et ensuite taper
<B>CTRL+t</B> pour revenir. Vous pouvez refaire ceci aussi souvent que vous
le désirez pour avoir une navigation complète au travers de toutes les
fonctions C ou C++.</P>

<H2><A NAME="ss5.1">5.1 Ctags pour ESQL</A>
</H2>

<P>Puisque ctags ne supporte pas directement le langage  Embedded SQL/C (ESQL),
le script shell suivant peut être utilisé pour créer les marques pour esql.
ESQL/C est un ensemble de commandes SQL de base de donnée à l'intérieur de
programmes « C ».
Le ESQL/C d'Oracle est appellé Pro*C et Sybase, Informix ont ESQL/C et
PostgreSQL a produit « ecpg ».</P>

<P>Sauvez ce fichier sous « sqltags.sh » et tapez chmod a+rx tags_gen.sh.
<HR>
<PRE>
#!/bin/sh

# Programme pour créer les ctags pour les fichiers ESQL, C++ et C
ESQL_EXTN=pc
tag_file1=tags_file.1
tag_file2=tags_file.2

which_tag=ctags

rm -f $tag_file1 $tag_file2 tags

aa=`ls *.$ESQL_EXTN`
#echo $aa
for ii in $aa
do
        #echo $ii
        jj=`echo $ii | cut -d'.' -f1`
        #echo $jj

        if [ ! -f $jj.cpp ]; then
                echo " "
                echo " "
                echo "*******************************************************"
                echo "Les fichiers ESQL *.cpp files n'existent pas..."
                echo "Vous devez générer les fichiers *.cpp à partir des *.pc"
                echo "en utilisant le pré-compilateur Oracle Pro*C ou Sybase"
                echo "ou le pré-compilateur Informix esql/c."
                echo "Puis relancez cette commande"
                echo "*******************************************************"
                echo " "
                exit
        fi

        rm -f tags
        $which_tag $jj.cpp
        kk=s/$jj\.cpp/$jj\.pc/g

        #echo $kk > sed.tmp
        #sed -f sed.tmp tags >> $tag_file1

        #sed -e's/sample\.cpp/sample\.pc/g' tags >> $tag_file1
        sed -e $kk tags >> $tag_file1
done

# S'occupe des fichiers C++/C - exclut les fichiers ESQL *.cpp
rm -f tags $tag_file2
bb=`ls *.cpp *.c`
aa=`ls *.$ESQL_EXTN`
for mm in $bb
do
        ee=`echo $mm | cut -d'.' -f1`
        file_type="NOT_ESQL"
        # Exclut les fichiers ESQL *.cpp et *.c
        for nn in $aa
        do
                dd=`echo $nn | cut -d'.' -f1`
                if [ "$dd" = "$ee" ]; then
                        file_type="ESQL"
                        break
                fi
        done

        if [ "$file_type" = "ESQL" ]; then
                continue
        fi

        rm -f tags
        $which_tag $mm
        cat tags >> $tag_file2
done

mv -f $tag_file2 tags
cat  $tag_file1 >> tags
rm -f $tag_file1

# Doit sortir le fichier des marqueurs pour fonctionner correctement...
sort tags > $tag_file1
mv $tag_file1 tags
</PRE>
<HR>
</P>

<H2><A NAME="ss5.2">5.2 Ctags pour les programmes JavaScript, les scripts shell Korn, Bourne</A>
</H2>

<P>Le script shell donné ci-dessous peut être utilisé pour générer les marques
pour une très large variété de programmes écrits en JavaScript, les scripts
PHP/FI, Korn, C, Bourne et beaucoup d'autres. C'est un module très générique.</P>
<P>Sauvez ce fichier sous tags_gen.sh et tapez chmod a+rx tags_gen.sh.
<HR>
<PRE>
#!/bin/sh

tmp_tag=tags_file
tmp_tag2=tags_file2

echo " "
echo " "
echo " "
echo " "
echo " "
echo "Génère les marqueurs pour..."
while :
do
        echo "Entrer l'extension du fichier pour lequel vous voulez générer des marqueurs."
        echo -n "Les extensions de fichiers peuvent être sh, js, ksh, etc... : "
        read ans

        if [ "$ans" == "" ]; then
                echo " "
                echo "Mauvaise entrée. Essayez encore !"
        else
                break
        fi
done

rm -f $tmp_tag

aa=`ls *.$ans`

for ii in $aa
do
        jj=`echo $ii | cut -d'.' -f1`
        #echo $jj
        cp $ii $jj.c
        ctags $jj.c
        echo "s/$jj.c/$ii/g" > $tmp_tag2
        sed -f $tmp_tag2 tags >> $tmp_tag
        \rm -f tags $jj.c
done

sort $tmp_tag > tags

rm -f $tmp_tag $tmp_tag2
</PRE>
<HR>
</P>

<H2><A NAME="ss5.3">5.3 Déboguer avec gdb</A>
</H2>

<P>Vous utiliserez gdb extensivement avec Vi. Le déboguage est l'un des plus
importants aspects de la programmation en tant que coût majeur du
développement et des tests des projets.</P>
<P>Pour déboguer des programmes C/C++ vous utiliserez l'outil « gdb ». Voyez
<B>'man gdb'</B>. Vous devrez compiler vos programmes avec l'option -g3
comme
<BLOCKQUOTE><CODE>
<PRE>
        gcc -g3 foo.c foo_another.c sample.c
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Pour configurer des alias utiles :
<BLOCKQUOTE><CODE>
<PRE>
  Configurez l'alias dans votre ~/.bash_profile
        alias gdb='gdb -directory=/home/src -directory=/usr/monnom/src '
  Donnera -
        gdb foo.cpp
        gdb> dir /hom2/another_src
        Ceci ajoutera un chemin à la recherche de fichier
        gdb> break 'some_class::func&lt;TAB>&lt;TAB>
  Ce qui complètera le nom de la fonction en vous évitant le temps de
frappe... et sortira comme -
        gdb> break 'some_class::function_foo_some_where(int aa, float bb)'
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Taper la touche TAB deux fois permet le complément de la ligne de commande,
sauvant ainsi beaucoup de temps de frappe. C'est l'une des techniques les plus
importantes pour l'utilisation de gdb.</P>
<P>Pour obtenir de l'aide en ligne -
<BLOCKQUOTE><CODE>
<PRE>
        gdb> help
  Donne l'aide en ligne
        gdb> help breakpoints
  Donne plus de détails sur les points d'ancrage.
</PRE>
</CODE></BLOCKQUOTE>

Pour placer les points d'ancrage et effectuer du déboguage
<BLOCKQUOTE><CODE>
<PRE>
        unixprompt> gdb exe_filename
        gdb> b main
  Ceci mettra un point d'ancrage dans la fonction main()
        gdb> b 123
  Ceci mettra un point d'ancrage à la ligne 123 du fichier courant
        gdb> help breakpoints
    Donne plus de détails sur les points d'ancrage.
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Pour analyser des core dumps :
<BLOCKQUOTE><CODE>
<PRE>
        unixprompt> gdb exe_filename  core
        gdb> bt
Donne une trace de retour des fonctions et les numéros de lignes où le
programme a échoué
        gdb> help backtrace
  Donne plus de détails sur la trace de retour.
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Vous pouvez aussi utiliser une version GUI de gdb appellée xxgdb.</P>
<P>Outils de perte de mémoire -
<UL>
<LI> Freeware Electric Fence sous linux cd</LI>
<LI> Commercial tools Purify 
<A HREF="http://www.rational.com">http://www.rational.com</A></LI>
<LI> Insure++ 
<A HREF="http://www.insure.com">http://www.insure.com</A></LI>
</UL>
</P>

<H2><A NAME="s6">6. Aide de ViM en ligne</A></H2>

<P>Voyez les pages de manuel en ligne. Au prompt unix, tapez
<B>'man vim'</B> et <B>'man gvim'</B>.</P>
<P>Ou lors d'une session gvim tapez :help pour obtenir la page d'aide. Voyez
aussi le 
<A HREF="#Tutoriel Vim">Tutoriel Vim</A>
</P>

<H2><A NAME="s7">7. Pages web de ViM et liens ViM</A></H2>

<P>La page principale de ViM se trouve sur 
<A HREF="http://www.vim.org">http://www.vim.org</A>, et son
site miroir aux US est sur 
<A HREF="http://www.us.vim.org">http://www.us.vim.org</A>.</P>
<P>La FAQ ViM est sur 
<A HREF="http://www.grafnetix.com/~laurent/vim/faq.html">http://www.grafnetix.com/~laurent/vim/faq.html</A>
et sur 
<A HREF="http://www.vim.org/faq">http://www.vim.org/faq</A>.</P>
<P>La page ViM d'Eli se trouve sur 
<A HREF="http://www.netusa.net/~eli/src/vim.html">http://www.netusa.net/~eli/src/vim.html</A>.</P>
<P>La page des amoureux de Vi sur 
<A HREF="http://www.cs.vu.nl/~tmgil/vi.html">http://www.cs.vu.nl/~tmgil/vi.html</A>.</P>
<P>Le guide de référence sur ViM sur 
<A HREF="http://scisun.sci.ccny.cuny.edu/~olrcc/vim/">http://scisun.sci.ccny.cuny.edu/~olrcc/vim/</A>.</P>
<P>Les listes de diffusion ViM sont sur 
<A HREF="http://www.findmail.com/listsaver/vimannounce.html">http://www.findmail.com/listsaver/vimannounce.html</A> et 
<A HREF="http://www.vim.org/mail.html">http://www.vim.org/mail.html</A>.</P>
<P>Les archives des listes sont conservées sur :
<UL>
<LI> 
<A HREF="http://www.egroups.com/group/vim">http://www.egroups.com/group/vim</A></LI>
<LI> 
<A HREF="http://www.egroups.com/group/vimdev">http://www.egroups.com/group/vimdev</A></LI>
<LI> 
<A HREF="http://www.egroups.com/group/vimannounce">http://www.egroups.com/group/vimannounce</A></LI>
</UL>
</P>
<P>Les macros ViM sont sur 
<A HREF="http://www.grafnetix.com/~laurent/vim/macros.html">http://www.grafnetix.com/~laurent/vim/macros.html</A>.</P>

<H2><A NAME="Tutoriel Vim"></A> <A NAME="s8">8. Tutoriel ViM </A></H2>

<H2><A NAME="vimhandson"></A> <A NAME="ss8.1">8.1 Tutoriels ViM sous la main </A>
</H2>

<P>Sur les systèmes Linux, on trouve souvent le tutoriel dans
/usr/doc/vim-common-5.*/tutor, sur les autres systèmes Unix cherchez le
répertoire où ViM est installé et cherchez le répertoire doc.
<HR>
<PRE>
        bash$ cd /usr/doc/vim-common*/tutor
        bash$ less README.txt
        bash$ cp tutor $HOME
        bash$ cd $HOME
        bash$ less tutor
</PRE>
<HR>
</P>

<H2><A NAME="vimurls"></A> <A NAME="ss8.2">8.2 Tutoriels Vi sur Internet</A>
</H2>

<P>
<UL>
<LI> Purdue University 
<A HREF="http://ecn.www.ecn.purdue.edu/ECN/Documents/VI/">http://ecn.www.ecn.purdue.edu/ECN/Documents/VI/</A></LI>
<LI> Quick Vi tutorial 
<A HREF="http://linuxwww.db.erau.edu/LUG/node165.html">http://linuxwww.db.erau.edu/LUG/node165.html</A></LI>
<LI> Advanced Vi tutorial 
<A HREF="http://www.yggdrasil.com/bible/bible-src/user-alpha-4/guide/node171.html">http://www.yggdrasil.com/bible/bible-src/user-alpha-4/guide/node171.html</A></LI>
<LI> Tutorials 
<A HREF="http://www.cfm.brown.edu/Unixhelp/vi_.html">http://www.cfm.brown.edu/Unixhelp/vi_.html</A></LI>
<LI> Tutorials 
<A HREF="http://www.linuxbox.com/~taylor/4ltrwrd/section3_4.html">http://www.linuxbox.com/~taylor/4ltrwrd/section3_4.html</A></LI>
<LI> Unix world online vi tutorial 
<A HREF="http://www.networkcomputing.com/unixworld/unixhome.html">http://www.networkcomputing.com/unixworld/unixhome.html</A></LI>
<LI> Univ of Hawaii tutorial 
<A HREF="http://www.eng.hawaii.edu/Tutor/vi.html">http://www.eng.hawaii.edu/Tutor/vi.html</A></LI>
<LI> InfoBound  
<A HREF="http://www.infobound.com/vi.html">http://www.infobound.com/vi.html</A></LI>
<LI> Cornell Univ 
<A HREF="http://www.tc.cornell.edu/Edu/Tutor/Basics/vi/">http://www.tc.cornell.edu/Edu/Tutor/Basics/vi/</A></LI>
<LI> Vi Lovers home page 
<A HREF="http://www.cs.vu.nl/~tmgil/vi.html">http://www.cs.vu.nl/~tmgil/vi.html</A></LI>
<LI> Après Sept 2000, sera sur 
<A HREF="http://www.thomer.com/thomer/vi/vi.html">http://www.thomer.com/thomer/vi/vi.html</A></LI>
<LI> Beginner's Guide to vi 
<A HREF="http://www.cs.umr.edu/unixinfo/general/packages/viguide.html">http://www.cs.umr.edu/unixinfo/general/packages/viguide.html</A></LI>
<LI> vi Help file 
<A HREF="http://www.vmunix.com/~gabor/vi.html">http://www.vmunix.com/~gabor/vi.html</A></LI>
<LI> ViM FAQ 
<A HREF="http://www.math.fu-berlin.de/~guckes/vim/faq/">http://www.math.fu-berlin.de/~guckes/vim/faq/</A></LI>
</UL>
</P>
<P>Il y a de nombreux tutoriels Vi sur Internet. Sur Yahoo (Lycos, excite ou
Hotbot), entrer « Vi Tutorial » dans le champ de recherche vous renverra de
nombreux pointeurs.</P>

<H2><A NAME="vimtut"></A> <A NAME="s9">9. Tutoriel Vi </A></H2>

<P>Dans ce tutoriel, nous décrirons quelques commandes et concepts <B>vi</B>
avancés, vous pourrez ainsi apprécier la puissance de <B>vi</B> et décider
de construire vos connaissances avec les commandes <B>vi</B>. Quasiment
toutes les références listent les commandes disponibles, mais beaucoup ne
montrent pas comment ces commandes interagissent ; ce point précis est le thème
principal de ce tutoriel.</P>

<H2><A NAME="ss9.1">9.1 Commandes du mouvement du curseur</A>
</H2>

<P>Les commandes du mouvement du curseur de <B>vi</B> vous permettent de
positionner le curseur dans le fichier et/ou à l'écran de manière efficace,
avec un nombre minimal de frappe de touches. Il y a de nombreuses commandes
contrôlant les mouvements du curseur - n'essayez pas de toute les mémoriser en
une fois ! Plus tard, nous verrons que la majeure partie de la puissance de
<B>vi</B> vient du mélange entre les commandes de mouvement du curseur et
les autres commandes pour effacer, changer, copier, et filtrer le texte.</P>
<P>Veuillez éditer un gros fichier texte (disons, <B>wknight</B>) afin
d'expérimenter chaque commande décrite. Gardez en tête que ces commandes ne
marchent qu'en Mode Commande, et pas en Mode Insertion ; si vous voyez vos
« commandes » dans votre texte, appuyez sur ESC pour retourner en Mode Commande.</P>
<P>
<UL>
<LI> <B>touches fléchées</B> : Ainsi que nous l'avons vu, les touches
curseur permettent de se déplacer avec un simple caractère vers la gauche, le
bas, le haut et la droite. Les mouvements au-delà du haut du fichier, en
dessous du bas, à droite de la fin de la ligne, ou à gauche du début ne sont
pas autorisés (pas de coupure de ligne).


</LI>
<LI> <B>hjkl</B> : Lorsque <B>vi</B> a été écrit (vers 1978), de
nombreux terminaux sur systèmes UNIX n'avaient pas de touches fléchées !
<B>h, j, k,</B> et <B>l</B> ont été choisies comme commandes pour se
déplacer vers la gauche, le bas, le haut, et la droite, respectivement.
Essayez les ! La plupart des intégristes de <B>vi</B> les préfèrent aux
touches fléchées car :
<UL>
<LI><B>(a)</B> elles sont à la même place sur tous les claviers, et</LI>
<LI><B>(b)</B> elles se placent agréablement sous les doigts, au contraire
de la plupart des touches fléchées, qui sont arrangées en boîte ou en « T » ou
sous une autre forme non linéaire.</LI>
</UL>


Pourquoi h, j, k, et l ? Eh bien, dans le code des caractères ascii, CTRL-H
est l'effacement (déplacement vers la gauche), CTRL-J le retour chariot
(déplacement vers le bas), et bien entendu, k et l sont proches de h et j, et
comme vous le voyez, ces touches forment une combinaison mnémonique.


</LI>
<LI> <B>0</B> : (« zéro », et pas « oh ») Déplacement au début de la ligne
courante. (Pour essayer ceci et les quelques commandes suivantes, utilisez les
touches du curseur ou <B>h j k l</B> pour vous déplacer vers une ligne
indentée contenant quelques caractères « e ». Si vous ne pouvez trouver de ligne
indentée dans votre fichier, créez en une en insérant quelques espaces au
début de la ligne.)


</LI>
<LI> <B> ^ </B> : Déplacement sur le premier caractère non-blanc de la
ligne courante (pour une ligne indentée, 0 et ^ ont des significations
différentes).


</LI>
<LI> <B> $ </B> : Déplacement sur le dernier caractère de la ligne
courante.


</LI>
<LI> <B> tC </B> : Déplacement jusqu'au (mais pas sur) le prochain
caractère C de la ligne courante (tapez 0, puis tapez te. Ceci vous déplacera
vers le premier e de la ligne courante).


</LI>
<LI> <B> fC </B> : Trouve (déplacement sur) le prochain caractère C de la
ligne courante (tapez fe, et le curseur trouvera - c'est-à-dire se mettra sur
- le prochain e de la ligne courante).


</LI>
<LI> <B> TC </B> : Déplacement jusqu'au (mais pas sur) le précédent
caractère C de la ligne courante (tapez $, puis Te).


</LI>
<LI> <B> FC </B> : Trouve (déplacement sur) le précédent caractère C de la
ligne courante (tapez Fe).


</LI>
<LI> <B> n| </B> : Déplacement sur la colonne n de la ligne courante
(tapez 20 | ; les chiffres 2 et 0 ne seront pas affichés lorsque vous les
taperez, mais lorsque vous presserez | le curseur se déplacera en colonne 20).

Essayez quelquez trucs avec t f T F | . Lorsque vous faîtes quelque chose
d'illégal, <B>vi</B> émettra un bip.


</LI>
<LI> <B> w </B> : Déplacement au début du prochain « petit » mot (un « petit »
mot consiste en une suite ininterrompue de caractères alphanumétiques ou de
caractères de ponctuation, mais pas un mélange de caractères de ponctuation et
alphanumériques). Essayez de taper w une douzaine de fois -- notez ce qui
arrive aux ponctuations.


</LI>
<LI> <B> W </B> : Déplacement au début du prochain « grand » mot (mélange
alphanumérique et ponctuation). Essayez de taper W une douzaine de fois.


</LI>
<LI> <B> b </B> : Retour au début d'un « petit » mot.


</LI>
<LI> <B> B </B> : Retour au début d'un « grand » mot.


</LI>
<LI> <B> e </B> : Déplacement à la fin d'un « petit » mot.


</LI>
<LI> <B> E </B> : Déplacement à la fin d'un « grand » mot.


</LI>
<LI> <B> + Return </B> : Déplacement sur le premier caractère non-blanc
sur la même ligne (+ et la touche Entrée ont le même effet).


</LI>
<LI> <B> - </B> : Déplacement sur le premier caractère non-blanc de la
ligne précédente.


</LI>
<LI> <B> ) </B> : Déplacement sur la fin d'une phrase (une phrase se
termine soit par une ligne blanche, ou un point ou une marque d'exclamation
suivis par deux caractères d'espace ou la fin de la ligne. Un point ou une
marque d'exclamation suivis par un seul caractère d'espace ne termine pas une
phrase ; ceci est un comportement correct, en accord avec les règles
traditionnelles de la manière dont les phrases doivent apparaître dans les
documents imprimés, mais apparaît souvent comme faux pour ceux qui n'ont
jamais utilisé une classe typographique correcte.)

NdT : Ceci n'est valable qu'en typographie anglaise.  En typographie
française, une phrase se termine par un point (ou une marque d'exclamation)
suivit par une espace.


</LI>
<LI> <B> ( </B> : Déplacement au début d'une phrase.


</LI>
<LI> <B> } </B> : Déplacement à la fin d'un paragraphe (les paragraphes
sont séparés par des lignes blanches, par définition avec <B>vi</B>).


</LI>
<LI> <B> { </B> : Déplacement au début d'un paragraphe.


</LI>
<LI> <B> H </B> : Déplacement vers la position première (la ligne du haut)
de l'écran.


</LI>
<LI> <B> M </B> : Déplacement au milieu de la ligne à l'écran.


</LI>
<LI> <B> L </B> : Déplacement sur la dernière ligne de l'écran.


</LI>
<LI> <B> nG </B> : Déplacement sur la ligne n. Si n n'est pas donné,
déplacement sur la dernière ligne du fichier (essayez 15G pour vous déplacer
sur la ligne 15, par exemple. La commande CTRL-G affiche le nom du fichier,
quelques informations sur l'état, et le numéro de la ligne actuelle. Pour vous
déplacer au début du fichier : 1G).


</LI>
<LI> <B> CTRL-d </B> : Déplacement vers le bas d'un demi-écran (voir note).</LI>
<LI> <B> CTRL-u </B> : Déplacement vers le haut d'un demi-écran (voir note).</LI>
<LI> <B> CTRL-f </B> : Déplacement vers le bas d'un écran (voir note).</LI>
<LI> <B> CTRL-b </B> : Déplacement vers le haut d'un écran (voir note).</LI>
<LI> <B> Note </B> : Ces quatres commandes de déplacement ne peuvent être
utilisées avec les commandes d'effacement, de changement, de copie ou de
filtre.


</LI>
<LI> <B> /reg_exp </B> : Déplacement sur la prochaine occurence de
l'expression rationnelle reg_exp.
Lorsque vous tapez /, le curseur se déplace vers le coin en bas à gauche de
l'écran et attend que vous tapiez l'expression rationnelle.
Tapez la touche Entrée pour finir ; <B>vi</B> cherchera alors dans la suite
du fichier la prochaine occurence de l'expression rationnelle. Par exemple,
tapez /the puis Entrée. Ceci vous déplacera sur la prochaine apparition de
the, peut-être mise en évidence au milieu d'un mot plus long (other, weather,
etc.). Si vous tapez juste / puis Entrée, <B>vi</B> cherchera la prochaine
apparition de la dernière expression rationnelle que vous aviez cherché.


</LI>
<LI> <B> n </B> : A le même effet que de presser / et Entrée ; c-à-d
recherche la prochaine occurence de la dernière expression rationnelle que
vous aviez cherché.


</LI>
<LI> <B> ?reg_exp </B> : Recherche en arrière, et pas en avant. Si la
reg_exp n'est pas donnée, recherche la dernière expression rationnelle entrée.
Les 2 / et ? sont tournants, donc rechercher « plus bas » que le bas ou « plus
haut » que le haut du fichier est légal.


</LI>
<LI> <B> N </B> : Identique à&nbsp;? et Entrée.</LI>
</UL>
</P>

<H2><A NAME="ss9.2">9.2 Compteurs de répétitions</A>
</H2>

<P>La plupart des commandes de mouvements présentées ci-dessus peuvent être
précédées d'un compteur de répétitions ; le mouvement est simplement répété le
nombre de fois donné :</P>
<P>
<UL>
<LI> <B> 3w </B> : Déplacement en avant de 3 mots.</LI>
<LI> <B> 5k </B> : Déplacement vers le haut de 4 caractères.</LI>
<LI> <B> 3fa </B> : Trouve le 3ème « a » successif de la ligne courante.</LI>
<LI> <B> 6+ </B> : Descend de 6 lignes.</LI>
</UL>

Pour certaines commandes, les « compteurs de répétitions » ont des
significations spéciales :
<UL>
<LI> <B> 4H </B> : Déplacement vers la ligne 4 de l'écran (touche home et 3).</LI>
<LI> <B> 8L </B> : Déplacement sur la 8ème ligne à partir du bas de l'écran.</LI>
<LI> <B> 3$ </B> : Déplacement à la fin de la 3ème ligne plus bas.</LI>
</UL>

Pour plusieurs commandes (telles que ^) le compteur de répétition est ignoré ;
pour d'autres (par exemple, / et ?) il est illégal.</P>

<H2><A NAME="ss9.3">9.3 Effacer du texte</A>
</H2>

<P>Nous avons vu que <B>dd</B> efface la ligne courante. Ceci peut être utilisé
avec un compteur de répétitions : 3dd efface trois lignes, la ligne courante et
les 2 lignes suivantes.</P>
<P>La commande d peut être utilisée comme un « préfixe » pour la plupart des
commandes de mouvement ci-dessus pour effacer à peu près toute sorte de
parties de texte. Lorsqu'elles sont utilisées avec d, les commandes de
mouvements sont appellées des spécificateurs de cibles. On peut donner un
compteur de répétition à d (lorsque vous essayez ces expériences, rappellez
vous d'appuyer sur u après chaque commande pour annuler l'effacement).</P>
<P>
<UL>
<LI> <B> dw </B> : Efface le prochain « petit » mot.</LI>
<LI> <B> d3w </B> : Efface les 3 prochains « petits » mots.</LI>
<LI> <B> 3dw </B> : Trois fois, efface le prochain « petit » mot.</LI>
<LI> <B> 3d3w </B> : Trois fois, efface les 3 prochains « petits » mots
(c'est-à-dire, efface les 9 prochains « petits » mots).</LI>
<LI> <B> d+ </B> : Efface la ligne actuelle et la ligne suivante.</LI>
<LI> <B> d/the </B>: Efface à partir du caractère courant jusqu'à, mais
sans inclure, la prochaine apparition de «&nbsp;the&nbsp;».</LI>
<LI> <B> d$ </B> : Efface jusqu'à la fin de la ligne.</LI>
<LI> <B> d0 </B> : Efface jusqu'au début de la ligne.</LI>
<LI> <B> d30G </B> : Efface la ligne courante jusqu'à et incluant la ligne 30.</LI>
<LI> <B> dG </B> : Efface la ligne courante jusqu'à et incluant la
dernière ligne.</LI>
<LI> <B> d1G </B> : Efface la ligne courante jusqu'à et incluant la ligne 1.</LI>
</UL>

Pour effacer de simples caractères, utilisez x. x peut être utilisé en
utilisant un compteur répétitif :
<UL>
<LI> <B> 15x </B> : Efface le caractère courant et les 14 suivants.</LI>
</UL>

x est simplement une abbréviation de d1 ; c'est-à-dire efface un caractère à
droite.</P>

<H2><A NAME="ss9.4">9.4 Changer le texte</A>
</H2>

<P>La commande c est similaire à d, à part qu'elle change le mode de <B>vi</B> en
insertion, autorisant le texte original (non désiré) à être changé en quelque
chose d'autre.</P>
<P>Par exemple, placez le curseur sur le début d'un mot (tapez w pour arriver au
début du prochain mot). Ensuite, tapez cw pour changer ce mot. À l'écran, le
dernier caractère de ce mot en cours de changement sera remplacé par un
symbole <B>$</B> indiquant la fin du changement ; tapez un nouveau mot (vous
réécrirez le mot original à l'écran) et tapez la touche ESC lorsque vous aurez
fini. Votre entrée peut être plus longue ou plus courte que le mot en cours de
changement.</P>
<P>Placez le curseur au début d'une ligne contenant au moins trois mots, et taper
c3w pour changer ces trois mots. Essayez c$ pour changer la fin de la ligne
actuelle. Dans tous les cas où le changement affecte uniquement la ligne
courante, la fin du changement est indiquée avec $.</P>
<P>Lorsqu'un changement affecte plus que la ligne courante, <B>vi</B> efface le
texte original de l'écran et se place en mode insertion. Par exemple, essayez
c3+ pour changer la ligne courante et les trois suivantes ; <B>vi</B>
supprime les quatres lignes originales de l'écran et se place en mode
d'insertion sur une nouvelle ligne blanche.
Comme toujours, tapez la touche ESC lorsque vous aurez fini d'entrer votre
nouveau texte.</P>
<P>Quelques autres commandes de changement :
<UL>
<LI> <B> cc </B> : Change la ligne courante.</LI>
<LI> <B> 5cc </B> : Change cinq lignes (courante et quatre suivantes).</LI>
<LI> <B> c/the </B> : Changer du caractère courant jusqu'à, mais sans
inclure, la prochaine occurence de « the ».</LI>
<LI> <B> c$ </B> : Change jusqu'à la fin de la ligne.</LI>
<LI> <B> c30G </B> : Change de la ligne courante jusqu'à la ligne 30
incluse.</LI>
<LI> <B> cG </B> : Changer de la ligne courante jusqu'à et incluant la
dernière ligne.</LI>
<LI> <B> c1G </B> : Changer la ligne courante jusqu'à la ligne 1 incluse.</LI>
</UL>
</P>

<H2><A NAME="ss9.5">9.5 Emmener (copier) du texte</A>
</H2>

<P>La commande y emmène une copie du texte dans un buffer ; le texte copié peut
être placé (ou collé) n'importe où dans le fichier en utilisant p ou P.</P>
<P>La forme la plus simple de copie est yy pour copier la ligne courante ; après
yy, essayez p pour mettre une copie de la ligne copiée après le curseur. En
suivant yy, vous pouvez faire autant de copie de la ligne emmenée que vous le
voulez en vous déplaçant dans le fichier et en tapant p.</P>
<P>Pour copier plusieurs lignes, essayez, par exemple, 5yy (copie la ligne
courante et les 4 lignes suivantes). p place une copie des lignes emmenées
après le curseur ; la séquence 5yyp « marche » mais ce n'est probablement pas ce
que vous voudriez faire. La commande P fonctionne comme p, mais place une
copie de la ligne au-dessus du curseur ; essayez la séquence 5yyP.</P>
<P>Autres commandes de copie :
<UL>
<LI> <B> y3w </B> : Copie 3 mots.</LI>
<LI> <B> y$ </B> : Copie jusqu'à la fin de la ligne.</LI>
<LI> <B> y1G </B> : Copie de la ligne courante jusqu'à la ligne 1
incluse.</LI>
</UL>
</P>

<H2><A NAME="ss9.6">9.6 Filtrer le texte</A>
</H2>

<P>La commande de filtrage <B>!</B> demande le nom d'une commande UNIX (qui
doit être un filtre), passe les lignes sélectionnées par ce filtre, en
remplaçant les lignes sélectionnées dans le buffer <B>vi</B> avec la sortie
de la commande filtrante. La capacité de <B>vi</B> à passer des parties
arbitraires de texte au travers de tout filtre UNIX ajoute une flexibilité
incroyable à <B>vi</B>, sans « coût supplémentaire » de taille ou de
performance à <B>vi</B> même.</P>
<P>Quelques exemples peuvent aider l'illustration. Créez une ligne dans votre
fichier contenant juste le mot «&nbsp;who&nbsp;» et absolument aucun autre texte. Placez
le curseur sur cette ligne, et tapez <B>!!</B>. Cette commande est analogue
à dd, cc, ou yy, mais au lieu d'effacer, de changer ou de copier la ligne
courante, elle filtre la ligne courante. Lorsque vous pressez le second !, le
curseur descend vers le coin en bas à gauche de l'écran et un simple ! est
affiché, vous demandant d'entrer le nom d'un filtre. En tant que nom de
filtre, tapez «&nbsp;sh&nbsp;» et pressez la touche Entrée. <B>sh</B> (le shell Bourne)
est un filtre ! Il lit l'entrée standard, exécute une partie de l'entrée
(c'est-à-dire qu'il exécute des commandes), et envoie sa sortie (la sortie de
ces commandes) à la sortie standard. Filtrer la ligne contenant « who » au
travers de «&nbsp;sh&nbsp;» remplace la ligne contenant «&nbsp;who&nbsp;» par la liste des
utilisateurs du système courant -- directement dans votre fichier !</P>
<P>Essayez de répéter ce procédé avec <B>date</B>. C'est-à-dire, créez une
ligne ne contenant rien d'autre que le mot <B>date</B>, puis placez le
curseur sur cette ligne, et tapez <B>!!sh</B> et la touche Entrée. La ligne
contenant <B>date</B> est remplacée par la sortie de la commande
<B>date</B>.</P>
<P>Mettez votre curseur sur la première ligne de la sortie de « who ». Comptez le
nombre de lignes. Supposons, par exmple, que ce nombre soit six. Sélectionnez
alors ces six lignes à filtrer au travers de sort ; tapez <B>6!!sort</B> et
la touche Entrée. Les six lignes seront passées à sort, et la sortie de sort
remplacera les six lignes d'origine.</P>
<P>La commande filtre peut uniquement être utilisée sur des lignes complètes,
pas sur des caractères ou des mots.</P>
<P>Quelques autres commandes de filtres (ici, « CR » indique pressez Entrée) :
<UL>
<LI> <B>!/the CR sort CR</B> : Sort la ligne courante jusqu'à la ligne
suivante contenant « the » incluse.</LI>
<LI><B> !1Ggrep the CR</B> : Remplace la ligne courante jusqu'à la ligne 1
incluse par les lignes contenant «&nbsp;the&nbsp;».</LI>
<LI><B> !Gawk '{print $1}' CR  </B>: De la ligne courante jusqu'à la fin
du fichier, remplace chaque ligne par son premier mot.</LI>
</UL>
</P>

<H2><A NAME="ss9.7">9.7 Marquer des lignes et des caractères</A>
</H2>

<P>Vous pouvez marquer des lignes et des caractères pour être
utilisés en tant que cible pour des mouvements, effacement,
changement, copie, et filtration en utilisant la commande mc, où
c est une lettre minuscule.</P>
<P>Par exemple, mettez le curseur au milieu d'un mot et tapez ma.
Ceci marque le caractère sous le curseur sous la marque a.</P>
<P>Maintenant, déplacez le curseur en dehors du caractère marqué
vers une ligne différente (utilisez les flèches curseur, CTRL-u,
ou autre). Pour retourner à la ligne marquée, tapez 'a (c'est-à-dire
apostrophe, puis a). Ceci vous place sur le premier
caractère non-blanc de la ligne contenant la marque a.</P>
<P>Sortez de la ligne encore une fois. Pour retourner au caractère
marqué, tapez `a (apostrophe inverse, puis a). Ceci vous
déplacera sur le caractère marqué par a.</P>
<P>Le marquage est habituellement utilisé avec l'effacement, le
changement, la copie ou la filtration. Par exemple, déplacez le
curseur sur une autre ligne que celle contenant la marque a, et
pressez d'a (d, apostrophe, a). Ceci efface de la ligne courante
jusqu'à la ligne marquée a incluse.</P>
<P>Mettez le curseur au milieu d'un autre mot et tapez mb pour
mettre la marque b. Maintenant, déplacez le curseur hors de ce
mot (mais seulement de quelques lignes, ainsi vous pourrez voir
ce que nous allons faire plus facilement), et pressez d`b (d,
apostrophe inverse, b). Ceci efface le caractère courant jusqu'au
caractère marqué par b inclus.</P>
<P>Comme autre exemple, pour trier la sortie de who, marquez la
première ligne (ma), puis déplacez le curseur vers la dernière
ligne et taper !'asort puis la touche Entrée.</P>
<P>Si vous sautez jusqu'à une marque et que vous décidez de revenir
en arrière, de l'endroit d'où vous avez sauté, vous pouvez taper
'' (reviens à la ligne) ou `` (reviens au caractère).</P>

<H2><A NAME="ss9.8">9.8 Nommer les tampons</A>
</H2>

<P>Lorsque vous effacez, modifiez, ou copier du texte, le texte original est
sauvé (jusqu'au prochain effacement, changement ou copie) dans un tampon non
nommé à partir duquel il peut être mis en utilisant p ou P. En utilisant le
tampon non nommé, seul le plus récent changement du texte peut être récupéré.</P>
<P>Si vous voulez effacer, changer ou copier plusieurs parties de texte et se
souvenir de toutes (jusqu'à un maximum de 26), vous pouvez donner un nom au
tampon avec la commande utilisée. Un nom de tampon est de la forme "c (double
apostrophe, c minuscule).</P>
<P>Par exemple, tapez "ayy pour copier la ligne courante dans le tampon a, puis
déplacez vous sur une autre ligne et tapez "byy pour copier cette ligne dans
le tampon b. Maintenant, déplacez vous n'importe où dans le fichier et tapez
"ap et "bp pour placer des copies du texte sauvé dans les tampons a et b.</P>
<P>Quelques autres commandes de tampon :
<UL>
<LI> <B> "a6yy </B> : Copie 6 lignes (courante et 5 suivantes) dans le tampon a.</LI>
<LI> <B> "bd1G </B> : Efface de la ligne courante jusqu'à la ligne 1
incluse, en sauvant les lignes effacées dans le tampon b.</LI>
<LI> <B> "cy'c </B> : Copie de la ligne courante jusqu'à la ligne marquée
c dans le tampon c (les marques et les tampons sont distincts, et peuvent
avoir le même nom sans que <B>vi</B> ne s'en préoccupe).</LI>
</UL>
</P>

<H2><A NAME="ss9.9">9.9 Substitutions</A>
</H2>

<P>Pour échanger un bloc de texte par un autre dans les lignes de votre fichier,
utilisez la commande :s. Quelques exemples de substitutions :
<UL>
<LI> <B> :1,$s/the/THE/g </B> De la ligne 1 à la dernière ligne (ligne
$), remplace le texte « the » par « THE » ; le fais globalement pour toute ligne où se
trouve un « the ».</LI>
<LI> <B> :'a,.s/.*/ha ha/ </B> De la ligne marquée a jusqu'à la ligne
actuelle (ligne .), substitue tout ce qu'il y a sur la ligne par le texte « ha
ha ».</LI>
</UL>
</P>

<H2><A NAME="ss9.10">9.10 Diverses «&nbsp;commandes double point&nbsp;»</A>
</H2>

<P>Toutes les commandes de double point débutent avec «&nbsp;:&nbsp;» ; lorsque
vous tapez ce symbole, le curseur saute vers le coin bas à gauche
de l'écran, et un prompt à deux points est affiché, attendant que
vous finissiez la commande.</P>
<P>Quelques exemples importants :
<UL>
<LI><B>:w </B> Écrit le contenu du tampon dans le fichier
sans quitter <B>vi</B>.</LI>
<LI><B>:w abc </B> Écrit le contenu du tampon dans le fichier
abc (crée abc s'il n'existe pas, ou réécrit son contenu actuel
s'il existe) sans quitter <B>vi</B>.</LI>
<LI><B>:1,10w  abc  </B> Écrit les lignes 1 à 10 dans le
fichier abc.</LI>
<LI><B>:'a,$w abc  </B>Écrit de la ligne marquée a jusqu'à la
dernière ligne dans le fichier abc.</LI>
<LI><B>:e abc </B>Édite le fichier abc, au lieu du fichier
actuel. <B>vi</B> affiche un message d'erreur si des
changements ont été faits au fichier actuel et qui n'ont pas été
sauvés avec :w.</LI>
<LI><B>:e #  </B>Édite le fichier précédemment édité (des
commandes successives :e# vont et viennent entre deux fichiers).</LI>
<LI><B>:f abc  </B>Change le nom du fichier pour le tampon
actuel vers abc.</LI>
<LI><B>:q </B>Quitte, à moins qu'il n'y ait des changements
que vous ayez faits.</LI>
<LI><B>:q! </B>Quitte, en omettant tous les changements que
vous pourriez avoir fait.</LI>
<LI><B>:r abc </B>Lit le fichier abc dans le tampon
<B>vi</B> actuel, après la ligne sur laquelle se trouve le
curseur (essayez :r croc pour insérer une copie du fichier croc).</LI>
<LI><B>:!cmd </B>Exécute la commande cmd (who, sort, ls, etc.).</LI>
</UL>
</P>

<H2><A NAME="ss9.11">9.11 Utiliser les options</A>
</H2>

<P>Diverses options peuvent affecter le «&nbsp;confort&nbsp;» de <B>vi</B>. Vous pouvez
afficher toutes les diverses options pouvant être utilisées en tapant set all.
Vous pouvez également utiliser «&nbsp;:set&nbsp;» pour changer les options.</P>
<P>Par exemple, si vous désirez voir le numéro de ligne pour les lignes du
fichier que vous éditez, utilisez la commande :set number. Pour supprimer
l'affichage du numéro de ligne, utilisez la commande :set nonumber. La plupart
des options peuvent être abrégées ; :set nu affiche le numéro des lignes et
:set nonu le supprime.</P>
<P>Si vous utilisez :set nomagic, la signification spéciale des caractères
d'expression régulière (point, astérisque, crochet, etc.) est supprimée.
Utilisez :set magic pour restaurer ces significations particulières.</P>
<P>Quelques options ont une valeur. Par exemple, :set tabstop=4 affiche les
tabulations en quatre caractères d'espace, plutôt que les huit habituels.</P>
<P>Si vous trouvez que vous désirez toujours certaines options placées de
certaines manières, vous pouvez mettre ces commandes optionnelles dans un
fichier .exrc, ou vous pouvez utiliser la variable d'environnement EXINIT pour
spécifier les options désirées.</P>
<P>Par exemple, si votre shell par défaut est le shell Bourne, cette ligne peut
aller dans votre fichier .profile :
<HR>
<PRE>
    EXINIT='set nomagic nu tabstop=4'; export EXINIT
</PRE>
<HR>

Si votre shell par défaut est un C shell, cette ligne peut aller dans votre
fichier .login :
<HR>
<PRE>
    setenv EXINIT 'set nomagic nu tabstop=4'
</PRE>
<HR>
</P>

<H2><A NAME="ss9.12">9.12 Cartographie des touches</A>
</H2>

<P>Si vous vous apercevez que vous utilisez encore et encore la même série de
commandes simples, vous pouvez les lier à une touche de commande inutilisée en
utilisant la commande :map. Si votre lien inclut des caractères de contrôle
comme la touche Entrée (ctrl-M en ascii) ou ESC (ctrl-[ en ascii), vous pouvez
les faire précéder de ctrl-v pour supprimer leur signification classique.</P>
<P>Par exemple, cette commande relit ctrl-A pour déplacer le curseur de 55
lignes, puis revenir à la ligne vide la plus récente, changer ensuite  cette
ligne blanche par un saut de page (ctrl-L) et trois lignes blanches. C'est à
dire que chaque ctrl-A paginera la page suivante, sans couper de paragraphes
entre les pages.</P>
<P>Note : Dans cette commande, chaque caractère de contrôle est représenté par ^C,
où C est une lettre majuscule quelconque. Par exemple, ctrl-M est représenté
par ^M. De même, lorsque vous entrez cette commande vous ne verrez pas les
caractères ctrl-v : chaque ctrl-v se voit remplacé par la signification
spéciale du caractère de contrôle suivant, ainsi lorsque vous utiliserez la
séquence ^V^M, tout ce que vous verrez à l'écran est un ^M. Dans cette
commande, ^M est la touche Entrée et ^[ la touche ESC.
<HR>
<PRE>
         :map ^A  55+?^$^V^Mcc^V^L^V^M^V^M^V^M^V^[
</PRE>
<HR>
</P>

<H2><A NAME="ss9.13">9.13 Éditer plusieurs fichiers</A>
</H2>

<P>Vous pouvez éditer plusieurs fichiers avec <B>vi</B> en lui donnant
plusieurs noms de fichiers en arguments de ligne de commande :
<HR>
<PRE>
         vi croc fatherw  wknight
</PRE>
<HR>

Trois commandes sont utilisées pour se déplacer entre plusieurs fichiers :
<UL>
<LI><B> :n  </B> Déplace dans le prochain fichier de la liste d'arguments
(vous devez sauver les changements avec :w ou <B>vi</B> affichera un message
d'erreur).</LI>
<LI><B> :N  </B>Déplace dans le fichier précédent de la liste d'arguments
(vous devez sauver les changements avec :w ou <B>vi</B> affichera un
message d'erreur).</LI>
<LI><B> :rew </B>Rembobine et repart du premier fichier de la liste
d'arguments.</LI>
</UL>
</P>
<P>Les commandes :n, :N et :rew sont quelques peu étranges, mais elles ont des
bénéfices importants : le contenu des tampons ("a, "b, "c, etc.) sont connus
entre les fichiers, et vous pouvez ainsi utiliser :n et :rew avec p et P pour
copier le texte vers l'un ou l'autre des fichiers. De même, la plus récente
chaîne de recherche des commandes / et ? sont les mêmes suivant les fichiers,
et vous pouvez ainsi faire des recherches répétées sur plusieurs fichiers
assez facilement.</P>
<P>Par exemple, tentez l'expérience suivante :
tout d'abord sortez de <B>vi</B>, et exécutez ensuite <B>vi</B> avec croc
et wknight en arguments :
<HR>
<PRE>
         $ vi croc wknight
</PRE>
<HR>

Dans croc, cherchez</P>
<P><B>    /the &lt; CR &gt; </B></P>
<P>Copiez cette ligne dans le tampon a :</P>
<P><B>    "ayy </B></P>
<P>Maintenant déplacez vous sur le prochain fichier (vous n'avez fait aucun
changement à croc, donc ça marchera) :</P>
<P><B>    :n &lt; CR &gt; </B></P>
<P>Cherchez la ligne suivante contenant « the », sans retaper la chaîne de
recherche :</P>
<P><B>    n </B></P>
<P>Mettez une copie du tampon après la ligne courante dans wknight :</P>
<P><B>    "ap </B></P>
<P>Descendez de deux lignes, et copiez la ligne courante dans le tampon b :</P>
<P><B>    jj"byy </B></P>
<P>Sauvez les changements de wknight</P>
<P><B>    :w &lt; CR &gt; </B></P>
<P>Maintenant, retournez à croc</P>
<P><B>    :rew &lt; CR &gt; </B></P>
<P>Cherchez encore, et mettez une copie du tampon b après la ligne trouvée :</P>
<P><B>    n"bp </B></P>
<P>Sauvez les changements, et quittez <B>vi</B></P>
<P><B>    ZZ </B></P>

<H2><A NAME="ss9.14">9.14 Remarques finales</A>
</H2>

<P>Ce tutoriel était prévu pour vous introduire quelques unes des possibilités de
<B>vi</B> que vous pouvez également retrouver dans le manuel <B>vi</B> de
votre système ou qui ne sont pas mentionnées dans ce manuel (de nombreux
systèmes ont des manuels de qualité très variée).</P>
<P>Vous ne serez pas un expert <B>vi</B> après la lecture de ce tutoriel, mais
vous aurez une bonne appréciation des possibilités de <B>vi</B>. Seul le
temps et l'effort peuvent vous faire devenir un expert <B>vi</B>. Mais
l'efficacité et l'universalité de <B>vi</B> rend cet effort payant dans le
long terme.</P>
<P>Vous pouvez avoir décidé que vous détestez <B>vi</B>. Très bien ! Mais prenez
garde, <B>vi</B> demeure l'éditeur de texte standard sous UNIX - le seul
éditeur sur lequel vous pouvez compter pour être disponible sous tout système
UNIX que vous utiliserez - donc même si vous préférez utiliser quelque chose
d'autre dans la vie courante, vous seriez avisé de connaître le minimum à
propos de <B>vi</B> qui est couvert dans ce tutoriel.</P>

<H2><A NAME="vimref"></A> <A NAME="s10">10. Carte de référence ViM</A></H2>


<H2><A NAME="ss10.1">10.1 États Vi</A>
</H2>

<P>Vi a 3 modes :
<OL>
<LI> <B><I>mode commande</I></B> - État normal et initial ; les autres
reviennent ici (utilisez <B>ESC</B> pour stopper une commande partiellement
tapée).</LI>
<LI> <B><I>mode d'entrée</I></B> - Atteint par différentes commandes
<B>a i A I o O c C s S R </B> et terminé par <B>ESC</B> ou anomalement par
interruption.</LI>
<LI> <B><I>mode ligne</I></B> - C-à-d attendant une entrée après une
commande <B>: </B>, <B>/ </B>, <B>?</B> ou un <B>! </B> (terminé par
<B>CR</B>, stoppé par <B>CTRL-c</B>). <B>CTRL</B> est la touche de
contrôle : <B>CTRL-c</B> signifie  « control c ».</LI>
</OL>
</P>

<H2><A NAME="ss10.2">10.2 Commandes Shell</A>
</H2>

<P>
<OL>
<LI> <B>TERM=</B> <I>code</I> Place le nom de code de votre terminal
dans la variable <B>TERM</B>.</LI>
<LI> <B>export TERM</B> Transporte la valeur de <B>TERM</B> (le code du
terminal) vers tout programme UNIX dépendant du terminal.</LI>
<LI> <B>tput init</B> Initialise le terminal pour qu'il fonctionne
proprement avec divers programmes UNIX.</LI>
<LI> <B>vi </B> <I>fichier</I> Accède à l'éditeur <B>vi</B> afin de
pouvoir éditer le fichier spécifié.</LI>
<LI> <B>vi </B> <I>fichier1 fichier2 fichier3</I> Rentre trois fichiers
dans le tampon <B>vi</B> à éditer. Ces fichiers sont <I>fichier1,
fichier2</I>, et <I>fichier3</I>.</LI>
<LI> <B>view </B> <I>fichier</I> Invoque l'éditeur vi sur le
<I>fichier</I> en mode lecture.</LI>
<LI> <B>vi -R </B> <I>fichier</I> Invoque l'éditeur vi sur le
<I>fichier</I> en mode lecture.</LI>
<LI> <B>vi -r </B> <I>fichier</I> Récupère le <I>fichier</I> et les
éditions récentes après le crash du système.</LI>
</OL>
</P>

<H2><A NAME="ss10.3">10.3 Activer les options</A>
</H2>

<P>
<OL>
<LI> <B>:set</B> <I>option</I> Active l'<I>option</I>.</LI>
<LI> <B>:set</B> <I>option=valeur</I> Assigne la <I>value</I> à l'<I>option</I>.</LI>
<LI> <B>:set no</B> <I>option</I> Désactive l'<I>option</I>.</LI>
<LI> <B>:set </B> Affiche les options activées par l'utilisateur.</LI>
<LI> <B>:set all</B> Affiche la liste de toutes les options, à la fois les options par défaut et celles activées par l'utilisateur.</LI>
<LI> <B>:set </B> <I>option</I>? Affiche les valeurs de l'<I>option</I>.</LI>
</OL>
</P>

<H2><A NAME="ss10.4">10.4 Notations utilisées</A>
</H2>

<P>Notations :
<OL>
<LI> <B>CTRL-c</B> <B>CTRL</B> est la touche de contrôle : <B>CTRL-c</B> signifie « control c » ;</LI>
<LI> <B>CR</B> est le retour chariot (touche Entrée).</LI>
</OL>
</P>

<H2><A NAME="ss10.5">10.5 Interrompre, annuler</A>
</H2>

<P>
<UL>
<LI> <B>ESC</B> Arrête l'insertion ou une commande incomplète ;</LI>
<LI> <B>CTRL-?</B> <B>CTRL</B> est la touche de contrôle : <B>CTRL-?</B> signifie « control ? »  supprime ou interrompt des interruptions ;</LI>
<LI> <B>CTRL-l</B> réaffiche/rafraîchit l'écran si ctrl-? l'a malmené.</LI>
</UL>
</P>

<H2><A NAME="ss10.6">10.6 Manipulation de fichier</A>
</H2>

<P>
<UL>
<LI> <B>ZZ</B> Sauve le fichier et sort de vi.</LI>
<LI> <B>:wq</B> Sauve le fichier et sort de vi.</LI>
<LI> <B>:w</B> Écrit le fichier courant.</LI>
<LI> <B>:w!</B> Force l'écriture du fichier courant, si le fichier est en lecture seule.</LI>
<LI> <B>:w<I>nom</I></B> Écrit dans le fichier <I>nom</I>.</LI>
<LI> <B>:q</B> Sort de vi.</LI>
<LI> <B>:q!</B> Force la sortie de vi (annule les changements).</LI>
<LI> <B>:e name</B> Édite le fichier <I>nom</I>.</LI>
<LI> <B>:e!</B> Réédite, en annulant les changements.</LI>
<LI> <B>:e + name</B> Édite le fichier <I>nom</I>, en partant de la fin.</LI>
<LI> <B>:e + n</B> Édite en partant de la ligne <I>n</I>.</LI>
<LI> <B>:e #</B> Édite un fichier alternatif.</LI>
<LI> <B>:n</B> Édite le fichier suivant de la <I>liste des
arguments</I>.</LI>
<LI> <B>:args</B> Liste les fichiers de la liste actuelle.</LI>
<LI> <B>:rew</B> Rembobine la liste des fichiers et édite le premier.</LI>
<LI> <B>:n args</B> Spécifie une nouvelle liste des arguments.</LI>
<LI> <B>:f </B> Affiche le fichier actuel et la ligne.</LI>
<LI> <B>CTRL-G</B> Synonyme de :f, affiche le fichier actuel et la ligne.</LI>
<LI> <B>:ta tag </B> Pour marquer l'entrée du fichier par <I>tag</I>.</LI>
<LI> <B>CTRL-] </B> :ta, le mot suivant est tag.</LI>
</UL>
</P>

<H2><A NAME="ss10.7">10.7 Mouvement</A>
</H2>

<P>
<UL>
<LI> <B>Flèches</B> Déplace le curseur.</LI>
<LI> <B>CTRL-d</B> Descend d'une demi-page.</LI>
<LI> <B>CTRL-u</B> Monte d'une demi page.</LI>
<LI> <B>CTRL-f</B> Descend d'une page entière.</LI>
<LI> <B>CTRL-b</B> Monte d'une page entière.</LI>
<LI> <B>:0</B> Déplacement au début du fichier.</LI>
<LI> <B>:n</B> Déplacement à la ligne numéro n.</LI>
<LI> <B>:$</B> Déplacement à la fin du fichier.</LI>
<LI> <B>0</B> Déplacement au début de la ligne.</LI>
<LI> <B>^</B> Déplacement au premier caractère non-blanc.</LI>
<LI> <B>$</B> Déplacement au début de la ligne.</LI>
<LI> <B>CR</B> Déplacement au début de la ligne suivante.</LI>
<LI> <B>-</B> Déplacement au début de la ligne précédente.</LI>
<LI> <B>%</B> Trouve le crochet correspondant.</LI>
<LI> <B>G </B> Va à la ligne (défaut à la dernière ligne).</LI>
<LI> <B>]] </B> section/fonction suivante.</LI>
<LI> <B>[[ </B> section/fonction précédente.</LI>
</UL>
</P>

<H2><A NAME="ss10.8">10.8 Positionnement en ligne</A>
</H2>

<P>
<UL>
<LI> <B>H </B> Première ligne de l'écran.</LI>
<LI> <B>L </B> Dernière ligne de l'écran.</LI>
<LI> <B>M </B> Ligne du milieu de l'écran.</LI>
<LI> <B>+ </B> Ligne suivante, sur le premier non-blanc.</LI>
<LI> <B>- </B> Ligne précédente, sur le premier non-blanc.</LI>
<LI> <B>CR </B> Entrée, pareil que +.</LI>
<LI> <B>j </B> Ligne suivante, même colonne.</LI>
<LI> <B>k </B> Ligne précédente, même colonne.</LI>
</UL>
</P>

<H2><A NAME="ss10.9">10.9 Positionnement des caractères</A>
</H2>

<P>
<UL>
<LI> <B>0 </B> Début de la ligne.</LI>
<LI> <B>$ </B> Fin de la ligne.</LI>
<LI> <B>h </B> Avance.</LI>
<LI> <B>l </B> Recule.</LI>
<LI> <B>SPACE </B> Pareil que l.</LI>
<LI> <B>fx </B> Trouve x en avant.</LI>
<LI> <B>Fx </B> Trouve x en arrière.</LI>
<LI> <B>; </B> Répète le dernier f F.</LI>
<LI> <B>, </B> Inverse de ; .</LI>
<LI> <B>| </B> Vers la colonne spécifiée.</LI>
<LI> <B>% </B> Trouve le { ou } correspondant.</LI>
</UL>
</P>

<H2><A NAME="ss10.10">10.10 Mots, phrases, paragraphes</A>
</H2>

<P>
<UL>
<LI> <B>w </B> Mot en avant.</LI>
<LI> <B>b </B> Mot en arrière.</LI>
<LI> <B>e </B> Fin du mot.</LI>
<LI> <B>) </B> Phrase suivante.</LI>
<LI> <B>( </B> Phrase précédente.</LI>
<LI> <B>} </B> Paragraphe suivant.</LI>
<LI> <B>{ </B> Paragraphe précédent.</LI>
<LI> <B>W </B> Mot délimité par du blanc.</LI>
<LI> <B>B </B> Retour d'un mot blanc.</LI>
<LI> <B>E </B> Fin d'un mot blanc.</LI>
</UL>
</P>

<H2><A NAME="ss10.11">10.11 Marquage et retour</A>
</H2>

<P>
<UL>
<LI> <B>``</B> (taper deux fois la touche `) Contexte précédent.</LI>
<LI> <B>''</B> (taper deux fois la touche ') Contexte précédent au premier non-blanc de la ligne.</LI>
<LI> <B>mx</B> Marque la position avec la lettre x.</LI>
<LI> <B>`x</B> (touche ` et lettre x) Va à la marque x.</LI>
<LI> <B>'x</B> Va à la marque x au premier non-blanc de la ligne.</LI>
</UL>
</P>

<H2><A NAME="ss10.12">10.12 Corrections au cours de l'insertion</A>
</H2>

<P>
<UL>
<LI> <B>CTRL-h</B> Efface le dernier caractère.</LI>
<LI> <B>CTRL-w</B> Efface le dernier mot.</LI>
<LI> <B>erase </B> Taper la touche DELETE, pareil que CTRL-h.</LI>
<LI> <B>kill </B> Votre touche kill, efface l'entrée de la ligne.</LI>
<LI> <B>\ </B> Échappement de CTRL-h, efface et kill.</LI>
<LI> <B>ESC </B> Stoppe l'insertion, retourne en commande.</LI>
<LI> <B>CTRL-? </B> Interrompt, termine l'insertion.</LI>
<LI> <B>CTRL-d </B> Retour de tabulation sur un <I>autoindent</I>.</LI>
<LI> <B>CTRL-v </B> Affiche un caractère non affichable.</LI>
</UL>
</P>

<H2><A NAME="ss10.13">10.13 Ajuster l'écran</A>
</H2>

<P>
<UL>
<LI> <B>CTRL-l</B> Efface et redessine.</LI>
<LI> <B>CTRL-r</B> Redessine, élimine les lignes @.</LI>
<LI> <B>z-CR</B> Redessine avec la ligne courante en haut.</LI>
<LI> <B>z-</B> Redessine, avec la ligne courante au bas de la fenêtre.</LI>
<LI> <B>z.</B> Redessine, avec la ligne courante au centre de la fenêtre.</LI>
<LI> <B>/pat/z-</B> Ligne contenant <I>pat</I> en bas.</LI>
<LI> <B>tn</B> Utilise une fenêtre de n lignes.</LI>
<LI> <B>CTRL-e</B> Descend la fenêtre d'une ligne.</LI>
<LI> <B>CTRL-y</B> Remonte la fenêtre d'une ligne.</LI>
</UL>
</P>

<H2><A NAME="ss10.14">10.14 Effacer</A>
</H2>

<P>
<UL>
<LI> <B>x</B> Efface le caractère sous le curseur.</LI>
<LI> <B>X</B> Efface le caractère avant le curseur.</LI>
<LI> <B>D</B> Efface jusqu'à la fin de la ligne.</LI>
<LI> <B>d^</B> Efface jusqu'au début de la ligne.</LI>
<LI> <B>dd</B> Efface la ligne.</LI>
<LI> <B>ndd</B> Efface <I>n</I> lignes en commençant à la ligne
actuelle.</LI>
<LI> <B>dnw</B> Efface <I>n</I> mots en partant du curseur.</LI>
</UL>
</P>

<H2><A NAME="ss10.15">10.15 Insérer, changer</A>
</H2>

<P>
<UL>
<LI> <B>i</B> Passe en mode d'insertion avant le curseur.</LI>
<LI> <B>I</B> Passe en mode d'insertion avant le premier caractère non-blanc.</LI>
<LI> <B>a</B> Passe en mode d'insertion après le curseur.</LI>
<LI> <B>A</B> Passe en mode d'insertion après la fin de la ligne.</LI>
<LI> <B>o</B> Ouvre une nouvelle ligne en dessous de la ligne courante et passe en mode d'insertion.</LI>
<LI> <B>O</B> Ouvre une nouvelle ligne au dessus de la ligne courante et passe en mode d'insertion.</LI>
<LI> <B>r</B> Remplace le caractère en dessous du curseur (ne passe PAS en mode d'insertion).</LI>
<LI> <B>R</B> Entre en mode d'insertion en remplaçant les caractères.</LI>
<LI> <B>C</B> shift-c. Change le reste de la ligne.</LI>
<LI> <B>D</B> shift-d. Efface le reste de la ligne.</LI>
<LI> <B>s</B> Substitue des caractères.</LI>
<LI> <B>S</B> Substitue des lignes.</LI>
<LI> <B>J</B> Joint les lignes.</LI>
</UL>
</P>

<H2><A NAME="ss10.16">10.16 Copier et coller</A>
</H2>

<P>Le tampon de copie est rempli par <I>TOUTE</I> commande d'effacement, ou explicitement par <B>Y</B> et <B>yy</B>.
<UL>
<LI> <B>Y</B> Copie la ligne courante dans le tampon.</LI>
<LI> <B><I>n</I>yy</B> Copie <I>n</I> lignes en partant de la ligne actuelle dans le tampon.</LI>
<LI> <B>p</B> Colle le tampon après le curseur (ou sous la ligne
actuelle).</LI>
<LI> <B>P</B> Colle le tampon avant le curseur (ou avant la ligne actuelle).</LI>
<LI> <B>"<I>x</I>p </B> Colle à partir du buffer x.</LI>
<LI> <B>"<I>x</I>y </B> Copie dans le tampon x.</LI>
<LI> <B>"<I>x</I>d </B> Efface dans le tampon x.</LI>
</UL>
</P>

<H2><A NAME="ss10.17">10.17 Opérateurs (utiliser des doubles pour agir sur les lignes complètes)</A>
</H2>

<P>
<UL>
<LI> <B>d </B> Effacer.</LI>
<LI> <B>c </B> Changer.</LI>
<LI> <B>&lt; </B> Déplacement gauche.</LI>
<LI> <B>> </B> Déplacement droit.</LI>
<LI> <B>! </B> Filtrer au travers de la commande.</LI>
<LI> <B>= </B> Indenter pour LISP.</LI>
<LI> <B>y </B> Copier le texte dans le tampon.</LI>
</UL>
</P>

<H2><A NAME="ss10.18">10.18 Chercher et remplacer</A>
</H2>

<P>
<UL>
<LI> <B>/<I>texte</I></B> Cherche en avant pour <I>texte</I>.</LI>
<LI> <B>?<I>texte</I></B> Cherche en arrière pour <I>texte</I>.</LI>
<LI> <B>n</B> Répète la dernière recherche dans la même direction.</LI>
<LI> <B>N</B> Répète la dernière recherche dans la direction inverse.</LI>
<LI> <B>/</B> Répète la dernière recherche en avant.</LI>
<LI> <B>?</B> Répète la dernière recherche en arrière.</LI>
<LI> <B>[ addr ] s/from/to/ [ g ] </B> Cherche une occurence de <I>from</I> et remplace par <B><I>to</I></B> dans la ligne actuelle, ou dans le bloc.
<B><I>addr</I></B> (deux numéros de lignes séparés par une commande ; 1,$ est le fichier entier) remplace une occurence par ligne, ou toutes les occurences si <B><I>g</I></B> est spécifié.
Par exemple, :3,20s/unmot/unautre/g remplacera "unmot" par "unautre" de la ligne 3 à la ligne 20. 'g' est global et signifie que toutes les occurences de "unmot" seront remplacées.</LI>
</UL>
</P>

<H2><A NAME="ss10.19">10.19 Général</A>
</H2>

<P>
<UL>
<LI> <B>:sh</B> Donne un shell (à quitter avec CTRL-d).</LI>
<LI> <B>:!<I>commande</I></B> Lance un shell pour exécuter <I>commande</I>.</LI>
<LI> <B>:set number</B> Active la numérotation des lignes.</LI>
<LI> <B>:set nonumber</B> Désactive la numérotation des lignes.</LI>
</UL>
</P>

<H2><A NAME="ss10.20">10.20 Commandes d'édition de ligne</A>
</H2>

<P>
<UL>
<LI> <B>:</B> Prévient <B>vi</B> que les prochaines commandes seront des commandes pour l'éditeur de ligne.</LI>
<LI> <B>:sh</B> Retourne temporairement au shell pour exécuter quelques commandes shell sans quitter <B>vi</B>.</LI>
<LI> <B>CTRL-d</B> Sort du shell temporaire et retourne sous <B>vi</B> afin de pouvoir éditer la fenêtre actuelle.</LI>
<LI> <B>:</B><I>n</I> Va à la <I>n</I>ème ligne du tampon.</LI>
<LI> <B>:</B><I>x,z</I><B>w</B> <I>fichier</I> Écrit les lignes <I>x</I> à <I>z</I> dans un nouveau fichier appellé <I>fichier</I>.</LI>
<LI> <B>:$</B> Déplace le curseur au début de la dernière ligne du tampon.</LI>
<LI> <B>:.,$d</B> Efface toutes les lignes de la ligne actuelle à la dernière ligne.</LI>
<LI> <B>:r</B> <I>fichier</I> Insère le contenu du fichier <I>fichier</I> sous la ligne actuelle du tampon.</LI>
<LI> <B>:s</B><I>/texte/autre_texte/</I> Remplace la première apparition de <I>texte</I> sur la ligne actuelle par <I>autre_texte</I>.</LI>
<LI> <B>:s</B><I>/texte/autre_texte/g</I> Remplace toutes les apparitions de <I>texte</I> sur la ligne actuelle par <I>autre_texte</I>.</LI>
<LI> <B>:g</B><I>/texte/s//autre_texte/g</I> Change toutes les apparitions de <I>texte</I> dans le tampon par <I>autre_texte</I>.</LI>
</UL>
</P>

<H2><A NAME="ss10.21">10.21 Autres commandes</A>
</H2>

<P>
<UL>
<LI> <B>u</B> Annule le dernier changement.</LI>
<LI> <B>U</B> Restaure la ligne actuelle.</LI>
<LI> <B>~</B> Change la casse.</LI>
<LI> <B>J</B> Joint la ligne actuelle et la ligne suivante.</LI>
<LI> <B>.</B> Répète la dernière commande de changement de texte.</LI>
<LI> <B>CTRL-g</B> Montre le nom du fichier et le nombre de lignes.</LI>
</UL>
</P>

<H2><A NAME="s11">11. URLs connexes</A></H2>

<P>Les URLs connexes à ViM sont sur :
<UL>
<LI> C et C++ Beautifer 
<A HREF="http://www.metalab.unc.edu/LDP/HOWTO/C-C++Beautifier-HOWTO.html">http://www.metalab.unc.edu/LDP/HOWTO/C-C++Beautifier-HOWTO.html</A></LI>
<LI> Linux goodies 
<A HREF="http://www.aldev.8m.com">http://www.aldev.8m.com</A> ou sur 
<A HREF="http://www.aldev.webjump.com">http://www.aldev.webjump.com</A></LI>
</UL>
</P>


<H2><A NAME="s12">12. Autres formats de ce document</A></H2>

<P>Ce document est publié sous 11 formats différents, nommément - DVI,
Postscript, Latex, Adobe Acrobat PDF, LyX, GNU-info, HTML, RTF(Rich Text Format), Plain-text,
pages man Unix et SGML.
<UL>
<LI>Vous pouvez obtenir ce document howto sous la forme d'une archive tar en html,
dvi, postscript et sgml de :
<A HREF="ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/other-formats/">ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/other-formats/</A>
</LI>
<LI>Le format texte plein est sur :
<A HREF="ftp://metalab.unc.edu/pub/Linux/docs/HOWTO">ftp://metalab.unc.edu/pub/Linux/docs/HOWTO</A>
</LI>
<LI>Les traductions dans d'autres langages comme français, allemand,
espagnol, chinois, japonais sont sur
<A HREF="ftp://metalab.unc.edu/pub/Linux/docs/HOWTO">ftp://metalab.unc.edu/pub/Linux/docs/HOWTO</A>.
Toute aide de votre part pour traduire ce document dans d'autres langages est
la bienvenue.</LI>
</UL>

Ce document est écrit en utilisant un outil nommé « SGML tools » qui peut être
obtenu de :
<A HREF="http://www.sgmltools.org">http://www.sgmltools.org</A>.
Pour compiler le source vous obtiendrez les commandes suivantes comme :
<UL>
<LI>sgml2html Vim-howto.sgml     (pour générer un fichier html)</LI>
<LI>sgml2rtf Vim-howto.sgml     (pour générer un fichier RTF)</LI>
<LI>sgml2latex Vim-howto.sgml    (pour générer un fichier latex)</LI>
</UL>
</P>
<P>Les documents LaTeX peuvent être convertis en fichiers PDF en produisant
simplement une sortie Postscript en utilisant <B>sgml2latex</B> (et dvips)
et en utilisant la sortie via la commande Acrobat <B>distill</B> (
<A HREF="http://www.adobe.com">http://www.adobe.com</A>) comme suit :
<HR>
<PRE>
bash$ man sgml2latex
bash$ sgml2latex filename.sgml
bash$ man dvips
bash$ dvips -o filename.ps filename.dvi
bash$ distill filename.ps
bash$ man ghostscript
bash$ man ps2pdf
bash$ ps2pdf input.ps output.pdf
bash$ acroread output.pdf &amp;
</PRE>
<HR>

Ou vous pouvez utiliser la commande Ghostscript <B>ps2pdf</B>. ps2pdf est un
clone pour la majorité des fonctionnalités du produit Adobe's Acrobat
Distiller : il convertit les fichiers PostScript en fichiers Portable Document
Format (PDF).
<B>ps2pdf</B> est implémenté sous la forme d'un fichier script de commandes
très petit qui invoque Ghostscript, en sélectionnant un périphérique de sortie
spécial nommé <B>pdfwrite</B>. Afin d'utiliser ps2pdf, le périphérique
pdfwrite doit être inclus dans le makefile lors de la compilation Ghostscript ;
voyez la documentation sur la compilation de Ghostscript pour les détails.</P>
<P>Ce document se trouve sur :
<UL>
<LI> 
<A HREF="http://metalab.unc.edu/LDP/HOWTO/ViM-HOWTO.html">http://metalab.unc.edu/LDP/HOWTO/ViM-HOWTO.html</A></LI>
</UL>
</P>
<P>Vous pouvez aussi trouver ce document sur les sites miroirs suivants :
<UL>
<LI> 
<A HREF="http://www.caldera.com/LDP/HOWTO/ViM-HOWTO.html">http://www.caldera.com/LDP/HOWTO/ViM-HOWTO.html</A></LI>
<LI> 
<A HREF="http://www.WGS.com/LDP/HOWTO/ViM-HOWTO.html">http://www.WGS.com/LDP/HOWTO/ViM-HOWTO.html</A></LI>
<LI> 
<A HREF="http://www.cc.gatech.edu/linux/LDP/HOWTO/ViM-HOWTO.html">http://www.cc.gatech.edu/linux/LDP/HOWTO/ViM-HOWTO.html</A></LI>
<LI> 
<A HREF="http://www.redhat.com/linux-info/ldp/HOWTO/ViM-HOWTO.html">http://www.redhat.com/linux-info/ldp/HOWTO/ViM-HOWTO.html</A>
</LI>
<LI>D'autres sites miroirs près de vous (à l'échelle du réseau) peuvent se
trouver sur
<A HREF="http://metalab.unc.edu/LDP/mirrors.html">http://metalab.unc.edu/LDP/mirrors.html</A>,
sélectionnez un site et allez voir le fichier /LDP/HOWTO/Vim-HOWTO.html.</LI>
</UL>
</P>
<P>Afin de voir un document au format dvi, utilisez le programme xdvi. Le
programme xdvi se trouve dans le paquetage tetex-xdvi*.rpm de la Redhat Linux
qui peut se trouver dans ControlPanel | Applications | Publishing | TeX.</P>
<P>Pour lire un document dvi utilisez la commande :</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        xdvi -geometry 80x90 howto.dvi
        man xdvi
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Et redimmensionnez la fenêtre avec une souris. Voyez la page man de
xdvi. Pour naviguer utilisez les flèches, les touches page up, down,
ou également les lettres 'f', 'd', 'u', 'c', 'l', 'r', 'p', 'n' pour
monter, descendre, centrer, page suivante, page précédente, etc. Pour
supprimer le menu expert appuyez sur 'x'.</P>
<P>Vous pouvez lire le fichier postscript avec le programme 'gv' (ghostview) ou
'ghostscript'.
Le programme ghostscript est dans le paquetage ghostscript*.rpm et le
programme gv dans gv*.rpm, qui se trouvent sous ControlPanel | Applications |
Graphics. Le programme gv est beaucoup plus agréable à utiliser que
ghostscript.</P>
<P>Ghostscript et gv sont aussi disponibles sous d'autres
plateformes comme OS/2, Windows 95 et NT. Vous pouvez donc lire ce document
sur toutes ces plateformes.</P>
<P>
<UL>
<LI>Prenez ghostscript pour Windows 95, OS/2, et tous les OS sur
<A HREF="http://www.cs.wisc.edu/~ghost">http://www.cs.wisc.edu/~ghost</A></LI>
</UL>
</P>
<P>Pour lire le document postscript utilisez la commande :</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        gv howto.ps
        ghostscript howto.ps
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Vous pouvez lire le document en html en utilisant Netscape Navigator,
Microsoft Internet explorer, Redhat Baron ou tout autre des 10 navigateurs
web.</P>
<P>Vous pouvez lire la sortie LaTeX ou LyX en utilisant LyX ou vim.</P>

<H2><A NAME="s13">13. Notice de Copyright</A></H2>

<P>Le Copyright est GNU/GPL comme pour le LDP (Linux Documentation project). Le
LDP est un projet GNU/GPL.
Les restrictions additionnelles sont - vous devez conserver le nom de
l'auteur, l'adresse mail et cette notice de Copyright sur toutes les copies.
Si vous effectuez un changement ou une addition à ce document, vous devez
notifier tous les auteurs de ce document.</P>

</BODY>
</HTML>
