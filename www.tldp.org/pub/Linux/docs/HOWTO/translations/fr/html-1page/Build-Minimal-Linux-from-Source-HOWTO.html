<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Construire un système Linux minimum à partir du code source</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"></HEAD
><BODY
CLASS="ARTICLE"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>Construire un système Linux minimum à partir du code source</A
></H1
><H3
CLASS="AUTHOR"
><A
NAME="AEN4"
>Greg O'Keefe</A
></H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:gcokeefe@postoffice.utas.edu.au"
>gcokeefe@postoffice.utas.edu.au</A
>&#62;</CODE
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
></DIV
><P
CLASS="OTHERCREDIT"
><B
>Dominique van den Broeck - </B
><SPAN
CLASS="CONTRIB"
>Traduction française</SPAN
></P
><P
CLASS="OTHERCREDIT"
><B
>Jean-Philippe Guérard - </B
><SPAN
CLASS="CONTRIB"
>Relecture de la version française</SPAN
></P
><P
CLASS="PUBDATE"
>v0.9, novembre 2000<BR></P
><DIV
><DIV
CLASS="ABSTRACT"
><P
></P
><A
NAME="AEN27"
></A
><P
>Voici les instructions pour construire un système Linux minimum à partir 
du code source. Ce document faisait partie du guide pratique 
« <A
HREF="http://www.traduc.org/docs/HOWTO/lecture/From-PowerUp-To-Bash-Prompt-HOWTO.html"
TARGET="_top"
>De la mise 
sous tension à l'invite de commande de Bash</A
> », mais 
j'ai choisi d'en faire un document indépendant, afin que chacun de ces 2 
documents restent courts et concentrés. Le système que nous construisons 
ici est réduit au minimum et n'est pas apte à réaliser un vrai travail. 
Si vous voulez monter un vrai système, lisez plutôt le <A
HREF="http://www.fr.linuxfromscratch.org/"
TARGET="_top"
>Comment faire un
système Linux à partir de zéro</A
> (<I
CLASS="FOREIGNPHRASE"
>Linux from 
scratch - LFS</I
>).</P
><P
></P
></DIV
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table des matières</B
></DT
><DT
>1. <A
HREF="#AEN32"
>Ce qu'il vous faut</A
></DT
><DT
>2. <A
HREF="#AEN122"
>Le système de fichier</A
></DT
><DT
>3. <A
HREF="#AEN138"
>MAKEDEV</A
></DT
><DT
>4. <A
HREF="#AEN157"
>Le noyau</A
></DT
><DT
>5. <A
HREF="#AEN174"
>Lilo</A
></DT
><DT
>6. <A
HREF="#AEN205"
>Glibc</A
></DT
><DT
>7. <A
HREF="#AEN222"
>SysVinit</A
></DT
><DT
>8. <A
HREF="#AEN249"
>Ncurses</A
></DT
><DT
>9. <A
HREF="#AEN254"
>Bash</A
></DT
><DT
>10. <A
HREF="#AEN267"
>Util-linux (getty et login)</A
></DT
><DT
>11. <A
HREF="#AEN287"
>Sh-utils</A
></DT
><DT
>12. <A
HREF="#AEN297"
>Rendre le système plus utilisable</A
></DT
><DT
>13. <A
HREF="#AEN316"
>Informations complémentaires</A
></DT
><DD
><DL
><DT
>13.1. <A
HREF="#FINDING"
>Astuces diverses</A
></DT
><DT
>13.2. <A
HREF="#LIENS"
>Liens</A
></DT
></DL
></DD
><DT
>14. <A
HREF="#AEN344"
>Section administrative</A
></DT
><DD
><DL
><DT
>14.1. <A
HREF="#AEN346"
>Copyright</A
></DT
><DT
>14.2. <A
HREF="#AEN350"
>Page principale</A
></DT
><DT
>14.3. <A
HREF="#AEN354"
>Réactions</A
></DT
><DT
>14.4. <A
HREF="#ACKNOWLEDGE"
>Références et remerciements</A
></DT
><DT
>14.5. <A
HREF="#AEN390"
>Historique des changements</A
></DT
><DT
>14.6. <A
HREF="#AEN402"
>Améliorations prévues</A
></DT
><DT
>14.7. <A
HREF="#ADAPTATION-FRANCAISE"
>Adaptation française</A
></DT
></DL
></DD
></DL
></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN32"
>1. Ce qu'il vous faut</A
></H2
><P
>Nous installerons une distribution de Linux telle que Red Hat sur une 
partition, et l'utiliserons pour construire un nouveau système Linux sur 
une autre partition. Je nommerai par la suite 
« cible » le système que nous construisons, et 
« source » le système que nous utilisons pour 
construire le système cible (à ne pas confondre avec <EM
>code 
source</EM
> que nous utiliserons aussi).</P
><P
>Vous allez donc avoir besoin d'une machine avec deux partitions libres.
Si vous le pouvez, utilisez une machine qui ne contienne rien
d'important. Vous pouvez utiliser un système Linux déjà existant comme
système source, mais je le déconseille. Si vous oubliez un des paramètres
des commandes que nous allons saisir, vous pourriez accidentellement
réinstaller des choses sur votre système source. Cela peut mener à des
incompatibilités, et des conflits.</P
><P
>Les <ACRONYM
CLASS="ACRONYM"
>BIOS</ACRONYM
> des PC dont l'architecture est ancienne, 
pour la plupart des 486 et des machines antérieures, ont une limitation 
ennuyeuse. Ils ne peuvent lire les disques durs au-delà des 512 premiers 
méga-octets. Ce n'est pas vraiment un problème pour Linux, qui gère 
lui-même les disques une fois lancé. Mais pour que Linux soit chargé sur 
ces vieilles machines, le noyau doit résider quelque part en-dessous de 
512 méga-octets. Si vous utilisez une de ces machines, vous devrez créer 
une partition distincte en-dessous de 512 Mo, à monter sur 
<TT
CLASS="FILENAME"
>/boot</TT
> pour chaque système 
dont la partition racine se situe au-dessus de la limite des 
512 Mo.</P
><P
>La dernière fois que je l'ai fait, j'ai utilisé Red Hat 6.1 comme système
source. J'ai installé le système de base plus :</P
><P
></P
><UL
><LI
><P
>cpp</P
></LI
><LI
><P
>egcs</P
></LI
><LI
><P
>egcs-c++</P
></LI
><LI
><P
>patch</P
></LI
><LI
><P
>make</P
></LI
><LI
><P
>dev86 </P
></LI
><LI
><P
>ncurses-devel</P
></LI
><LI
><P
>glibc-devel </P
></LI
><LI
><P
>kernel-headers </P
></LI
></UL
><P
>J'ai aussi installé X-Window et Mozilla pour pouvoir lire la 
documentation facilement, mais ce n'est pas vraiment nécessaire. À la 
fin de mon travail, celui-ci avait pris environ 350 Mo d'espace 
disque (cela semble un peu élevé, je me demande pourquoi).</P
><P
>Le système cible achevé prenait 650 Mo, mais comprenait tout le 
code source et les fichiers intermédiaires. Si l'espace est limité, je 
vous conseille de faire un <B
CLASS="COMMAND"
>make clean</B
> après la 
construction de chaque paquet. Cela dit, cette taille surprenante est un 
peu inquiétante.</P
><P
><A
NAME="DOWNLOADS"
></A
>
Enfin, vous allez avoir besoin du code source du système que vous allez
construire. Ce sont les paquets dont nous avons parlé dans le guide 
pratique « <A
HREF="http://www.traduc.org/docs/HOWTO/lecture/From-PowerUp-To-Bash-Prompt-HOWTO.html"
TARGET="_top"
>De la mise sous 
tension à l'invite de commande de Bash</A
> ». On peut les 
obtenir depuis un CD, ou par l'Internet. Je donnerai les url de 
leurs sites américains et des miroirs français.</P
><P
></P
><UL
><LI
><P
>MAKEDEV : <A
HREF="ftp://sunsite.unc.edu/pub/Linux/system/admin/"
TARGET="_top"
>ftp://sunsite.unc.edu/pub/Linux/system/admin/</A
> (USA), 
<A
HREF="ftp://ftp.lip6.fr/pub/linux/sunsite/system/admin/"
TARGET="_top"
>ftp://ftp.lip6.fr/pub/linux/sunsite/system/admin/</A
> 
(France).</P
></LI
><LI
><P
>Lilo : <A
HREF="ftp://lrcftp.epfl.ch/pub/linux/local/lilo/"
TARGET="_top"
>ftp://lrcftp.epfl.ch/pub/linux/local/lilo/</A
> (Suisse),
<A
HREF="ftp://ftp.lip6.fr/pub/linux/sunsite/system/boot/lilo/"
TARGET="_top"
>ftp://ftp.lip6.fr/pub/linux/sunsite/system/boot/lilo/</A
> 
(France).</P
></LI
><LI
><P
>Noyau Linux : utilisez un des miroirs listés sur <A
HREF="http://www.kernel.org"
TARGET="_top"
>http://www.kernel.org</A
> plutôt que <A
HREF="ftp://ftp.kernel.org/pub/linux/kernel/"
TARGET="_top"
>ftp://ftp.kernel.org/pub/linux/kernel/</A
> (USA)
car ils sont toujours en surcharge ; <A
HREF="ftp://ftp.fr.kernel.org/pub/linux/kernel/"
TARGET="_top"
>ftp://ftp.fr.kernel.org/pub/linux/kernel/</A
> (France).</P
></LI
><LI
><P
>GNU libc : la bibliothèque elle-même, ainsi que les extensions 
linuxthreads sont sur <A
HREF="ftp://ftp.gnu.org/pub/gnu/glibc/"
TARGET="_top"
>ftp://ftp.gnu.org/pub/gnu/glibc/</A
> (USA), <A
HREF="ftp://ftp.lip6.fr/pub/gnu/glibc/"
TARGET="_top"
>ftp://ftp.lip6.fr/pub/gnu/glibc/</A
> (France).</P
></LI
><LI
><P
>Extensions de la libc GNU : vous aurez aussi besoin des linuxthreads et 
des extensions libcrypt. Si libcrypt est absente du fait des lois 
américaines sur l'exportation, vous pouvez la récupérer sur <A
HREF="ftp://ftp.gwdg.de/pub/gnu/glibc"
TARGET="_top"
>ftp://ftp.gwdg.de/pub/gnu/glibc</A
> les extensions 
linuxthreads sont au même endroit que la libc proprement dite.</P
></LI
><LI
><P
>GNU ncurses : <A
HREF="ftp://ftp.gnu.org/gnu/ncurses"
TARGET="_top"
>ftp://ftp.gnu.org/gnu/ncurses</A
> (USA),
<A
HREF="ftp://ftp.lip6.fr/pub/gnu/ncurses"
TARGET="_top"
>ftp://ftp.lip6.fr/pub/gnu/ncurses</A
> (France).</P
></LI
><LI
><P
>SysVinit : <A
HREF="ftp://sunsite.unc.edu/pub/Linux/system/daemons/init/"
TARGET="_top"
>ftp://sunsite.unc.edu/pub/Linux/system/daemons/init/</A
> 
(USA), <A
HREF="ftp://ftp.lip6.fr/pub/linux/sunsite/system/daemons/init/"
TARGET="_top"
>ftp://ftp.lip6.fr/pub/linux/sunsite/system/daemons/init/</A
> 
(France).</P
></LI
><LI
><P
>GNU Bash : <A
HREF="ftp://ftp.gnu.org/gnu/bash/"
TARGET="_top"
>ftp://ftp.gnu.org/gnu/bash/</A
> (USA),
<A
HREF="ftp://ftp.lip6.fr/pub/gnu/bash/"
TARGET="_top"
>ftp://ftp.lip6.fr/pub/gnu/bash/</A
> (France).</P
></LI
><LI
><P
>GNU sh-utils : <A
HREF="ftp://ftp.gnu.org/gnu/sh-utils/"
TARGET="_top"
>ftp://ftp.gnu.org/gnu/sh-utils/</A
> 
(USA), <A
HREF="ftp://ftp.lip6.fr/pub/gnu/sh-utils/"
TARGET="_top"
>ftp://ftp.lip6.fr/pub/gnu/sh-utils/</A
> 
(France).</P
></LI
><LI
><P
>util-linux : <A
HREF="ftp://ftp.win.tue.nl/pub/linux/utils/util-linux/"
TARGET="_top"
>ftp://ftp.win.tue.nl/pub/linux/utils/util-linux/</A
> 
(Pays-Bas), <A
HREF="ftp://ftp.lip6.fr/pub/linux/sunsite/system/misc/"
TARGET="_top"
>ftp://ftp.lip6.fr/pub/linux/sunsite/system/misc/</A
> 
(France). Ce paquet contient <SPAN
CLASS="SYSTEMITEM"
>agetty</SPAN
> et 
<SPAN
CLASS="SYSTEMITEM"
>login</SPAN
>.</P
></LI
></UL
><P
>Pour résumer, il vous faut :</P
><P
></P
><UL
><LI
><P
>Une machine avec deux partitions distinctes d'environ 400 Mo et 
700 Mo respectivement, bien que vous puissiez sûrement vous en 
tirer avec un espace plus restreint. </P
></LI
><LI
><P
>Une distribution de Linux (par exemple, un CD Red Hat), et de quoi
l'installer (par exemple, un lecteur de CD).</P
></LI
><LI
><P
>Les archives tar de code source listées ci-dessus. (Le format tar permet 
de regrouper plusieurs fichiers en un seul. Un fichier tar peut être 
compressé.)</P
></LI
></UL
><P
>Je pars du principe que vous pouvez installer le système source vous-même,
sans aide de ma part. À partir de maintenant, je considère que c'est 
fait.</P
><P
>Les premiers pas de ce projet consistent à faire démarrer le noyau, et 
à le laisser « paniquer » (panic) car il ne trouve 
pas le programme <SPAN
CLASS="SYSTEMITEM"
>init</SPAN
>.
Cela signifie que nous allons devoir installer un noyau, et installer Lilo.
Pour que Lilo s'installe facilement, nous aurons besoin des fichiers 
spéciaux du répertoire <TT
CLASS="FILENAME"
>/dev</TT
> du 
système cible. Lilo en a besoin pour effectuer les accès bas niveau au 
disque, nécessaire pour écrire le secteur d'amorçage. 
<B
CLASS="COMMAND"
>MAKEDEV</B
> est le script qui crée ces fichiers spéciaux 
(vous pourriez bien sûr les recopier depuis le système source, mais ce 
serait tricher !). Mais d'abord, il nous faut un système de 
fichiers dans lequel les mettre.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN122"
>2. Le système de fichier</A
></H2
><P
>Notre nouveau système a besoin d'un système de fichiers pour vivre. 
Donc, il nous faut tout d'abord créer ce système de fichiers en 
utilisant <B
CLASS="COMMAND"
>mke2fs</B
>. Ensuite il faut le monter quelque 
part. Je vous suggère <TT
CLASS="FILENAME"
>/mnt/cible</TT
>. Dans ce qui va 
suivre, je considère que votre système cible se trouve à cet endroit. 
Vous pouvez gagner un peu de temps en ajoutant une entrée dans 
<TT
CLASS="FILENAME"
>/etc/fstab</TT
> de façon à ce que le montage de votre 
système de destination se fasse automatique lors du démarrage de votre 
système source.</P
><P
>Lorsque nous démarrerons le système cible, ce qui se trouve dans
<TT
CLASS="FILENAME"
>/mnt/cible</TT
> se trouvera alors dans 
<TT
CLASS="FILENAME"
>/</TT
> (la racine).</P
><P
>Nous avons besoin d'une structure de sous-répertoires sur la cible. Jetez un
&#339;il au standard de hiérarchie des fichiers (<I
CLASS="FOREIGNPHRASE"
>File 
Hierarchy Standard - FHS</I
>, voir la section <A
HREF="#LIENS"
>liens</A
>) pour trouver vous-même ce qu'elle devrait être, ou 
faites simplement un <B
CLASS="COMMAND"
>cd</B
> vers l'endroit où la cible 
est montée et tapez aveuglément :</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>mkdir bin boot dev etc home lib mnt root sbin tmp usr var
cd var; mkdir lock log run spool  
cd ../usr; mkdir bin include lib local sbin share src
cd share/; mkdir man; cd man 
mkdir man1 man2 man3 man4 man5 man6 man7 man8 man9</PRE
></FONT
></TD
></TR
></TABLE
><P
>Comme le standard de hiérarchie des fichiers et la plupart des paquets 
se contredisent en ce qui concerne l'endroit où les pages de manuel 
doivent se trouver, nous avons besoin d'un lien symbolique :</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>cd ..; ln -s share/man man</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN138"
>3. MAKEDEV</A
></H2
><P
>Nous mettrons le code source dans le répertoire 
<TT
CLASS="FILENAME"
>/usr/src</TT
> cible. Ainsi si votre 
système de fichiers cible est monté sur <TT
CLASS="FILENAME"
>/mnt/cible</TT
>, et que vos archives tar sont 
dans <TT
CLASS="FILENAME"
>/root</TT
>, il faudra 
faire :</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>cd /mnt/cible/usr/src
tar -xzvf /root/MAKEDEV-2.5.tar.gz</PRE
></FONT
></TD
></TR
></TABLE
><P
>Ne vous comportez pas en amateur fini en copiant les archives à 
l'endroit où vous allez les décompresser ;-)</P
><P
>En principe, lorsque vous installez un logiciel, vous l'installez sur le
système en fonctionnement. En l'occurrence, ce n'est pas notre intention,
nous souhaitons l'installer comme si /mnt/cible était la racine du 
système de fichiers. Les différents paquets ont différentes manières de 
vous laisser faire cela. Pour MAKEDEV, vous devez faire :</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>ROOT=/mnt/cible make install</PRE
></FONT
></TD
></TR
></TABLE
><P
>Vous devez rechercher ces options dans les fichiers README et INSTALL
ou faire un <B
CLASS="COMMAND"
>./configure --help</B
>.</P
><P
>Explorez le <TT
CLASS="FILENAME"
>Makefile</TT
> de MAKEDEV pour voir l'usage 
qu'il fait de la variable <VAR
CLASS="ENVAR"
>ROOT</VAR
>, que nous avons définie 
dans cette commande. Ensuite jetez un &#339;il à la page de manuel en 
faisant un <B
CLASS="COMMAND"
>man ./MAKEDEV.man</B
> pour voir comment il 
fonctionne. Vous découvrirez que la méthode que nous devons 
utiliser pour créer ces fichiers spéciaux consiste à faire un 
<B
CLASS="COMMAND"
>cd /mnt/cible/dev</B
> puis un <B
CLASS="COMMAND"
>./MAKEDEV 
generic</B
>. Faites un <B
CLASS="COMMAND"
>ls</B
> pour découvrir tous 
les merveilleux fichiers spéciaux qu'il a créé pour vous !</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN157"
>4. Le noyau</A
></H2
><P
>Ensuite, nous devons fabriquer un noyau. Je considère que vous l'avez déjà
fait, aussi serai-je bref. Il est plus facile d'installer Lilo si le noyau
censé être monté est déjà là. Retournez dans le répertoire <TT
CLASS="FILENAME"
>usr/src</TT
> de la cible, et extrayez-y les 
sources du noyau Linux. Entrez dans l'arborescence des sources 
(<B
CLASS="COMMAND"
>cd linux</B
>) et configurez le noyau, en utilisant votre 
méthode préférée, par exemple <B
CLASS="COMMAND"
>make menuconfig</B
>. Vous 
vous faciliterez grandement la vie si vous configurez un noyau sans 
module. Si vous choisissez d'avoir des modules, vous devrez éditer 
le fichier <TT
CLASS="FILENAME"
>Makefile</TT
>, trouver 
<VAR
CLASS="LITERAL"
>INSTALL_MOD_PATH</VAR
>, et lui affecter la 
valeur <TT
CLASS="FILENAME"
>/mnt/cible</TT
>.</P
><P
>Vous pouvez maintenant taper <B
CLASS="COMMAND"
>make dep</B
>, <B
CLASS="COMMAND"
>make 
bzImage</B
>, et si vous avez configuré des modules : 
<B
CLASS="COMMAND"
>make modules</B
>, <B
CLASS="COMMAND"
>make 
modules_install</B
>. Copiez le noyau 
<TT
CLASS="FILENAME"
>arch/i386/boot/bzImage</TT
> et le plan système 
<TT
CLASS="FILENAME"
>System.map</TT
> vers le répertoire d'amorçage de la 
cible <TT
CLASS="FILENAME"
>/mnt/cible/boot</TT
>, et nous 
seront prêts à installer Lilo.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN174"
>5. Lilo</A
></H2
><P
>Lilo est livré avec un script très bien conçu nommé 
<B
CLASS="COMMAND"
>QuickInst</B
>.
Décompressez les sources de Lilo dans le répertoire des sources du système
cible, lancez ce script par la commande
<B
CLASS="COMMAND"
>ROOT=/mnt/cible ./QuickInst</B
>. Il vous posera plusieurs questions
concernant la manière dont vous souhaitez que Lilo soit installé.</P
><P
>Puisque nous avons affecté à la variable <VAR
CLASS="ENVAR"
>ROOT</VAR
> la 
partition cible, les noms des fichiers que nous lui indiquons doivent 
être relatifs à cette partition. Donc, à la question du nom du noyau à 
lancer par défaut, répondez <TT
CLASS="FILENAME"
>/boot/bzImage</TT
>, et 
<EM
>non</EM
> <TT
CLASS="FILENAME"
>/mnt/cible/boot/bzImage</TT
>. </P
><P
>J'ai trouvé une erreur mineure dans le script, qui lui fait dire :</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>./QuickInst: /boot/bzImage: no such file </PRE
></FONT
></TD
></TR
></TABLE
><P
>Mais si vous vous contentez de l'ignorer, cela passe quand même.</P
><P
>Comment doit-on s'y prendre pour expliquer à 
<B
CLASS="COMMAND"
>QuickInst</B
> où installer le secteur d'amorçage ? 
Quand nous redémarrerons, nous voulons avoir le choix de démarrer le 
système source ou le système cible, ou encore n'importe quel autre 
système présent sur la machine. Et nous souhaitons que l'instance de
Lilo que nous mettons en place maintenant lance le noyau de notre nouveau
système. Comment réaliser ces deux choses ? Écartons-nous un moment 
du sujet et étudions la façon dont Lilo démarre DOS sur un système Linux 
en double-amorçage. Le fichier <TT
CLASS="FILENAME"
>lilo.conf</TT
> d'un tel 
système doit sûrement ressembler à ça.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>prompt  
timeout = 50
default = linux

image = /boot/bzImage 
	label  = linux
	root   = /dev/hda1
	read-only

other = /dev/hda2
	label = dos</PRE
></FONT
></TD
></TR
></TABLE
><P
>Si la machine est configurée de cette façon, alors le bloc de 
démarrage (<I
CLASS="FOREIGNPHRASE"
>Master Boot Record - MBR</I
>) est 
lu et chargé par le Bios, et lance le chargeur d'amorçage de Lilo 
(<I
CLASS="FOREIGNPHRASE"
>bootloader</I
>), qui affiche une invite de 
commande. Si vous tapez <VAR
CLASS="LITERAL"
>dos</VAR
> à cette invite, Lilo 
chargera le secteur d'amorçage de hda2, qui lancera DOS.</P
><P
>Ce que nous allons faire est exactement la même chose, à une 
différence près : le secteur d'amorçage de hda2 sera un autre 
secteur d'amorçage Lilo - celui-là même que 
<B
CLASS="COMMAND"
>QuickInst</B
> va installer. Donc le Lilo de la 
distribution Linux chargera le Lilo que nous avons construit, 
qui chargera le noyau que nous avons bâti. Vous verrez alors deux 
invites Lilo au redémarrage.</P
><P
>Pour raccourcir une longue histoire, lorsque <B
CLASS="COMMAND"
>QuickInst</B
>
vous demande où placer le secteur de boot, indiquez-lui l'endroit où se
trouve votre système de fichiers cible, par exemple <TT
CLASS="FILENAME"
>/dev/hda2</TT
>.</P
><P
>Maintenant modifiez le fichier <TT
CLASS="FILENAME"
>lilo.conf</TT
> de votre système source,
de façon à ce qu'il comprenne une ligne ressemblant à :</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>other = /dev/hda2
	label = cible</PRE
></FONT
></TD
></TR
></TABLE
><P
>Lancez <B
CLASS="COMMAND"
>lilo</B
>, et nous devrions être capables de faire 
notre premier démarrage sur le système cible.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN205"
>6. Glibc</A
></H2
><P
>L'étape suivante consiste à installer <SPAN
CLASS="SYSTEMITEM"
>init</SPAN
>, mais comme la plupart
des programmes qui tournent sous Linux, <SPAN
CLASS="SYSTEMITEM"
>init</SPAN
> utilise des fonctions
issues de la bibliothèque standard C GNU, glibc. Aussi 
l'installerons-nous en premier.</P
><P
>Glibc est un paquet très gros et très complexe. Il faut 90 heures pour 
le construire sur mon vieux 386sx / 16 avec 8 Mo de 
mémoire. Mais cela ne prend que 33 minutes sur mon Celeron 433 avec 
64 Mo de mémoire. Je pense que la quantité de mémoire est le 
principal critère dans notre cas. Si vous n'avez que 8 Mo de 
mémoire (ou - j'en tremble - encore moins !), préparez vous à une 
très longue compilation.</P
><P
>La documentation d'installation de glibc recommande une construction dans un
répertoire distinct. Cela vous permettra de recommencer facilement, en
supprimant simplement ce répertoire. Cela vous permet aussi d'économiser
265 Mo d'espace disque.</P
><P
>Comme d'habitude, décompressez l'archive 
<TT
CLASS="FILENAME"
>glibc-2.1.3.tar.gz</TT
> (ou n'importe quelle autre 
version) dans <TT
CLASS="FILENAME"
>/mnt/cible/usr/src</TT
>. 
À présent, nous devons décompresser les extensions dans le répertoire de 
glibc. Donc, faites un <B
CLASS="COMMAND"
>cd glibc-2.1.3</B
>, puis 
décompressez à cet endroit les archives 
<TT
CLASS="FILENAME"
>glibc-crypt-2.1.3.tar.gz</TT
> et 
<TT
CLASS="FILENAME"
>glibc-linuxthreads-2.1.3.tar.gz</TT
>.</P
><P
>Maintenant, nous pouvons créer le répertoire de construction, configurer,
construire et installer glibc. Voici les commandes que j'ai utilisées, 
mais relisez vous-même la documentation et assurez-vous de faire ce qui 
est le plus approprié dans votre environnement. Toutefois, avant de 
faire tout cela, vous voudrez sans doute connaître l'espace disque qu'il 
vous reste en faisant un <B
CLASS="COMMAND"
>df</B
>. Vous pourrez en faire un 
autre après avoir construit et installé glibc pour en déduire son 
volume.</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>cd ..
mkdir glibc-build
../glibc-2.1.3/configure --enable-add-ons --prefix=/usr
make
make install_root=/mnt/cible install</PRE
></FONT
></TD
></TR
></TABLE
><P
>Remarquez que nous avons ici encore une autre façon de dire au paquet 
l'endroit où s'installer.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN222"
>7. SysVinit</A
></H2
><P
>Fabriquer et installer les binaires de SysVinit est assez simple. Il y a 
juste une petit manipulation à faire dans le fichier 
<TT
CLASS="FILENAME"
>Makefile</TT
>, situé dans le sous-répertoire <TT
CLASS="FILENAME"
>src/</TT
>. Dans les 4 dernières lignes, vous 
devez placer <VAR
CLASS="LITERAL"
>$(ROOT)</VAR
> juste devant 
<VAR
CLASS="LITERAL"
>/dev/initctl</VAR
>. Par exemple :</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>@ if [ ! -p /dev/initctl ]; then \</PRE
></FONT
></TD
></TR
></TABLE
><P
>devient :</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>@ if [ ! -p <STRONG
>$(ROOT)</STRONG
>/dev/initctl ]; then \</PRE
></FONT
></TD
></TR
></TABLE
><P
>Le fichier spécial <TT
CLASS="FILENAME"
>initctl</TT
> est un moyen de 
communication avec init. Par exemple, la page de manuel d'init indique 
que ce fichier doit être utilisé de préférence au signal 
<VAR
CLASS="SYMBOL"
>SIGPWR</VAR
> pour demander à init d'arrêter le système 
lorsque l'alimentation électrique à basculé sur batterie suite à une 
panne de courant. Cette manipulation permet de s'assurer que ce fichier 
se trouvera dans le système cible, et non dans le système source.</P
><P
>Une fois que c'est fait, placez-vous dans le sous-répertoire <TT
CLASS="FILENAME"
>src</TT
>, et entrez :</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>make
ROOT=/mnt/cible make install</PRE
></FONT
></TD
></TR
></TABLE
><P
>Il existe aussi beaucoup de scripts associés à 
<SPAN
CLASS="SYSTEMITEM"
>init</SPAN
>. Il y a des scripts d'exemple fournis dans 
le paquet SysVinit, qui fonctionnent bien. Mais vous devez les installer 
manuellement. Ils sont rangés hiérarchiquement sous <TT
CLASS="FILENAME"
>debian/etc</TT
> dans l'arborescence du code 
source. Vous pouvez recopier toute cette hiérarchie dans le répertoire
<TT
CLASS="FILENAME"
>etc</TT
> du système cible, avec une 
commande du style <B
CLASS="COMMAND"
>cd ../debian/etc; cp -r * 
/mnt/cible/etc</B
>. Évidement, vous voudrez les examiner avant de 
les recopier.</P
><P
>Tout est désormais en place pour permettre au noyau cible de lancer
<SPAN
CLASS="SYSTEMITEM"
>init</SPAN
> au redémarrage. Le problème, cette fois, viendra des scripts
qui ne pourront être exécutés car <SPAN
CLASS="SYSTEMITEM"
>bash</SPAN
> ne sera pas là pour les
interpréter. <SPAN
CLASS="SYSTEMITEM"
>init</SPAN
> tentera également de lancer des <SPAN
CLASS="SYSTEMITEM"
>getty</SPAN
>,
qui sont eux aussi inexistants. Redémarrez le système, et assurez-vous 
que tout le reste fonctionne correctement.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN249"
>8. Ncurses</A
></H2
><P
>L'étape suivante consiste à mettre Bash en place, mais bash a besoin de
ncurses, aussi devons-nous installer celui-ci en premier. Ncurses remplace
termcap dans la manière de gérer les écrans texte, mais apporte également
une compatibilité descendante en prenant en charge les appels termcap. 
Dans l'objectif d'avoir un système moderne, simple et propre, je pense 
que le mieux est de désactiver l'ancienne méthode termcap. Vous pourriez 
par la suite rencontrer des problèmes avec des applications utilisant 
termcap, mais au moins vous connaîtrez les éléments qui l'utilisent. Si 
vous en avez besoin, vous pourrez recompiler ncurses avec prise en 
charge de termcap.</P
><P
>Les commandes que j'ai utilisées sont :</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>./configure --prefix=/usr --with-install-prefix=/mnt/cible --with-shared --disable-termcap
make
make install</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN254"
>9. Bash</A
></H2
><P
>Il m'a fallu beaucoup de lecture, de réflexion, de tests, et d'erreurs pour
que Bash s'installe là où je pensais qu'il devait aller. Les options de
configuration que j'ai utilisées sont :</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>./configure --prefix=/mnt/cible/usr/local --exec-prefix=/mnt/cible \
            --with-curses </PRE
></FONT
></TD
></TR
></TABLE
><P
>Une fois que vous aurez construit et installé Bash, vous devrez créer un 
lien symbolique comme ceci : <B
CLASS="COMMAND"
>cd /mnt/cible/bin; ln -s bash 
sh</B
>. Cela est dû au fait que les scripts débutent généralement 
par une ligne comme celle-ci :</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>#!/bin/sh</PRE
></FONT
></TD
></TR
></TABLE
><P
>Si vous n'avez ce lien symbolique, les scripts ne fonctionneront pas, car
ils chercheront <VAR
CLASS="LITERAL"
>/bin/sh</VAR
> et non <VAR
CLASS="LITERAL"
>/bin/bash</VAR
>. </P
><P
>Arrivé à ce point, vous pouvez redémarrer si vous le souhaitez. Lors 
du redémarrage, vous devriez remarquer que, maintenant, les scripts 
s'exécutent. Cependant, vous ne pourrez pas vous connecter, car il n'y 
pas encore de programmes <SPAN
CLASS="SYSTEMITEM"
>getty</SPAN
> ou 
<SPAN
CLASS="SYSTEMITEM"
>login</SPAN
>.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN267"
>10. Util-linux (getty et login)</A
></H2
><P
>Le paquet util-linux contient <SPAN
CLASS="SYSTEMITEM"
>agetty</SPAN
> et 
<SPAN
CLASS="SYSTEMITEM"
>login</SPAN
>. Nous avons besoin des deux pour 
pouvoir nous connecter et obtenir l'invite de commande de bash. Après 
l'avoir installé, faites un lien symbolique depuis 
<TT
CLASS="FILENAME"
>agetty</TT
> vers <TT
CLASS="FILENAME"
>getty</TT
> dans le 
répertoire <TT
CLASS="FILENAME"
>/sbin</TT
> du système 
cible. <SPAN
CLASS="SYSTEMITEM"
>getty</SPAN
> est un des programmes censés se 
trouver sur tous les systèmes de type Unix, donc faire un lien est une 
meilleure idée que de modifier <TT
CLASS="FILENAME"
>inittab</TT
> pour qu'il 
lance <SPAN
CLASS="SYSTEMITEM"
>agetty</SPAN
>.</P
><P
>Il me reste un problème avec la compilation d'util-linux. Le paquet
contient également le programme <VAR
CLASS="LITERAL"
>more</VAR
>, et, pour ce 
programme, je n'ai pas été capable de persuader <VAR
CLASS="LITERAL"
>make</VAR
> 
de réaliser l'édition de liens avec le ncurses 5 du système cible au 
lieu du ncurses 4 du système source.</P
><P
>Vous aurez aussi besoin d'un fichier <TT
CLASS="FILENAME"
>/etc/passwd</TT
> 
sur le système cible. C'est l'endroit où le programme 
<SPAN
CLASS="SYSTEMITEM"
>login</SPAN
> ira vérifier si vous avez le droit de 
vous connecter. Comme il ne s'agit que d'un système jouet, vous pouvez 
vous permettre à ce niveau des choses scandaleuses, comme de ne définir 
que l'utilisateur root, sans mot de passe ! Mettez le simplement 
dans le fichier <TT
CLASS="FILENAME"
>/etc/passwd</TT
> du système cible :</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>root::0:0:root:/root:/bin/bash</PRE
></FONT
></TD
></TR
></TABLE
><P
>Les champs sont séparés par des deux-points, et correspondent, de gauche 
à droite, à l'identifiant de l'utilisateur, à son mot de passe 
(chiffré), à son numéro d'utilisateur, à son numéro de groupe, à son nom 
complet, à son répertoire personnel, et à son interpréteur de 
commandes par défaut.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN287"
>11. Sh-utils</A
></H2
><P
>Le dernier paquet dont nous ayons besoin est le sh-utils GNU. Le seul 
programme nécessaire à ce niveau est <VAR
CLASS="LITERAL"
>stty</VAR
>, qui est 
utilisé dans <TT
CLASS="FILENAME"
>/etc/init.d/rc</TT
>, 
lui-même utilisé pour changer de niveau d'exécution et entrer dans le 
niveau initial. En fait, je possède et ai utilisé un paquet qui ne 
contient que <VAR
CLASS="LITERAL"
>stty</VAR
> mais je ne peux me souvenir d'où
il vient. Il vaut mieux utiliser le paquet GNU, car il contient d'autres
choses dont vous aurez besoin si vous voulez les ajouter au système pour 
le rendre vraiment utilisable.</P
><P
>Bien, ça y est. Vous devriez maintenant avoir un système qui va 
démarrer et vous donner l'invite de connexion. Saisissez-y 
<VAR
CLASS="LITERAL"
>root</VAR
>, et vous devriez accéder à l'interpréteur 
de commandes. Vous ne pourrez pas faire grand chose avec, il n'y a même 
pas la commande <B
CLASS="COMMAND"
>ls</B
> pour voir votre travail. Tapez 
deux fois sur la touche <B
CLASS="KEYCAP"
>Tab</B
> pour voir les commandes 
disponibles. C'est la chose la plus intéressante que j'ai trouvée à 
faire avec.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN297"
>12. Rendre le système plus utilisable</A
></H2
><P
>Il semblerait que nous ayons là un système plutôt inutilisable. Mais en
réalité, nous ne sommes pas très loin de pouvoir commencer à
travailler avec. L'une des premières choses à faire est de rendre le
système de fichiers racine accessible en lecture et en écriture. Il y a 
un script issu du paquet SysVinit, 
<SPAN
CLASS="SYSTEMITEM"
>/etc/init.d/mountall.sh</SPAN
> qui s'occupe de cela, 
et effectue un <B
CLASS="COMMAND"
>mount -a</B
> pour monter automatiquement 
tout ce qui est spécifié dans le fichier 
<TT
CLASS="FILENAME"
>/etc/fstab</TT
>. Mettez un lien symbolique du genre 
<TT
CLASS="FILENAME"
>S05mountall</TT
> vers lui dans le répertoire <TT
CLASS="FILENAME"
>etc/rc2.d</TT
> du système cible.</P
><P
>Il se peut que ce script utilise des commandes que vous n'avez pas encore
installées. Si c'est le cas, trouvez le paquet qui contient ces commandes et
installez-le. Voyez la section <A
HREF="#FINDING"
>astuces diverses</A
> pour avoir des indications sur la marche à suivre pour 
trouver ces paquets.</P
><P
>Regardez les autres scripts de <TT
CLASS="FILENAME"
>/etc/init.d</TT
>. La plupart d'entre-eux doit 
être incluse dans tout système sérieux. Ajoutez-les un à un, et 
assurez-vous que tout se lance en douceur avant d'en ajouter d'autres.</P
><P
>Lisez le standard de hiérarchie des fichiers (voir section <A
HREF="#LIENS"
>liens</A
>). Il contient une liste des commandes qui devraient 
être dans <TT
CLASS="FILENAME"
>/bin</TT
> et <TT
CLASS="FILENAME"
>/sbin</TT
>. Assurez-vous que toutes ces 
commandes sont installées sur votre système. Mieux encore, trouvez la 
documentation Posix qui spécifie tout cela.</P
><P
>À partir de maintenant, il n'est plus question que d'ajouter de plus en
plus de paquets, jusqu'à ce que tout ce que vous souhaitez avoir se 
trouve sur votre système. Installez les outils de construction comme 
<VAR
CLASS="LITERAL"
>make</VAR
> et <VAR
CLASS="LITERAL"
>gcc</VAR
> le plus tôt possible. 
Une fois que cela sera fait, vous pourrez faire construire le système 
cible par lui-même, ce qui est bien moins complexe.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN316"
>13. Informations complémentaires</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="FINDING"
>13.1. Astuces diverses</A
></H3
><P
>Si vous avez une commande appelée <B
CLASS="COMMAND"
>machin</B
>
sur un système Linux avec RPM, et souhaitez avoir des indications sur
l'endroit où trouver les sources, vous pouvez utiliser la commande :</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>rpm -qif `which machin`</PRE
></FONT
></TD
></TR
></TABLE
><P
>Et si vous avez un CD de sources Red Hat, vous pouvez installer le code
source avec</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="PROGRAMLISTING"
>rpm -i /mnt/cdrom/SRPMS/<VAR
CLASS="REPLACEABLE"
>ce.qu.il.vient.de.dire-1.2.srpm</VAR
></PRE
></FONT
></TD
></TR
></TABLE
><P
>Ceci mettra l'archive, avec les patches Redhats éventuels dans
<TT
CLASS="FILENAME"
>/usr/src/redhat/SOURCES</TT
>. </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="LIENS"
>13.2. Liens</A
></H3
><P
></P
><UL
><LI
><P
>Il existe un guide pratique sur la manière de construire des logiciels à 
partir de leurs sources, le <A
HREF="http://www.traduc.org/docs/HOWTO/lecture/Software-Building-HOWTO.html"
TARGET="_top"
>Software Building HOWTO</A
>.</P
></LI
><LI
><P
>Il existe aussi un guide pratique sur la manière de construire un 
système Linux à partir de zéro. Il met l'accent sur la construction d'un 
système réellement utilisable, plutôt que d'être un simple 
exercice : <A
HREF="http://www.fr.linuxfromscratch.org/"
TARGET="_top"
>Comment 
faire un système Linux à partir de zéro</A
> (<I
CLASS="FOREIGNPHRASE"
>Linux 
from scratch - LFS</I
>).</P
></LI
><LI
><P
>Le <A
HREF="http://www.pathname.com/fhs/"
TARGET="_top"
>standard de hiérarchie
du système de fichier Unix (FHS)</A
>. Ce standard décrit quels 
éléments doivent aller à quels endroits dans un système de fichier Unix, 
et pourquoi. Il indique également le contenu minimum requis des 
répertoires <TT
CLASS="FILENAME"
>/bin</TT
>, <TT
CLASS="FILENAME"
>/sbin</TT
>, et cætera. C'est une bonne référence 
si votre but est de réaliser un système minimal, mais fonctionnel. Il 
en existe une <A
HREF="http://ftp.traduc.org/documents/fhs/"
TARGET="_top"
>version 
française</A
>.</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN344"
>14. Section administrative</A
></H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="AEN346"
>14.1. Copyright</A
></H3
><P
>Copyright © 1999, 2000 Greg O'Keefe. Vous êtes libre de
l'utiliser, le copier, le distribuer ou le modifier, sans obligation, selon
les termes de la licence publique générale GNU (GPL : <A
HREF="http://www.gnu.org/copyleft/gpl.html"
TARGET="_top"
>GNU General Public 
Licence</A
>). Merci de citer l'auteur si vous utilisez tout ou 
partie de ce document dans un autre.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN350"
>14.2. Page principale</A
></H3
><P
>Les mises à jour de ce document évoluent sur <A
HREF="http://www.netspace.net.au/~gok/power2bash/"
TARGET="_top"
>From Powerup 
To Bash Prompt</A
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN354"
>14.3. Réactions</A
></H3
><P
>J'aimerais recevoir vos commentaires, critiques et suggestions. Veuillez
s'il vous plaît me les envoyer en anglais à Greg O'Keefe 
<CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:gcokeefe@postoffice.utas.edu.au"
>gcokeefe@postoffice.utas.edu.au</A
>&#62;</CODE
></P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="ACKNOWLEDGE"
>14.4. Références et remerciements</A
></H3
><P
>Les noms de produits cités sont des marques déposées par leurs
propriétaires respectifs, et considérés par cette note comme reconnus
comme tels.</P
><P
>Il y a quelques personnes que je voudrais remercier, pour m'avoir aidé à
réaliser tout ceci.</P
><P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Michael Emery</DT
><DD
><P
>Pour m'avoir rappelé Unios.</P
></DD
><DT
>Tim Little</DT
><DD
><P
>Pour de bonnes indications concernant <TT
CLASS="FILENAME"
>/etc/passwd</TT
></P
></DD
><DT
>sPaKr dans #linux sur efnet</DT
><DD
><P
>Qui a soupçonné l'utilisation de <TT
CLASS="FILENAME"
>/etc/services</TT
> par syslog,
et m'a fait connaître la phrase « rolling your own »
(« fabriquez votre propre système ») 
pour  décrire la construction d'un système à partir des sources.</P
></DD
><DT
>Alex Aitkin</DT
><DD
><P
>Pour avoir porté Vico et son « verum ipsum factum » 
(La compréhension découle de l'expérience) à mon attention.</P
></DD
><DT
>Dennis Scott</DT
><DD
><P
>Pour avoir corrigé mon arithmétique hexadécimale.</P
></DD
><DT
>jdd</DT
><DD
><P
>Pour avoir mis en évidence quelques erreurs typographiques.</P
></DD
></DL
></DIV
></P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN390"
>14.5. Historique des changements</A
></H3
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>0.8 -&#62; 0.9</DT
><DD
><P
>Ajout de la manipulation du fichier <TT
CLASS="FILENAME"
>makefile</TT
> de 
sysvinit. Cette information est due à Gerard Beekmans, connu pour le 
« Linux From Scratch ».</P
></DD
><DT
>0.8</DT
><DD
><P
>Version initiale. Séparation de ce HOWTO du « From 
PowerUp to Bash Prompt ».</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN402"
>14.6. Améliorations prévues</A
></H3
><P
></P
><UL
><LI
><P
>Conversion au format DocBook.</P
></LI
></UL
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="ADAPTATION-FRANCAISE"
>14.7. Adaptation française</A
></H3
><DIV
CLASS="SECT3"
><H4
CLASS="SECT3"
><A
NAME="AEN409"
>14.7.1. Traduction</A
></H4
><P
>La traduction française de ce document a été réalisée par Dominique van 
den Broeck <CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:dvandenbroeck@free.fr"
>dvandenbroeck@free.fr</A
>&#62;</CODE
>, décembre 2000 (v0.9).</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN413"
>14.7.2. Relecture</A
></H4
><P
>La relecture de ce document a été réalisée par Jean-Philippe Guérard 
<CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:jean-philippe.guerard@laposte.net"
>jean-philippe.guerard@laposte.net</A
>&#62;</CODE
>. Les version 
précédentes ont été relues par Guillaume Allègre et Anthony Boureux.</P
></DIV
></DIV
></DIV
></DIV
></BODY
></HTML
>