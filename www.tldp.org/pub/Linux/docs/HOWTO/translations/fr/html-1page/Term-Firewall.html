<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.21">
 <TITLE>Mini-HOWTO Term-Firewall</TITLE>
</HEAD>
<BODY>
<H1>Mini-HOWTO Term-Firewall</H1>

<H2>Barak Pearlmutter, <CODE>barak.pearlmutter@alumni.cs.cmu.edu</CODE></H2>22 Mai 1996
<HR>
<EM>(Version française réalisée par Eric Dumas, <CODE>dumas@freenix.fr</CODE>,
<CODE>dumas@Linux.EU.Org</CODE>, 1er Juillet 1997).
Ce document décrit comme utiliser Term pour traverser un Firewall Internet, ce que vous n'êtes pas supposé pouvoir faire.</EM>
<HR>
<H2><A NAME="s1">1. Avertissements (Important !) </A></H2>




<P>Je décline sur le présent document toute responsabilité d'une quelconque
application de ce qui va suivre. Si cela échoue de n'importe quelle
manière, c'est votre problème. Ce n'est pas ma faute. Si vous ne
comprenez pas les risques qui découlent de cette méthode, ne l'utilisez
pas. Si vous employez cette méthode et que cela permet
à des pirates vicieux de pénétrer dans votre système informatique et
que cela vous coûte votre travail et à votre entreprise des millions
de dollars, ce n'est que de votre faute. Ne venez pas pleurer.</P>

<H2><A NAME="s2">2. Copyright </A></H2>


<P>Sauf contre-indication, les documents HOWTO Linux sont 
copyrightés par leurs auteurs respectifs. Les documents Linux
HOWTO peuvent être reproduits et diffusés totalement ou en
partie, sous n'importe quel support physique ou électronique
du moment ou la notice légale se trouve sur toute copie.
Les diffusions commerciales sont autorisées et encouragées. Toutefois,
l'auteur souhaiterait être tenu au courant de telles diffusions.</P>
<P>Toute traduction, travail dérivé contenant n'importe quel 
document HOWTO Linux doit être convert par cette note légale.
Ainsi, vous ne pouvez pas créer un document dérivé d'un HOWTO
et ajouter des restrictions sur sa diffusion. Des exceptions
à ces règles peuvent être éventuellement acceptées dans 
certaines conditions. Contactez le coordinateur
des HOWTO à l'adresse qui suit.</P>
<P>En résumant, nous souhaitons favoriser la dissémination
de ces informations <EM>via</EM> le maximum de moyens
de communications. Toutefois, nous souhaitons garder un copyright
sur ces documents et souhaiterions être tenu au courant de 
toute initiative de diffusion de ces documents.</P>
<P>Si vous avez des questions, contactez Greg Hankins, le coordinateur
des HOWTO Linux à gregh@sunsite.unc.edu par courrier 
électronique ou par téléphone au 1 404 853 9989.</P>

<H2><A NAME="s3">3. Introduction </A></H2>


<P>Le programme <CODE>term</CODE> est normalement utilisé sur une ligne
série ou modem, pour permettre à plusieurs services machine-à-machine
de communiquer grâce à cette simple connexion série. Toutefois,
il est assez utile quelquefois d'établir une connexion
entre deux machines communiquant par <CODE>telnet</CODE> avec <CODE>term</CODE>.</P>
<P>L'utilisation la plus intéressante réside dans la connexion de deux
machines séparées par des <I>firewalls</I> ou par des serveurs
<I>socks</I>.
Les <I>firewalls</I> permettent l'établissement de connexions à travers
eux-mêmes, typiquement en utilisant le protocole <I>socks</I>. 
Ce dernier permet aux machines du réseau interne de se connecter à 
l'extérieur, et
oblige les utilisateurs extérieurs à se connecter en premier sur la
machine passerelle qui leur demande un mot de passe.
Ces <I>firewalls</I> rendent impossible, par exemple, la communication
entre un client X sur une machine intérieure et un serveur extérieur.
Mais, en configurant une connexion <CODE>term</CODE>, ces restrictions peuvent
être contournées assez facilement, au niveau de l'utilisateur.</P>

<H2><A NAME="s4">4. Mise en oeuvre générale </A></H2>


<P>Configurer une connexion <CODE>term</CODE> par-dessus une session 
<CODE>telnet</CODE> se fait en deux phases.</P>
<P>Dans un premier temps, votre client habituel <CODE>telnet</CODE> est
utilisé pour configurer une connexion <CODE>telnet</CODE> et pour se 
connecter.
Ensuite, le client <CODE>telnet</CODE> est mis en sommeil, et fait en sorte que
la connexion <CODE>telnet</CODE> soit transmise à <CODE>term</CODE>.</P>


<H2><A NAME="s5">5. Procédure détaillée </A></H2>


<P>En détail, la marche à suivre est la suivante :</P>
<P>
<OL>
<LI> A partir d'une machine à l'intérieur du <I>firewall</I>,
se connecter par <CODE>telnet</CODE> à l'extérieur de celui-ci et s'y loger.
</LI>
<LI> Sauf si vous êtes sous <B>Linux</B> et que vous
utilisez le système de fichiers <I>/proc</I> (voir ci-dessous),
vérifiez que votre shell est du genre <CODE>sh</CODE>. C.à.d. que
votre shell par défaut soit une variante de <CODE>csh</CODE>. Appelez
<CODE>telnet</CODE> par
<CODE>(setenv SHELL /bin/sh; telnet machine.la-bas.dehors)</CODE>.
</LI>
<LI>Après s'être logé, lancer la commande sur la machine
de l'extérieur :
<CODE>term -r -n off telnet</CODE>.</LI>
</OL>
</P>
<P>Maintenant revenez à l'invite <CODE>telnet</CODE> sur la machine locale,
en utilisant le caractère d'échappement <CODE> ^] </CODE> (ou celui que vous
voulez), puis utilisez la commande de <CODE>telnet</CODE> pour exécuter une
commande shell <CODE> ! </CODE> pour lancer <CODE>term</CODE> :</P>
<P>
<PRE>
telnet> ! term -n on telnet &lt;&amp;3 >&amp;3
</PRE>
</P>
<P><I>Et voilà !!!</I> (Ndt : En français dans le texte).</P>
<P>(Si vous possédez une autre version de <CODE>telnet</CODE>, vous risquez 
d'avoir
à utiliser d'autres descripteurs de fichiers que 3. C'est facile
à déterminer en utilisant trace. Mais 3 semble fonctionner sur tous les
<CODE>telnet</CODE> de type bsd que j'ai testés. J'ai également
essayé sous Sun OS 4.x et les distributions <B>Linux</B> standard.)</P>
<P>Certains clients telnet ne possèdent pas de caractère d'échapement !.  
Par exemple, client telnet diffusé avec la Slackware 3.0 en fait partie.
Les sources de ce client sont sensés provenir de 
ftp://ftp.cdrom.com:/pub/linux/slackware-3.0/source/n/tcpip/NetKit-B-0.05.tar.gz,
paquetage qui contient le caractère d'échapement. Une solution assez simple
est de récupérer ces sources et de les recompiler. Je n'y suis malheureusement
pas arriver. De plus, si vous êtes à l'intérieur d'un firewall socks, vous
devrez avoir un client telnet à la SOCKS. J'ai réussi à 
compiler un tel cient en utilisant 
ftp://ftp.nec.com/pub/security/socks.cstc/socks.cstc.4.2.tar.gz
ou si vous êtes à l'extérieur des USA, 
ftp://ftp.nec.com/pub/security/socks.cstc/export.socks.cstc.4.2.tar.gz</P>
<P>Autrement, sous <B>Linux</B> version 1.2.13 ou précédentes,
vous pouvez mettre <CODE>telnet</CODE> en
sommeil avec <CODE> ^]^z </CODE>, récupérer son pid et lancer :</P>
<P>
<PRE>
   term -n on -v /proc/ &lt; telnetpid > /fd/3 telnet
</PRE>
</P>
<P>Cela ne fonctionne plus avec les noyaux 1.3 et supérieur,
qui ont vérouillé certaines failles de sécurité pour éviter 
les accès à des descripteurs de fichiers n'appartenant pas
au propriétaire du processus ou à ses fils.</P>

<H2><A NAME="s6">6. Sockets pour <CODE>term</CODE> multiples </A></H2>


<P>C'est une bonne idée de donner un nom explicite à la socket de 
<CODE>term</CODE>.
C'est l'argument donné à <CODE>telnet</CODE> dans la ligne de commande
ci-dessus. A moins que vous n'ayez la variable d'environnement
TERMSERVER positionnée à <CODE>telnet</CODE>,
vous pouvez appeler les clients avec le paramètre <CODE>-t</CODE>, 
c'est-à-dire :
<CODE>trsh -t telnet</CODE>.</P>


<H2><A NAME="s7">7. Le fichier d'initialisation .term/termrc.telnet </A></H2>


<P>J'ai attendu que la ligne soit claire en utilisant un
vérficateur de ligne sur ce média. J'espérais qu'il soit totalement
transparent, mais cela semble impossible. Toutefois, le seul caractère
perturbant semble être le 255. Le fichier <CODE> /.term/termrc.telnet</CODE>
que j'emploie (le fichier <CODE>.telnet</CODE> est le nom de la connexion
<CODE>term</CODE>, cf. supra) contient :</P>
<P>
<PRE>
baudrate off
escape 255
ignore 255
timeout 600
</PRE>
</P>
<P>Il peut être amélioré en trichant, j'ai un débit de seulement 30.000 cps
(caractères par secondes) pour une connexion longue distance à-travers
un <I>firewall</I> lent. FTP peut aller jusqu'à 100.000 cps en suivant
le
même chemin. Une vitesse en bps (bits par seconde) réaliste peut éviter
quelques temps morts.</P>

<H2><A NAME="s8">8. Administration </A></H2>


<P>Manifestement, si vous attaquez de l'extérieur du <I>firewall</I>,
et que vous employez une carte avec un identificateur sécurisé ou
quelque chose de ce genre, vous voudrez sûrement inverser les rôles des
serveurs de connexion et local (si vous ne comprennez pas
ce que cela signifie, vous n'êtes peut-être pas assez familier avec
<CODE>term</CODE> pour utiliser l'astuce décrite dans ce document d'une 
manière responsable).</P>


<H2><A NAME="s9">9. Securité </A></H2>


<P>Ce n'est rien moins qu'une faille que la possibilité d'avoir
une connexion <CODE>telnet</CODE> détournée sur une machine non sécurisée
de l'extérieur.
Le premier risque supplémentaire provient des personnes capables 
d'utiliser
la socket <CODE>term</CODE> que vous avez configurée sans que vous soyez au
courant. Donc, soyez prudents (personnellement, je fais cela sur une
machine externe que je sais être sécurisée.
Pour être plus précis, un portable sous <B>Linux</B> que
j'administre moi-même et qui n'accepte aucune connexion de l'extérieur).</P>
<P>Une autre possibilité est d'ajouter <CODE>socket off</CODE> 
dans <CODE>~/.term/termrc.telnet</CODE> ou ajouter
<CODE>-u off</CODE>. Cela évide que la socket soit accessible
du site distant, avec une perte de fonctionnalité assez mineure.</P>


<H2><A NAME="s10">10. Mode <CODE>telnet</CODE> </A></H2>


<P>Vérifiez que le démon <CODE>telnetd</CODE> distant n'est pas dans un
mauvais mode sept bits. Si c'est le cas, vous devez l'indiquer à 
<CODE>term</CODE>
lorsque vous le lancez en ajoutant un <CODE>-a</CODE> sur la ligne de commande
(j'emploie de temps en temps un <CODE>^] telnet> set outbin</CODE>
ou un <CODE>set bin</CODE> ou bien, je lance <CODE>telnet</CODE> avec
l'option <I>-8</I> pour forcer la connexion en mode 8 bits).</P>


<H2><A NAME="s11">11. Bugs et mes souhaits concerant term </A></H2>


<P>Le programme de vérification de ligne a de temps en temps quelques problèmes
pour contrôler la connexion <CODE>telnet</CODE>. Cela provient parfois
du fait qu'il ne vérifie pas le code de retour de l'appel <CODE>read()</CODE>.
Pour des connexions réseau, cet appel peut retourner le code d'erreur
-1 avec <I>EINTR</I> (interrompu) ou <I>EAGAIN</I> (reéssayer).
Manifestement, cela serait une bonne chose que cela soit vérifié.</P>
<P>Un certain nombre de caractéristiques pourraient faciliter
l'utilisation de <CODE>term</CODE> sur <CODE>telnet</CODE>. Cela provient
essentiellement d'une hypothèse qui a influencé le développement de
<CODE>term</CODE>, qui est que la connexion dispose d'une largeur de bande
faible, d'une latence réduite et qu'elle est quelque peu bruitée.</P>
<P>Une connexion <CODE>telnet</CODE> possède en général une bande passante assez
importante, une grande latence et qui contient peu d'erreurs. Cela signifie
que la connexion pourrait être mieux utilisée si :
<OL>
<LI> la taille maximale de la fenêtre était augmentée, bien
au-delà de la limite imposée par la formule <I>N_PACKETS/2 = 16</I>
de <CODE>term</CODE></LI>
<LI> une option pour désactiver l'envoi et la vérification
du <I>checksum</I> des paquets était implémentée</LI>
<LI> de plus grands paquets étaient permis lorsque cela
est approprié.</LI>
</OL>
</P>
<P>Egalement, pour améliorer la sécurité, il serait sympathique d'avoir 
une
option dans <CODE>term</CODE> pour afficher la liste des connexions
réalisées par la socket dans un fichier ou sur stderr, ou bien dans
les deux. Cela permettrait de vérifier si une connexion <CODE>term</CODE> a
été corrompue par des pirates situés du côté non sécurisé de 
la machine.</P>

<H2><A NAME="s12">12. Trucs qui semblent ne pas fonctionner</A></H2>


<P>Quelques clients et serveurs <CODE>telnet</CODE> acceptent d'encoder leurs
communications pour tromper la surveillance sur réseau. Malheureusement,
la méthode employée ci-dessus (en utilisant la connexion réseau que le
client <CODE>telnet</CODE> a configuré pendant que l'autre client est en 
attente) ne fonctionne pas dans ce cas.
Au lieu de cela, il doit réellement traverser le client <CODE>telnet</CODE>,
donc ne peut réaliser l'encodage. Il semble qu'il faille modifier
que le client, pour y a jouter une commande qui lance un processus avec
leurs stdin et stdout connectés au <CODE>telnet</CODE> en cours.
Cela serait également utile pour des processus de connexion
automatiques, peut-être quelqu'un l'a-t-il déjà fait.</P>

<H2><A NAME="s13">13. Sources</A></H2>


<P>J'ai légèrement consulté la bibliothèque Term. Les détails
ainsi que les patches à SOCKS sont disponibles en les demandant à
Steven Danz (danz@wv.mentorg.com).</P>

<H2><A NAME="s14">14. Remerciement</A></H2>


<P>Mes remerciements à 
<UL>
<LI>Gary Flake (flake@scr.siemens.com)</LI>
<LI>Bill Riemers (bcr@physics.purdue.edu)</LI>
<LI>Greg Louis (glouis@dynamicro.on.ca)</LI>
</UL>
</P>



<H2><A NAME="s15">15. Copie supplémentaire des avertissements -Lisez-le !</A></H2>


<P>Je décline sur le présent document toute responsabilité d'une quelconque
application de ce qui a été exposé. Si cela échoue de n'importe quelle
manière, c'est votre problème. Ce n'est pas ma faute. Si vous ne
comprenez pas les risques qui découlent de cette méthode, ne l'utilisez
pas. Si l'emploi de cette méthode permet à des pirates vicieux de
pénétrer dans votre système informatique et
que cela vous côte votre travail et à votre entreprise des millions
de dollars, ce n'est que de votre faute. Ne venez pas pleurer.</P>

</BODY>
</HTML>
