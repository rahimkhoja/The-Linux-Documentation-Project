<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Petit guide de VB6 vers Tcl</title><link rel="stylesheet" href="style.css" type="text/css"/><meta name="generator" content="DocBook XSL Stylesheets V1.75.1"/><meta name="description" content="Un tour de Tcl en 15 minutes pour programmeurs Visual Basic et VBScript."/></head><body><div xml:lang="fr" class="article" title="Petit guide de VB6 vers Tcl"><div class="titlepage"><div><div><h2 class="title"><a xmlns:saxon="http://icl.com/saxon" id="d0e1"/>

Petit guide de VB6 vers Tcl

</h2></div><div><h3 class="subtitle"><i>

Version française du <span class="foreignphrase"><em class="foreignphrase"> VB6 To Tcl mini-HOWTO</em></span>

</i></h3></div><div><div class="author"><h3 class="author"><span class="firstname">Mark</span> <span class="surname">Hubbard</span></h3><div class="affiliation"><span class="orgname">
      <a class="ulink" href="http://www.dcisite.com" target="_top">Digital Connections Inc.</a>
  <br/></span><div class="address"><p><code class="email">&lt;<a class="email" href="mailto:markh CHEZ dcisite POINT com">markh CHEZ dcisite POINT com</a>&gt;</code></p></div></div></div></div><div><p class="othercredit"><span class="contrib">
    Conversion du format HTML au format DocBook v4.1.
 </span> : <span class="firstname">Pradeep</span> <span class="surname">Padala</span></p></div><div><p class="othercredit"><span class="contrib">Adaptation française</span> : <span class="firstname">Berhaut</span> <span class="surname">Denis</span></p></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="3"><b>Historique des versions</b></th></tr><tr><td align="left">Version v1.0.fr.1.0</td><td align="left">02 juin 2004</td><td align="left">db</td></tr><tr><td align="left" colspan="3">Première traduction française</td></tr><tr><td align="left">Version v1.0</td><td align="left">2003-04-30</td><td align="left">tab</td></tr><tr><td align="left" colspan="3">
       Version initiale, révisée par LDP</td></tr><tr><td align="left">Version 
0.9</td><td align="left">
2003-04-08</td><td align="left">
ppadala</td></tr><tr><td align="left" colspan="3">
Conversion au format Docbook</td></tr><tr><td align="left">Version 
0.8</td><td align="left">
2002-07-08</td><td align="left">
mark</td></tr><tr><td align="left" colspan="3">
Document original </td></tr></table></div></div><div><div class="abstract" title="Résumé"><p class="title"><b>Résumé</b></p><p>

  Un tour de Tcl en 15 minutes pour programmeurs Visual Basic et 
  VBScript.

</p></div></div></div><hr/></div><div class="toc"><p><b>Table des matières</b></p><dl><dt><span class="sect1"><a href="#intro">1. 
Introduction</a></span></dt><dt><span class="sect1"><a href="#examples">2. 
Exemples</a></span></dt><dt><span class="sect1"><a href="#more">3. 
Pour plus d'information</a></span></dt><dt><span class="sect1"><a href="#copyright">4. 
Licence et droits d'auteur</a></span></dt></dl></div><div class="sect1" title="1.  Introduction"><div class="titlepage"><div><div><h2 class="title"><a xmlns:saxon="http://icl.com/saxon" id="intro"/>1. 
Introduction</h2></div></div></div><p>
<span class="emphasis"><em>
Programmeurs VB and VBScript :  Je sais ce que vous ressentez.</em></span>
Vraiment. En tant que Microsoft Certified Professional en VB6, j'ai pratiqué ces langages pendant sept ans. Je les ai vraiment aimés, jusqu'à ce que je saute le pas pour Tcl et que je commence à remarquer les différences de flexibilité qui sont présentées ici. Si Tcl vous paraît complètement étranger, et que vous vous demandez comment une chose pareille peut exister, attendez d'avoir vu un morceau de code C ou un script de shell UNIX. Je pense que ce sont eux qui l'ont le plus influencé. Les scripts shell UNIX sont beaucoup plus avancés que les scripts shell MS Windows, y compris ceux de NT/2000. En fait, les scripts Unix ont une grande partie des fonctionnalités montrées ici. Tcl et les scripts shell sont tous les deux largement basés sur des substitutions de chaînes. J'ai choisi d'étudier Tcl plutôt que les scripts shell parce que le code Tcl est beaucoup plus verbeux et semblable à l'anglais (et donc maintenable) que les scripts shell, qui ont tendance à être obscurs. Certains noms d'instructions de script consistent uniquement en de la ponctuation!</p><p>
Tcl tourne aussi sur les 'quatre grandes' plate-formes pour PC (Linux, *nix, Windows, Mac) comme sur d'autres. Java(tm) le promet, mais Tcl l'a fait (sinon plus). Contrairement à Java et VB, Tcl n'est soumis à aucune influence commerciale (ce qui le rend vraiment libre,pas seulement 'gratuit') ; au fil des années son développement a collé à vos besoins et vos désirs, vous les développeurs et développeurs potentiels. Aucune société n'a tiré Tcl en dehors de ce chemin pour son intérêt d'entreprise. Le contraste le plus important entre Tcl et VB est que même les différences techniques expliquées plus bas peuvent être éclipsées par Tcl</p></div><div class="sect1" title="2.  Exemples"><div class="titlepage"><div><div><h2 class="title"><a xmlns:saxon="http://icl.com/saxon" id="examples"/>2. 
Exemples</h2></div></div></div><div class="table"><a xmlns:saxon="http://icl.com/saxon" id="d0e103"/><p class="title"><b>Tableau 1. 
Différences</b></p><div class="table-contents"><table summary="&#xA;Différences" border="1"><colgroup><col/><col/></colgroup><tbody><tr><td align="center">
VB6 </td><td align="center">
Tcl/Tk 8.3 </td></tr><tr><td colspan="2">
Notes/différences </td></tr><tr><td>
<p>
</p><pre class="programlisting">
dim a as integer dim b as integer a=1 : b=0 </pre><p>
 </p>
</td><td>
<p>
</p><pre class="programlisting">
set a 1; set b 0
</pre><p>
 </p>
</td></tr><tr><td colspan="2">
Séparateur d'instructions multiples sur une ligne. Tcl utilise un point virgule. On considère généralement que plusieurs instructions sur une ligne constituent du code mal formé, mais on utilise aussi le point virgule pour mettre en commentaire une partie d'une ligne, comme illustré ici. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
' ceci est une ligne entière
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
# ceci est une ligne entière
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Commentaire sur une ligne entière. Ce langage n'a pas besoin non plus d'un espace après la marque de mise en commentaire. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
dim a as integer a=1 'ceci est un commentaire sur la même ligne qu'une instruction.
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
set a 1 ;# ceci est un commentaire sur la même ligne qu'une instruction.
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Commentaire partagé avec une instruction sur une ligne. Remarquez le point virgule, utilisé comme si le commentaire est une autre instruction sur cette ligne. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
dim s as string s="/data/docs/vb6_to_tcl.htm"
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
set s {/data/docs/vb6_to_tcl.htm}
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Assignation d'une chaîne entre accolades. Les substitutions en Tcl ne s'effectuent généralement pas dans une chaîne entre accolades. Si la chaîne contient des variables ou d'autres éléments qui devraient être substitués, ce sera différé, mais on pourra les substituer plus tard. On peut souvent le faire avec des instructions qui mettent en œuvre des structures de contrôle, comme 'if' or 'while'. Une fois que vous êtes familiarisés avec les principes de Tcl,faites en sorte d'avoir une compréhension approfondie de ce processus parce que c'est important pour progresser en Tcl. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
(Pas d'équivalence)
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
set s "/data/docs/vb6_to_tcl.htm"
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Assignation d'une chaîne entre guillemets. On peut effectuer toutes les substitutions (variables, commandes,antislash) à l'intérieur d'une chaîne entre guillemets. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
(Pas d'équivalence)
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
set s /data/docs/vb6_to_tcl.htm
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Assignation d'une chaîne hors des guillemets. On peut effectuer toutes les substitutions (variables, commandes,antislash) sur une chaîne située à l'extérieur de guillemets. L'interpréteur prend simplement la chaîne comme étant le troisième terme de l'instruction set (deuxième argument de l'instruction set). Ceci marche s'il n'y a pas d'espace ou certains autres caractères dans la chaîne. A utiliser avec précaution, en particulier si vous manipulez des données saisies par l'utilisateur. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
dim s as string s = vbCrLf &amp;"Un logiciel libre n'est pas simplement" &amp;vbCrLf _ &amp;" et seulement'gratuit'" &amp;vbCrLf _ &amp;"mais offre aussi la liberté de créer" &amp;vbCrLf _ &amp;"et d'utiliser les meilleurs outils." &amp;vbCrLf
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
set s { Un logiciel libre n'est pas simplement 'gratuit' mais offre aussi la liberté de créer et d'utiliser les meilleurs outils. }
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Assignation d'une chaîne multi-lignes. Remarquez la syntaxe plus encombrée du VB, qui le rend plus difficile à lire que le code Tcl. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
dim s as string dim t as string s = trim(t)
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
set s [string trim $t]
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Assignation d'une valeur de retour de fonction. Le troisième terme de cette instruction set est entre crochets. Cela signifie qu'il est lui-même une instruction qui doit être exécutée, le résultat occupant la place du troisième terme de l'instruction set. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
dim s as string dim t as string s = lcase(trim(t))
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
set s [string tolower [string trim $t]]
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Assignation d'une fonction de fonction. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
dim x as double dim y as double x = (y + 10) * 5
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
set x [expr {($y + 10) * 5}]
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Assignation du résultat d'une expression mathématique. L'interpréteur Tcl utilise l'instruction expr pour évaluer les expressions mathématiques ou logiques. Beaucoup d'autres instructions telles que 'if' or 'while' utilisent expr. Quand on y recourt explicitement, expr doit comporter un seul argument qui est une chaîne contenant l'expression (comme présenté ici). Cela peut sembler grossier dans les cas simples, quand vous voulez juste ajouter quelque chose à une variable. Dans ce cas, essayez d'utiliser l'instruction incr. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
dim s as string s = s &amp;"ajout de texte rajouté"
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
append s {ajout de texte}
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Ajouter une chaîne à une autre. En VB, c'est l'une des opérations les plus lentes, mais c'est particulièrement rapide en Tcl. La vitesse est très importante ici, parce qu'on effectue souvent cette opération dans des boucles ou des boucles imbriquées. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
dim s as string dim t as string dim u as string s = "Je demanderai à " &amp; t &amp; " de m'envoyer " &amp; trim(u) &amp; " ainsi que le tarif" </pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
set s "Ije demanderai à $t de m'envoyer [string trim $u] ainsi que le tarif"
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Construire une chaîne par substitution. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
print "bonjour"
</pre><p>
</p>
</td><td>
Displays bonjour.
</td></tr><tr><td colspan="2">
Afficher sur la console (en fait, VB affiche dans un formulaire ou dans la fenêtre de débogage. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
sub ma_procedure (byval a as integer, byval b as string)
 debug.print "Je demanderai à " &amp; b
end sub
function ma_fonction (byval a as integer, _ optional byval b as string = "Mark") _ as string
 ma_fonction = "Je demanderai à " &amp; b
end function
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
proc ma_procedure {a b} {
 debug.print "Je demanderai à " b
}
proc ma_fonction {a {b Mark}} {
 return "Je demanderai à $b"
}
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Définition de procédure. Remarquez qu'en VB, la syntaxe est différente pour les procédures et les fonctions. En Tcl,on utilise la commande <span class="command"><strong>
proc</strong></span>
pour définir les deux. <span class="command"><strong>
proc</strong></span>
est une instruction ordinaire Tcl qui s'exécute comme n'importe quelle autre instruction. Son premier argument est une liste de paramètres Tcl pour la nouvelle procédure. Son deuxième argument est une grande chaîne qui contient le corps de la nouvelle procédure (le script Tcl en lui-même). <span class="emphasis"><em>
Important :</em></span>
Tcl est sensible à la classe pour pratiquement toutes les opérations : toutes les références aux noms d'instructions et aux noms de variables, ainsi que par défaut les comparaisons de chaînes de caractères. Ainsi,un appel à <span class="command"><strong>
Proc</strong></span>
provoquera une erreur (P en majuscule),comme le ferait un appel à <code class="varname">
Ma_procedure</code>
, ou faire référence à la variable <code class="varname">
B</code>
dans <code class="varname">
ma_procedure</code>
(b était en minuscule). </td></tr><tr><td>
<p>
</p><pre class="programlisting">
dim i as integer if i &lt; 0 then i = 0 else i = i - 1
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
if {$i &lt; 0} {set i 0} {incr i -1}
# option possible if {$i &lt; 0} then {set i 0} else {incr i -1}
# une autre option if {$i &lt; 0} then { set i 0 } else { incr i -1 } </pre><p>
</p>
</td></tr><tr><td colspan="2">
Exécution conditionnelle 'if'. S'ils sont présents, l'instruction Tcl 'if' ignore les mots-clés facultatifs 'then' et 'else'. Dans la mesure où les deux blocs de codes sont juste des chaînes,on peut les entourer d'accolades pour les formater correctement, comme on le voit. Afin d'éviter les erreurs de syntaxe, entourez aussi par des accolades toutes les expressions de test non triviales. De cette manière, les substitutions (comme $i dans notre exemple) ne seront prises en compte que lorsque l'instruction  'if' passera l'expression de test à l'analyseur d'expressions. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
dim i as integer i = 1 while i &lt; 2000 i = i * 2 wend
'option possible i = 1 do while i &lt; 2000 i = i * 2 loop </pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
set i 1 while {$i &lt; 2000} { set i [expr {$i * 2}] }
</pre><p>
</p>
</td></tr><tr><td colspan="2">
'while' loop. Ceci est identique à l'instruction 'if' dans laquelle il prend une expression de test comme premier argument, suivie par une chaîne de code. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
dim i as integer for i = 0 to 8 'neuf répétitions 0-8 debug.print i next
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
for {set i 0} {$i &lt; 9} {incr i} { # neuf répétitions 0-8 puts $i }
# option possible for {set i 0} {$i &lt;= 8} {incr i} { # de nouveau, neuf répétitions 0-8 puts $i } # autre option possible for {set i 1} {$i &lt;= 9} {incr i} { # neuf répétitions 1-9 puts $i }
# encore une autre possible - moins lisible set i 1 for {} {[incr i] &lt;= 9} {} { # neuf répétitions 1-9 puts $i } </pre><p>
</p>
</td></tr><tr><td colspan="2">
'for' boucle avec compteur interne. En Tcl (comme dans tous les langages), ceci revient à une boucle 'while'. Dans certains langages comme VB, 'for' n'est pas aussi flexible que 'while'. Ce n'est pas le cas en Tcl. On peut utiliser n'importe quoi comme code d'initialisation, comme expression de test pour for, comme code d'incrémentation. Ces éléments ne sont pas réservés à une utilisation particulière,comme vous pouvez le voir dans l'exemple final. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
dim c as new collection dim o as object c.add "Mark" c.add "Roy" c.add "Brian" for each o in c debug.print o next
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
set c [list Mark Roy Brian] foreach o $c { puts $o }
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Boucle à travers des éléments d'une structure de données. En Tcl, on utilise une structure de données en liste. Il n'y a pas d'équivalent direct en VB, mais ce qu'il y a de plus proche est une collection d'objets. Remarquez bien que les collections VB sont, et de loin, plus lentes que les listes Tcl dans des opérations classiques,parce qu'appeler des objets dans des méthodes est plus consommateur de temps système. Retenez aussi qu'il existe <span class="emphasis"><em>
des utilisations bien plus puissantes et créatives</em></span>
de l'instruction foreach,qui ne sont pas montrées ici. Elles n'ont pas d'équivalent direct en VB. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
dim s as string select case s case "John" debug.print "Mellencamp" case "Steve" debug.print "Tyler" case else debug.print "Inconnu" end select
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
switch -exact $s { John {puts Mellencamp} Steve {puts Tyler} default {puts Inconnu} }
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Exécution d'un choix parmi plusieurs. Remarquez que la version Tcl est sensible à la casse. ça n'est pas souvent le cas en VB, en fonction de l'option 'option compare' qui est active dans le module. L'option  <code class="option">
-exact</code>
précise que la chaîne doit être exactement concordante,contrairement à une concordance partielle ou à une concordance d'expression rationnelle (qui n'est pas sensible à la casse). Notez aussi qu'il y a de nombreuses d'utilisations puissantes et créatives de l'instruction switch, qui ne sont pas montrées ici. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
on error goto capture debug.print a 'a n'a pas été déclaré. ... capture: debug.print err.number, err.description
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
if [catch { puts $a ;# a n' pas été initialisé } my_err] { puts "message d'erreur: $my_err" puts "stack trace: $errorInfo" # ces erreurs auraient été montrées # de toute façon par la l'interception d'erreur par défaut. } else { puts {Tout est correct.} # l'autre bloc est facultatif. }
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Interception d'erreur. En VB, l'interception d'erreurs de façon concise peut poser des problèmes, en particulier si des actions différentes, dépendant du code impliqué, doivent être menées. L'instruction Tcl <span class="command"><strong>
catch</strong></span>
résout clairement ces problèmes. De plus,Tcl fournit automatiquement une trace de la pile de code en erreur. en VB, la trace de la pile doit être explicitement construite dans le code,si l'on désire en avoir une dans l'application de production (pas dans l'IDE). C'est un avantage pour Tcl quand on débogue sur le terrain. Retenez que <span class="command"><strong>
catch</strong></span>
retourne un booléen 1 ou 0, que l'on utilise classiquement avec 'if', comme présenté ici. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
(Pas d'équivalence)
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
set i [expr $e]
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Passe une expression mathématique arbitraire à l'interpréteur pour qu'il l'évalue. Ce peut être une expression saisie par un utilisateur, ou générée antérieurement par du code. C'est l'un des aspects les plus puissants de Tcl. En VB,on ne peut pas du tout en disposer. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
(Pas d'équivalence)
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
set s [eval $c]
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Passe un code arbitraire à l'interpréteur pour qu'il l'exécute. Ce peut être un script saisi par un utilisateur, ou généré antérieurement par du code. C'est l'un des aspects les plus puissants de Tcl. En VB,on ne peut pas du tout en disposer. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
(Pas d'équivalence)
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
source my_script.tcl
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Passe un nom de fichier arbitraire à l'interpréteur pour qu'il exécute ce fichier comme un script. C'est l'un des aspects les plus puissants de Tcl. En VB,on ne peut pas du tout en disposer. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
(Pas d'équivalence)
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
set var_name marks_age incr $var_name
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Exécute des opérations sur une variable choisie arbitrairement. Le code montré ici va modifier la variable <code class="varname">
age_de_marc</code>
. Son nom (la chaîne "age_de_marc") est stocké dans la variable <code class="varname">
nom_de_variable</code>
. En fait, juste avant son exécution, chaque élément de chaque instruction est soumis à une tentative de substitution par l'interpréteur. Ainsi,n'importe quelle partie d'une instruction (et même le nom de l'instruction elle-même) peut être modifiée en fonction des données ou d'un autre critère. C'est l'un des aspects les plus puissants de Tcl. En VB,on ne peut pas du tout en disposer. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
dim s as string dim li as string dim f_num as integer s = "" f_num = fichierlibre open "mon_fichier.txt" for input as #f_num while not eof(f_num) line input #f_num, li s = s &amp; li &amp; vbCrLf wend close #f_num
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
set f [open mon_fichier.txt r] set s [read $f] close $f
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Lit le fichier entier dans une variable. Ce code VB est très lent, même pour des fichiers moyennement gros. Et il n'y aucun moyen de prendre en compte les caractères de saut de ligne. Le code Tcl accepte et préserve les sauts de ligne dans les données. Il normalise aussi les différents caractères de sauts de ligne en un simple type de caractères de sauts de ligne standardisé(par défaut). Ce code s'applique de façon équivalente à des données brutes, à des listes Tcl, à des tableaux Tcl. L'option <code class="option">
r</code>
dans l'instruction <span class="command"><strong>
open</strong></span>
indique qu'elle est en mode 'read' (lecture). </td></tr><tr><td>
<p>
</p><pre class="programlisting">
dim a(1 to 3) as string a(1) = "Mark" a(2) = "Brian" a(3) = "Roy" 'aïe - il me faut plus d'éléments redim preserve a(1 to 10) as string a(4) = "John"
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
array set a [list 1 Mark 2 Brian 3 Roy] set a(4) John # maintenant différents types # de noms d'éléments dans le même tableau set a(Red) Hat set a(Linux,RedHat) 7.1
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Tableau contre Tableau. En VB, les tableaux sont limités à l'utilisation de nombres comme indices (En Tcl, on appelle 'element names' les indices, ou index). Et la taille d'un tableau doit être déclarée ; pour l'agrandir il faut utiliser l'opération (lente) 'ReDim Preserve'. Les tableaux Tcl s'agrandissent automatiquement, et disposent d'une table de hashage super efficace qui leur permet même de prendre en charge des centaines de milliers d'éléments à une vitesse supérieure. En Tcl, on utilise tous les types de données comme nom d'élément, et différents types peuvent même être mélangés dans le même tableau. Le nombre de dimensions de chaque élément n'est pas limité. Tcl fournit des moyens simples pour se déplacer dans les tableaux, ou dans certains éléments du tableau (par filtrage). Vous pouvez aussi obtenir une liste entière ou partielle des noms d'éléments, et faire d'autres opérations plus facilement qu'en VB. En VB, l'utilisation d'une partie de ses possibilités nécessite l'utilisation d'une collection ou d'un objet de dictionnaire. Chacun d'eux possède ses bizarreries et ses pièges, tels qu'une charge plus importante qu'un tableau VB. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
(Pas d'équivalence)
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
array set mon_tableau $ma_liste set ma_liste [array get mon_tableau]
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Liste vers tableau, et l'inverse. Le transfert facile et rapide entre deux structures de données primaires signifie que les outils appliqués à l'un peuvent l'être à l'autre. Ils multiplient mutuellement leur utilité. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
dim a(1 to 100) as string dim i as integer dim f_num as integer f_num = fichierlibre open "mon_fichier.txt" for output as #f_num for i=1 to 100 print #f_num, a(i) next close #f_num </pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
set f [open mon_fichier.txt w] set $f [array get a] close $f
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Ecrit le tableau entier. Dans ce code VB, et fréquemment dans d'autres codes VB, les sauts de ligne et d'autres caractères présents dans les données vont provoquer des erreurs à un stade ultérieur (phénomène de relecture). Cela devient un problème si votre code manipule des données saisies par un utilisateur. En Tcl, ça n'en n'est pas un, les données sont conservées tout le temps "proprement". De plus, de nombreuses combinaisons de caractères de retour chariot (0x0 ou décimal 13) et de saut de ligne (0x0A ou décimal 10)sont automatiquement normalisées par défaut. Remarquez bien que ces deux exemples ne produisent pas des fichiers identiques en sortie. L'exemple Tcl, comme le VB, écrit un fichier texte. Mais le fichier Tcl sera lu (par Tcl) et aura automatiquement le même nombre d'éléments, les mêmes noms d'éléments, etc. En Tcl, la structure de données en liste est utilisée pour cela. S'en servir garantit que les données sont formatées selon une représentation concise, sans ambiguïté, textuelle. Les humains peuvent aussi le lire et y écrire. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
(Pas d'équivalence)
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
set f [open mon_fichier.txt w] puts $f [array get a blanc*] close $f
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Ecrit certains éléments d'un tableau. En VB, il faudrait utiliser une collection ou un objet de dictionnaire pour faire ça. Une boucle ferait une itération à travers tous les éléments et sélectionnerait ceux qui sont appropriés. En Tcl, le nom du tableau est <code class="literal">
a</code>
et une chaîne <code class="literal">
blanc*</code>
(sensible à la casse) est utilisée comme filtre pour sélectionner les éléments à grande vitesse. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
(Pas d'équivalence)
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
set ma_liste [lsort $ma_liste]
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Trier une liste. Le tri peut être inversé, ou ordonné numériquement, etc... On peut aussi trier une liste de sous-listes en utilisant un élément d'index. Tcl contient une suite complète d'instructions pour manipuler les structures de données en liste. Voir aussi <span class="command"><strong>
lappend</strong></span>
, <span class="command"><strong>
linsert</strong></span>
, <span class="command"><strong>
lreplace</strong></span>
, <span class="command"><strong>
lsearch</strong></span>
, <span class="command"><strong>
concat</strong></span>
, <span class="command"><strong>
split</strong></span>
, <span class="command"><strong>
join</strong></span>
, etc. On peut aussi imbriquer arbitrairement les listes Tcl ; l'instruction <span class="command"><strong>
foreach</strong></span>
s'exécutera sans problème. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
' nécessite une référence aux ADO ' considère que nous avons une connexion nommée conn dim rs as new recordset rs.open "select id, nom, age from peuple", _ ma_connexion, adOpenStatic ' placer ici le code rs.close set rs=nothing </pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
package require tclodbc # considère que nous avons une connexion nommée conn conn read a "select id, nom, age from peuple" # placer ici le code unset a ;# libération du tableau
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Renvoie un simple tableau de données d'une table de base de données. En VB, les données sont toujours retournées dans un objet 'recordset'. En Tcl,il peut être renvoyé dans un tableau et/ou dans une liste, en fonction de vos besoins et du paquetage de la base de données utilisé. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
(Pas d'équivalence)
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
package require http set httpTrans [http::geturl $pageURL] upvar #0 $httpTrans state if {$state(status) == {ok}} { puts $state(body) } </pre><p>
</p>
</td></tr><tr><td colspan="2">
Retourne un document ou un fichier d'un serveur Web. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
(Pas d'équivalence)
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
regexp -all {src=['"](.+?)['"]} $body mes_images
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Recherche et extraction de modèles de chaînes complexes. En Tcl,on utilise les  <span class="emphasis"><em>
expressions rationnelles</em></span>
pour cela. <span class="emphasis"><em>
Expression rationnelle</em></span>
est une spécification de recherche de concordance de modèles de chaînes,dont le concept est similaire au modèle des cartes magiques utilisé avec l'opérateur 'like', à l'exception des stéroïdes,  <span class="emphasis"><em>
de tous</em></span>
les stéroïdes. Les expressions rationnelles sont plusieurs fois plus puissantes et plus flexibles que les modèles 'like'. Pour une initiation informelle aux expressions rationnelles, voyez <a class="ulink" href="http://zez.org/article/articleprint/11" target="_top">
http://zez.org/article/articleprint/11</a>
. L'analyseur d'expressions rationnelles de Tcl est écrit en code C optimisé, et on peut l'utiliser au travers de différentes instructions Tcl (<span class="command"><strong>
regexp</strong></span>
, <span class="command"><strong>
regsub</strong></span>
, <span class="command"><strong>
lsearch</strong></span>
, etc. Vous pouvez aussi utiliser les versions plus simples, moins puissantes auxquelles vous êtes habitués dans différentes instructions (<span class="command"><strong>
glob</strong></span>
, <span class="command"><strong>
string match</strong></span>
, <span class="command"><strong>
lsearch</strong></span>
, et d'autres encore). Cet exemple prendrait entre 15 et 50 lignes de code VB, en fonction de la robustesse et de la tolérance à des situations diverses qu'il aurait besoin d'avoir. De plus, c'est l'un des codes les plus difficiles, les plus durs à déboguer, et les plus lents que l'on puisse écrire en VB (c'est la voix de l'expérience qui parle). Ici, on obtient rapidement une liste des URLs de toutes les images d'une page HTML. </td></tr><tr><td>

<pre class="programlisting">
(Pas d'équivalence)
</pre>

</td><td>

<pre class="programlisting">
set find {&lt;tr&gt;(.*?)&lt;td&gt;(.*?)&lt;/td&gt;&lt;td&gt;(.*?)&lt;/td&gt;&lt;td&gt;(.*?)&lt;/td&gt;(.*?)&lt;/tr&gt;} set replace {&lt;tr&gt;\1&lt;td width=20%&gt;\2&lt;/td&gt;&lt;td width=40%&gt;\3&lt;/td&gt;&lt;td width=30%&gt;\4&lt;/td&gt;\5&lt;/tr&gt;} regsub -all -nocase $exp $body $replace result puts $result
</pre>

</td></tr><tr><td colspan="2">

Recherche et substitution de modèles de chaînes complexes. De nouveau,
en Tcl,on utilise les expressions rationnelles. Cet exemple prendrait
entre 40 lignes de code VB voire plus, en particulier s'il est
logiquement organisé avec suffisamment de commentaires pour qu'un
programmeur chargé de la maintenance puisse suivre. Et de plus, c'est
l'un des codes les plus difficiles, les plus durs à déboguer, et les
plus lents que l'on puisse écrire en VB. Ici, le jeu de trois cellules
dans <span class="emphasis"><em> chaque ligne du corps du HTML</em></span> est
systématiquement modifié, tout en laissant le contenu de chaque cellule
inchangé.

</td></tr><tr><td>

<pre class="programlisting">
(Pas d'équivalence)
</pre>

</td><td>

<pre class="programlisting">

set handle [socket markhpc.dcisite.com 2000] set bienvenue [read $handle] close $handle

</pre>

</td></tr><tr><td colspan="2">
Crée une connexion à une interface réseau (en tant que client) et retourne des données. Dans l'exemple, nous considérons qu'un serveur écoute sur le port TCP 2000 de l'hôte spécifié. </td></tr><tr><td>
<p>
</p><pre class="programlisting">
(Pas d'équivalence)
</pre><p>
</p>
</td><td>
<p>
</p><pre class="programlisting">
proc bienvenue {handle client_ip client_port} { puts $handle {Bienvenue sur notre serveur d'accueil!} close $handle } socket -server bienvenue 2000
</pre><p>
</p>
</td></tr><tr><td colspan="2">
Met en oeuvre un serveur réseau pour répondre au client montré ci-dessus. Voici le script complet. si vous utilisez Wish (le shell fenêtré Tcl), il tournera toute la journée comme il est présenté. Si vous utilisez Wish (le shell fenêtré Tcl), ajoutez une instruction <span class="command"><strong>
vwait</strong></span>
à la fin, pour forcer le programme à attendre des événements plutôt que de se terminer à la fin du script. Cette différence entre les deux shells est nécessaire et intentionnelle, dans la mesure où Wish est piloté par défaut par les événementset que Tclsh ne l'est pas. </td></tr></tbody></table></div></div><br class="table-break"/></div><div class="sect1" title="3.  Pour plus d'information"><div class="titlepage"><div><div><h2 class="title"><a xmlns:saxon="http://icl.com/saxon" id="more"/>3. 
Pour plus d'information</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>
<span class="emphasis"><em>
Programmation Tcl/Tk et initiation : </em></span>
Lisez l'incroyable livre de Brent Welch <span class="emphasis"><em>
Practical Programming in Tcl and Tk</em></span>
. Grâce à la générosité de Brent, vous pouvez même lire et imprimer les vieilles éditions et des chapitres sélectionnés des éditions actuelles sur <a class="ulink" href="http://www.beedub.com/book" target="_top">
http://www.beedub.com/book</a>
.</p></li><li class="listitem"><p>
<span class="emphasis"><em>
Téléchargements nécessaires pour développer en Tcl : </em></span>
Voyez <a class="ulink" href="http://www.tcl.tk" target="_top">
http://www.tcl.tk</a>
pour TclPro 1.4.1 pour tous les systèmes d'exploitation et à peu près tous les paquetages complémentaires dont vous pourriez avoir besoin. TclPro contient les deux interpréteurs (Tclsh et Wish) version 8.3, plus un excellent débogueur interactif ainsi qu'un ensemble d'outils et de bibliothèques très utiles. La version 1.4.1 est disponible au public. cependant, à la mi-2002,il semble que <a class="ulink" href="http://www.activestate.com" target="_top">
ActiveState</a>
est en train de transformer TclPro en produit commercial. Rappelez-vous que vous pouvez toujours obtenir les interpréteurs 'standard' pour tous les systèmes d'exploitation du site <a class="ulink" href="http://tcl.sourceforge.net" target="_top">
http://tcl.sourceforge.net</a>
étant donné que Tcl est un logiciel open source.</p></li><li class="listitem"><p>
<span class="emphasis"><em>
Editeurs avec coloration syntaxique, etc : </em></span>
Pour travailler sous MS Windows, j'apprécie le produit commercial bon marché TextPad disponible à l'adresse <a class="ulink" href="http://www.textpad.com" target="_top">
http://www.textpad.com</a>
. Actuellement, il coûte 29$ US par licence, et vous pouvez l'essayer avant de l'acheter. Téléchargez la définition de syntaxe Tcl de leur site Web. TextPad est l'éditeur pour MS Windows possédant le plus de caractéristiques que j'ai jamais vues ; il a la capacité d'émuler le comportement des éditeurs de Microsoft. Vous pouvez l'utiliser comme IDE (outil de développement) pour Tcl/Tk en l'interfaçant avec les interpréteurs et vos autres outils. Pour Unix/Linux, et peut-être bien même pour MS Windows, essayez Nedit à l'adresse <a class="ulink" href="http://www.nedit.org" target="_top">
http://www.nedit.org</a>
. Il est libre, placé sous les termes de la GNU General Public License. C'est aussi un bon outil, qui permet aux utilisateurs de MS Windows d'être immédiatement productifs.</p></li><li class="listitem"><p>
<span class="emphasis"><em>
Des outils auxquelles vous penserez probablement : </em></span>
La première chose que veulent beaucoup de programmeurs VB est d'attaquer une base de données ODBC. Allez chercher le paquetage TclODBC de <a class="ulink" href="http://www.tcl.tk" target="_top">
http://www.tcl.tk</a>
. C'est une DLL win32 qui vous permettra d'accéder à toutes les sources de données et pilotes ODBC. Il est fourni avec de la documentation, et il y a un mini-exemple ci-dessus. Remarquez qu'il peut être comme ne pas être portable vers d'autres systèmes d'exploitation, donc vous devriez encapsuler tous les appels que vous lui ferez dans des procédures. De cette façon, vous pourrez porter votre code pour utiliser d'autres bibliothèques plus tard. Les expressions rationnelles sont en elle-même presqu'un langage de programmation puissant. De ce fait, il faut un certain temps pour les maîtriser. Le petit programme Tcl 'Visual RegExp' m'a énormément aidé en cela. Vous l'obtiendrez à l'adresse <a class="ulink" href="http://laurent.riesterer.free.fr/regexp" target="_top">
http://laurent.riesterer.free.fr/regexp</a>
. Il y a aussi plusieurs paquetages qui relient Tcl au monde d'ActiveX ; ainsi vous pouvez automatiser des applications MS Office, etc...</p></li><li class="listitem"><p>
<span class="emphasis"><em>
Sujets d'aide principaux : </em></span>
Quand vous aurez obtenu TclPro et son fichier d'aide, allez à son index et regardez le sujet 'Tcl'. Il y a un sommaire des règles syntaxiques du langage, et des substitutions qui le pilotent. Regardez sans faute les sujets suivants : 're_syntax', 'tclvars', 'tclsh', and 'wish'. A première vue, ils sont transcrits des pages de manuel (man pages)d'Unix/Linux, et constituent certains des meilleurs textes que j'ai jamais vu dans les aides de Windows ; si vous avez besoin de <span class="emphasis"><em>
matériaux de référence</em></span>
, je ne vous recommande pas de lire ce fichier d'aide pour votre initiation, mais c'est une excellente référence de programmation.</p></li><li class="listitem"><p>
<span class="emphasis"><em>
'Démarrer' éléments du menu :</em></span>
Après avoir installé TclPro, vous devriez regarder le menu 'Démarrer' de TclPro,et examiner le 'Incr Widgets Reference' et le 'Widget Tour'. Ils montrent les possibilités de l'interface graphique de Tk <span class="emphasis"><em>
avec le code Tcl effectivement nécessaire pour les utiliser.</em></span>
</p></li><li class="listitem"><p>
<span class="emphasis"><em>
Argumentaire (comment convaincre votre direction d'utiliser Tcl/Tk) : </em></span>
On trouvera une profusion d'informations convaincantes à l'adresse suivante <a class="ulink" href="http://www.tcl.tk" target="_top">
http://www.tcl.tk</a>
.</p></li></ul></div></div><div class="sect1" title="4.  Licence et droits d'auteur"><div class="titlepage"><div><div><h2 class="title"><a xmlns:saxon="http://icl.com/saxon" id="copyright"/>4. 
Licence et droits d'auteur</h2></div></div></div><p>
Copyright (c) 2003 Mark Hubbard.</p><p>
Permission est accordée de copier, distribuer et/ou de modifier ce document selon les termes de la GNU Free Documentation Licence, version 1.2 ou ultérieure publiée par la Free Software Foundation ; sans section modifiée, sans texte de couverture de première ou de dernière page. Une copie de la license est disponible à <a class="ulink" href="http://www.gnu.org/copyleft/fdl.html" target="_top">
http://www.gnu.org/copyleft/fdl.html</a>
, dans la section intitulée <span class="quote">« <span class="quote">
GNU Free Documentation License</span> »</span>
.</p><p>
<span class="emphasis"><em>
"Visual Basic," "VBScript," et tous les termes relatifs sont la propriété de Microsoft <a class="ulink" href="http://www.microsoft.com" target="_top">
http://www.microsoft.com</a>
.</em></span>
</p><p>
<span class="emphasis"><em>
Tcl (Tool Command Language) est un logiciel open source, créé par John Ousterhout - <a class="ulink" href="http://www.tcl.tk" target="_top">
http://www.tcl.tk</a>
ou <a class="ulink" href="http://tcl.sourceforge.net" target="_top">
http://tcl.sourceforge.net</a>
.</em></span>
</p></div></div></body></html>