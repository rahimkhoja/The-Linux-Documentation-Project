<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.21">
 <TITLE>Petit guide d'exécution à distance des applications X</TITLE>
</HEAD>
<BODY>
<H1>Petit guide d'exécution à distance des applications X</H1>

<H2>Version française du <EM>Remote X Apps mini-HOWTO</EM></H2>
<H2>
<A HREF="http://www.xs4all.nl/~zweije/">Vincent Zweije</A> &lt;
<A HREF="mailto:zweije@xs4all.nl">zweije@xs4all.nl</A>&gt;</H2>V 0.7.5, 8 décembre 2001
<HR>
<EM>Ce petit guide décrit comment exécuter des applications X à distance.
C'est-à-dire, comment faire pour qu'un programme X s'affiche sur un écran
d'ordinateur différent de celui sur lequel il s'exécute. Ou, autrement dit,
comment faire tourner un programme X sur un ordinateur différent de celui
devant lequel vous êtes assis. L'accent de ce petit guide sera mis sur les
questions de sécurité. Ce petit guide contient également des informations
sur la manière de faire tourner des applications X en local, mais avec un
identificateur d'utilisateur (user-id) différent ainsi que des informations
sur la façon de mettre en place un ordinateur comme terminal X.
Adaptation française&nbsp;:
Albert-Paul Bouillot,
Frédéric Bothamy
<A HREF="mailto:fbothamy@mail.dotcom.fr">fbothamy@mail.dotcom.fr</A>.
Relecture de la version française&nbsp;: Olivier Kaloudoff 
<A HREF="mailto:kalou@kalou.net">kalou@kalou.net</A>.</EM>
<HR>
<H2><A NAME="s1">1. Introduction</A></H2>

<P>Ce petit guide constitue un guide sur la manière de faire 
tourner des applications X à distance.
J'ai rédigé ce document pour plusieurs raisons&nbsp;:</P>
<P>
<OL>
<LI>Il y a eu de nombreuses questions, sur Usenet, sur la manière de faire 
tourner des applications X à distance&nbsp;;
</LI>
<LI>J'ai vu beaucoup, beaucoup de conseils d'utilisation de
&laquo;&nbsp;<CODE>xhost +hostname</CODE>&nbsp;&raquo; ou même de 
&laquo;&nbsp;<CODE>xhost +</CODE>&nbsp;&raquo; pour réaliser des connexions 
X. <B>C'est d'une insécurité totale</B>, et il existe de bien 
meilleures méthodes&nbsp;;
</LI>
<LI>Je n'ai pas connaissance d'un document simple décrivant les options
dont <EM>on peut</EM> disposer. Si vous avez des informations complémentaires,
s'il vous plaît, faites-le moi savoir (en anglais)&nbsp;:
<A HREF="mailto:zweije@xs4all.nl">&lt;zweije@xs4all.nl&gt;</A>.</LI>
</OL>
</P>
<P>Ce document a été écrit en pensant à des systèmes de type Unix.
Si le système d'exploitation de votre ordinateur local ou de celui qui est
à distance est de type différent, vous devriez trouver ici des informations
sur la manière dont les choses se passent. Cependant, il vous faudra modifier
les exemples par vous-même pour les utiliser sur votre propre système.</P>
<P>La version (anglaise) la plus récente de ce document est toujours disponible
sur le WWW à 
<A HREF="http://www.xs4all.nl/~zweije/xauth.html">http://www.xs4all.nl/~zweije/xauth.html</A>.
Il est également disponible en tant que mini-HOWTO Linux 
&laquo;&nbsp;Applications X à distance&nbsp;&raquo; (Remote X Apps) 
à&nbsp;: 
<A HREF="http://www.tldp.org/HOWTO/mini/Remote-X-Apps">http://www.tldp.org/HOWTO/mini/Remote-X-Apps</A>. Les
(mini-)HOWTO du projet de documentation Linux (LDP) sont disponibles par 
http ou ftp sur 
<A HREF="http://www.tldp.org">www.tldp.org</A>.</P>
<P>La version française la plus récente de ce document est toujours 
disponible sur le site du projet 
<A HREF="http://www.traduc.org">traduc.org</A> à 
<A HREF="http://www.traduc.org/docs/HOWTO/mini/lecture/Remote-X-Apps.html">http://www.traduc.org/docs/HOWTO/mini/lecture/Remote-X-Apps.html</A>.</P>
<P>Ceci constitue la version 0.7.5. Aucune garantie, seulement de bonnes
intentions. Je suis ouvert aux suggestions, idées, ajouts, pointeurs
utiles, corrections (typo), et cætera. Je veux que cela reste un 
document simple et lisible, dans la bonne moyenne du style des guides 
pratiques du projet de documentation Linux.
Les querelles seront redirigées vers /dev/null. Ce document est diffusé
sous la version 1.1 de la licence 
<A HREF="http://www.gnu.org/">GNU</A> Free Documentation Licence. <EM>This document is 
released under version 1.1 of the 
<A HREF="http://www.gnu.org/">GNU</A> Free Documentation Licence</EM>.</P>
<P>Le contenu de ce petit guide a été mis à jour le 8 décembre 2001 par 
<A HREF="http://www.xs4all.nl/~zweije/index.html">Vincent Zweije</A>. La 
version française de ce document a été mise à jour le 4 mars 2003 par
<A HREF="mailto:fbothamy@mail.dotcom.fr">Frédéric  Bothamy</A>. La relecture de cette nouvelle version française a été 
réalisée par 
<A HREF="mailto:kalou@kalou.net">Olivier  Kaloudoff</A>.</P>

<H2><A NAME="s2">2. Lectures complémentaires</A></H2>

<P>Un document, en rapport avec cela, sur le WWW traite de &laquo;&nbsp;Que 
faire quand Tk dit que votre écran n'est pas sûr&nbsp;&raquo;,
<A HREF="http://ce-toolkit.crd.ge.com/tkxauth/">http://ce-toolkit.crd.ge.com/tkxauth/</A>.
Il a été écrit par 
<A HREF="http://ce-toolkit.crd.ge.com/people/kennykb.html">Kevin Kenny</A>. Il suggère une solution similaire à celle de ce document pour
l'authentification X (xauth). Cependant, Kevin vise plus à l'utilisation 
de xdm pour diriger xauth à votre place.</P>
<P>On m'a indiqué que le volume 8 de la série consacrée au système X 
Window, le &laquo;&nbsp;Guide de l'administrateur du système X 
Window&nbsp;&raquo; de chez 
<A HREF="http://www.oreilly.com/">O'Reilly and Associates</A> était une bonne source d'informations. 
Cependant, ce guide n'a pas été mis à jour depuis sa publication 
d'origine en 1992. Il ne couvre donc que X11R4 et X11R5, tout ce qui est 
spécifique à X11R6 n'est pas couvert.</P>
<P>Il y a également un autre document qui ressemble beaucoup à celui que vous 
êtes en train de lire, dont le titre est &laquo;&nbsp;Securing X 
Windows&nbsp;&raquo;, et qui est disponible à 
<A HREF="http://ciac.llnl.gov/ciac/documents/ciac2316.html">http://ciac.llnl.gov/ciac/documents/ciac2316.html</A>.</P>
<P>Consultez également les forums de diffusion Usenet, tels que&nbsp;:
<CODE>comp.windows.x</CODE>,
<CODE>comp.os.linux.x</CODE> et <CODE>comp.os.linux.networking</CODE>.</P>

<H2><A NAME="s3">3. Le contexte</A></H2>

<P>Vous utilisez deux ordinateurs. Sur le premier, vous êtes dans l'environnement
X Window pour taper au clavier et regarder l'écran. Sur le second, vous 
effectuez un important traitement graphique. Vous voulez que les sorties du
second soient affichées sur l'écran du premier. Le système X Window rend
cela possible.</P>
<P>Naturellement, vous devez disposer d'une connexion à un réseau pour pouvoir le
réaliser. De préférence rapide, car le protocole X est un dévoreur de 
ressources réseau. Mais, avec un peu de patience et un protocole de 
compression de données adapté, vous pouvez même faire tourner des applications
par l'intermédiaire d'un modem. Pour un protocole de compression pour X, vous
pouvez aller consulter les sites&nbsp;:
dxpc 
<A HREF="http://www.vigor.nu/dxpc/">http://www.vigor.nu/dxpc/</A> ou LBX
<A HREF="http://www.traduc.org/docs/HOWTO/mini/lecture/LBX.html">http://www.traduc.org/docs/HOWTO/mini/lecture/LBX.html</A> 
(disponible en version originale sur le site de l'auteur&nbsp;:
<A HREF="http://www.paulandlesley.org/faqs/LBX-HOWTO.html">http://www.paulandlesley.org/faqs/LBX-HOWTO.html</A>).</P>
<P>Vous avez deux choses à faire pour réaliser tout cela&nbsp;:</P>
<P>
<OL>
<LI> Indiquer à l'unité d'affichage locale (le serveur) qu'elle doit accepter
les connexions venant de l'ordinateur à distance.
</LI>
<LI> Dire à l'application à distance (le client) de rediriger ses sorties
vers votre unité d'affichage locale.
</LI>
</OL>
</P>

<H2><A NAME="s4">4. Un peu de théorie</A></H2>

<P>Le mot magique est <CODE>DISPLAY (unité d'affichage)</CODE>. Dans le système X
Window, une unité d'affichage est constituée (en simplifiant) d'un clavier, 
d'un mulot et d'un écran. Une unité d'affichage est gérée par un programme
serveur, plus connu sous le nom de serveur X. Le serveur fournit des 
fonctionnalités d'affichage aux autres programmes qui se connectent à lui.</P>

<P>Une unité d'affichage est identifiée par un nom, de type, par exemple&nbsp;:</P>
<P>
<UL>
<LI> <CODE>DISPLAY=light.uni.verse:0</CODE>
</LI>
<LI> <CODE>DISPLAY=localhost:4</CODE>
</LI>
<LI> <CODE>DISPLAY=:0</CODE>
</LI>
</UL>
</P>
<P>Un nom d'unité d'affichage est constitué d'un nom d'hôte (par exemple&nbsp;:
<CODE>light.uni.verse</CODE> et <CODE>localhost</CODE>), du signe deux point
(<CODE>:</CODE>), et d'un numéro de séquence (tels que <CODE>0</CODE> et
<CODE>4</CODE>). Le nom d'hôte de l'unité d'affichage est le nom de l'ordinateur 
sur lequel tourne le serveur X. Si le nom de l'hôte est omis, cela signifie 
qu'il s'agit de l'ordinateur local.
D'habitude, le numéro de séquence est 0 &ndash; cela peut changer s'il 
y a plusieurs unités d'affichage connectées sur le même ordinateur.</P>
<P>Si jamais il vous arrive de voir le nom d'une unité d'affichage avec un
<CODE>.n</CODE> supplémentaire accolé à son nom, c'est qu'il s'agit d'un numéro
d'écran. Une unité d'affichage peut, en théorie, avoir plusieurs écrans.
Cependant, d'habitude, il n'y en a qu'un, qui porte le numéro 
<CODE>n=0</CODE>, et c'est le numéro par défaut.</P>

<P>D'autres formes de <CODE>DISPLAY</CODE> existent, mais celle-ci suffira 
pour notre propos.</P>
<P>Pour celui qui est curieux de technique&nbsp;:
<UL>
<LI> <CODE>hostname:D.S</CODE> signifie écran <CODE>S</CODE> sur unité d'affichage
<CODE>D</CODE> de l'hôte <CODE>hostname</CODE>&nbsp;: le serveur X de cette unité
d'affichage est à l'écoute du port TCP <CODE>6000+D</CODE>.
</LI>
<LI> <CODE>host/unix:D.S</CODE> signifie écran <CODE>S</CODE> sur unité d'affichage
<CODE>D</CODE> de l'hôte <CODE>host</CODE>&nbsp;: le serveur X de cette unité d'affichage
est à l'écoute du socket de domaine UNIX <CODE>/tmp/.X11-unix/XD</CODE>
(et donc, seul <CODE>host</CODE> peut l'atteindre).
</LI>
<LI> <CODE>:D.S</CODE> est équivalent à <CODE>host/unix:D.S</CODE>, où <CODE>host</CODE>
est le nom de l'hôte local.
</LI>
</UL>
</P>

<H2><A NAME="s5">5. Dire au client&nbsp;...</A></H2>

<P>Le programme client (par exemple, votre application graphique)
sait à quelle unité d'affichage il doit se connecter en consultant la
variable d'environnement <CODE>DISPLAY</CODE>. Cependant ce paramétrage peut être
modifié en lançant le client avec l'argument  <CODE>-display
hostname:0</CODE> dans la ligne de commande. Quelques exemples peuvent
clarifier les choses.</P>

<P>Notre ordinateur est connu du monde extérieur sous le nom light, et nous 
sommes dans le domaine uni.verse. 
Si nous fonctionnons avec un serveur X normal,
l'unité d'affichage est connue comme étant <CODE>light.uni.verse:0</CODE>.
Nous voulons faire tourner le programme de dessin xfig
sur un ordinateur à distance, appelé
<CODE>dark.matt.er</CODE>,
et afficher sa sortie ici, sur light.</P>
<P>Supposons que vous vous soyez déjà connecté par telnet à l'ordinateur distant,
<CODE>dark.matt.er</CODE>.</P>
<P>Si l'interpréteur de commande de l'ordinateur éloigné est csh&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
dark% setenv DISPLAY light.uni.verse:0
dark% xfig &amp;
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Ou, d'une autre manière&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
dark% xfig -display light.uni.verse:0 &amp;
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Si c'est sh qui tourne sur l'ordinateur à distance&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
dark$ DISPLAY=light.uni.verse:0
dark$ export DISPLAY
dark$ xfig &amp;
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Ou, autrement&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
dark$ DISPLAY=light.uni.verse:0 xfig &amp;
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Ou, bien sûr, également&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
dark$ xfig -display light.uni.verse:0 &amp;
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Il paraît que certaines versions de telnet transmettent automatiquement la
variable
<CODE>DISPLAY</CODE>
à l'ordinateur hôte éloigné. Si vous avez l'une de celles-ci, vous avez de la
chance, et c'est effectivement automatique. Si ce n'est pas le cas, la
plupart des versions de telnet <EM>doivent</EM> transmettre la variable
d'environnement <CODE>TERM</CODE>, et avec un bidouillage judicieux, il est
possible de superposer la variable
<CODE>DISPLAY</CODE>
sur la variable <CODE>TERM</CODE>.</P>
<P>L'idée, sous-jacente à cette superposition, est de réaliser une sorte de script
pour effectuer ceci&nbsp;: avant la connexion par telnet, donnez la valeur de
<CODE>DISPLAY</CODE> à <CODE>TERM</CODE>. Puis, lancez telnet. Du côté de l'ordinateur
distant, dans le fichier <CODE>.*shrc</CODE> concerné, lisez la valeur de
<CODE>DISPLAY</CODE> à partir de <CODE>TERM</CODE>.</P>

<H2><A NAME="s6">6. Dire au serveur&nbsp;...</A></H2>

<P>Le serveur n'acceptera pas de connexions venant de n'importe où. Vous
ne voulez pas que n'importe qui puisse afficher des fenêtres sur votre
écran. Ou lire ce vous tapez &ndash; souvenez-vous que votre clavier 
fait partie de votre unité d'affichage&nbsp;!</P>

<P>Trop peu de gens semble réaliser que permettre l'accès à leur unité 
d'affichage pose des problèmes de sécurité. Quelqu'un qui dispose d'un
accès à votre unité d'affichage peut lire et écrire sur vos écrans, lire 
vos frappes au clavier, et suivre les déplacements de votre mulot.</P>
<P>La plupart des serveurs disposent de deux manières d'authentifier les
demandes de connexions qui arrivent&nbsp;:
le mécanisme de la liste d'hôtes (xhost) et le mécanisme du mot de 
passe secret (magic cookie) (xauth).
De plus, il y a ssh, l'interpréteur de commande sécurisé,
qui peut acheminer les connexions X.</P>
<P>Veuillez noter que certains serveurs X (de XFree86) peuvent être configurés
pour ne pas écouter sur le port habituel TCP avec le paramètre
<CODE>-nolisten tcp</CODE>. La configuration par défaut de Debian GNU/Linux,
notamment, désactive l'écoute sur le port TCP par le serveur X. Si vous
désirez utiliser X à distance sur un système Debian, vous devriez réactiver
ceci en modifiant la façon dont est lancé le serveur X. Veuillez voir le
fichier <CODE>/etc/X11/xinit/xserverrc</CODE> pour un point de départ.</P>

<H2><A NAME="ss6.1">6.1 Xhost</A>
</H2>

<P>Xhost permet les accès basés sur les nom d'hôtes. Le serveur entretient
une liste des hôtes qui sont autorisés à se connecter à lui. Il peut
aussi désactiver complètement la vérification des hôtes. Attention&nbsp;: 
cela signifie que plus aucun contrôle n'est effectué, et donc, que
<EM>n'importe quel</EM> hôte peut se connecter&nbsp;!</P>

<P>Vous pouvez contrôler la liste des hôtes du serveur avec le programme
<CODE>xhost</CODE>.
Pour utiliser ce mécanisme dans l'exemple précédent, faites&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
light$ xhost +dark.matt.er
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Ceci permet toutes les connexions à partir de l'hôte <CODE>dark.matt.er</CODE>.
Dès que votre client X a réalisé sa connexion et affiche une fenêtre,
par sécurité, supprimez les permissions pour d'autres connexions
avec&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
light$ xhost -dark.matt.er
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Vous pouvez désactiver la vérification des hôtes avec&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
light$ xhost +
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Ceci désactive la vérification des accès des hôtes et donc permet à
<EM>tout le monde</EM> de se connecter. Vous ne devriez <EM>jamais</EM>
faire cela sur un réseau où vous n'avez pas confiance dans <EM>tous</EM>
les utilisateurs (tel internet). Vous pouvez réactiver la vérification
des hôtes avec&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
light$ xhost -
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P><CODE>xhost -</CODE>
par lui-même <EM>ne supprime pas</EM>
tous les hôtes de la liste d'accès (ce qui serait tout à fait inutile -
vous ne pourriez plus vous connecter de n'importe où, pas même de votre
hôte local).</P>
<P><EM>Xhost est un mécanisme vraiment très peu sûr.</EM> Il ne fait pas de distinction entre les différents utilisateurs
sur l'hôte à distance. De plus, les noms d'hôtes (en réalité des adresses)
peuvent être manipulés. C'est mauvais si vous vous trouvez sur un
réseau douteux (déjà, par exemple, avec un accès PPP téléphonique à 
Internet).</P>

<H2><A NAME="ss6.2">6.2 Xauth</A>
</H2>

<P>Xauth autorise l'accès à tous ceux qui connaissent le bon secret.
On appelle un tel secret un enregistrement d'autorisation ou cookie. 
Ce mécanisme d'autorisation est désigné 
cérémonieusement comme étant le MIT-MAGIC-COOKIE-1.</P>

<P>Les cookies pour les différentes unités d'affichage sont stockés
ensemble dans <CODE>~/.Xauthority</CODE>. Votre fichier  
<CODE>~/.Xauthority</CODE> doit être inaccessible pour les utilisateurs 
groupe/autres. Le programme xauth gère ces cookies, d'où le surnom xauth dans
ce schéma.</P>
<P>Vous pouvez spécifier un fichier cookie différent avec la variable
d'environnement <CODE>XAUTHORITY</CODE>, mais vous aurez rarement besoin de le
faire. Si vous ne savez pas quel fichier cookie votre xauth utilise, faites
un <CODE>xauth -v</CODE> et il vous l'indiquera.</P>
<P>Au démarrage d'une session, le serveur lit un cookie dans le fichier qui est 
indiqué par l'argument <CODE>-auth</CODE>. Ensuite, le serveur ne permet la
connexion que des clients qui connaissent le même cookie. Quand le
cookie dans <CODE>~/.Xauthority</CODE>
change, <EM>le serveur ne récupérera pas la modification</EM>.</P>

<P>Les serveurs les plus récents peuvent générer des cookies à la volée pour des
clients qui le demandent. Les cookies sont cependant encore conservés dans le
serveur&nbsp;: ils ne finissent pas dans <CODE>~/.Xauthority</CODE>
à moins qu'un client ne les y mettent. Selon David Wiggins&nbsp;:</P>
<P>
<BLOCKQUOTE>
Une possibilité supplémentaire , qui peut vous intéresser, a été ajoutée
dans X11R6.3.
Par l'intermédiaire de la nouvelle extension SECURITY, le serveur X 
lui-même peut générer et renvoyer de nouveaux cookies à la volée. De plus,
on peut désigner les cookies comme étant &laquo;&nbsp;douteux&nbsp;&raquo; de sorte que les 
applications qui se connectent avec de tels cookies auront une capacité
opératoire restreinte. Par exemple, ils ne pourront pas regarder les entrées
au clavier/mulot, ou le contenu des fenêtres, d'autres clients &laquo;&nbsp;fiables&nbsp;&raquo;. 
Il y a une nouvelle sous-commande &laquo;&nbsp;generate&nbsp;&raquo; de xauth pour rendre cette
fonctionnalité, pas forcément facile, mais au moins possible à utiliser.
</BLOCKQUOTE>
</P>
<P>Xauth possède un avantage clair, au niveau de la sécurité, sur xhost. Vous
pouvez limiter l'accès à des utilisateurs spécifiques sur des ordinateurs
spécifiques. Il ne permet pas l'usurpation d'adresse comme le permet xhost. 
Et, si vous le désirez, vous pouvez encore utiliser xhost en parallèle pour
permettre des connexions.</P>

<H3>Fabrication du cookie</H3>

<P>Si vous voulez utiliser xauth, vous devez lancer le serveur X avec 
l'argument <CODE>-auth authfile</CODE>. Si vous utilisez le script
<B>startx</B> pour lancer le serveur X, c'est le bon endroit pour le
faire. Créez l'enregistrement d'autorisation comme indiqué ci-dessous dans
votre script startx.</P>
<P>Extrait de <CODE>/usr/X11R6/bin/startx</CODE>&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
mcookie|sed -e 's/^/add :0 . /'|xauth -q
xinit -- -auth "$HOME/.Xauthority"
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Mcookie est un petit programme du paquet util-linux, site primaire
<A HREF="ftp://ftp.win.tue.nl/pub/linux-local/utils/util-linux">ftp://ftp.win.tue.nl/pub/linux-local/utils/util-linux</A>. 
Autrement, vous pouvez utiliser md5sum pour créer quelques données 
aléatoires (de, par exemple, <CODE>/dev/urandom</CODE> ou <CODE>ps -axl</CODE>) au 
format cookie&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
dd if=/dev/urandom count=1|md5sum|sed -e 's/^/add :0 . /'|xauth -q
xinit -- -auth "$HOME/.Xauthority"
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Si vous ne pouvez pas éditer le script startx (parce que vous n'êtes pas root),
demandez à votre administrateur système de configurer startx correctement,
ou, à la place, laissez-le configurer xdm. S'il ne peut, ou ne veut, pas, vous
pouvez écrire un script <CODE>~/.xserverrc</CODE>. Si vous avez ce script, 
il sera exécuté par xinit au lieu du véritable serveur X. Alors, vous pourrez 
lancer le serveur X véritable à partir de ce script avec les arguments adaptés.
Pour faire cela, faites utiliser par votre <CODE>~/.xserverrc</CODE> le
<CODE>mcookie</CODE> de la ligne ci-dessus pour créer un cookie puis lancer le
véritable serveur X&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
#!/bin/sh
mcookie|sed -e 's/^/add :0 . /'|xauth -q
exec /usr/X11R6/bin/X "$@" -auth "$HOME/.Xauthority"
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Si vous utilisez xdm pour gérer vos sessions X, vous pouvez
utiliser xauth facilement. Définissez les ressources du 
DisplayManager.authDir dans <CODE>/etc/X11/xdm/xdm-config</CODE>.
Xdm passera l'argument <CODE>-auth</CODE> au serveur X à son démarrage. Au moment de
la connexion sous xdm, xdm place le cookie dans
<CODE>~/.Xauthority</CODE> pour vous. Consultez xdm(1) pour de plus
amples informations.
Par exemple, mon <CODE>/etc/X11/xdm/xdm-config</CODE>
contient la ligne suivante&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
DisplayManager.authDir: /var/lib/xdm
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H3>Transfert du cookie</H3>

<P>Maintenant que vous avez lancé votre session X sur le serveur hôte 
<CODE>light.uni.verse</CODE> et que vous avez votre cookie dans
<CODE>~/.Xauthority</CODE>, il vous faut transférer le cookie sur 
le client, <CODE>dark.matt.er</CODE>. Il y a plusieurs façons de le faire.</P>

<H3>Répertoires personnels (home) partagés</H3>

<P>Le plus simple est que vos répertoires sur <CODE>light</CODE> et <CODE>dark</CODE>
soient partagés. Les fichiers <CODE>~/.Xauthority</CODE> sont les mêmes,
donc le cookie est transféré instantanément.
Cependant, il y a un piège&nbsp;: lorsque vous mettez un cookie pour <CODE>:0</CODE> 
dans <CODE>~/.Xauthority</CODE>, dark va croire que c'est un cookie pour lui
au lieu de light. Il faut que vous utilisiez un nom d'hôte explicite à la 
création du cookie&nbsp;: on ne peut pas faire autrement. Vous pouvez installer
le même cookie pour, à la fois, <CODE>:0</CODE> et <CODE>light:0</CODE> avec un peu d'astuce&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
#!/bin/sh
mcookie|sed -e 's/^/add :0 . /' -e p -e "s/:/$HOST&amp;/"|xauth -q
exec /usr/X11R6/bin/X "$@" -auth "$HOME/.Xauthority"
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H3>En utilisant le shell à distance, <CODE>rsh</CODE></H3>

<P>Si les répertoires <EM>home</EM> ne sont pas partagés, vous pouvez transférer le cookie
au moyen de rsh, le shell à distance&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
light$ xauth nlist "${HOST}:0" | rsh dark.matt.er xauth nmerge -
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>
<OL>
<LI> Extraire le cookie de votre fichier local <CODE>~/.Xauthority</CODE>
(<CODE>xauth nlist :0</CODE>).
</LI>
<LI> Le transférer vers dark.matt.er (<CODE>| rsh dark.matt.er</CODE>).
</LI>
<LI> Le mettre dans <CODE>~/.Xauthority</CODE> là (<CODE>xauth nmerge -</CODE>).
</LI>
</OL>
</P>

<P>Notez l'utilisation de <CODE>${HOST}</CODE>. Vous devez transférer le cookie qui
est explicitement associé à l'hôte local. Une application X distante
interpréterait une valeur d'unité d'affichage égale à <CODE>:0</CODE> comme
étant une référence à la machine distante, ce qui ne correspond pas à ce
que l'on veut&nbsp;!</P>

<H3>Manuellement, par Telnet</H3>

<P>Il est possible que <CODE>rsh</CODE> ne fonctionne pas chez vous. En plus de
cela, <CODE>rsh</CODE> a un inconvénient en ce qui concerne la sécurité
(noms d'hôtes usurpés, si je me souviens bien). Si vous ne pouvez, ou ne 
voulez, pas utiliser <CODE>rsh</CODE>, vous pouvez également transférer le 
cookie manuellement, comme ceci&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
light$ echo $DISPLAY
:0
light$ xauth list $DISPLAY
light/unix:0 MIT-MAGIC-COOKIE-1 076aaecfd370fd2af6bb9f5550b26926
light$ rlogin dark.matt.er
Password:
dark% setenv DISPLAY light.uni.verse:0
dark% xauth
Using authority file /home/zweije/.Xauthority
xauth> add light.uni.verse:0 . 076aaecfd370fd2af6bb9f5550b26926
xauth> exit
Writing authority file /home/zweije/.Xauthority
dark% xfig &amp;
[15332]
dark% logout
light$
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Consultez également rsh(1) et xauth(1x) pour de plus amples informations.</P>

<H3>En automatisant la méthode Telnet</H3>

<P>Il doit être possible de superposer le cookie sur la
variable <CODE>TERM</CODE> ou <CODE>DISPLAY</CODE> quand vous utilisez telnet sur l'hôte 
éloigné. Cela doit fonctionner de la même manière que de superposer la 
variable <CODE>DISPLAY</CODE> sur la variable <CODE>TERM</CODE>. Regardez la section 5&nbsp;:
Dire au client. De mon point de vue, sur ce sujet, vous prenez vos 
responsabilités, mais cela m'intéresse si quelqu'un peut me confirmer ou 
m'infirmer cela.</P>
<P>Notez, cependant, qu'avec certains Unix les variables d'environnement peuvent 
être visibles par les autres et vous ne pourrez pas empêcher la
visualisation du cookie dans <CODE>$TERM</CODE> si certains veulent le voir. </P>

<H3>Utilisation du cookie</H3>

<P>Une application X, telle que <CODE>xfig</CODE> ci-dessus, sur 
<CODE>dark.matt.er</CODE>, ira automatiquement voir le cookie dans
<CODE>~/.Xauthority</CODE> pour s'authentifier.</P>

<P>L'utilisation de <CODE>localhost:D</CODE> entraîne une petite difficulté.
Les applications X clientes traduisent <CODE>localhost:D</CODE> en 
<CODE>host/unix:D</CODE> pour effectuer la recherche du cookie. 
Effectivement, cela signifie qu'un cookie pour <CODE>localhost:D</CODE> dans 
votre <CODE>~/.Xauthority</CODE> n'a <EM>aucun</EM> effet.</P>
<P>Si l'on y réfléchit, c'est logique. L'interprétation de <CODE>localhost</CODE>
dépend entièrement de la machine sur laquelle s'effectue cette interprétation.
Si ce n'était pas le cas, cela causerait un horrible bazar dans le cas 
d'un répertoire personnel (home) partagé, par exemple par l'intermédiaire de
NFS, avec plusieurs hôtes interférant chacun avec ses propres cookies.</P>

<H2><A NAME="ss6.3">6.3 Ssh</A>
</H2>

<P>Les enregistrements d'autorisation sont transmis sur le réseau sans 
codage. Si vous vous
souciez de ce que l'on puisse espionner vos connexions, utilisez ssh, le
shell sécurisé. Il effectuera des transmissions X sécurisées au moyen de
connexions chiffrées.</P>
<P>Pour activer la transmission X par ssh, utilisez l'option de la ligne de
commande <CODE>-X</CODE> ou écrivez ce qui suit dans votre fichier local de
configuration de ssh&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
Host remote.host.name
  ForwardX11 yes
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Le serveur ssh (<CODE>sshd</CODE>) du côté distant positionnera automatiquement la
variable <CODE>DISPLAY</CODE> sur l'extrémité du tunnel X transmis. Le tunnel
distant récupère son propre cookie&nbsp;; le serveur ssh distant le génère
pour vous et le place dans <CODE>~/.Xauthority</CODE> là-bas. Ainsi,
l'autorisation X avec ssh est complètement automatique.</P>
<P>De plus, il est génial pour d'autres choses aussi. C'est une bonne
amélioration structurelle de votre système. Allez simplement voir 
<A HREF="http://www.ssh.org/">http://www.ssh.org/</A>, la page d'accueil de
ssh.</P>

<P>Si vous possédez d'autres informations sur les méthodes d'authentification ou
de chiffrement des connexions X, par exemple, grâce à Kerberos, envoyez-les moi,
je les intégrerai ici.</P>

<H2><A NAME="s7">7. Les applications X avec un identificateur d'utilisateur (User-id) différent</A></H2>

<P>Supposez que vous vouliez faire tourner un outil graphique de configuration
qui nécessite d'avoir les privilèges du compte <EM>root</EM> alors que la 
session X actuelle se déroule sous votre compte. Cela peut sembler étrange 
au premier abord, mais le serveur X <EM>ne</EM> permettra <EM>pas</EM> à cet outil
d'accéder à votre unité d'affichage. Comment cela est-il possible alors
que <EM>root</EM> peut normalement tout faire&nbsp;? Et comment contourner ce
problème&nbsp;?</P>

<P>Élargissons le propos au cas où l'on veut faire tourner une application X,
sous un identificateur d'utilisateur <CODE>clientuser</CODE>, alors que la session
X a été lancée par <CODE>serveruser</CODE>. Si vous avez lu le paragraphe sur les
<EM>cookies</EM>, il est évident que <CODE>clientuser</CODE> ne peut pas accéder à
votre unité d'affichage&nbsp;: 
<CODE>~clientuser/.Xauthority</CODE> ne contient pas le cookie magique qui permet
d'accéder à l'unité d'affichage. Le cookie correct se trouve dans
<CODE>~serveruser/.Xauthority</CODE>.</P>

<H2><A NAME="ss7.1">7.1 Plusieurs utilisateurs sur le même hôte </A>
</H2>

<P>Naturellement, tout ce qui marche pour un X distant marchera aussi pour
un X à partir d'un identificateur d'utilisateur différent (particulièrement
<CODE>slogin localhost -l clientuser</CODE>). Et ici l'hôte client et l'hôte
serveur sont précisément les mêmes. Cependant, quand les deux hôtes
sont les mêmes, il y a quelques raccourcis pour transférer le 
<EM>cookie magique</EM>.</P>

<P>On supposera que l'on utilise <CODE>su</CODE> pour passer d'un identificateur 
utilisateur à l'autre. Essentiellement, il faut écrire un script qui
appelle <CODE>su</CODE>, mais enveloppe la commande que <CODE>su</CODE> exécute d'un
peu de code qui effectue les tâches nécessaires pour le X distant.
Ces tâches nécessaires sont l'initialisation de la variable <CODE>DISPLAY</CODE>
et le transfert du <EM>cookie magique</EM>.</P>

<P>L'initialisation de <CODE>DISPLAY</CODE> est relativement facile&nbsp;; il faut
simplement définir
<CODE>DISPLAY="$DISPLAY"</CODE> avant d'exécuter l'argument de la commande su. Donc,
il faut simplement faire&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
su - clientuser -c "env DISPLAY="$DISPLAY" clientprogram &amp;"
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>Ce n'est pas tout, il faut encore transférer le cookie. On peut le retrouver
en utilisant <CODE>xauth list "$DISPLAY"</CODE>.  Cette commande renvoie le
cookie dans un format qui convient pour l'utiliser dans la commande
<CODE>xauth add</CODE>&nbsp;: ce dont
nous avons justement besoin&nbsp;!</P>
<P>On pourrait imaginer passer le cookie par l'intermédiaire d'un canal de
transmission.
Manque de chance, ce n'est pas si facile de passer quelque chose à la
commande <CODE>su</CODE> par l'intermédiaire d'un canal de transmission car <CODE>su</CODE>
attend le mot de passe de l'entrée standard. Cependant, dans un script shell
on peut jongler avec quelques descripteurs de fichiers et arriver à le faire.</P>
<P>Donc, on écrit un script de ce style en le paramétrant avec <CODE>clientuser</CODE> et
<CODE>clientprogram</CODE>. Pendant que nous y sommes, améliorons un peu ce
script, ça va le rendre un peu moins compréhensible mais un
peu plus robuste. Le tout ressemble à cela&nbsp;: </P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
#!/bin/sh

if [ $# -lt 2 ]
then echo "usage: `basename $0` clientuser command" >&amp;2
     exit 2
fi

CLIENTUSER="$1"
shift

# FD 4 becomes stdin too
exec 4>&amp;0

xauth list "$DISPLAY" | sed -e 's/^/add /' | {

    # FD 3 becomes xauth output
    # FD 0 becomes stdin again
    # FD 4 is closed
    exec 3>&amp;0 0>&amp;4 4>&amp;-

    exec su - "$CLIENTUSER" -c \
         "xauth -q &lt;&amp;3
          exec env DISPLAY='$DISPLAY' "'"$SHELL"'" -c '$*' 3>&amp;-"

}
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Je pense que c'est portable et que cela fonctionne suffisamment correctement
dans la plupart des circonstances. Le seul défaut auquel je pense en ce 
moment est dû à l'utilisation de <CODE>'$*'</CODE>, les guillemets simples dans
<CODE>command</CODE> vont perturber les guillemets de l'argument(<CODE>'$*'</CODE>)
de la commande <CODE>su</CODE>. Si cela entraîne quelque chose de vraiment gênant, 
envoyez-moi un courrier électronique.</P>

<P>Nommez le script <CODE>/usr/local/bin/xsu</CODE>, et vous pouvez faire&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
xsu clientuser 'command &amp;'
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>Cela ne peut pas être plus facile, à moins que vous ne vous débarrassiez du
mot de passe. Oui, il existe des moyens pour y arriver (<CODE>sudo</CODE>), mais
ce n'est pas l'endroit pour en parler.</P>

<P>Le petit script <CODE>xsu</CODE> mentionné ci-dessus a servi comme base pour un
script plus étendu appelé <CODE>sux</CODE> qui a, apparemment, trouvé sa place
comme paquet dans la distribution 
<A HREF="http://www.debian.org/">Debian</A>.</P>

<H2><A NAME="ss7.2">7.2 Root est l'utilisateur client</A>
</H2>

<P>Évidemment, tout ce qui marche pour un client non root doit fonctionner
pour root. Cependant, avec root vous pouvez faire cela encore plus
facilement, car celui-ci peut lire le fichier <CODE>~/.Xauthority</CODE> de
tout le monde. Il n'y a pas besoin de transférer le cookie. Tout ce
qu'il y a à faire consiste à initialiser <CODE>DISPLAY</CODE>, et à faire pointer
<CODE>XAUTHORITY</CODE> sur <CODE>~serveruser/.Xauthority</CODE>. Donc, vous
pouvez écrire&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
su - -c "exec env DISPLAY='$DISPLAY' \
                  XAUTHORITY='${XAUTHORITY-$HOME/.Xauthority}' \
                  command"
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>Et, en mettant cela dans un script, cela donne quelque chose comme&nbsp;</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
#!/bin/sh
if [ $# -lt 1 ]
then echo "usage: `basename $0` command" >&amp;2
     exit 2
fi
su - -c "exec env DISPLAY='$DISPLAY' \
                  XAUTHORITY='${XAUTHORITY-$HOME/.Xauthority}' \
                  "'"$SHELL"'" -c '$*'"
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>Nommez le script <CODE>/usr/local/bin/xroot</CODE>, et vous pouvez faire&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
xroot 'control-panel &amp;'
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>Cependant, si vous avez déjà initialisé <CODE>xsu</CODE> , il n'y a pas de vraie
raison de faire cela.</P>

<H2><A NAME="s8">8. Faire tourner un gestionnaire de fenêtres distant</A></H2>

<P>Un gestionnaire de fenêtres (comme <CODE>twm</CODE>, <CODE>wmaker</CODE>, ou <CODE>fvwm95</CODE>)
est une application comme n'importe quelle autre. La procédure normale devrait
fonctionner.</P>

<P>Enfin, presque. Il ne peut tourner, au plus, qu'un seul gestionnaire de
fenêtres à un instant donné dans une unité d'affichage. Si vous faites déjà 
tourner un gestionnaire de fenêtre local, vous ne pouvez pas lancer
le gestionnaire distant (il le dira et s'arrêtera). Il faut tuer (ou
simplement quitter) le gestionnaire local en premier.</P>

<P>Par manque de chance, beaucoup de scripts de sessions X se terminent par un</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
exec le-gestionnaire-de-fenetres-de-votre-choix
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>et cela signifie que quand le gestionnaire de fenêtre (local) se termine,
votre session se termine, et le système (xdm ou xinit) considère que votre 
session est terminée, et effectivement, vous déconnecte.</P>

<P>Vous aurez encore à faire quelques contorsions, mais vous devez y arriver
et ce n'est pas trop difficile. Amusez-vous un peu avec
votre script de session (normalement <CODE>~/.xsession</CODE> ou
<CODE>~/.xinitrc</CODE>) pour arriver à vos fins.</P>

<P>Attention, un gestionnaire de fenêtres permet souvent de faire tourner
de nouveaux programmes qui s'exécuteront sur la machine locale. C'est-à-dire
locale à la machine sur lequel tourne le gestionnaire de fenêtres. Si vous
faites tourner un gestionnaire de fenêtres distant, il lancera des 
applications distantes, et ce n'est peut-être pas ce que vous voulez.
Naturellement, elles continueront à s'afficher sur l'unité d'affichage
qui est locale pour vous.</P>

<H2><A NAME="s9">9. Mettre en place un terminal X</A></H2>

<P>Trouvez une utilisation à votre vieux PC&nbsp;! Faites-en un endroit
supplémentaire pour pouvoir travailler&nbsp;! Pas besoin d'acheter un
nouveau matériel coûteux&nbsp;! Vous avez déjà tout ce qu'il faut&nbsp;!</P>

<P>Sérieusement, vous pouvez mettre en place un vieux PC comme terminal X. Un
terminal X est un ordinateur qui fondamentalement n'exécute rien d'autre
qu'un serveur X. Vous pouvez vous connecter dessus et obtenir une session
X, avec des xterms, xbiff, xclock et tout autre client X concevable.
Cependant, les clients X s'exécuteront sur l'hôte distant et ils
utiliseront le serveur X distant pour afficher leur sortie sur votre
terminal X local. Même le gestionnaire de fenêtre s'exécutera à distance.</P>

<P>Un terminal X consomme peu de ressources en comparaison d'une machine Unix
complète. J'ai ici un terminal X constitué par un processeur 486,
16&nbsp;Mo de RAM et 250&nbsp;Mo d'espace disque. Oh et une connexion
réseau, naturellement. Il n'a même pas besoin d'avoir des répertoires
utilisateurs.</P>

<P>Pour trouver des lectures liées à ce sujet, jetez un coup d'oeil aux
documents suivants&nbsp;:</P>
<P>
<UL>
<LI>
Le <EM>petit guide XDM et Terminal X</EM> (
<A HREF="http://www.traduc.org/docs/HOWTO/mini/lecture/XDM-Xterm.html">http://www.traduc.org/docs/HOWTO/mini/lecture/XDM-Xterm.html</A>).
Ce document est une description complète de ce qui est possible avec
XDMCP et xdm, appliqué à la construction de terminaux X. Vous devriez
vraiment le lire.
</LI>
<LI>
Le <EM>guide pratique XDMCP</EM> (
<A HREF="http://www.traduc.org/docs/HOWTO/lecture/XDMCP-HOWTO.html">http://www.traduc.org/docs/HOWTO/lecture/XDMCP-HOWTO.html</A>).
Ce document décrit les étapes nécessaires à la mise en place de xdm
pour utiliser des serveurs X distants, comme depuis un terminal X. La
configuration du serveur X dans une telle situation est décrite de
façon plus succinte.
</LI>
<LI>
Le <EM>petit guide Xterminal</EM> (
<A HREF="http://www.traduc.org/docs/HOWTO/mini/lecture/X-Terminal.html">http://www.traduc.org/docs/HOWTO/mini/lecture/X-Terminal.html</A>).
Il n'est pas actuellement maintenu, mais il peut contenir quelques
informations intéressantes pour vous.
</LI>
</UL>
</P>

<P>À la différence des documents ci-dessus, le document que vous êtes en train de
lire se limite à une courte description de XDMCP, mais il insiste plus sur les
problèmes de sécurité impliqués.</P>

<H2><A NAME="ss9.1">9.1 Une fois de plus, un peu de théorie en premier</A>
</H2>

<P>En ce qui concerne X, le terminal X va n'exécuter rien d'autre qu'un
serveur X. Ce serveur X sera configuré pour dialoguer avec l'hôte distant
en utilisant XDMCP (le protocole de contrôle de gestion d'affichage X,
«&nbsp;X Display Manager Control Protocol&nbsp;»). Il va demander à l'hôte
distant une session X. L'hôte distant fournira une fenêtre de connexion
dans le terminal X et après la connexion, il exécutera une session X avec
tout l'habillage y compris le gestionnaire de fenêtres, tout cela
utilisant X distant pour l'affichage sur le terminal X.</P>

<P>Vous aurez probablement remarqué que l'hôte distant agit comme un serveur,
bien que pas comme un serveur X. L'hôte distant fournit les sessions X aux
serveurs X qui les demandent. Ainsi, selon XDMCP, l'hôte distant est en
fait un serveur, fournissant des sessions X, également connu sous le nom de
serveur XDMCP. Le serveur X joue le rôle d'un client XDMCP&nbsp;! Vous me
suivez&nbsp;?</P>

<P>Le programme qui fournit le service XDMCP sur le serveur XDMCP est
<CODE>xdm</CODE>. Donc, pour exécuter un terminal X, vous devez configurer deux
programmes&nbsp;: <CODE>X</CODE> (le client XDMCP) sur le terminal X et xdm (le
serveur XDMCP) sur l'hôte distant.</P>

<P>Vous devez toujours vous rappeler que le protocole X (et le protocole
XDMCP) n'est pas chiffré. Si vous devez utiliser X à distance, tout ce
qui transite sur le réseau peut être espionné par d'autres hôtes du réseau.
Ceci est particulièrement néfaste avec les sessions X distantes car la
première chose qui se passe est la connexion en donnant l'utilisateur et le
mot de passe. <B>Vous ne devez donc exécuter X à distance que sur un réseau
sécurisé&nbsp;!</B></P>

<H2><A NAME="ss9.2">9.2 Configurer <CODE>X</CODE> comme client XDMCP</A>
</H2>

<P>Si vous désirez mettre en place une machine Linux comme terminal X, vous
avez besoin de très peu de ressources. Fondamentalement, vous avez besoin
de ce qu'il est nécessaire d'avoir pour faire fonctionner une machine Linux
dépouillée  plus un serveur X. Spécifiquement, vous
<EM>n'avez pas</EM> besoin des clients et bibliothèques X. Il peut être utile
d'installer certaines polices X, mais vous pouvez également utiliser un
serveur de polices situé quelque part sur le réseau.</P>

<P>Il existe plusieurs moyens pour un serveur X d'obtenir une session X d'un
serveur XDMCP. La plus simple est d'aller directement à un serveur XDMCP
connu et de lui en demander une. Le serveur peut également émettre en
multi-diffusion une requête et utiliser le premier serveur XDMCP qui
répond. Enfin, le serveur X peut demander à un serveur XDMCP de lui fournir
une liste des hôtes qui acceptent de fournir une session et laisser
l'utilisateur choisir l'hôte de session.</P>
<P>
<OL>
<LI>Si vous connaissez l'hôte qui va vous fournir une session, utilisez-le
directement. Exécutez
<BLOCKQUOTE><CODE>
<PRE>
X -query sessionhost
</PRE>
</CODE></BLOCKQUOTE>

et, en supposant que <CODE>xdm</CODE> fonctionne sur <CODE>sessionhost</CODE>, vous
obtiendrez une fenêtre de connexion et, après connexion, une session X.
</LI>
<LI>Si l'hôte duquel vous obtiendrez la session vous importe peu, utilisez la
méthode d'émission de multi-diffusion. Exécutez
<BLOCKQUOTE><CODE>
<PRE>
X -broadcast
</PRE>
</CODE></BLOCKQUOTE>

et, en supposant que <CODE>xdm</CODE> fonctionne sur un hôte quelque part sur le
réseau, vous obtiendrez une fenêtre de connexion du premier (et, on
l'espère, du plus rapide) <CODE>xdm</CODE> qui répond et, après connexion, une
session X.
</LI>
<LI>Si vous désirez choisir l'hôte où vous voulez avoir votre session, demandez
au serveur XDMCP une liste des hôtes. Exécutez
<BLOCKQUOTE><CODE>
<PRE>
X -indirect xdmcpserver
</PRE>
</CODE></BLOCKQUOTE>

et, en supposant que <CODE>xdm</CODE> est bien configuré sur ce serveur, une liste
des hôtes vous sera présentée parmi lesquels vous pourrez choisir.
Choisissez-en un&nbsp;; vous obtiendrez la fenêtre de connexion pour cet
hôte et, après connexion, la session que vous avez demandée.
</LI>
</OL>
</P>

<P>Il se peut que vous ayez remarqué l'absence de l'option <CODE>-auth</CODE>. Le
serveur X utilisera XDMCP pour négocier le mot de passe secret
(«&nbsp;magic cookie&nbsp;») avec le serveur XDMCP. Le serveur XDMCP
placera le cookie dans votre <CODE>~/.Xauthority</CODE> après la connexion.</P>

<P>Après la fermeture d'une session, le serveur X va boucler, il reviendra au
serveur XDMCP d'origine et lui demandera une nouvelle session (ou une liste
de choix). Si vous ne désirez pas cela, vous pouvez utiliser l'option
<CODE>-once</CODE>. Notez que ceci ne semble pas fonctionner avec l'option
<CODE>-indirect</CODE> à cause de l'implémentation du «&nbsp;chooser&nbsp;».</P>

<P>Quand vous avez déterminé la façon dont vous allez exécuter le serveur X,
vous pouvez alors le placer dans un script de démarrage ou même l'exécuter
directement à partir de <CODE>/etc/inittab</CODE>. Veuillez consulter la
documentation de votre propre distribution pour savoir comment modifier vos
scripts d'amorçage ou <CODE>/etc/inittab</CODE>.</P>

<P>N'exécutez <EM>pas</EM> un serveur X ainsi depuis le fichier de configuration
<CODE>Xservers</CODE>.  <CODE>xdm</CODE> s'attend à pouvoir se connecter à de tels serveurs
et il pourrait les tuer s'il ne peut pas se connecter.</P>

<H2><A NAME="ss9.3">9.3 Configurer <CODE>xdm</CODE> comme serveur XDMCP</A>
</H2>

<P>Le programme qui fournit le service XDMCP (le service de session) est
généralement <CODE>xdm</CODE>. Il existe des variantes de celui-ci, comme <CODE>wdm</CODE>
ou <CODE>gdm</CODE> sur Linux, mais ceux-ci fonctionnent fondamentalement de la
même façon. Assurez-vous donc que <CODE>xdm</CODE> ou une variante est installé sur
l'hôte où vous désirez exécuter vos sessions X. Si vous disposez d'une
connexion graphique locale depuis l'hôte de session X, <CODE>xdm</CODE> est déjà
installé&nbsp;; la plupart des distributions Linux sont ainsi fournis de
nos jours.</P>

<P>En plus de <CODE>xdm</CODE>, vous aurez besoin des programmes que vous désirez
exécuter dans une session X. C'est-à-dire, tous les clients X comme
<CODE>xterm</CODE>, <CODE>xfig</CODE>, <CODE>xclock</CODE>, des gestionnaires de fenêtre et ainsi
de suite. Cependant, pour un serveur XDMCP, vous n'avez <EM>pas</EM> besoin
d'installer de serveur X&nbsp;; le serveur X fonctionnera à la place sur le
terminal X.</P>

<P>À partir de l'histoire sur le serveur X ci-dessus, vous pouvez en conclure
qu'il y a fondamentalement deux types de services XDMCP. Il y a le
service <EM>direct</EM> qui consiste à permettre la connexion d'un client XDMCP
et à lui fournir une session X. Il y a également le service <EM>indirect</EM>
dans lequel le serveur fournit une liste d'hôtes fournissant un service
direct, au choix pour le client XDMCP.</P>

<P>Tous les services <CODE>xdm</CODE> sont configurés dans le fichier d'accès,
généralement situé à <CODE>/etc/X11/xdm/Xaccess</CODE> ou un emplacement
semblable. Cet emplacement est en fait défini dans le fichier de
configuration général de <CODE>xdm</CODE> <CODE>/etc/X11/xdm/xdm-config</CODE> par la
ressource <CODE>accessFile</CODE>. Veuillez voir votre manuel <CODE>xdm</CODE> pour
l'emplacement par défaut.</P>
<P>
<OL>
<LI><P>Si vous désirez autoriser <CODE>xdm</CODE> à fournir des sessions X aux clients
XDMCP, que ce soit par multi-diffusion ou non, placez le nom d'hôte du
client XDMCP (le serveur X, vous vous souvenez&nbsp;?) seul sur une ligne
dans le fichier <CODE>Xaccess</CODE>. En fait, vous pouvez placer un expression
rationnelle correspondant à plusieurs hôtes. Voici quelques expressions
valides&nbsp;:
<BLOCKQUOTE><CODE>
<PRE>
xterm023.my.domain      # xterm023.my.domain peut obtenir une session X
*.my.domain             # tout hôte dans my.domain peut obtenir une session X
*                       # tout hôte sur Internet peut obtenir une session X (non sécurisé)
</PRE>
</CODE></BLOCKQUOTE>
</P>

<P>Vouloir fournir une session X à tout hôte sur Internet est discutable. De
façon évidente, tout service que vous fournissez est une faille de sécurité
potentielle dans la sécurité de votre serveur. D'un autre côté, le serveur
devrait être sécurisé lui-même et un client XDMCP demandant une session X
doit fournir une authentification valide avant que la session X ne soit
accordée.</P>

<P>De plus, la session X utilise une connexion X distante qui n'est pas
chiffrée. La paire nom d'utilisateur/mot de passe de connexion sera
transportée sur cette connexion. Toute personne pourrait alors espionner
des combinaisons valides d'utilisateur/mot de passe tout comme sur des
connexions telnet simple. Ceci est même pire que d'avoir son mot de passe
secret («&nbsp;magic cookie&nbsp;») espionné.</P>

<P>Prenez vos propres décisions ici, mais je recommande de ne pas activer ce
service au monde entier à moins d'avoir une bonne raison.</P>

</LI>
<LI><P>Si vous désirez fournir aux clients XDMCP (<CODE>X -indirect xdmcpserver</CODE>)
une liste de choix (une liste d'hôtes pour choisir duquel ils obtiendront
une session X), faite suivre l'expression rationnelle du client par le
mot-clé <CODE>CHOOSER</CODE> et la liste des hôtes que le client peut choisir. À la
place de la liste des hôtes, vous pouvez également spécifier
<CODE>BROADCAST</CODE>&nbsp;; avec ceci, <CODE>xdm</CODE> émet en multi-diffusion sur le
réseau pour interroger les serveurs désirant fournir une session. Des
exemples valides&nbsp;:
<BLOCKQUOTE><CODE>
<PRE>
xterm023.my.domain      CHOOSER seshost1 seshost2
*.my.domain             CHOOSER BROADCAST
*                       CHOOSER extseshost1 extseshost2
</PRE>
</CODE></BLOCKQUOTE>

Le premier exemple permet à <CODE>xterm023</CODE> de choisir entre des sessions sur
<CODE>seshost1</CODE> et sur <CODE>seshost2</CODE>. Le deuxième exemple permet à tout hôte
dans <CODE>my.domain</CODE> de choisir n'importe quel hôte fournissant une session
X. Le troisième exemple permet à tout hôte de choisir une session entre
<CODE>extseshost1</CODE> et <CODE>extseshost2</CODE>.</P>

<P>Ce n'est probablement pas une bonne idée de faire <CODE>* CHOOSER BROADCAST</CODE>.
Ceci permettrait à tout hôte en dehors de votre réseau d'obtenir des
informations sur les hôtes dans votre réseau. Vous ne voulez probablement
pas communiquer une telle information. En fait, autoriser un choix pour
tout hôte extérieur n'est probablement pas très utile de toute façon, car
vous ne devriez pas autoriser des connexions arbitraires directes non plus.</P>

</LI>
</OL>
</P>

<P>Quand vous avez reconfiguré <CODE>xdm</CODE>, envoyez-lui le signal <CODE>HUP</CODE> pour
le forcer à relire ses fichiers de configuration.
<BLOCKQUOTE><CODE>
<PRE>
# kill -HUP pid-of-xdm
#
</PRE>
</CODE></BLOCKQUOTE>
</P>

<H2><A NAME="ss9.4">9.4 XDMCP techniquement</A>
</H2>

<P>Techniquement, pour autant que je puisse le voir, XDMCP n'est pas tout à
fait ce à quoi vous pouvez vous attendre d'après la description ci-dessus.
<CODE>xdm</CODE> peut rediriger des serveurs X se connectant, vers un autre endroit
et il utilise cette astuce pour implémenter la liste de choix. Ainsi, le
choix se produit dans xdm et non dans le serveur X bien que la liste de
choix soit représentée dans l'affichage du serveur X. C'est également pour
cela que l'option <CODE>-once</CODE> du serveur X ne se combine pas avec
<CODE>-indirect</CODE>.</P>


<H2><A NAME="s10">10. Maintenance</A></H2>

<P>D'ordinaire, la première fois que vous allez essayer de faire tourner une
application X à distance, ça ne marchera pas. Voici quelques-uns des messages
d'erreur habituels, leur cause probable et des solutions pour vous aider
à progresser.</P>

<P>
<BLOCKQUOTE><CODE>
<PRE>
xterm Xt error: Can't open display:
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Il n'y a pas de variable DISPLAY renseignée dans votre environnement et vous 
n'avez pas non plus lancé l'application avec le drapeau <CODE>-display</CODE>.
L'application assume que la variable display contient une chaîne de
caractères vide, ce qui est syntaxiquement incorrect. La solution à cela
consiste à s'assurer que la variable DISPLAY est correctement renseignée dans
l'environnement (avec <CODE>setenv</CODE> ou <CODE>export</CODE> selon votre shell).</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
_X11TransSocketINETConnect: Can't connect: errno = 101
xterm Xt error: Can't open display: love.dial.xs4all.nl:0
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Erreur 101 signifie &laquo;&nbsp;Réseau inaccessible&nbsp;&raquo;. L'application n'arrive pas à se 
connecter au serveur à travers le réseau. 
Vérifiez que la variable  <CODE>DISPLAY</CODE> est correctement renseignée et que 
la machine
serveur est accessible à partir de votre client (ce qui devrait être le cas,
car après tout vous êtes probablement connecté au serveur en ayant une session
telnet avec votre client).</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
_X11TransSocketINETConnect: Can't connect: errno = 111
xterm Xt error: Can't open display: love.dial.xs4all.nl:0
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Erreur 111 signifie &laquo;&nbsp;Connexion refusée&nbsp;&raquo;. La machine à laquelle vous êtes en 
train d'essayer de vous connecter peut être atteinte, mais le serveur indiqué 
n'existe pas à cet endroit. 
Vérifiez que vous utilisez le nom d'hôte correct et le numéro d'unité
d'affichage adéquat.</P>
<P>Sinon, il est possible que le serveur X a été configuré pour <EM>ne pas</EM>
écouter sur le port TCP habituel. Pour savoir s'il s'agit de ce cas,
regardez si le serveur X a été lancé avec le paramètre <CODE>-nolisten tcp</CODE>
et si oui, enlevez-le.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
Xlib: connection to ":0.0" refused by server
Xlib: Client is not authorized to connect to Server
xterm Xt error: Can't open display: love.dial.xs4all.nl:0.0
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Le client pourrait réaliser une connexion avec le serveur, mais celui-ci
ne permet pas au client de l'utiliser (pas autorisé). Assurez-vous que
vous avez transféré le bon cookie au client, et qu'il n'est pas périmé
(le serveur utilise un nouveau cookie au démarrage d'une nouvelle session).</P>

</BODY>
</HTML>
