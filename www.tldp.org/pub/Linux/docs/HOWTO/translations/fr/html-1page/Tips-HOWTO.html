<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.21">
 <TITLE> Astuces Linux HOWTO</TITLE>
</HEAD>
<BODY>
<H1> Astuces Linux HOWTO</H1>

<H2>
<A HREF="mailto:paul@geeky1.ebtech.net">Paul Anderson</A>, traduit par 
<A HREF="mailto:gomesdv@mail.dotcom.fr">Arnaud Gomes-do-Vale</A> et
     
<A HREF="mailto:nat@nataa.fr.eu.org">Nat Makar&eacute;vitch</A></H2> v3.6, Juin 1998
traduction du 2 janvier 1999
<HR>
<EM>Ce document contient ces astuces et r&eacute;glages difficiles
&agrave; trouver qui rendent Linux un peu plus sympathique.</EM>
<HR>
<H2><A NAME="s1">1. Introduction</A></H2>

<P>Ce document est le <B>Linux Astuces HOWTO</B> (titre original&nbsp;: <B>Linux
Tips HOWTO</B>), une liste de trucs et d'optimisations bien pratiques,
qui contribuent &agrave; rendre Linux plus agr&eacute;able. Tout ce
qui est ici sort ou bien de ma t&ecirc;te, ou bien de l'ancien Astuces
HOWTO (apr&egrave;s tout, pourquoi enlever des astuces qui
marchent&nbsp;?) Alors envoyez-moi vos astuces
pr&eacute;f&eacute;r&eacute;es (NdT&nbsp;: en anglais&nbsp;!) pour que je puisse
les inclure dans la prochaine version du Linux Astuces HOWTO.</P>
<P>Paul Anderson <EM>R&eacute;dacteur de "Linux TIPS HOWTO"</EM></P>
<P><CODE>panderso@ebtech.net</CODE></P>


<H2><A NAME="s2">2. Astuces simples</A></H2>

<H2><A NAME="ss2.1">2.1 Un truc pratique pour syslog. <EM>Paul Anderson, r&eacute;dacteur       du Linux Astuces HOWTO</EM>.</A>
</H2>

<P>Editez le ficher <CODE>/etc/syslog.conf</CODE> et ajoutez-y la ligne
suivante&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# Tout envoyer sur tty8
*.*                                      /dev/tty8
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Attention&nbsp;: PENSEZ &Agrave; UTILISER DES TABULATIONS&nbsp;! Syslog n'aime pas
les espaces.</P>


<H2><A NAME="ss2.2">2.2 Un script pour afficher les HOWTO compact&eacute;s. <EM>Didier       Juges,</EM> <CODE>dj@destin.nfds.net</CODE>.</A>
</H2>

<P>De d&eacute;butant &agrave; d&eacute;butant, voici un petit script qui
facilite la lectures des howto. Mes howto sont dans
<CODE>/usr/doc/faq/howto/</CODE> et sont compressés avec
<CODE>gzip</CODE>. Les fichiers s'appellent <CODE>XXX-HOWTO.gz</CODE>, où XXX est le
titre. J'ai appel&eacute; le script suivant <CODE>howto</CODE> et je l'ai
plac&eacute; dans <CODE>/usr/local/sbin/</CODE>&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#!/bin/sh
if [ "$1" = "" ]; then
    ls /usr/doc/faq/howto | less
else
    gunzip -c /usr/doc/faq/howto/$1-HOWTO.gz | less
fi
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>
<P>Appel&eacute; sans argument, il affiche la liste des howto
disponibles. Quand on lui passe en argument la premi&egrave;re partie
du nom du fichier (avant le trait d'union), il d&eacute;compacte le
document (en laissant l'original intact) et l'affiche &agrave;
l'&eacute;cran.</P>
<P>Par exemple, pour afficher le document <CODE>Serial-HOWTO.gz</CODE>, tapez&nbsp;:
<BLOCKQUOTE><CODE>
<PRE>
$ howto serial
</PRE>
</CODE></BLOCKQUOTE>
</P>


<H2><A NAME="ss2.3">2.3 Reste-t-il assez de place libre&nbsp;? <EM>Hans Zoebelein,</EM></A>
     <CODE>zocki@goldfish.cube.net</CODE>.</H2>

<P>Voici un script qui v&eacute;rifie &agrave; intervalles
r&eacute;guliers qu'il reste de la place sur tout ce qui est
mont&eacute; (disques durs, CDROM, disquettes...)</P>
<P>En cas de p&eacute;nurie d'espace libre, un message est affich&eacute;
&agrave; l'&eacute;cran toutes les X secondes et un courrier
&eacute;lectronique est envoy&eacute; pour chaque
p&eacute;riph&eacute;rique qui d&eacute;borde.</P>
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#!/bin/sh

#
# $Id: Tips-HOWTO.sgml,v 1.1.1.1 2003/01/03 02:38:54 traduc Exp $
#

#
# Depuis que j'ai &eacute;t&eacute; confront&eacute; &agrave; des
# messages d'erreur myst&eacute;rieux pendant les compilations
# quand les fichiers temporaires remplissaient mes disques, j'ai
# &eacute;crit &ccedil;a pour &ecirc;tre averti avant que les disques
# ne soient pleins.
#
# Si &ccedil;a a empech&eacute; vos serveurs d'exploser, envoyez
# les courriers de remerciement &agrave; zocki@goldfish.cube.net.
# Si votre site flambe &agrave; cause de &ccedil;a, d&eacute;sol&eacute;
# mais je vous avais pr&eacute;venu: c'est votre probl&egrave;me
# Si vous savez vraiment vous servir de sed, excusez moi :)
#

#
# Lancez-le et vous pouvez l'oublier: mettez "check_hdspace &amp;"
# dans rc.local. Il v&eacute;rifie l'espace libre toutes les
# $SLEEPTIME secondes. Vous pouvez m&ecirc;me surveiller vos
# disquettes et vos bandes.  :)
# Si l'espace libre est inf&eacute;rieur &agrave; $MINFREE (Ko),
# le script va afficher un message d'avertissement et envoyer un
# courrier &agrave; $MAIL_TO_ME pour chaque p&eacute;riph&eacute;rique
# concern&eacute;. D&egrave;s qu'il y a &agrave; nouveau plus de place
# libre que la limite, le syst&egrave;me d'envoi de courrier est 
# r&eacute;amorc&eacute;.
#

# RESTE &Agrave; FAIRE:
# Des $MINFREE diff&eacute;rents pour chaque p&eacute;riph&eacute;rique
# Nettoyer les r&eacute;pertoires /*tmp des vieilleries en cas de
#           p&eacute;nurie d'espace.


DEVICES='/dev/sda2 /dev/sda8 /dev/sda9' # vos disques
MINFREE=20480                           # la limite
SLEEPTIME=10                            # secondes entre deux v&eacute;rifications
MAIL_TO_ME='root@localhost'             # la personne &agrave; avertir


# ------- rien &agrave; changer en dessous (j'esp&egrave;re :) -------

MINMB=0
ISFREE=0
MAILED=""
let MINMB=$MINFREE/1024         # oui, on fait &ccedil;a bien :)

while [ 1 ]; do
        DF="`/bin/df`"
                for DEVICE in $DEVICES ; do
                ISFREE=`echo $DF | sed s#.\*$DEVICE" "\*[0-9]\*""\*[0-9]\*" "\*## | sed s#" ".\*##`
                
                if [ $ISFREE -le $MINFREE ] ; then
                        let ISMB=$ISFREE/1024
                        echo  "WARNING: $DEVICE only $ISMB mb free." >&amp;2
                        #echo "more stuff here" >&amp;2
                        echo -e "\a\a\a\a"
                        
                        if [ -z  "`echo $MAILED | grep -w $DEVICE`" ] ; then
                                echo "WARNING: $DEVICE only $ISMB mb free.      (Trigger is set to $MINMB mb)" \
                                | mail -s "WARNING: $DEVICE only $ISMB mb free!" $MAIL_TO_ME
                                MAILEDH="$MAILED $DEVICE"
                                MAILED=$MAILEDH
                                # rajoutez ce qu'il reste &agrave; faire
                                # par exemple nettoyer les */tmp
                        fi
                        elif [ -n  "`echo $MAILED | grep -w $DEVICE`" ] ; then
                                # Enlever le marqueur de courrier si
                                # l'espace disponible remonte
                                # au-dessus de la limite. Pour pouvoir
                                # envoyer un nouveau message en cas de 
                                # besoin.
                                MAILEDH="`echo $MAILED  | sed s#$DEVICE##`"
                                MAILED=$MAILEDH
                        fi
                        
                done
                sleep $SLEEPTIME

done
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>



<H2><A NAME="ss2.4">2.4 Un utilitaire pour nettoyer vos fichiers journaux</A>
     (logs). <EM>Paul Anderson, r&eacute;dacteur du Linux Astuces      HOWTO</EM>.</H2>

<P>Si vous &ecirc;tes comme moi, vous avez une liste de diffusion avec
430 inscrits et plus de 100 messages qui arrivent tous les jours par
UUCP. Qu'est-ce qu'un bidouilleur peut bien faire avec ces
&eacute;normes fichiers journaux&nbsp;? Il peut installer
<CODE>chklogs</CODE>. <CODE>chklogs</CODE> a &eacute;t&eacute; &eacute;crit par Emilio
Grimaldo, <CODE>grimaldo@panama.iaehv.nl</CODE>, et la version 1.8 actuelle
est disponible sur
<CODE>ftp.iaehv.nl:/pub/users/grimaldo/chklogs-1.8.tar.gz</CODE>. C'est
tr&egrave;s simple &agrave; installer (il faut bien s&ucirc;r lire le
contenu du r&eacute;pertoire <CODE>doc</CODE>). Une fois le paquetage
install&eacute;, rajoutez une entr&eacute;e &agrave; votre crontab&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# Lance chklogs tous les jours &agrave; 21h
00 21 * * *          /usr/local/sbin/chklogs -m
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Pendant que vous y &ecirc;tes, n'oubliez pas de dire &agrave; l'auteur
&agrave; quel point vous appr&eacute;ciez son logiciel :)</P>


<H2><A NAME="ss2.5">2.5 Un script pratique pour nettoyer les fichiers</A>
     <CODE>core</CODE>. <EM>Otto Hammersmith</EM>.</H2>

<P>Cr&eacute;ez un fichier <CODE>rmcores</CODE> (l'auteur l'appelle
<CODE>handle-cores</CODE>) contenant ceci&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#!/bin/sh
USAGE="$0 &lt;directory> &lt;message-file>"

if [ $# != 2 ] ; then
        echo $USAGE
        exit
fi

 echo Deleting...
find $1 -name core -atime 7 -print -type f -exec rm {} \;

echo e-mailing
for name in `find $1 -name core -exec ls -l {} \; | cut -c16-24`
do
        echo $name
        cat $2 | mail $name
done
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>
<P>Et utilisez cron pour le lancer &agrave; intervalles r&eacute;guliers.</P>


<H2><A NAME="ss2.6">2.6 D&eacute;placement de r&eacute;pertoires inter partitions Linux (filesystems). <I>Alan Cox,</I> <CODE>A.Cox@swansea.ac.uk</CODE>.</A>
</H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
(cd /r&eacute;pertoire_source &amp;&amp; tar cf - . ) | (cd /r&eacute;pertoire_cible &amp;&amp; tar xvf -)
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P><I>[ Et pas cd /r&eacute;pertoire_source; tar...etc., qui laisse la
possibilit&eacute; de bousiller un r&eacute;pertoire en cas de
probl&egrave;me. Merci &agrave; Jim Dennis, <CODE>jim@starshine.org</CODE>,
qui me l'a signal&eacute;. -le r&eacute;dacteur ]</I></P>


<H2><A NAME="ss2.7">2.7 Trouver les plus gros r&eacute;pertoires. <EM>Mick Ghazey</EM>.</A>
</H2>

<P>Vous vous &ecirc;tes d&eacute;j&agrave; demand&eacute; quels
&eacute;taient les plus gros r&eacute;pertoires sur votre machine&nbsp;?
Voici une fa&ccedil;on de les trouver.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
du -S | sort -n
</PRE>
</CODE></BLOCKQUOTE>
</P>


<H2><A NAME="ss2.8">2.8 La Linux Gazette.</A>
</H2>

<P>Bravo et merci &agrave; John Fisk, le cr&eacute;ateur de la Linux
Gazette. C'est un excellent magazine en ligne, qui plus est
<B>GRATUIT&nbsp;!</B> Que demander de plus&nbsp;? Vous pouvez le trouver &agrave;
l'adresse&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
http://www.linuxgazette.com
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Au fait, il s'av&egrave;re que (1) la LG est maintenant mensuelle et
(2) elle n'est plus maintenue par John Fisk, mais par l'&eacute;quipe
de SSC.</P>


<H2><A NAME="ss2.9">2.9 Indication permettant de r&eacute;soudre le probl&egrave;me pos&eacute; par le VPATH du GNU make version 3.7. <I>Ted Stern,</I> <CODE>stern@amath.washington.edu</CODE>.</A>
</H2>

<P>J'ignore si ce probl&egrave;me concerne de nombreux utilisateurs mais
l'une des caract&eacute;ristiques de la version 3.7 du GNU make ne
m'enthousiasme pas. Il s'agit du comportement d'un VPATH sur
r&eacute;pertoire absolu. Un robuste patch corrige cela, vous pourrez
l'obtenir aupr&egrave;s de Paul D. Smith
<CODE>&lt;psmith@wellfleet.com></CODE> 
<BLOCKQUOTE>Veuillez r&eacute;diger
votre courrier en anglais !  NDT</BLOCKQUOTE>
.  Ce dernier poste dans le
groupe gnu.utils.bug un article contenant ce patch et sa documentation
apr&egrave;s parution de chaque nouvelle version du GNU make.  En ce
qui me concerne... il est install&eacute; sur tous les
syst&egrave;mes auxquels j'ai acc&egrave;s !</P>


<H2><A NAME="ss2.10">2.10 Comment interdire &agrave; ma machine de lancer fsck apr&egrave;s chaque d&eacute;marrage&nbsp;? <I>Dale Lutz,</I> <CODE>dal@wimsey.com</CODE>.</A>
</H2>

<P>R&eacute;ponse&nbsp;: Apr&egrave;s recompilation du noyau le syst&egrave;me
de fichiers est consid&eacute;r&eacute; comme non
v&eacute;rifi&eacute; ("marked as dirty"), ce qui implique que fsck
sera mis en action lors de chaque d&eacute;marrage. Pour &eacute;viter
cela lancer :
<BLOCKQUOTE><CODE>
<PRE>
rdev -R /zImage 1
</PRE>
</CODE></BLOCKQUOTE>

Cela modifie le noyau qui, d&egrave;s lors, consid&egrave;re que le
syst&egrave;me de fichiers est sain.</P>

<P>Note&nbsp;: Ajoutez, si vous employez LILO, 
<CODE>read-only</CODE> &agrave; la section de l'image de boot
de votre fichier de configuration LILO (souvent nomm&eacute; /etc/lilo/config ou /etc/lilo.conf).</P>


<H2><A NAME="ss2.11">2.11 Comment &eacute;viter les lancements de fsck, au boot, d&ucirc;s au "device busy"&nbsp;? <I>Jon Tombs,</I> <CODE>jon@gtex02.us.es</CODE>.</A>
</H2>

<P>Si votre syst&egrave;me conna&igrave;t de fr&eacute;quentes erreurs de type
"device busy" au d&eacute;marrage qui laissent le syst&egrave;me de
fichiers dans un &eacute;tat exigeant un <CODE>fsck</CODE>, veuillez suivre
les recommandations suivantes :</P>
<P>Ajoutez, au fichier <CODE>/etc/rc.d/init.d/halt</CODE> ou
<CODE>/etc/rc.d/rc.0</CODE>, la ligne
<BLOCKQUOTE><CODE>
<PRE>
mount -o remount,ro /mount.dir
</PRE>
</CODE></BLOCKQUOTE>

pour tous vos syst&egrave;mes de fichiers mont&eacute;s, sauf la
racine, avant l'invocation de umount -a. Cela signifie que si, pour
une quelconque raison, "shutdown" ne parvient pas &agrave; tuer tous
les processus puis d&eacute;monter les partitions ces derni&egrave;res
seront malgr&eacute; tout consid&eacute;r&eacute;es comme saines lors
du red&eacute;marrage.  Cette astuce a consid&eacute;rablement
&eacute;court&eacute; le temps de d&eacute;marrage de mon
syst&egrave;me !</P>


<H2><A NAME="ss2.12">2.12 Comment trouver les plus gros fichiers sur votre disque</A>
dur. <I>Simon Amor,</I> <CODE>simon@foobar.co.uk</CODE>.</H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
ls -l | sort +4n
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Pour ceux d'entre vous qui sont vraiment &agrave; l'&eacute;troit,
&ccedil;a prend du temps, mais &ccedil;a marche bien&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
cd /
ls -lR | sort +4n
</PRE>
</CODE></BLOCKQUOTE>
</P>


<H2><A NAME="ss2.13">2.13 Comment imprimer sur des pages avec marges ? <I>Mike Dickey,</I> <CODE>mdickey@thorplus.lib.purdue.edu</CODE>.</A>
</H2>

<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
        #!/bin/sh
        # /usr/local/bin/print
        # Une simple sortie format&eacute;e pour permettre de
        # perforer les feuilles afin de les mettre dans un classeur

        cat $1 | pr -t -o 5 -w 85 | lpr
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>


<H2><A NAME="ss2.14">2.14 M&eacute;thode permettant de rechercher des expressions rationnelles dans des fichiers. <I>Raul Deluth Miller,</I> <CODE>rockwell@nova.umd.edu</CODE>.</A>
</H2>

<P>Je d&eacute;signe, par "expressions rationnelles", les <CODE>regexp</CODE>
de "grep" et consorts.</P>
<P>J'ai appel&eacute; ce script "forall" et l'utilise ainsi :
<BLOCKQUOTE><CODE>
<PRE>
forall /usr/include grep -i ioctl
forall /usr/man grep ioctl
</PRE>
</CODE></BLOCKQUOTE>

Voici le script forall:
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#!/bin/sh
if [ 1 = `expr 2 \> $#` ]
then
        echo Syntaxe: $0 repertoire commande [arguments]
        exit 1
fi
dir=$1
shift
find $dir -type f -print | xargs "$@"
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>


<H2><A NAME="ss2.15">2.15 Un script pour faire le m&eacute;nage derri&egrave;re les</A>
     programmes qui cr&eacute;ent des fichiers de sauvegarde.</H2>

<P>Voici un petit script de deux lignes qui parcourt une arborescence et
qui y efface les fichiers de sauvegarde (# et ~) d'emacs, les fichiers
.o, et les fichiers .log de TeX. Il compacte &eacute;galement les
fichiers .tex et README. Sur mon syst&egrave;me, je l'ai appel&eacute;
"squeeze".</P>
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#!/bin/sh
#SQUEEZE efface les fichiers superflus et compacte les fichiers .tex
#et README.
#Par Barry tolnas, tolnas@sun1.engr.utk.edu
#
echo nettoyage de $PWD
find  $PWD \( -name \*~ -or -name \*.o -or -name \*.log -or -name \*\#\) -exec
rm -f {} \;
find $PWD \( -name \*.tex -or -name \*README\* -or -name \*readme\* \) -exec gzip -9 {} \;
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>


<H2><A NAME="ss2.16">2.16 Comment trouver le processus qui occupe le plus de</A>
     m&eacute;moire. <EM>Simon Amor</EM>.</H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
ps -aux | sort +4n
</PRE>
</CODE></BLOCKQUOTE>

-OU-
<BLOCKQUOTE><CODE>
<PRE>
ps -aux | sort +5n
</PRE>
</CODE></BLOCKQUOTE>
</P>


<H2><A NAME="ss2.17">2.17 Configuration de <CODE>vi</CODE> pour la programmation en C. <EM>Paul</A>
      Anderson, r&eacute;dacteur du Linux Astuces HOWTO</EM>.</H2>

<P>Je passe beaucoup de temps &agrave; programmer en C, et j'ai pris le
temps de configurer vi pour me faciliter la t&acirc;che. Voici le
contenu de mon fichier <CODE>.exrc</CODE>&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
set autoindent
set shiftwidth=4
set backspace=2
set ruler
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>
<P>Qu'est-ce que &ccedil;a fait&nbsp;? <CODE>autoindent</CODE> force vi &agrave;
indenter automatiquement toutes les lignes qui suivent la
premi&egrave;re ligne indent&eacute;e, <CODE>shiftwidth</CODE> impose une
taille de 4 espaces pour ^T, <CODE>backspace</CODE> configure la touche
d'espacement arri&egrave;re, et <CODE>ruler</CODE> force l'affichage des
num&eacute;ros de lignes. Notez que pour placer le curseur sur une
ligne donn&eacute;e, par exemple la ligne 20, vous pouvez utiliser&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
vi +20 monfichier.c
</PRE>
</CODE></BLOCKQUOTE>
</P>


<H2><A NAME="ss2.18">2.18 Utilisation de ctags pour faciliter la programmation</A>
</H2>

<P>Beaucoup de bidouilleurs ont d&eacute;j&agrave; ctags sur leur
machine, mais ne s'en servent pas. Cela peut &ecirc;tre tr&egrave;s
pratique pour &eacute;diter des fonctions sp&eacute;cifiques. Supposez
que vous avez une fonction dans l'un des nombreux fichiers sources
contenus dans un r&eacute;pertoire pour un programme que vous
&ecirc;tes en train d'&eacute;crire, et que vous voulez &eacute;diter
cette fonction pour faire une mise &agrave; jour. Appelons cette
fonction foo(). Vous ne savez pas non plus o&ugrave; elle se trouve
dans le fichier source. C'est l&agrave; que ctags peut &ecirc;tre
tr&egrave;s pratique. Quand vous le lancez, ctags cr&eacute;e un
fichier nomm&eacute; <CODE>tags</CODE> dans le r&eacute;pertoire courant, qui
contient la liste de toutes les fonctions, le fichier source dans
lequel elles se trouvent et leur emplacement dans ce fichier
source. Le fichier <CODE>tags</CODE> ressemble &agrave; &ccedil;a&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>

ActiveIconManager       iconmgr.c       /^void ActiveIconManager(active)$/
AddDefaultBindings      add_window.c    /^AddDefaultBindings ()$/
AddEndResize    resize.c        /^AddEndResize(tmp_win)$/
AddFuncButton   menus.c /^Bool AddFuncButton (num, cont, mods, func, menu, item)$/
AddFuncKey      menus.c /^Bool AddFuncKey (name, cont, mods, func, menu, win_name, action)$/
AddIconManager  iconmgr.c       /^WList *AddIconManager(tmp_win)$/
AddIconRegion   icons.c /^AddIconRegion(geom, grav1, grav2, stepx, stepy)$/
AddStartResize  resize.c        /^AddStartResize(tmp_win, x, y, w, h)$/
AddToClientsList        workmgr.c       /^void AddToClientsList (workspace, client)$/
AddToList       list.c  /^AddToList(list_head, name, ptr)$/
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>
<P>Pour &eacute;diter, par exemple, AddEndResize() avec vim, tapez&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
vim -t AddEndResize
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Cela va ouvrir le bon fichier dans l'&eacute;diteur et placer le
curseur au d&eacute;but de la fonction.</P>


<H2><A NAME="ss2.19">2.19 Pourquoi sendmail se bloque-t-il pendant 5 minutes au</A>
     d&eacute;marrage d'une Red Hat&nbsp;? <EM>Paul Anderson</EM>.</H2>

<P>C'est un probl&egrave;me assez courant, presque au point d'en faire
une FAQ. Je ne sais pas si Red Hat corrige l'erreur dans sa
distributions, mais vous pouvez r&eacute;parer &ccedil;a
vous-m&ecirc;me. Si vous regardez dans votre fichier
<CODE>/etc/hosts</CODE>, vous allez trouver quelque chose qui ressemble
&agrave; &ccedil;a&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
127.0.0.1        localhost        votremachine
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Quand sendmail d&eacute;marre, il fait une recherche sur le nom de
votre machive (<CODE>votremachine</CODE> dans l'exemple). Ensuite, il trouve
que l'adresse IP de la machine est 127.0.0.1; sendmail n'aime pas
&ccedil;a et recommence la recherche. Il continue comme &ccedil;a
pendant un moment avant d'abandonner. Corriger ce probl&egrave;me est
tr&egrave;s facile&nbsp;: &eacute;ditez votre fichier <CODE>/etc/hosts</CODE> et
mettez-y quelque chose comme &ccedil;a&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
127.0.0.1        localhost
10.56.142.1      votremachine
</PRE>
</CODE></BLOCKQUOTE>
</P>


<H2><A NAME="ss2.20">2.20 Comment configurer une Red Hat pour avoir <CODE>ls</CODE> en couleurs?</A>
     <EM>Paul Anderson,</EM> <CODE>paul@geeky1.ebtech.net</CODE>.</H2>

<P>La distribution Red Hat est fournie avec color-ls (ls en couleurs),
mais je n'arrive pas &agrave; comprendre pourquoi ils ne le
configurent pas pour utiliser les couleurs par d&eacute;faut. Voici
une fa&ccedil;on d'arranger &ccedil;a.</P>
<P>Commencez par taper <CODE>eval `DIRCOLORS`</CODE></P>
<P>Puis <CODE>alias ls='ls --color=auto'</CODE></P>
<P>Enfin, mettez la ligne "<CODE>alias .....</CODE>" dans votre
<CODE>/etc/bashrc</CODE>.</P>


<H2><A NAME="ss2.21">2.21 Comment trouver quelle biblioth&egrave;que de /usr/lib</A>
     contient une fonction donn&eacute;e&nbsp;? <EM>Pawel Veselow</EM>.</H2>

<P>Vous &ecirc;tes en train de compiler un programme et vous avez
oubli&eacute; de lier une biblioth&egrave;que n&eacute;cessaire? Et
gcc qui ne donne que les noms des fonctions manquantes... Voici une
commande pour trouver ce que vous cherchez&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
for i in *; do echo $i:;nm $i|grep tgetnum 2>/dev/null;done
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Remplacez <CODE>tgetnum</CODE> par le nom de la fonction que vous cherchez.</P>


<H2><A NAME="ss2.22">2.22 J'ai compil&eacute; un petit programme en C, mais quand je le</A>
     lance, je ne vois aucun r&eacute;sultat&nbsp;!</H2>

<P>Vous avez compil&eacute; le programme et cr&eacute;&eacute; un
programme appel&eacute; <CODE>test</CODE>, non? Linux a d&eacute;j&agrave; un
programme <CODE>test</CODE>, qui teste si une certaine condition est vraie et
qui n'affiche aucun r&eacute;sultat &agrave; l'&eacute;cran. Pour
lancer votre programme <CODE>test</CODE>, tapez <CODE>./test</CODE>.</P>


<H2><A NAME="s3">3. Astuces d&eacute;taill&eacute;es</A></H2>

<H2><A NAME="ss3.1">3.1 Linux et Windows peuvent utiliser une m&ecirc;me partition pour le swap ! <I>Tony Acero,</I> <CODE>ace3@midway.uchicago.edu</CODE>.</A>
</H2>

<P>
<OL>
<LI> Formater la partition sous DOS puis y disposer le fichier d'&eacute;change
de Windows. Ne pas employer Windows tout de suite afin de laisser ce
fichier compl&egrave;tement "vide" pour faciliter son compactage.
</LI>
<LI> D&eacute;marrer Linux et sauver ce fichier dans un fichier.
Exemple (cas d'une partition de "swap" commun nomm&eacute;e /dev/hda8) :
<BLOCKQUOTE><CODE>
<PRE>
dd if=/dev/hda8 of=/etc/dosswap
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI> Compacter le fichier de swap :
<BLOCKQUOTE><CODE>
<PRE>
gzip -9 /etc/dosswap
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI> Ajouter au fichier /etc/rc la ligne suivante afin de pr&eacute;parer et
installer la partition de swap lorsqu'elle est employ&eacute;e par Linux :
<EM>XXXXX repr&eacute;sente ici le nombre de blocs que compte la partition de swap</EM>
<BLOCKQUOTE><CODE>
<PRE>
mkswap /dev/hda8 XXXXX
swapon -av   
</PRE>
</CODE></BLOCKQUOTE>

Ajoutez une ligne destin&eacute;e &agrave; cette partiton de swap dans le fichier /etc/fstab
</LI>
<LI> 
Si les programmes init et shutdown employ&eacute;s utilisent /etc/brc ajouter
&agrave; ce fichier les lignes suivantes&nbsp;:
<BLOCKQUOTE><CODE>
<PRE>
swapoff -av
zcat /etc/dosswap.gz | dd of=/dev/hda8 bs=1k count=100
</PRE>
</CODE></BLOCKQUOTE>

Dans le cas contraire il vous faudra invoquer ces commandes avant chaque fin
de session Linux (placer ces commandes dans un script...)</LI>
</OL>

Note : dd ne traite que 100 blocs car j'ai empiriquement d&eacute;termin&eacute; que rien
ne sert d'en &eacute;crire davantage&nbsp;!</P>
<P>&gt;&gt;  Quels sont les avantages et inconv&eacute;nients de cette m&eacute;thode ?</P>
<P>Avantages&nbsp;: gain d'espace disponible sur le disque !</P>
<P>Inconv&eacute;nients&nbsp;: si l'&eacute;tape de restauration du fichier d'&eacute;change Windows n'est
pas automatique il ne faudra pas n&eacute;gliger, sous Linux et avant chaque
red&eacute;marrage "vers" Windows, de lancer les commandes charg&eacute;es de cette remise
en place.</P>


<H2><A NAME="ss3.2">3.2 R&eacute;cup&eacute;ration de fichiers effac&eacute;s. <EM>Michael Hamilton,</EM> <CODE>michael@actrix.gen.nz</CODE>.</A>
</H2>

<P>Voici une astuce dont j'ai eu besoin &agrave; quelques reprises.</P>
<P>La r&eacute;cup&eacute;ration d'un fichier texte par une personne
d&eacute;sesp&eacute;r&eacute;e.</P>
<P>Si vous effacez un fichier texte par accident, par exemple un courrier
&eacute;lectronique ou le produit d'une nuit de programmation, tout
n'est pas perdu. Si le fichier a eu le temps d'aller jusqu'au disque,
c'est &agrave; dire s'il a exist&eacute; pendant plus de 30 secondes,
il est possible que son contenu se trouve encore sur la partition.</P>
<P>Vous pouvez le rechercher dans la partition en utilisant la commande
grep.</P>
<P>Par exemple, r&eacute;cemment, j'ai effac&eacute; un courrier
&eacute;lectronique par accident. J'ai imm&eacute;diatement
cess&eacute; toute activit&eacute; qui aurait pu modifier le contenu
de la partition&nbsp;: je me suis abstenu de sauvegarder quoi que ce soit,
de compiler quoi que ce soit, etc. En d'autres occasions, je suis
all&eacute; jusqu'&agrave; passer le syst&egrave;me en mode
mono-utilisateur et d&eacute;monter le syst&egrave;me de fichiers.</P>
<P>J'ai ensuite utilis&eacute; la commande egrep sur la partition&nbsp;: dans
mon cas, le message se trouvait dans <CODE>/usr/local/home/michael/</CODE>,
et donc d'apr&egrave;s la sortie de df, dans <CODE>/dev/hdb5</CODE>.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
   sputnik3:~ % df
   Filesystem         1024-blocks  Used Available Capacity Mounted on
   /dev/hda3              18621    9759     7901     55%   /
   /dev/hdb3             308852  258443    34458     88%   /usr
   /dev/hdb5             466896  407062    35720     92%   /usr/local

   sputnik3:~ % su
   Password:
   [michael@sputnik3 michael]# egrep -50 'ftp.+COL' /dev/hdb5 > /tmp/x
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Je suis extr&ecirc;mement prudent quand je manipule des partitions,
donc j'ai bien pris le temps de m'assurer que je comprenais la syntaxe
de cette commande AVANT de presser la touche Entr&eacute;e. Dans ce
cas, le message contenait la mot "ftp", puis un peu de texte suivi du
mot "COL". Le message faisait une vingtaine de lignes, donc j'ai
utilis&eacute; -50 pour avoir toutes les lignes assez proches de la
phrase. Il m'est d&eacute;j&agrave; arriv&eacute; d'utiliser -3000
pour &ecirc;tre s&ucirc;r de r&eacute;perer toutes les lignes d'un
code source. J'ai redirig&eacute; le sortie de egrep vers une autre
partition pour &eacute;viter d'&eacute;craser le message que je
recherchais.</P>
<P>J'ai ensuite utilis&eacute; la commande strings pour examiner le
r&eacute;sultat.</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
  strings /tmp/x | less
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Effectivement, le message &eacute;tait l&agrave;.</P>
<P>Cette m&eacute;thode peut ne pas &ecirc;tre efficace si tout ou partie
de l'espace disque a d&eacute;j&agrave; &eacute;t&eacute;
r&eacute;utilis&eacute;.</P>
<P>Cette astuce n'est probablement utilisable que sur un syst&egrave;me
mono-utilisateur. Sur un syst&egrave;me multi-utilisateurs avec
beaucoup d'activit&eacute; sur les disques, l'emplacement que vous
avez lib&eacute;r&eacute; peut tr&egrave;s bien d&eacute;j&agrave;
avoir &eacute;t&eacute; r&eacute;utilis&eacute;. Et pour la plupart
nous ne pouvons pas nous permettre d'enlever la machine de sous les
pieds de nos utilisateurs d&egrave;s que nous avons besoin de
r&eacute;cup&eacute;rer un fichier.</P>
<P>Sur mon syst&egrave;me personnel, cette astuce a &eacute;t&eacute;
bien pratique &agrave; environ trois occasions ces quelques
derni&egrave;res ann&eacute;es&nbsp;-&nbsp;g&eacute;n&eacute;ralement
apr&egrave;s que j'ai d&eacute;truit accidentellement une partie de
mon travail du jour. Si ce que je fais survit assez longtemps pour
progresser de fa&ccedil;on significative, je le sauvegarde sur une
disquette, donc je n'ai pas souvent besoin de ce truc.</P>


<H2><A NAME="ss3.3">3.3 Comment utiliser le marqueur d'immutabilit&eacute;. <EM>Jim</A>
      Dennis,</EM> <CODE>jadestar@rahul.net</CODE>.</H2>

<P>Utilisez le marqueur d'immutabilit&eacute;.</P>
<P>Juste apr&egrave;s avoir install&eacute; et configur&eacute; votre
syst&egrave;me, faites un tour dans <CODE>/bin</CODE>, <CODE>/sbin</CODE>,
<CODE>/usr/bin</CODE>, <CODE>/usr/sbin</CODE>, <CODE>/usr/lib</CODE> et autres, et
n'h&eacute;sitez pas &agrave; vous servir de la commande "<CODE>chattr
+i</CODE>". Appliquez-la aussi aux fichiers du noyau &agrave; la
racine. Maintenant, "<CODE>mkdir /etc/.dist</CODE>" et copiez-y toute
l'arborescence contenue dans <CODE>/etc</CODE> (je le fais en deux
&eacute;tapes en utilisant <CODE>/tmp/etcdist.tar</CODE> pour &eacute;viter
la r&eacute;cursion). (Vous pouvez aussi vous contenter de
<CODE>/etc/.dist.tar.gz</CODE>). Et placez-y un marqueur
d'immutabilit&eacute;.</P>
<P>Tout cela sert &agrave; limiter les d&eacute;g&acirc;ts que vous
pouvez faire en tant que root. Vous &eacute;viterez ainsi
d'&eacute;craser des fichiers avec une redirection mal
contr&ocirc;l&eacute;e, et vous ne risquez pas de rendre le
syst&egrave;me inutilisable &agrave; cause d'une espace mal
plac&eacute;e dans une commande "<CODE>rm -fr</CODE>"&nbsp;; vous pouvez toujours
faire tr&egrave;s mal &agrave; vos donn&eacute;es, mais vos binaires
et vos biblioth&egrave;ques seront &agrave; l'abri.</P>
<P>De plus, cela pr&eacute;vient, ou du moins complique, l'exploitation
d'un certain nombre de trous de s&eacute;curit&eacute;&nbsp;; en effet,
beaucoup d'attaques de ce type &eacute;crasent un fichier au moyen
d'un quelconque programme SUID qui <EM>ne permet pas
d'ex&eacute;cuter une commande arbitraire</EM>.</P>
<P>Le seul inconv&eacute;nient se pr&eacute;sente &agrave; l'installation
de divers logiciels syst&egrave;me. D'un autre c&ocirc;t&eacute;,
&ccedil;a emp&ecirc;che l'&eacute;crasement accidentel de fichiers par
"<CODE>make install</CODE>". Si vous oubliez de lire le Makefile et
d'appliquer <CODE>chattr -i</CODE> aux fichiers qui doivent &ecirc;tre
&eacute;cras&eacute;s (et aux r&eacute;pertoires auxquels vous voulez
ajouter des fichiers), le make &eacute;choue, et il suffit d'utiliser
chattr avant de le relancer. Vous pouvez aussi en profiter pour
d&eacute;placer vos anciens binaires, biblioth&egrave;ques et autres
dans un r&eacute;pertoire <CODE>.old/</CODE>, les renommer, les archiver ou
autre.</P>


<H2><A NAME="ss3.4">3.4 Une suggestion quant &agrave; l'endroit o&ugrave; mettre ce</A>
     que vous rajoutez.</H2>

<P>Tout ce que vous rajoutez doit se trouver sous <CODE>/usr/local</CODE> ou
<CODE>/usr/local/`hostname`</CODE>!</P>
<P>Si votre distribution laisse <CODE>/usr/local</CODE> vide, cr&eacute;ez
<CODE>/usr/local/src</CODE>, <CODE>/usr/local/bin</CODE>, etc. et utilisez-les. Si
votre distribution met des choses dans <CODE>/usr/local</CODE>, cr&eacute;ez
<CODE>/usr/local/`hostname`</CODE> et donnez-lui le mode +w pour le groupe
wheel (en plus, je le rends SUID et SGID pour m'assurer que les
membres du groupe wheel ne peuvent toucher qu'&agrave; leurs propres
fichiers et que tous les nouveaux fichiers vont appartenir au groupe
wheel).</P>
<P>Maintenant, forcez-vous &agrave; <EM>TOUJOURS</EM> placer
les nouveaux paquetages sous
<CODE>/usr/local/src/.from/$OU_JE_L_AI_EU</CODE> (pour les fichiers .tar ou
autres) et &agrave; les compiler sous <CODE>/usr/local/src</CODE> (ou
<CODE>.../$HOSTNAME/src</CODE>). Assurez-vous qu'ils s'installent sous la
hi&eacute;rarchie locale. Si quelque chose *doit obligatoirement*
&ecirc;tre install&eacute; dans <CODE>/bin</CODE> ou <CODE>/usr/bin</CODE> ou
autre, cr&eacute;ez un lien symbolique depuis la hi&eacute;rarchie
locale vers tout ce qui est install&eacute; ailleurs.</P>
<P>La raison de tout &ccedil;a, m&ecirc;me si &ccedil;a repr&eacute;sente
plus de travail, est que &ccedil;a permet de trouver facilement ce qui
doit &ecirc;tre sauvegard&eacute; et r&eacute;install&eacute; en cas
de r&eacute;installation compl&egrave;te depuis le m&eacute;dia de
distribution (habituellement un CD &agrave; l'heure actuelle). En
utilisant un r&eacute;pertoire <CODE>/usr/local/src/.from</CODE>, vous
gardez aussi une trace de la provenance de vos sources, ce qui est
utile pour trouver les mises &agrave; jour et qui peut s'av&eacute;rer
critique pour suivre les listes d'annonces de s&eacute;curit&eacute;.</P>
<P>Un de mes syst&egrave;mes personnels (celui que j'utilise) a
&eacute;t&eacute; mont&eacute; avant que je n'applique moi-m&ecirc;me
cette politique. Je ne "sais" toujours pas en quoi il diff&egrave;re
du syst&egrave;me de base "tel qu'install&eacute;". Et cela
bien que je n'ai chang&eacute; que tr&egrave;s peu de choses
quant &agrave; sa configuration et que je suis le *seul* &agrave;
l'utiliser.</P>
<P>A contrario, tous les syst&egrave;mes que j'ai mis en place au travail
(o&ugrave; j'ai &eacute;t&eacute; bombard&eacute; administrateur
syst&egrave;me) ont &eacute;t&eacute; configur&eacute;s de cette
fa&ccedil;on. Ils ont &eacute;t&eacute; administr&eacute;s par
plusieurs personnes ext&eacute;rieures et autres membres du
d&eacute;partement informatique, et ils ont subi de nombreuses mises
&agrave; jour et installations de logiciels. Pourtant, j'ai une
id&eacute;e tr&egrave;s pr&eacute;cise de ce qui a &eacute;t&eacute;
rajout&eacute; *apr&egrave;s* l'installation et la configuration
initiales.</P>


<H2><A NAME="ss3.5">3.5 Conversion de tous les fichiers d'un r&eacute;pertoire en</A>
     minuscules. <EM>Justin Dossey,</EM> <CODE>dossey@ou.edu</CODE>.</H2>

<P>J'ai remarqu&eacute; quelques proc&eacute;dures difficiles ou
superflues recommand&eacute;es dans les trucs et astuces du
num&eacute;ro 12 
<BLOCKQUOTE>NdT&nbsp;: Apparemment, cette section est
tir&eacute;e de la Linux Gazette</BLOCKQUOTE>
. Comme il y en a plusieurs, je
vous adresse ce message.</P>
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#!/bin/sh
         # lowerit
         # convertit les noms de tous les fichiers du r&eacute;pertoire
         # courant en minuscules
         # n'affecte que les fichiers, pas les sous-r&eacute;pertoires
         # demande confirmation avant d'&eacute;craser un fichier existant
         for x in `ls`
           do
           if [ ! -f $x ]; then
             continue
             fi
           lc=`echo $x  | tr '[A-Z]' '[a-z]'`
           if [ $lc != $x ]; then
             mv -i $x $lc
           fi
           done
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>
<P>Voil&agrave; un long script. Je n'&eacute;crirais pas un script pour
&ccedil;a&nbsp;; j'utiliserais plut&ocirc;t la commande suivante&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
for i in * ; do [ -f $i ] &amp;&amp; mv -i $i `echo $i | tr '[A-Z]' '[a-z]'`;
done;
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Ce contributeur dit qu'il a &eacute;crit le script de cette
fa&ccedil;on pour des raisons de lisibilit&eacute; (voir plus bas).</P>
<P>Pour l'astuce suivante, qui traite de l'ajout et de la suppression
d'utilisateurs, Geoff s'en sort bien jusqu'&agrave; la derni&egrave;re
&eacute;tape. Rebooter&nbsp;? J'esp&egrave;re qu'il ne reboote pas &agrave;
chaque fois qu'il supprime un utilisateur. Les deux premi&egrave;res
&eacute;tapes suffisent. De toutes fa&ccedil;ons, quels processus cet
utilisateur pourrait-il laisser tourner&nbsp;? Un bot IRC&nbsp;? Tuez simplement
les processus avec&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
kill -9 `ps -aux |grep ^&lt;nom d'utilisateur> |tr -s " " |cut -d " " -f2`
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Par exemple, pour l'utilisateur foo:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
kill -9 `ps -aux |grep ^foo |tr -s " " |cut -d " " -f2`
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Cette question &eacute;tant class&eacute;e, passons au mot de passe de
root oubli&eacute;.</P>
<P>La solution donn&eacute;e dans la Gazette est la plus universelle,
mais pas la plus facile. Aussi bien avec LILO qu'avec Loadlin, le
param&egrave;tre "single" permet de lancer directement le shell par
d&eacute;faut au d&eacute;marrage, sans entrer de login ni de mot de
passe. &Agrave; partir de l&agrave;, il suffit de changer ou d'enlever
le mot de passe probl&eacute;matique, avant de taper "<CODE>init 3</CODE>"
pour passer en mode multi-utilisateurs. De cette fa&ccedil;on, un seul
reboot&nbsp;; de l'autre, deux reboots.</P>
<P>Justin Dossey.</P>


<H2><A NAME="ss3.6">3.6 Mise &agrave; jour de Sendmail. <EM>Paul Anderson,</EM></A>
     <CODE>paul@geeky1.ebtech.net</CODE></H2>

<P>Nous partons d'une source propre. Commencez par vous procurer le code
source de sendmail. J'ai t&eacute;l&eacute;charg&eacute; la version
8.9.0, qui est comme vous pouvez le voir &agrave; la pointe du
progr&egrave;s. Je l'ai r&eacute;cup&eacute;r&eacute;e depuis
ftp.sendmail.org:/pub/sendmail/sendmail-8.9.0.tar.gz</P>
<P>Il p&egrave;se &agrave; peu pr&egrave;s un m&eacute;ga-octet, et
sachant que j'utilise la version 8.7.6, je crois que &ccedil;a vaut le
co&ucirc;t. Si &ccedil;a marche, vous en entendrez s&ucirc;rement
parler&nbsp;; sinon, je n'aurai plus de courrier et je ne pourrai pas
distribuer la nouvelle version de ce HOWTO :)</P>
<P>Maintenant que vous avez t&eacute;l&eacute;charg&eacute; le source,
d&eacute;compactez-le. Cela va cr&eacute;er un sous-r&eacute;pertoire
<CODE>sendmail-8.9.0</CODE> dans le r&eacute;pertoire courant. Placez-vous
dans ce sous-r&eacute;pertoire et lisez les fichiers <CODE>README</CODE> et
<CODE>RELEASE_NOTES</CODE> (et soyez &eacute;poustoufl&eacute; par toutes les
am&eacute;liorations qu'ils ont apport&eacute;es). Maintenant,
placez-vous dans <CODE>src</CODE>. C'est l&agrave; que vous allez faire le
plus gros du travail.</P>
<P><EM>Une remarque au passage&nbsp;: Sendmail est un programme petit, puissant
et bien &eacute;crit. Le binaire <CODE>sendmail</CODE> lui-m&ecirc;me a mis
moins de 5 minutes &agrave; compiler sur mon 5x86 133 avec 32 Mo de
RAM&nbsp;! La totalit&eacute; de la compilation et de l'installation (sans
compter la configuration) ont pris moins de 15 minutes&nbsp;!</EM></P>
<P>Je n'utilise pas BIND sur mon syst&egrave;me, donc j'ai cherch&eacute;
les lignes suivantes&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
# ifndef NAMED_BIND
#  define NAMED_BIND    1       /* use Berkeley Internet Domain Server */
# endif
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>
<P>et j'ai remplac&eacute; le 1 par un 0:</P>
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
# ifndef NAMED_BIND
#  define NAMED_BIND    0       /* use Berkeley Internet Domain Server */
# endif
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>
<P>Sur la Debian 1.3, <CODE>db.h</CODE> est install&eacute; par d&eacute;faut
dans <CODE>/usr/include/db</CODE>, au lieu de <CODE>/usr/include</CODE> o&ugrave;
sendmail esp&egrave;re le trouver. Placez-vous successivement dans les
sous-r&eacute;pertoires <CODE>src</CODE>, <CODE>mailstats</CODE>, <CODE>makemap</CODE>,
<CODE>praliases</CODE>, <CODE>rmail</CODE> et <CODE>smrsh</CODE> et &eacute;xecutez la
commande suivante&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
 ./Build -I/usr/include/db
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Ensuite, <CODE>cd ..</CODE> et tapez <CODE>make install</CODE>. Voil&agrave;&nbsp;! La
version 8.9.0 de Sendmail doit maintenant &ecirc;tre install&eacute;e&nbsp;!
Bien s&ucirc;r, &ccedil;a suppose que vous avez d&eacute;j&agrave;
votre configuration d'origine. Pour que tout marche bien sur mon
syst&egrave;me, comme j'h&eacute;berge des listes de diffusion
gratuites utilisant majordomo, j'ai ajout&eacute; la ligne suivante au
d&eacute;but de mon <CODE>/etc/sendmail.cf</CODE>&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
O DontBlameSendmail=forwardfileinunsafedirpath, forwardfileinunsafedirpathsafe
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>
<P>Sendmail 8.9.0 est &agrave; l'heure actuelle plut&ocirc;t bavard
&agrave; propos des permissions des r&eacute;pertoires et des
fichiers, et il va se plaindre &agrave; propos des r&eacute;pertoires
et des fichiers qui autorisent l'acc&egrave;s en &eacute;criture pour
le groupe ou pour tout le monde parmi les fichiers d'alias ou
<CODE>.forward</CODE>. Bien qu'il ne soit pas recommand&eacute; d'inhiber ces
avertissements, je suis toujours seul &agrave; la console et j'ai
trouv&eacute; que ce trou de s&eacute;curit&eacute; mineur
n'&eacute;tait en fait pas g&ecirc;nant. C'est vous qui voyez.</P>


<H2><A NAME="ss3.7">3.7 Quelques astuces pour les administrateurs syst&egrave;me</A>
     d&eacute;butants. <EM>Jim Dennis,</EM> <CODE>jadestar@rahul.net</CODE></H2>

<P>Cr&eacute;ez et tenez &agrave; jour un fichier
<CODE>/README.`hostname`</CODE> ou <CODE>/etc/README.`hostname`</CODE>
<EM>[&nbsp;ou &eacute;ventuellement
<CODE>/usr/local/etc/README.`hostname`</CODE> - le
r&eacute;dacteur&nbsp;]</EM></P>
<P>Absolument, &agrave; compter du <EM>premier jour</EM> de l'administration
d'un syst&egrave;me, prenez des notes dans un fichier journal. Vous
pouvez mettre "vi /README.$(hostname)" sur une ligne du fichier
<CODE>.bash_logout</CODE> de root. Une autre fa&ccedil;on de faire est
d'&eacute;crire un script <CODE>su</CODE> ou <CODE>sudo</CODE> qui fait quelque chose
comme &ccedil;a&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
                function exit \
                        { unset exit; exit; \
                          cat ~/tmp/session.$(date +%y%m%d) \
                          >> /README.$(hostname) &amp;&amp; \
                          vi /README.$(hostname)
                          }
                script -a ~/tmp/session.$(date +%y%m%d)
                /bin/su.org -
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>(utilise la commande tap&eacute;e pour cr&eacute;er une trace de la
session et cr&eacute;e une fonction pour automatiser la mise &agrave;
jour du fichier journal).</P>
<P>J'admets que je n'ai pas implant&eacute; cette automatisation -
jusqu'&agrave; maintenant je me suis repos&eacute; sur ma
discipline. Cependant j'ai envisag&eacute; l'id&eacute;e (au point
d'&eacute;crire les scripts et les fonctions que vous avez sous les
yeux). Une chose qui me retient est la commande "script"
elle-m&ecirc;me. Je pense qu'il va falloir que je me procure les
sources et que je rajoute une paire de param&egrave;tres (pour
arr&ecirc;ter l'enregistrement du script depuis la ligne de commandes)
avant de me mettre &agrave; utiliser &ccedil;a.</P>
<P>Ma derni&egrave;re suggestion (pour cette fois)&nbsp;:</P>
<P>La variable PATH de root devrait contenir <CODE>PATH=~/bin</CODE>.</P>
<P>C'est tout. Rien d'autre dans le PATH de root. Tout ce que root peut
faire est fourni par un lien symbolique dans <CODE>~/bin</CODE>, un alias,
une fonction shell, un script ou un binaire situ&eacute; dans
<CODE>~/bin</CODE>, ou bien la commande est tap&eacute;e avec un chemin
d'acc&egrave;s explicite.</P>
<P>De cette fa&ccedil;on, toute personne utilisant le compte root se rend
compte (parfois douloureusement) &agrave; quel point elle fait
confiance aux binaires. L'administrateur avis&eacute; d'un
syst&egrave;me multi-utilisateurs va en plus parcourir
r&eacute;guli&egrave;rement son r&eacute;pertoire <CODE>~/bin</CODE> et ses
fichiers <CODE>~/.*history</CODE> pour y chercher des
r&eacute;p&eacute;titions et des moyens de les contourner.</P>
<P>L'administrateur vraiment motiv&eacute; va rep&eacute;rer les
encha&icirc;nements qui peuvent &ecirc;tre automatis&eacute;s, les
endroits o&ugrave; des v&eacute;rifications peuvent &ecirc;tre
ajout&eacute;es, et les t&acirc;ches pour lesquelles les
privil&egrave;ges de root peuvent &ecirc;tre abandonn&eacute;es (comme
lancer un &eacute;diteur, un agent de transport de courrier
&eacute;lectronique ou autre gros programme pouvant ex&eacute;cuter
des scripts qui *pourraient* &ecirc;tre inclus dans des fichiers de
donn&eacute;es - comme vi (<CODE>./.exrc</CODE>) ou emacs (<CODE>./.emacs</CODE>)
ou m&ecirc;me, plus insidieux, $EXINIT et les macros contenues au
d&eacute;but ou &agrave; la fin des documents). Bien s&ucirc;r, les
commandes de ce genre peuvent &ecirc;tre lanc&eacute;es avec quelque
chose comme &ccedil;a&nbsp;:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
                cp $donn&eacute;es $r&eacute;pertoire_utilisateur/tmp
                su -c $commande_d_origine $param&egrave;tres
                cp $r&eacute;pertoire_utilisateur/tmp $donn&eacute;es
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>(... o&ugrave; les d&eacute;tails d&eacute;pendent de la commande).</P>
<P>Ces derni&egrave;res pr&eacute;cautions sont pour la plupart
superflues pour la machine personnelle ou la station
"mono-utilisateur". Mais elles repr&eacute;sentent une tr&egrave;s
bonne mani&egrave;re d'administrer un gros syst&egrave;me
multi-utilisateurs, particuli&egrave;rement dans le cas d'un
acc&egrave;s public (comme les machines de netcom).</P>


<H2><A NAME="ss3.8">3.8 Comment configurer <CODE>xdm</CODE> pour qu'il permette de choisir le syst&egrave;me h&ocirc;te ? <I>Arrigo Triulzi,</I> <CODE>a.triulzi@ic.ac.uk</CODE>.</A>
</H2>

<P>
<OL>
<LI> Modifier le  fichier lan&ccedil;ant xdm lors du d&eacute;marrage
(probablement nomm&eacute; /etc/rc/rc.6 ou /etc/rc.local) de fa&ccedil;on que la section
de xdm contienne :
<BLOCKQUOTE><CODE>
<PRE>
/usr/bin/X11/xdm
exec /usr/bin/X11/X -indirect hostname
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI> Modifier le fichier /usr/lib/X11/xdm/Xservers et commenter la ligne
invoquant le serveur sur la machine locale (commence par "0:")
</LI>
<LI> Relancer le syst&egrave;me... tout doit fonctionner&nbsp;!</LI>
</OL>
</P>
<P>J'ajoute cette section apr&egrave;s avoir su&eacute; une semaine durant sur ce probl&egrave;me&nbsp;!</P>
<P>Attention : certaines anciennes versions de la distribution SLS (1.1.1)
exigent qu'un param&egrave;tre "-nodaemon" accompagne l'invocation d'xdm.
Les version ult&eacute;rieures ne pr&eacute;sentent <B>PAS</B> cette caract&eacute;ristique.</P>

</BODY>
</HTML>
