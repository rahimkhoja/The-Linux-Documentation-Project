<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><title>Guide pratique du jeu sous Linux</title><link rel="stylesheet" href="style.css" type="text/css"><meta name="generator" content="DocBook XSL Stylesheets V1.64.1"><meta name="description" content="
    
    Les mêmes questions reviennent continuellement sur les listes de
    diffusion et groupes de discussion Linux. Beaucoup d'entre elles
    sont dues à la méconnaissance du fonctionnement de Linux, du moins
    en ce qui concerne le jeu. Jouer peut être malaisé : cela
    requiert la connaissance d'une très grande étendue de sujets parmi
    lesquels on trouve les compilateurs, les bibliothèques,
    l'administration système, la gestion de réseaux, l'administration de
    XFree86, et cætera, vous voyez le genre.
    Chaque aspect de votre ordinateur joue un rôle dans le jeu. C'est un
    sujet exigeant, mais ce fait est occulté par le but principal du
    jeu : s'amuser et décompresser.
    
     
    
    Ce document est un point de départ pour résoudre la plupart des
    problèmes courants et pour donner aux joueurs les connaissances
    nécessaires afin de réagir intelligemment en cas de problème avec
    leurs jeux. Comme de coutume sous Linux, vous devez connaître un peu
    ce qui se passe en coulisses pour que vos jeux continuent à
    fonctionner correctement ou pour poser un diagnostic et agir en
    conséquence dans le cas contraire.
    
    "></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article" lang="fr"><div class="titlepage"><div><div><h1 class="title"><a name="Linux-Gamers-HOWTO"></a>Guide pratique du jeu sous Linux</h1></div><div><h3 class="subtitle"><i>
    
        Version française du <span class="foreignphrase"><i class="foreignphrase">Linux Gamers'
        HOWTO</i></span>
    
    </i></h3></div><div><div class="author"><h3 class="author"><span class="firstname">Peter</span> <span class="othername">Jay</span> <span class="surname">Salzman</span></h3><tt class="email">&lt;<a href="mailto:p%20CHEZ%20dirac%20POINT%20org">p CHEZ dirac POINT org</a>&gt;</tt></div></div><div><div class="author"><h3 class="author"><span class="firstname">Frédéric</span> <span class="surname">Delanoy</span></h3></div></div><div><p class="othercredit"><span class="contrib">Traduction française</span>: <span class="firstname">Frédéric</span> <span class="surname">Delanoy</span></p></div><div><p class="releaseinfo">Version : 1.0.1.fr.0.9</p></div><div><p class="copyright">Copyright © 2001, 2002 Peter Jay Salzman</p></div><div><p class="copyright">Copyright © 2003, 2004 Peter Jay Salzman, Frédéric Delanoy</p></div><div><div class="legalnotice"><p>
        <tt class="email">&lt;<a href="mailto:p%20CHEZ%20dirac%20POINT%20org">p CHEZ dirac POINT org</a>&gt;</tt> / 
        <a href="http://www.dirac.org/p" target="_top">http://www.dirac.org/p</a>.
      </p><p>
        Distribué selon les termes de la <span class="foreignphrase"><i class="foreignphrase">Open Software
        License</i></span>, version 1.1.
      </p></div></div><div><p class="pubdate">9 juin 2004</p></div><div><div class="revhistory"><table border="1" width="100%" summary="Revision history"><tr><th align="left" valign="top" colspan="2"><b>Historique des versions</b></th></tr><tr><td align="left">Version 1.0.1.fr.0.9</td><td align="left">2004-06-09</td></tr><tr><td align="left" colspan="2">
            Traduction de la version 1.0.1 du « Linux
            Gamers' HOWTO »
        </td></tr><tr><td align="left">Version 1.0.1</td><td align="left">2004-02-04</td></tr></table></div></div><div><div class="abstract"><p class="title"><b>Résumé</b></p><p>
    
    Les mêmes questions reviennent continuellement sur les listes de
    diffusion et groupes de discussion Linux. Beaucoup d'entre elles
    sont dues à la méconnaissance du fonctionnement de Linux, du moins
    en ce qui concerne le jeu. Jouer peut être malaisé : cela
    requiert la connaissance d'une très grande étendue de sujets parmi
    lesquels on trouve les compilateurs, les bibliothèques,
    l'administration système, la gestion de réseaux, l'administration de
    <span class="application">XFree86</span>, et cætera, vous voyez le genre.
    Chaque aspect de votre ordinateur joue un rôle dans le jeu. C'est un
    sujet exigeant, mais ce fait est occulté par le but principal du
    jeu : s'amuser et décompresser.
    
    </p><p>
    
    Ce document est un point de départ pour résoudre la plupart des
    problèmes courants et pour donner aux joueurs les connaissances
    nécessaires afin de réagir intelligemment en cas de problème avec
    leurs jeux. Comme de coutume sous Linux, vous devez connaître un peu
    ce qui se passe en coulisses pour que vos jeux continuent à
    fonctionner correctement ou pour poser un diagnostic et agir en
    conséquence dans le cas contraire.
    
    </p></div></div></div><div></div><hr></div><div class="toc"><p><b>Table des matières</b></p><dl><dt><span class="sect1"><a href="#administrata">1. Informations administratives</a></span></dt><dd><dl><dt><span class="sect2"><a href="#droits">1.1. Droits d'utilisation</a></span></dt><dt><span class="sect2"><a href="#authorship">1.2. Authorship and Copyright</a></span></dt><dt><span class="sect2"><a href="#acknowledgements">1.3. Remerciements</a></span></dt><dt><span class="sect2"><a href="#version">1.4. Dernières versions et traductions</a></span></dt></dl></dd><dt><span class="sect1"><a href="#definitions">2. Définitions : types de jeux</a></span></dt><dd><dl><dt><span class="sect2"><a href="#arcade">2.1. Arcade</a></span></dt><dt><span class="sect2"><a href="#cardboard">2.2. Jeux de cartes, de logique et de
    plateau</a></span></dt><dt><span class="sect2"><a href="#interactivefiction">2.3. Aventure en mode texte (ou
    fiction interactive)</a></span></dt><dt><span class="sect2"><a href="#graphicaladventure">2.4. Aventures graphiques</a></span></dt><dt><span class="sect2"><a href="#id2497338">2.5. Jeux de simulation</a></span></dt><dt><span class="sect2"><a href="#strategy">2.6. Jeux de stratégie</a></span></dt><dt><span class="sect2"><a href="#fps">2.7. Jeux de combat à la première personne (First
    Person Shooter, FPS)</a></span></dt><dt><span class="sect2"><a href="#id2497687">2.8. Jeux à défilement horizontal</a></span></dt><dt><span class="sect2"><a href="#id2497736">2.9. Jeux de combat à la troisième personne</a></span></dt><dt><span class="sect2"><a href="#rpg">2.10. Jeux de rôle (Role Playing Game, RPG)</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2497982">3. Bibliothèques</a></span></dt><dd><dl><dt><span class="sect2"><a href="#glide2">3.1. Glide2</a></span></dt><dt><span class="sect2"><a href="#glide3">3.2. Glide3</a></span></dt><dt><span class="sect2"><a href="#opengl">3.3. OpenGL</a></span></dt><dt><span class="sect2"><a href="#mesa">3.4. Mesa</a></span></dt><dt><span class="sect2"><a href="#id2498417">3.5. DRI</a></span></dt><dt><span class="sect2"><a href="#id2498508">3.6. GLX</a></span></dt><dt><span class="sect2"><a href="#id2498523">3.7. Utah GLX</a></span></dt><dt><span class="sect2"><a href="#xlib">3.8. xlib</a></span></dt><dt><span class="sect2"><a href="#widgetset">3.9. Widgets</a></span></dt><dt><span class="sect2"><a href="#sdl">3.10. SDL (Simple DirectMedia Layer)</a></span></dt><dt><span class="sect2"><a href="#ggi">3.11. GGI</a></span></dt><dt><span class="sect2"><a href="#svgalib">3.12. SVGAlib, framebuffer et console</a></span></dt><dt><span class="sect2"><a href="#openal">3.13. OpenAL</a></span></dt><dt><span class="sect2"><a href="#directx">3.14. DirectX</a></span></dt><dt><span class="sect2"><a href="#clanlib">3.15. Clanlib</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2499398">4. XFree86 et vous</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2499454">4.1. Recueillir des informations sur votre système X</a></span></dt><dt><span class="sect2"><a href="#nowm">4.2. Jouer à des jeux sous X sans gestionnaire de
    fenêtres</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2499900">5. Divers</a></span></dt><dd><dl><dt><span class="sect2"><a href="#mtrr">5.1. Registres d'intervalles
    mémoire</a></span></dt><dt><span class="sect2"><a href="#milkingperformance">5.2. Exploiter au maximum les
    ressources de votre système</a></span></dt><dt><span class="sect2"><a href="#id2500077">5.3. À propos des bibliothèques sous Linux</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2500547">6. Quand de mauvaises choses arrivent à de bonnes gens</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2500576">6.1. RTFM !</a></span></dt><dt><span class="sect2"><a href="#id2500622">6.2. Recherchez des mises à jour et des correctifs</a></span></dt><dt><span class="sect2"><a href="#id2500702">6.3. Groupes de discussion</a></span></dt><dt><span class="sect2"><a href="#id2500758">6.4. Recherche sur Google Groupes</a></span></dt><dt><span class="sect2"><a href="#id2500879">6.5. Débogage : traces d'appel et fichiers core</a></span></dt><dt><span class="sect2"><a href="#savedgames">6.6. Parties sauvegardées</a></span></dt><dt><span class="sect2"><a href="#id2501115">6.7. Que faire quand on ne trouve pas un fichier ou une
    bibliothèque (ou se faciliter la vie avec
    strace)</a></span></dt><dt><span class="sect2"><a href="#hosedconsoles">6.8. Consoles corrompues</a></span></dt><dt><span class="sect2"><a href="#id2501804">6.9. Système bloqué</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2502159">7. Cartes vidéo</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2502163">7.1. Historique</a></span></dt><dt><span class="sect2"><a href="#id2502563">7.2. Situation actuelle (13 juillet 2003)</a></span></dt><dt><span class="sect2"><a href="#id2502668">7.3. Quelle carte vidéo dois-je acheter ? (13 juillet
      2003)</a></span></dt><dt><span class="sect2"><a href="#id2502756">7.4. Définitions : carte vidéo et terminologie 3D</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2503208">8. Son</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2503213">8.1. Quelle carte son est la meilleure ?</a></span></dt><dt><span class="sect2"><a href="#id2503403">8.2. Pourquoi le son ne fonctionne-t-il pas ?</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2503945">9. Problèmes divers</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2503950">9.1. Problèmes d'accélération matérielle</a></span></dt><dt><span class="sect2"><a href="#id2504221">9.2. L'accélération matérielle ne fonctionne que pour
    root</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2504334">10. Émulation et machines virtuelles</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2504370">10.1. Qu'est-ce qu'une machine virtuelle ?</a></span></dt><dt><span class="sect2"><a href="#id2504444">10.2. Apple 8 bits</a></span></dt><dt><span class="sect2"><a href="#id2504571">10.3. DOS</a></span></dt><dt><span class="sect2"><a href="#id2504676">10.4. Win16</a></span></dt><dt><span class="sect2"><a href="#win32">10.5. Win32</a></span></dt></dl></dd><dt><span class="sect1"><a href="#interpreters">11. Interpréteurs</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2505833">11.1. Moteur SCUMM (LucasArts)</a></span></dt><dt><span class="sect2"><a href="#id2505937">11.2. AGI : Adventure Gaming Interface (Sierra)</a></span></dt><dt><span class="sect2"><a href="#id2506008">11.3. SCI : SCript Interpreter ou Sierra Creative
    Interpreter (Sierra)</a></span></dt><dt><span class="sect2"><a href="#infocom">11.4. Infocom Adventures (Infocom,
    Activision)</a></span></dt><dt><span class="sect2"><a href="#scottadams">11.5. Scott Adams Adventures (Adventure
    International)</a></span></dt><dt><span class="sect2"><a href="#id2506340">11.6. Ultima Underworld : The Stygian Abyss (Origin, Blue
    Sky Productions)</a></span></dt><dt><span class="sect2"><a href="#exult">11.7. Ultima 7 (Origin, Electronic Arts)</a></span></dt><dt><span class="sect2"><a href="#id2506547">11.8. System Shock (Electronic Arts, Origin)</a></span></dt></dl></dd><dt><span class="sect1"><a href="#id2506680">12. Sites web et ressources</a></span></dt><dd><dl><dt><span class="sect2"><a href="#id2506684">12.1. Méta-sites web de jeux</a></span></dt><dt><span class="sect2"><a href="#id2506765">12.2. Jeux Linux commerciaux</a></span></dt><dt><span class="sect2"><a href="#id2507078">12.3. Autres ressources</a></span></dt></dl></dd></dl></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="administrata"></a>1. Informations administratives</h2></div></div><div></div></div><p>
    
    Si vous avez des idées, corrections ou questions relatives à ce
    guide, envoyez-moi un courriel. Le fait de recevoir du retour (même
    si je n'ai pas le temps de répondre) me donne l'impression que je
    fais quelque chose d'utile. Dès lors, cela me motive à écrire plus
    encore et à compléter ce document. Vous pouvez me contacter
    (NdT : en anglais) à l'adresse
    
    <tt class="email">&lt;<a href="mailto:p%20CHEZ%20dirac%20POINT%20org">p CHEZ dirac POINT org</a>&gt;</tt>.
    
    Ma page web est <a href="http://www.dirac.org/p" target="_top">http://www.dirac.org/p</a> et mes
    pages Linux sont situées sur <a href="http://www.dirac.org/linux" target="_top">http://www.dirac.org/linux</a>. N'hésitez pas à envoyer
    vos commentaires et suggestions relatifs à ce guide. Même si je ne
    les retiens pas tous, votre apport est le bienvenu.
    
    </p><p>
    
    N'hésitez pas à faire parvenir tout commentaire relatif à la version
    française de ce document à
    
    <tt class="email">&lt;<a href="mailto:commentaires%20CHEZ%20traduc%20POINT%20org">commentaires CHEZ traduc POINT org</a>&gt;</tt>.
    
</p><p>
    
    Je présume une connaissance pratique de Linux, et j'utilise donc
    certains termes comme les niveaux d'exécution et les modules sans
    les définir. S'il y a assez de questions (ou même de protestations),
    j'ajouterai des informations plus basiques à ce document.
    
    </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="droits"></a>1.1. Droits d'utilisation</h3></div></div><div></div></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td colspan="2" align="left" valign="top"><p>
        
        Le texte ci-dessous est la version française de la licence de ce
        document. Seule la version originale de cette licence, présentée
        dans la section suivante, fait foi.
      
      </p></td></tr></table></div><p>
      
      La version originale de ce document a été réalisée par
      <span class="firstname">Peter</span> <span class="othername">
      Jay</span> <span class="surname"> Salzman</span>
      
      <tt class="email">&lt;<a href="mailto:p%20CHEZ%20dirac%20POINT%20org">p CHEZ dirac POINT org</a>&gt;</tt>
      
      pour les années 2001-2002, et à <span class="firstname">Peter</span> <span class="othername">
      Jay</span> <span class="surname"> Salzman</span> et
      <span class="firstname">Frédéric</span> <span class="surname">
      Delanoy</span> pour les années 2003-2004.
      
      </p><p>
      
      Vous avez le droit de copier, distribuer et modifier la version
      originale de ce document selon les termes de la <a href="http://opensource.org/licenses/osl-1.1.txt" target="_top"><span class="foreignphrase"><i class="foreignphrase">Open Software
      License</i></span></a> (OSL), version 1.1, complétés par
      les dispositions présentées dans le paragraphe suivant. Je déteste
      les guides qui incluent la licence : des arbres
      meurent…
      
      </p><p>
      
      Si vous voulez créer un travail dérivé ou publier ce guide à des
      fins commerciales, je souhaiterais être contacté au préalable.
      Cela me donnera l'occasion de vous fournir la version la plus
      récente. J'apprécierais également soit une copie de votre travail,
      soit une pizza aux épinards, à l'ail, aux champignons, à la feta
      et aux cœurs d'artichauts.
      
      </p><p>
      
      La version française de ce document a été réalisée par
      <span class="firstname">Frédéric</span> <span class="surname">
      Delanoy</span>. Elle est publiée en accord avec
      les termes de la <span class="foreignphrase"><i class="foreignphrase">Open Software
      License</i></span>.
      
      </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="authorship"></a>1.2. Authorship and Copyright</h3></div></div><div></div></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Important"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Important]" src="images/important.png"></td><th align="left">Important</th></tr><tr><td colspan="2" align="left" valign="top"><p>
    
    Le texte ci-dessous est la licence de ce document. Ce texte fait
    foi. Il est composé de la licence en anglais du document orignal,
    suivi de la licence en français de sa traduction.
    
    </p></td></tr></table></div><p>
    
      This document is copyright (c) 2001-2002 Peter Jay Salzman,
      
      <tt class="email">&lt;<a href="mailto:p(at)dirac(dot)org">p(at)dirac(dot)org</a>&gt;</tt>;
      
      2003-2004 Peter Jay Salzman and Frédéric Delanoy. Permission is
      granted to copy, distribute and/or modify this document under the
      terms of the Open Software License, Version 1.1, except for the
      provisions I list in the next paragraph. I hate HOWTO's that
      include the license; it's a tree killer. You can read the OSL at
      <a href="http://opensource.org/licenses/osl-1.1.txt" target="_top">http://opensource.org/licenses/osl-1.1.txt</a>.
      
    </p><p>
    
    If you want to create a derivative work or publish this HOWTO for
    commercial purposes, I would appreciate it if you contact me first.
    This will give me a chance to give you the most recent version. I'd
    also appreciate either a copy of whatever it is you're doing or a
    spinach, garlic, mushroom, feta cheese and artichoke heart pizza.
    
    </p><p>
    
    La version française de ce document a été réalisée par
    
    <span class="firstname">Frédéric</span> <span class="surname">Delanoy</span>.
    
    Elle est publiée en accord avec les termes de la <span class="foreignphrase"><i class="foreignphrase">Open
    Software License</i></span>.
    
    </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="acknowledgements"></a>1.3. Remerciements</h3></div></div><div></div></div><p>
      
      Merci à
      
      <span class="firstname">Mike</span> <span class="surname">Phillips</span>
      
      qui a énormément commenté ce guide.
      Merci à
      
      <span class="firstname">Dmitry</span> <span class="surname">Samoyloff</span>,
      
      <tt class="email">&lt;<a href="mailto:dsamoyloff%20CHEZ%20yandex%20POINT%20ru">dsamoyloff CHEZ yandex POINT ru</a>&gt;</tt>,
      
      qui a traduit ce document en russe. Cela m'a fait chaud au
      cœur quand il m'a raconté qu'il traduisait mes mots en
      russe. D'autres remerciements reviennent à :
      
      </p><div class="orderedlist"><ol type="1"><li><p>Moritz Muehlenhoff
          
          <tt class="email">&lt;<a href="mailto:jmm%20CHEZ%20Informatik%20POINT%20uni-bremen%20POINT%20de">jmm CHEZ Informatik POINT uni-bremen POINT de</a>&gt;</tt> 
          
          qui m'a envoyé des mises à jour (même si je suis éternellement
          à la traîne…)
          
          </p></li><li><p>
          
          Frédéric Delanoy pour d'importantes différences, corrections
          de fautes de frappe ou d'erreurs docbook.
          
          </p></li></ol></div><p>
      
        Je voudrais également remercier Michael Mc Donnell pour m'avoir
        envoyé des commentaires et des corrections.
      
      </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="version"></a>1.4. Dernières versions et traductions</h3></div></div><div></div></div><p>
      
      La version la plus récente peut être trouvée sur <a href="http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/lgh/LG-HOWTO" target="_top">http://cvs.sourceforge.net/cgi-bin/viewcvs.cgi/lgh/LG-HOWTO</a>
      ou <a href="http://www.dirac.org/linux/writing" target="_top">http://www.dirac.org/linux/writing</a>, mais
      c'est ma copie de travail personnelle. La version présente sur mon
      site web personnel pourrait être corrompue si je travaille sur le
      guide. La version sur sourceforge est la plus récente mais est
      garantie non corrompue, même si elle peut comporter quelques
      petits problèmes, comme des paragraphes non terminés. :)
      
      </p><p>
      
      La version stable la plus récente peut être trouvée sur <a href="http://www.tldp.org" target="_top">http://www.tldp.org</a>.
      
      </p><p>

      <span class="firstname">Dmitry</span> <span class="surname">Samoyloff</span>,
      
      <tt class="email">&lt;<a href="mailto:dsamoyloff%20CHEZ%20yandex%20POINT%20ru">dsamoyloff CHEZ yandex POINT ru</a>&gt;</tt>,
      
      est responsable de la traduction russe de ce guide. La version la
      plus récente peut être trouvée sur <a href="http://www.dirac.org/linux/writing" target="_top">http://www.dirac.org/linux/writing</a>.
      
      </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="definitions"></a>2. Définitions : types de jeux</h2></div></div><div></div></div><p>Tout le monde ne connaît pas les différents types de jeux
    existants. Pour pouvoir parler un langage commun, je vais m'intéresser
    à chaque type de jeu et fournir un très bref historique.</p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="arcade"></a>2.1. Arcade</h3></div></div><div></div></div><p>Bien que les jeux d'arcade ont connu leur heure de gloire dans
      les années 80, ils restent néanmoins très populaires. Rien ne
      remplacera jamais une promenade dans une galerie d'arcade sombre,
      bondée et bruyante, y glissant une pièce dans votre machine préférée
      et jouant à un vieux jeu du genre <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Space
      Invaders</i></span></span>™. Les jeux de style arcade
      essaient de simuler les jeux d'arcade eux-mêmes. Il y en a tellement
      qu'il est quasi impossible de tous les énumérer, mais on peut citer
      les clones de
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Asteroids</i></span></span>™,
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Space
      Invaders</i></span></span>™,
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Pac-Man</i></span></span>™,
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Missile
      Command</i></span></span>™ et
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Galaxian</i></span></span>™.
      </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="cardboard"></a>2.2. Jeux de cartes, de logique et de
    plateau</h3></div></div><div></div></div><p>
      Les jeux de cartes simulent des jeux comme le poker ou le solitaire.
      Le programme peut simuler votre ou vos adversaire(s).
      </p><p>
      Les jeux de logique simulent habituellement quelque casse-tête
      logique bien connu comme <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Master
      Mind</i></span></span>™ ou le taquin.
      </p><p>
      Les jeux de plateau simulent les jeux que vous pourriez jouer sur une
      table avec des amis, comme le
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Monopoly</i></span></span>™,
      les échecs, et cætera. Le programme peut simuler votre adversaire.
      </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="interactivefiction"></a>2.3. Aventure en mode texte (ou
    fiction interactive)</h3></div></div><div></div></div><p>Il était une fois, quand Apple ][, Commodore et Atari
      dominaient le monde, les aventures en mode texte étaient le jeu dans
      le vent des « <span class="quote">gens éduqués</span> ». On vous fournit
      un scénario et vous pouvez interagir avec le monde dans lequel vous
      vous trouvez :
      </p><pre class="screen">
You are in a room.  It is pitch dark and you're likely
to be eaten by a grue.
&gt; Light lantern with match.
You light the lantern.  This room appears to be a kitchen. 
There's a table with a book in the center.  You
also see an oven, refrigerator and a door leading east.
&gt; Open the oven.
In the oven you see a brown paper bag.
&gt; Take the bag.  Open the bag.  Close the oven.
Inside the bag is a clove of garlic and a cheese sandwich.
The oven door is now closed.
</pre><p>À cette époque, les aventures en mode texte étaient des
      exécutables autonomes tenant entièrement sur une disquette ou une
      cassette. Il y avait souvent un fichier de données et un
      interpréteur. L'interpréteur lit les fichiers de données et fournit
      l'interface de jeu. Les fichiers de données constituent le jeu en
      lui-même, à la manière de la relation entre les <a href="#fps" title="2.7. Jeux de combat à la première personne (First
    Person Shooter, FPS)">jeux de combat à la première personne</a> et les
      fichiers <tt class="filename">wad</tt>.</p><p>Le premier jeu d'aventure était
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Adventure</i></span></span>™
      (en fait
      « <span class="quote"><span class="productname"><span class="foreignphrase"><i class="foreignphrase">ADVENT</i></span></span>™</span> »,
      écrit sur un PDP-1 en 1972). Vous pouvez toujours jouer à Adventure
      (en fait, à un descendant) : il est fourni avec les
      « <span class="quote">jeux bsd</span> » sur la plupart des distributions
      Linux. Les aventures en mode texte ont été popularisées par <a href="#scottadams" title="11.5. Scott Adams Adventures (Adventure
    International)"><span class="firstname">Scott</span> <span class="surname"> Adams</span></a> et ont atteint leur pic
      de popularité à la fin des années 80 avec les jeux de <a href="#infocom" title="11.4. Infocom Adventures (Infocom,
    Activision)">Infocom</a> auxquels on peut également jouer
      sous Linux.</p><p>Comme les modes graphiques se sont développés et sont devenus
      plus puissants, les aventures en mode texte ont cédé la place aux
      aventures en mode graphique. La mort de la fiction interactive a plus
      ou moins coïncidé avec la faillite de Infocom.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="graphicaladventure"></a>2.4. Aventures graphiques</h3></div></div><div></div></div><p>Les aventures graphiques sont, en fin de compte, des aventures
      en mode texte traitées aux anabolisants. Leur degré d'utilisation des
      graphiques varie fortement. Dans les années 80, ils n'étaient qu'un
      peu plus que des aventures en mode texte et affichaient un écran
      rempli de graphiques statiques. Quand vous ramassiez un objet,
      l'arrière-plan était repeint et l'objet disparaissait. L'exemple type
      pourrait être les prétendues « <span class="quote">aventures en haute
      résolution</span> » comme <span class="productname"><span class="foreignphrase"><i class="foreignphrase">The Wizard
      And The Princess</i></span></span>™. Plus tard, les
      aventures graphiques sophistiquées faisaient déambuler votre
      personnage à l'écran, et vous pouviez même utiliser une souris, mais
      l'interface restait purement textuelle.</p><p>Ensuite, il y eut les « <span class="quote">aventures pilotées à la
      souris</span> » qui n'avaient plus d'interface textuelle, et
      disposaient souvent de graphiques dynamiques, comme un chat se
      baladant dans la pièce pendant que vous décidiez de la prochaine
      action à effectuer. Dans ce type de jeux, vous pointez un objet
      (p.ex. un livre) et vous pouvez choisir une action à partir d'une
      liste déroulante de fonctions. Un genre d'aventure orientée objet. :)
      Il n'y a pas beaucoup d'aventures graphiques écrites nativement pour
      Linux. La seule dont je me rappelle est
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Hopkins FBI</i></span></span>™
      (qui est mon jeu préféré sous Linux).</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2497338"></a>2.5. Jeux de simulation</h3></div></div><div></div></div><p>Les simulations s'efforcent d'immerger le joueur dans un milieu
      auquel il n'aurait normalement pas accès. Cela peut être quelque
      chose comme un avion de chasse ou quelque chose d'imaginaire comme
      une unité de combat mécanisée. Dans tous les cas, les simulations
      recherchent le réalisme.</p><p>Certaines simulations ne comportent que peu ou pas de
      stratégie. Elles vous placent simplement dans un cockpit pour vous
      donner la sensation de piloter un avion. Certaines sont extrêmement
      complexes, et la frontière est souvent ténue entre les simulations et
      les <a href="#strategy" title="2.6. Jeux de stratégie">jeux de stratégie</a>. Un bon exemple
      serait <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Heavy Gear
      III</i></span></span>™ ou
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Flight
      Gear</i></span></span>™. De nos jours, les jeux de
      simulation et de stratégie sont pratiquement indissociables mais, il
      y a longtemps, les simulations se déroulaient en temps réel alors que
      les jeux de stratégie se jouaient au tour à tour. Cette dénomination
      est maladroite de nos jours, car un jeu comme
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Warcraft</i></span></span>™,
      que tout le monde considère être un jeu de stratégie, serait une
      simulation par définition.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="strategy"></a>2.6. Jeux de stratégie</h3></div></div><div></div></div><p>Les jeux de stratégie descendent des vieux jeux de plateau de
      type <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Avalon</i></span></span>™
      comme <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Panzer
      Leader</i></span></span>™ et des vieux jeux de stratégie
      militaire publiés par SSI. Généralement, ils simulent quelque type de
      scénario. Il peut être pacifique, comme la gestion réussie d'une
      ville
      (<span class="productname"><span class="foreignphrase"><i class="foreignphrase">SimCity</i></span></span>™),
      ou pas, comme la vente illégale de drogue
      (<span class="productname"><span class="foreignphrase"><i class="foreignphrase">DrugWars</i></span></span>™)
      ou un jeu de stratégie militaire acharné comme
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Myth II</i></span></span>™. Ce
      type de jeux a habituellement une longue durée de vie et requiert
      beaucoup de réflexion.</p><p>Les jeux de stratégie peuvent être à leur tour subdivisés en
      deux classes : le temps réel et le tour à tour. Les jeux de
      stratégie en temps réel sont basés sur le principe « <span class="quote">un
      petit moment d'inattention, et c'est perdu</span> ». Par exemple,
      vous gérez une ville et un incendie se déclenche quelque part. Au
      plus il vous faut du temps pour mobiliser les pompiers, au plus
      l'incendie fera du dégât. Les jeux de stratégie au tour à tour sont
      similaires aux échecs : l'ordinateur joue, puis c'est au tour du
      joueur, et cætera.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="fps"></a>2.7. Jeux de combat à la première personne (First
    Person Shooter, FPS)</h3></div></div><div></div></div><p>Quelle est cette lumière au loin ? Cela doit être l'éclair
      du fusil de chasse à double canon ! L'histoire des jeux FPS est
      longue et tortueuse et a commencé quand id Software a ouvert le code
      source de
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Doom</i></span></span>™. Ce
      code a été repris (par d'autres équipes) et fusionné à de nombreuses
      reprises. D'autres moteurs précédemment fermés se sont ouverts,
      beaucoup de moteurs sont jouables via des émulateurs, beaucoup de
      jeux FPS commerciaux ont été publiés pour Linux et nombre de moteurs
      FPS étaient des projets <span class="foreignphrase"><i class="foreignphrase">open source</i></span> à
      l'origine. Bien qu'il se peut que vous ne puissiez pas jouer à votre
      jeu FPS <span class="emphasis"><em>préféré</em></span> sous Linux
      (<span class="productname"><span class="foreignphrase"><i class="foreignphrase">Half-Life</i></span></span>™
      marche très bien sous <span class="application">winex</span>), Linux ne
      présente certainement aucune lacune dans ce domaine !</p><p>Les FPS sont caractérisés par deux choses. Primo, vous tirez à
      peu près sur tout ce qui bouge. Secundo, l'action a lieu à la
      première personne, c.-à-d. au travers des yeux du personnage que vous
      interprétez. Vous pouvez même voir vos mains ou votre arme en bas de
      l'écran. Ils peuvent être du type fantastique
      (<span class="productname"><span class="foreignphrase"><i class="foreignphrase">Hexen</i></span></span>™),
      science-fiction (<span class="productname"><span class="foreignphrase"><i class="foreignphrase">Quake
      II</i></span></span>™), réaliste
      (<span class="productname"><span class="foreignphrase"><i class="foreignphrase">Soldier Of
      Fortune</i></span></span>™) parmi bien d'autres
      possibilités.</p><p>Tout comme les aventures en mode texte, les FPS obéissent au
      format moteur/fichier de données. Le moteur représente le jeu en
      lui-même
      (<span class="productname"><span class="foreignphrase"><i class="foreignphrase">Doom</i></span></span>™,
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Quake</i></span></span>™,
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Heretic2</i></span></span>™)
      et utilise les niveaux et les méchants décrits par les fichiers de
      données (<tt class="filename">doom2.wad</tt>,
      <tt class="filename">pak0.pak</tt>, etc). Beaucoup de jeux FPS permettent
      de créer ses propres fichiers de données non commerciaux. Il y a des
      centaines, si pas des milliers, de fichiers de données pour
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Doom</i></span></span>™ que
      vous pouvez télécharger gratuitement depuis Internet. Souvent, les
      sociétés libèrent leurs moteurs afin que la communauté
      <span class="foreignphrase"><i class="foreignphrase">open source</i></span> puisse les améliorer.
      Néanmoins, les fichiers de données originaux restent propriétaires.
      À ce jour, vous devez toujours acheter
      <tt class="filename">doom.wad</tt>.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2497687"></a>2.8. Jeux à défilement horizontal</h3></div></div><div></div></div><p>Les jeux à défilement horizontal sont similaires aux FPS mais
      vous voyez votre personnage comme une figure 2D qui court sur
      plusieurs écrans en tirant ou en effectuant d'autres tâches. Par
      exemple, il y a
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Abuse</i></span></span>™ pour
      Linux et le <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Duke
      Nukem</i></span></span>™ original. Ils ne sont pas
      nécessairement violents, comme
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">xscavenger</i></span></span>™,
      un clone du vieux jeu 8 bits <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Lode
      Runner</i></span></span>™.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2497736"></a>2.9. Jeux de combat à la troisième personne</h3></div></div><div></div></div><p>Similaires aux FPS, mais vous voyez votre personnage à la
      troisième personne et en 3D. Dans les jeux de combat à la troisième
      personne modernes, vous pouvez en général réaliser des
      manœuvres dévastatrices comme les retournés acrobatiques et les
      roulades à la Jackie Chan. L'exemple type serait
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Tomb
      Raider</i></span></span>™. Sous Linux, on dispose de
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Heretic 2</i></span></span>™
      et de <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Heavy Metal
      FAKK2</i></span></span>™.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="rpg"></a>2.10. Jeux de rôle (Role Playing Game, RPG)</h3></div></div><div></div></div><p>Quiconque a déjà joué à des jeux du style
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Dungeons &amp;
      Dragons</i></span></span>™ ou
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Call of
      Cthulhu</i></span></span>™ sait exactement ce qu'est un
      RPG. Vous interprétez un personnage (parfois plusieurs) doté de
      certaines caractéristiques (p.ex. force, dextérité), d'aptitudes
      (p.ex. explosifs, confection de paniers, mécanique) et de propriétés
      (niveaux, argent liquide). Au fil du temps, le personnage devient
      plus puissant et le jeu s'adapte en conséquence : p.ex., au lieu
      de combattre des orcs, vous commencez à combattre des dragons noirs
      dans les plus hauts niveaux. Les récompenses augmentent en
      conséquence. Dans les bas niveaux, vous pourriez obtenir quelques
      pièces d'or comme récompense suite à la victoire dans une
      bataille ; plus loin, vous pourriez obtenir une épée magique ou
      un fusil d'assaut ravageur.</p><p>Les RPG proposent généralement une quête ayant un épilogue bien
      déterminé. Dans
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">nethack</i></span></span>™,
      vous devez retrouver l'amulette de Yendor pour votre dieu. Dans
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Ultima II</i></span></span>™,
      vous détruisez la sorcière maléfique Minax. À un certain moment,
      votre personnage devient suffisamment puissant pour pouvoir vous
      lancer et essayer de terminer la quête.</p><p>Bien que la série immensément populaire des
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Ultima</i></span></span>™,
      écrite par <span class="firstname">Richard</span> <span class="surname">
      Garriot</span> (alias Lord British) pour Origin,
      n'était pas le premier RPG, elle a popularisé et propulsé le genre
      RPG sur le devant de la scène. <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Ultima
      I</i></span></span>™ a été publié en 1987 et est le point
      de départ de 9 (en fonction du mode de comptage) suites très
      populaires, se terminant par <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Ultima IX:
      Ascension</i></span></span>™. Vous pouvez <a href="#exult" title="11.7. Ultima 7 (Origin, Electronic Arts)">jouer à <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Ultima
      VII</i></span></span>™ sous Linux</a> avec
      Exult.</p><p>Le jeu RPG type sous Linux est
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Rogue</i></span></span>™ (la
      bibliothèque ncurses était à l'origine une routine de traitement
      d'écran pour
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Rogue</i></span></span>™ !)
      et on en décline des tas de variantes comme
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Zangband</i></span></span>™ et
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Nethack</i></span></span>™
      (qui a lui-même de nombreuses variantes). Certains RPG sont assez
      compliqués et constituent de véritables exploits de programmation. Il
      semble y avoir une carence en RPG commerciaux sous Linux. Si l'on ne
      compte pas les variantes de
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Rogue</i></span></span>™,
      c'est également le cas des RPG <span class="foreignphrase"><i class="foreignphrase">open
      source</i></span>.</p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2497982"></a>3. Bibliothèques</h2></div></div><div></div></div><p>Voici différentes bibliothèques consacrées au jeu que l'on peut
    trouver sous Linux.</p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="glide2"></a>3.1. Glide2</h3></div></div><div></div></div><p>Glide2 est une API et un pilote graphiques de bas niveau qui
      accèdent aux fonctions 3D accélérées par matériel des cartes Voodoo
      I, II et III de 3dfx sous <span class="application">XFree86</span>
      3.x.</p><p>Un programme ne peut utiliser les fonctionnalités spéciales
      accélérées matériellement de ces cartes qu'en utilisant la
      bibliothèque Glide2 d'une des deux façons suivantes :</p><div class="itemizedlist"><ul type="disc"><li><p>directement en utilisant Glide2
        (<span class="productname"><span class="foreignphrase"><i class="foreignphrase">Myth II</i></span></span>™,
        <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Descent
        III</i></span></span>™)</p></li><li><p>indirectement en utilisant Mesa construit avec un
        dorsal Glide2 pour simuler OpenGL
        (<span class="productname"><span class="foreignphrase"><i class="foreignphrase">Rune</i></span></span>™,
        <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Unreal
        Tournament</i></span></span>™)</p></li></ul></div><p>3dfx a ouvert les spécifications et le code source à la
      communauté <span class="foreignphrase"><i class="foreignphrase">open source</i></span>. Cela a permis
      à <span class="firstname">Daryll</span> <span class="surname">
      Strauss</span> de porter Glide2 sous Linux,
      autorisant les utilisateurs de <span class="application">XFree86</span> 3.x
      à utiliser les cartes Voodoo I, II et III sous Linux.</p><p>Puisque Glide2 accède directement à la carte vidéo, les
      applications Glide2 doivent soit être exécutées par root, soit être
      setuid-root. Une façon d'éviter cela était de créer le module noyau
      3dfx. Ce module (et son fichier de périphérique <tt class="filename">/dev/3dfx</tt>) permet l'accélération
      graphique matérielle Glide2 pour les utilisateurs non-root
      d'applications non-setuid.</p><p>Malheureusement, Glide2 n'est pas une solution d'avenir. Elle
      n'est utilisée que pour les cartes Voodoo I, II et III (qui
      deviennent obsolètes), sous <span class="application">XFree86</span> 3.x
      (la majorité utilise <span class="application">XFree86</span> 4.x). Et
      étant donné que 3dfx est maintenant une société défunte, il est
      certain qu'aucun développement n'aura désormais lieu sur Glide2 et
      qu'aucun nouveau jeu ne sera écrit en utilisant Glide2.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="glide3"></a>3.2. Glide3</h3></div></div><div></div></div><p>À la différence de Glide2, Glide3 n'est pas une API utilisée
      pour la programmation de jeux. Elle n'existe que pour gérer le DRI
      pour les cartes Voodoo III, IV et V sous
      <span class="application">XFree86</span> 4.x. Aucun des jeux utilisant
      Glide2 ne fonctionnera avec Glide3. Cela ne devrait pas être
      surprenant dans la mesure où Glide2 et Glide3 prennent en charge des
      cartes vidéo différentes et des versions de
      <span class="application">XFree86</span> différentes. La seule carte vidéo
      pouvant utiliser à la fois Glide2 (sous
      <span class="application">XFree86</span> 3.x) et Glide3 (sous
      <span class="application">XFree86</span> 4.x) est la Voodoo III. On
      rapporte qu'une Voodoo III utilisant Glide2 surpasse une Voodoo III
      utilisant Glide3.</p><p>Quand vous utilisez une Voodoo III, IV ou V sous
      <span class="application">XFree86</span> 4.x, vous devez utiliser une
      version de <a href="#mesa" title="3.4. Mesa">Mesa</a> qui a été compilée pour
      utiliser Glide3 comme dorsal afin de pouvoir utiliser l'accélération
      matérielle OpenGL sur votre système.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="opengl"></a>3.3. OpenGL</h3></div></div><div></div></div><p>OpenGL est une interface de programmation graphique de haut
      niveau développée à l'origine par SGI, et qui est devenue un standard
      industriel pour la programmation 2D et 3D. Elle est définie et
      soutenue par le Architectural Revision Board
      (<span class="acronym">ARB</span>), une organisation qui inclut des
      représentants de SGI, IBM, DEC et Microsoft. OpenGL fournit un jeu de
      fonctionnalités puissant, complet et générique pour les opérations
      graphiques 2D et 3D.</p><p>OpenGL est constitué de 3 parties :</p><div class="itemizedlist"><ul type="disc"><li><p>GL : les appels OpenGL de
        base</p></li><li><p>GLU : les appels utilitaires</p></li><li><p>GLUT : le traitement des événements de
        fenêtre indépendants du système (événements de souris, du clavier,
        et cætera).</p></li></ul></div><p>OpenGL n'est pas seulement une API, c'est aussi une
      implémentation, écrite par SGI. Elle essaie d'utiliser l'accélération
      matérielle pour diverses opérations graphiques quand elle est
      disponible, en fonction de de la carte vidéo dont vous disposez. Si
      l'accélération matérielle n'est pas possible pour une tâche
      particulière, OpenGL retombe sur le rendu logiciel. Cela signifie que
      si vous vous procurez OpenGL chez SGI, et que vous voulez disposer
      d'une accélération matérielle quelconque, elle doit être écrite en
      OpenGL et compilée spécifiquement pour une certaine carte graphique.
      Sinon, vous retomberez sur le rendu logiciel. Cela s'applique
      également aux clones d'OpenGL, comme Mesa.</p><p>OpenGL est l'équivalent <span class="foreignphrase"><i class="foreignphrase">open
      source</i></span> de Direct3D, un composant de <a href="#directx" title="3.14. DirectX">DirectX</a>. Une différence importante est que
      puisque OpenGL est ouvert (et DirectX fermé), les jeux écrits en
      OpenGL sont beaucoup plus faciles à porter et à co-développer sous
      Linux que ne le sont les jeux utilisant DirectX.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mesa"></a>3.4. Mesa</h3></div></div><div></div></div><p>Mesa &lt;<a href="http://www.mesa3d.org" target="_top">http://www.mesa3d.org</a>&gt; est
      une implémentation libre de l'API OpenGL, conçue et écrite par Brian
      Paul. Bien qu'elle ne soit pas officiellement certifiée (cela
      nécessiterait plus d'argent que n'en dispose un projet
      <span class="foreignphrase"><i class="foreignphrase">open source</i></span>), elle constitue une
      implémentation d'OpenGL presque totalement conforme aux
      spécifications de l'ARB. On rapporte que Mesa est même plus rapide
      que la propre implémentation OpenGL de SGI.</p><p>Tout comme OpenGL, Mesa utilise l'accélération matérielle quand
      c'est possible. Quand une tâche graphique particulière ne peut être
      accélérée matériellement par la carte vidéo, elle est rendue en
      logiciel ; la tâche est alors accomplie par votre processeur.
      Cela signifie qu'il existe différentes moutures de Mesa en fonction
      du type de carte vidéo dont vous disposez. Chaque mouture utilise une
      bibliothèque différente comme moteur de rendu. Par exemple, si vous
      avez une Voodoo I, II ou III sous <span class="application">XFree86</span>
      3.x, vous devriez utiliser mesa+glide2 (écrit par <span class="firstname">David</span> <span class="surname">
      Bucciarelli</span>) qui est l'implémentation Mesa de
      OpenGL qui utilise Glide2 comme dorsal pour rendre les opérations
      graphiques.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2498417"></a>3.5. DRI</h3></div></div><div></div></div><p>Le rendu des graphiques comporte 3 protagonistes :
      l'application cliente (comme <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Quake
      3</i></span></span>™), le serveur X et le matériel (la
      carte graphique). Auparavant, les applications clientes ne pouvaient
      pas écrire directement sur le matériel, et il y avait une bonne
      raison à cela : un programme à qui l'on permet un accès en
      écriture direct sur le matériel peut faire planter le système de
      plusieurs façons. Plutôt que de faire confiance aux programmeurs pour
      écrire des programmes (accédant au matériel) totalement exempts de
      bogues et coopératifs, Linux l'a tout simplement interdit. Néanmoins,
      cela a changé sous <span class="application">XFree</span> 4.x avec
      l'infrastructure de rendu direct (<a href="http://www.dri.sourceforge.net" target="_top">Direct Rendering
      Infrastructure</a>, <span class="acronym">DRI</span>). La DRI autorise les
      clients X à écrire des informations de rendu 3D directement sur la
      carte vidéo d'une manière sûre et coopérative.</p><p>DRI fait abstraction du serveur X afin que le pilote 3D (Mesa
      ou OpenGL) puisse parler directement au matériel. Cela améliore les
      performances. Les informations de rendu 3D ne doivent même pas subir
      d'accélération matérielle. D'un point de vue technique, cela a
      plusieurs avantages :</p><div class="itemizedlist"><ul type="disc"><li><p>Les données associées aux sommets de polygones ne
        doivent pas être codées/décodées via GLX.</p></li><li><p>Les données graphiques ne sont pas envoyées via une
        socket au serveur X.</p></li><li><p>Sur les machines mono-processeur, le CPU ne doit
        pas changer de contexte entre XFree86 et son client pour rendre les
        graphiques.</p></li></ul></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2498508"></a>3.6. GLX</h3></div></div><div></div></div><p>GLX est l'extension X utilisée par les programmes OpenGL ;
      c'est le liant entre l'OpenGL indépendant de la plate-forme, et X
      dépendant de la plate-forme.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2498523"></a>3.7. Utah GLX</h3></div></div><div></div></div><p>Utah-GLX est le précurseur de DRI. Certaines décisions de
      conception sont différentes en ce qui concerne la séparation des
      données et des méthodes d'accès à la carte vidéo, comme le repos sur
      l'accès root plutôt que la création de l'infrastructure noyau
      permettant un accès sécurisé. Il prend en charge quelques cartes qui
      ne sont pas bien gérées par le DRI comme la famille ATI Rage Pro, la
      S3 Virge (bien que quiconque l'utilise pour jouer est pour ainsi dire
      cinglé), et un pilote TNT/TNT2 <span class="foreignphrase"><i class="foreignphrase">open
      source</i></span> (très incomplet). Le pilote TNT/TNT2 est basé
      sur la rétro-ingénierie de la publication du code source obscurci des
      pilotes X 3.3 par nVidia. Néanmoins, ils sont très incomplets et,
      pour tout dire, inutilisables.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="xlib"></a>3.8. xlib</h3></div></div><div></div></div><p>De temps à autre, vous verrez quelques malades (dit avec
      respect) qui écrivent un jeu en xlib. C'est un groupe de
      bibliothèques C qui comportent l'interface de programmation du plus
      bas niveau pour <span class="application">XFree86</span>. Toute
      programmation graphique sous X fait <span class="emphasis"><em>in fine</em></span>
      usage de la bibliothèque xlib.</p><p>Il n'est pas exagéré de dire que xlib est volumineux,
      mystérieux et compliqué. De ce fait, il existe des tas de
      bibliothèques comme <a href="#sdl" title="3.10. SDL (Simple DirectMedia Layer)">SDL</a> pour les
      graphiques 2D, et <a href="#opengl" title="3.3. OpenGL">OpenGL</a> pour les
      graphiques 3D et les jeux d'éléments graphiques (<a href="#widgetset" title="3.9. Widgets"><span class="foreignphrase"><i class="foreignphrase">widgets</i></span></a>)
      pour les éléments graphiques à l'intérieur des fenêtres qui cachent
      les détails de différents aspects de la programmation xlib.</p><p>Bien que quelques jeux soient écrits avec xlib, comme l'éditeur
      Doom Yadex, xlib en lui-même ne peut pas raisonnablement servir de
      bibliothèque d'écriture de jeux. La plupart des jeux n'ont pas besoin
      de l'interface de bas niveau fournie par xlib. De plus, en utilisant
      les bibliothèques de plus haut niveau, un programmeur de jeux peut
      développer son jeu sur plusieurs plates-formes, même celles qui
      n'utilisent pas <span class="application">XFree86</span>.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="widgetset"></a>3.9. <span class="foreignphrase"><i class="foreignphrase">Widgets</i></span></h3></div></div><div></div></div><p>Les éléments graphiques (widgets) sont des objets qui
      constituent l'interface d'une application graphique. Ils incluent des
      choses comme les boîtes d'entrée de texte, les menus déroulants, les
      barres de défilement, les boutons radio et bien d'autres choses. Un
      jeu d'éléments graphiques (widget set) est une collection d'éléments
      graphiques apparentés qui sont conçus pour avoir une interface
      commune et un aspect cohérent. Gtk est le jeu d'éléments graphiques
      canonique sous Linux, mais il y en a beaucoup d'autres comme fltk (de
      petite taille, écrit en C++), Xaw, Qt (le jeu d'éléments graphiques
      de KDE) et Motif (celui utilisé par Netscape). Motif régnait dans le
      monde Unix, mais sa licence d'utilisation était très coûteuse. L'Open
      Group a finalement ouvert la licence de Motif pour les systèmes
      d'exploitation <span class="foreignphrase"><i class="foreignphrase">open source</i></span>, mais
      c'était trop tard. Il y a beaucoup de jeux d'éléments graphiques
      complètement <span class="foreignphrase"><i class="foreignphrase">open source</i></span> qui sont plus
      complets et plus beaux que Motif, y compris Lesstif, un clone
      totalement gratuit de Motif.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="sdl"></a>3.10. SDL (Simple DirectMedia Layer)</h3></div></div><div></div></div><p><a href="http://www.libsdl.org" target="_top">SDL</a> est une
      bibliothèque de <span class="firstname">Sam</span> <span class="surname">
      Lantiga</span> (diplômé de l'UCD !). C'est en
      fait une méta-bibliothèque, c.-à-d. que ce n'est pas seulement une
      bibliothèque graphique qui cache les détails de la programmation
      xlib, mais c'est aussi une interface simple d'utilisation pour le
      traitement du son, de la musique et des événements. Sa licence est la
      LGPL et elle prend également en charge les joysticks et OpenGL. À la
      différence de <a href="#xlib" title="3.8. xlib">xlib</a>, SDL convient fort
      bien à la programmation de jeux.</p><p>Le plus impressionnant dans SDL est son caractère
      multi-plates-formes. Mis à part quelques détails, un programme écrit
      en SDL compilera sous Linux, MS Windows, BeOS, MacOS, MacOS X,
      Solaris, IRIX, FreeBSD, QNX et OSF. Il existe diverses extensions
      permettant de manipuler à peu près tous les formats graphiques, lire
      des vidéos MPEG, afficher des polices
      <span class="foreignphrase"><i class="foreignphrase">truetype</i></span>, gérer les acteurs
      (<span class="foreignphrase"><i class="foreignphrase">sprites</i></span>) et à peu près tout ce qui
      est imaginable. SDL est un exemple de ce à quoi toutes les
      bibliothèques graphiques devraient aspirer. </p><p>Sam avait une motivation cachée pour l'écriture d'une si
      chouette bibliothèque : il était le programmeur en chef de Loki
      Software (il code maintenant pour Blizzard Software), qui utilisait
      SDL dans tous ses jeux sauf
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Quake3</i></span></span>™.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="ggi"></a>3.11. GGI</h3></div></div><div></div></div><p><a href="http://www.ggi-project.org" target="_top">GGI</a> est un
      projet qui vise à implémenter une couche d'abstraction graphique dans
      du code de bas niveau, de placer la prise en charge du matériel
      graphique dans une base de code commune, et d'apporter une plus
      grande stabilité et portabilité aux applications graphiques. Les
      applications LibGGI tournent entre autres sous SVGAlib, fb et X. Si
      l'on en juge à leurs captures d'écran, c'est une bibliothèque assez
      puissante.</p><p>Les applications qui utilisent LibGGI directement comportent
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Heroes</i></span></span>™,
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Ultrapoint</i></span></span>™,
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Quake</i></span></span>™ et
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Berlin</i></span></span>™. La
      plupart des applications qui utilisent SVGALib peuvent être exécutées
      sous X ou sous n'importe quel autre dorsal LibGGI en utilisant une
      bibliothèque enveloppe qui réimplémente <a href="#svgalib" title="3.12. SVGAlib, framebuffer et console">SVGALib</a> en utilisant LibGGI. Les
      applications <a href="#sdl" title="3.10. SDL (Simple DirectMedia Layer)">SDL</a> et <a href="#clanlib" title="3.15. Clanlib">clanlib</a> peuvent s'afficher avec LibGGI mais
      les pilotes natifs de ces bibliothèques sont généralement plus
      rapides ; néanmoins, c'est un bon moyen pour que des
      applications SDL, clanlib et SVGALib s'exécutent là où elles
      n'auraient pas pu le faire auparavant.</p><p>GGI a un projet sœur, KGI, qui développe une alternative
      de niveau noyau aux systèmes du type
      <span class="foreignphrase"><i class="foreignphrase">framebuffer</i></span> linux et DRI. Ce projet
      est beaucoup moins avancé que LibGGI lui-même, mais promet de
      combiner les vitesses de niveau DRI à la stabilité et à la sécurité
      auxquelles aspirent les utilisateurs UNIX.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="svgalib"></a>3.12. SVGAlib, framebuffer et console</h3></div></div><div></div></div><p>La console est l'écran noir non graphique que vous voyez
      lorsque votre ordinateur démarre pour la première fois (et qu'aucune
      application du genre <span class="application">xdm</span> ou
      <span class="application">gdm</span> ne tourne). C'est différent de
      l'environnement X qui comporte toutes sortes d'éléments graphiques
      comme les <span class="application">xterm</span>. Une idée fausse fort
      répandue est de croire que X signifie
      « <span class="quote">graphique</span> » et que console signifie
      « <span class="quote">non graphique</span> ». Il peut assurément y avoir
      des graphiques en mode console ; nous discuterons des deux
      manières les plus habituelles de procéder.</p><p>SVGAlib est une bibliothèque graphique qui vous permet de
      dessiner des graphiques sur la console. Il existe beaucoup
      d'applications graphiques et de jeux utilisant SVGAlib comme
      <span class="application">zgv</span> (un visualisateur d'images en mode
      console), <span class="application">prboom</span> et
      <span class="application">hhexen</span>. J'apprécie cette bibliothèque et
      les jeux graphiques en mode console en général : ils sont
      extrêmement rapides, plein écran et captivants. SVGAlib souffre de
      trois défauts. Primo, les exécutables SVGAlib doivent être lancés par
      root ou être setuid-root (néanmoins, la bibliothèque abandonne les
      privilèges root immédiatement après le début de l'exécution).
      Secundo, SVGAlib est dépendant de la carte vidéo :  si votre
      carte vidéo n'est pas prise en charge par SVGAlib, c'est pas de
      chance. Tertio, SVGAlib est spécifique à Linux :  les jeux
      écrits en SVGAlib ne fonctionneront <span class="emphasis"><em>que</em></span> sous
      Linux.</p><p>Les <span class="foreignphrase"><i class="foreignphrase">framebuffers</i></span> sont des
      consoles implémentées par un mode graphique plutôt qu'un mode texte
      du BIOS. Pourquoi simuler un mode texte dans un environnement
      graphique ? Cela permet d'exécuter des applications graphiques
      en console, comme p.ex. de choisir la police affichée en console (qui
      est normalement fixée par le BIOS). On peut trouver un bon
      « <span class="quote">Guide pratique du frame-buffer</span> » (<a href="http://www.traduc.org/docs/howto/lecture/Framebuffer-HOWTO.html" target="_top"><span class="foreignphrase"><i class="foreignphrase">Framebuffer-HOWTO</i></span></a>)
      sur le LDP. Les jeux en console graphique écrits en utilisant le
      framebuffer souffrent des mêmes problèmes que ceux utilisant
      SVGAlib : le support matériel est limité, et le code ne
      fonctionnera que sous Linux.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="openal"></a>3.13. OpenAL</h3></div></div><div></div></div><p><a href="http://www.openal.org" target="_top">OpenAL</a> a pour
      objectif d'être au son ce que OpenGL est aux graphiques. Développé
      conjointement par Loki Software et Creative Labs, elle a pour but
      d'être une API neutre et multi-plates-formes pour le son. Sa licence
      est la LGPL et les spécifications peuvent être obtenues gratuitement
      depuis le site web de OpenAL. OpenAL est entièrement fonctionnel,
      mais depuis que Loki Software n'existe plus, son développement futur
      est incertain.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="directx"></a>3.14. DirectX</h3></div></div><div></div></div><p>DirectX est une collection d'API multimédia propriétaires,
      développée à l'origine par Microsoft en 1995, pour ses différents
      systèmes d'exploitation Windows. C'est une erreur de prétendre que
      « <span class="quote">DirectX est similaire à OpenGL</span> » ou
      « <span class="quote">DirectX est similaire à SDL</span> », comme il est
      souvent dit dans les didacticiels DirectX. Les API multimédia sont
      plus centralisées sous Windows qu'elles ne le sont sous Linux. Une
      formulation plus précise serait : « <span class="quote">DirectX est
      similaire à DRI, OpenGL et SDL combinés</span> ». En juin 2003,
      la version la plus récente de DirectX était la 9.0. Les composants de
      DirectX sont : </p><div class="variablelist"><dl><dt><span class="term">DirectDraw</span></dt><dd><p>DirectDraw
          fournit un accès direct à la mémoire vidéo, comme DRI, de sorte
          que les graphiques 2D peuvent être placés directement sur la
          carte vidéo. DirectDraw est similaire au composant graphique de
          SDL, mais l'accès direct à la carte vidéo est effectué par DRI
          plutôt que par SDL. C'est pourquoi un jeu peut facilement faire
          tomber un système Windows mais ne devrait pas le faire avec un
          système Linux.</p></dd><dt><span class="term">Direct3D (D3D)</span></dt><dd><p>Direct3D,
          comme OpenGL, fournit une API graphique 3D. Alors qu'OpenGL est
          <span class="foreignphrase"><i class="foreignphrase">open source</i></span>, de plus bas niveau et
          compile sous une multitude de systèmes d'exploitation, D3D est
          propriétaire, de plus haut niveau et ne compile que sous Windows.
          D3D est d'abord apparu dans DirectX 2, en
          1996.</p></dd><dt><span class="term">DirectXAudio</span></dt><dd><p>Direct Audio est une combinaison de deux API
          audio, DirectSound et DirectMusic, qui offrent un accès direct à
          la carte son pour jouer du son et de la
          musique.</p></dd><dt><span class="term">DirectInput</span></dt><dd><p>DirectInput permet l'utilisation de périphériques
          d'entrée de jeu comme les
          joysticks.</p></dd><dt><span class="term">DirectPlay</span></dt><dd><p>DirectPlay offre une gestion réseau
          simplifiée pour les jeux multi-joueurs.</p></dd><dt><span class="term">DirectShow</span></dt><dd><p>DirectShow prend en charge les fichiers vidéo
          comme <tt class="filename">AVI</tt> et <tt class="filename">MPG</tt>. C'était une API distincte de
          DirectX, mais elle a été intégrée dans DirectX
          8.</p></dd><dt><span class="term">DirectSetup</span></dt><dd><p>Cette API
          facilite l'installation de DirectX à partir d'une application
          pour simplifier l'installation des
          jeux.</p></dd></dl></div><p>DirectX est un peu pris en charge par <a href="#winex" title="10.5.3. winex"><span class="application">winex</span></a>, l'est mal
      par <a href="#wine" title="10.5.1. wine"><span class="application">wine</span></a>,
      l'est à peine par <a href="#vmware" title="10.5.5. VMWare"><span class="application">vmware</span></a> et ne l'est
      pas du tout par <a href="#win4lin" title="10.5.4. Win4Lin"><span class="application">Win4Lin</span></a>.</p><p>Remarque sur la portabilité : pour chaque composant de DirectX,
      on peut trouver plusieurs bibliothèques correspondantes sous Linux.
      Mieux encore, un programmeur de jeux qui utilise des bibliothèques
      comme OpenGL, GGI ou SDL écrira un jeu qui compilera trivialement
      sous Windows, Linux et une multitude d'autres systèmes
      d'exploitation. Pourtant, les sociétés productrices de jeux
      persistent à utiliser DirectX et limitent de ce fait leur public aux
      seuls utilisateurs Windows. Si vous écrivez des jeux, veuillez
      envisager l'utilisation de bibliothèques multi-plates-formes et
      rester éloigné de DirectX.</p><p>Une société nommée realtechVR a démarré un projet
      <span class="foreignphrase"><i class="foreignphrase">open source</i></span>, <a href="http://www.v3x.net/directx" target="_top">DirectX Port</a> qui, comme
      <span class="application">wine</span>, fournit une couche d'émulation de
      Direct3D qui implémente les appels Direct3D. Le projet se concentrait
      sur la plate-forme BeOS, mais l'est maintenant sur MacOS et Linux.
      Vous pouvez récupérer la toute dernière mouture depuis leur
      référentiel CVS sur &lt;<a href="http://sourceforge.net/projects/dxglwrap" target="_top">http://sourceforge.net/projects/dxglwrap</a>&gt;.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="clanlib"></a>3.15. Clanlib</h3></div></div><div></div></div><p>ClanLib est un kit d'outils de développement de niveau
      intermédiaire. Au plus bas niveau, il fournit des outils indépendants
      de la plate-forme (dans la limite du possible en C++) de gestion de
      l'affichage, du son, des entrées, du réseau, des fichiers, des
      threads, et cætera. ClanLib construit un cadre générique de développement
      de jeu, vous offrant une gestion aisée des ressources, une
      réplication des objets sur le réseau, des interfaces utilisateur
      graphiques (GUI) autorisant les thèmes, les langages de scripts dans
      les jeux et plus encore.</p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2499398"></a>4. <span class="application">XFree86</span> et vous</h2></div></div><div></div></div><p>Si vous avez l'intention de jouer sous X, il est primordial que
    vous le connaissiez quelque peu. Le « <span class="quote">Guide pratique de
    l'utilisateur de X Window</span> » (<a href="http://www.traduc.org/docs/howto/lecture/XWindow-User-HOWTO.html" target="_top"><span class="foreignphrase"><i class="foreignphrase">XWindow-User-HOWTO</i></span></a>),
    et en particulier <b class="userinput"><tt>man XF86Config</tt></b>
    constituent des lectures <span class="emphasis"><em>requises</em></span>. N'essayez pas
    d'y échapper : lisez-les. Elles ont un très bon rapport
    signal/bruit. Beaucoup de problèmes peuvent être résolus facilement si
    vous savez vous y retrouver dans <tt class="filename">XF86Config</tt> (ou
    <tt class="filename">XF86Config-4</tt>).</p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2499454"></a>4.1. Recueillir des informations sur votre système X</h3></div></div><div></div></div><p>Que vous essayiez de diagnostiquer un problème X ou que vous
      requerriez de l'aide sur une liste de diffusion ou un groupe de
      discussion Usenet, vous devrez disposer d'un maximum d'informations.
      Voici quelques outils qui peuvent vous y aider :</p><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2499467"></a>4.1.1. <span><b class="command">probeonly</b></span></h4></div></div><div></div></div><p>La sortie de <span><b class="command">probeonly</b></span> constitue l'un des
        meilleurs outils de diagnostic et l'une des meilleures sources
        d'informations sur votre système. Pour l'utiliser, arrêtez X le cas
        échéant et tapez depuis une console :</p><pre class="screen">
    X -probeonly 2&gt; X.out
          </pre><p>La sortie de X va sur stderr, et il faut donc rediriger
        stderr avec « <span class="quote">2&gt;</span> » dans un fichier nommé
        <tt class="filename">X.out</tt>. Ce fichier contiendra tout ce qu'il y a
        à savoir sur votre système X. Il est crucial que vous connaissiez
        la différence entre les différentes marques que vous pourrez
        rencontrer dans la sortie de
        <span><b class="command">probeonly</b></span> :</p><pre class="screen">
    (--) probed              (**) from config file    (==) default setting
    (++) from command line   (!!) notice              (II) informational
    (WW) warning             (EE) error               (??) unknown.
          </pre><p>Voici un exemple de quelques informations que j'ai pu
        glaner :</p><p>J'utilise des couleurs 16 bits :</p><pre class="screen">
    (**) TDFX(0): Depth 16, (--) framebuffer bpp 16
          </pre><p>X a détecté que la puce et la mémoire RAM de ma carte vidéo
        sont :</p><pre class="screen">
    (--) Chipset 3dfx Voodoo5 found
    (--) TDFX(0): VideoRAM: 32768 kByte Mapping 65536 kByte
          </pre></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2499566"></a>4.1.2. Obtenir des informations sur votre configuration :
      <span><b class="command">xvidtune</b></span></h4></div></div><div></div></div><p><span><b class="command">xvidtune</b></span> est votre ami si votre écran X
        est un peu trop décalé sur la droite, ou si la hauteur est trop
        réduite pour remplir votre écran. Néanmoins, c'est également un
        très bon outil de diagnostic. Il affiche :</p><div class="itemizedlist"><ul type="disc"><li><p>l'intervalle <span class="hardware">hsync/vsync</span>
          (valeurs de synchronisation horizontale et verticale
          respectivement) spécifié dans votre fichier
          <tt class="filename">XF86Config</tt>.</p></li><li><p>les 4 nombres horizontaux et les 4 nombres
          verticaux qui définissent votre mode vidéo (le premier couple
          horizontal/vertical indique la résolution de l'écran). Ces 8
          nombres vous indiqueront quelle ligne de mode
          (<span class="foreignphrase"><i class="foreignphrase">modeline</i></span>) votre X utilise. Voyez
          le « <span class="quote">Guide pratique de configuration vidéo de
          XFree86</span> » (<a href="http://www.traduc.org/docs/howto/lecture/XWindow-User-HOWTO.html" target="_top"><span class="foreignphrase"><i class="foreignphrase">XFree86-Video-Timings-HOWTO</i></span></a>)
          pour plus d'informations. Notez que des spécifications explicites
          ne sont plus nécessaires, car XFree 4.0.1 (et les versions
          ultérieures) les calcule automatiquement à partir des
          possibilités de votre moniteur et de votre carte vidéo.
          Néanmoins, c'est parfois utile en cas de matériel exotique ou si
          vous voulez un peu bidouiller votre affichage.</p></li><li><p>La « <span class="quote">fréquence d'horloge</span> »
          à laquelle tourne votre carte vidéo.</p></li></ul></div></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2499665"></a>4.1.3. Obtenir des informations sur votre configuration :
      <span><b class="command">xwininfo</b></span></h4></div></div><div></div></div><p><span><b class="command">xwininfo</b></span> vous indique toutes sortes
        d'informations sur les fenêtres X. L'arrière-plan est également
        assimilé à une fenêtre. Ainsi, quand il vous demande de cliquer sur
        la fenêtre pour laquelle vous désirez des informations, cliquez sur
        votre arrière-plan. Il vous indique entre autres la résolution de
        l'écran et de la fenêtre, le nombre de couleurs (NdT : plus
        précisément, le nombre de bits utilisés pour les représenter),
        l'état de gravité de la fenêtre (qui donne une indication au
        gestionnaire de fenêtres sur l'endroit où placer les nouvelles
        fenêtres) et l'utilisation du cache d'affichage
        (<span class="foreignphrase"><i class="foreignphrase">backing store</i></span>).</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2499686"></a>4.1.4. Autres sources d'information</h4></div></div><div></div></div><p><span><b class="command">xdpyinfo</b></span> vous donne des informations
        intéressantes, comme la version de X et les extensions chargées
        (inestimable quand vous essayez de voir ce qui manque, comme GLX,
        DRI, XFree86-VidMode, et cætera).</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2499732"></a>4.1.5. Obtenir des informations sur votre système 3D</h4></div></div><div></div></div><p><span><b class="command">glxinfo</b></span> donne des tas d'informations
        utiles sur OpenGL comme l'utilisation ou non du rendu direct, les
        versions de glx et mesa actuellement installées, les chaînes de
        vendeur/moteur de rendu, les fichiers de bibliothèque GL utilisés,
        et cætera.</p></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="nowm"></a>4.2. Jouer à des jeux sous X sans gestionnaire de
    fenêtres</h3></div></div><div></div></div><p>
        Quand vous jouez à un jeu sous X, vous devriez envisager de ne pas
        utiliser de gestionnaire de fenêtres. Des « <span class="quote">poids
        lourds</span> » comme enlightenment produiront un
        ralentissement perceptible ; même des plus légers comme twm
        vous volent des cycles processeur (et dans le cas de twm, même les
        jeux plein écran auront un cadre autour de leur fenêtre). Pour
        exécuter un jeu sans gestionnaire de fenêtres, modifiez
        <tt class="filename">.xinitrc</tt> dans votre répertoire personnel.
        Voici à quoi ressemble mon
        <tt class="filename">.xinitrc</tt> :</p><pre class="screen">
        #quake3 +set r_gldriver libGR.so.1
        #exec ut
        #lsdldoom -server 2
        #exec tribes2
        exec /usr/bin/enlightenment
      </pre><p>Vous y remarquerez généralement un gestionnaire de fenêtres
      et/ou de bureau (GNOME ou KDE). Commentez les lignes contenant un
      gestionnaire de fenêtres et/ou de bureau avec un signe dièse (#) et
      placez votre jeu sur une nouvelle ligne accompagné des arguments de
      ligne de commandes éventuels. Si votre jeu n'est pas situé dans votre
      <tt class="envar">$PATH</tt>, donnez le nom de chemin complet. Notez que ceci
      ne s'applique qu'aux personnes utilisant <span><b class="command">startx</b></span>
      pour démarrer X.</p><p>Je n'utilise jamais des choses comme <span><b class="command">gdm</b></span> ou
      le niveau d'exécution 5 (je ne suis donc pas sûr de mon fait), mais
      je suspecte que si vous le faites, vous devrez agir un peu
      différemment. Ma recommandation est d'aller en mode mono-utilisateur
      (niveau d'exécution 1) avec :</p><pre class="screen">
    # telinit 1
    </pre><p>ensuite d'éditer <tt class="filename">.xinitrc</tt>, et de revenir
       au niveau 5 avec</p><pre class="screen">
      # telinit 5
      </pre><p>Ensuite, quand vous arrêtez de jouer, allez au niveau 1,
      modifiez <tt class="filename">.xinitrc</tt> et revenez au niveau 5. Je
      n'ai jamais expérimenté cela, et je ne peut donc pas me prononcer
      avec certitude, mais vous pourriez devoir tuer
      <span class="application">gdm</span>. J'apprécierai du retour à ce
      sujet.</p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2499900"></a>5. Divers</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="mtrr"></a>5.1. <span class="hardware">Registres d'intervalles
    mémoire</span></h3></div></div><div></div></div><p>À partir des processeurs de classe Pentium (y compris Athlon,
      K6-2 et d'autres CPU), ces registres (Memory Type Range Registers,
      MTRR) contrôlent la façon dont le processeur accède aux intervalles
      d'adresses mémoire. Pour résumer, ce mécanisme remplace plusieurs
      petites écritures séparées sur la carte vidéo par une seule écriture
      (une rafale). Cela améliore l'efficacité des écritures sur la carte
      vidéo et peut accélérer le rendu graphique de 250 % voire
      plus !</p><p>Voyez
      <tt class="filename">/usr/src/linux/Documentation/mtrr.txt</tt> pour les
      détails. Notez que, depuis que ce fichier a été écrit,
      <span class="application">XFree86</span> a été amélioré pour détecter
      automatiquement l'adresse de base et la taille de votre RAM vidéo et
      configurer les MTRR.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="milkingperformance"></a>5.2. Exploiter au maximum les
    ressources de votre système</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li><p>Si pour une raison quelconque, vous utilisez X 3.3,
        suivez les instructions données dans <tt class="filename">mtrr.txt</tt>
        (voyez la <a href="#mtrr" title="5.1. Registres d'intervalles
    mémoire">Section 5.1, « Registres d'intervalles
    mémoire »</a>) pour configurer les MTRR.
        X 4.0 fait cela automatiquement pour vous.</p></li><li><p>Si vous jouez sous X, n'exécutez pas de gestionnaire de
     fenêtres, et <span class="emphasis"><em>certainement pas</em></span> de
     gestionnaire de bureau comme GNOME ou KDE. Voyez la <a href="#nowm" title="4.2. Jouer à des jeux sous X sans gestionnaire de
    fenêtres">Section 4.2, « Jouer à des jeux sous X sans gestionnaire de
    fenêtres »</a> pour plus de détails.</p><p>Arrêtez tous les processus non essentiels (en tant que
     root) en utilisant les scripts de démarrage de votre système.
     Sous Debian, les scripts de démarrage pour le niveau d'exécution
     2 sont situés dans <tt class="filename">/etc/rc2.d/</tt>. Vous pouvez arrêter un
     service d'une manière ordonnée en envoyant à son script de
     démarrage la commande
     « <span class="quote">stop</span> » :</p><pre class="screen">
    # cd /etc/rc2.d
    # ./ntpd stop
    </pre><p>Une autre possibilité (radicale) est de simplement vous
          placer en mode mono-utilisateur avec</p><pre class="screen">
    # telinit 1
    </pre><p>Cela vous débarrassera même de
     <span><b class="command">getty</b></span> ; votre système s'exécutera avec
     uniquement ce qui est absolument crucial pour son fonctionnement.
     Il y aura quelque chose comme 10 processus en cours d'exécution.
     L'inconvénient est que vous devez jouer en tant que root. Mais
     votre table de processus sera une ville fantôme, et tous les
     cycles CPU supplémentaires bénéficieront à votre
     jeu.</p></li></ul></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2500077"></a>5.3. À propos des bibliothèques sous Linux</h3></div></div><div></div></div><p>Un problème souvent rencontré est un fichier de bibliothèque
      non trouvé. Ils sont quelque peu mystérieux et ont des noms
      bizarres ; nous en parlerons donc un peu. Il y a deux types de
      bibliothèques, les statiques et les dynamiques. Quand vous compilez
      un programme, <span><b class="command">gcc</b></span> utilise par défaut les
      bibliothèques dynamiques, mais vous pouvez lui faire utiliser des
      bibliothèques statiques en utilisant l'option
      <tt class="option">-static</tt>. À moins que vous n'ayez l'intention de
      compiler des jeux à partir du code source, vous serez principalement
      intéressés par les bibliothèques dynamiques.</p><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2500116"></a>5.3.1. Bibliothèques dynamiques</h4></div></div><div></div></div><p>Les bibliothèques dynamiques, aussi appelées
   « <span class="quote">bibliothèques partagées</span> », fournissent du
   code objet à une application alors qu'elle s'exécute, c.-à-d. que
   le code est lié à l'exécutable au moment de l'exécution, et non à
   celui de la compilation. Elles sont analogues aux <tt class="filename">.dll</tt> utilisées sous Windows. Le
   programme responsable de la liaison du code « <span class="quote">au
   vol</span> » est appelé <span><b class="command">/etc/ld.so</b></span>, et les
   bibliothèques dynamiques elles-mêmes se terminent habituellement
   par <tt class="filename">.so</tt> avec un numéro de
   version, comme :</p><pre class="screen">
    /usr/lib/libSDL.so
    /lib/libm.so.3
      </pre><p>Quand vous utilisez <span><b class="command">gcc</b></span>, vous référencez
   ces bibliothèques en enlevant les chaînes de caractères
   <tt class="literal">lib</tt>, <tt class="literal">.so</tt> et tous les numéros
   de version. Donc, pour utiliser ces deux bibliothèques, vous
   devriez passer les options <tt class="literal">-lSDL -lm</tt> à
   <span><b class="command">gcc</b></span>. Celui-ci placera alors une marque dans
   l'exécutable indiquant d'examiner les fichiers <tt class="filename">/usr/lib/libSDL.so</tt> et <tt class="filename">/lib/libm.so.3</tt> à chaque fois qu'une
   fonction SDL ou une fonction mathématique est utilisée.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2500238"></a>5.3.2. Bibliothèques statiques</h4></div></div><div></div></div><p>Contrairement aux bibliothèques statiques qui fournissent du
        code alors que l'application s'exécute, les bibliothèques statiques
        contiennent du code qui est lié (inséré) dans le programme lors de
        sa compilation. Aucun code n'est inséré au moment de
        l'exécution : le code est complètement autonome. Les
        bibliothèques statiques se terminent habituellement par <tt class="filename">.a</tt> suivi d'un numéro de version,
        comme :</p><pre class="screen">
    /usr/lib/libSDL.a
    /usr/lib/libm.a
      </pre><p>Les fichiers <tt class="filename">.a</tt>
        forment réellement des archives de fichiers <tt class="filename">.o</tt> (objet), à la manière d'un fichier
        tar. Vous pouvez utiliser <span><b class="command">nm</b></span> pour lister les
        fonctions contenues dans une bibliothèque statique :</p><pre class="screen">
    % nm /usr/lib/libm.a
    ...
    e_atan2.o:
    00000000 T __ieee754_atan2
    
    e_atanh.o:
    00000000 T __ieee754_atanh
    00000000 r half
    00000010 r limit
    00000018 r ln2_2
    ...
      </pre><p>Quand vous utilisez <span><b class="command">gcc</b></span>, vous référencez ces
      bibliothèques en enlevant les chaînes de caractères
      « <span class="quote">lib</span> », « <span class="quote">.a</span> » et tous
      les numéros de version. Donc, pour utiliser ces deux bibliothèques,
      vous devriez passer les options <tt class="option">-lSDL -lm</tt> à
      <span><b class="command">gcc</b></span>. Celui-ci importera alors du code de <tt class="filename">/usr/lib/SDL.a</tt> et <tt class="filename">/usr/lib/libm.a</tt> à chaque fois qu'il
      rencontre une fonction mathématique lors du processus de
      compilation.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2500372"></a>5.3.3. Localisation des fichiers de bibliothèques</h4></div></div><div></div></div><p>Si vous compilez vos propres jeux, le problème principal avec
   les bibliothèques sera soit que <span><b class="command">gcc</b></span> ne trouve
   pas une bibliothèque statique, soit que la bibliothèque n'est pas
   présente sur votre système. Quand vous jouez à des jeux à partir du
   binaire, le problème sera soit que <span><b class="command">ld.so</b></span> ne
   trouve pas la bibliothèque, soit que la bibliothèque n'est pas
   présente sur votre système. Il est donc opportun de d'abord parler
   de la façon dont <span><b class="command">gcc</b></span> et <span><b class="command">ld.so</b></span>
   s'y prennent pour trouver les bibliothèques.</p><p><span><b class="command">gcc</b></span> recherche les bibliothèques dans les
        « <span class="quote">répertoires système standard</span> » ainsi que
        dans ceux spécifiés avec l'option <tt class="option">-L</tt>. Vous pouvez
        déterminer la liste des répertoires système standard avec
        <b class="userinput"><tt>gcc -print-search-dirs</tt></b>.</p><p><span><b class="command">ld.so</b></span> examine un condensé binaire contenu
   dans un fichier nommé <tt class="filename">/etc/ld.so.cache</tt> pour y
   trouver une liste de répertoires contenant les bibliothèques
   dynamiques disponibles. Puisqu'il contient des données binaires,
   vous ne pouvez pas modifier directement ce fichier. Néanmoins, le
   fichier est généré à partir d'un fichier texte
   <tt class="filename">/etc/ld.so.conf</tt> que vous pouvez éditer. Ce
   fichier contient la liste des répertoires où
   <span><b class="command">ld.so</b></span> doit rechercher les bibliothèques
   dynamiques. Si vous voulez ajouter des bibliothèques dynamiques
   dans <tt class="filename">/home/joecool/privatelibs</tt>, il faut
   ajouter ce répertoire dans <tt class="filename">/etc/ld.so.conf</tt>.
   Votre modification n'est prise en compte dans
   <tt class="filename">/etc/ld.so.cache</tt> qu'après avoir exécuté
   <span><b class="command">ldconfig</b></span> ; une fois fait,
   <span><b class="command">ld.so</b></span> commencera à rechercher des bibliothèques
   dans votre répertoire privé.</p><p>De plus, même si vous ne faites qu'ajouter de nouvelles
   bibliothèques à votre système, vous devez mettre à jour
   <tt class="filename">ld.so.cache</tt> pour qu'il reflète la présence des
   nouvelles bibliothèques.</p></div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2500547"></a>6. Quand de mauvaises choses arrivent à de bonnes gens</h2></div></div><div></div></div><p>Bien sûr, il n'est pas possible de recouvrir tous les types de
    problèmes, mais je vais souligner certains points de bon sens.</p><p>Il y a deux types de problèmes : les aléatoires et les
    reproductibles. Il est difficile de diagnostiquer ou de corriger des
    problèmes aléatoires sur lesquels vous n'avez par définition aucun
    contrôle. Néanmoins, si le problème est reproductible (ex :
    « <span class="quote">cela se produit quand j'appuie deux fois sur la flèche
    gauche</span> »), alors vous pouvez agir.</p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2500576"></a>6.1. RTFM !</h3></div></div><div></div></div><p>Relis ton fameux manuel. Le
      « <span class="quote">manuel</span> » peut revêtir plusieurs formes.
      Pour les jeux <span class="foreignphrase"><i class="foreignphrase">open source</i></span>, on
      peut trouver les fichiers <tt class="filename">readme</tt>
      (« <span class="quote">lisez-moi</span> »). Les jeux commerciaux sont
      accompagnés d'un manuel imprimé et éventuellement de quelques
      fichiers <tt class="filename">readme</tt> sur le CD. N'oubliez pas
      d'explorer le CD de votre jeu pour obtenir des astuces et des
      conseils utiles.</p><p>N'oubliez pas le site web du jeu. Son auteur a
      probablement déjà eu affaire à maintes reprises à des personnes
      ayant exactement le même problème que vous, et il pourrait avoir
      placé des informations spécifiques à ce jeu sur son site web. Un
      bon exemple : les FAQ en ligne de Loki Software situées sur
      <a href="http://faqs.lokigames.com" target="_top">http://faqs.lokigames.com</a>.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2500622"></a>6.2. Recherchez des mises à jour et des correctifs</h3></div></div><div></div></div><p>Si vous jouez à un jeu <span class="foreignphrase"><i class="foreignphrase">open
      source</i></span> que vous avez compilé, assurez-vous de
      disposer de la version la plus récente en visitant le site web du
      jeu. Si votre jeu fait partie d'une distribution, assurez-vous qu'il
      n'y ait pas de paquet rpm/deb plus à jour pour le jeu.</p><p>Les sociétés produisant des jeux commerciaux comme Loki
      publient des correctifs pour leurs jeux (souvent nombreux, p.ex.
      pour
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Myth2</i></span></span>™),
      et certains sont même injouables en leur absence
      (<span class="productname"><span class="foreignphrase"><i class="foreignphrase">Heretic2</i></span></span>™).
      Recherchez des correctifs sur le site web du jeu que vous ayez
      un problème avec le jeu ou pas ; il peut y avoir une mise à
      jour pour un problème de sécurité dont vous pourriez ne pas
      avoir eu connaissance.</p><p>À propos, Loki propose maintenant un utilitaire qui recherche
      les logiciels Loki sur votre disque dur et les met à jour
      automatiquement. Consultez <a href="http://updates.lokigames.com" target="_top">http://updates.lokigames.com</a>.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2500702"></a>6.3. Groupes de discussion</h3></div></div><div></div></div><p>Si vous ne savez pas ce que sont les News (Usenet), alors ça
      vaut la peine de prendre 30 minutes pour vous y frotter. Installez un
      lecteur de News. Je préfère les outils en console, et j'utilise donc
      <span class="application">tin</span>, mais <span class="application">slrn</span>
      est également populaire. Netscape propose également un chouette
      lecteur de News graphique piloté à la souris.</p><p>Par exemple, je peux me promener sur le serveur de News de Loki
      Software avec <b class="userinput"><tt>tin -g news.lokigames.com</tt></b>. Vous
      pouvez également spécifier quel serveur de News utiliser grâce à la
      variable d'environnement <tt class="envar">$NNTP</tt> ou le fichier
      <tt class="filename">/etc/nntpserver</tt>.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2500758"></a>6.4. Recherche sur Google Groupes</h3></div></div><div></div></div><p>Chaque soumission faite sur Usenet est archivée dans la base de
      données de Google sur <a href="http://groups.google.fr" target="_top">http://groups.google.fr</a>.
      Cette archive était située sur <a href="http://www.deja.com" target="_top">http://www.deja.com</a>, mais a été rachetée par Google.
      Beaucoup de personnes parlent toujours de
      « <span class="quote">deja</span> ».</p><p>Il est presque sûr que quel que soit le problème que vous
      avez avec Linux, qu'il ait ou pas un rapport avec le jeu, il a
      déjà été reporté et solutionné sur Usenet, pas une, pas deux,
      mais de nombreuses fois. Si vous ne comprenez pas la première
      réponse que vous voyez (ou si elle ne fonctionne pas), essayez
      l'une des suivantes. Si la page n'est pas dans une langue que
      vous comprenez, il existe des tas de sites de traduction qui
      convertiront le texte dans la langue que vous préférez, comme
      <a href="http://www.freetranslation.com" target="_top">http://www.freetranslation.com</a> et <a href="http://translation.lycos.com" target="_top">http://translation.lycos.com</a>. Mon navigateur web
      préféré,
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Opera</i></span></span>™
      (disponible sur <a href="http://www.opera.com" target="_top">http://www.opera.com</a>) vous
      permet d'utiliser le bouton droit de la souris pour sélectionner
      un extrait de texte, et de cliquer avec le bouton gauche sur la
      sélection pour le traduire. Très utile quand une recherche sur
      Google Groupes renvoie une page en allemand qui semble utile et
      que ma petite amie (qui lit bien l'allemand) n'est pas
      disponible.</p><p>La recherche sur Google Groupes propose une page de recherche
      élémentaire et avancée. Ne perdez pas de temps avec la recherche
      simple. La recherche avancée est située sur <a href="http://groups.google.com/advanced_group_search" target="_top">http://groups.google.com/advanced_group_search</a>.</p><p>C'est facile à utiliser. Par exemple, si mon problème est que
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Quake III</i></span></span>™
      plante à chaque fois que Lucy saute, j'entre « <span class="quote">linux
      quake3 crash lucy saute</span> » dans la boîte de texte
      « <span class="quote">Retrouver les messages avec tous les mots
      suivants</span> ».</p><p>Certains champs permettent de limiter la portée de votre
      recherche à un groupe de discussion. Prenez le temps de lire et de
      comprendre la signification de chaque champ. Je vous le
      promets : ce service ne vous décevra pas. Utilisez-le, et vous
      serez quelqu'un de beaucoup plus heureux. Notez bien que les groupes
      de discussion privés ne sont pas archivés, comme le serveur de News
      de Loki Software. Néanmoins, vu que beaucoup de personnes utilisent
      Usenet, cela n'a généralement que peu d'importance.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2500879"></a>6.5. Débogage : traces d'appel et fichiers core</h3></div></div><div></div></div><p>Ce n'est généralement pas quelque chose que vous ferez pour les
      jeux commerciaux. Pour les jeux <span class="foreignphrase"><i class="foreignphrase">open
      source</i></span>, vous pouvez aider l'auteur en lui fournissant
      un fichier core ou une trace de la pile. En bref, un fichier core
      (dit « <span class="quote">core dump</span> ») est un fichier qui conserve
      l'état du programme au moment où il s'est crashé. Il contient des
      indices précieux pour le programmeur relatifs à la nature du
      crash : ce qui l'a causé et ce que le programme faisait quand il
      s'est produit. Si vous voulez en savoir plus sur les fichiers core,
      j'ai un super tutoriel <span class="application">gdb</span> disponible sur
      <a href="http://www.dirac.org/linux" target="_top">http://www.dirac.org/linux</a>.</p><p>En <span class="emphasis"><em>dernier</em></span> recours, l'auteur sera
      intéressé par la pile d'appels au moment du plantage du jeu. Voici
      comment procéder :</p><p>Il arrive que les distributions configurent leur système
      d'exploitation en sorte que les fichiers core (qui sont
      principalement utiles aux programmeurs) ne sont pas générés. La
      première étape est d'autoriser votre système à générer des fichiers
      core de taille illimitée :</p><pre class="screen">
    ulimit -c unlimited
      </pre><p>Vous devrez maintenant recompiler le programme et passer
      l'option <tt class="option">-g</tt> à <span class="application">gcc</span>
      (l'explication dépasse la portée de ce document). À présent,
      exécutez le jeu et répétez ce qui a fait planter le programme pour
      générer à nouveau un fichier core. Exécutez le débogueur avec le
      fichier core comme second argument :</p><pre class="screen">
    $ gdb ExécutableJeuChouette core
      </pre><p>À l'invite, tapez <b class="userinput"><tt>backtrace</tt></b>. Vous verrez
      quelque chose comme : </p><pre class="screen">
    #0 printf (format=0x80484a4 "z is %d.\n") at printf.c:30
    #1 0x8048431 in display (z=5) at try1.c:11
    #2 0x8048406 in main () at try1.c:6
      </pre><p>Cela peut être assez long, mais utilisez votre souris pour
      copier et coller ces informations dans un fichier. Envoyez-le par
      courriel à l'auteur et indiquez-lui :</p><div class="orderedlist"><ol type="1"><li><p>le nom du jeu</p></li><li><p>le message d'erreur qui est apparu à l'écran quand
        le jeu a planté.</p></li><li><p>ce qui a provoqué le plantage et s'il est
        reproductible ou non.</p></li><li><p>la pile d'appels</p></li></ol></div><p>Si vous avez une bonne bande passante, demandez à l'auteur s'il
      souhaite le fichier core généré par son programme. S'il est d'accord,
      envoyez-le lui. N'oubliez pas de lui demander au préalable, car les
      fichiers core peuvent être très, très gros.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="savedgames"></a>6.6. Parties sauvegardées</h3></div></div><div></div></div><p>Si votre jeu permet de sauvegarder des parties, alors
      l'envoi à l'auteur d'une copie de la partie sauvegardée est
      utile car cela lui permet de reproduire le dysfonctionnement.
      Pour les jeux commerciaux, cette possibilité est plus fructueuse
      que d'envoyer un fichier core ou une pile d'appels car les jeux
      commerciaux ne peuvent être recompilés de sorte à inclure des
      informations de débogage. Vous devriez impérativement demander
      avant d'envoyer une partie sauvegardée car ils ont tendance à
      être gros, mais une société comme Loki Software dispose de
      beaucoup de bande passante. <span class="firstname">Mike</span> <span class="surname">
      Phillips</span> (un ancien de Loki Software)
      indique que l'envoi de sauvegardes de jeux à Loki est
      définitivement une bonne chose.</p><p>Évidemment, cela ne s'applique que si votre jeu plante de façon
      reproductible dans certaines circonstances. Si le jeu vous donne une
      erreur de segmentation (<span class="foreignphrase"><i class="foreignphrase">segmentation
      fault</i></span>) à chaque fois que vous l'exécutez, ou est
      incroyablement lent, une sauvegarde de jeu n'aura que peu
      d'utilité.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2501115"></a>6.7. Que faire quand on ne trouve pas un fichier ou une
    bibliothèque (ou se faciliter la vie avec
    <span><b class="command">strace</b></span>)</h3></div></div><div></div></div><p>Parfois, vous verrez des messages d'erreur indiquant qu'un
      fichier n'a pu être trouvé. Le fichier pourrait être une
      bibliothèque :</p><pre class="screen">
    % ./exult 
    ./exult: error while loading shared libraries: libSDL-1.2.so.0: cannot load shared object
    file: No such file or directory
      </pre><p>ou un fichier de données, comme un fichier <tt class="filename">wad</tt> ou <tt class="filename">map</tt> :</p><pre class="screen">
    % qf-client-sdl  
    IP address 192.168.0.2:27001 UDP Initialized Error: W_LoadWadFile: couldn't load gfx.wad
      </pre><p>Supposez que <tt class="filename">gfx.wad</tt> est déjà sur mon
      système, mais qu'il ne peut être trouvé étant donné qu'il n'est pas
      dans le bon répertoire. Mais alors, où est le bon répertoire ?
      Ne serait-il pas utile de savoir où ces programmes recherchent les
      fichiers manquants ?</p><p>C'est ici que <span><b class="command">strace</b></span> brille. Il vous indique
      quels appels système sont effectués, avec quels arguments, et quelles
      sont les valeurs de retour. Dans mon « <span class="quote">Guide de
      programmation de modules noyau</span> » (à paraître bientôt sur
      le LDP), je souligne tout ce que vous devez savoir sur
      <span><b class="command">strace</b></span>. Mais voici les grandes lignes :
      saisissez la commande</p><pre class="screen">
    strace -o ./LS_LOG /bin/ls
      </pre><p>L'option <tt class="option">-o</tt> envoie la sortie de
      <span><b class="command">strace</b></span> dans un fichier, ici LS_LOG. Le dernier
      argument de <span><b class="command">strace</b></span> est le programme à surveiller,
      ici <span><b class="command">ls</b></span>. Regardez le contenu de
      <tt class="filename">LS_LOG</tt>. Assez impressionnant, n'est-ce
      pas ? Voici une ligne typique :</p><pre class="screen">
    open(".", O_RDONLY|O_NONBLOCK|0x18000)  = 4
      </pre><p>Nous avons utilisé l'appel système <tt class="function">open()</tt>
      pour ouvrir « <span class="quote"><tt class="filename">.</tt></span> » avec divers arguments, et
      la valeur de retour de l'appel est <span class="returnvalue">4</span>. Quel
      est le rapport avec les fichiers non trouvés ?</p><p>Supposez que je veuille regarder la démo de
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">StateOfMind</i></span></span>™
      car je ne m'en lasse pas. Un jour, j'essaie de l'exécuter et quelque
      chose se passe mal :</p><pre class="screen">
% ./mind.i86_linux.glibc2.1 
Loading &amp; massaging...
Error:Can't open data file 'mind.dat'.
</pre><p>Utilisons <span><b class="command">strace</b></span> pour détecter l'endroit où
      le programme recherchait le fichier de données.</p><pre class="screen">
    strace ./mind.i86_linux.glibc2.1 2&gt; ./StateOfMind_LOG
      </pre><p>Lançant <span class="application">vim</span> et recherchant toutes
      les occurrences de <tt class="filename">mind.dat</tt>, je trouve les
      lignes suivantes :</p><pre class="screen">
    open("/usr/share/mind.dat",O_RDONLY) = -1 ENOENT (No such file)
    write(2, "Error:", 6Error:)   = 6
    write(2, "Can\'t open data file \'mind.dat\'."..., ) = 33
      </pre><p>Je ne recherchais <tt class="filename">mind.dat</tt> que dans
      un seul répertoire. Il apparaît clairement que
      <tt class="filename">mind.dat</tt> n'est pas dans <tt class="filename">/usr/share</tt>. Nous pouvons maintenant
      essayer de localiser <tt class="filename">mind.dat</tt> et de le
      déplacer dans <tt class="filename">/usr/share</tt>
      ou, mieux, créer un lien symbolique.</p><p>Cette méthode fonctionne également pour les bibliothèques.
      Supposez que la bibliothèque <tt class="filename">libmp3.so.2</tt> est située dans <tt class="filename">/usr/local/include</tt> mais que votre
      nouveau jeu
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Kill-Metallica</i></span></span>™
      ne le trouve pas. Vous pouvez utiliser <span><b class="command">strace</b></span> pour
      déterminer où
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Kill-Metallica</i></span></span>™
      doit rechercher la bibliothèque et créer un lien symbolique de
      <tt class="filename">/usr/local/include/libmp3.so.2</tt>
      vers l'endroit où
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Kill-Metallica</i></span></span>™
      recherchait le fichier de bibliothèque.</p><p><span><b class="command">strace</b></span> est un utilitaire très puissant.
      Quand vous essayez de savoir pourquoi quelque chose n'est pas trouvé,
      il est votre meilleur allié, et est même plus rapide que la
      consultation du code source. De plus, vous ne pouvez pas rechercher
      d'informations dans le code source des jeux commerciaux de Lokisoft
      ou Tribsoft. Mais vous pouvez toujours utiliser
      <span><b class="command">strace</b></span> !</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="hosedconsoles"></a>6.8. Consoles corrompues</h3></div></div><div></div></div><p>Parfois, un jeu se termine anormalement et votre console
      se retrouve alors dans un état bizarroïde : le texte à
      l'écran est du charabia, votre bel écran noir habituel ressemble
      à un écran semi-graphique, et cætera. Quand vous tapez sur
      <span><b class="keycap">Entrée</b></span>, un retour à la ligne n'est pas
      reproduit à l'écran. Parfois, certaines touches du clavier ne
      répondent pas. La déconnexion suivie d'une reconnexion ne marche
      pas toujours, mais il y a d'autres possibilités :</p><div class="itemizedlist"><ul type="disc"><li><p>Si aucun des caractères que vous tapez
        n'apparaît à l'écran, les réglages de votre terminal peuvent
        être incorrects. Essayez
        « <span class="quote">stty echo</span> ». Cela devrait
        rétablir l'écho des caractères.</p></li><li><p>À l'invite, tapez <b class="userinput"><tt>reset</tt></b>.
        Cela devrait éliminer beaucoup de problèmes, y compris les consoles
        corrompues par un jeu basé sur SVGAlib ou
        ncurses.</p></li><li><p>Essayez de ré-exécuter le même jeu normalement. Une
        fois, j'ai dû tuer <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Quake
        III</i></span></span>™ en toute hâte, et j'ai donc
        effectué un <span><b class="keycap">ctrl</b></span>+<span><b class="keycap">alt</b></span>+<span><b class="keycap">backspace</b></span>. La
        console était corrompue et présentait un écran quasi-graphique.
        Exécuter <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Quake
        III</i></span></span>™ et le quitter normalement a
        corrigé le problème.</p></li><li><p>Les commandes <span><b class="command">deallocvt</b></span> et
        <span><b class="command">openvt</b></span> fonctionneront pour la plupart des autres
        problèmes. <span><b class="command">deallocvt <i class="parameter"><tt>N</tt></i></b></span>
        tue entièrement le terminal <tt class="literal">N</tt>, de sorte que
        <tt class="literal">Alt-FN</tt> ne fonctionne plus du tout.
        <span><b class="command">openvt <tt class="option">-c
        <i class="parameter"><tt>N</tt></i></tt></b></span> ou <b class="userinput"><tt>openvt
        <tt class="option">-c <i class="parameter"><tt>N</tt></i></tt></tt></b> le
        redémarre.</p></li><li><p>Si certaines touches de votre clavier ne
        fonctionnent pas, faites preuve de créativité. Si vous voulez
        redémarrer mais que la touche <span><b class="keycap">o</b></span> ne fonctionne
        pas, essayez d'employer <span><b class="command">halt</b></span>. Une méthode
        que j'ai expérimentée est de taper une commande à l'invite et
        d'utiliser des caractères à l'écran en utilisant le
        copier-coller avec la souris. Par exemple, vous pouvez taper
        <b class="userinput"><tt>ps ax</tt></b>, et vous êtes sûr(e) d'avoir un
        <span><b class="keycap">h</b></span>, <span><b class="keycap">a</b></span>, <span><b class="keycap">l</b></span> et
        un <span><b class="keycap">t</b></span> quelque part à l'écran. Vous pouvez
        utiliser la souris pour copier et coller le mot
        « <span class="quote">halt</span> ».</p></li><li><p>L'option la plus regrettable est le
        redémarrage. Si c'est possible, un arrêt ordonné est
        préférable ; utilisez <span><b class="command">halt</b></span> ou
        <span><b class="command">shutdown</b></span>. Sinon, utilisez
        <span><b class="command">ssh</b></span> depuis une autre machine. Cela
        fonctionne parfois quand votre console présente d'importants
        dysfonctionnements. Dans le pire des cas, appuyez sur le
        bouton Reset ou Power (réinitialisation ou arrêt de
        l'alimentation).</p></li></ul></div><p>Notez que si vous utilisez un système de fichiers
      journalisé comme ext3, reiserfs ou xfs, l'appui sur le bouton
      Power n'est pas aussi néfaste que cela. Vous êtes toujours
      supposé arrêter la machine d'une façon ordonnée, mais
      l'intégrité du système de fichiers sera préservée. Vous ne
      verrez normalement pas de <span><b class="command">fsck</b></span> pour les
      partitions qui utilisent le système de fichiers
      journalisé.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2501804"></a>6.9. Système bloqué</h3></div></div><div></div></div><p>Quand un ordinateur se bloque, le clavier et la souris ne
      répondent plus du tout. C'est une conséquence directe d'un bogue
      dans le noyau Linux. Bien que Linux soit réputé pour sa
      stabilité, de telles choses peuvent arriver, en particulier avec
      les jeux qui occasionnent des événements matériels extrêmement
      synchronisés se produisant très rapidement, même pour un
      ordinateur. Quand un ordinateur se bloque, cela peut être un
      « <span class="quote">blocage total</span> », signifiant que le noyau
      a complètement cessé de fonctionner. Cela indique souvent que le
      matériel est en cause. Le seul remède à ce type de blocage est
      d'appuyer sur le bouton Reset ou Power. Le blocage peut
      également être « <span class="quote">léger</span> », à savoir que le
      noyau fonctionne toujours dans une certaine mesure. Il est
      possible de se remettre gracieusement de cette situation.</p><div class="itemizedlist"><ul type="disc"><li><p>La première chose à essayer est de taper
        <span><b class="keycap">control</b></span>+<span><b class="keycap">alt</b></span>+<span><b class="keycap">backspace</b></span>
        qui tue X. Si vous récupérez le contrôle sur votre système, le
        noyau n'était pas réellement bloqué. Si cela ne fonctionne pas
        après quelques secondes, il faut alors redémarrer le système en
        suivant les recommandations suivantes :</p></li><li><p>Utilisez <span><b class="keycap">control</b></span>+<span><b class="keycap">alt</b></span>+<span><b class="keycap">delete</b></span> pour redémarrer le système.
   Vous savez que cela a fonctionné si l'ordinateur émet un bip après
   quelques secondes (c'est le BIOS qui dit « <span class="quote">Tout est
   OK</span> » au cours du cycle de démarrage).</p></li><li><p>Connectez-vous à partir d'un autre système via ssh.
        Si vous y parvenez, redémarrez ou arrêtez le
        système.</p></li><li><p>Si cela n'est pas possible, vous devrez utiliser la
        « <span class="quote">touche magique <span><b class="keycap">SysRq</b></span></span> » qui
        est documentée dans
        <tt class="filename">/usr/src/linux/Documentation/sysrq.txt</tt>. Voici
        un résumé pour l'architecture x86 (consultez la documentation pour
        les autres architectures). Notez que si votre clavier n'a pas de
        touche <span><b class="keycap">SysRq</b></span>, il vous faudra utiliser la touche
        <span><b class="keycap">PrintScreen</b></span> :

          </p><div class="orderedlist"><ol type="1"><li><p>Tapez <span><b class="keycap">Alt</b></span>+<span><b class="keycap">SysRq</b></span>+<span><b class="keycap">s</b></span> pour tenter de synchroniser vos
              systèmes de fichiers montés afin que les changements apportés
              aux fichiers soient effectués sur disque. Vous pouvez
              entendre de l'activité du disque dur. Si vous regardez sur
              une console, le système devrait afficher le nom des
              périphériques pour lesquels cette opération a eu
              lieu.</p></li><li><p>Quelques secondes plus tard, tapez <span><b class="keycap">Alt</b></span>+<span><b class="keycap">SysRq</b></span>+<span><b class="keycap">u</b></span> pour essayer de remonter les
              systèmes de fichiers montés en mode lecture seule. Vous
              devriez entendre de l'activité disque. Si vous examinez une
              console, le système affichera les périphériques qui ont été
              remontés.</p></li><li><p>Après un bref moment, utilisez <span><b class="keycap">Alt</b></span>+<span><b class="keycap">SysRq</b></span>+<span><b class="keycap">b</b></span> pour redémarrer le
              système.</p></li><li><p>Vous pouvez aussi taper <span><b class="keycap">Alt</b></span>+<span><b class="keycap">SysRq</b></span>+<span><b class="keycap">h</b></span> pour obtenir un écran d'aide
         ultra-concis.</p></li></ol></div></li></ul></div><p>Pour prendre en charge la touche magique
      <span><b class="keycap">SysRq</b></span>, votre noyau doit avoir été compilé à cet
      effet. Vous trouverez cette option sous
      « <span class="quote"><tt class="literal">Kernel Hacking | Kernel Debugging | Magic
      SysRq key</tt></span> ». Si la séquence magique
      <span><b class="keycap">SysRq</b></span> n'éteint pas correctement votre système,
      votre noyau s'est réellement bien planté et le seul remède est
      d'utiliser le bouton Reset ou Power.</p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2502159"></a>7. Cartes vidéo</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2502163"></a>7.1. Historique</h3></div></div><div></div></div><p>Il était une fois, une société de San Jose, en Californie,
      appelée <span class="trademark">3dfx Interactive</span>™ dominait le marché
      des cartes vidéo destinées au jeu. En octobre 1996, elle a mis sur le
      marché la Voodoo I, qui a connu un succès phénoménal. C'était la
      première carte proposant une accélération matérielle, mais elle
      n'effectuait que du rendu 3D ; il fallait une seconde carte
      vidéo 2D de haute qualité pour effectuer le rendu 2D (Matrox était
      immensément populaire à l'époque) alors que les informations 3D
      (voyez Glide2, à la <a href="#glide2" title="3.1. Glide2">Section 3.1, « Glide2 »</a>) sont transmises à la
      Voodoo I et rendues, en utilisant le matériel rapide de la Voodoo
      pour effectuer les calculs graphiques nécessaires. La Voodoo Rush est
      sortie en avril 1996. Elle aurait dû être plus puissante, avec un GPU
      cadencé à 50 Mhz et 8 Mo de RAM. Mieux encore, elle
      constituait leur première carte combinée 2D/3D, libérant un port PCI
      précieux (la plupart des PC n'avaient que deux ports PCI à l'époque)
      mais la Rush n'a pas été aussi populaire. 3dfx a supprimé l'unité
      multi-textures de la Rush, qui a dès lors été surclassée par la
      Voodoo I. Pendant ce temps-là, ATI produisait sa série de Rage et
      nVidia celle de Riva 128, mais la Voodoo I dominait toujours
      largement.</p><p>C'était une belle époque pour Linux. id Software avait libéré
      le code source de Doom et porté Quake I sous Linux (décembre 1996).
      Nous goûtions pour la première fois au jeu commercial réel. Le choix
      était vite fait : vous achetiez une Voodoo. Et vous vous sentiez
      bien, car 3dfx avait ouvert ses pilotes. La reine des cartes vidéo
      fonctionnait grâce à des développeurs Linux. Non seulement nous
      disposions des meilleures cartes vidéo, mais de plus leurs pilotes
      étaient tous <span class="foreignphrase"><i class="foreignphrase">open source</i></span>.</p><p>En mars 1998, 3dfx lançait la Voodoo II, avec sa bande passante
      mémoire de 3.6 Go/sec, 12 Mo de mémoire vidéo et un
      cœur fonctionnant à 90 MHz. Elle permettait des
      résolutions allant jusqu'à 1024x768. C'était 3dfx à son apogée. Comme
      la Voodoo I, la Voodoo II était une carte ne s'occupant que de la 3D,
      et se reposant sur une autre carte vidéo pour la 2D. La Voodoo
      Banshee est sortie en septembre 1998 comme une carte combinée 2D/3D,
      comme la Rush. Malgré un cœur plus rapide fonctionnant à
      100 MHz, la Banshee était dépassée par la Voodoo II du fait de
      la suppression de l'unité multi-textures, comme pour la Rush. Et à
      nouveau, comme la Rush, elle n'était pas populaire. Mais 3dfx régnait
      en maître, et personne ne pouvait leur faire de l'ombre.</p><p>La Voodoo III est sortie en avril 1999. Il y en a eu plusieurs,
      au cœur variant de 143 à 183 MHz. Certaines versions
      disposaient d'une sortie TV. Il y avait des versions PCI et AGP
      (c'était la première carte vidéo AGP). C'était un autre succès, mais
      3dfx commençait à perdre du terrain au profit de nVidia, qui
      produisait la TNT 2. Celle-ci surclassait la Voodoo II, et offrait
      une accélération 3D avec des couleurs 32 bits, alors que les Voodoo
      étaient limitées aux couleurs 16 bits. Mais la vie était toujours
      belle pour Linux. Nous disposions d'une carte qui était pratiquement
      au coude à coude avec nVidia, nos pilotes étaient <span class="foreignphrase"><i class="foreignphrase">open
      source</i></span> et, en décembre 1999, id Software nous a fait
      un grand cadeau : ils ont ouvert le code source de Quake
      I.</p><p>Ensuite, la GeForce 256 de nVidia est apparue en octobre 1999.
      La Voodoo IV de 3dfx, son concurrent direct, avait à peu près une
      année de retard, ce qui est pour le moins ennuyeux quand on se bat
      sur un marché « <span class="quote">de pointe</span> ». Alors que les
      travaux en recherche et développement de nVidia étaient appliqués à
      ses cartes, 3dfx ne faisait qu'ajouter de la RAM plus rapide. Les
      Voodoo IV et V rendaient les couleurs 32 bits, prenaient très bien en
      charge l'<a href="#aa" title="7.4.3. AA : Anti
      Aliasing">anti-crénelage</a>, proposaient un
      second GPU, plus de mémoire, et étaient pour ainsi dire supérieures
      aux autres cartes vidéo. Néanmoins, la sortie tardive des Voodoo IV
      et V couplée au fait qu'on pouvait obtenir la GeForce pour moitié
      moins explique le naufrage rapide de 3dfx. Pour Linux, les plus
      récentes Voodoo ne pouvaient accélérer que pour les couleurs 16 et 24
      bits. Pire encore, le second GPU de la Voodoo V n'était pas exploité
      par le pilote Linux (et, à ce jour, la Voodoo V est fonctionnellement
      équivalente à la Voodoo IV sous Linux). La plupart des utilisateurs
      Windows sont passés à nVidia et, bien que les pilotes de cette
      dernière étaient propriétaires, même les utilisateurs Linux
      commençaient à la choisir. VA Linux, le plus grand vendeur des
      serveurs Linux, plaçait des nVidia dans ses machines.</p><p>Ensuite, en avril 2000, 3dfx a été attaqué sur un autre
      front : ATI commençait à produire sa première génération de
      Radeon. Auparavant, ATI avait toujours été un fabricant de puces
      graphiques innovant (leurs propres puces accélératrices 3D datent de
      1996, à peu près au même moment que 3dfx), mais fort discret. Les
      Radeon étaient leur première carte accélératrice 3D à réellement
      intéresser les joueurs. Leurs Radeon écrasaient à la fois nVidia et
      3dfx. Ils ont collaboré avec des développeurs Linux, ont ouvert le
      code source de tous leurs pilotes et ont été acclamés comme le grand
      espoir pour le jeu sous Linux. nVidia revint à la charge, et c'en
      était trop pour 3dfx. Entre la défaite dans les bancs d'essais contre
      la GeForce et la Radeon, leurs nouvelles cartes en retard et leurs
      prix élevés, 3dfx avait perdu sa part de marché et n'avait plus les
      fonds nécessaires pour continuer ses activités. Le 18 avril 2001, ils
      ont vendu la plupart des leurs avoirs et technologies à nVidia et, en
      octobre 2002, ont finalement fait aveu de faillite.</p><p>La disparition de 3dfx était très soudaine et une gifle pour la
      communauté <span class="foreignphrase"><i class="foreignphrase">open source</i></span>. Je me souviens
      toujours de mon ami <span class="firstname">Gabe</span> <span class="surname"> Rosa</span> m'envoyant un courriel avec ces
      simples mots « <span class="quote"><tt class="literal">Look at /.</tt></span> »
      (Va voir sur slashdot) et la vision de la nouvelle. C'était le 2e
      jour le plus sombre de l'histoire du jeu sous Linux (après la mort de
      Loki). Et c'était aussi vraiment dommage. 3dfx était sur le point de
      sortir une nouvelle Voodoo V avec 4 GPU qui aurait écrasé les offres
      de ATI et nVidia, ainsi qu'une nouvelle carte au nom de code
      « <span class="quote">Rampage</span> » qui les auraient ramené sur le
      devant de la scène. On raconte que la technologie de Rampage (qui a
      été vendue à nVidia) s'est retrouvée dans la GeForce 5900. Pas trop
      mal pour une technologie vieille de 3 ans !</p><p>Au début, tout était simple. Les joueurs Linux gardaient soit
      leurs Voodoo <span class="foreignphrase"><i class="foreignphrase">open source</i></span>, acquéraient
      une Radeon <span class="foreignphrase"><i class="foreignphrase">open source</i></span> ou une GeForce
      propriétaire. Néanmoins, les jeux grossissant et s'améliorant, ce
      n'était qu'une question de temps avant que les Voodoo ne soient plus
      viables pour les jeux modernes. Certains utilisaient toujours des
      Voodoo, mais ces personnes étaient pratiquement hors du coup en ce
      qui concerne le jeu.</p><p>ATI a produit un nombre incroyable de versions de chaque carte
      vidéo, et il devenait difficile de suivre l'évolution de leur
      terminologie. ATI et nVidia dominaient le marché. Leurs produits ont
      toujours été au coude à coude depuis lors, la GeForce prenant
      l'avantage un peu plus souvent que la Radeon. Mais les pilotes de la
      Radeon étaient <span class="foreignphrase"><i class="foreignphrase">open source</i></span>, et de
      nombreux utilisateurs Linux lui restaient fidèles. Ensuite, cela
      s'est compliqué.</p><p>ATI a commencé à devenir de plus en plus réticent aux pilotes
      <span class="foreignphrase"><i class="foreignphrase">open source</i></span> pour leurs nouvelles
      cartes et, soudainement, il n'était plus facile de savoir qui était
      le « <span class="quote">bon</span> ». L'excuse de nVidia était qu'une
      partie de leur code GL est sous licence d'une autre société, et ne
      peut par conséquent pas être « <span class="quote">libérée</span> ».
      Vraisemblablement, ATI ne veut pas collaborer afin de conserver ses
      secrets de fabrique. Et cela ne s'arrange pas. Les pilotes ATI Linux
      ont souffert de performances extrêmement faibles. Même quand une
      offre de ATI est meilleure que celle de la GeForce du moment pour
      Windows, la carte est toujours écrasée par la GeForce sous Linux. Du
      fait de pilotes ATI Linux calamiteux, les utilisateurs Linux ne
      peuvent se fier aux bancs d'essais ou aux tests de cartes prévus pour
      MS Windows. Ils ne sont tout simplement pas appropriés. Et c'est à
      peu près au point où nous en sommes pour le moment.</p><p>Finalement, le seul véritable banc d'essais des cartes vidéo
      sous Linux date malheureusement, à ma connaissance, de mars 2001,
      entre une Radeon 32 DDR et une GeForce 2. Vous pouvez le consulter
      vous-même sur <a href="http://www.linuxhardware.org/features/01/03/19/0357219.shtml" target="_top">http://www.linuxhardware.org/features/01/03/19/0357219.shtml</a>,
      mais la conclusion est que la GeForce 2 domine de la tête et des
      épaules la Radeon 32 DDR.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2502563"></a>7.2. Situation actuelle (13 juillet 2003)</h3></div></div><div></div></div><p>La dernière offre de nVidia est la GeForce 5900, basée sur le
      jeu de composants NV35. Elle est bien prise en charge sous Linux par
      des pilotes de haute qualité mais propriétaires. Ils ne fournissent
      pas d'informations aux développeurs Linux, et vous ne pourrez donc
      utiliser que leurs pilotes binaires ; ils ne font pas partie de
      XFree86. nVidia utilise une architecture unifiée pratique :
      leurs pilotes prennent en charge de la TNT 2 à la GeForce
      5900.</p><p>ATI a travaillé avec les développeurs Linux pour toutes les
      Radeon jusqu'à la Radeon 9200. Ces cartes font l'objet d'une prise en
      charge 2D et 3D dans XFree86. Je ne suis pas entièrement sûr de la
      qualité de ces pilotes <span class="foreignphrase"><i class="foreignphrase">open
      source</i></span> ; néanmoins,
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Soldier of Fortune
      I</i></span></span>™ et <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Heavy
      Metal</i></span></span>™ ont toujours des problèmes de
      textures opaques avec la première génération de Radeon. Après la
      9200, vous devez utiliser les pilotes binaires propriétaires,
      disponibles au format rpm, depuis le site web de ATI. Ces pilotes
      sont abominables : un de mes amis m'affirme que sa GeForce 4400
      surclasse sa Radeon 9700 pro. C'est une honte !</p><p>Sur le papier, et selon les bancs d'essais pour Windows, la
      Radeon 9800 écrase la mal-conçue GeForce 5800 et dépasse légèrement
      la GeForce 5900. Sur le papier, elle est tout simplement la carte la
      plus impressionnante. Mais, à nouveau, le problème des pilotes ne
      nous permet pas d'en bénéficier. Si vous désirez acheter la meilleure
      carte pour Linux, vous devrez utiliser la GeForce 9800. Préparez-vous
      simplement à manger des nouilles pendant quelques mois : les
      deux cartes sont excessivement chères.</p><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2502628"></a>7.2.1. Support de SVGAlib</h4></div></div><div></div></div><p>Au 30 juin 2002, la prise en charge par la SVGAlib des
          cartes Radeon est problématique. Les développeurs ont rapporté
          que SVGAlib fonctionne avec les Radeon 7500 et Radeon QD (modèle
          64 Mo DDR) mais a quelques soucis avec la Radeon VE.</p><p>Je ne dispose pas d'informations concernant les cartes
          GeForce.</p></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2502668"></a>7.3. Quelle carte vidéo dois-je acheter ? (13 juillet
      2003)</h3></div></div><div></div></div><p>La réponse était très difficile l'an dernier, mais voici mon
   opinion :</p><div class="orderedlist"><ol type="1"><li><p>Toutes les cartes GeForce requièrent un pilote
          propriétaire qui « <span class="quote">salit</span> » votre noyau.
          Néanmoins, c'est également la cas de toutes les cartes ATI
          suivant la Radeon 9200.</p></li><li><p>nVidia a prouvé qu'elle se souciait suffisamment
          de Linux pour écrire et actualiser des pilotes vidéo de haute
          qualité pour Linux. Même quand ATI a ouvert le code source de ses
          pilotes, ils se reposaient sur les développeurs Linux pour faire
          le sale boulot. Leurs pilotes propriétaires actuels sont
          ignobles.</p></li><li><p>La Radeon 9800 actuelle bat tout juste la GeForce
          5900 dans les bancs d'essais et sur le plan des spécifications,
          mais les utilisateurs Linux ne pourront en bénéficier du fait de
          la faiblesse des pilotes de la 9800.</p></li><li><p>ATI a depuis longtemps l'habitude d'abandonner le
          support de son matériel dès que c'est possible.</p></li><li><p>Sous MS Windows, quand la GeForce bat son
          principal adversaire Radeon, les critiques affirment généralement
          que les graphismes de la Radeon étaient plus soignés. Je ne sais
          pas si cela se ressent également sous Linux.</p></li></ol></div><p>En fin de compte, la plupart devrait acheter une GeForce pour
        le moment.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2502756"></a>7.4. Définitions : carte vidéo et terminologie 3D</h3></div></div><div></div></div><p>Parlons à présent de la terminologie des cartes vidéo et des
      graphiques 3D. Ce n'est pas primordial pour faire fonctionner un jeu
      en pratique, mais cela peut vous aider à décider quelles options
      matérielles et logicielles vous conviennent le mieux.</p><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="textures"></a>7.4.1. Textures</h4></div></div><div></div></div><p>Une scène rendue est constituée à la base de polygones et de
        lignes. Une texture est une image 2D (habituellement une bitmap)
        recouvrant les polygones d'un monde 3D. Pensez à une couche de
        peinture sur les polygones.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="tl"></a>7.4.2. <span class="foreignphrase"><i class="foreignphrase">T&amp;L : Transform and
      Lighting</i></span></h4></div></div><div></div></div><p>Le T&amp;L (transformation et éclairage) est le processus de
        traduction de toutes les informations du monde 3D (position,
        distance et sources de lumière) en une image 2D effectivement
        affichée à l'écran.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="aa"></a>7.4.3. <span class="foreignphrase"><i class="foreignphrase">AA : Anti
      Aliasing</i></span></h4></div></div><div></div></div><p>L'anti-aliasing (anti-crénelage) est le lissage de l'effet
        d'escalier d'une courbe ou d'un polygone, apparaissant lors du
        dessin d'une ligne brisée ou d'une courbe composée de pixels (de
        forme rectangulaire), aussi appelé
        « <span class="quote">crénelage</span> ». Il se produit quand les pixels
        forment une ligne crénelée plutôt qu'une courbe ou une ligne lisse.
        L'AA utilise un filtrage gourmand en temps CPU pour lisser de tels
        contours crénelés. Cela améliore l'aspect visuel d'un jeu, mais
        peut également grever dramatiquement les performances.</p><p>L'AA est utilisé dans différentes situations. Par exemple,
        quand vous grossissez une image, vous pouvez remarquer que des
        lignes qui étaient lissent deviennent crénelées (essayez avec
        <span class="application">The Gimp</span>). Le rendu des polices de
        caractères est une autre grande application pour l'AA.</p><p>L'AA peut être fait soit par l'application elle-même (comme
        avec <span class="application">The Gimp</span> ou le système de polices
        de <span class="application">XFree86</span>), soit par le matériel, si
        votre carte le supporte. Puisque l'AA est gourmand en temps CPU, il
        vaut mieux l'effectuer en matériel, mais si nous parlons
        d'applications semi-statiques, comme <span class="application">The
        Gimp</span>, cela ne pose pas vraiment de problème. Pour les
        situations dynamiques, comme les jeux, effectuer l'AA en matériel
        peut être crucial.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="fsaa"></a>7.4.4. <span class="foreignphrase"><i class="foreignphrase">FSAA : Full Screen
      Anti-Aliasing</i></span></h4></div></div><div></div></div><p>Le FSAA (anti-crénelage plein écran) implique habituellement
        le dessin d'une version grossie de l'écran entier dans un
        framebuffer séparé, en effectuant l'AA sur l'image entière puis en
        la ramenant à la résolution normale. Comme vous pouvez l'imaginer,
        c'est extrêmement gourmand en temps CPU. Vous ne verrez jamais de
        FSAA non accéléré matériellement.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="mipmapping"></a>7.4.5. <span class="foreignphrase"><i class="foreignphrase">Mip
      Mapping</i></span></h4></div></div><div></div></div><p>Le « <span class="quote">mip mapping</span> » est une technique
        consistant à stocker diverses copies à l'échelle de la même texture
        dans la mémoire de la carte vidéo, afin de représenter la texture à
        différentes distances. Quand la texture est très éloignée, une plus
        petite version de la texture est utilisée. Quand la texture est
        proche, une plus grande est utilisée. Le <span class="foreignphrase"><i class="foreignphrase">mip
        mapping</i></span> peut être utilisé quelle que soit la <a href="#texturefiltering" title="7.4.6. Filtrage de textures">méthode de filtrage</a>. Il réduit
        non seulement les besoins en bande passante mémoire (puisque les
        images sont stockées sur le matériel), mais offre également une
        meilleure qualité d'image.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="texturefiltering"></a>7.4.6. Filtrage de textures</h4></div></div><div></div></div><p>Le filtrage de textures est la fonctionnalité fondamentale
        requise pour fournir des graphiques 3D agréables. Il a plusieurs
        applications, comme mélanger sans encombre des textures adjacentes,
        et rendre réaliste des textures vues depuis un angle (p.ex.
        regarder un panneau d'affichage depuis un angle extrême). Il existe
        plusieurs techniques de filtrage de textures incluant
        l'échantillonnage de points et les filtrages bilinéaire,
        trilinéaire et anisotrope.</p><p>Quand je parle de « <span class="quote">dégradation de
        performances</span> », gardez à l'esprit qu'elle dépend de la
        résolution utilisée. Par exemple, à une basse résolution, l'impact
        sur les performances de l'utilisation du filtrage trilinéaire au
        lieu du filtrage bilinéaire est négligeable. Mais à de hautes
        résolutions, il peut être énorme. De plus, je ne connais aucune
        carte qui utilise le filtrage de textures anisotrope. Les pilotes
        TNT le prétendent, mais j'ai lu que ces pilotes utilisent toujours
        le filtrage trilinéaire au moment du rendu réel d'une image à
        l'écran.</p><div class="sect4" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="id2503026"></a>7.4.6.1. Filtrage de textures avec échantillonnage de
        points</h5></div></div><div></div></div><p>L'échantillonnage de points est rare de nos jours, mais si
          vous exécutez un jeu avec le « <span class="quote">rendu
          logiciel</span> » (ce que vous devrez faire si vous exécutez
          un jeu avec accélération 3D sans carte accélératrice 3D), vous
          constaterez probablement son utilisation.</p></div><div class="sect4" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="id2503050"></a>7.4.6.2. Filtrage de textures bilinéaire</h5></div></div><div></div></div><p>Le filtrage bilinéaire est un filtrage de textures peu
          exigeant en temps de calcul mais de basse qualité. Il approxime
          les différences entre les textures en échantillonnant la couleur
          des quatre texels les plus proches (supérieur, inférieur, gauche
          et droit). Toutes les cartes vidéo accélératrices 3D modernes
          peuvent effectuer du filtrage bilinéaire en matériel sans chute
          des performances.</p></div><div class="sect4" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="id2503071"></a>7.4.6.3. Filtrage de textures trilinéaire</h5></div></div><div></div></div><p>Le filtrage trilinéaire est un filtre bilinéaire de haute
          qualité qui utilise les quatre pixels les plus proches du
          deuxième niveau de mip map (<span class="foreignphrase"><i class="foreignphrase">mip map
          level</i></span>) le plus approprié pour produire des
          transitions plus douces entre les niveaux. Le filtrage
          trilinéaire échantillonne à partir de huit pixels et les intègre
          avant de calculer le rendu. Le filtrage trilinéaire utilise
          toujours le <a href="#mipmapping" title="7.4.5. Mip
      Mapping"><span class="foreignphrase"><i class="foreignphrase">mip
          mapping</i></span></a>. Il élimine l'effet de bandes qui
          apparaît entre des niveaux adjacents. La plupart des cartes vidéo
          accélératrices 3D peuvent effectuer du filtrage trilinéaire en
          matériel sans impact sur les performances.</p></div><div class="sect4" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="id2503117"></a>7.4.6.4. Filtrage de textures anisotrope</h5></div></div><div></div></div><p>Le filtrage anisotrope est la meilleure mais la plus
          demandeuse en temps de calcul des trois méthodes habituelles de
          filtrage de textures. Le filtrage trilinéaire est capable de
          produire de beaux résultats, mais il ne fait qu'échantillonner à
          partir d'une zone carrée, ce qui n'est pas toujours la méthode
          idéale. Anisotrope (signifiant « <span class="quote">depuis n'importe
          quelle direction</span> ») échantillonne à partir de plus de
          8 pixels. Le nombre de pixels utilisés et lesquels sont utilisés
          dépendent de l'angle de vision de la surface par rapport à votre
          écran. Il fait des merveilles lors de la visualisation de
          caractères alphanumériques depuis un certain angle.</p></div></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2503155"></a>7.4.7. <span class="foreignphrase"><i class="foreignphrase">Z-buffer</i></span></h4></div></div><div></div></div><p>Un Z-buffer est une partie de RAM qui représente la distance
        entre l'observateur (vous) et chaque pixel d'un objet. Beaucoup de
        cartes accélératrices 3D modernes disposent d'un z-buffer dans leur
        RAM vidéo, ce qui accélère considérablement les choses, mais il
        peut également être pris en charge par le moteur de rendu de
        l'application. Néanmoins, ce type de choses devrait clairement être
        fait en mémoire à chaque fois que c'est possible.</p><p>Chaque objet possède son ordre d'empilement, à la manière
        d'une pile de cartes. Quand des objets sont rendus dans un
        framebuffer 2D, le moteur de rendu supprime les surfaces cachées en
        utilisant le Z-buffer. Il y a deux façons de s'y prendre. Les
        moteurs stupides dessinent d'abord les objets éloignés puis
        seulement les objets proches, cachant les objets situés en dessous
        d'eux dans le Z-buffer. Les moteurs intelligents calculent quelles
        portions des objets seront cachées par les objets situés au-dessus
        et ne rendent tout simplement pas les portions que vous ne verriez
        de toute façon pas. Pour les textures compliquées, cela offre des
        grandes économies en temps processeur.</p></div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2503208"></a>8. Son</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2503213"></a>8.1. Quelle carte son est la meilleure ?</h3></div></div><div></div></div><p>Par « <span class="quote">meilleure</span> », j'entends
      « <span class="quote">meilleure pour le jeu</span> ». Les joueurs
      demandent une haute qualité sonore sans trop de paramétrage à
      effectuer. Les musiciens ont par contre d'autres exigences : le
      concept de « <span class="quote">meilleure carte son</span> » sera
      probablement différent pour eux. Si vous êtes un musicien, vous
      devriez consulter le « <span class="quote">Guide pratique de la qualité du son
      sous Linux</span> » (<span class="foreignphrase"><i class="foreignphrase"><a href="http://www.linuxdj.com/audio/quality/" target="_top">Linux Audio Quality
      HOWTO</a></i></span>).</p><p>Maintenant que Linux commence à mûrir, cette question a perdu
      de son importance. Auparavant, les cartes son sans puce MIDI intégrée
      (la plupart des cartes son PCI) ne pouvaient pas interpréter le MIDI.
      C'était principalement un problème pour les jeux comme
      <span class="productname">xdoom</span>™ ou <span class="productname">lxdoom</span>™
      qui utilisent <span class="application">musserv</span>. De nos jours, il
      existe des émulateurs MIDI comme <span class="application">Timidity</span>
      et des bibliothèques comme SDL qui ne requièrent pas de support MIDI
      matériel. Franchement, j'ai eu beaucoup de cartes et je n'ai pas
      constaté de différences en ce qui concerne le jeu. Si vous voulez des
      choses comme la conversion d'un enregistrement LP en format
      numérique, alors votre choix de carte son se portera sur un
      convertisseur analogique/numérique de niveau professionnel. Dans ce
      guide, nous supposerons que vous êtes plus un joueur qu'un ingénieur
      du son.</p><p>Votre décision devrait se baser sur la facilité de
      configuration. Si vous avez déjà une carte qui fonctionne bien, c'est
      suffisant. Si vous explorez le marché pour acheter une carte son,
      prenez quelque chose qui ne prend qu'une seconde à configurer. Les
      cartes PCI sont beaucoup plus faciles à gérer que les cartes ISA car
      vous ne devez pas indiquer à leur pilote quelles ressources système
      (IRQ, DMA, adresses d'entrée-sortie) utiliser. Certaines cartes ISA
      sont plug-n-play, comme la Creative AWE-64, et le noyau Linux a
      beaucoup évolué pour les auto-configurer.
      </p><p>Ma recommandation personnelle est une carte à base de es1370 ou
      es1371, qui utilise les pilotes son es1370 et es1371 sous Linux. Ces
      cartes vont de la plus ancienne Ensoniq es1370 à la plus récente
      Creative PCI-128. Ces cartes sont très bon marché et triviales à
      faire fonctionner sous Linux. </p><p>J'étais un grand fan des cartes son Creative Soundblaster AWE
      32, AWE 64 et AWE 64 gold. Ces cartes ISA PnP sont bien prises en
      charge à la fois par OSS et par Alsa. Elles utilisent toutes la même
      puce de synthèse sonore E-mu 8000 qui leur permet de jouer 32 voix
      simultanément (elles ont 32 « <span class="quote">canaux</span> »). Elles
      sont ISA, mais plug-n-play. Quelques remarques : primo, le
      <span class="foreignphrase"><i class="foreignphrase">Soundblaster AWE HOWTO</i></span> est très
      dépassé. Secundo, la AWE 64 et la AWE 64 gold peuvent jouer jusqu'à
      64 voix simultanément, mais cela est fait en logiciel. Creative n'a
      jamais publié de pilote Linux pour ces cartes (ni n'ont publié
      d'informations de programmation à ce sujet), et les utilisateurs
      Linux ne peuvent donc pas utiliser les 32 canaux supplémentaires de
      la AWE 64 et de la AWE 64 gold. Pour eux, ces trois cartes sont
      complètement identiques (bien que la AWE 64 gold ait des connecteurs
      plaqués or, qui offrent une meilleure qualité de son que les
      connecteurs en acier habituels).</p><p>La Creative Soundblaster Live! est une carte son PCI
      extrêmement populaire de nos jours. Je n'en ai jamais possédé, et je
      ne peut donc pas vous donner mes impressions. Néanmoins, on a reporté
      à de nombreuses reprises des problèmes sérieux avec la Live! et les
      cartes mères AMD qui utilisent le southbridge 686b. Une recherche sur
      Google devrait produire un tas d'informations sur ce problème.</p><p>Un élément plus pertinent est les haut-parleurs, mais même ici
      la différence n'est pas énorme. J'ai eu des haut-parleurs Altec
      Lansing coûteux qui ne fonctionnent que légèrement mieux que les
      haut-parleurs bon marché. Tout dépend du prix que vous êtes
      disposé(e) à mettre, mais ne vous attendez pas à de grosses
      différences. Vous devriez vous procurer quelque chose avec un caisson
      de basses séparé : les différences sont perceptibles au prix de
      câbles d'alimentation et de connecteurs supplémentaires.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2503403"></a>8.2. Pourquoi le son ne fonctionne-t-il pas ?</h3></div></div><div></div></div><p>Tout d'abord, votre jeu n'est probablement pas en cause ;
      il s'agit probablement de votre configuration. À ma
      connaissance, il y a 3 possibilités pour faire fonctionner une carte
      son configurée sous Linux : les pilotes son libres OSS
      accompagnant le noyau Linux, les pilotes Alsa et les pilotes son OSS
      commerciaux. Personnellement, je préfère les pilotes OSS, mais
      beaucoup ne jurent que par Alsa. Les pilotes commerciaux sont bons
      quand vous avez du mal à faire fonctionner votre carte son avec des
      méthodes libres. Ne crachez pas dessus : ils sont très bon
      marché (du genre 10 ou 20 $), supportent des cartes son du
      dernier cri et évitent beaucoup d'essai-erreur lors du processus de
      configuration.</p><p>Il y a 5 choses qui peuvent mal se passer avec votre système
      son : </p><div class="orderedlist"><ol type="1"><li><p>interruption partagée</p></li><li><p>pilote mal configuré</p></li><li><p>quelque chose accède déjà à la carte son</p></li><li><p>mauvais pilote utilisé</p></li><li><p>problème de permissions</p></li></ol></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2503500"></a>8.2.1. Interruption partagée</h4></div></div><div></div></div><p>La première chose à faire est de savoir s'il y a un conflit
        d'IRQ. Les cartes ISA ne peuvent pas partager de canaux
        d'interruption. Les cartes PCI le peuvent, mais certains types de
        cartes à grande bande passante n'aiment tout simplement pas
        partager, en ce compris les cartes réseau et son. Pour déterminer
        si vous avez un conflit, tapez
        <b class="userinput"><tt>cat /proc/interrupts</tt></b>. J'obtiens comme
        sortie sur mon système :
      </p><pre class="screen">
    $ cat /proc/interrupts
               CPU0       CPU1
      0:   24185341          0          XT-PIC  timer
      1:     224714          0          XT-PIC  keyboard
      2:          0          0          XT-PIC  cascade
      5:    2478476          0          XT-PIC  soundblaster
      5:     325924          0          XT-PIC  eth0
     11:     131326          0          XT-PIC  aic7xxx
     12:    2457456          0          XT-PIC  PS/2 Mouse
     14:     556955          0          XT-PIC  ide0
    NMI:          0          0
    LOC:   24186046   24186026
    ERR:       1353
    </pre><p>La seconde colonne est présente car j'ai 2 processeurs sur
        cette machine ; si vous n'en avez qu'un, vous n'aurez qu'une
        seule colonne CPU. Les nombres sur la gauche sont les IRQ
        attribuées et les chaînes de caractères sur la droite indiquent
        quel périphérique a été assigné à cette IRQ. Vous pouvez voir que
        j'ai un conflit entre la carte son (soundblaster) et la carte
        réseau. Elles partagent l'IRQ 5. En fait, j'ai créé cet exemple de
        toutes pièces car je voulais vous montrer à quoi ressemble un
        conflit d'IRQ. Mais si j'avais ce conflit, ni mon réseau ni mon son
        ne fonctionneraient correctement (ou ne fonctionneraient tout
        court !).</p><p>Si la carte son est une PCI, le plus simple est de simplement
        déplacer l'une des cartes dans un port différent et d'espérer que
        le BIOS trie tout correctement. Une méthode plus avancée serait
        d'aller dans le BIOS et d'attribuer des IRQ à des ports
        spécifiques. Les BIOS modernes en sont capables.
    </p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2503573"></a>8.2.2. Pilote mal configuré</h4></div></div><div></div></div><p>Parfois, une carte utilisera toujours une certaine IRQ
        (uniquement pour les cartes ISA). Alternativement, certaines cartes
        ISA peuvent être configurées pour utiliser une IRQ spécifique en
        utilisant des cavaliers sur la carte elle-même. Avec ce type de
        cartes, vous devez passer les IRQ, adresses mémoire et port
        d'entrée-sortie corrects au pilote.</p><p>C'est un sujet spécifique à la carte son, qui dépasse le cadre
        de ce guide.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2503601"></a>8.2.3. Quelque chose accède déjà à votre carte son</h4></div></div><div></div></div><p>Peut-être une application accède-t-elle déjà à votre carte
        son ? Par exemple, peut-être y a-t-il un lecteur MP3 qui est
        en mode pause… Si quelque chose accède déjà à votre carte,
        d'autres applications ne pourront l'utiliser. Même s'il a été conçu
        pour partager la carte entre des applications, je trouve que
        <span class="application">esd</span> (le serveur de son de Enlightenment)
        ne fonctionne pas toujours correctement. Le meilleur outil est
        <span><b class="command">lsof</b></span>, qui montre quels processus accèdent à un
        fichier. Votre carte son est représentée par <tt class="filename">/dev/dsp</tt>. À l'instant, j'écoute
        un MP3 (pas de Metallica bien sûr…) avec
        <span class="application">mp3blaster</span>.
        </p><pre class="screen">
    # lsof /dev/dsp
    COMMAND    PID USER   FD   TYPE DEVICE SIZE   NODE NAME
    mp3blaste 1108    p    6w   CHR   14,3      662302 /dev/dsp
    </pre><p><span><b class="command">fuser</b></span> est similaire, mais vous permet
        d'envoyer un signal à un processus quelconque accédant au fichier
        de périphérique. </p><pre class="screen">
    # fuser -vk /dev/dsp
    
                         USER        PID ACCESS COMMAND
    /dev/dsp             root       1225 f....  mp3blaster
                         root       1282 f....  mp3blaster
    </pre><p>Après avoir saisi la commande,
        <span class="application">mp3blaster</span> a été tué par un signal
        SIGKILL. Voyez les pages de manuel de <span><b class="command">lsof</b></span> et
        <span><b class="command">fuser</b></span> ; elles sont très utiles. Vous devrez
        les exécuter en tant que root car vous demandez des informations
        concernant des processus pouvant appartenir à root.
        </p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2503718"></a>8.2.4. Mauvais pilote (ou aucun pilote) utilisé</h4></div></div><div></div></div><p>Il n'y a que deux façons de configurer votre
        carte :</p><div class="orderedlist"><ol type="1"><li><p>La prise en charge doit être compilée directement
          dans le noyau</p></li><li><p>Le bon pilote doit être chargé en mémoire</p></li></ol></div><p>Vous pouvez trouver quel pilote utilise votre carte son en
        utilisant <span><b class="command">lsmod</b></span> ou en examinant la sortie de
        <span><b class="command">dmesg</b></span>. Étant donné que le son est de première
        importance pour moi, je le compile toujours dans mes noyaux. Si
        aucun pilote n'est chargé, vous devez déterminer ce qui a été
        compilé dans votre noyau. Ce n'est pas si facile. Il vaut mieux
        compiler votre noyau. À propos, sachez que la compilation de
        votre propre noyau est la première étape vers la compétence sous
        Linux. C'est pénible la première fois, mais une fois que c'est fait
        correctement, cela devient très facile, en particulier si vous
        conservez tous vos anciens fichiers <tt class="filename">.config</tt> et
        utilisez des choses comme <b class="userinput"><tt>make oldconfig</tt></b>.
        Voyez le « <span class="quote">Guide pratique du noyau Linux</span> »
        (<a href="http://www.traduc.org/docs/howto/lecture/Kernel-HOWTO.html" target="_top"><span class="foreignphrase"><i class="foreignphrase">Kernel-HOWTO</i></span></a>)
        pour les détails.
        </p><p>Si vous n'avez pas compilé votre noyau vous-même, il est très
        probable que votre système soit configuré de sorte à charger les
        pilotes son sous forme de modules. C'est ainsi que fonctionnent les
        distributions. Compilez tout ce qui est possible sous forme de
        module et essayez de les charger tous. Ainsi, si vous ne voyez pas
        le pilote de votre carte son avec <span class="application">lsmod</span>,
        votre carte n'est probablement pas encore configurée.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2503838"></a>8.2.5. Problème de permissions</h4></div></div><div></div></div><p>Si la carte son ne fonctionne que lorsque vous êtes root,
        vous avez probablement un problème de permissions. Si c'est le cas,
        sous root, examinez le groupe propriétaire de la carte son en
        utilisant <b class="userinput"><tt>ls -l /dev/dsp</tt></b> ; il
        s'agira probablement de <tt class="literal">audio</tt>. Ensuite, sous
        root, ajoutez votre utilisateur non-root au groupe
        <tt class="literal">audio</tt> dans <tt class="filename">/etc/group</tt>. Par
        exemple, j'ai ajouté les utilisateurs <tt class="literal">toto</tt> et
        <tt class="literal">lulu</tt> au groupe <tt class="literal">audio</tt> sur mon
        système :</p><pre class="screen">
    audio:x:29:toto,lulu
    </pre><p>N'oubliez pas d'utiliser <span><b class="command">grpconv</b></span> si vous
        utilisez les mots de passe masqués (<span class="foreignphrase"><i class="foreignphrase">shadow
        passwords</i></span>), ce qui devrait être le cas sur la
        plupart des distributions récentes, afin de préserver une
        configuration de groupes cohérente. Ensuite, déconnectez-vous et
        reconnectez-vous comme utilisateur normal. Votre carte son devrait
        fonctionner à présent. Merci à <span class="firstname">James
        </span> <span class="surname">Barton</span> pour m'avoir
        rappelé d'ajouter ceci à ce guide.</p></div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2503945"></a>9. Problèmes divers</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2503950"></a>9.1. Problèmes d'accélération matérielle</h3></div></div><div></div></div><p><span class="application">XFree86</span> 4.x fournit une approche
      plus centralisée et plus autonome en ce qui concerne la vidéo.
      Beaucoup des joyeusetés comme les modules noyau pour un accès non
      root aux cartes vidéo ont, heureusement, disparu.</p><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2503971"></a>9.1.1. L'accélération matérielle ne fonctionne pas du
      tout</h4></div></div><div></div></div><p>Si vous obtenez quelque chose comme 1 image par seconde,
        alors votre système n'utilise pas d'accélération matérielle 3D.
        Voici deux causes possibles :</p><div class="orderedlist"><ol type="1"><li><p>votre système 3D est mal configuré (très
          probable) ;</p></li><li><p>le jeu X est mal configuré (moins
          probable).</p></li></ol></div><p>La première étape est déterminer ce qui se passe.</p><div class="orderedlist"><ol type="1"><li><p>Si vous utilisez X 4.0 (les utilisateurs de X 3.*
            passeront à l'étape 2), regardez la sortie de la commande
            <b class="userinput"><tt>X -probeonly</tt></b>. Vous verrez :</p><pre class="screen"> (II) XXXXXX: direct rendering enabled </pre><p> ou </p><pre class="screen"> (II) XXXXXX: direct rendering disabled </pre><p>où XXXXXXX dépend de la carte vidéo que vous possédez. Si
            le rendu direct est désactivé, alors votre configuration X est
            en cause, et pas le jeu. Vous devez déterminer pourquoi le DRI
            est désactivé. L'outil le plus important est le
            « <span class="quote">Guide de l'utilisateur DRI</span> »
            (<span class="foreignphrase"><i class="foreignphrase">DRI Users Guide</i></span>). C'est un
            document très bien écrit qui vous donne des informations pas à
            pas sur la façon de configurer correctement le DRI pour votre
            machine. Une copie est disponible sur <a href="http://www.xfree86.org/4.0/DRI.html" target="_top">http://www.xfree86.org/4.0/DRI.html</a>.</p><p>Notez que si vous réussissez ce test, votre système est
            <span class="emphasis"><em>capable</em></span> de faire du rendu direct. Vos
            bibliothèques peuvent toujours être en cause. Passez donc à
            l'étape 2. </p></li><li><p>Il existe un programme appelé
          <span><b class="command">glxgears</b></span> qui accompagne le paquet
          « <span class="quote">mesademos</span> ». Vous pouvez obtenir
          mesademos sous Debian (<span><b class="command">apt-get install
          mesademos</b></span>) ou vous pouvez chercher le rpm sur <a href="http://www.rpmfind.net" target="_top">http://www.rpmfind.net</a>. Vous pouvez également
          télécharger les sources depuis le site officiel de mesa et les
          compiler vous-même.</p><p>L'exécution de <span><b class="command">glxgears</b></span> montrera des
            pignons en rotation. La <span><b class="command">xterm</b></span> depuis
            laquelle vous exécutez <span><b class="command">glxgears</b></span> affichera
            « <span class="quote">X frames in Y seconds = X/Y FPS</span> » (X
            images en Y secondes). Vous pouvez comparer votre système avec
            la liste de bancs d'essais ci-dessous. </p><pre class="screen">
      CPU TYPE     VIDEO CARD     X VERSION    AVERAGE FPS
      </pre><p>Compiler les modules Mesa et DRI vous-même peut vous
            faire gagner 15 images par seconde, une grosse augmentation de
            performances ! Donc, si vous obtenez, disons, 20 images
            par seconde de moins qu'une machine comparable, il est possible
            que <span><b class="command">glxgears</b></span> utilise le rendu logiciel. En
            d'autres termes, votre carte graphique n'accélère pas les
            graphiques 3D.
            </p><p>Plus important encore que le nombre d'images par seconde,
            est la non-variation de ce nombre pour les petites et les
            grandes fenêtres. Si l'accélération matérielle fonctionne, le
            nombre d'images par seconde pour <span><b class="command">glxgears</b></span>
            devrait être pratiquement indépendant de la taille de fenêtre.
            Si ce n'est pas le cas, alors vous ne bénéficiez d'aucune
            accélération matérielle.
            </p></li></ol></div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2504221"></a>9.2. L'accélération matérielle ne fonctionne que pour
    root</h3></div></div><div></div></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2504227"></a>9.2.1. <span class="application">XFree86</span> 4.x</h4></div></div><div></div></div><p>Si les lignes suivantes ne sont pas présentes dans votre
        fichier <tt class="filename">XF86Config-4</tt>, placez-les
        y :</p><pre class="screen">
         Section "DRI"
                 Mode 0666
         EndSection
      </pre><p>Cela permet aux utilisateurs non-root d'utiliser le DRI. Pour
        les paranoïaques, il est possible de restreindre l'utilisation du
        DRI à seuls quelques utilisateurs non-root. Voyez le
        <span class="foreignphrase"><i class="foreignphrase">DRI User Guide</i></span>.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2504270"></a>9.2.2. <span class="application">XFree86</span> 3.x</h4></div></div><div></div></div><div class="sect4" lang="fr"><div class="titlepage"><div><div><h5 class="title"><a name="id2504279"></a>9.2.2.1. Cartes Voodoo</h5></div></div><div></div></div><p>L'accélération matérielle pour les cartes Voodoo a lieu
          <span class="emphasis"><em>uniquement</em></span> en couleurs 16 bits et échoue
          silencieusement lors du démarrage de X avec un autre nombre de
          couleurs.
        </p><p>De plus, les cartes Voodoo ont besoin du module noyau
          <tt class="filename">3dfx.o</tt> et d'un fichier de périphérique
          <tt class="filename">/dev/3dfx</tt> (majeur 107,
          mineur 0) pour l'accélération matérielle pour les utilisateurs
          normaux (non root). Ni le module ni le fichier de périphérique ne
          sont utilisés sous <span class="application">XFree86</span> 4.x.
          </p></div></div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2504334"></a>10. Émulation et machines virtuelles</h2></div></div><div></div></div><p>Linux est beaucoup critiqué du fait de l'absence de la profusion
    de jeux présents sous d'autres plates-formes. Franchement, il y a assez
    de jeux pour moi, même s'il serait très chouette d'avoir certains des
    jeux du dernier cri et des classiques comme
    <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Half-life</i></span></span>™ et
    <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Carmageddon</i></span></span>™.
    Heureusement, il y a plus d'émulateurs que vous ne pouvez en tester.
    Bien que jouer à un jeu émulé n'est pas aussi amusant que de le jouer
    sur la machine originale, et que faire fonctionner correctement
    certains émulateurs peut s'avérer difficile, ils existent, et il y en a
    beaucoup !</p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2504370"></a>10.1. Qu'est-ce qu'une machine virtuelle ?</h3></div></div><div></div></div><p>Un « <span class="quote">véritable ordinateur</span> » fournit
    beaucoup de choses à un système d'exploitation : CPU, canaux
    d'entrée-sortie, mémoire, un BIOS pour fournir un accès de bas niveau à
    la carte mère et aux ressources d'entrée-sortie, et cætera. Quand un système
    d'exploitation veut écrire sur un disque dur, il communique par
    l'intermédiaire d'un pilote de périphérique qui fait l'interface
    directe avec le matériel.</p><p>Néanmoins, il est possible de donner à un programme toutes les
    ressources matérielles dont il a besoin. Quand il veut accéder à un
    disque dur, donnons-lui de la mémoire où écrire. Quand il veut
    attribuer une IRQ, donnons-lui l'impression d'avoir attribué une IRQ.
    Si vous faites ceci correctement alors, en principe, la pauvre
    application est incapable de savoir si elle accède réellement au
    matériel ou si on la trompe en lui donnant des ressources qui simulent
    le matériel. Une machine virtuelle est l'environnement qui trompe les
    applications en leur faisant croire qu'elles tournent sur une machine
    réelle. Elle fournit tous les services offerts par un véritable
    ordinateur.</p><p>Les machines virtuelles ont été à l'origine utilisées dans les
    années 1960 pour émuler les systèmes d'exploitation à temps partagé. De
    nos jours, nous les utilisons pour exécuter des logiciels qui ont été
    conçus pour des systèmes d'exploitation différents, ou plus
    communément, pour émuler un système d'exploitation entier. Du fait de
    la nature des machines virtuelles, le système d'exploitation étranger
    ne peut faire la différence entre fonctionnement à l'intérieur d'une
    machine virtuelle et fonctionnement dans une
    « <span class="quote">vraie</span> » machine.
    </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2504444"></a>10.2. Apple 8 bits</h3></div></div><div></div></div><p>Tous les émulateurs Apple ][ 8 bits requièrent une copie de la
      ROM originale, quel que soit le système que vous voulez émuler, dans
      un fichier. Si vous cherchez suffisamment bien, vous pouvez trouver
      des copies des ROM pour les Apple ][, ][+, ][e, ][c et //gs. Ils sont
      toujours propriété de Apple, et vous ne pouvez les utiliser
      légalement que si vous possédez réellement un de ces ordinateurs.
      </p><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2504462"></a>10.2.1. KEGS</h4></div></div><div></div></div><p><span class="application">KEGS</span>, de <span class="firstname">Kent </span> <span class="surname">
        Dickey</span> <tt class="email">&lt;<a href="mailto:kentd%20CHEZ%20cup%20POINT%20hp%20POINT%0A%20%20%20%20%20%20%20%20com">kentd CHEZ cup POINT hp POINT
        com</a>&gt;</tt>, est un émulateur Apple II qui a été écrit à l'origine
        pour HP-UX, mais amélioré et taillé pour Linux. Il tourne sous X
        pour n'importe quel nombre de couleurs, et supporte des tailles de
        mémoire variables, les joysticks et le son.
        <span class="application">KEGS</span> amorce toutes les variantes de
        Apple II, et prend en charge tous les modes graphiques des Apple
        ][. Je n'arrive pas à trouver de page d'accueil pour cette
        application.
        </p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2504511"></a>10.2.2. apple2 et xapple2</h4></div></div><div></div></div><p><span class="application">apple2</span> basé sur SVGAlib et
        <span class="application">xapple2</span> utilisant X peuvent émuler
        n'importe quelle variante de Apple ][ sauf le //gs. L'interface est
        assez originale, mais utilisable. La configuration est aussi un peu
        étrange ; cet émulateur bénéficierait d'un outil de
        configuration basé sur SVGA ou X. Il supporte la partie non
        documentée du jeux d'instructions 6502 sur laquelle se basent
        certains jeux. <span class="application">apple2</span> est actuellement
        maintenu par <span class="firstname">Michael</span> <span class="surname">
        Deutschmann</span> <tt class="email">&lt;<a href="mailto:michael%20CHEZ%20talamasca%0A%20%20%20%20%20%20%20%20POINT%20ocis%20POINT%20net">michael CHEZ talamasca
        POINT ocis POINT net</a>&gt;</tt> et semble être développé à une allure
        lente mais constante. Je ne pense pas que cette application ait une
        page d'accueil. </p></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2504571"></a>10.3. DOS</h3></div></div><div></div></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="dosemu"></a>10.3.1. <span class="application">dosemu</span></h4></div></div><div></div></div><p><a href="http://www.dosemu.org" target="_top"><span class="application">dosemu</span></a>
        est l'émulateur DOS canonique sous Linux. Quand vous pensez à DOS,
        ne pensez pas à des choses comme PROCOM PLUS OU D'AUTRES PROGRA~1
        QUI ONT DES NOMS COURTS ET QUI SONT TOUS EN MAJUSCULES. Quelques
        classiques ont été écrits pour DOS comme
        <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Carmageddon</i></span></span>™,
        <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Redneck
        Rampage</i></span></span>™ et
        <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Tomb
        Raider</i></span></span>™.
        <span class="application">dosemu</span> peut les faire tourner.
        Malheureusement, il peut être malaisé de le faire fonctionner et,
        depuis janvier 2002, le code audio est quelque peu défectueux. Pas
        un gros problème si vous essayez d'exécuter
        <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Wordperfect</i></span></span>™
        ou une vieille application de base de données, mais ça empêche de
        jouer en pratique. Parvenir à faire fonctionner correctement
        <span class="application">dosemu</span> n'est pas facile, mais c'est
        malheureusement le mieux qu'on puisse faire pour les jeux DOS.
        Bonne chance. Si vous utilisez avec succès
        <span class="application">dosemu</span>, prévenez-moi.
        </p></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2504676"></a>10.4. Win16</h3></div></div><div></div></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2504681"></a>10.4.1. Wabi</h4></div></div><div></div></div><p><span class="application">Wabi</span> est un émulateur Win16
         commercial, c.-à-d. qu'il exécute des applications Windows 16 bits
         prévues pour un environnement Windows 3.1, Windows 3.11 ou Windows
         for Workgroups 3.11. <span class="application">Wabi</span> a été
         initialement créé par SCO Unix il y a longtemps et a été acheté
         par Caldera un beau jour vers la mi-2001. </p><p><span class="application">Wabi</span> est rapide et fait bien son
        boulot, même si j'ai entendu dire qu'il est plus stable sous
        Solaris que sous Linux. Il pourrait être utile pour jouer à de plus
        anciens jeux Win16, mais il y a trois problèmes :</p><div class="itemizedlist"><ul type="disc"><li><p>vous devez posséder une copie légale de Windows
          3.1/3.11 ou de Windows for Workgroups 3.11 ; </p></li><li><p><span class="application">Wabi</span> est affreusement
          cher pour ce qu'il fait ;</p></li><li><p>Wabi ne fonctionne pas en couleurs 24 ou 32 bits.
          </p></li></ul></div><p><span class="application">Wabi</span> ne gère
        <span class="emphasis"><em>pas</em></span> DOS par lui-même, mais il semble qu'il
        puisse utiliser un émulateur DOS comme dorsal pour exécuter des
        programmes DOS. On a parlé d'un <span class="application">Wabi</span> 3.0
        qui aurait effectué de l'émulation Win32, mais pour autant que je
        sache, ce projet est tombé aux oubliettes. Je pense que Wabi
        fonctionne sous Linux sur toutes les architectures (quelqu'un
        peut-il le vérifier ?).</p></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="win32"></a>10.5. Win32</h3></div></div><div></div></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="wine"></a>10.5.1. <span class="application">wine</span></h4></div></div><div></div></div><p><a href="http://www.winehq.com" target="_top"><span class="application">wine</span></a>,
        qui porte l'acronyme GNUide de <span class="foreignphrase"><i class="foreignphrase">Wine Is Not An
        Emulator</i></span> (Wine n'est pas un émulateur) est une
        implémentation non commerciale de l'API Win32. La raison pour
        laquelle ce n'est pas un émulateur est subtile et pas du plus grand
        intérêt pour la plupart des non-informaticiens, et nous parlerons
        donc d'émulateur ici (il s'agit en fait d'une traduction au moment
        de l'exécution des appels de l'API Win32 en appels POSIX/X11).
        <span class="application">wine</span> a beaucoup évolué, et est capable
        d'émuler beaucoup de jeux importants, ce qui est une bonne nouvelle
        pour les utilisateurs Linux intéressés.</p><p><span class="application">wine</span> ne fournit <tt class="literal">pas</tt> d'API DOS, et vous ne pouvez donc pas
        l'utiliser pour exécuter des applications DOS. Pour cela, vous
        devriez jeter un œil à <a href="#dosemu" title="10.3.1. dosemu"><span class="application">dosemu</span></a>.
        <span class="application">wine</span> n'a jamais très bien implémenté
        DirectX, bien que quelques jeux fonctionnent sous
        <span class="application">wine</span>. Pour les jeux, vous devriez vous
        tourner vers <a href="#winex" title="10.5.3. winex"><span class="application">winex</span></a>. </p><p>En plus de la traduction au moment de l'exécution de l'API
        Win32 vers POSIX/X11 (il exécute des applications Windows sous
        Linux), <span class="application">wine</span> effectue également une
        traduction au moment de la compilation de l'API Win32 vers
        POSIX/X11 (il compile le code source d'une application Windows sous
        Linux). Vu sous cet angle, <span class="application">wine</span> est un
        utilitaire de portage Windows-vers-Linux. L'architecture x86 n'est
        pas requise, mais est recommandée car elle permet une exécution
        binaire x86 réelle ainsi qu'une utilisation directe des DLL.
        </p><p>Vous pouvez utiliser <span class="application">wine</span>
        « <span class="quote">avec Windows</span> », ce qui signifie qu'il
        utilise des bibliothèques qui proviennent en réalité de Microsoft
        Windows lui-même. Cela n'est légal que si vous possédez une copie
        de Windows qui n'est pas actuellement utilisée sur un ordinateur.
        On dit que <span class="application">wine</span> fonctionne le mieux
        quand il est exécuté avec Windows. Vous pouvez également utiliser
        <span class="application">wine</span> sans Windows. Les gens de <a href="http://www.winehq.com" target="_top">winehq</a> écrivent leur propre jeu
        de bibliothèques appelé <tt class="literal">libwine</tt> qui implémente
        l'API Win32 sans aucun code provenant de Microsoft. </p><p>
        
        <a name="winelicense"></a><span class="application">wine</span> était
        à l'origine placé sous licence MIT/X11, et pouvait donc être
        utilisé à la fois à des fins commerciales et non commerciales.
        À la mi-2002, des parties de
        <span class="application">wine</span> sont passées à la LGPL afin de
        ne plus pouvoir être utilisées à des fins commerciales. Cela
        pose un problème à des sociétés comme Transgaming (<a href="#winex" title="10.5.3. winex">Section 10.5.3, « winex »</a>) et a ouvert la voie à un nouveau projet issu
        de <span class="application">wine</span> appelé <a href="#rewind" title="10.5.2. rewind"><span class="application">ReWind</span></a>.
        
        </p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="rewind"></a>10.5.2. <span class="application">rewind</span></h4></div></div><div></div></div><p><a href="http://rewind.sourceforge.net/" target="_top"><span class="application">rewind</span></a>
        a été démarré par <span class="firstname">Éric
        </span> <span class="surname">Pouech</span> (un développeur
        de <span class="application">wine</span>) et <span class="firstname">Ove</span> <span class="surname"> Kåven</span>
        (un développeur de <span class="application">winex</span>) en réponse au
        <a href="#winelicense">changement de licence de
        <span class="application">wine</span></a>. Il a vu le jour comme un
        instantané de la dernière version de
        <span class="application">wine</span> complètement placée sous la licence
        MIT/X11. Le but est que <span class="application">rewind</span> demeure
        sous licence MIT/X11 afin que des sociétés comme Transgaming
        puissent offrir des produits dérivés de
        <span class="application">wine</span>.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="winex"></a>10.5.3. <span class="application">winex</span></h4></div></div><div></div></div><p><span class="application">winex</span> est publié par une société
        appelée <a href="http://www.transgaming.com" target="_top">Transgaming</a>. Ses
        développeurs utilisent <a href="#wine" title="10.5.1. wine"><span class="application">wine</span></a> et y ajoutent
        le support DirectX/DirectDraw. Bien que
        <span class="application">winex</span> soit commercial, leur modèle
        économique est intéressant. </p><p>L'utilisateur final (vous) peut télécharger le code source
        gratuitement. Néanmoins, pour 5 $ US par mois, vous pouvez
        devenir un abonné de Transgaming, ce qui procure trois avantages
        principaux :</p><div class="itemizedlist"><ul type="disc"><li><p>Les abonnés peuvent à tout moment télécharger des
          versions empaquetées de <span class="application">winex</span> dans le
          format <tt class="filename">deb</tt>, <tt class="filename">rpm</tt> ou <tt class="filename">tar.gz</tt> (y compris les mises à jour).
          Elles sont également plus fonctionnelles que le source
          publiquement disponible : celui-ci est une version
          antérieure qui ne dispose pas de certaines des fonctionnalités
          les plus récentes, comme la prise en charge des programmes
          protégés contre la copie.</p></li><li><p>Les utilisateurs abonnés peuvent indiquer lors de
          sondages mensuels quels sont les points qu'il faut améliorer en
          priorité dans <span class="application">winex</span>. Par exemple, ils
          peuvent voter pour des choses comme « <span class="quote">Améliorer la
          prise en charge des programmes protégés contre la
          copie</span> », « <span class="quote">Meilleur support
          d'Installshield</span> » ou « <span class="quote">Améliorer la prise
          en charge de DirectX 8.0</span> ». Il me semble que les
          développeurs écoutent réellement les sondages.</p></li><li><p>Le site web de Transgaming comporte quelques
          forums d'assistance aux utilisateurs. D'un côté, ils utilisent le
          format le plus affreux, horrible, confus, dispendieux et idiot
          qu'il m'ait été donné de voir, et j'espère bien ne plus jamais
          revoir de forum ayant un format aussi mauvais que celui de
          Transgaming. D'un autre côté, vous pouvez demander de l'aide et
          les développeurs sont <span class="emphasis"><em>très</em></span> bons pour trouver
          une réponse à votre question ; leur vigilance est assez
          impressionnante. Les non abonnés peuvent parcourir les forums,
          mais seuls les abonnés peuvent y écrire (et, par conséquent, y
          demander de l'aide).</p></li></ul></div><p>Les développeurs de <span class="application">winex</span> avaient
        l'intention de publier périodiquement leurs améliorations à
        Installshield, DirectX et DirectDraw dans
        <span class="application">wine</span>. En contrepartie, au fur et à
        mesure de la maturation de <span class="application">wine</span>, les
        développeurs de <span class="application">winex</span> auraient pris les
        nouvelles versions de <span class="application">wine</span> pour les
        utiliser dans <span class="application">winex</span>. Néanmoins, depuis
        la naissance de Transgaming, des parties de
        <span class="application">wine</span> sont <a href="#winelicense">passées à la licence plus restrictive GNU
        LGPL</a>. Cela signifie en gros que les versions de
        <span class="application">wine</span> publiées après la date du
        changement de licence ne peuvent plus être utilisées par
        <span class="application">winex</span>. Par conséquent,
        <span class="application">winex</span> sera à présent basé sur <a href="#rewind" title="10.5.2. rewind"><span class="application">rewind</span></a>.
        </p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="win4lin"></a>10.5.4. Win4Lin</h4></div></div><div></div></div><p><a href="http://www.netraverse.com" target="_top"><span class="application">Win4Lin</span>
        </a> est un produit commercial de Netraverse. Comme <a href="#vmware" title="10.5.5. VMWare"><span class="application">vmware</span></a>, il
        utilise l'approche de la machine virtuelle pour exécuter des
        applications Windows, et affiche donc une grande fenêtre depuis
        laquelle vous pouvez démarrer Windows et exécuter toutes sortes
        d'applications Windows. À la différence de
        <span class="application">vmware</span>,
        <span class="application">Win4Lin</span> ne prend en charge que Windows
        95/98/ME, mais cela s'avère être mieux pour les joueurs. Puisque
        <span class="application">Win4Lin</span> se concentre sur ces systèmes
        d'exploitation, on dit qu'il est plus rapide et exécute mieux les
        jeux sous ces systèmes d'exploitation que
        <span class="application">vmware</span>. Il est également bien moins cher
        que ce dernier. <span class="application">Win4Lin</span>, dont la version
        la plus récente au 30 juin 2003 est la 5.0, souffre néanmoins de
        certaines limitations :</p><div class="itemizedlist"><ul type="disc"><li><p>Il ne prend pas en charge DirectX ou DirectDraw,
          alors que <span class="application">vmware</span> a un support
          « <span class="quote">limité</span> » pour DirectX. </p></li><li><p>Il ne prend en charge que les périphériques série
          et parallèle. C'est important pour ceux qui utilisent des
          joysticks USB. Notez que <span class="application">vmware</span> peut
          gérer jusqu'à 2 périphériques USB. </p></li><li><p>Au 30 juin 2003, comptez 89.99 $ sans
          documentation imprimée et 99.99 $ avec. De plus, il n'y a
          pas de copie d'évaluation disponible, bien qu'il y ait une
          garantie de remboursement sous 30 jours. Néanmoins, puisque c'est
          commercial, vous avez le support technique.
          <span class="application">vmware</span> est beaucoup plus cher. </p></li><li><p>Comme pour <span class="application">vmware</span>,
          vous devez posséder une copie autorisée de Win95 ou Win98.
          <span class="application">Win4Lin</span> ne peut utiliser une
          installation existante de Windows à la manière de
          <span class="application">wine</span>. </p></li><li><p>Il ne tourne que sur les architectures x86.
          </p></li></ul></div></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="vmware"></a>10.5.5. VMWare</h4></div></div><div></div></div><p><a href="http://www.vmware.com" target="_top"><span class="application">VMWare</span></a>
        est une machine virtuelle qui peut exécuter plusieurs systèmes
        d'exploitation simultanément sur un PC standard : les systèmes
        d'exploitation pris en charge comprennent ceux de Microsoft, Linux,
        Novell Netware et FreeBSD. Vous pouvez entre autres l'utiliser pour
        exécuter un système d'exploitation MS Windows et y lancer votre jeu
        favori. Vous pouvez même faire tourner Linux sous Linux ;
        utile par exemple si vous voulez tester une autre distribution.
        Stupéfiant ! Mais il y a des mauvais côtés. Vous devriez
        assurément disposer d'une bonne configuration pour
        l'utiliser ; le minimum annoncé est un CPU x86 500 Mhz
        avec 128 Mo de RAM, mais un processeur plus rapide avec au
        moins 256 Mo de RAM semble le minimum absolu si vous désirez
        des performances raisonnables. Toutes les distributions Linux ne
        sont pas prises en charge : les dernières RedHat, Mandrake et
        Suse le sont, mais c'est pas de chance si vous avez une autre
        version et/ou distribution (comme Debian). De plus, la prise en
        charge par <span class="application">vmware</span> de DirectX est
        limitée, et vous pourriez ne pas pouvoir jouer à des jeux
        récents.</p><p>Voyez <a href="http://www.vmware.com" target="_top">http://www.vmware.com</a> pour plus
        d'informations. Ce n'est pas bon marché (environ 300 $ pour la
        version Workstation), mais vous pouvez obtenir une version
        d'évaluation limitée à 30 jours.</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2505674"></a>10.5.6. Que choisir ?</h4></div></div><div></div></div><p>En premier lieu, vous devriez essayer un émulateur. Bien que
        certains jeux fonctionnent sous <a href="#wine" title="10.5.1. wine">wine</a>,
        vous aurez probablement le plus de succès avec <a href="#winex" title="10.5.3. winex">winex</a> : sa prise en charge de DirectX
        s'améliore constamment. Dans la version 3.1, la prise en charge de
        DirectX 8 est quasiment achevée, mais ce n'est pas forcément le cas
        des versions plus anciennes de DirectX (et donc des jeux plus
        anciens).</p><p>Vous pourriez également essayer une machine virtuelle comme
        <a href="#win4lin" title="10.5.4. Win4Lin">Win4Lin</a> ou <a href="#vmware" title="10.5.5. VMWare">VMWare</a> au lieu d'un émulateur. Si votre but
        est d'exécuter des applications Win95/98/ME sous Linux, sans USB et
        sur l'architecture x86, le coût et le centrage sur les systèmes
        d'exploitation de type Win95 de <span class="application">Win4Lin</span>
        en font un meilleur choix que <span class="application">vmware</span>.
        Néanmoins, si vous devez avoir la prise en charge de l'USB ou
        exécuter Linux sur une plate-forme autre que x86,
        <span class="application">vmware</span> est votre seule
        possibilité.</p><p>Maintenant, si votre but est d'exécuter des jeux pour des
        systèmes d'exploitation de type Win95 sous Linux,
        <span class="application">Win4Lin</span> semble presque toujours meilleur
        que <span class="application">vmware</span>. Le plus gros problème est
        que <span class="application">vmware</span> a un support limité de
        DirectX alors que <span class="application">Win4Lin</span> n'en a aucun.
        Ce fait seul rend tant <span class="application">Win4Lin</span> que
        <span class="application">vmware</span> inutilisables pour la plupart des
        jeux un tant soit peu évolués. Mais si vous voulez essayer, vous
        aurez probablement plus de succès avec
        <span class="application">vmware</span>.
        </p></div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="interpreters"></a>11. Interpréteurs</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2505833"></a>11.1. Moteur SCUMM (LucasArts)</h3></div></div><div></div></div><p>Lucasarts a écrit un moteur pour les aventures pilotées à la
      souris nommé SCUMM (<span class="foreignphrase"><i class="foreignphrase">Script Creation Utility for Maniac
      Mansion</i></span>). Ils ont écrit beaucoup d'aventures
      graphiques en utilisant SCUMM, comme leur célèbre série
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Monkey
      Island</i></span></span>™ (tous les trois). <span class="firstname">Ludvig</span> <span class="surname">
      Strigeus</span> <tt class="email">&lt;<a href="mailto:strigeus%20CHEZ%20users%20POINT%0A%20%20%20%20%20%20sourceforge%20POINT%20net">strigeus CHEZ users POINT
      sourceforge POINT net</a>&gt;</tt> a pu utiliser la rétro-ingénierie pour
      comprendre le format SCUMM et écrire un interpréteur pour les jeux
      l'utilisant qui compile sous Linux et Win32. Il s'agit de <a href="http://scummvm.sourceforge.net/" target="_top"><span class="application">scummvm</span></a>.
      Leur site web est très bon, et regorge d'informations sur SCUMM et
      l'utilisation de <span class="application">scummvm</span> pour ce type de
      jeux.</p><p>Une page de compatibilité peut être trouvée sur le site web de
      <span class="application">scummvm</span>. Ça vaut ce que ça vaut, mais j'ai
      pu finir beaucoup des jeux qui sont listés à 90 % sans le
      moindre problème. <span class="application">scummvm</span> est très
      robuste, et vous permet d'acheter des jeux Lucas Arts utilisant le
      format SCUMM, copier les fichiers de données sur votre disque dur et
      les jouer sous Linux. En février 2002, j'ai suivi leur CVS, et ce
      projet subit un développement constant. Gloire à l'équipe de
      <span class="application">scummvm</span>. </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2505937"></a>11.2. AGI : Adventure Gaming Interface (Sierra)</h3></div></div><div></div></div><p>Les anciens jeux d'aventures graphiques DOS de Sierra
      utilisaient un langage de script appelé AGI (<span class="foreignphrase"><i class="foreignphrase">Adventure
      Gaming Interface</i></span>). Quelques jeux écrits en AGI :
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Leisure Suit Larry
      I</i></span></span>™ (EGA),
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Space Quest
      I</i></span></span>™, <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Space
      Quest II</i></span></span>™,
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">King's Quest
      II</i></span></span>™,
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Mixed-Up Mother
      Goose</i></span></span>™, et cætera. On peut y jouer en
      utilisant <a href="http://sarien.sourceforge.net" target="_top"><span class="application">sarien</span></a>,
      un interpréteur <span class="foreignphrase"><i class="foreignphrase">open source</i></span> pour les
      jeux AGI. </p><p>Sarien a été écrit en SDL, et devrait donc tourner sur toute
      plate-forme qui peut compiler des programmes SDL. De plus, il y a des
      versions pour DOS, les PDA utilisant Strong-Arm, QNX (mon dieu !
      du jeu embarqué !), les systèmes à base de MIPS et les Pocket PC
      à base de SH3/4. Les développeurs ont clairement perdu la tête (d'une
      bonne façon !). Sarien propose de nombreuses améliorations non
      trouvées dans les jeux originaux, comme une console déroulante du
      genre de celle de Quake, un visualisateur d'images et de
      dictionnaire, un son amélioré et la prise en charge de AGDS, un clone
      russe de AGI. Sarien est en cours de développement et les
      développeurs ont très bien documenté la conception interne de Sarien
      si jamais quelqu'un veut s'impliquer dans son développement. </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2506008"></a>11.3. SCI : SCript Interpreter ou Sierra Creative
    Interpreter (Sierra)</h3></div></div><div></div></div><p>Les jeux d'aventures graphiques plus récents de Sierra (c.-à-d.
      de la fin des années 80) utilisaient un interpréteur appelé SCI. Il y
      a beaucoup de versions de SCI puisque Sierra a constamment amélioré
      son moteur. Les premiers jeux SCI s'exécutaient sous DOS, mais Sierra
      s'est finalement tourné vers Win32. Quelques exemples de jeux écrits
      avec SCI : <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Leisure Suit Larry
      1</i></span></span>™ (VGA),
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Leisure Suit Larry
      2-7</i></span></span>™, <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Space
      Quest 3-6</i></span></span>™,
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">King's Quest
      4-6</i></span></span>™, <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Quest
      For Glory 1-4</i></span></span>™ et beaucoup d'autres.
      Comparées aux jeux AGI, les aventures SCI ont une meilleure prise en
      charge de la musique, un moteur plus complexe et des tas de
      fioritures.</p><p>Beaucoup de jeux utilisant SCI (écrits en SCI0) peuvent être
      joués en utilisant <span class="application">freesci</span>, disponible sur
      <a href="http://freesci.linuxgames.com" target="_top">http://freesci.linuxgames.com</a>. Comme
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Sarien</i></span></span>™,
      FreeSCI peut utiliser beaucoup de cibles graphiques incluant SDL,
      xlib et GGI, de sorte que ce programme peut compiler et s'exécuter
      sous un nombre incroyable de plates-formes. Les développeurs ont très
      bien documenté leur application. </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="infocom"></a>11.4. Infocom Adventures (Infocom,
    Activision)</h3></div></div><div></div></div><p>La <a href="http://www.gnelson.demon.co.uk/zspec/index.html" target="_top">Z-machine</a>
      est une machine virtuelle bien documentée conçue par Infocom pour
      exécuter leurs jeux de fiction interactive. Cela leur permet d'écrire
      des fichiers de données de jeu d'une façon multi-plates-formes, car
      seul le moteur lui-même, la Z-machine, est dépendant de la
      plate-forme. La Z-machine a subi différentes évolutions durant la vie
      de Infocom, et deux révisions supplémentaires (V7 et V8 créées par
      <span class="firstname">Graham</span> <span class="surname">
      Nelson</span>) après la mort de Infocom. Les versions
      ultérieures disposaient même d'une prise en charge limitée du son et
      des graphiques !
      </p><p>Un des interpréteurs de Z-machine parmi les plus populaires est
      <a href="http://www.cs.csubak.edu/~dgriffi/proj/frotz/" target="_top"><span class="application">Frotz</span></a>.
      Leur excellente page d'accueil regorge de liens sympas pour les
      amateurs de fiction interactive. <span class="application">Frotz</span> est
      placé sous GPL, exécute toutes les versions de la Z-machine et
      compile sur la plupart des versions de Unix. Frotz est à l'origine de
      nombreuses variantes, comme une version pour PalmOS et les PDA à base
      de Linux.</p><p><a href="http://jzip.sourceforge.net/" target="_top"><span class="application">jzip</span></a>
      est un autre interpréteur de Z-machine très populaire qui exécute les
      fichiers de données des Z-machine V1-V5 et V8.
      <span class="application">jzip</span> est très portable ; il compile
      sous tous les Unix, OS/2, Atari ST et DOS.</p><p>Il y a en fait beaucoup d'autres interpréteurs de Z-machine
      comme <span class="application">nitfol</span> et
      <span class="application">rezrov</span> (écrit en Perl !). Chaque
      interpréteur a ses points forts, et vous pouvez trouver des liens les
      référençant sur les pages d'accueil de
      <span class="application">Frotz</span> et <span class="application">jzip</span>.
      </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="scottadams"></a>11.5. Scott Adams Adventures (Adventure
    International)</h3></div></div><div></div></div><p>On peut dire que <span class="firstname">Scott</span> <span class="surname"> Adams</span> est le père de la fiction
      interactive. Bien qu'il ait lui-même été inspiré par la première
      œuvre de fiction interactive,
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Adventure</i></span></span>™,
      Scott a propulsé l'aventure au devant de la scène. Ses jeux étaient
      disponibles pour Atari, Apple 2, Commodore, Sorcerer, TI et CPM. Sa
      société, Adventure International, a publié quelques jeux très
      appréciés entre 1978 et 1984 avant d'arrêter. Elle a récemment publié
      un nouveau jeu (une version Linux n'est pas disponible) mais depuis
      le déclin du jeu d'aventure, elle s'est plutôt tenue à l'écart de
      l'industrie du jeu.
      </p><p><span class="firstname">Alan</span> <span class="surname">
      Cox</span> a écrit
      <span class="application">scottfree</span>, un interpréteur de fichier de
      jeux d'aventure du type Scott Adams pour Unix. En utilisant
      <span class="application">scottfree</span> et l'un des fichiers de données
      du type Scott Adams qui peuvent être téléchargés depuis le <a href="http://www.msadams.com/" target="_top">site web de Scott</a>, vous pouvez
      vous délecter de ces classiques.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2506340"></a>11.6. Ultima Underworld : The Stygian Abyss (Origin, Blue
    Sky Productions)</h3></div></div><div></div></div><p>Le projet <a href="http://uwadv.sourceforge.net/" target="_top">Underworld
      Adventures</a> est un effort visant à porter le classique de
      1992, <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Ultima Underworld: The Stygian
      Abyss</i></span></span>™ sur des systèmes d'exploitation
      modernes comme Linux, MacOS X et Windows. Il utilise OpenGL pour les
      graphiques 3D, SDL pour les tâches spécifiques à la plate-forme et
      est publié sous la GNU GPL. Underworld Adventures fournit un système
      graphique impressionnant qui utilise les fichiers de jeu originaux,
      et vous avez donc besoin du disque de jeu original pour jouer.</p><p>Underworld Adventures offre également un tas d'outils pour
      afficher les cartes de niveaux, examiner les scripts de conversation
      uw1 et bien d'autres choses.</p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="exult"></a>11.7. Ultima 7 (Origin, Electronic Arts)</h3></div></div><div></div></div><p><span class="productname"><span class="foreignphrase"><i class="foreignphrase">Ultima
      7</i></span></span>™ en en fait constitué de 2 jeux :
      la partie I (<span class="productname"><span class="foreignphrase"><i class="foreignphrase">The Black
      Gate</i></span></span>™) et la partie II
      (<span class="productname"><span class="foreignphrase"><i class="foreignphrase">Serpent
      Island</i></span></span>™) qui utilise une version
      légèrement améliorée du moteur de <span class="productname"><span class="foreignphrase"><i class="foreignphrase">The
      Black Gate</i></span></span>™. De plus, une disquette
      additionnelle a été publiée à la fois pour la partie I
      (<span class="productname"><span class="foreignphrase"><i class="foreignphrase">The Forge Of
      Virtue</i></span></span>™) et la partie II
      (<span class="productname"><span class="foreignphrase"><i class="foreignphrase">The Silver
      Seed</i></span></span>™). </p><p>Une équipe a développé <a href="http://exult.sourceforge.net/" target="_top"><span class="application">exult</span></a>,
      un interpréteur <span class="foreignphrase"><i class="foreignphrase">open source</i></span> permettant
      d'exécuter les deux parties de <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Ultima
      7</i></span></span>™ et leurs disquettes additionnelles.
      <span class="application">Exult</span> est écrit en C++ et utilise SDL, et
      compilera donc sur toute plate-forme pouvant compiler des programmes
      SDL. Il offre également certaines améliorations par rapport aux
      versions originales du moteur de <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Ultima
      VII</i></span></span>™. Vous devrez acheter une copie de
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Ultima 7</i></span></span>™
      pour pouvoir jouer. Les développeurs n'ont pas l'intention d'étendre
      <span class="application">Exult</span> pour interpréter les autres Ultima
      étant donné que les moteurs ont changé radicalement entre les
      différentes versions. </p><p>L'équipe d'<span class="application">Exult</span> a également
      travaillé dur pour créer un éditeur de niveaux,
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Exult
      Studio</i></span></span>™, et un compilateur de scripts
      qui permettra aux utilisateurs de créer leurs propres RPG dans le
      style
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Ultima</i></span></span>™.
      </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2506547"></a>11.8. System Shock (Electronic Arts, Origin)</h3></div></div><div></div></div><p><span class="productname"><span class="foreignphrase"><i class="foreignphrase">System
      Shock</i></span></span>™ est un jeu de combat à la
      première personne/aventure classique datant de 1994, ce qui le place
      en contemporain de
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Doom</i></span></span>™.
      Néanmoins, son moteur est beaucoup plus évolué que celui du
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Doom</i></span></span>™
      original : par exemple, <span class="productname"><span class="foreignphrase"><i class="foreignphrase">System
      Shock</i></span></span>™ disposait d'acteurs
      (<span class="foreignphrase"><i class="foreignphrase">sprites</i></span>) 3D, d'un angle de vue
      modifiable (à la souris), et de la possibilité d'empiler des objets,
      donnant l'illusion d'une carte 3D complète, comme
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Quake</i></span></span>™. Les
      critiques que j'en ai lues sont très positives. Elles concordent pour
      dire que ce jeu a les fonctionnalités de
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Quake</i></span></span>™ avec
      une intrigue et un scénario plus convaincants que
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Half-life</i></span></span>™.
      Le moteur de <span class="productname"><span class="foreignphrase"><i class="foreignphrase">System
      Shock</i></span></span>™ était optimisé pour la
      sophistication, alors que celui de
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Doom</i></span></span>™ était
      optimisé pour vous balancer des tas de monstres à la figure :
      une approche complètement différente. Très impressionnant pour un
      vieux jeu !</p><p>Le <a href="http://madeira.physiol.ucl.ac.uk/tsshp/sshock.html" target="_top"><span class="foreignphrase"><i class="foreignphrase">System
      Shock Hack Project</i></span></a> est une tentative de mise
      à jour du jeu pour les systèmes d'exploitation modernes. Ce projet
      utilise SDL, et est publié sous une licence BSD modifiée. Bien que
      vous ayez besoin des fichiers de jeu originaux pour jouer à SSHP, il
      devrait fonctionner avec la version de démonstration de
      <span class="productname"><span class="foreignphrase"><i class="foreignphrase">System
      Shock</i></span></span>™, qui est disponible
      gratuitement.</p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="id2506680"></a>12. Sites web et ressources</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2506684"></a>12.1. Méta-sites web de jeux</h3></div></div><div></div></div><p>Voici quelques ressources générales pour les joueurs
      Linux :</p><div class="variablelist"><dl><dt><span class="term">Le <span class="foreignphrase"><i class="foreignphrase">Linux Game
        Tome</i></span> : <a href="http://www.happypenguin.org" target="_top">http://www.happypenguin.org</a></span></dt><dd><p>Les jeux en eux-mêmes. </p></dd><dt><span class="term"><a href="http://www.linuxgames.com" target="_top">Linuxgames</a></span></dt><dd><p>Actualités sur les jeux Linux. </p></dd><dt><span class="term"> <a href="http://www.holarse.net" target="_top">http://www.holarse.net</a></span></dt><dd><p>Méta-site web sur les jeux Linux pour les
        germanophones.</p></dd><dt><span class="term"><a href="http://www.mobygames.com" target="_top">Mobygames</a></span></dt><dd><p>Une base de données de tous les jeux vidéo
        informatiques connus. C'est un site très complet et un des mes
        favoris.</p></dd></dl></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2506765"></a>12.2. Jeux Linux commerciaux</h3></div></div><div></div></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2506770"></a>12.2.1. Où acheter des jeux commerciaux</h4></div></div><div></div></div><p><a href="http://www.ebgames.com" target="_top">ebgames</a> ne vend
        plus de logiciels Linux. Ils ont cessé de vendre des jeux et des
        distributions Linux à peu près au même moment où Loki Software a
        fait aveu de faillite, ce qui est une honte car ils avaient les
        plus bas prix sur les jeux Linux qu'il m'ait été donné de voir.
        Néanmoins, de temps en temps, ils proposent des choses comme Code
        Warrior ou Red Hat Linux.</p><div class="variablelist"><dl><dt><span class="term"><a href="http://www.tuxgames.com" target="_top">Tux Games</a>
            </span></dt><dd><p>Votre magasin pour l'achat de jeux Linux
            commerciaux (les vendeurs de logiciel comme Tribsoft et Loki
            ont aussi des magasins en ligne sur leurs sites web).
            </p></dd></dl></div></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="id2506817"></a>12.2.2. Qui publiait des jeux pour Linux</h4></div></div><div></div></div><p>Ce sont des sociétés qui publiaient des jeux pour Linux mais
        qui pour des raisons diverses ne sont plus actives dans l'industrie
        du jeu sous Linux. </p><div class="variablelist"><dl><dt><span class="term">Loki Software : <a href="http://www.lokigames.com" target="_top">http://www.lokigames.com</a></span></dt><dd><p>En
          tant que société qui a apporté
          <span class="productname"><span class="foreignphrase"><i class="foreignphrase">CTP</i></span></span>™ et
          <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Quake3</i></span></span>™
          sous Linux, Loki était le père du jeu sous Linux. Ils étaient des
          pionniers et avaient, de loin, le plus de titres (je les ai
          tous). Loki a porté des jeux sous Linux, principalement en
          utilisant la bibliothèque SDL. La mort de Loki en janvier 2002
          était le plus grand revers subi par Linux dans sa tentative de
          conquête du marché domestique. Linuxgames.com propose un bel
          historique de Loki sur <a href="http://www.linuxgames.com/articles/lokitimeline/" target="_top">http://www.linuxgames.com/articles/lokitimeline/</a>
          </p></dd><dt><span class="term">Tribsoft : <a href="http://www.tribsoft.com" target="_top">http://www.tribsoft.com</a></span></dt><dd><p>Tribsoft a publié <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Jagged
          Alliance 2</i></span></span>™, un excellent jeu de
          rôle/stratégie qui a réclamé plus de 2 semaines de ma vie. Ils
          devaient publier <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Europai
          Universalis</i></span></span>™,
          <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Majesty</i></span></span>™
          et <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Unfinished
          Business</i></span></span>™. Néanmoins, en date du 3
          janvier 2001, <span class="firstname">Mathieu</span> <span class="surname"> Pinard</span> de Tribsoft a dit qu'il
          faisait une pause et que Tribsoft ne publierait plus de jeux pour
          le moment. Il continuera toujours l'assistance pour
          <span class="productname"><span class="foreignphrase"><i class="foreignphrase">JA2</i></span></span>™
          mais ne vous attendez pas à des correctifs ou à des mises à jour.
          </p></dd><dt><span class="term">MP Entertainment : <a href="http://www.hopkinsfbi.com" target="_top">http://www.hopkinsfbi.com</a></span></dt><dd><p>MP Entertainment a publié
          <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Hopkins
          FBI</i></span></span>™, mon jeu préféré jamais publié
          pour Linux. Plus violent que
          <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Quake</i></span></span>™.
          Plus de nudité que Hustler. Plus de mauvais goût que <a href="http://www.flatwaremedia.com/liberace/gallery.cfm" target="_top">Liberace</a>.
          C'est une bande dessinée sur votre moniteur. Il était prévu
          qu'ils publient <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Hopkins FBI
          II</i></span></span>™ et quelques autres titres, mais
          les annonces datent déjà de quelques années sans aucun signe
          d'arrivée prochaine du jeu. Ils ont ignoré toutes mes demandes
          d'informations, et j'en ai donc conclu que MP Entertainment est
          dans la même situation que Tribsoft. Vous pouvez toujours acheter
          ou télécharger une démo de <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Hopkins
          FBI</i></span></span>™ depuis leur site web. Si
          quelqu'un a plus d'informations sur cette société ou sur l'auteur
          de <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Hopkins
          FBI</i></span></span>™, veuillez me contacter.
          </p></dd><dt><span class="term">Phantom EFX : <a href="http://www.phantomefx.com" target="_top">http://www.phantomefx.com</a></span></dt><dd><p>Ils proposent <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Reel
          Deal Slots</i></span></span>™, qui est très bien
          fait ! Je ne suis pas trop amateur de jeux de cartes ou
          d'argent, mais ce jeu est impressionnant ! Étant donné que
          leur seul spécialiste Linux a quitté la société,
          <span class="productname"><span class="foreignphrase"><i class="foreignphrase">Reel Deal
          Slots</i></span></span>™ est leur seule, et à ce jour
          dernière, publication pour Linux. </p></dd></dl></div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="id2507078"></a>12.3. Autres ressources</h3></div></div><div></div></div><p>Cette section propose des URL qui devraient être mentionnées
      mais qui ne trouvaient pas leur place dans une section séparée à
      l'intérieur de ce guide, et que j'ai donc listées ici dans une sorte
      d'annexe.</p><div class="variablelist"><dl><dt><span class="term">Linux Game Publishing :  <a href="http://www.linuxgamepublishing.com" target="_top">http://www.linuxgamepublishing.com</a></span></dt><dd><p>Linux Publishing ne vend pas directement au
          public, mais fournit des services professionnels de publication
          de jeux aux éditeurs de jeux. Je pense que cela signifie la
          réplication de disques, l'emballage et la vente aux
          détaillants.</p></dd><dt><span class="term">Site officiel de
        <span class="application">XFree86</span> : <a href="http://www.xfree86.org" target="_top">http://www.xfree86.org</a></span></dt><dd><p>Page
        d'accueil de
        <span class="application">XFree86</span>.</p></dd><dt><span class="term">Linux Game Development Center :  <a href="http://lgdc.sunsite.dk/index.html" target="_top">http://lgdc.sunsite.dk/index.html</a></span></dt><dd><p>C'est le site web de référence pour qui veut
        programmer des jeux sous Linux. C'est une montagne d'informations
        contenant des articles bien écrits sur tous les aspects de la
        programmation de jeux (pas nécessairement spécifiques à Linux), des
        liens vers d'importantes ressources relatives à la programmation de
        jeux, des interviews, tests, sondages et des tas d'autres trucs. Il
        est difficile d'imaginer un meilleur site web sur le
        sujet.</p></dd><dt><span class="term">La FAQ de Linux Gamers : <a href="http://www.icculus.org/lgfaq/" target="_top">http://www.icculus.org/lgfaq/</a></span></dt><dd><p>Malgré le fait sidérant qu'elle ne mentionne nulle
        part ce présent guide comme une ressource dans leur texte, je
        considère la FAQ comme un bon complément à ce guide. J'ai essayé de
        ne garder que le strict minimum d'informations spécifiques à des
        jeux particuliers dans ce guide. La FAQ prend l'approche
        opposée : elle se concentre principalement sur les jeux
        eux-mêmes, y compris des problèmes spécifiques à certains jeux et
        l'endroit où les obtenir. La FAQ et le guide sont complémentaires à
        cet égard, et j'ai essayé de ne pas reproduire leur contenu. Même
        si les auteurs sont un peu hargneux, leur effort est à souligner.
        Si vous voulez une source d'informations globale pour des questions
        spécifiques à certains jeux, la FAQ est un excellent point de
        départ. De plus, elle donne des informations sur un assez grand
        nombre de jeux Linux.</p></dd><dt><span class="term">Le « <span class="quote">Guide pratique de la qualité du son
   sous Linux</span> » (<span class="foreignphrase"><i class="foreignphrase">Linux Audio Quality
   HOWTO</i></span>) : <a href="http://www.linuxdj.com/audio/quality/" target="_top">http://www.linuxdj.com/audio/quality/</a></span></dt><dd><p>Ce guide intéressera principalement les musiciens qui
   utilisent des cartes professionnelles ou semi-professionnelles pour
   l'enregistrement et la création de musique sur un ordinateur. Les
   informations sont très détaillées, peut-être même trop pour les
   joueurs.</p></dd></dl></div></div></div></div></body></html>
