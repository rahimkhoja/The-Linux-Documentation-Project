<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.21">
 <TITLE>RPM HOWTO (RPM at Idle)</TITLE>
</HEAD>
<BODY>
<H1>RPM HOWTO (RPM at Idle)</H1>

<H2>Donnie Barnes, 
<A HREF="mailto:djb@redhat.com">djb@redhat.com</A></H2>v2.0, 8 Avril 1997
<HR>
<EM>Traduit en français par
Sebastien Bricout, 
<A HREF="mailto:sbricout@francemel.com">sbricout@francemel.com</A>
Traduit le 3 juillet 1999</EM>
<HR>
<H2><A NAME="s1">1. Introduction</A></H2>

<P>RPM est le gestionnaire de paquetages Redhat (RedHat package manager). Malgré le fait qu'il contienne RedHat dans le nom, il se veut totalement un système de paquetages ouvert disponible pour tous. Il permet aux utilisateurs de prendre le code source pour des nouveaux logiciels et de l'"empaqueter" sous forme de source ou de binaire pour que les binaires puissent être simplement installés et suivis et les sources recompilées simplement. Il maintient aussi une base de donées de tous les paquetages et de leurs fichiers qui peut être utilisée pour vérifer les paquetages et chercher des informations a propos des fichiers et/ou des paquetages.</P>
<P>RedHat Software encourage les autres vendeurs de distributions à prendre le temps de s'intéresser à RPM et à l'utiliser pour leur propre distribution. RPM est complètement flexible et simple d'utilisation, bien qu'il fournisse la base d'un système très puissant. Il est aussi complètement ouvert et disponible, bien que nous appréciions les rapports de bugs et les correctifs. La permission d'utiliser et distribuer RPM gratuitement est admise conformément à la GPL.</P>
<P>Une documentation plus complète est disponible sur RPM dans le livre d'Ed Bailey, Maximum RPM. Ce livre est disponible pour le téléchargement ou l'achat sur www.redhat.com 
<A HREF="http://www.redhat.com/">http://www.redhat.com/</A>.</P>


<H2><A NAME="s2">2. Overview</A></H2>

<P>Premièrement, laissez-moi décrire la philosophie de RPM. Un but de l'étude était de permettre l'utilisation des sources "de base". Avec RPP (notre ancien système de paquetages duquel rien de RPM n'est dérivé), nos paquetages sources étaient des sources "bidouillées" à partir desquelles nous compilions.
Théoriquement, quelqu'un peut installer un RPP source puis le compiler sans prblèmes. Mais les sources n'étaient pas les originales, et il n'y avait pas de référence comme quels changements avsions nous fait pour que les sources compilent. Il devait télécharger les sources de base séparément. Avec RPM, vous avez les sources de base ainsi qu'un patch que nous avons utilisé pour compiler. Nous y voyons un grand avantage. Pourquoi ? Il y a plusieurs raisons. Tout d'abord, si une nouvelle version d'un programme sort, vous ne devez pas nécessairement repartir de rien pour obtenir la compilation par les RedHat Labs. Vous pouvez regarder le patch pour voir ce que vous avez besoin de faire. Toutes les valeurs par défaut de compilation sont facilement visibles par ce moyen.</P>
<P>RPM est aussi conçu pour avoir de puissantes options de reqûete. Vous pouvez chercher à travers la base de données entière des paquetages ou seulement certains fichiers. Vous pouvez aussi simplement trouver à quel paquetage un fichier appartient, et d'où il vient. Les fichiers RPM eux-mêmes sont des archives compressées, mais vous pouvez interroger des paquetages individuels simplement et rapidement grâce à un en-tête binaire spécial ajouté au paquetage avec tout ce dont vous pouvez avoir besoin de savoir sur le contenu sous forme non-compressée. Cela permet des requêtes plus rapides.</P>
<P>Une autre fonctionnalité puissante est la capacité de vérifier des paquetages. Si vous avez peur d'avoir effacé un fichier important pour un paquetage, vérifiez-le simplement. Vous serez avertis des anomalies. A ce stade, vous pouvez réinstaller le paquetage so nécessaire. Les fichiers de configuration que vous aviez sont bien sûr préservés.</P>
<P>Nous aimerions remercier les gens de la distribution BOGUS pour beaucoup de leurs idées et concepts qui sont inclus dans RPM. Quoique RPM ait été complètement écrit par RedHat Software, ses fonctions sont basées sur le code écrit par BOGUS (PM et PMS).</P>


<H2><A NAME="s3">3. Information générale</A></H2>



<H2><A NAME="ss3.1">3.1 Se procurer RPM</A>
</H2>

<P>Le meilleur moyen de se procurer RPM est d'installer RedHat Linux. Si vous ne le voulez pas, vous pouvez tout de même obtenir et utiliser RPM. Vous pouvez vous le procurer sur ftp.redhat.com 
<A HREF="ftp://ftp.redhat.com//pub/redhat/code/rpm">ftp://ftp.redhat.com//pub/redhat/code/rpm</A>.</P>


<H2><A NAME="ss3.2">3.2 Ce que RPM requiert</A>
</H2>

<P>Ce qui est principalement requis pour faire tourner RPM est cpio 2.4.2 ou supérieur. Quoique ce système soit conçu pour être utilisé avec Linux, il peut très bien être porté sur d'autres systèmes Unix. Il a, en fait, été compilé sur SunOS, Solaris, AIX, Irix, AmigaOS, et d'autres. Faites attention, les paquetages binaires générés sur un système Unix de type différent ne seront pas compatibles.</P>
<P>Ce sont les exigences minimales pour installer des RPMs. Pour construire des RPMs à partir de sources, vous avez aussi besoin de ce qui est normalement requis pour compiler un paquetage, comme gcc, make, etc.</P>


<H2><A NAME="s4">4. Utiliser RPM</A></H2>

<P>Dans sa forme la plus simple, RPM peut être utilisé pour installer des paquetages:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
               rpm -i foobar-1.0-1.i386.rpm
</PRE>
</CODE></BLOCKQUOTE>

La commande suivant la plus simple est la désinstallation d'un paquetage:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
                rpm -e foobar
</PRE>
</CODE></BLOCKQUOTE>

Une des plus complexes mais très utile des commandes vous permet d'installer des paquetages via FTP. Si vous êtes connectés à internet et voulez installer un nouveau paquetage, tout ce que vous avez besoin de faire est de spécifier le fichier avec une URL valide, comme dans:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
               rpm -i ftp://ftp.pht.com/pub/linux/redhat/rh-2.0-beta/RPMS/foobar-1.0-1.i386.rpm
</PRE>
</CODE></BLOCKQUOTE>

Notez que RPM va maintenant interroger et/ou installer via FTP.</P>
<P>Bien que ce soient des commandes simples, RPM peut être utilisé d'une multitude de façons comme le montre le message Usage:</P>
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
  RPM version 2.3.9
  Copyright (C) 1997 - Red Hat Software
  This may be freely redistributed under the terms of the GNU Public License

  usage: rpm {--help}
         rpm {--version}
         rpm {--initdb}   [--dbpath &lt;dir>]
         rpm {--install -i} [-v] [--hash -h] [--percent] [--force] [--test]
                          [--replacepkgs] [--replacefiles] [--root &lt;dir>]
                          [--excludedocs] [--includedocs] [--noscripts]
                          [--rcfile &lt;file>] [--ignorearch] [--dbpath &lt;dir>]
                          [--prefix &lt;dir>] [--ignoreos] [--nodeps]
                          [--ftpproxy &lt;host>] [--ftpport &lt;port>]
                          file1.rpm ... fileN.rpm
         rpm {--upgrade -U} [-v] [--hash -h] [--percent] [--force] [--test]
                          [--oldpackage] [--root &lt;dir>] [--noscripts]
                          [--excludedocs] [--includedocs] [--rcfile &lt;file>]
                          [--ignorearch]  [--dbpath &lt;dir>] [--prefix &lt;dir>]
                          [--ftpproxy &lt;host>] [--ftpport &lt;port>]
                          [--ignoreos] [--nodeps] file1.rpm ... fileN.rpm
         rpm {--query -q} [-afpg] [-i] [-l] [-s] [-d] [-c] [-v] [-R]
                          [--scripts] [--root &lt;dir>] [--rcfile &lt;file>]
                          [--whatprovides] [--whatrequires] [--requires]
                          [--ftpuseport] [--ftpproxy &lt;host>] [--ftpport &lt;port>]
                          [--provides] [--dump] [--dbpath &lt;dir>] [targets]
         rpm {--verify -V -y} [-afpg] [--root &lt;dir>] [--rcfile &lt;file>]
                          [--dbpath &lt;dir>] [--nodeps] [--nofiles] [--noscripts]
                          [--nomd5] [targets]
         rpm {--setperms} [-afpg] [target]
         rpm {--setugids} [-afpg] [target]
         rpm {--erase -e} [--root &lt;dir>] [--noscripts] [--rcfile &lt;file>]
                          [--dbpath &lt;dir>] [--nodeps] [--allmatches]
                          package1 ... packageN
         rpm {-b|t}[plciba] [-v] [--short-circuit] [--clean] [--rcfile  &lt;file>]
                          [--sign] [--test] [--timecheck &lt;s>] specfile
         rpm {--rebuild} [--rcfile &lt;file>] [-v] source1.rpm ... sourceN.rpm
         rpm {--recompile} [--rcfile &lt;file>] [-v] source1.rpm ... sourceN.rpm
         rpm {--resign} [--rcfile &lt;file>] package1 package2 ... packageN
         rpm {--addsign} [--rcfile &lt;file>] package1 package2 ... packageN
         rpm {--checksig -K} [--nopgp] [--nomd5] [--rcfile &lt;file>]
                             package1 ... packageN
         rpm {--rebuilddb} [--rcfile &lt;file>] [--dbpath &lt;dir>]
         rpm {--querytags}
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>
<P>Vous pouvez trouver plus de détails sur ce que font ces options dans la page de man de RPM.</P>

<H2><A NAME="s5">5. Que puis-je vraiment faire avec RPM ?</A></H2>

<P>Rpm est un utilitaire très utile (!), comme vous pouvez le voir, avec de nombreuses options. Le meilleur moyen de de leur donner un sens est de regarder des exemples. J'ai abordé la simple installation/désinstallation plus haut, alors voici plus d'exemples :</P>
<P>
<UL>
<LI>Imaginez que vous ayez effacé des fichiers par accident, mais que vous ne soyez pas sûr que vous les avez effacé. Si vous ne voulez pas vérifier votre système complet et voir ce qui manque, vous ferez :
<BLOCKQUOTE><CODE>
<PRE>
        rpm -Va
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI>Imaginez que parcouriez un fichier que vous ne reconnaissez pas. Pour trouvez à quel paquetage il appartient, vous ferez :
<BLOCKQUOTE><CODE>
<PRE>
        rpm -qf /usr/X11R6/bin/xjewel
</PRE>
</CODE></BLOCKQUOTE>

La sortie sera :
<BLOCKQUOTE><CODE>
<PRE>
        xjewel-1.6-1
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI>Vous avez trouvé un nouveau RPM de koules, mais vous ne savez pas ce que c'est. Pour avoir des informations à son propos, faites :
<BLOCKQUOTE><CODE>
<PRE>
        rpm -qpi koules-1.2-2.i386.rpm
</PRE>
</CODE></BLOCKQUOTE>

La sortie sera :
<BLOCKQUOTE><CODE>
<HR>
<PRE>
       Name        : koules                      Distribution: Red Hat Linux Colgate
       Version     : 1.2                               Vendor: Red Hat Software
       Release     : 2                             Build Date: Mon Sep 02 11:59:12 1996
       Install date: (none)                        Build Host: porky.redhat.com
       Group       : Games                         Source RPM: koules-1.2-2.src.rpm
       Size        : 614939
       Summary     : SVGAlib action game with multiplayer, network, and sound support
       Description :
       This arcade-style game is novel in conception and excellent in execution.
       No shooting, no blood, no guts, no gore.  The play is simple, but you
       still must develop skill to play.  This version uses SVGAlib to
       run on a graphics console.
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</LI>
<LI>Maintenant vous voulez voir quels fichers le RPM de koules va installer. Vous ferez :
<BLOCKQUOTE><CODE>
<PRE>
        rpm -qlp koules-1.2-2.i386.rpm
</PRE>
</CODE></BLOCKQUOTE>

La sortie est :
<BLOCKQUOTE><CODE>
<HR>
<PRE>

  /usr/doc/koules
  /usr/doc/koules/ANNOUNCE
  /usr/doc/koules/BUGS
  /usr/doc/koules/COMPILE.OS2
  /usr/doc/koules/COPYING
  /usr/doc/koules/Card
  /usr/doc/koules/ChangeLog
  /usr/doc/koules/INSTALLATION
  /usr/doc/koules/Icon.xpm
  /usr/doc/koules/Icon2.xpm
  /usr/doc/koules/Koules.FAQ
  /usr/doc/koules/Koules.xpm
  /usr/doc/koules/README
  /usr/doc/koules/TODO
  /usr/games/koules
  /usr/games/koules.svga
  /usr/games/koules.tcl
  /usr/man/man6/koules.svga.6
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</LI>
</UL>
</P>
<P>Ce sont juste quelques exemples. De plus créatifs peuvent être proches de ce que vous pouvez vraiment faire en étant familier de RPM.</P>


<H2><A NAME="s6">6. Compiler des RPMs</A></H2>

<P>Compiler ses RPMs est très simple, spécialement si vous pouvez obtenir du logiciel que vous essayez qu'il se compile tout seul.</P>
<P>La procédure de base pour compiler un RPM est la suivante :</P>
<P>
<UL>
<LI>Assurez-vous que votre fichier /etc/rpmrc est paramétré pour votre système.
</LI>
<LI>Récupérez les sources donc vous compilez le RPM pour la compilation sur votre système.
</LI>
<LI>Faites un patch des changements que vous devez faire aux sources pour qu'elles compilent correctement.
</LI>
<LI>Faites un fichier spec pour le paquetage.
</LI>
<LI>Assurez-vous que chaque chose est à sa place.</LI>
</UL>
</P>
<P>En utilisation normale, RPM construit aussi bien des paquetages sources que des binaires.</P>


<H2><A NAME="ss6.1">6.1 Le fichier rpmrc</A>
</H2>

<P>Maintenant, la seule configuration de RPM is disponible via le fichier /etc/rpmrc. Un exemple de celui-ci ressemble à :
<BLOCKQUOTE><CODE>
<HR>
<PRE>

  require_vendor: 1
  distribution: I roll my own!
  require_distribution: 1
  topdir: /usr/src/me
  vendor: Mickiesoft
  packager:  Mickeysoft Packaging Account &lt;packages@mickiesoft.com>

  optflags: i386 -O2 -m486 -fno-strength-reduce
  optflags: alpha -O2
  optflags: sparc -O2

  signature: pgp
  pgp_name: Mickeysoft Packaging Account
  pgp_path: /home/packages/.pgp

  tmppath: /usr/tmp
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>
<P>La ligne require_vendor fait que RPM trouve une ligne vendor. Elle peut provenir du fichier /etc/rpmrc ou de l'en-tête du fichier spec lui-même. Pour désactiver ceci, mettez le nombre à 0. Cela reste vrai pour les lignes require_distribution et require_group.</P>
<P>La ligne suivante est la ligne distribution. Pour pouvez définir cela ici ou plus tard, dans l'en-tête du fichier spec. Quand vous compilez pour une distribution particulière, il est conseillé de s'assurer que cette ligne est correcte, bien que ça ne soit pas requis. La ligne vendor fonctionne selon le même principe, mais peut être n'importe quoi (ex: Joe's Software and Rock Music Emporium).</P>
<P>RPM supporte aussi maintenant la création de paquetages sur des architectures multiples. Le fichier rpmrc peut conserver une variable "optflags" pour compiler ce qui requiert des options spécifiques à l'architecture durant la compilation. Voir plus loin les paragraphes concernant l'utilisation de cette option.</P>
<P>En supplément des macros ci-dessus, il y en a beaucoup plus. Vous pouvez utiliser :</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        rpm --showrc
</PRE>
</CODE></BLOCKQUOTE>

pour savoir comment vos options sont définies et quels sont les options disponibles.</P>


<H2><A NAME="ss6.2">6.2 Le fichier Spec</A>
</H2>

<P>Nous avons commencé à parler du fichier spec. Les fichiers spec sont requis pour construire un paquetage. Le fichier spec est une description du logiciel accompagnée des instructions concernant sa compilation, ainsi qu'une liste des fichiers pour tous les binaires qui seront installés.</P>
<P>Il est recommandé nommer votre fichier spec conformément à une convention standard, c'est à dire nom_du_paquetage-numéro_de_version-numéro de release.spec.</P>
<P>Voici un petit fichier spec (vim-3.0-1.spec):</P>
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>

  Summary: ejects ejectable media and controls auto ejection
  Name: eject
  Version: 1.4
  Release: 3
  Copyright: GPL
  Group: Utilities/System
  Source: sunsite.unc.edu:/pub/Linux/utils/disk-management/eject-1.4.tar.gz
  Patch: eject-1.4-make.patch
  Patch1: eject-1.4-jaz.patch
  %description
  This program allows the user to eject media that is autoejecting like
  CD-ROMs, Jaz and Zip drives, and floppy drives on SPARC machines.

  %prep
  %setup
  %patch -p1
  %patch1 -p1

  %build
  make RPM_OPT_FLAGS="$RPM_OPT_FLAGS"

  %install
  install -s -m 755 -o 0 -g 0 eject /usr/bin/eject
  install -m 644 -o 0 -g 0 eject.1 /usr/man/man1

  %files
  %doc README COPYING ChangeLog

  /usr/bin/eject
  /usr/man/man1/eject.1
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>


<H2><A NAME="ss6.3">6.3 L'en-tête</A>
</H2>

<P>L'en-tête comporte des champs standard que vous devez remplir. Il y a quelques 
restrictions bien sûr. Les champs doivent être remplis comme suit :</P>
<P>
<UL>
<LI>Summary: C'est la description du paquetage en une ligne.
</LI>
<LI>Name: Cela doit être la partie "nom" du fichier rpm que vous projetez d'utiliser.
</LI>
<LI>Version: Cela doit être la partie "version" du fichier rpm que vous projetez d'utiliser.
</LI>
<LI>Release: C'est le numéro de release pour un paquetage d'une même version (par exemple si vous construisez un paquetage et que vous le trouvez qu'il est légèrement râté et que vous souhaitez le reconstruire, le paquetage suivant aura le numéro de release 2).
</LI>
<LI>Icon: c'est le nom du fichier icône pour utilisation par un autre utilitaire d'installation de "haut niveau" (comme glint ou gnorpm). Ce doit être un gif et doit être placé dans le répertoire SOURCES.
</LI>
<LI>Source: Cette ligne pointe sur l'emplacement d'origine des sources de base. Il est utilisé si vous voulez réobtenir les sources ou regarder si il existe une version plus récente. Restriction: le nom du fichier dans cette ligne doit concorder avec le nom du fichier que vous avez sur votre propre système (c'est à dire ne pas télécharger les sources et changer le nom du fichier). Vous pouvez aussi spécifier plus d'un fichier source en utilisation des lignes comme :
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
  Source0: blah-0.tar.gz
  Source1: blah-1.tar.gz
  Source2: fooblah.tar.gz
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>
<P>Ces fichiers iront dans le répertoire SOURCES (la structure des répertoires est abordée dans un autre paragraphe, "L'arborescence du répertoire des sources".)</P>

</LI>
<LI>Patch: C'est l'emplacement où vous pouvez trouvez le patch si vous voulez le retélécharger. Restriction: le nom du fichier dpot concorder avec celui que vous utilisez qaudn vous faites VOTRE patch. Notez que vous pouvez avoir plusieurs fichiers patch de la même façon que vous pouvez avoir plusieurs sources. Vous auriez ainsi quelque chose comme :
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
       Patch0: blah-0.patch
       Patch1: blah-1.patch
       Patch2: fooblah.patch
</PRE>
<HR>
</CODE></BLOCKQUOTE>

Ces fichiers vont dans le répertoire SOURCES.</P>

</LI>
<LI>Copyright: Cette ligne indique la façon dont le package est protégé légalement. Vous pouvez utiliser quelque chose comme GPL, BSD, MIT, public domain, Distributable, ou commercial.
</LI>
<LI>Buildroot: Cette ligne vous permet de spécifier un répertoire comme "root" pour la compilation et l'installation du nouveau paquetage. Vous pouvez l'utiliser pour faciliter les tests de votre paquetage avant de l'installer sur votre machine.
</LI>
<LI>Group: Cette ligne est utilisée pour donner aux programmes d'installation de haut niveau l'emplacement de ce paquetage dans leur structure hiérarchique. La arborescence des groupes ressemble actuellement à :
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
Applications
        Communications
        Editeurs
                Emacs
        Ingéniérie
        Tableurs
        Bases de données
        Graphiques
        Réseau
        Mail
        News
        Publication
                TeX
Base
        Noyau
Utilitaires
        Archive
        Console
        Fichiers
        Système
        Terminal
        Texte
Démons
Documentation
X11
        XFree86
                Serveurs
        Applications
                Graphiques
                Réseau
        Jeux
                Stratégie
                Vidéo
        Amusements
        Utilitaires
        Librairies
        Gestionnaires de fenêtres
Librairies
Réseaux
        Admin
        Démons
        News
        Utilitaires
Développement
        Débuggeurs
        Librairies
                Libc
        Langages
                Fortran
                Tcl
        Construction
        Contrôle de version
        Utilitaires
Shells
Jeux
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>

</LI>
<LI>%description Ce n'est pas pas vraiment un champ de l'en-tête, mais doit être décrit avec le reste de celui-ci. Vous avez besoin d'un champ description par paquatage/sous-paquetage. C'est un champ multilgine qui est utilisé pour donner une description claire du paquetage.</LI>
</UL>
</P>


<H2><A NAME="ss6.4">6.4 Prep</A>
</H2>

<P>C'est la seconde section du fichier spec. Il est utilisé pour préparer les sources à la compilation. Vous mettez ce que vous avez besoin de faire pour patcher les sources et paramétrer, comme ce que vous mettriez pour compiler les sources.</P>
<P>Une chose importante: chacune de ces sections est simplement un emplacement pour exécuter des scripts shell. Vous pourriez simplement faire un script sh et le mettre après le tag %prep pour décompresser et patcher vos sources. Nous avons conçu des macros pour aider à cela, toutefois.</P>
<P>La première de ces macros est %setup. Dans sa forme la plus simple (pas d'options de ligne de commande), elle décompresse simplement les sources et se rend dans le répertoire des sources. Elle prend aussi les options suivantes :</P>
<P>
<UL>
<LI>-n nom va définir le nom du répertoire de compilation. La valeur par défaut est $NAME-$VERSION. D'autres possibilités, parmi lesquelles $NAME, ${NAME}${VERSION}, ou n'importe quoi utilisé par le fichier tar principal. (Notez que ces variables "$" ne sont pas des variables réelles disponibles à l'intérieur du fichier spec . En réalité, elles sont juste utilisées ici à la place du nom de l'exemple. Il est nécessaire d'utiliser les vrais noms et versions dans votre paquetage, et non une variable.)

</LI>
<LI>-c va créer et se rendre dans le répertoire donné avant de détarrer.

</LI>
<LI>-b # va détarrer Source# avant de se rendre dans le répertoire (et cela n'a aucun sens avec -c donc ne les associez pas). C'est utile seulement avec de multiples fichiers source.

</LI>
<LI>-a # va détarrer Source# après s'être rendu dans le répertoire.

</LI>
<LI>-T Cette option supplante l'action par défaut de détarrer le Source et requiert un -b 0 ou -a 0 pour détarrer le fichier source principal. Vous en aurez besoin quand il y a des sources secondaires.

</LI>
<LI>-D N'efface pas le répertoire avant la décompression. C'est seulement utilse où vous avez plus d'un macro setup Cela doit être utilisé uniquement dans les macros setup après la première (mais jamais dans celle-ci).</LI>
</UL>
</P>
<P>La macro suivante est la macro %patch. Cette macro aide à automatiser le processus d'application des patches aux sources. Il comporte plusieurs options, listées ici :</P>
<P>
<UL>
<LI># va appliquer Patch# comme fichier patch

</LI>
<LI>-p # spécifie le nombre de répertoires à éliminer pour la commande patch(1) (NdT: option -p).

</LI>
<LI>-P L'action par défaut est d'appliquer Patch (ou Patch0). Ce paramètre inhibe ce comportement par défaut et requierrera un 0 pour détarrer le fichier. Cette option est très utile en seconde (ou plus) macro %patch qui requiert un numéro différent de la première macro.

</LI>
<LI>Vous pouvez aussi faire %patch# au lieu de faire la commande réelle: %patch # -P</LI>
</UL>
</P>
<P>Ce sont toutes les macros dont vous avez besoin. Après que vous les ayez faites, vous pouvez également faire un autre réglage dont vous avez besoin via un script sh. Tout ce que vous incluez jusqu'à de la macro %build (évoquée dans la section suivante) est exécuté par sh. Regardez l'exemple plus haut afin de vous donner une idée du genre de choses que vous pouvez faire ici.</P>

<H2><A NAME="ss6.5">6.5 Compiler</A>
</H2>

<P>Ils n'y a pas de vraies macros pour cette section. Vous devez juste mettre ici les commandes dont vous avez besoin pour compiler le logiciel lorsque vous avez détarré les sources, patchées celles-ci, et vous être rendu dans le répertoire. C'est juste un autre ensemble de commandes passées à sh, donc n'importe quelle commande acceptée par sh peut être placée ici (y compris des commentaires). Votre répertoire de travail courant est rétabli dans ces sections au répertoire racine des cources, gardez cela en mémoire. Vous devez changer de répertoire pour atteindre les sous-répertoires si nécessaire.</P>


<H2><A NAME="ss6.6">6.6 Installation</A>
</H2>

<P>De même, il n'y a pas ici non plus de vraies macros. Vous mettrez ici simplement les commandes donc vous avez besoin pour installer. Si vous avez un "make install" disponible dans le paquetage que vous compilez, mettez-le ici. Sinon, vous pouvez patcher le Makefile pour un "make install" et faire juste un make install ici, ou l'installer à la main ici avec des commandes sh. Considérez que votre répertoire courant est le répertoire racine de vos sources.</P>

<H2><A NAME="ss6.7">6.7 Scripts d'installation/désinstallation optionnels</A>
</H2>

<P>Vous pouvez mettre des scripts qui seront exécutés avant et après l'installation et la désinstallation de paquetages binaires. Une des principales raison pour ça est la nécessité de lancer /sbin/ldconfig  après l'installation ou la suppression de paquetages contenant des librairies partagées. Les macros pour chacun de ces scripts sont les suivantes:</P>
<P>
<UL>
<LI>%pre est la macro qui fait les scripts de pré-installation.

</LI>
<LI>%post est la macro qui fait les scripts de post-installation.

</LI>
<LI>%preun est la macro qui fait les scripts de pré-désinstallation.

</LI>
<LI>%postrun est la macro qui fait les scripts de post-désinstallation.</LI>
</UL>
</P>
<P>Le contenu de ces sections doit ressembler à un script sh, sauf que vous n'avez pas besoin de #!/bin/sh.</P>


<H2><A NAME="ss6.8">6.8 Fichiers</A>
</H2>

<P>C'est la section où vous devez lister les fichiers pour le paquetage binaire. RPM n'a aucun moyen de connaitre quels fichiers sont installés par le "make install". Il n'y a PAS de moyen de le savoir. Certains ont suggéré de faire un "find" avant et après l'installation. Avec un système multiutilisateur, c'est inacceptable car d'autres fichiers qui n'ont rien à voir peuvent être crées pendant le processus d'installation.</P>
<P>Il y a plusieurs macros disponibles pour faire des choses spéciales. Elles sont listées et décrites ici:</P>
<P>
<UL>
<LI>%doc est utiliser pour marquer la documentation dans le paquetage source que vous voulez installer dans un paquetage binaire. Les documents seront installés dans /usr/doc/$NAME-$VERSION-$RELEASE. Vous pouvez lister plusieurs documents sur la ligne de commande avec cette macro, ou les lister séparément en utilisant une macro pour chaque.

</LI>
<LI>%config est utilisé pour marquer les fichiers de configuration dans un paquetage. Cela inclut des fichiers comme sendmail.cf, passwd, etc. Si vous déinstallez par la suite un paquetage contenant des fichiers de configuration, les fichiers non modifiés seront supprimés et les fichiers modifiés seront conservés avec l'extension .rpmsave. Vous pouvez bien sûr mettre plusieurs fichiers avec cette macro.

</LI>
<LI>%files -f <CODE>nomfichier</CODE> va vous permettre de lister vos fichiers dans un fichier arbitraire à l'intérieur du répertoire de compilation des sources. C'est pratique dans le cas où vous avez un paquetage qui ne peut pas construire sa propre liste de fichiers. Vous incluez alors simplement cette liste de fichiers ici, et vous ne devez pas lister les fichiers spécifiquement.</LI>
</UL>
</P>
<P>Le plus gros inconvénient dans le liste de fichier est la liste des répertoire. Si vous listez /usr/bin par accident, votre paquetage va contenir tous les fichiers de /usr/bin sur votre système.</P>


<H2><A NAME="ss6.9">6.9 Le compiler</A>
</H2>



<H3>L'arborescence du répertoire des sources</H3>

<P>La première chose dont vous avez besoin est une arborescence de compilation bien configurée. C'est configurable dans /etc/rpmrc. La plupart des gens utiliseront simplement /usr/src.</P>
<P>Vous aurez probablement besoin de créer les répertoires suivants pour construire l'arborescence de compilation:</P>
<P>
<UL>
<LI>BUILD est le répertoire où toutes les compilations par RPM ont lieu. Vous ne devez pas faire vos tests de compilation quelquepart en particulier, mais c'est là où RPM va faire sa compilation.

</LI>
<LI>SOURCES est le répertoire où vous mettrez le fichier source tarré original et vos patches. C'est là que RPM regarde par défaut.

</LI>
<LI>SPECS est le répertoire où tous les fichiers spec vont.

</LI>
<LI>RPMS is le répertoire où RPM va mettre tous ses binaires RPMs compilés.</LI>
</UL>
</P>


<H3>Test de la compilation</H3>

<P>La premireè chose que vous voudrez probablement faire est de compiler proprement la source sans utiliser RPM. Pour faire cela, décompressez les sources, et changez le nom du répertoire en $NAME.orig. Ensuite re-décompressez les sources. Utilisez ces sources pour compiler. Allez à l'intérieur de celui-ci et suivez les instructions de compilation pour le compiler. Si vous devez éditer des choses, vous aurez besoin d'un patch. Dès que vous réuississez à le compiler, nettoyez le répertoire des sources. Effacez les fichiers qui ont été obtenus par le script configure. Ensuite, remontez au répertoire parent. Vous ferez ensuite quelque chose comme :</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
               diff -uNr dirname.orig dirname > ../SOURCES/dirname-linux.patch
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>Cela créera un patch pour vous que vous pourrez utilisez dans votre fichier spec. Notez que le "linux" que vous voyez dans le nom du patch est juste un identificateur. Vous voudrez sûrement utiliser quelque chose de plus descriptif comme "config" ou "bugs" pour décrire pourquoi vous avez dû faire un patch. De plus il est recommandé de vérifier dans le fichier patch que vous avez créé que vous n'avez pas inclus de binaires par accident avant de l'utiliser.</P>


<H3>Générer la liste des fichiers</H3>

<P>Maintenant que vous avez des souces qui vont compiler et que vous savez comment le faire, compilez-les et installez-les. Regardez la sortie de la séquence d'installation et construisez la liste de fichiers que vous utiliserez dans le fichier spec à partir de celle-ci. On construit habituellement le fichier spec en parallèle avec toutes ces étapes. Vous pouvez créer celui de base et remplir ses parties les plus simples, et ensuite remplir les autre étapes au fur et à mesure.</P>


<H3>Compiler le package avec RPM</H3>

<P>Dès que vous avez un fichier spec, vous êtes prêt à essayer et à compiler votre paquetage. Le voie la plus utilisée pour faire cela est avec une commande qui ressemble à la suivante :</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
               rpm -ba foobar-1.0.spec
</PRE>
</CODE></BLOCKQUOTE>

Il y a d'autres options utiles avec le paramètre -b :</P>
<P>
<UL>
<LI>p signifie d'éxécuter simplement la section prep du fichier spec.

</LI>
<LI>l est un vérificateur de liste qui fait des contrôles sur %files.

</LI>
<LI>c fait le prep et compile. C'est utile quand vous n'êtes pas sûr du tout de la source que vous compilez. Cela semble peu utile parce que vous travaillerez avec les sources elles-mêmes jusqu'à ce qu'elles compilent et commencerez seulement à travailler avec RPM, mais dès que vous serez accoutumé à l'utilisation de RPM vous trouverez des cas où vous les utiliserez.

</LI>
<LI>i fait un prep, compile, et installe.

</LI>
<LI>a fait tout (paquetages source et binaire).</LI>
</UL>
</P>
<P>Il y a plusieurs modificateurs à l'option -b. Ce sont les suivants:</P>
<P>
<UL>
<LI>--short-circuit va sauter à une étape (peut être utilisé uniquement avec c et i).

</LI>
<LI>--clean efface l'arborescence de compilation quand le travail est terminé.

</LI>
<LI>--keep-temps va conserver tous les fichiers temporaires et les scripts fais dans /tmp. Vous pouvez actuellement voir quels fichiers ont été crées dans /tmp en utilisant l'option -v.

</LI>
<LI>--test n'exécute aucune des étapes réelles, mais conserve les fichiers temporaires.</LI>
</UL>
</P>


<H2><A NAME="ss6.10">6.10 Le tester</A>
</H2>

<P>Dès que vous avez des rpms source et binaire pour votre paquetage, vous devez le tester. La voie la plus simple et la meilleure est d'utiliser pour les tests une machine totalement différente de celle sur laquelle vous avez construit le paquetage. Après tout, vous avec juste fait un ensemble de "make install" sur votre propre machine, alors il pourrait aussi bien être installé.</P>
<P>Vous pouvez faire un rpm -u nom_du_paquetage sur le paquetage pour tester, mais vous pouvez être déçu parce durant la construction du paquetage, vous avez fait un make install. Si vous avez laissé quelque chose en dehors de votre liste des fichiers, il ne sera pas désinstallé. Vous réinstallerez alors le paquetage binaire et votre système sera de nouveau complet, mais votre rpm toujours pas. Gardez à l'esprit que vous faites un rpm -ba paquetage, la plupart des peersonnes installeront simplement celui-ci avec rpm -i paquetage. Assurez-vous de ne rien faire dans la section build ou install qui aura besoin d'être fait quand les binaires seront installés par eux-mêmes.</P>


<H2><A NAME="ss6.11">6.11 Que faire avec vos nouveaux RPMs</A>
</H2>

<P>Dès que vous avez construit votre propre rpm de quelque chose (si il n'a pas déjà été "RPMisé"), vous pouvez faire profier les autres de votre travail (si votre rpm est un logiciel librement redistribuable). Pour cela, vous l'uploaderez sur 
<A HREF="ftp://contrib.redhat.com/">ftp://contrib.redhat.com/</A></P>


<H2><A NAME="ss6.12">6.12 Que faire maintenant ?</A>
</H2>

<P>Regardez les sections précédentes Tests et Que faire ... Nous voulons tous les RPMs que nous pouvons obtenir, et nous voulons que ce soient tous les bons RPMs. Prenez le temps de les tester correctement, et ensuite prenez le temps de les uploader afin que chacun en bénéficie. De même, assurez-vous que vous uploadez uniquement des logiciels librement redistribuables. Les logiciels commerciaux et les sharewares ne doivent pas être uploadés à moins que le copyright le permette explicitement. Cela inclut Netscape, ssh, pgp, etc.</P>


<H2><A NAME="s7">7. Construire des RPM pour plusieurs architectures</A></H2>

<P>RPM peut maintenant être utilisé pour construire des paquetages pour intel 386, le Digital Alpha faisant tourner linux, et le Sparc. Il a été signalé qu'il fonctionnait aussi bien sur des stations de travail SGI et HP. De nombreuses options permettent de construire des paquetages sur toutes les plateformes facilement. La première de celles-ci est la directive "optflags" dans /etc/rpmrc. Elle peut être utilisée pour positionner des options utilisés durant la compilation concernant des valeurs spécifiques à l'architecture. Elles peuvent être utilisées pour faire différentes choses qui dépend de l'architecture sur laquelle vous compilez. Une fonctionnalité est la directive "Exclude" dans le header.</P>


<H2><A NAME="ss7.1">7.1 Exemple de fichier spec</A>
</H2>

<P>La partie qui suit est extraite du fichier spec pour le paquetage fileutils. Il est paramétré pour compiler aussi bien sur Alpha que sur Intel.</P>
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
  Summary: GNU File Utilities
  Name: fileutils
  Version: 3.16
  Release: 1
  Copyright: GPL
  Group: Utilities/File
  Source0: prep.ai.mit.edu:/pub/gnu/fileutils-3.16.tar.gz
  Source1: DIR_COLORS
  Patch: fileutils-3.16-mktime.patch

  %description
  These are the GNU file management utilities.  It includes programs
  to copy, move, list, etc, files.

  The ls program in this package now incorporates color ls!

  %prep
  %setup

  %ifarch alpha
  %patch -p1
  autoconf
  %endif
  %build
  configure --prefix=/usr --exec-prefix=/
  make CFLAGS="$RPM_OPT_FLAGS" LDFLAGS=-s

  %install
  rm -f /usr/info/fileutils*
  make install
  gzip -9nf /usr/info/fileutils*
</PRE>
<HR>
</CODE></BLOCKQUOTE>
</P>


<H2><A NAME="ss7.2">7.2 Optflags</A>
</H2>

<P>Dans cet exemple, vous pouvez voir comment la directive "optflags" est utilisée dans le /etc/rpmrc. Selon l'architecture sur laquelle vous compilez, la valeur est donnée à RPM_OPT_FLAGS. Vous devez patcher le Makefile pour votre paquetage pour utiliser cette variable à la place des directives normales que vous utilisez probablement (comme -m486 et -O2). Vous pouvez obtenir un meilleur aspect de ce dont vous avez à faire par l'installation du paquetage source, la décompression de celui-ci et l'examen du Makefile. Ensuite regardez au patch pour le Makefile et voyez les changements à faire.</P>


<H2><A NAME="ss7.3">7.3 Macros</A>
</H2>

<P>la macro %ifarch est très important pour tout cela. LA plupart du temps vous autre besoin de faire un patch ou deux qui sera spécifique à une architecture seulement. Dans ce cas, RPM va vous permettre d'appliquer ce patch uniquement sur cette architecture.</P>
<P>Dans l'exemple plus haut, fileutils a un patch pour les machines 64 bits. Manifestement, cela doit uniquement être appliqué sur Alpha à ce jour. Donc, on ajoute une macro %ifarch pour le patch 64 bits comme suit:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
       %ifarch axp
       %patch1 -p1
       %endif
</PRE>
</CODE></BLOCKQUOTE>

Cela garantira que le patch ne sera pas appliqué sur une autre architecture que Alpha.</P>


<H2><A NAME="ss7.4">7.4 Exclure des architectures des paquetages</A>
</H2>

<P>Comme vous pouvez maintenir les RPMs sources dans un répertoire pour toutes les plateformes, nous avons implémenté la capacité d'exclure des paquetages d'être compilées sur certaines architectures. C'est ce que vous pouvez faire avec quelque chose comme </P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
       rpm --rebuild /usr/src/SRPMS/*.rpm
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>et vous obtenez les vrais paquetages compilés. Si vous n'avez pas encore porté une application sur une certaine platefome, tout ce que vous devez faire est une ligne comme:</P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
      ExcludeArch: axp
</PRE>
</CODE></BLOCKQUOTE>
</P>
<P>à l'en-tête du fichier spec des paquetages source. Ensuite recompilez les paquetages sur les plateformes sur lesquelles il compile. Vous aurez alors un paquetage source qui compile sur Intel et peut facilement être sauté sur Alpha.</P>


<H2><A NAME="ss7.5">7.5 Pour finir</A>
</H2>

<P>Utilisez RPM pour construire des paquetages multi-architectures est habituellement plus simple à faire que d'obtenir du paquetage lui-même qu'il compile sur des architectures différentes. Aussi plus les paquetages compilent difficilement  plus vous obtiendrez de facilité (Ndt: ?). Comme toujours, la meilleure aide quand la construction d'un RPM vous pose problème est de regarder un paquetage source similaire.</P>


<H2><A NAME="s8">8. Note de Copyright</A></H2>

<P>Ce document et son contenu sont protégés.
La redistribution de ce document est permise tant que le contenu demeure complètement intact et inchangé. En d'autres mots, vous pouvez changer le format et le réimprimer ou redistribuer seulement.</P>

</BODY>
</HTML>
