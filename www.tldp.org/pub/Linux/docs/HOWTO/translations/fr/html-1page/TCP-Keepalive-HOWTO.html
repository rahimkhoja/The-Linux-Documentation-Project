<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Guide pratique du maintien de connexion TCP</title><link href="style.css" rel="stylesheet" type="text/css" /><meta content="DocBook XSL Stylesheets V1.73.2" name="generator" /><meta name="description" content="Ce document décrit l'implémentation du TCP keepalive dans le noyau linux, présente le concept global et détaille à la fois la configuration système et le développement d'application." /></head><body><div class="article" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="N10001" />Guide pratique du maintien de connexion TCP</h2></div><div><h3 class="subtitle"><i>
    
    Version française du <span class="foreignphrase" lang="en"><em class="foreignphrase">TCP Keepalive 
    HOWTO</em></span>.
    
    </i></h3></div><div><div class="author"><h3 class="author"><span class="firstname">Fabio</span> <span class="surname">Busatto</span></h3><div class="affiliation"><div class="address"><p><span style="white-space: pre;"><code class="email">&lt;<a class="email" href="mailto:fabio.busatto@sikurezza.org">fabio.busatto@sikurezza.org</a>&gt;</code></span></p></div></div></div></div><div><div class="othercredit"><h3 class="othercredit"><span class="firstname">Laurent</span> <span class="surname">Gauthier</span></h3><span class="contrib">Adaptation française</span> <code class="email">&lt;<a class="email" href="mailto:laurent POINT mail CHEZ gmail POINT com">laurent POINT mail CHEZ gmail POINT com</a>&gt;</code></div></div><div><div class="othercredit"><h3 class="othercredit"><span class="firstname">Eric</span> <span class="surname">Deschamps</span></h3><span class="contrib">Relecture de la version française</span> <code class="email">&lt;<a class="email" href="mailto:erdesc CHEZ free POINT fr">erdesc CHEZ free POINT fr</a>&gt;</code></div></div><div><div class="othercredit"><h3 class="othercredit"><span class="firstname">Jean-Philippe</span> <span class="surname">Guérard</span></h3><span class="contrib">Préparation de la publication de la v.f.</span> <code class="email">&lt;<a class="email" href="mailto:fevrier CHEZ tigreraye POINT org">fevrier CHEZ tigreraye POINT org</a>&gt;</code></div></div><div><p class="releaseinfo">Version : 1.0.fr.1.0</p></div><div><p class="pubdate">2007-05-04</p></div><div><div class="revhistory"><table summary="Revision history" width="100%" border="1"><tr><th colspan="3" valign="top" align="left"><b>Historique des versions</b></th></tr><tr><td align="left">Version 1.0.fr.1.0</td><td align="left">2008-05-02</td><td align="left">LG, ED, JPG</td></tr><tr><td colspan="3" align="left">
        
          Première adaptation française.
          
        </td></tr><tr><td align="left">Version 1.0</td><td align="left">2007-05-04</td><td align="left">FB</td></tr><tr><td colspan="3" align="left">
        
          Première édition, révisée par TM.
          
        </td></tr></table></div></div><div><div class="abstract"><p class="title"><b>Résumé</b></p><p>

        Ce document décrit l'implémentation du TCP keepalive dans le noyau
        linux, présente le concept global et détaille à la fois la 
        configuration système et le développement d'application.

      </p></div></div></div><hr /></div><div class="toc"><p><b>Table des matières</b></p><dl><dt><span class="sect1"><a href="#introduction">1. Introduction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#copyright">1.1. Droits d'utilisation</a></span></dt><dt><span class="sect2"><a href="#avertissement">1.2. Avertissement</a></span></dt><dt><span class="sect2"><a href="#credits">1.3. Remerciements et contributions</a></span></dt><dt><span class="sect2"><a href="#feedback">1.4. Commentaires et corrections</a></span></dt><dt><span class="sect2"><a href="#translations">1.5. Traductions</a></span></dt></dl></dd><dt><span class="sect1"><a href="#apercu">2. Aperçu de TCP keepalive</a></span></dt><dd><dl><dt><span class="sect2"><a href="#questce">2.1. Qu'est-ce que TCP keepalive ?</a></span></dt><dt><span class="sect2"><a href="#pourquoiutiliser">2.2. Pourquoi utiliser TCP keepalive ?</a></span></dt><dt><span class="sect2"><a href="#verifierinjoignables">2.3. Vérifier les hôtes injoignables</a></span></dt><dt><span class="sect2"><a href="#eviterdeconnexion">2.4. Éviter une déconnexion due à une inactivité réseau.</a></span></dt></dl></dd><dt><span class="sect1"><a href="#usingkeepalive">3. Utiliser TCP keepalive sous Linux</a></span></dt><dd><dl><dt><span class="sect2"><a href="#configuringkernel">3.1. Configurer le noyau</a></span></dt><dt><span class="sect2"><a href="#rendremodifspersistantes">3.2. Rendre les modifications persistantes au redémarrage</a></span></dt></dl></dd><dt><span class="sect1"><a href="#programmer">4. Programmer des applications</a></span></dt><dd><dl><dt><span class="sect2"><a href="#quandrequis">4.1. Quand votre code requiert keepalive</a></span></dt><dt><span class="sect2"><a href="#setsockopt">4.2. L'appel de fonction <code class="function">setsockopt</code></a></span></dt><dt><span class="sect2"><a href="#exemples">4.3. Exemples de code</a></span></dt></dl></dd><dt><span class="sect1"><a href="#applitierce">5. Implémenter keepalive sur une application tierce</a></span></dt><dd><dl><dt><span class="sect2"><a href="#modifiersource">5.1. Modifier le code source</a></span></dt><dt><span class="sect2"><a href="#libkeepalive">5.2. <span class="application">libkeepalive</span>: préchargement de bibliothèque</a></span></dt></dl></dd></dl></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="introduction" />1. Introduction</h2></div></div></div><p>
    Comprendre TCP keepalive n'est pas indispensable dans la plupart des cas,
    mais cela peut être très utile dans certaines circonstances. Il vous faudra
    posséder quelques notions de base des réseaux TCP/IP et de la programmation
    en langage C pour comprendre toutes les sections de ce document.
  </p><p>
    Le principal objectif de ce tutoriel (HOWTO) est de décrire en détail le 
    TCP keepalive et de présenter différents cas d'application. Après avoir 
    débuté avec un peu de théorie, le propos se concentre sur 
    l'implémentation des routines TCP keepalive dans les noyaux Linux
    actuels (2.4.x, 2.6.x), et sur les moyens dont les administrateurs système
    peuvent tirer parti de ces routines, avec des exemples de configuration 
    précis et des astuces.
  </p><p>
    La seconde partie de ce tutoriel met en jeu l'interface de programmation  
    proposée par le noyau Linux, et le mode d'écriture des applications qui
    implémentent le TCP keepalive en langage C. Des exemples pratiques sont
    présentés, et une approche du projet <code class="literal">libkeepalive</code> est
    amorcée, permettant aux applications de bénéficier par héritage du keepalive
    sans modification de code.
  </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="copyright" />1.1. Droits d'utilisation</h3></div></div></div><p>
      Les droits de ce document, TCP Keepalive HOWTO, sont déposés sous
      copyright (c) 2007 par Fabio Busatto. Il est permis de copier, distribuer
      et/ou modifier ce document dans le cadre de la  Licence de Documentation
      Libre GNU, Version 1.1 ou ultérieure publiée par la Free Software 
      Foundation; aucune section invariable, pas de texte de couverture.
      Un exemplaire de la licence est disponible à l'adresse 
      <a class="ulink" href="http://www.gnu.org/licenses/licenses.fr.html#FDL" target="_top">
      http://www.gnu.org/licenses/licenses.fr.html#GPL</a>.
    </p><p>
      Le code source inclus dans ce document relève de la licence publique
      générale (GPL) GNU General Public License, Version 2 ou ultérieure
      publiée par la Free Software Foundation. Un exemplaire de la licence
      est disponible à l'adresse
      <a class="ulink" href="http://www.gnu.org/licenses/licenses.fr.html#GPL" target="_top">
      http://www.gnu.org/licenses/licenses.fr.html#GPL</a>.
    </p><p>
      Linux est une marque déposée de Linus Torvalds.
    </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="avertissement" />1.2. Avertissement</h3></div></div></div><p>
      Aucune responsabilité relative au contenu du présent document ne sera
      endossée. L'utilisation des concepts, exemples et informations est à vos
      propres risques. Des erreurs ou imprécisions peuvent endommager votre 
      système. Agissez avec précaution, et même si cela est peu commun, 
      l'auteur n'endosse aucune responsabilité (NdT : le traducteur non plus).
    </p><p>
      Tous les droits sont détenus par leurs propriétaires respectifs, sauf 
      mention particulière. L'utilisation de termes de ce document ne doit 
      pas être considérée comme une atteinte à la validité d'une marque 
      déposée ou marque de service. Citer un produit ou une marque ne devrait
      pas être considéré comme répréhensible.
    </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="credits" />1.3. Remerciements et contributions</h3></div></div></div><p>
      Ce travail ne doit à personne que je devrais remercier. Mais il doit à 
      ma vie, et à mon savoir aussi: donc, merci à chacun m'ayant soutenu,
      avant ma naissance, actuellement, ou dans le futur. Sincèrement.
    </p><p>
      Un merci tout spécial à Tabatha, la femme patiente qui a lu mon travail et 
      fait les corrections nécessaires.
    </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="feedback" />1.4. Commentaires et corrections</h3></div></div></div><p>
      Vos retours sur ce document seront les bienvenus. Adressez vos ajouts,
      commentaires et remarques à l'auteur à l'adresse mail suivante :
      <code class="email">&lt;<a class="email" href="mailto:fabio.busatto@sikurezza.org">fabio.busatto@sikurezza.org</a>&gt;</code>.
    </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="translations" />1.5. Traductions</h3></div></div></div><p>
      Si vous êtes intéressé par la traduction de ce HOWTO en d'autres langues,
      n'hésitez pas à me contacter. Votre contribution sera la bienvenue.
    </p><p>
      Langues disponibles : 
      <div class="itemizedlist"><ul><li><p>
            <a class="ulink" href="http://www.tldp.org/HOWTO/html_single/TCP-Keepalive-HOWTO/" target="_top">
              anglais (document original)
            </a>
          </p></li><li><p>
            <a class="ulink" href="http://www.traduc.org/docs/howto/lecture/TCP-Keepalive-HOWTO.html" target="_top">
              français
            </a>
          </p></li></ul></div>
    </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="apercu" />2. Aperçu de TCP keepalive</h2></div></div></div><p>
    Afin de comprendre ce que fait TCP keepalive (que nous appellerons
    'keepalive'), vous n'avez besoin que d'en lire le nom : keep TCP
    alive (maintenir TCP en vie), c'est à dire conserver la connexion TCP.
    Cela signifie que vous serez en mesure de vérifier l'état de votre socket
    de connexion (appelée aussi socket TCP), et de déterminer si la connexion
    est toujours établie ou si elle est rompue.
  </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="questce" />2.1. Qu'est-ce que TCP keepalive ?</h3></div></div></div><p>
      Le concept du keepalive est très simple: lorsque vous initiez une 
      connexion TCP, vous y associez un jeu de chronomètres. Certains de ces 
      chronomètres ont trait à la procédure du keepalive. Quand la durée
      maximale du keepalive est atteinte, vous adressez à l'hôte distant un
      paquet sonde de keepalive ne contenant aucune donnée, avec le bit ACK 
      positionné. Cela est possible grâce aux particularités de TCP/IP,
      une sorte de ACK doublé, et l'hôte distant n'aura aucun argument,
      puisque TCP est un protocole orienté flux. En retour vous aurez une 
      réponse de l'hôte distant (qui n'a nul besoin d'implémenter le keepalive,
      mais seulement TCP/IP), sans donnée, et le ACK positionné.
    </p><p>
      Si vous recevez une réponse à votre sonde keepalive, vous pouvez être
      certain que la connexion est toujours établie et active sans inquiétude
      pour le niveau applicatif. Concrètement, TCP permet de maintenir un flux,
      sans paquet, donc un paquet de longueur zéro n'est pas dangereux pour 
      le programme utilisateur.
    </p><p>
      Cette méthode est utile car si les autres points distants perdent leurs 
      connexions (en raison d'un redémarrage par exemple) vous détecterez que
      la connexion est rompue, même sans avoir de flux de donnée. Si les sondes 
      keepalive n'obtiennent pas de réponse, vous pouvez certifier que la 
      connexion ne peut plus être considérée comme valide et agir en 
      conséquence.
    </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="pourquoiutiliser" />2.2. Pourquoi utiliser TCP keepalive ?</h3></div></div></div><p>
      Vous pouvez vivre plutôt heureux sans keepalive, donc si vous lisez ces
      lignes, soit vous essayez de comprendre si keepalive est une réponse 
      possible à vos problèmes, soit vous n'avez rien de plus intéressant à 
      faire et c'est bien aussi. :)
    </p><p>
      Keepalive est non invasif, et dans la plupart des cas, si vous avez un
      doute, vous pouvez l'activer sans risque d'erreur. mais souvenez vous que
      c'est générateur de flux supplémentaire, ce qui peut avoir un impact sur
      les routeurs et les pare-feu.
    </p><p>
      En résumé, utilisez vos méninges et soyez prudent.
    </p><p>
      Dans la section suivante nous distinguerons les deux objectifs de 
      keepalive:
      <div class="itemizedlist"><ul><li><p>S'assurer qu'un hôte distant n'est pas injoignable</p></li><li><p>Éviter une déconnexion due à une inactivité réseau.</p></li></ul></div>
    </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="verifierinjoignables" />2.3. Vérifier les hôtes injoignables</h3></div></div></div><p>
      Keepalive peut être utilisé pour être averti que l'hôte distant est mort
      avant qu'il soit capable de vous le notifier. Cela pourrait se produire 
      en différentes circonstances, une panique noyau ou une interruption 
      soudaine du processus maintenant la connexion par exemple. 
      Un autre cas justifiant keepalive pour détecter que l'hôte distant n'est
      pas joignable est la défaillance du réseau. Dans ce cas, si le réseau
      n'est pas à nouveau opérationnel, vous êtes dans la même situation que 
      pour la mort de l'hôte distant. C'est dans ces cas de figure que les 
      mécanismes TCP classiques ne permettent pas de s'assurer de l'état d'une 
      connexion.
    </p><p>
      Songez à une simple connexion TCP entre l'hôte A et l'hôte B: il y a 
      la poignée de main initiale en trois phases, le paquet SYN de A vers B,
      le SYN/ACK en retour de B vers A, et le ACK final de A vers B. A ce 
      stade, nous sommes dans une situation stable : la connexion est établie,
      et les données peuvent donc être envoyées sur ce lien. Mais le problème 
      survient : débranchez l'alimentation de B et instantanément il s'éteint,
      sans rien envoyer sur le réseau pour notifier A que la connexion va être
      interrompue. A, de son côté, est prêt à envoyer des données, et 
      n'imagine pas que B est muet. Maintenant rebranchez l'alimentation de B
      et attendez que le système redémarre. A et B sont de retour, mais A 
      présente une connexion toujours active vers B, alors que B l'ignore. 
      La situation se résout d'elle-même lorsque A tente d'envoyer des données
      à B sur une connexion morte, et que B répond par un paquet RST, forçant 
      A à finalement mettre fin à la connexion.
    </p><p>
      Keepalive peut vous notifier quand un destinataire devient injoignable
      sans risque de faux positif. En fait, si le problème tient au réseau 
      entre les deux hôtes, le rôle du keepalive est d'attendre un temps pour
      tenter à nouveau, adressant le paquet keepalive avant de notifier de la 
      rupture du lien.
    </p><p>

<pre class="screen">
 _____                                                     _____
|     |                                                   |     |
|  A  |                                                   |  B  |
|_____|                                                   |_____|
   ^                                                         ^
   |---&gt;---&gt;---&gt;-------------- SYN --------------&gt;---&gt;---&gt;---|
   |---&lt;---&lt;---&lt;------------ SYN/ACK ------------&lt;---&lt;---&lt;---|
   |---&gt;---&gt;---&gt;-------------- ACK --------------&gt;---&gt;---&gt;---|
   |                                                         |
   |                                   le système meurt ---&gt; X
   |
   |                               le système redémarre ---&gt; ^
   |                                                         |
   |---&gt;---&gt;---&gt;-------------- PSH --------------&gt;---&gt;---&gt;---|
   |---&lt;---&lt;---&lt;-------------- RST --------------&lt;---&lt;---&lt;---|
   |                                                         |
</pre>
    </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="eviterdeconnexion" />2.4. Éviter une déconnexion due à une inactivité réseau.</h3></div></div></div><p>
      L'autre objectif utile de keepalive est d'éviter que l'inactivité ne
      provoque une déconnexion. C'est un cas fréquent d'être déconnecté sans
      raison lorsque vous vous trouvez derrière un proxy NAT ou un pare-feu.
      Ce comportement est dû aux procédures de surveillance des connexions
      des proxies et pare-feu, qui tiennent un inventaire des connexions qui
      les traverse. En raison des limites physiques de leurs ressources, ces 
      machines ne peuvent conserver en mémoire qu'un nombre déterminé de 
      connexions. La règle la plus courante et la plus logique est de maintenir
      les connexions les plus récentes et de mettre d'abord fin aux connexions 
      les plus anciennes ou inactives.
    </p><p>
      Pour revenir à nos hôtes A et B, reconnectons les. Une fois le lien 
      établi, attendons qu'un évènement se produise pour le transmettre à l'hôte
      distant. Qu'en est-il si cet évènement se produit après un long moment ? 
      Notre connexion a sa propre durée, qui est inconnue du proxy. Lorsque nous
      finissons par transmettre des données, le proxy n'est plus capable de les 
      traiter correctement, et la connexion est rompue.
    </p><p>
      Puisque le fonctionnement normal est de mettre en tête de liste la 
      connexion par laquelle transitent des paquets, et de choisir la dernière
      connexion de la file quand il faut en supprimer une, le fait d'envoyer
      périodiquement des paquets sur le réseau est un bon moyen pour toujours 
      rester en phase avec un risque minime de suppression.
    </p><p>
<pre class="screen">
 _____           _____                                     _____
|     |         |     |                                   |     |
|  A  |         | NAT |                                   |  B  |
|_____|         |_____|                                   |_____|
   ^               ^                                         ^
   |---&gt;---&gt;---&gt;---|----------- SYN -------------&gt;---&gt;---&gt;---|
   |---&lt;---&lt;---&lt;---|--------- SYN/ACK -----------&lt;---&lt;---&lt;---|
   |---&gt;---&gt;---&gt;---|----------- ACK -------------&gt;---&gt;---&gt;---|
   |               |                                         |
   |               | &lt;--- connexion supprimée de la table    |
   |               |                                         |
   |---&gt;- PSH -&gt;---| &lt;--- connexion invalide                 |
   |               |                                         |
</pre>
    </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="usingkeepalive" />3. Utiliser TCP keepalive sous Linux</h2></div></div></div><p>
    Linux intègre nativement le keepalive. Vous devez activer le réseau TCP/IP
    pour pouvoir l'utiliser. Vous avez aussi besoin du support de 
    <code class="literal">procfs</code> et de <code class="literal">sysctl</code> pour pouvoir 
    configurer les paramètre noyau au lancement.
  </p><p>
    Les fonctions impliquant keepalive utilisent trois variables manipulées par l'utilisateur :

    <div class="variablelist"><dl><dt><span class="term">
          <code class="varname">tcp_keepalive_time</code>
        </span></dt><dd><p>
            intervalle entre le dernier envoi de paquet (le simple ACK n'étant
            pas considéré comme de la donnée) et la première sonde keepalive;
            après que la connexion ait été marquée comme requérant un keepalive, 
            ce compteur n'est plus utilisé.
          </p></dd><dt><span class="term">
          <code class="varname">tcp_keepalive_intvl</code>
        </span></dt><dd><p>
            intervalle entre deux sondes keepalive, indépendamment de ce qui 
            est échangé sur la connexion dans l'intervalle
          </p></dd><dt><span class="term">
          <code class="varname">tcp_keepalive_probes</code>
        </span></dt><dd><p>
            nombre de sondes non acquittées à envoyer avant de considérer la 
            connexion perdue et de notifier la couche applicative.
          </p></dd></dl></div>
  </p><p>
    Rappelez-vous que le support du keepalive, même s'il est configuré dans le
    noyau, n'est pas le comportement par défaut de Linux. Les programmes 
    doivent requérir le contrôle du keepalive pour que ses sockets puissent
    utiliser l'interface <code class="literal">setsockopt</code>. Relativement peu de 
    programmes implémentent keepalive, mais vous pouvez facilement ajouter le
    support du keepalive pour la plupart d'entre eux en suivant les 
    instructions détaillées plus avant dans ce document.
  </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="configuringkernel" />3.1. Configurer le noyau</h3></div></div></div><p>
      Il existe deux moyens de configurer les paramètres keepalive du noyau
      au travers de commandes utilisateur:

      <div class="itemizedlist"><ul><li><p>l'interface <code class="literal">procfs</code></p></li><li><p>l'interface <code class="literal">sysctl</code></p></li></ul></div>
    </p><p>
      Nous aborderons essentiellement comment procéder au travers de l'interface
      procfs car elle est la plus utilisée, recommandée et la plus simple à 
      appréhender. L'interface sysctl, particulièrement sous l'aspect de l'appel
      système (syscall) <span class="citerefentry"><span class="refentrytitle">
      <code class="function">sysctl</code></span>(2)</span> et non de l'outil <span class="citerefentry"><span class="refentrytitle"><span class="command"><strong>
      sysctl</strong></span></span>(8)</span>,
      n'est là qu'à titre informatif.
    </p><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="procfsinterface" />3.1.1. L'interface<code class="literal">procfs</code></h4></div></div></div><p>
        Cette interface nécessite que<code class="literal">sysctl</code> et <code class="literal">
        procfs</code> soient inclus au noayu, et que <code class="literal">procfs
        </code> soit monté quelque part dans le système de fichiers 
        (habituellement <code class="filename">/proc</code>, comme dans l'exemple 
        ci-dessous). Vous pouvez lire les valeurs des paramètres actuels
        en listant avec la commande « <span class="quote">cat</span> » les fichiers du 
        répertoire <code class="filename">/proc/sys/net/ipv4/</code> :

        <div class="informalexample"><pre class="programlisting">
  <code class="prompt"># </code><strong class="userinput"><code>cat /proc/sys/net/ipv4/tcp_keepalive_time</code></strong>
  <code class="computeroutput">7200</code>

  <code class="prompt"># </code><strong class="userinput"><code>cat /proc/sys/net/ipv4/tcp_keepalive_intvl</code></strong>
  <code class="computeroutput">75</code>

  <code class="prompt"># </code><strong class="userinput"><code>cat /proc/sys/net/ipv4/tcp_keepalive_probes</code></strong>
  <code class="computeroutput">9</code>
        </pre></div>
      </p><p>
        Les deux premiers paramètres sont exprimés en secondes, et le dernier 
        est un nombre simple. Cela signifie que les routines keepalive 
        attendent deux heures (7200 secs) avant d'adresser la première sonde
        keepalive, et en adressent une nouvelle toutes les 75 secondes. 
        Si aucune réponse ACK n'est reçue après neuf tentatives consécutives,
        la connexion est considérée comme rompue.
      </p><p>
        La modification de ces valeurs est directe : il faut écrire de 
        nouvelles valeurs dans les fichiers. Supposons que souhaitiez 
        configurer la machine pour que le keepalive débute après dix minutes
        d'inactivité sur le lien, et que des sondes soient envoyées chaque 
        minute. En raison de l'instabilité de ce brin de votre réseau
        et de la faible valeur de l'intervalle, supposons que vous vouliez 
        augmenter le nombre de tentatives à 20.
      </p><p>
        Voici comment paramétrer ces valeurs :

        <div class="informalexample"><pre class="programlisting">
  <code class="prompt"># </code><strong class="userinput"><code>echo 600 &gt; /proc/sys/net/ipv4/tcp_keepalive_time</code></strong>

  <code class="prompt"># </code><strong class="userinput"><code>echo 60 &gt; /proc/sys/net/ipv4/tcp_keepalive_intvl</code></strong>

  <code class="prompt"># </code><strong class="userinput"><code>echo 20 &gt; /proc/sys/net/ipv4/tcp_keepalive_probes</code></strong>
        </pre></div>
      </p><p>
        Pour confirmer la prise en compte des nouvelles valeurs, affichez à 
        nouveau le contenu des fichiers pour vérifier qu'ils présentent bien
        les valeurs souhaitées.
      </p><p>
        Il faut garder présent à l'esprit que <code class="literal">procfs</code> manipule
        des fichiers spéciaux, et vous ne pouvez pas tout faire sur ces fichiers 
        qui ne sont qu'une interface vers l'environnement du noyau, non de 
        véritables fichiers. Testez vos scripts avant de les utiliser et faites
        en sorte d'utiliser des modes d'accès simples comme dans les exemples 
        ci-dessus.
      </p><p>
        Vous pouvez accéder à l'interface grâce à l'outil <span class="citerefentry"><span class="refentrytitle">
        <span class="command"><strong>sysctl</strong></span></span>(8)</span>, en précisant ce que vos voulez lire ou écrire.

        <div class="informalexample"><pre class="programlisting">
  <code class="prompt"># </code><strong class="userinput"><code>sysctl \</code></strong>
  <code class="prompt">&gt; </code><strong class="userinput"><code>net.ipv4.tcp_keepalive_time \</code></strong>
  <code class="prompt">&gt; </code><strong class="userinput"><code>net.ipv4.tcp_keepalive_intvl \</code></strong>
  <code class="prompt">&gt; </code><strong class="userinput"><code>net.ipv4.tcp_keepalive_probes</code></strong>
  <code class="computeroutput">net.ipv4.tcp_keepalive_time = 7200
  net.ipv4.tcp_keepalive_intvl = 75
  net.ipv4.tcp_keepalive_probes = 9</code>
        </pre></div>
      </p><p>
        Remarquez que les noms <code class="literal">sysctl</code> sont proches des chemins
        <code class="literal">procfs</code>. L'écriture se fait grâce à l'option <code class="option">-w</code>
        de <span class="citerefentry"><span class="refentrytitle"><span class="command"><strong>sysctl</strong></span>
        </span>(8)</span>:

        <div class="informalexample"><pre class="programlisting">
  <code class="prompt"># </code><strong class="userinput"><code>sysctl -w \</code></strong>
  <code class="prompt">&gt; </code><strong class="userinput"><code>net.ipv4.tcp_keepalive_time=600 \</code></strong>
  <code class="prompt">&gt; </code><strong class="userinput"><code>net.ipv4.tcp_keepalive_intvl=60 \</code></strong>
  <code class="prompt">&gt; </code><strong class="userinput"><code>net.ipv4.tcp_keepalive_probes=20</code></strong>
  <code class="computeroutput">net.ipv4.tcp_keepalive_time = 600
  net.ipv4.tcp_keepalive_intvl = 60
  net.ipv4.tcp_keepalive_probes = 20</code>
        </pre></div>
      </p><p>
        Remarquez que <span class="citerefentry"><span class="refentrytitle"><span class="command"><strong>sysctl</strong></span>
        </span>(8)</span> n'utilise pas
        l'appel système (syscall)<span class="citerefentry"><span class="refentrytitle"><code class="function">sysctl</code></span>(2)</span>, mais lit et écrit directement
        dans l'arborescence <code class="literal">procfs</code>, donc <code class="literal">procfs</code>
        devra être  activé dans le noyau et monté dans le système de fichiers,
        comme si vous accédiez directement aux fichiers via l'interface
        <code class="literal">procfs</code>. <span class="citerefentry"><span class="refentrytitle">
        <span class="command"><strong>Sysctl</strong></span></span>(8)</span> n'est qu'un moyen différent de faire la même chose.
      </p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a id="sysctlinterface" />3.1.2. L'interface<code class="literal">sysctl</code></h4></div></div></div><p>
        Il existe un autre moyen d'accéder aux variables du noyau : l'appel 
        système <span class="citerefentry"><span class="refentrytitle"><code class="function">sysctl</code>
        </span>(2)</span>. Cela peut être 
        utile lorque <code class="literal">procfs</code> n'est pas disponible du fait que 
        la communication avec le noyau est réalisée directement via syscall et pas 
        au travers de l'arborescence <code class="literal">procfs</code> . Il n'existe 
        actuellement aucun programme qui implémente l'appel syscall 
        (souvenez-vous que <span class="citerefentry"><span class="refentrytitle"><span class="command"><strong>
        sysctl</strong></span></span>(8)</span>
        ne l'utilise pas).
      </p><p>
        Pour une utilisation détaillé de <span class="citerefentry"><span class="refentrytitle"><code class="function">
        sysctl</code></span>(2)</span>
        reportez vous au manuel (man).
      </p></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="rendremodifspersistantes" />3.2. Rendre les modifications persistantes au redémarrage</h3></div></div></div><p>
      Il existe différents moyens de paramétrer le système à chaque démarrage.
      Tout d'abord, souvenez vous que chaque distribution Linux possède son 
      propre jeu de scripts d'initialisation appelé par
      <span class="citerefentry"><span class="refentrytitle"><span class="command"><strong>init</strong></span>
      </span>(8)</span>. 
      Les configurations les plus courantes incluent soit le répertoire 
      <code class="filename">/etc/rc.d/</code> , soit <code class="filename">/etc/init.d/</code> . 
      Dans ce cas vous pouvez positionner les paramètres dans un script de 
      démarrage quelconque, keepalive relisant les valeurs à chaque fois 
      que ses routines en ont besoin. Donc si vous changez la valeur de 
      <code class="varname">tcp_keepalive_intvl</code> alors que la connexion est 
      encore active, le noyau utilisera la nouvelle valeur pour continuer.
    </p><p>
      Les commandes d'initialisation peuvent logiquement être placées en trois 
      endroits différents : le premier est dans la configuration réseau,
      le second dans le script <code class="filename">rc.local</code> , habituellement 
      inclus dans toutes les distributions, et connu comme étant le point de
      configuration utilisateur au démarrage. Le troisième point existe 
      peut-être déjà sur votre système. En revenant à l'outil
      <span class="citerefentry"><span class="refentrytitle"><span class="command"><strong>sysctl</strong></span>
      </span>(8)</span> , vous pouvez
      voir que l'option <code class="option">-p</code> charge les paramètres du fichier
      de configuration <code class="filename">/etc/sysctl.conf</code> . Il est fréquent 
      que votre script d'initialisation exécute déjà <span class="command"><strong>sysctl</strong></span> <code class="option">-p</code>
      (un « <span class="quote">grep</span> » sur le répertoire de configuration le confirmera),
      et vous n'avez alors qu'à ajouter les lignes dans <code class="filename">
      /etc/sysctl.conf</code> pour qu'elles soient prises en compte 
      à chaque démarrage. Pour davantage d'informations sur la syntaxe de
      <span class="citerefentry"><span class="refentrytitle"><code class="filename">sysctl.conf</code>
      </span>(5)</span>, 
      reportez vous au manuel.
    </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="programmer" />4. Programmer des applications</h2></div></div></div><p>
    Cette section aborde le code nécessaire à l'écriture d'une application utilisant
    keepalive. Ce n'est pas un manuel de programmation, et il requiert d'avoir 
    une connaissance du langage C et des concepts réseau. Je considère que la 
    notion de socket vous est familière, de même que tous les aspects généraux 
    de votre application.
  </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="quandrequis" />4.1. Quand votre code requiert keepalive</h3></div></div></div><p>
      Les applications réseau ne requièrent pas toutes l'aide du keepalive. 
      Souvenez vous qu'il s'agit de TCP keepalive. Comme vous pouvez le 
      deviner, seules les sockets TCP peuvent en tirer parti.
    </p><p>
      La plus belle chose que vous puissiez faire en écrivant une application est
      de la rendre aussi paramétrable que possible, et de ne pas en forcer les choix.
      Si vous voulez prendre en compte le bonheur de vos utilisateurs, vous 
      devriez implémenter keepalive et laisser les utilisateurs décider s'ils
      veulent ou non l'utiliser en prévoyant un paramètre de configuration ou 
      une option de ligne de commande.
    </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="setsockopt" />4.2. L'appel de fonction <code class="function">setsockopt</code></h3></div></div></div><p>
      Tout ce dont vous avez besoin pour que keepalive soit activé sur une 
      socket particulière est de positionner l'option sur cette socket.
      Le prototype de fonction est le suivant:

      <pre class="synopsis">
  int <code class="function">setsockopt</code>(int s, int level, int optname,
                 const void *optval, socklen_t optlen)
      </pre>
    </p><p>
      Le premier paramètre est la socket, préalablement créée avec
      <span class="citerefentry"><span class="refentrytitle"><code class="function">socket</code></span>(2)</span>; le second doit être <code class="constant">
      SOL_SOCKET</code>, et le troisième <code class="constant">SO_KEEPALIVE
      </code>. Le quatrième doit être un entier booleéen, indiquant que 
      l'option est active, alors que le dernier est la taille de la valeur 
      passée précédemment.
    </p><p>
      Conformément au manuel, le code retour <span class="returnvalue">0</span>
      indique le succès, <span class="returnvalue">-1</span> est la valeur 
      d'erreur (et <code class="varname">errno</code> est correctement renseignée).
    </p><p>
      Il existe aussi trois autres options de socket qu'il est possible de 
      renseigner en écrivant votre application. Toutes utilisent le niveau
      <code class="constant">SOL_TCP</code> au lieu de <code class="constant">SOL_SOCKET</code>,
      et elles prennent le pas sur les variables système pour la socket
      courante. Si vous lisez avant d'écrire, les paramètres système seront
      retournés.
    </p><div class="itemizedlist"><ul><li><p><code class="constant">TCP_KEEPCNT</code> : prend le pas sur <code class="varname">
        tcp_keepalive_probes</code></p></li><li><p><code class="constant">TCP_KEEPIDLE</code> : prend le pas sur <code class="varname">
        tcp_keepalive_time</code></p></li><li><p><code class="constant">TCP_KEEPINTVL</code> : prend le pas sur <code class="varname">
        tcp_keepalive_intvl</code></p></li></ul></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="exemples" />4.3. Exemples de code</h3></div></div></div><p>
      Voici un petit exemple qui crée une socket, montre que keepalive est 
      désactivé, puis l'active et vérifie que l'option est réellement positionnée.
    </p><div class="informalexample"><pre class="programlisting">
            /* --- début du programme de test  KEEPALIVE --- */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/socket.h&gt;
#include &lt;netinet/in.h&gt;

int main(void);

int main()
{
   int s;
   int optval;
   socklen_t optlen = sizeof(optval);

   /* Creation de la socket */
   if((s = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP)) &lt; 0) {
      perror("socket()");
      exit(EXIT_FAILURE);
   }

   /* Verifie l'etat de l'option keepalive */
   if(getsockopt(s, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, &amp;optlen) &lt; 0) {
      perror("getsockopt()");
      close(s);
      exit(EXIT_FAILURE);
   }
   printf("SO_KEEPALIVE is %s\n", (optval ? "ON" : "OFF"));

   /* Rend l'option active */
   optval = 1;
   optlen = sizeof(optval);
   if(setsockopt(s, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, optlen) &lt; 0) {
      perror("setsockopt()");
      close(s);
      exit(EXIT_FAILURE);
   }
   printf("SO_KEEPALIVE set on socket\n");

   /* Verifie a nouveau son etat */
   if(getsockopt(s, SOL_SOCKET, SO_KEEPALIVE, &amp;optval, &amp;optlen) &lt; 0) {
      perror("getsockopt()");
      close(s);
      exit(EXIT_FAILURE);
   }
   printf("SO_KEEPALIVE is %s\n", (optval ? "ON" : "OFF"));

   close(s);

   exit(EXIT_SUCCESS);
}

            /* ---  fin du programme de test  KEEPALIVE  --- */
    </pre></div></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title"><a id="applitierce" />5. Implémenter keepalive sur une application tierce</h2></div></div></div><p>
    Tout le monde n'est pas développeur d'application, et tout le monde ne 
    réécrira pas entièrement une application pour combler le manque
    d'une fonctionnalité. Peut-être souhaitez vous ajouter keepalive à une 
    application existante, et même si son auteur n'a pas considéré cela 
    important, vous pensez que ce sera utile.
  </p><p>
    Tout d'abord, souvenez vous de ce qui a été dit précédemment à propos 
    des cas où keepalive est nécessaire. Ensuite vous devrez affecter les
    sockets TCP orientées connexion.
  </p><p>
    Comme Linux ne fournit pas la possibilité d'activer le support keepalive
    via le noyau (les OS de type BSD le permettent souvent), le seul moyen
    est d'appeler <span class="citerefentry"><span class="refentrytitle"><code class="function">setsockopt
    </code></span>(2)</span>
    après la création de la socket. Il y a deux solutions:

    <div class="itemizedlist"><ul><li><p>modification du code source du programme original</p></li><li><p>injection <span class="citerefentry"><span class="refentrytitle"><code class="function">setsockopt</code>
        </span>(2)</span> en utilisant 
        la technique de préchargement de bibliothèque</p></li></ul></div>
  </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="modifiersource" />5.1. Modifier le code source</h3></div></div></div><p>
      Souvenez-vous que keepalive n'est pas orienté programme, mais orienté 
      socket, donc si vous avez de multiples sockets, vous pouvez gérer 
      keepalive séparément pour chacune d'entre elles. La première étape
      consiste à comprendre ce que fait le programme, la seconde à rechercher
      le code pour chaque socket dans le programme. Cela peut être fait en 
      utilisant <span class="citerefentry"><span class="refentrytitle"><span class="command"><strong>grep</strong></span></span>(1)</span>, comme suit:

      <pre class="programlisting">
  <code class="prompt"># </code><strong class="userinput"><code>grep 'socket *(' *.c</code></strong>
      </pre>
    </p><p>
      Cela vous montrera à peu près toutes les sockets du code. L'étape 
      suivante consiste à choisir les bonnes : vous ciblez les sockets TCP,
      donc recherchez <code class="constant">PF_INET</code> (ou <code class="constant">AF_INET</code>),
      <code class="constant">SOCK_STREAM</code> et <code class="constant">IPPROTO_TCP</code> (ou
      plus communément, <code class="constant">0</code>) dans les paramètres de votre
      liste de sockets, et enlevez celles qui ne correspondent pas.
    </p><p>
      Il existe un autre moyen de créer une socket au travers de
      <span class="citerefentry"><span class="refentrytitle"><code class="function">accept</code></span>(2)</span>. En ce ce cas, suivez les sockets
      TCP identifiées et vérifiez si certaines sont en écoute : si c'est
      le cas, gardez à l'esprit que <span class="citerefentry"><span class="refentrytitle">
      <code class="function">accept</code></span>(2)</span> retourne un descripteur de socket, qui doit être ajouté
      à votre liste de sockets.
    </p><p>
      Une fois les sockets identifiées, vous pouvez procéder aux modifications.
      Le patch le plus 'fast &amp; furious' peut consister à simplement ajouter
      la fonction <span class="citerefentry"><span class="refentrytitle"><code class="function">setsockopt</code></span>(2
      )</span> juste après le bloc de création de la socket.
      Éventuellement, vous pouvez ajouter des appels supplémentaires pour
      modifier les paramètres systèmes par défaut de keepalive. Surtout soyez 
      attentif au positionnement des vérifications d'erreurs et des handlers 
      de la fonction, peut-être en recopiant le style du code alentour. Songez
      à affecter à <code class="varname">optval</code> une valeur non nulle et à 
      initialiser <code class="varname">optlen</code> avant d'appeler la fonction.
    </p><p>
      Si vous en avez le temps ou pensez que ce serait plus élégant, essayez 
      d'implémenter complètement le keepalive à votre programme, en incluant
      une option de ligne de commande ou un paramètre de configuration pour 
      laisser à l'utilisateur la liberté d'utiliser ou non keepalive.
    </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a id="libkeepalive" />5.2. <span class="application">libkeepalive</span>: préchargement de bibliothèque</h3></div></div></div><p>
      Dans de nombreux cas vous n'avez pas la possibilité de modifier le code 
      source d'une application, ou bien lorsque vous devez activer keepalive
      pour tous vos programmes, tout patcher et tout recompiler n'est pas 
      recommandé.
    </p><p>
      Le projet <span class="application">libkeepalive</span> a vu le jour pour 
      faciliter l'implémentation du keepalive au sein des applications 
      puisque le noyau Linux ne permet pas de le faire nativement 
      (comme le fait BSD). La page d'accueil du projet 
      <span class="application">libkeepalive</span> est disponible à l'adresse
      <a class="ulink" href="http://libkeepalive.sourceforge.net/" target="_top">
      http://libkeepalive.sourceforge.net/</a>
    </p><p>
      Il consiste en une bibliothèque partagée qui outrepasse l'appel système 
      socket de la plupart des exécutables, sans aucun besoin de les recompiler
      ni de les modifier. La technique repose sur la fonctionnalité de
      pré-chargement (<em class="firstterm">preloading</em>) de
      <span class="citerefentry"><span class="refentrytitle"><span class="command"><strong>ld.so</strong></span></span>(8)</span>, chargeur inclus dans Linux, qui
      qui permet le chargement de bibliothèques partagées avec une priorité
      supérieure à la normale. Les programmes utilisent habituellement l'appel
      de fonction <span class="citerefentry"><span class="refentrytitle"><code class="function">socket</code>
      </span>(2)</span> situé dans la
      <code class="literal">glibc</code>, librairie partagée; avec <span class="application">libkeepalive</span> 
      il est possible d'encapsuler la fonction <span class="citerefentry"><span class="refentrytitle">
      <code class="function">setsockopt</code></span>(2)</span> juste après la création, retournant 
      au programme principal une socket avec keepalive déjà positionné.
      En raison des mécanismes utilisés pour réaliser l'appel système,
      ce procédé ne fonctionne pas lorsque la fonction socket est compilée
      statiquement dans le binaire, comme dans le cas d'un programme lié par 
      l'option <code class="option">-static</code> de <span class="citerefentry"><span class="refentrytitle">
      <span class="command"><strong>gcc</strong></span></span>(1
      )</span>.
    </p><p>
      Après avoir téléchargé et installé <span class="application">libkeepalive</span>,
      vous serez en mesure d'ajouter le support de keepalive à vos programmes
      sans être <code class="literal">root</code> au préalable, simplement en
      initialisant la variable d'environnement <code class="envar">LD_PRELOAD</code>
      avant d'exécuter le programme. Au fait, le super utilisateur peut aussi
      forcer la pré-chargement au travers d'une configuration globale, et 
      les utilisateurs peuvent choisir de le désactiver en positionnant 
      la variable d'environnement <code class="envar">KEEPALIVE</code> à <code class="constant">off</code>.
    </p><p>
      L'environnement est aussi utilisé pour positionner des valeurs
      spécifiques pour les paramètres de keepalive, vous avez donc la
      possibilité de gérer chaque programme de façon distincte,
      en initialisant <code class="envar">KEEPCNT</code>, <code class="envar">KEEPIDLE</code>
      et <code class="envar">KEEPINTVL</code> avant de lancer l'application.
    </p><p>
      Voici un exemple d'utilisation de libkeepalive :

      <div class="informalexample"><pre class="programlisting">
  <code class="prompt">$ </code><strong class="userinput"><code>test</code></strong>
  <code class="computeroutput">SO_KEEPALIVE is OFF</code>

  <code class="prompt">$ </code><strong class="userinput"><code>LD_PRELOAD=libkeepalive.so \</code></strong>
  <code class="prompt">&gt; </code><strong class="userinput"><code>KEEPCNT=20 \</code></strong>
  <code class="prompt">&gt; </code><strong class="userinput"><code>KEEPIDLE=180 \</code></strong>
  <code class="prompt">&gt; </code><strong class="userinput"><code>KEEPINTVL=60 \</code></strong>
  <code class="prompt">&gt; </code><strong class="userinput"><code>test</code></strong>
  <code class="computeroutput">SO_KEEPALIVE is ON
  TCP_KEEPCNT   = 20
  TCP_KEEPIDLE  = 180
  TCP_KEEPINTVL = 60</code>
      </pre></div>
    </p><p>
      Et vous pouvez utiliser <span class="citerefentry"><span class="refentrytitle"><span class="command"><strong>strace</strong></span>
      </span>(1)</span> pour comprendre
      ce qui se passe:
    </p><div class="informalexample"><pre class="programlisting">
  <code class="prompt">$ </code><strong class="userinput"><code>strace test</code></strong>
  <code class="computeroutput">execve("test", ["test"], [/* 26 vars */]) = 0
  [..]
  open("/lib/libc.so.6", O_RDONLY)        = 3
  [..]
  socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 3
  getsockopt(3, SOL_SOCKET, SO_KEEPALIVE, [0], [4]) = 0
  close(3)                                = 0
  [..]
  _exit(0)                                = ?</code>

  <code class="prompt">$ </code><strong class="userinput"><code>LD_PRELOAD=libkeepalive.so \</code></strong>
  <code class="prompt">&gt; </code><strong class="userinput"><code>strace test</code></strong>
  <code class="computeroutput">execve("test", ["test"], [/* 27 vars */]) = 0
  [..]
  open("/usr/local/lib/libkeepalive.so", O_RDONLY) = 3
  [..]
  open("/lib/libc.so.6", O_RDONLY)        = 3
  [..]
  open("/lib/libdl.so.2", O_RDONLY)       = 3
  [..]
  socket(PF_INET, SOCK_STREAM, IPPROTO_TCP) = 3
  setsockopt(3, SOL_SOCKET, SO_KEEPALIVE, [1], 4) = 0
  setsockopt(3, SOL_TCP, TCP_KEEPCNT, [20], 4) = 0
  setsockopt(3, SOL_TCP, TCP_KEEPIDLE, [180], 4) = 0
  setsockopt(3, SOL_TCP, TCP_KEEPINTVL, [60], 4) = 0
  [..]
  getsockopt(3, SOL_SOCKET, SO_KEEPALIVE, [1], [4]) = 0
  [..]
  getsockopt(3, SOL_TCP, TCP_KEEPCNT, [20], [4]) = 0
  [..]
  getsockopt(3, SOL_TCP, TCP_KEEPIDLE, [180], [4]) = 0
  [..]
  getsockopt(3, SOL_TCP, TCP_KEEPINTVL, [60], [4]) = 0
  [..]
  close(3)                                = 0
  [..]
  _exit(0)                                = ?</code>
    </pre></div><p>
      Pour d'autres informations, visitez la page d'accueil du projet
      <span class="application">libkeepalive</span> :
      <a class="ulink" href="http://libkeepalive.sourceforge.net/" target="_top">
      http://libkeepalive.sourceforge.net/</a>
    </p></div></div></div></body></html>