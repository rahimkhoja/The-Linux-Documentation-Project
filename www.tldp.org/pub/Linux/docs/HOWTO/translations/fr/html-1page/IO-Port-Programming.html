<html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>
    
        Petit guide de programmation des ports 
        d'entr&eacute;es / sorties sous Linux
    
    </title><link href="style.css" rel="stylesheet" type="text/css"><meta content="DocBook XSL Stylesheets V1.69.1" name="generator"><meta name="description" content="
	Ce document pr&eacute;sente les diff&eacute;rentes fa&ccedil;ons de programmer des 
	entr&eacute;es / sorties pour les architectures Intel x86 ainsi 
	que de les diff&eacute;rentes m&eacute;thodes permettant l'utilisation de 
	temporisations tr&egrave;s courtes pour les applications Linux tournant 
	en mode utilisateur.
	"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article" lang="fr"><div class="titlepage"><div><div><h1 class="title"><a name="N10001"></a>
    
        Petit guide de programmation des ports 
        d'entr&eacute;es / sorties sous Linux
    
    </h1></div><div><h3 class="subtitle"><i>
    
        Adaptation fran&ccedil;aise du <span class="foreignphrase" lang="en"><em class="foreignphrase">Linux I/O port 
        programming mini-HOWTO</em></span>
    
    </i></h3></div><div><div class="author"><h3 class="author"><span class="firstname">Riku</span> <span class="surname">Saikkonen</span></h3><code class="email">&lt;<a href="mailto:Riku POINT Saikkonen CHEZ hut POINT fi">Riku POINT Saikkonen CHEZ hut POINT fi</a>&gt;</code></div></div><div><p class="othercredit"><span class="contrib">Adaptation fran&ccedil;aise</span>: <span class="firstname">Jean-Fran&ccedil;ois</span> <span class="surname">Pr&eacute;vost</span></p></div><div><p class="othercredit"><span class="contrib">Relecture de la version fran&ccedil;aise</span>: <span class="firstname">Guillaume</span> <span class="surname">Lelarge</span>, <span class="firstname">Jean-Philippe</span> <span class="surname">Gu&eacute;rard</span></p></div><div></div><div><p class="releaseinfo">Version&nbsp;: 3.0.fr.1.1</p></div><div><p class="pubdate">24 avril 2006</p></div><div><div class="revhistory"><table summary="Revision history" width="100%" border="1"><tr><th colspan="3" valign="top" align="left"><b>Historique des versions</b></th></tr><tr><td align="left">Version 3.0.fr.1.1</td><td align="left">2006-04-24</td><td align="left">JPG</td></tr><tr><td colspan="3" align="left">
          
          Conversion en XML. Mise &agrave; jour de l'en-t&ecirc;te du document 
          pour respecter les conventions actuelles du projet Traduc.org.
          
      </td></tr><tr><td align="left">Version 3.0.fr.1.0</td><td align="left">2003-02-04</td><td align="left">JFP, GL, JPG</td></tr><tr><td colspan="3" align="left">Premi&egrave;re traduction fran&ccedil;aise.</td></tr><tr><td align="left">Version 3.0</td><td align="left">2000-12-13</td><td align="left">RS</td></tr></table></div></div><div><div class="abstract"><p class="title"><b>R&eacute;sum&eacute;</b></p><p>
	Ce document pr&eacute;sente les diff&eacute;rentes fa&ccedil;ons de programmer des 
	entr&eacute;es / sorties pour les architectures Intel x86 ainsi 
	que de les diff&eacute;rentes m&eacute;thodes permettant l'utilisation de 
	temporisations tr&egrave;s courtes pour les applications Linux tournant 
	en mode utilisateur.
	</p></div></div></div><div></div><hr></div><div class="toc"><p><b>Table des mati&egrave;res</b></p><dl><dt><span class="sect1"><a href="#N10061">1. Introduction</a></span></dt><dd><dl><dt><span class="sect2"><a href="#N1006A">1.1. Droits d'utilisation</a></span></dt><dt><span class="sect2"><a href="#N1008F">1.2. Commentaires et corrections</a></span></dt></dl></dd><dt><span class="sect1"><a href="#N100A0">2. Utilisation des ports d'entr&eacute;es / sorties en langage C</a></span></dt><dd><dl><dt><span class="sect2"><a href="#N100A3">2.1. La m&eacute;thode normale</a></span></dt><dt><span class="sect2"><a href="#N101C3">2.2. Une m&eacute;thode alternative&nbsp;: <code class="filename">/dev/port</code></a></span></dt></dl></dd><dt><span class="sect1"><a href="#N10225">3. Interruptions (IRQ) et acc&egrave;s DMA</a></span></dt><dt><span class="sect1"><a href="#N1023C">4. Temporisation de haute pr&eacute;cision</a></span></dt><dd><dl><dt><span class="sect2"><a href="#N1023F">4.1. Temporisations</a></span></dt><dt><span class="sect2"><a href="#N10352">4.2. Mesure du temps</a></span></dt></dl></dd><dt><span class="sect1"><a href="#N1036D">5. D'autres langages de programmation</a></span></dt><dt><span class="sect1"><a href="#N10381">6. Quelques ports utiles</a></span></dt><dd><dl><dt><span class="sect2"><a href="#N10393">6.1. Le port parall&egrave;le</a></span></dt><dt><span class="sect2"><a href="#N10418">6.2. Le port de manette de jeu</a></span></dt><dt><span class="sect2"><a href="#N10471">6.3. Le port s&eacute;rie</a></span></dt></dl></dd><dt><span class="sect1"><a href="#N10485">7. Conseils</a></span></dt><dt><span class="sect1"><a href="#N1049C">8. Probl&egrave;mes et solutions</a></span></dt><dt><span class="sect1"><a href="#N1051C">9. Code d'exemple</a></span></dt><dt><span class="sect1"><a href="#N10524">10. Remerciements</a></span></dt><dt><span class="sect1"><a href="#adaptation-francaise">11. Adaptation fran&ccedil;aise</a></span></dt><dd><dl><dt><span class="sect2"><a href="#N1052E">11.1. Traduction</a></span></dt><dt><span class="sect2"><a href="#N10536">11.2. Relecture</a></span></dt></dl></dd></dl></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N10061"></a>1.&nbsp;Introduction</h2></div></div><div></div></div><p>
    
      Ce document traite de la fa&ccedil;on de programmer des entr&eacute;es / sorties 
      mat&eacute;rielles sur une architecture Intel x86 ainsi que de 
      l'utilisation de temporisations tr&egrave;s courtes pour des applications 
      s'ex&eacute;cutant en mode utilisateur sous Linux. Ce document est un 
      descendant du tr&egrave;s court Petit guide des ports d'entr&eacute;es-sorties 
      (<span class="foreignphrase" lang="en"><em class="foreignphrase">IO-Port mini-HOWTO</em></span>) du 
      m&ecirc;me auteur.
      
    </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="N1006A"></a>1.1.&nbsp;Droits d'utilisation</h3></div></div><div></div></div><p>
        Copyright &copy; 1995-2000 Riku Saikkonen.
    </p><p>
        Copyright &copy; 2002-2006 Jean-Fran&ccedil;ois Pr&eacute;vost, Guillaume 
        Lelarge et Jean-Philippe Gu&eacute;rard pour la version fran&ccedil;aise.
    </p><p>

        Sauf mention du contraire, les Guides pratiques Linux sont la 
        propri&eacute;t&eacute; de leurs auteurs respectifs. Les Guides pratiques 
        Linux peuvent &ecirc;tre copi&eacute;s ou diffus&eacute;s, en partie ou en 
        int&eacute;gralit&eacute;, sous tout format qu'il soit physique ou 
        &eacute;lectronique, tant que ce texte d'information sur les droits 
        d'utilisation est conserv&eacute; dans toutes les copies. Les 
        diffusions commerciales de ce document sont permises et 
        encourag&eacute;es&nbsp;; cependant, l'auteur souhaiterait &ecirc;tre tenu au 
        courant de telles diffusions.
        
    </p><p>
    
        Toute traduction, &#339;uvre d&eacute;riv&eacute;e ou compilation incluant un Guide 
        pratique Linux doit &ecirc;tre diffus&eacute;e en respectant les conditions 
        de ce texte d'information sur les droits d'utilisation. 
        Autrement dit, vous n'avez pas le droit de cr&eacute;er des &#339;uvres 
        d&eacute;riv&eacute;es d'un Guide pratique et d'imposer des restrictions 
        suppl&eacute;mentaires &agrave; sa diffusion. Des exceptions &agrave; ces r&egrave;gles 
        peuvent &ecirc;tre accord&eacute;es dans certains cas&nbsp;; contactez (en 
        anglais) le coordinateur des Guides pratiques Linux &agrave; l'adresse 
        ci-dessous.
    
    </p><p>

        En r&eacute;sum&eacute;, nous souhaitons encourager la diss&eacute;mination de ces 
        informations au travers le plus grand nombre de circuits 
        possibles. Cependant, nous souhaitons conserver nos droits 
        d'auteurs sur ces Guides pratiques et nous souhaitons &ecirc;tre 
        inform&eacute; de tout projet de diffusion des Guides pratiques.

    </p><p>
    
        Pour toute question, envoyez un courrier &eacute;lectronique, en 
        anglais, &agrave; Tim Bynum, coordinateur des Guides pratiques Linux, &agrave; 
        l'adresse
        
        <code class="email">&lt;<a href="mailto:tjbynum CHEZ metalab POINT unc POINT edu">tjbynum CHEZ metalab POINT unc POINT edu</a>&gt;</code>.
    
    </p><p><span class="foreignphrase" lang="en"><em class="foreignphrase">

        Unless otherwise stated, Linux HOWTO documents are copyrighted 
        by their respective authors. Linux HOWTO documents may be 
        reproduced and distributed in whole or in part, in any medium 
        physical or electronic, as long as this copyright notice is 
        retained on all copies. Commercial redistribution is allowed and 
        encouraged; however, the author would like to be notified of any 
        such distributions.

    </em></span></p><p><span class="foreignphrase" lang="en"><em class="foreignphrase">

        All translations, derivative works, or aggregate works 
        incorporating any Linux HOWTO documents must be covered under 
        this copyright notice. That is, you may not produce a derivative 
        work from a HOWTO and impose additional restrictions on its 
        distribution. Exceptions to these rules may be granted under 
        certain conditions; please contact the Linux HOWTO coordinator 
        at the address given below.

    </em></span></p><p><span class="foreignphrase" lang="en"><em class="foreignphrase">

        In short, we wish to promote dissemination of this information 
        through as many channels as possible. However, we do wish to 
        retain copyright on the HOWTO documents, and would like to be 
        notified of any plans to redistribute the HOWTOs.

    </em></span></p><p><span class="foreignphrase" lang="en"><em class="foreignphrase">

        If you have questions, please contact Tim Bynum, the Linux HOWTO 
        coordinator, at
        
        <code class="email">&lt;<a href="mailto:tjbynum AT metalab DOT unc DOT edu">tjbynum AT metalab DOT unc DOT edu</a>&gt;</code>
        
        via email.

    </em></span></p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="N1008F"></a>1.2.&nbsp;Commentaires et corrections</h3></div></div><div></div></div><p>

      Si vous avez des remarques ou des corrections, n'h&eacute;sitez pas &agrave; m'&eacute;crire
      en anglais &agrave; l'adresse 
      
      <code class="email">&lt;<a href="mailto:Riku POINT Saikkonen CHEZ hut POINT fi">Riku POINT Saikkonen CHEZ hut POINT fi</a>&gt;</code> 
      
      &hellip;

    </p><p>
    
    N'h&eacute;sitez pas &agrave; faire parvenir vos commentaires et suggestions
    concernant l'adaptation fran&ccedil;aise de ce document au projet
    <a href="http://traduc.org" target="_top">Traduc.org</a> &agrave;
    l'adresse&nbsp;:
    
    <code class="email">&lt;<a href="mailto:commentaires CHEZ traduc POINT org">commentaires CHEZ traduc POINT org</a>&gt;</code>.

    </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N100A0"></a>2.&nbsp;Utilisation des ports d'entr&eacute;es / sorties en langage C</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="N100A3"></a>2.1.&nbsp;La m&eacute;thode normale</h3></div></div><div></div></div><p>
	Les routines pour acc&eacute;der aux ports d'entr&eacute;es / sorties sont 
	situ&eacute;es dans le fichier d'en-t&ecirc;te 
	<code class="filename">/usr/include/asm/io.h</code> (ou 
	<code class="filename">linux/include/asm-i386/io.h</code> dans les 
	sources du noyau Linux). Ces routines sont des macros, il suffit
	donc de d&eacute;clarer <code class="literal">#include 
	&lt;asm/io.h&gt;</code>; dans votre code source sans avoir 
	besoin de biblioth&egrave;ques additionnelles.
      </p><p>
	&Agrave; cause d'une limitation de gcc (pr&eacute;sente dans toutes les 
	versions que je connais, egcs y compris) vous 
	<span class="emphasis"><em>devez</em></span> compiler le code source qui fait 
	appel &agrave; ces routines avec le drapeau d'optimisation 
	(<span><strong class="command">gcc -O1</strong></span> ou plus), ou alternativement en 
	d&eacute;clarant <code class="literal">#define extern static</code> avant la 
	ligne <code class="literal">#include &lt;asm/io.h&gt;</code> 
	(n'oubliez pas de rajouter ensuite <code class="literal">#undef 
	extern</code>).
      </p><p>
	Pour le d&eacute;bogage, vous pouvez compiler avec les drapeaux 
	suivants (tout du moins avec les versions les plus r&eacute;centes de 
	gcc)&nbsp;: <span><strong class="command">gcc -g -O</strong></span>. Il faut savoir que 
	l'optimisation engendre un comportement parfois bizarre de la 
	part du d&eacute;bogueur. Si cela vous pose un r&eacute;el probl&egrave;me, vous 
	pouvez toujours utiliser les routines d'acc&egrave;s aux ports 
	d'entr&eacute;es / sorties dans un fichier source s&eacute;par&eacute;, et ne 
	compiler que ce fichier avec le drapeau d'optimisation activ&eacute;.
      </p><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="N100D1"></a>2.1.1.&nbsp;Les permissions</h4></div></div><div></div></div><p>
	  Avant d'acc&eacute;der aux ports, vous devez donner &agrave; votre 
	  programme la permission de le faire. Pour cela, il vous faut 
	  faire appel &agrave; la fonction <code class="function">ioperm()</code> 
	  (d&eacute;clar&eacute;e dans <code class="filename">unistd.h</code> et d&eacute;finie dans le 
	  noyau) quelque part au d&eacute;but de votre programme (avant tout 
	  acc&egrave;s aux ports d'entr&eacute;es / sorties). La syntaxe est la 
	  suivante&nbsp;: 
	  <code class="function">ioperm(<em class="replaceable"><code>premier_port</code></em>, , 
	  <em class="replaceable"><code>nombre</code></em>, , 
	  <em class="replaceable"><code>activer</code></em>)</code>, o&ugrave;
	  <em class="replaceable"><code>premier_port</code></em> est le num&eacute;ro 
	  du premier port auquel on souhaite avoir acc&egrave;s et 
	  <em class="replaceable"><code>nombre</code></em> le nombre de ports 
	  cons&eacute;cutifs auxquels on veut avoir la permission d'acc&eacute;der.
	  Par exemple, <code class="function">ioperm(0x300, 5, 1)</code> donnerait 
	  acc&egrave;s aux ports <code class="literal">0x300</code> jusqu'&agrave; 
	  <code class="literal">0x304</code> (au total 5 ports). Le 
	  dernier argument est une valeur bool&eacute;enne sp&eacute;cifiant si on 
	  autorise l'acc&egrave;s aux ports (vrai [1]) ou si on le 
	  restreint (faux [0]). Pour activer l'acc&egrave;s &agrave; plusieurs 
	  ports non cons&eacute;cutifs, vous pouvez faire plusieurs appels &agrave; 
	  <code class="function">ioperm()</code>. Reportez vous &agrave; la page de manuel 
	  <span class="citerefentry"><span class="refentrytitle">ioperm</span>(2)</span> pour plus de d&eacute;tails sur la syntaxe.
	</p><p>
	  L'appel &agrave; <code class="function">ioperm()</code> dans votre 
	  programme n&eacute;cessite les privil&egrave;ges de
	  super utilisateur (root). Il faut donc que votre programme 
	  soit ex&eacute;cut&eacute; en tant qu'utilisateur root, ou qu'il soit rendu 
	  setuid root. Vous pouvez abandonner les privil&egrave;ges 
	  d'utilisateur root apr&egrave;s  l'appel &agrave; 
	  <code class="function">ioperm()</code>. Il n'est pas imp&eacute;ratif
	  d'abandonner de fa&ccedil;on explicite  les privil&egrave;ges d'acc&egrave;s aux 
	  ports en utilisant <code class="function">ioperm( ... , 0 )</code> 
	  &agrave; la fin de votre programme, ceci est fait automatiquement 
	  lorsque le processus se termine.
	</p><p>
	  L'utilisation de <code class="function">setuid()</code> par un 
	  utilisateur non privil&eacute;gi&eacute; ne supprime pas l'acc&egrave;s accord&eacute; aux 
	  ports par <code class="function">ioperm()</code>. En revanche, lors d'un 
	  <code class="function">fork()</code>, le processus fils n'h&eacute;rite pas des 
	  permissions de son p&egrave;re (qui lui les garde).
	</p><p>
	  La fonction <code class="function">ioperm()</code> permet de contr&ocirc;ler 
	  l'acc&egrave;s aux ports de <code class="literal">0x000</code> &agrave; 
	  <code class="literal">0x3ff</code> uniquement. Pour les ports 
	  sup&eacute;rieurs, vous devez utiliser <code class="function">iopl()</code> 
	  qui ouvre un acc&egrave;s &agrave; tous les ports d'un coup. Pour donner &agrave; 
	  votre programme l'acc&egrave;s &agrave; <span class="emphasis"><em>tous</em></span> les ports 
	  d'entr&eacute;es / sorties (soyez certains de ce que vous faites 
	  car l'acc&egrave;s &agrave; des ports inappropri&eacute;s peut avoir des 
	  cons&eacute;quences d&eacute;sastreuses pour votre syst&egrave;me), il suffit de 
	  passer &agrave; la fonction un argument de valeur 
	  <code class="literal">3</code> (<code class="function">iopl(3)</code>). 
	  Reportez-vous &agrave; la page de manuel 
	  <span class="citerefentry"><span class="refentrytitle">iopl</span>(2)</span>
	  pour plus de d&eacute;tails.
	</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="N10147"></a>2.1.2.&nbsp;L'acc&egrave;s aux ports</h4></div></div><div></div></div><p>
	  Pour lire un octet (8 bits) sur un port, un appel &agrave;
	  <code class="function">inb(<em class="replaceable"><code>port</code></em>)</code> 
	  retourne la valeur de l'octet lu. Pour l'&eacute;criture d'un octet, 
	  il suffit d'appeler la fonction 
	  <code class="function">outb(<em class="replaceable"><code>valeur</code></em>, , 
	  <em class="replaceable"><code>port</code></em>)</code> (attention &agrave; 
	  l'ordre des param&egrave;tres).
	  La lecture d'un mot (16 bits) sur les ports 
	  <code class="literal"><em class="replaceable"><code>x</code></em></code> et 
	  <code class="literal"><em class="replaceable"><code>x</code></em>+1</code> (un octet 
	  sur chaque port pour constituer un mot gr&acirc;ce &agrave; l'instruction 
	  assembleur <code class="function">inw</code>), faites appel &agrave; 
	  <code class="function">inw(<em class="replaceable"><code>x</code></em>)</code>. Enfin, 
	  pour l'&eacute;criture d'un mot sur les deux ports, utilisez 
	  <code class="function">outw(<em class="replaceable"><code>value</code></em>, , 
	  <em class="replaceable"><code>x</code></em>)</code>. 
	  Si vous n'&ecirc;tes pas certain quant &agrave; la fonction &agrave; utiliser 
	  (octet ou mot), il est sage de se cantonner &agrave; l'appel de 
	  <code class="function">inb()</code> et <code class="function">outb()</code>. La 
	  plupart des p&eacute;riph&eacute;riques sont con&ccedil;us pour des acc&egrave;s sur un 
	  octet. Notez que toutes les instructions d'acc&egrave;s aux ports 
	  n&eacute;cessitent un temps d'ex&eacute;cution d'au minimum une 
	  microseconde.
	</p><p>
	  Les macros <code class="function">inb_p()</code>, 
	  <code class="function">outb_p()</code>, 
	  <code class="function">inw_p()</code> et 
	  <code class="function">outw_p()</code> fonctionnent  de mani&egrave;re 
	  identique &agrave; celles &eacute;voqu&eacute;es pr&eacute;c&eacute;demment &agrave; l'exception du fait 
	  qu'elles effectuent un court temps de pause additionnel apr&egrave;s 
	  l'acc&egrave;s au port (environ une microseconde). Vous avez la 
	  possibilit&eacute; d'allonger ce temps de pause &agrave; quatre 
	  microsecondes avec la directive <code class="literal">#define 
	  REALLY_SLOW_IO</code> avant de d&eacute;clarer 
	  <code class="literal">#include &lt;asm/io.h&gt;</code>. Ces macros 
	  utilisent normalement une &eacute;criture sur le port 
	  <code class="literal">0x80</code> pour leur temps de pause (sauf en 
	  d&eacute;clarant un <code class="literal">#define 
	  SLOW_IO_BY_JUMPING</code>, qui est en 
	  revanche moins pr&eacute;cis). Vous devez donc au pr&eacute;alable autoriser 
	  l'acc&egrave;s au port <code class="literal">0x80</code> avec 
	  <code class="function">ioperm()</code> (l'&eacute;criture sur le port 
	  <code class="literal">0x80</code> ne devrait avoir aucun effet 
	  ind&eacute;sirable sur votre syst&egrave;me).
	</p><p>
	  Si vous &ecirc;tes &agrave; la recherche de m&eacute;thodes plus souples 
	  d'utilisation, lisez la suite&nbsp;&hellip;
	</p><p>
	  Des pages de manuel pour
	  <span class="citerefentry"><span class="refentrytitle">ioperm</span>(2)</span>,
	  <span class="citerefentry"><span class="refentrytitle">iopl</span>(2)</span> et les macros d&eacute;crites ci-dessus sont 
	  disponibles dans les collections assez r&eacute;centes des pages de 
	  manuel Linux.
	</p></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="N101C3"></a>2.2.&nbsp;Une m&eacute;thode alternative&nbsp;: <code class="filename">/dev/port</code></h3></div></div><div></div></div><p>
	Un autre moyen d'acc&eacute;der aux ports d'entr&eacute;es / sorties est 
	d'ouvrir en lecture ou en &eacute;criture le p&eacute;riph&eacute;rique <code class="filename">/dev/port</code> (un p&eacute;riph&eacute;rique en mode 
	caract&egrave;re, num&eacute;ro majeur <code class="literal">1</code>, mineur 
	<code class="literal">4</code>) au moyen de la fonction 
	<code class="function">open()</code>. Notons que les fonctions en 
	<code class="function">f*()</code> de la biblioth&egrave;que stdio font appel &agrave; 
	des tampons m&eacute;moires internes, il vaut donc mieux les &eacute;viter. Il 
	suffit ensuite, comme dans le cas d'un fichier, de se 
	positionner sur l'octet appropri&eacute; au moyen de la fonction 
	<code class="function">lseek()</code> (l'octet <code class="literal">0</code> du 
	fichier &eacute;quivaut au port <code class="literal">0x00</code>, l'octet 
	<code class="literal">1</code> au port <code class="literal">0x01</code>, et c&aelig;tera) 
	et d'en lire (<code class="function">read()</code>) ou &eacute;crire 
	(<code class="function">write()</code>) un octet ou un mot.
      </p><p>
	Il est &eacute;vident que l'application doit avoir la permission 
	d'acc&eacute;der au p&eacute;riph&eacute;rique <code class="filename">/dev/port</code> pour que cette m&eacute;thode 
	fonctionne. Cette fa&ccedil;on de faire reste certainement plus lente 
	que la premi&egrave;re, mais elle ne n&eacute;cessite ni optimisation lors de 
	la compilation ni appel &agrave; <code class="function">ioperm()</code>. L'acc&egrave;s 
	aux privil&egrave;ges de super-utilisateur n'est pas imp&eacute;ratif non 
	plus, si vous donnez les permissions ad&eacute;quates &agrave; un utilisateur 
	ou un groupe pour acc&eacute;der &agrave; <code class="filename">/dev/port</code> (cela reste tout de m&ecirc;me 
	une tr&egrave;s mauvaise id&eacute;e du point de vue de la s&eacute;curit&eacute; du 
	syst&egrave;me, puisqu'il devient possible de porter atteinte au 
	syst&egrave;me, peut-&ecirc;tre m&ecirc;me d'obtenir le statut de root en utilisant
	<code class="filename">/dev/port</code> pour acc&eacute;der 
	directement aux disques durs, cartes r&eacute;seaux, et c&aelig;tera).
      </p><p>
	Il n'est pas possible d'utiliser les fonctions
	<span class="citerefentry"><span class="refentrytitle">select</span>(2)</span> ou
	<span class="citerefentry"><span class="refentrytitle">poll</span>(2)</span>
	pour lire <code class="filename">/dev/port</code> puisque l'&eacute;lectronique du syst&egrave;me n'a pas la
	possibilit&eacute; d'avertir le microprocesseur qu'une valeur a chang&eacute; sur
	un port d'entr&eacute;e.
      </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N10225"></a>3.&nbsp;Interruptions (IRQ) et acc&egrave;s DMA</h2></div></div><div></div></div><p>
      Vous ne pouvez tout simplement pas utiliser directement les
      interruptions ou l'acc&egrave;s DMA depuis un processus en mode 
      utilisateur. Pour cela, il vous faut d&eacute;velopper un pilote pour le 
      noyau. Reportez-vous au <a href="http://www.tldp.org/LDP/khg/HyperNews/get/khg.html" target="_top">Linux
      Kernel Hacker's Guide</a> pour plus de d&eacute;tails et au code 
      source du noyau pour des exemples.
    </p><p>
      Vous avez cependant la possibilit&eacute; de d&eacute;sactiver les
      interruptions depuis une application en mode utilisateur, mais
      cela peut s'av&eacute;rer dangereux (m&ecirc;me les pilotes du noyau ne le
      font que pour des p&eacute;riodes de temps tr&egrave;s br&egrave;ves). Apr&egrave;s appel
      &agrave; <code class="function">iopl(3)</code>, vous pouvez d&eacute;sactiver les
      interruptions en utilisant
      <code class="function">asm("cli");</code> et les r&eacute;activer avec
      <code class="function">asm("sti");</code>.
    </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N1023C"></a>4.&nbsp;Temporisation de haute pr&eacute;cision</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="N1023F"></a>4.1.&nbsp;Temporisations</h3></div></div><div></div></div><p>
	Avant toutes choses, il est important de pr&eacute;ciser
	l'impossibilit&eacute; de garantir un contr&ocirc;le pr&eacute;cis des temps
	d'ex&eacute;cution de processus en mode utilisateur du fait de la
	nature multit&acirc;che du noyau Linux. Votre processus peut &ecirc;tre
	mis en sommeil &agrave; n'importe quel moment pour une dur&eacute;e allant de
	10&nbsp;millisecondes &agrave; quelques secondes (sur un syst&egrave;me
	dont la charge est tr&egrave;s importante). Malgr&eacute; tout, pour la 
	plupart des applications utilisant les ports d'entr&eacute;es / 
	sorties, cela n'est pas tr&egrave;s important. Si vous voulez minimiser 
	cet inconv&eacute;nient, vous pouvez donner &agrave; votre processus une 
	priorit&eacute; plus haute (reportez-vous &agrave; la page de manuel de 
	<span class="citerefentry"><span class="refentrytitle">nice</span>(2)</span>) ou faire appel &agrave; l'ordonnancement temps-r&eacute;el 
	(voir ci-apr&egrave;s).
      </p><p>
	Si vous souhaitez obtenir une pr&eacute;cision de temporisation plus
	&eacute;lev&eacute;e que celle qu'offre les processus en mode utilisateur 
	usuels, sachez qu'il existe des possibilit&eacute;s de support 
	&laquo;&nbsp;temps-r&eacute;el&nbsp;&raquo; en mode utilisateur. Les 
	noyaux Linux de la s&eacute;rie 2.x permettent de travailler en quasi 
	temps-r&eacute;el. Pour les d&eacute;tails, reportez-vous &agrave; la page de manuel 
	de
	<span class="citerefentry"><span class="refentrytitle">sched_setscheduler</span>(2)</span>.
	Il existe &eacute;galement des versions sp&eacute;ciales du noyau offrant un 
	vrai ordonnancement temps-r&eacute;el.
	
      </p><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="N10254"></a>4.1.1.&nbsp;Avec <code class="function">sleep()</code> et
	      <code class="function">usleep()</code>
	</h4></div></div><div></div></div><p>
	  Commen&ccedil;ons tout d'abord par les appels de temporisation les
	  plus simples. Pour des temporisation de plusieurs secondes,
	  le meilleur choix est probablement la fonction 
	  <code class="function">sleep()</code>. Pour des dur&eacute;es au minimum 
	  de l'ordre de dizaines de millisecondes (10&nbsp;millisecondes
	  semblent &ecirc;tre la dur&eacute;e minimum), <code class="function">usleep()</code>
	  devrait s'av&eacute;rer suffisant. Ces fonctions lib&egrave;rent l'acc&egrave;s au
	  microprocesseur pour d'autres processus, &eacute;vitant ainsi le
	  gaspillage du temps machine. Les pages de manuel de
	  <span class="citerefentry"><span class="refentrytitle">sleep</span>(3)</span> et
	  <span class="citerefentry"><span class="refentrytitle">usleep</span>(3)</span> vous donneront plus de pr&eacute;cisions.
	</p><p>
	  Pour des temporisations de moins de 50 millisecondes (en 
	  fonction de la cadence du microprocesseur, de la machine ainsi 
	  que de la charge du syst&egrave;me), redonner le processeur aux 
	  autres processus prend &eacute;norm&eacute;ment de temps. En effet 
	  l'ordonnanceur des t&acirc;ches du noyau Linux (en tout cas pour les 
	  microprocesseurs de la famille x86) prend g&eacute;n&eacute;ralement au 
	  moins 10 &agrave; 30 millisecondes avant de rendre le contr&ocirc;le
	  au processus. De ce fait, dans les temporisations de courte 
	  dur&eacute;e,
	  <span class="citerefentry"><span class="refentrytitle">usleep</span>(3)</span> effectue en r&eacute;alit&eacute; une pause plus longue que 
	  celle sp&eacute;cifi&eacute;e en param&egrave;tre, prenant au moins 
	  10&nbsp;millisecondes suppl&eacute;mentaires.
	</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="N1027D"></a>4.1.2.&nbsp;<code class="function">nanosleep()</code></h4></div></div><div></div></div><p>
	  Dans les noyaux Linux de la s&eacute;rie 2.0.x est apparu l'appel
	  syst&egrave;me <code class="function">nanosleep()</code> (voir la page de 
	  manuel de
	  <span class="citerefentry"><span class="refentrytitle">nanosleep</span>(2)</span>)
	  permettant d'endormir ou de retarder un processus pendant
	  un laps de temps tr&egrave;s court (quelques microsecondes ou plus).
	</p><p>
	  Pour des attentes &le; 2 millisecondes, si (et seulement si) 
	  votre processus fonctionne en ordonnancement quasi temps-r&eacute;el 
	  (au moyen de 
	  <code class="function">sched_setscheduler()</code>), 
	  <code class="function">nanosleep()</code> fait appel &agrave; une boucle 
	  d'attente&nbsp;; si tel n'est pas le cas, le processus 
	  s'endort simplement tout comme avec 
	  <code class="function">usleep()</code>.
	</p><p>
	  La boucle d'attente utilise <code class="function">udelay()</code> (une 
	  fonction interne au noyau utilis&eacute;e par beaucoup de pilotes), 
	  la dur&eacute;e de celle-ci &eacute;tant calcul&eacute;e en fonction du nombre de
	  <code class="literal">BogoMips</code>. La vitesse de ce type de boucle 
	  d'attente est une des grandeurs que les
	  <code class="literal">BogoMips</code> permettent de mesurer de fa&ccedil;on 
	  pr&eacute;cise. Voyez <code class="filename">/usr/include/asm/delay.h</code> pour 
	  plus de d&eacute;tails quant &agrave; son fonctionnement.
	</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="N102AF"></a>4.1.3.&nbsp;Temporisations gr&acirc;ce aux ports d'entr&eacute;e / 
	       sortie</h4></div></div><div></div></div><p>
	  Les acc&egrave;s aux ports d'entr&eacute;e / sortie sont un autre moyen 
	  d'obtenir des temporisations. L'&eacute;criture ou la lecture d'un 
	  octet sur le port <code class="literal">0x80</code> (voir ci-dessus la 
	  proc&eacute;dure &agrave; suivre) devrait avoir pour cons&eacute;quence un 
	  retard d'une microseconde, ind&eacute;pendamment du type et de la 
	  cadence du microprocesseur. Vous pouvez donc proc&eacute;der de la 
	  sorte afin d'obtenir un retard de quelques microsecondes. 
	  L'&eacute;criture sur ce port ne devrait pas avoir d'effets 
	  secondaires sur une machine classique, pour preuve certains 
	  pilotes du noyau font appel &agrave; cette m&eacute;thode. C'est &eacute;galement 
	  de cette mani&egrave;re que 
	  <code class="function">{in|out}[bw]_p()</code> 
	  effectue une pause (voir <code class="filename">asm/io.h</code>).
	</p><p>
	  Plus pr&eacute;cis&eacute;ment, une op&eacute;ration de lecture ou d'&eacute;criture sur 
	  la plupart des ports dans l'intervalle 
	  <code class="literal">0x000</code>-<code class="literal">0x3ff</code> prend 
	  1&nbsp;microseconde. Par exemple, si vous utilisez directement 
	  le port parall&egrave;le, il suffit d'utiliser des 
	  <code class="function">inb()</code> additionnels sur ce port pour 
	  obtenir une temporisation.
	</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="N102CF"></a>4.1.4.&nbsp;Temporisations en assembleur</h4></div></div><div></div></div><p>
	  Si vous connaissez le type et la fr&eacute;quence du processeur de la 
	  machine sur laquelle votre programme va s'ex&eacute;cuter, vous 
	  pouvez coder en dur les temporisations en faisant appel &agrave; 
	  certaines instructions assembleur. Rappelez-vous cependant
	  qu'&agrave; tout moment votre processus peut-&ecirc;tre mis en attente par 
	  l'ordonnanceur et, de ce fait, les temporisations peuvent 
	  s'av&eacute;rer plus longues que souhait&eacute;es.
	</p><p>
	  Pour les donn&eacute;es du tableau ci-dessous, la fr&eacute;quence interne 
	  du microprocesseur d&eacute;termine le nombre de cycles d'horloge 
	  consomm&eacute;s. Par exemple, pour un microprocesseur &agrave; 50&nbsp;Mhz 
	  (un 486DX-50), un cycle d'horloge dure 1/50000000 de seconde 
	  (soit 200&nbsp;nanosecondes).
	</p><div class="informaltable"><table width="100%" border="1"><colgroup><col width="33%"><col width="33%"><col width="34%"></colgroup><thead><tr><th align="center">Instruction</th><th align="center">cycles d'horloge i386</th><th align="center">cycles d'horloge i486</th></tr></thead><tbody><tr><td align="center"><code class="literal">xchg %bx,%bx</code></td><td align="center">3</td><td align="center">3</td></tr><tr><td align="center"><code class="literal">nop</code></td><td align="center">3</td><td align="center">1</td></tr><tr><td align="center"><code class="literal">or %ax,%ax</code></td><td align="center">2</td><td align="center">1</td></tr><tr><td align="center"><code class="literal">mov %ax,%ax</code></td><td align="center">2</td><td align="center">1</td></tr><tr><td align="center"><code class="literal">add %ax,0</code></td><td align="center">2</td><td align="center">1</td></tr></tbody></table></div><p>
	  Les cycles d'horloges du Pentium devraient &ecirc;tre les m&ecirc;mes 
	  que ceux du 486, &agrave; l'exception du Pentium Pro / II, dont 
	  l'instruction <code class="literal">add %ax, 0</code> peut ne 
	  consommer qu'un demi cycle d'horloge. Cette instruction 
	  peut-&ecirc;tre parfois &ecirc;tre combin&eacute;e avec une autre (cependant, du 
	  fait de l'algorithme d'ex&eacute;cution hors de s&eacute;quence 
	  (<span class="foreignphrase"><em class="foreignphrase">out-of-order</em></span>), il 
	  n'est pas n&eacute;cessaire qu'il s'agisse d'une instruction 
	  cons&eacute;cutive dans le flot).
	</p><p>
	  Les instructions <code class="literal">nop</code> et 
	  <code class="literal">xchg</code> du tableau ne devraient pas avoir 
	  d'effets secondaires. Les autres, en revanche, peuvent 
	  modifier le registre d'&eacute;tat, mais cela reste sans gravit&eacute; 
	  puisque gcc devrait le d&eacute;tecter. <code class="literal">xchg 
	  %bx,%bx</code> reste un bon compromis comme 
	  instruction de temporisation.
	</p><p>
	  Pour utiliser ces instructions, placez un appel
	  <code class="function">asm("<em class="replaceable"><code>instruction</code></em>")</code> 
	  dans votre programme. La syntaxe d'appel de ces instructions 
	  est telle qu'&eacute;num&eacute;r&eacute;e dans le tableau ci-dessus. Si vous 
	  pr&eacute;f&eacute;rez grouper plusieurs instructions dans le m&ecirc;me appel &agrave; 
	  <code class="function">asm</code>, il vous suffit de les s&eacute;parer par 
	  des points-virgules. Par exemple 
	  <code class="function">asm("nop&nbsp;; nop&nbsp;; nop&nbsp;; 
	  nop")</code> ex&eacute;cute quatre fois l'instruction 
	  <code class="literal">nop</code>, effectuant une temporisation de quatre 
	  cycles d'horloge sur un i486 ou un Pentium (ou douze cycles 
	  sur un i386).
	</p><p>
	  Les instructions <code class="function">asm()</code> sont directement int&eacute;gr&eacute;es au code par gcc, &eacute;vitant
	  ainsi la perte de temps que pourrait engendrer un appel de fonction classique.
	</p><p>
	  Les temporisations de moins d'un cycle d'horloge sont impossibles sur les
	  architectures x86 d'Intel.
	</p></div><div class="sect3" lang="fr"><div class="titlepage"><div><div><h4 class="title"><a name="N10345"></a>4.1.5.&nbsp;<code class="literal">rdtsc</code> pour Pentium</h4></div></div><div></div></div><p>
	  Avec les microprocesseurs Pentium, vous avez la possibilit&eacute; de 
	  conna&icirc;tre le nombre de cycles d'horloge &eacute;coul&eacute;s depuis le 
	  dernier red&eacute;marrage avec le code C suivant (qui fait appel &agrave; 
	  l'instruction appel&eacute;e RDTSC)&nbsp;:
	</p><pre class="programlisting">
	    extern __inline__ unsigned long long int rdtsc()
	    {
	    unsigned long long int x;
	    __asm__ volatile (".byte 0x0f, 0x31" : "=A" (x));
	    return x;
	    }
	  </pre><p>
	  Vous pouvez scruter cette valeur dans une boucle d'attente 
	  afin d'obtenir un retard correspondant au nombre de cycles 
	  d'horloge que vous souhaitez.
	</p></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="N10352"></a>4.2.&nbsp;Mesure du temps</h3></div></div><div></div></div><p>
	Pour des dur&eacute;es de la pr&eacute;cision d'une seconde, il est 
	certainement plus simple d'utiliser la fonction 
	<code class="function">time()</code>. Pour obtenir plus de pr&eacute;cision, 
	<code class="function">gettimeofday()</code> a une pr&eacute;cision d'environ 
	une microseconde (mais rappelez-vous de l'ordonnancement d&eacute;j&agrave; 
	&eacute;voqu&eacute; pr&eacute;c&eacute;demment). Pour les Pentium, le fragment de code 
	<code class="literal">rdtsc</code> ci-dessus est pr&eacute;cis au cycle 
	d'horloge pr&egrave;s.
      </p><p>
	Si vous souhaitez que votre processus re&ccedil;oive un signal apr&egrave;s un 
	certain laps de temps, utilisez <code class="function">setitimer()</code> 
	ou <code class="function">alarm()</code>. Voyez les pages de manuel de 
	ces fonctions pour plus de d&eacute;tails.
      </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N1036D"></a>5.&nbsp;D'autres langages de programmation</h2></div></div><div></div></div><p>
      Les descriptions ci-dessus se concentrent principalement sur le 
      langage C. Cependant, ces exemples devraient &ecirc;tre directement 
      applicables au C++ et &agrave; l'objective C. En assembleur, il vous 
      suffit de faire appel &agrave; <code class="function">ioperm()</code> ou 
      <code class="function">iopl()</code>, comme en C, et d'utiliser ensuite
      directement les ports d'entr&eacute;e / sortie.
    </p><p>
      Avec d'autres langages, &agrave; moins de pouvoir ins&eacute;rer du code 
      assembleur, du code C ou utiliser les appels syst&egrave;mes, il est 
      probablement plus simple d'&eacute;crire un programme C tr&egrave;s simple 
      offrant des fonctions prenant en charge les temporisations et 
      les acc&egrave;s aux ports d'entr&eacute;es / sorties souhait&eacute;s, de le 
      compiler et de le lier avec le reste de votre application. Ou 
      vous pouvez utiliser <code class="filename">/dev/port</code> comme d&eacute;crit plus haut.
    </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N10381"></a>6.&nbsp;Quelques ports utiles</h2></div></div><div></div></div><p>
      Voici quelques informations utiles pour la programmation des ports 
      les plus utilis&eacute;s. Ces ports peuvent &ecirc;tre directement interfac&eacute;s 
      avec une &eacute;lectronique logique de type TTL (ou CMOS).
    </p><p>
      Si vous avez l'intention d'utiliser ces ports ou des ports 
      classiques en vue d'applications pour lesquels ils ont &eacute;t&eacute; con&ccedil;us 
      (par exemple pour contr&ocirc;ler une imprimante ou un modem ordinaire), 
      vous auriez int&eacute;r&ecirc;t &agrave; utiliser les pilotes d&eacute;j&agrave; existants (qui 
      sont g&eacute;n&eacute;ralement inclus dans le noyau) plut&ocirc;t que de programmer 
      directement les ports comme d&eacute;crit dans ce document. Cette section 
      s'adresse principalement aux personnes d&eacute;sireuses de connecter aux 
      ports d'entr&eacute;e / sortie standards de leur PC des &eacute;crans &agrave; 
      cristaux liquides, des moteurs pas-&agrave;-pas ou d'autres montages 
      &eacute;lectroniques faits maison.
    </p><p>
      En revanche, si votre but est de piloter un p&eacute;riph&eacute;rique grand
      public, tel qu'un scanner, disponible sur le march&eacute; depuis
      quelques temps d&eacute;j&agrave;, essayez plut&ocirc;t de savoir si un pilote a
      d&eacute;j&agrave; &eacute;t&eacute; d&eacute;velopp&eacute;. Le <a href="http://www.traduc.org/docs/HOWTO/lecture/Hardware-HOWTO.html" target="_top">Hardware-HOWTO</a> est un
      bon point de d&eacute;part pour mener cette investigation.
    </p><p>
      <a href="http://www.hut.fi/Misc/Electronics/" target="_top">http://www.hut.fi/Misc/Electronics/</a> est
      &eacute;galement une excellente source d'information sur la connexion
      de p&eacute;riph&eacute;riques &agrave; un ordinateur et sur l'&eacute;lectronique en
      g&eacute;n&eacute;rale.
    </p><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="N10393"></a>6.1.&nbsp;Le port parall&egrave;le</h3></div></div><div></div></div><p>
	L'adresse de base du port parall&egrave;le (appel&eacute;e
	<em class="replaceable"><code>BASE</code></em> ci-dessous) est 
	<code class="literal">0x3bc</code> pour <code class="filename">/dev/lp0</code>, <code class="literal">0x378</code>
	pour <code class="filename">/dev/lp1</code> et
	<code class="literal">0x278</code> pour
	<code class="filename">/dev/lp2</code>.
	Si vous souhaitez piloter un mat&eacute;riel fonctionnant comme une
	imprimante classique, voyez le <a href="http://www.traduc.org/docs/HOWTO/lecture/Printing-HOWTO.html" target="_top">Printing-HOWTO</a>.
      </p><p>
	En plus du mode standard d'&eacute;criture-seule d&eacute;crit ci-dessous, il 
	existe un mode &laquo;&nbsp;&eacute;tendu&nbsp;&raquo; bidirectionnel 
	sur la plupart des ports parall&egrave;les. Pour des informations &agrave; ce 
	sujet ainsi que sur les r&eacute;cents modes ECP / EPP (et le 
	standard IEEE 1284 en g&eacute;n&eacute;ral), voici deux adresses&nbsp;:  
	<a href="http://www.fapo.com/" target="_top">http://www.fapo.com/</a> et
	
	<a href="http://www.beyondlogic.org/" target="_top">http://www.beyondlogic.org/</a>. 
	Rappelez-vous cependant que puisque vous ne pouvez pas utiliser 
	les requ&ecirc;tes d'interruptions (IRQ) ou l'acc&egrave;s DMA dans un 
	programme en mode utilisateur, vous serez certainement oblig&eacute; 
	d'&eacute;crire un pilote pour le noyau afin d'exploiter les modes 
	ECP / EPP. Il me semble que quelqu'un est d&eacute;j&agrave; en train de 
	d&eacute;velopper un tel pilote, mais je n'en sais pas plus &agrave; ce sujet.
      </p><p>
	Le port <code class="literal"><em class="replaceable"><code>BASE</code></em>+0</code> 
	(port de donn&eacute;es) contr&ocirc;le les signaux de donn&eacute;es du port 
	(respectivement D0 &agrave; D7 pour les bits 0 &agrave; 7; &eacute;tats&nbsp;: 0 = 
	bas (0V), 1 = haut (5V)). Une &eacute;criture sur ce port positionne 
	l'&eacute;tat des broches correspondantes. La lecture retourne la 
	derni&egrave;re valeur &eacute;crite en mode standard ou &eacute;tendu, sinon les 
	donn&eacute;es pr&eacute;sentes sur les broches connect&eacute;es &agrave; un autre 
	p&eacute;riph&eacute;rique en mode de lecture &eacute;tendue.
      </p><p>
	Le port <code class="literal"><em class="replaceable"><code>BASE</code></em>+1</code>
	(port d'&eacute;tat) est en lecture seule et retourne l'&eacute;tat des
	signaux d'entr&eacute;e suivants&nbsp;:
	</p><div class="itemizedlist"><ul type="disc"><li><p>
	      Bits 0 et 1 sont r&eacute;serv&eacute;s.
	</p></li><li><p>
	      Bit 2 &eacute;tat d'IRQ (ne correspond pas &agrave; une broche, je ne sais pas comment il fonctionne)
	</p></li><li><p>
	      Bit 3 ERROR (1 = &eacute;tat haut)
	</p></li><li><p>
	      Bit 4 SLCT (1 = &eacute;tat haut)
	</p></li><li><p>
	      Bit 5 PE (1 = &eacute;tat haut)
	</p></li><li><p>
	      Bit 6 ACK (1 = &eacute;tat haut)
	</p></li><li><p>
	      Bit 7 -BUSY (0 = &eacute;tat haut)
	</p></li></ul></div><p>
	Le port <code class="literal"><em class="replaceable"><code>BASE</code></em>+2</code> (port de contr&ocirc;le) est en &eacute;criture seule (une lecture sur
	celui-ci retourne la derni&egrave;re valeur &eacute;crite) et contr&ocirc;le les signaux d'&eacute;tat
	suivants&nbsp;:
	</p><div class="itemizedlist"><ul type="disc"><li><p>
	      Bit 0 -STROBE (0 = &eacute;tat haut)
	  </p></li><li><p>
	      Bit 1 -AUTO_FD_XT (0 = &eacute;tat haut)
	  </p></li><li><p>
	      Bit 2 INIT (1 = &eacute;tat haut)
	  </p></li><li><p>
	      Bit 3 -SLCT_IN (0 = &eacute;tat haut)
	  </p></li><li><p>
	      Bit 4 active la requ&ecirc;te d'interruption (IRQ) du port 
	      parall&egrave;le (qui survient lors d'une transition 
	      bas-vers-haut de la broche ACK) lorsqu'il est positionn&eacute; &agrave; 
	      1.
	  </p></li><li><p>
	      Bit 5 contr&ocirc;le la direction du mode &eacute;tendu (0 = &eacute;criture, 1 = lecture) et est en &eacute;criture seule (une lecture sur ce bit ne retournera pas de valeur significative).
	  </p></li><li><p>
	      Bits 6 et 7 sont r&eacute;serv&eacute;s.
	  </p></li></ul></div><p>
	Brochage (d'un connecteur femelle sub-D 25 sur le port) 
	(e&nbsp;= entr&eacute;e, s&nbsp;= sortie)&nbsp;:
	</p><pre class="screen">
 1(e/s) -STROBE,   2(e/s) D0,          3(e/s) D1,          4(e/s) D2, 
 5(e/s) D3,        6(e/s) D4,          7(e/s) D5,          8(e/s) D6, 
 9(e/s) D7,       10(e) ACK,          11(e) -BUSY,        12(e) PE, 
13(e) SLCT,       14(s) -AUTO_FD_XT,  15(e) ERROR,        16(s) INIT,     
17(s) -SLCT_IN,   18-25 masse
</pre><p>
	Les sp&eacute;cifications donn&eacute;es par IBM indiquent que les broches 1, 
	14, 16 et 17 (les sorties de contr&ocirc;le) sont de type collecteur 
	ouvert ramen&eacute; &agrave; 5,0&nbsp;V au moyen d'une r&eacute;sistance de 
	4,7&nbsp;kohm (intensit&eacute; de fuite de 20&nbsp;mA, de source 
	0,55&nbsp;mA, &eacute;tat haut de sortie 5,0&nbsp;V moins tension de 
	<span class="foreignphrase"><em class="foreignphrase">pull-up</em></span>). Le reste des broches 
	ont une intensit&eacute; de fuite de 24&nbsp;mA, de source de 
	15&nbsp;mA et leur voltage &agrave; l'&eacute;tat haut est au minimum de 
	2,4&nbsp;V. L'&eacute;tat bas pour toutes les broches est au maximum de 
	0,5&nbsp;V. Les ports parall&egrave;les d'autres types que celui d'IBM 
	peuvent s'&eacute;carter de ce standard. Pour plus d'informations &agrave; ce 
	sujet, voyez l'adresse&nbsp;: <a href="http://www.hut.fi/Misc/Electronics/circuits/lptpower.html" target="_top">http://www.hut.fi/Misc/Electronics/circuits/lptpower.html</a>.
      </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td valign="top" align="center" rowspan="2" width="25"><img alt="[Avertissement]" src="images/warning.png"></td><th align="left">Avertissement</th></tr><tr><td valign="top" align="left"><p>
	Faites tr&egrave;s attention aux masses&nbsp;! J'ai d&eacute;j&agrave; grill&eacute; &agrave; 
	plusieurs reprises des ports parall&egrave;les en les connectant alors 
	que l'ordinateur &eacute;tait sous tension. Utiliser un port parall&egrave;le 
	non int&eacute;gr&eacute; &agrave; la carte m&egrave;re peut s'av&eacute;rer une bonne solution 
	pour &eacute;viter de trop grands d&eacute;sagr&eacute;ments. Vous pouvez obtenir un 
	second port parall&egrave;le pour votre machine au moyen d'une carte 
	multi-entr&eacute;es / sorties &agrave; petit prix. Il vous suffit de 
	d&eacute;sactiver les ports dont vous n'avez pas besoin, puis de 
	configurer le port parall&egrave;le de la carte sur une adresse libre. 
	Vous n'avez pas besoin de vous pr&eacute;occuper de l'IRQ du port 
	parall&egrave;le si vous n'y faites pas appel.
      </p></td></tr></table></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="N10418"></a>6.2.&nbsp;Le port de manette de jeu</h3></div></div><div></div></div><p>
	Le port de manette de jeu est accessible aux adresses 
	<code class="literal">0x200</code>-<code class="literal">0x207</code>. Si vous 
	souhaitez contr&ocirc;ler une manette de jeu ordinaire, vous serez 
	probablement mieux servi en utilisant les pilotes distribu&eacute;s 
	avec le noyau.
      </p><p>
	Brochage (pour un connecteur sub-D 15 femelle)&nbsp;:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
	      1,8,9,15&nbsp;: +5&nbsp;V (Alimentation)
	    </p></li><li><p>
	      4,5,12&nbsp;: masse
	    </p></li><li><p>
	      2,7,10,14&nbsp;: entr&eacute;es num&eacute;riques, respectivement BA1, 
	      BA2, BB1 et BB2
	    </p></li><li><p>
	      3,6,11,13&nbsp;: entr&eacute;es 
	      &laquo;&nbsp;analogiques&nbsp;&raquo;, respectivement AX, 
	      AY, BX et BY
	    </p></li></ul></div><p>
	Les broches fournissant une tension de +5&nbsp;V semblent 
	souvent &ecirc;tre connect&eacute;es directement sur l'alimentation de la 
	carte m&egrave;re, ce qui peut leur permettre d'obtenir pas mal de 
	puissance, en fonction de la carte m&egrave;re, du bloc d'alimentation 
	et du port de manette de jeu.
      </p><p>
	Les entr&eacute;es num&eacute;riques sont utilis&eacute;es pour les boutons des deux 
	manettes de jeu (manette A et manette B, avec deux boutons 
	chacune) que vous pouvez connecter au port. Ces entr&eacute;es 
	devraient &ecirc;tre de niveau TTL classique, ainsi vous pouvez lire 
	directement leurs valeurs sur le port d'&eacute;tat (voir plus bas). 
	Une v&eacute;ritable manette de jeu retourne un &eacute;tat bas (0&nbsp;V) 
	lorsque le bouton est press&eacute; et un &eacute;tat haut dans l'autre cas 
	(une tension de 5&nbsp;V des broches de d'alimentation au 
	travers d'une r&eacute;sistance de 1&nbsp;kohm).
      </p><p>
	Les pseudo entr&eacute;es analogiques mesurent en r&eacute;alit&eacute; la 
	r&eacute;sistance. Le port de manette de jeu comporte un quadruple 
	monostable (une puce de type NE558) connect&eacute; aux quatre 
	entr&eacute;es. Pour chaque entr&eacute;e, il y a une r&eacute;sistance de 
	2,2&nbsp;kohm entre la broche d'entr&eacute;e et la sortie du 
	monostable, et un condensateur de 0,01&nbsp;&micro;F entre la 
	sortie du monostable et la masse. Une v&eacute;ritable de manette de 
	jeu a un potentiom&egrave;tre pour chaque axe (X et Y), connect&eacute; entre 
	le +5&nbsp;V et la broche d'entr&eacute;e appropri&eacute;e (AX ou AY pour la 
	manette A, ou BX ou BY pour la manette B).
      </p><p>
	Lorsqu'il est activ&eacute;, le monostable initialise ses 
	lignes de sortie &agrave; un &eacute;tat haut (5&nbsp;V) et attend que chaque 
	condensateur de temporisation atteigne une tension de 3,3&nbsp;V 
	avant de mettre la sortie correspondante &agrave; un &eacute;tat bas. La dur&eacute;e 
	de l'&eacute;tat haut de la sortie du temporisateur est proportionnelle 
	&agrave; la r&eacute;sistance du potentiom&egrave;tre de la manette de jeu (en clair, 
	la position du manche de la manette de jeu de l'axe appropri&eacute;) 
	comme expliqu&eacute; ci-dessous&nbsp;:
      </p><div class="blockquote"><blockquote class="blockquote"><p>
      R = (t - 24.2) / 0.011
      </p></blockquote></div><p>
        o&ugrave; <code class="literal">R</code> est la r&eacute;sistance en ohm, du 
        potentiom&egrave;tre et <code class="literal">t</code> la dur&eacute;e de l'&eacute;tat haut de 
        la sortie, en microsecondes.
      </p><p>
	Pour effectuer une lecture sur les entr&eacute;es analogiques, vous 
	devez tout d'abord activer le monostable (au moyen d'une 
	&eacute;criture sur le port, voir plus bas), puis scruter l'&eacute;tat des 
	quatre axes au moyen de lectures r&eacute;p&eacute;t&eacute;es jusqu'&agrave; la transition 
	&agrave; un &eacute;tat bas, permettant ainsi de mesurer la dur&eacute;e de l'&eacute;tat 
	haut. Cette scrutation est tr&egrave;s gourmande en temps machine. De 
	plus, sur un syst&egrave;me multit&acirc;che non temps-r&eacute;el tel que Linux (en 
	mode utilisateur normal) le r&eacute;sultat n'est pas tr&egrave;s pr&eacute;cis, du 
	fait de l'impossibilit&eacute; de scruter le port constamment (&agrave; moins 
	d'utiliser un pilote noyau et de d&eacute;sactiver la gestion des 
	interruptions pendant la scrutation, mais sachez que vous 
	consommerez encore plus de temps machine). Si vous savez &agrave; 
	l'avance que le signal va mettre un certain temps (plusieurs 
	dizaines de millisecondes) avant de basculer, vous pouvez faire 
	appel &agrave; <code class="function">usleep()</code> avant de proc&eacute;der &agrave; la 
	scrutation afin de laisser un peu de temps machine aux autres 
	processus.
      </p><p>
	Le seul port d'entr&eacute;es / sorties auquel vous avez besoin 
	d'acc&eacute;der est le port <code class="literal">0x201</code> (les autres ports 
	se comportent de fa&ccedil;on identique ou ne r&eacute;agissent pas). Toute 
	&eacute;criture sur ce port, peu importe la valeur envoy&eacute;e, active le 
	temporisateur. Une lecture retourne l'&eacute;tat des signaux 
	d'entr&eacute;e&nbsp;:
      </p><div class="itemizedlist"><ul type="disc"><li><p>
	      Bit 0&nbsp;: AX (&eacute;tat de la sortie du temporisateur, 
	      1&nbsp;= &eacute;tat haut)
	  </p></li><li><p>
	      Bit 1&nbsp;: AY (&eacute;tat de la sortie du temporisateur,
	      1&nbsp;= &eacute;tat haut)
	  </p></li><li><p>
	      Bit 2&nbsp;: BX (&eacute;tat de la sortie du temporisateur,
	      1&nbsp;= &eacute;tat haut)
	  </p></li><li><p>
	      Bit 3&nbsp;: BY (&eacute;tat de la sortie du temporisateur,
	      1&nbsp;= &eacute;tat haut)
	  </p></li><li><p>
	      Bit 4&nbsp;: BA1 (entr&eacute;e num&eacute;rique, 1 = &eacute;tat haut)
	  </p></li><li><p>
	      Bit 5&nbsp;: BA2 (entr&eacute;e num&eacute;rique, 1 = &eacute;tat haut)
	  </p></li><li><p>
	      Bit 6&nbsp;: BB1 (entr&eacute;e num&eacute;rique, 1 = &eacute;tat haut)
	  </p></li><li><p>
	      Bit 7&nbsp;: BB2 (entr&eacute;e num&eacute;rique, 1 = &eacute;tat haut)
	  </p></li></ul></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="N10471"></a>6.3.&nbsp;Le port s&eacute;rie</h3></div></div><div></div></div><p>
	Si le p&eacute;riph&eacute;rique avec lequel vous communiquez est &agrave; peu pr&egrave;s 
	compatible avec le standard RS-232, vous devriez &ecirc;tre en mesure 
	d'utiliser pour cela le port s&eacute;rie. Le pilote s&eacute;rie du noyau 
	Linux devrait suffire pour la plupart des applications (vous ne 
	devriez pas avoir &agrave; programmer le port directement, de plus vous 
	devriez probablement &eacute;crire un pilote pour le noyau si vous 
	souhaitiez le faire), il est en effet tr&egrave;s polyvalent et l'usage 
	de d&eacute;bits non-standards ne devrait pas poser de probl&egrave;mes 
	particuliers.
      </p><p>
	Voyez la page de manuel de
	<span class="citerefentry"><span class="refentrytitle">termios</span>(3)</span>, le code source du pilote 
	(<code class="filename">linux/drivers/char/serial.c</code>) ainsi que la 
	page <a href="http://www.easysw.com/~mike/serial/" target="_top">http://www.easysw.com/~mike/serial/</a> 
	pour plus d'informations sur la programmation des ports s&eacute;ries 
	des syst&egrave;mes Unix.
      </p></div></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N10485"></a>7.&nbsp;Conseils</h2></div></div><div></div></div><p>
      Si vous souhaitez obtenir une bonne acquisition analogique, vous 
      pouvez connecter un CAN ou un CNA au port parall&egrave;le 
      (conseil&nbsp;: pour l'alimentation, utilisez soit le port de 
      manette de jeu, soit un connecteur d'alimentation de disque 
      que vous relierez &agrave; l'ext&eacute;rieur de votre bo&icirc;tier, &agrave; moins que vous 
      n'utilisiez un p&eacute;riph&eacute;rique peu consommateur d'&eacute;nergie, et que 
      vous puissiez utiliser le port parall&egrave;le lui-m&ecirc;me pour 
      l'alimenter, sinon utilisez tout simplement une source 
      d'alimentation externe). Vous pouvez &eacute;galement investir dans 
      l'achat d'une carte d'acquisition num&eacute;rique / analogique 
      ou analogique / num&eacute;rique (la plupart des cartes 
      d'acquisition les plus anciennes et les plus lentes s'appuient sur 
      l'usage de ports de communication externes). Sinon, si vous pouvez 
      vous satisfaire de seulement un ou deux canaux d'acquisition, de 
      r&eacute;sultats peu pr&eacute;cis et sans doute d'un mauvais niveau du z&eacute;ro, 
      l'utilisation d'une carte son bas de gamme support&eacute;e par le noyau 
      Linux devrait r&eacute;pondre &agrave; votre attente (et vous permettre de faire 
      des acquisitions rapides).
    </p><p>
      Avec des p&eacute;riph&eacute;riques analogiques de pr&eacute;cision, une mauvaise mise 
      &agrave; la masse peut g&eacute;n&eacute;rer de mauvaises mesures lors de lectures ou 
      d'&eacute;critures analogiques. Si vous rencontrez ce type de 
      d&eacute;sagr&eacute;ment, vous pouvez isoler &eacute;lectriquement le p&eacute;riph&eacute;rique 
      de votre ordinateur au moyen d'optocoupleurs (sur 
      <span class="emphasis"><em>toutes</em></span> les lignes entre le p&eacute;riph&eacute;rique et 
      l'ordinateur). Vous pouvez essayer de tirer l'alimentation 
      &eacute;lectrique des optocoupleurs de votre ordinateur (les signaux 
      de broches non utilis&eacute;es du port peuvent peut-&ecirc;tre vous fournir 
      une puissance suffisante) afin d'obtenir une meilleure isolation.
    </p><p>
      Si vous &ecirc;tes &agrave; la recherche d'un logiciel de conception de circuits
      imprim&eacute;s sous Linux, sachez qu'il existe une application libre pour
      X11 appel&eacute;e <span class="productname">Pcb</span>&trade; qui devrait vous rendre 
      de grands services, tout du moins si vous n'avez pas de projets 
      trop compliqu&eacute;s. Ce logiciel est inclus dans la plupart des 
      distributions Linux et est disponible &agrave; l'adresse suivante&nbsp;: 
      <a href="ftp://sunsite.unc.edu/pub/Linux/apps/circuits/" target="_top">ftp://sunsite.unc.edu/pub/Linux/apps/circuits/</a>
      (nom de l'archive <code class="filename">pcb-*</code>).
    </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N1049C"></a>8.&nbsp;Probl&egrave;mes et solutions</h2></div></div><div></div></div><p>
      <div class="variablelist"><dl><dt><span class="term">Q1.</span></dt><dd><p>
	      J'obtiens une erreur de segmentation lorsque j'essaye 
	      d'acc&eacute;der aux ports.
	    </p></dd><dt><span class="term">R1.</span></dt><dd><p>
	      Soit votre programme n'a pas les privil&egrave;ges de super 
	      utilisateur, soit l'appel &agrave; <code class="function">ioperm()</code> 
	      n'a pas r&eacute;ussi pour une raison ou une autre. V&eacute;rifiez la
	      valeur de retour de <code class="function">ioperm()</code>. 
	      V&eacute;rifiez &eacute;galement que vous acc&eacute;dez bien aux ports que 
	      vous avez activ&eacute;s pr&eacute;alablement avec 
	      <code class="function">ioperm()</code> (voir Q3). Si vous faites 
	      appel aux macros de temporisation 
	      (<code class="function">inb_p()</code>, 
	      <code class="function">outb_p()</code>, et c&aelig;tera), pensez 
	      aussi &agrave; utiliser <code class="function">ioperm()</code> pour 
	      obtenir l'acc&egrave;s au port <code class="literal">0x80</code>.
	    </p></dd><dt><span class="term">Q2.</span></dt><dd><p>
	      Je n'arrive &agrave; trouver nulle part la d&eacute;finition de 
	      <code class="function">in*()</code>, <code class="function">out*()</code>, 
	      de plus gcc se plaint de r&eacute;f&eacute;rences non-d&eacute;finies.
	    </p></dd><dt><span class="term">R2.</span></dt><dd><p>
	      Vous n'avez pas lanc&eacute; la compilation avec les drapeaux 
	      d'optimisation (<code class="literal">-O</code>), en 
	      cons&eacute;quence gcc n'a pas pu trouver les macros d&eacute;finies 
	      dans <code class="filename">asm/io.h</code>. 
	      Ou alors, vous n'avez pas inclus du tout la ligne 
	      <code class="literal">#include &lt;asm/io.h&gt;</code> dans 
	      votre code.
	    </p></dd><dt><span class="term">Q3.</span></dt><dd><p>
	      <code class="function">out*()</code> ne fait rien ou ne retourne 
	      que des valeurs bizarres.
	    </p></dd><dt><span class="term">R3.</span></dt><dd><p>
	      V&eacute;rifiez l'ordre des param&egrave;tres, ceux-ci devraient &ecirc;tre 
	      comme ce qui suit&nbsp;: 
	      <code class="function">outb(<em class="replaceable"><code>valeur</code></em>, , 
	      <em class="replaceable"><code>port</code></em>)</code> et non pas 
	      <code class="function">outportb(<em class="replaceable"><code>port</code></em>, , 
	      <em class="replaceable"><code>valeur</code></em>)</code> comme en 
	      MS-DOS.
	    </p></dd><dt><span class="term">Q4.</span></dt><dd><p>
	      Je souhaite contr&ocirc;ler un p&eacute;riph&eacute;rique standard, tel 
	      qu'un p&eacute;riph&eacute;rique RS-232, une imprimante parall&egrave;le, une 
	      manette de jeu,&nbsp;&hellip;
	    </p></dd><dt><span class="term">R4.</span></dt><dd><p>
	      Vous auriez plut&ocirc;t int&eacute;r&ecirc;t &agrave; utiliser les pilotes d&eacute;j&agrave; 
	      existants (dans le noyau Linux ou un serveur X ou 
	      ailleurs) pour ce faire. Ces pilotes sont g&eacute;n&eacute;ralement 
	      assez polyvalents. Ainsi ils arrivent m&ecirc;me en g&eacute;n&eacute;ral &agrave; 
	      faire fonctionner les p&eacute;riph&eacute;riques sortant l&eacute;g&egrave;rement des 
	      standards. Voyez la note d'information ci-dessus sur les 
	      ports standards pour de la documentation &agrave; leur sujet.
	    </p></dd></dl></div>
    </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N1051C"></a>9.&nbsp;Code d'exemple</h2></div></div><div></div></div><p>
      Voici un exemple de programme simple permettant l'acc&egrave;s aux ports 
      d'entr&eacute;es / sorties&nbsp;:
    </p><pre class="programlisting">
/*
* exemple.c&nbsp;: un exemple tr&egrave;s simple d'acc&egrave;s aux ports d'E/S
*
* Ce programme ne fait rien d'utile, juste une &eacute;criture sur le port,
* une pause, puis une lecture sur le m&ecirc;me port.
* &Agrave; compiler avec &laquo; gcc -O2 -o exemple exemple.c &raquo;et &agrave; 
* ex&eacute;cuter en tant que root avec &laquo; ./exemple &raquo;.
*/

#include &lt;stdio.h&gt;
#include &lt;unistd.h&gt;
#include &lt;asm/io.h&gt;

#define BASEPORT 0x378 /* lp1 */

int main()
{
/* Obtention de l'acc&egrave;s aux ports */
if (ioperm(BASEPORT, 3, 1)) {perror("ioperm"); exit(1);}

/* Initialisation de tous les signaux de donn&eacute;es (D0-D7) &agrave; l'&eacute;tat bas (0) */
outb(0, BASEPORT);

/* Dormons pendant un moment (100 ms) */
usleep(100000);

/* Lecture sur le port d'&eacute;tat (BASE+1) et affichage du r&eacute;sultat */
printf("status&nbsp;: %d\n", inb(BASEPORT + 1));

/* Nous n'avons plus besoin de l'acc&egrave;s aux ports */
if (ioperm(BASEPORT, 3, 0)) {perror("ioperm"); exit(1);}

exit(0);
}

/* fin d'exemple.c */
</pre></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N10524"></a>10.&nbsp;Remerciements</h2></div></div><div></div></div><p>
      Beaucoup trop de personnes ont contribu&eacute; &agrave; l'&eacute;criture de ce 
      document pour que je puisse en faire la liste ici, mais merci &agrave; 
      tous. Je n'ai pas pu r&eacute;pondre &agrave; toutes les contributions re&ccedil;ues, 
      je m'en excuse, mais encore merci pour votre aide.
    </p></div><div class="sect1" lang="fr"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="adaptation-francaise"></a>11.&nbsp;Adaptation fran&ccedil;aise</h2></div></div><div></div></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="N1052E"></a>11.1.&nbsp;Traduction</h3></div></div><div></div></div><p>
        
        La traduction fran&ccedil;aise de ce document a &eacute;t&eacute; r&eacute;alis&eacute;e par
        Jean-Fran&ccedil;ois Pr&eacute;vost

        <code class="email">&lt;<a href="mailto:prevost CHEZ 2cse TIRET group POINT com">prevost CHEZ 2cse TIRET group POINT com</a>&gt;</code>.
          
   </p></div><div class="sect2" lang="fr"><div class="titlepage"><div><div><h3 class="title"><a name="N10536"></a>11.2.&nbsp;Relecture</h3></div></div><div></div></div><p>
    
        La relecture de ce document a &eacute;t&eacute; r&eacute;alis&eacute;e par Guillaume Lelarge 
        
        <code class="email">&lt;<a href="mailto:gleu CHEZ wanadoo POINT fr">gleu CHEZ wanadoo POINT fr</a>&gt;</code>
        
        et Jean-Philippe Gu&eacute;rard 
        
        <code class="email">&lt;<a href="mailto:fevrier CHEZ tigreraye POINT org">fevrier CHEZ tigreraye POINT org</a>&gt;</code>.
        
    </p></div></div></div></body></html>