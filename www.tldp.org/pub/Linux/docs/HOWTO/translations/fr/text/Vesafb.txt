
                               Vesafb mini-HOWTO

Alex Buell, alex.buell@tahallah.demon.co.uk

   v0.5, 2 August 1998
     _________________________________________________________________

   _Ce document décrit l'utilisation du gestionnaire vesafb sous Linux
   pour un pc comprenant une carte graphique conforme aux spécifications
   VESA 2.0._
     _________________________________________________________________

1. Remerciements

   Merci aux personnes dont les noms suivent pour avoir aidé à
   l'amélioration du HOWTO vesafb.

     * Jeff Noxon jeff@planetfall.com
     * Francis Devereux f.devereux@cs.ucl.ac.uk
     * Andreas Ehliar ehliar@futurniture.se
     * Martin McCarthy marty@ehabitat.demon.co.uk
     * Simon Kenyon simon@koala.ie
     * David Ford david@kalifornia.com
     * Chris Black cblack@cmpteam4.unil.ch
     * N Becker nbecker@fred.net
     * Bob Tracy rct@gherkin.sa.wlk.com
     * Marius Hjelle marius.hjelle@roman.uib.no
     * Aaron Tiensivu tiensivu@pilot.msu.edu

   et bien sûr l'auteur du pilote:

     * Gerd Knorr kraxel@cs.tu-berlin.de
     * Geert Uytterhoeven Geert.Uytterhoeven@cs.kuleuven.ac.be
     * Martin Mares mj@ucw.cz
     * S'il y en a d'autres, qu'ils lèvent la main. :o)

2. Vesafb, quès acco ?

   Vesafb est un gestionnaire de mémoire vidéo sur compatible PC dédié
   aux cartes cartes graphiques conformes aux spécifications VESA 2.0.
   Son fonctionnement est lié de près aux gestionnaires de mémoire vidéo
   génériques du noyau.

   Vesafb permet le recours aux modes graphiques sur PC pour
   l'utilisation des consoles textes en point par point. Vesafb autorise
   également l'affichage d'un logo et c'est vraisemblablement ce pour
   quoi vous voulez vous en servir :o)

   On ne peut malheureusement pas utiliser vesafb avec des cartes VESA
   1.2. En effet, ces cartes n'utilisent pas l'adressage linéaire.
   Quelqu'un écrira peut-ètre un gestionnaire de périphériques vesafb12
   pour ce type de cartes, mais cela consommera de la mémoire par
   ailleurs précieuse pour le noyau. :o(

   Il existe cependant un moyen détourné d'accéder aux fonctionnalités
   VESA 2.0 sur une carte VESA 1.2. Peut-ètre pouvez vous charger depuis
   le DOS un programme de type TSR qui, utilisé conjointement avec
   loadlin, aidera à configurer la carte pour les modes graphiques
   voulus. Cela ne marchera pas toujours. Ainsi, certaines cartes de chez
   Cirrus Logic, telles les VLB 54xx, se retrouvent à une position en
   mémoire ( par exemple entre 15 et 16 Mo ) qui en interdit
   l'utilisation sur les systèmes munis de plus de 32 Mo de mémoire. Ce
   n'est pas rédhibitoire si l'on dispose d'un BIOS permettant de ne pas
   affecter de mémoire entre 15 et 16 Mo ( "Memory Hole" ) mais il m'a
   semblé comprendre que Linux n'aime pas ça. Si l'expérience vous tente,
   vous pouvez essayer UNIVBE ( disponible sur l'Internet ).

3. Qu'est-ce qu'un gestionnaire de mémoire graphique ?

   Ce gestionnaire fournit une abstraction du matériel graphique. Il
   reproduit le tampon mémoire de certains composants vidéo et offre aux
   applications l'accés au matériel via une interface bien définie.
   Ainsi, les logiciels n'ont plus à se préoccuper des détails de
   bas-niveau [ Traduit approximativement de
   /usr/src/linux/Documentation/fb/framebuffer.txt ]

4. Comment fais-je fonctionner le gestionnaire vesafb ?

   [NB : les informations qui suivent sont basées sur mon expérience
   concernant le noyau Linux 2.1.112 sur un P75+ muni d'une carte ATI
   VideoExpress avec 2Mo de mémoire vidéo. N'hésitez pas à me faire part
   de vos expériences particulières. ]

   A supposer que vous utilisiez menuconfig, vous devrez passer par les
   étapes suivantes :

   Dans le menu "Code maturity level options" :
     * Prompt for development and/or incomplete code/drivers

   [ceci peut changer dans les futurs noyaux. Ce HOWTO sera alors
   modifié]

   Dans le menu "Console drivers" :

     * VGA Text Console
     * Video Selection Support
     * Support for frame buffer devices (experimental)
     * VESA VGA Graphic console
     * Advanced Low Level Drivers
     * Choisissez les gestionnaires Mono, 2bpp, 4bpp, 8bpp, 16bpp, 24bpp
       et 32bpp .
     * VGA character/attributes support

   Le support des composants VGA (en mode texte) - vgafb - appartenait à
   la liste ci-dessus mais il en a été supprimé en raison de son
   obsolescence. Il disparaitra sous peu. Sélectionnez plutôt "VGA Text
   Console".

   Vérifiez bien que le support "Mac variable bpp packed pixel" n'est pas
   activé. [ En 2.2.111, il semblerait qu'il le soit si "Advanced Low
   Level Drivers" l'est ].

   Assurez vous que rien n'est modularisé. [J'ai des doutes quand aux
   possibilités de modularisation de l'ensemble - les précisions seront
   les bienvenues]

   Recompilez le noyau, modifiez l'/etc/lilo.conf de façon à ajouter le
   paramètre VGA=ASK, lancez lilo. Ceci vous permettra de choisir le mode
   graphique que vous voulez.

   Redémarrez le noyau et essayez comme test d'entrer 0301 au prompt VGA.
   Vous devriez vous retrouver en 640x480 sur 256 couleurs avec un
   délicieux petit logo de pingouin.

   Maintenant que ça fonctionne, il vous reste à essayer les différents
   modes VESA ( cf ci-dessous ), à choisir celui que vous préférez et à
   le figer via le paramètre "VGA=toto" du lilo.conf. Pour cela, après
   avoir fait votre choix, cherchez sa représentation décimale dans les
   tables qui suivent et utilisez ce nombre. Par exemple, pour du 1280
   par 1024 en 256 couleurs, vous utiliserez "VGA=775". N'oubliez pas de
   relancer lilo. C'est tout. Pour davantage d'informations sur le sujet,
   reportez vous aux HOWTO sur LILO et Loadlin.

5. De quels modes VESA puis-je me servir ?

   Cela dépend de votre carte graphique, en particulier de la quantité de
   mémoire dont elle dispose. A vous de voir quels sont les modes qui
   fonctionnent le mieux.

   La table suivante fournit les numéros des modes que vous pouvez passer
   à l'invite VGA ( en fait les indices se sont vus ajouter 0x200 afin de
   s'y retrouver plus facilement dans la table ).

Couleurs | 640x480 800x600 1024x768 1280x1024 1600x1200
---------+---------------------------------------------
256      |  0301    0303     0305     0307      031C
32,768   |  0310    0313     0316     0319      031D
65,536   |  0311    0314     0317     031A      031E
16.8M    |  0312    0315     0318     031B      031F

   La même chose en décimal :

Couleurs | 640x480 800x600 1024x768 1280x1024 1600x1200
---------+---------------------------------------------
256      |   769     771      773      775       796
32,768   |   784     787      790      793       797
65,536   |   785     788      791      794       798
16.8M    |   786     789      792      795       799

   [L'auteur apprécierait fortement de recevoir les codes 03xx pour les
   modes manquants, i.e. 1152x900]

6. Existe-t-il un serveur X11 adapté à vesafb ?

   Oui. Si pour une raison ou une autre votre serveur habituel digère mal
   vesafb, vous devrez utiliser la version XF86_FBdev. Téléchargez
   X332servonly.tgz depuis http://wwwxfree86.org ou un de ses mirroirs,
   décompressez le, effectuez les modifications nécessaires dans le
   fichier xc/config/cf/xf86site.def et décommentez le #define relatif à
   XF68FBDevServer. Ne prétez pas attention à ce qui se rapporte à m68k.
   L'architecture PC est supportée. Compilez le tout, il y en a pour un
   moment. Ooommmm...

   Il n'y a pas encore actuellement de binaire XF86_FBdev disponible tel
   quel mais Debian y travaille et les versions libc5/glibc devraient
   sortir.

   Certains ont signalé que X11 n'est pas exploitable sur certaines
   cartes lorsque le gestionnaire vesafb est activé. Si vous vous
   retrouvez dans ce cas, essayez le dernier serveur XF86_FBdev pour X11.

   Ce gestionnaire, utilisé avec vesafb, peut permettre de faire
   fonctionner X11 avec certains chipsets à des résolutions qui ne
   seraient pas autrement supportées par quelque serveur X que ce soit (
   ex. MGA G-200 ).

   Esperons que les problèmes de support des cartes graphiques avec X11
   seront résolus par les versions à venir.

7. Vesafb peut-il être modularisé ?

   En ce qui concerne le 2.1.112, vesafb ne peut être compilé en tant que
   module. D'ailleurs, après modularisation, on ne verrait rien à l'écran
   jusqu'à ce que l'on effectue un modprobe sur vesafb. Il est donc
   surement plus sage pour l'instant de le laisser dans le noyau, des
   fois que le boot ne se déroule pas correctement.

8. Divers

   Les infos données ici sont valables pour la version 2.1.112 du noyau.
   Ce HOWTO sera mis à jour selon l'avancement du développement du noyau.
   N'hésitez pas à transmettre à l'auteur vos commentaires et
   approfondissements.

   A noter : le défilement en arrière ne fonctionne pas encore.
