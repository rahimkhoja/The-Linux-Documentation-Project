
                    Mini-HOWTO Linux de XFree vers XInside

par Marco Melgazzi, marco@techie.com
Traducteur: Sébastien Blondeel ( sebastien.blondeel@lifl.fr)

   version 1.3 / septembre 1997
     _________________________________________________________________

   _Comment convertir une ligne de mode vidéo XFree86 en ligne de mode
   vidéo XInside/XiGraphics_
     _________________________________________________________________

1. Introduction

   Au printemps 1996, j'ai lu dans comp.os.linux.x (groupe de discussion
   consacré à la partie graphique du système d'exploitation Linux)
   beaucoup d'articles demandant comment convertir les modes vidéo entre
   XFree86 et une de ses alternatives commerciales: XInside (désormais
   appelé XiGraphics, mais vous remarquerez que dans ce document
   j'utiliserai l'ancien nom de produit, puisque je me réfère
   principalement à cette version-là).

   J'avais déjà évalué le produit auparavant et j'avais encore sur mon
   disque dur cette version d'évaluation: comme j'aime résoudre des
   problèmes, j'ai décidé de m'y mettre et, après quelques heures de
   tâtonnements et de calculs, j'ai rédigé un article censé être
   intéressant, qui fut rapidement posté.

   Les discussions parlant de la conversion prirent subitement fin et
   j'ai reçu 1 (un) courrier électronique me remerciant pour l'article de
   telle sorte que, puisque quelqu'un d'autre risque de se poser ces
   questions à l'avenir, j'ai décidé de transformer cet article en ce
   mini HOWTO.

   Mettons tout de suite les choses au clair: je ne travaille PAS pour
   XInside et je n'ai eu accès qu'à leur version d'évaluation 1.2 pour
   Linux. Je sais que maintenant (en mai 1997) AccelX a atteint le numéro
   de version 3.1, mais je pense que l'information contenue dans ce
   document est toujours utilisable, au prix peut-être de quelques
   modifications mineures.

   Puisque ce HOWTO a été mis au point à l'aide d'une version de XInside
   assez vieille, il se peut que certaines données présentées ici ne
   soient pas tout à fait exactes. Comme vous le lirez plus loin, grâce à
   l'avènement de XFree 3.2, je n'ai pas acheté ce serveur commercial.
   Aussi, si vous l'avez acheté, et que vous remarquez des erreurs,
   veuillez prendre le temps de me les communiquer par courrier
   électronique.

   Attention, bidouiller les réglages d'un moniteur est assez dangereux
   et, pour cette raison, je ne garantis rien du tout. Si cela fonctionne
   pour votre ordinateur, tant mieux. Si vous le faites exploser, ne m'en
   tenez pas pour responsable.

2. En ai-je vraiment besoin?

   Je ne comprends absolument pas le choix de XInside de ne pas proposer
   d'utilitaire pour régler vos modes vidéo (comme xvidtune) et/ou pour
   importer vos modes vidéo de XFree dans la version d'évaluation (qui
   est, pour autant que je sache, commerciale). J'ai passé environ trois
   heures à mettre tout ceci au point (indice: j'ai comparé l'entrée
   concernant le VESA 1024x768 à 70Hz dans les deux formats (et je suis
   presque ingénieur en électronique ;-)) alors qu'un programmeur de chez
   XInside aurait pu écrire un article comparatif en bien moins de
   temps...

   Je n'ai pas téléchargé les versions d'évaluation à partir de la 1.3 et
   j'espère vraiment qu'ils ont réglé cela. Et si c'est le cas, on peut
   penser que ce mini HOWTO est devenu inutile mais puisque vous le
   lisez, espérons qu'il vous aidera à mieux comprendre comment tout cela
   fonctionne...

3. Allons-y

   Supposons que vous ayez votre mode XFree86 bien aimé et que vous
   vouliez évaluer XInside dans les mêmes conditions: suivez les étapes
   présentées ci-dessous et vous devriez pouvoir le faire; nous allons
   utiliser à titre d'exemple vécu mon mode vidéo par défaut et je vais
   vous expliquer ce que vous devrez faire pour le convertir.

   Une entrée de XFree86 ressemble à ceci:

Modeline "blabla" DOTCLK  A B C D  a b c d

   Chacun des nombres de A à D et de a à d a une signification précise:
   si vous le voulez, vous pouvez faire des recherches dans le "Guide du
   Rootard pour les modes vidéo sous X386/XFree86"
   (/usr/lib/X11/doc/VideoModes.doc) mais vous n'avez pas besoin de
   connaître toute la théorie sous-jacente pour réaliser une conversion
   couronnée de succès...

   Mon entrée dans /usr/lib/X11/XF86Config est:

Modeline "1168x876" 105  1168 1256 1544 1640  876 877 891 900
                     |     |    |    |    |    |   |   |   |
                  DOT_CLK  A    B    C    D    a   b   c   d

   Sous XInside, il vous faut ajouter une entrée dans le fichier
   Xtimings, qui devrait se trouver dans etc/ (à partir de maintenant,
   nous supposerons que vous vous trouvez dans le répertoire racine de
   Xaccel, qui devrait être quelque chose comme
   /usr/X11/lib/X11/AcceleratedX).

!    Quelque part dans le fichier, mettez ici le nom désiré

[MODE_PRÉAJUSTÉ]
    NomDuModePréajusté = "1168x876 @ 72Hz";

!
!    Les quatre lignes suivantes sont évidentes... pour qui parle anglais
!
    HorPixel          = 1168;         // pixels
    VerPixel          = 876;          // lignes
    PixelWidthRatio   = 4;            // taux de largeur des pixels
    PixelHeightRatio  = 3;            // taux de hauteur des pixels

!
!   hsync: DOT_CLK / D * 1000 [KHz]
!
!   hsync = 105 / 1640 * 1000 = 64.024 KHz
!
!   vsync: ( 1 / (( D / DOT_CLK ) * d) ) * 1,000,000 [Hz]
!
!   vsync: ( 1 / (( 1640 / 105 ) * 900) ) * 1,000,000
!           ( 1 / 14057.1428571 ) * 1,000,000 = 71.138 Hz
!

    HorFrequency      = 64.180;        // kHz
    VerFrequency      = 71.138;        // Hz

!   Type de balayage

    ScanType          = NONINTERLACED;

!
!   Mettez ici les options de XFree86 +/-hsync et +/-vsync
!
    HorSyncPolarity   = POSITIVE;
    VerSyncPolarity   = POSITIVE;

!   Cela ne devrait pas changer

    CharacterWidth    = 8;             // largeur des caractères, en pixels

!   ici, c'est DOT_CLK

    PixelClock        = 105.000;       // MHz
!
!
!   section des réglages horizontaux: [usec, ou microsecondes]
!
    HorTotalTime  = D / DOT_CLK                  = 15.619;
    HorAddrTime   = A / DOT_CLK                  = 11.124;
    HorBlankStart = A / DOT_CLK                  = 11.124;
    HorBlankTime  = HorTotalTime - HorBlankStart =  4.495;
    HorSyncStart  = B / DOT_CLK                  = 11.962;
    HorSyncTime   = C / DOT_CLK - HorSyncStart   =  2.743;

 !
 !  section des réglages verticaux:    [msec, ou millisecondes]
 !

    VerTotalTime  = ( HorTotalTime * d ) / 1000  = 14.057;
    VerAddrTime   = ( HorTotalTime * a ) / 1000  = 13.682;
    VerBlankStart = ( HorTotalTime * a ) / 1000  = 13.682;
    VerBlankTime  = VerTotalTime - VerBlankStart =  0.375;
    VerSyncStart  = ( HorTotalTime * b ) / 1000  = 13.698;
    VerSyncTime   = ( HorTotalTime * ( c - b ) ) / 1000
                                                 = 0.219

 ! C'est tout !

   Il vous faut maintenant positionner ce mode vidéo nouvellement créé
   dans les fichiers indiqués dans la section suivante, au bon endroit.

4. Mettre les choses au point

   Dans les extraits ci-dessous, le signe -> vous indique ce qui a été
   modifié: ne l'incluez PAS dans vos fichiers!

   Entrée du moniteur (la mienne est monitors/mfreq/mfreq64.vda)

    [MODES_ÉTABLIS]
        "640x480 @ 60Hz",
        "640x480 @ 72Hz",
        "640x480 @ 75Hz",
        "800x600 @ 56Hz",
        "800x600 @ 60Hz",
        "800x600 @ 72Hz",
        "800x600 @ 75Hz",
        "1024x768 Interlaced",
        "1024x768 @ 60Hz",
        "1024x768 @ 70Hz",
        "1024x768 @ 75Hz",
    "1152x900 Interlaced",
        "1152x900 @ 60Hz",
        "1152x900 @ 67Hz",
->      "1168x876 @ 72Hz",
        "1280x1024 Interlaced",
        "1280x1024 @ 60Hz",
    "1600x1200 Interlaced";

   Dans le fichier d'informations propre à la carte (la mienne est
   (boards/s3/764-2.xqa, je me demande pourquoi ils ont presque toutes
   les cartes Hercules sauf la mienne: Terminator 64/Dram).

    [VISUEL]
    BitsPerPixel   = 8;
    MemoryModel    = Packed;
    ColorModel     = Indexed;
    BitsRGB        = 6;
    NumberOfColors = 256;

    [RÉSOLUTIONS]
    640x480,
    800x600,
    1024x768,
->  1168x876,
    1152x900,
    1280x1024

    [BUREAUX]
    640x480,
    800x600,
    1024x768,
    1152x900,
->  1168x876,
    1280x1024,
    1600x1200

   Si la carte le permet (ce qui n'est PAS le cas pour ma carte) vous
   pouvez même mettre cette entrée dans les sections 16bpp et 32bpp (bpp:
   bit par pixel).

   Le fichier etc/Xaccel.ini ressemblera à ce qui suit:

--------------------------------------------------------------
    Board   = "s3/764-2.xqa";
    Monitor = "mfreq/mfreq64.vda";
    Depth   = 8;
->  Desktop = 1168x876;

    [RÉSOLUTIONS]
->      1168x876,
        1024x768;

   L'entrée du mode correspondant pour XInside dans etc/Xtimings:

--------------------------------------------------------------
[MODE_PRÉAJUSTÉ]
    NomDuModePréajusté = "1168x876 @ 72Hz";

    HorPixel          = 1168;          // pixels
    VerPixel          = 876;           // lignes
    PixelWidthRatio   = 4;
    PixelHeightRatio  = 3;
    HorFrequency      = 64.024;        // kHz
    VerFrequency      = 71.138;        // Hz
    ScanType          = NONINTERLACED;
    HorSyncPolarity   = POSITIVE;
    VerSyncPolarity   = POSITIVE;
    CharacterWidth    = 8;             // pixels
    PixelClock        = 105.000;       // MHz
    HorTotalTime      = 15.619;        // (usec) =  205 caractères
    HorAddrTime       = 11.124;        // (usec) =  146 caractères
    HorBlankStart     = 11.124;        // (usec) =  146 caractères
    HorBlankTime      =  4.495;        // (usec) =   59 caractères
    HorSyncStart      = 11.962;        // (usec) =  157 caractères
    HorSyncTime       =  2.743;        // (usec) =   36 caractères
    VerTotalTime      = 14.057;        // (msec) =  900 lignes
    VerAddrTime       = 13.682;        // (msec) =  876 lignes
    VerBlankStart     = 13.682;        // (msec) =  876 lignes
    VerBlankTime      =  0.375;        // (msec) =   24 lignes
    VerSyncStart      = 13.698;        // (msec) =  877 lignes
    VerSyncTime       =  0.219;        // (msec) =   14 lignes

   Vous pouvez vérifier votre conversion en lançant le programme vgaset
   sans paramètres alors que le serveur XInside tourne: cela produira une
   ligne à la XFree et, si tout s'est bien passé, cette ligne sera la
   même que celle de laquelle vous étiez parti (sauf si b et c sont
   égaux, je n'ai pas réussi à reproduire cette situation dans XInside:
   le meilleur cas qui s'est produit étant c=b+1).

5. La fin...

   C'est tout pour cette fois-ci ! J'espère que cela vous sera utile. Je
   ne pense pas acheter le serveur XiGraphics dans un futur proche pour
   une raison simple: la sortie de XFree86 3.2 a résolu tous les
   problèmes de vitesse que je rencontrais avec mon humble carte vidéo
   Trio 64 ;)

   Il semble toutefois que le serveur XiGraphics reconnaît un ensemble de
   puces et de cartes vidéo bien plus large que XFree, aussi est-il
   possible que l' "alternative commerciale" soit la seule disponible
   pour vous. Si c'est le cas, et si vous avez acheté le serveur
   XiGraphics, j'aimerais vraiment avoir de vos nouvelles afin de savoir
   si l'information présentée ici vous a été utile, si vous l'avez
   trouvée trop compliquée, ou quoi que ce soit.

6. Rendre le processus automatique

   Le petit script qui suit automatise la plupart du travail. Faites très
   attention au ScanType (type de balayage) et aux deux lignes Polarity
   (polarité): le script ne les positionne pas et, si vous avez la
   paresse de ne pas les corriger, les risques d'endommager votre
   moniteur augmentent en flèche.

   Remarquez que je ne sais pas si le drapeau "Doublescan" (balayage
   double) a une signification quelconque dans XInside: si vous tentez de
   convertir un mode de double balayage de faible résolution FAITES
   ATTENTION, vous pouvez assez facilement casser votre moniteur puisque
   le taux de rafraîchissement que vous obtenez sera doublé (en fait mon
   400x300 à 72Hz est devenu un 400x300 à 144Hz!).

#!/bin/sh
##########################################################################
# XF2XInside
#
# Ce script convertit les lignes de mode vidéo du format XF86Config au
# format XInside pour remplir les besoins du fichier etc/Xtimings.
#
# C'est une bidouille vite programmée, n'en attendez pas des vérifications
# d'erreurs fines (et ne parlons pas de l'interface utilisateur).
#
# Si vous l'appelez sans argument, il devrait vous dire quoi faire.
#
#                               (juillet 1996, hcz@tazlwurm.bb.bawue.de)
#
# Au fait: Les nouveaux modes créés comme expliqués dans ce HOWTO
# fonctionnent, mais n'apparaissent pas dans le menu de Xsetup. Quelqu'un
# sait-il pourquoi ?
#
##########################################################################
#----------------------------------------------- On y va:
# Modifiez ceci si votre fichier de lignes de modes vidéo est ailleurs:
XF=/usr/X11/lib/X11/XF86Config
if [ $# -ne 1 ] ; then
  echo "utilisation: ${0##*/} <mode>"
  echo " exemple: ${0##*/} 1024x764"
  echo -e " rôle: convertit une entrée de ligne de mode vidéo de $XF au\nformat
 XInside (stdout, ou la sortie standard)"
  exit 1
fi
egrep -i "^[\t ]*modeline.+\"$1\""  /usr/X11/lib/X11/XF86Config |
gawk '
NF < 11  { print "! mauvaise ligne:\n! " $0 "\n!"; next }
{
  print "//", $0  ":"
  name = $2
  DOT_CLK = $3;
  A = $4;
  B = $5;
  C = $6;
  D = $7;
  a = $8;
  b = $9;
  c = $10;
  d = $11;
  VerFrequency =  1000000 / ((D / DOT_CLK) * d)
  print "[MODE_PRÉAJUSTÉ]"
  printf "  NomDuModePréajusté = \"%dx%d @ %.0dHz\";\n", A, a, VerFrequency
  print "  HorPixel\t\t= " A ";"
  print "  VerPixel\t\t= " a ";"
  print "  PixelWidthRatio\t= 4;\n  PixelHeightRatio\t= 3;"
  print "  HorFrequency\t\t= " DOT_CLK / D * 1000 ";\t// kHz"
  print "  VerFrequency\t\t= " VerFrequency  ";\t// Hz"
  print "  ScanType\t\t= NONINTERLACED;\t\t// *VÉRIFIEZ*"
  print "  HorSyncPolarity\t= NEGATIVE;\t\t\t// *VÉRIFIEZ*"
  print "  VerSyncPolarity\t= NEGATIVE;\t\t\t// *VÉRIFIEZ*"
  print "  CharacterWidth\t= 8;"
  print "  PixelClock\t\t= " DOT_CLK ";"
  HorTotalTime = D / DOT_CLK
  print "  HorTotalTime\t\t= " HorTotalTime ";"
  print "  HorAddrTime \t\t= " A / DOT_CLK ";"
  print "  HorBlankStart\t\t= " A / DOT_CLK ";"
  print "  HorBlankTime\t\t= " D / DOT_CLK - A / DOT_CLK ";"
  print "  HorSyncStart\t\t= " B / DOT_CLK ";"
  print "  HorSyncTime\t\t= " C / DOT_CLK - B / DOT_CLK ";"
  VerTotalTime  = ( HorTotalTime * d ) / 1000
  print "  VerTotalTime\t\t= " VerTotalTime ";"
  print "  VerAddrTime\t\t= " ( HorTotalTime * a ) / 1000 ";"
  VerBlankStart = ( HorTotalTime * a ) / 1000
  print "  VerBlankStart\t\t= " VerBlankStart ";"
  print "  VerBlankTime\t\t= " VerTotalTime - VerBlankStart ";"
  print "  VerSyncStart\t\t= " ( HorTotalTime * b ) / 1000 ";"
  print "  VerSyncTime\t\t= " ( HorTotalTime * ( c - b ) ) / 1000
  print ""
}'

7. Merci à

     * Heike Claudia Zimmerer hcz@tazlwurm.bb.bawue.de pour m'avoir fait
       remarquer une petite contradiction et pour m'avoir envoyé un
       script qui automatise une grande partie du travail.
     * Bartosz Maruszewski B.Maruszewski@zsmeie.torun.pl pour avoir
       traduit ce mini HOWTO en polonais et pour m'avoir fait remarquer
       une petite faute de frappe.

8. Copyright/point de vue légal

   (c)opyright 1996-7 par Marco Melgazzi (marco@techie.com) - couvert par
   la GPL (licence publique de GNU). Pour obtenir une copie de cette
   licence, écrivez à la Fondation pour un Logiciel Libre, à l'adresse:
   Free Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139,
   USA.

   Les marques déposées appartiennent à leurs propriétaires. Aucune
   garantie ne couvre la justesse ou l'utilité de l'information que vous
   trouverez dans ce document.
