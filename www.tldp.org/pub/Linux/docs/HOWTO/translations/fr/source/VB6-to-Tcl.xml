<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
  "http://docbook.org/xml/4.2/docbookx.dtd">
  
<article lang="fr">
<articleinfo>

<title>

Petit guide de VB6 vers Tcl

</title>

<subtitle>

Version française du <foreignphrase> VB6 To Tcl mini-HOWTO</foreignphrase>

</subtitle>

<author>
  <firstname>Mark</firstname>
  <surname>Hubbard</surname>
  <affiliation><orgname>
      <ulink url="http://www.dcisite.com">Digital Connections Inc.</ulink>
  </orgname>
  <address><email>markh CHEZ dcisite POINT com</email></address>
 </affiliation>
</author>

<othercredit role='converter'>
  <firstname>Pradeep</firstname>
 <surname>Padala</surname>
 <contrib>
    Conversion du format HTML au format DocBook v4.1.
 </contrib>
 <email>p_padala CHEZ yahoo POINT com</email>
 </othercredit>
 
 <othercredit role="traduction">
 <firstname>Berhaut</firstname>
 <surname>Denis</surname>
 <contrib>Adaptation française</contrib>
 <email>denis POINT berhaut CHEZ free POINT fr</email>
 </othercredit>

 <revhistory>
 <revision>
   <revnumber>v1.0.fr.1.0</revnumber>
   <date>02 juin 2004</date>
   <authorinitials>db</authorinitials>
   <revremark>Première traduction française</revremark>
 </revision>
 <revision>
   <revnumber>v1.0</revnumber>
   <date>2003-04-30</date>
   <authorinitials>tab</authorinitials>
   <revremark>
       Version initiale, révisée par LDP</revremark>
 </revision>
 <revision>
 <revnumber>
0.9</revnumber>
 <date>
2003-04-08</date>
 <authorinitials>
ppadala</authorinitials>
 <revremark>
Conversion au format Docbook</revremark>
 </revision>
 <revision>
 <revnumber>
0.8</revnumber>
 <date>
2002-07-08</date>
 <authorinitials>
mark</authorinitials>
 <revremark>
Document original </revremark>
 </revision>
 </revhistory>

<abstract><para>

  Un tour de Tcl en 15 minutes pour programmeurs Visual Basic et 
  VBScript.

</para></abstract>

</articleinfo>

<sect1 id="intro">
 <title>
Introduction</title>
 <para>
<emphasis>
Programmeurs VB and VBScript :  Je sais ce que vous ressentez.</emphasis>
Vraiment. En tant que Microsoft Certified Professional en VB6, j'ai pratiqué ces langages pendant sept ans. Je les ai vraiment aimés, jusqu'à ce que je saute le pas pour Tcl et que je commence à remarquer les différences de flexibilité qui sont présentées ici. Si Tcl vous paraît complètement étranger, et que vous vous demandez comment une chose pareille peut exister, attendez d'avoir vu un morceau de code C ou un script de shell UNIX. Je pense que ce sont eux qui l'ont le plus influencé. Les scripts shell UNIX sont beaucoup plus avancés que les scripts shell MS Windows, y compris ceux de NT/2000. En fait, les scripts Unix ont une grande partie des fonctionnalités montrées ici. Tcl et les scripts shell sont tous les deux largement basés sur des substitutions de chaînes. J'ai choisi d'étudier Tcl plutôt que les scripts shell parce que le code Tcl est beaucoup plus verbeux et semblable à l'anglais (et donc maintenable) que les scripts shell, qui ont tendance à être obscurs. Certains noms d'instructions de script consistent uniquement en de la ponctuation!</para>
 <para>
Tcl tourne aussi sur les 'quatre grandes' plate-formes pour PC (Linux, *nix, Windows, Mac) comme sur d'autres. Java(tm) le promet, mais Tcl l'a fait (sinon plus). Contrairement à Java et VB, Tcl n'est soumis à aucune influence commerciale (ce qui le rend vraiment libre,pas seulement 'gratuit') ; au fil des années son développement a collé à vos besoins et vos désirs, vous les développeurs et développeurs potentiels. Aucune société n'a tiré Tcl en dehors de ce chemin pour son intérêt d'entreprise. Le contraste le plus important entre Tcl et VB est que même les différences techniques expliquées plus bas peuvent être éclipsées par Tcl</para>
</sect1>
<sect1 id="examples">
 <title>
Exemples</title><table frame="all"><title>
Différences</title>
<tgroup cols="2">
 <colspec colname="VB6"/>
 <colspec colname="Tcl8.3"/>
 <spanspec namest="VB6" nameend="Tcl8.3" spanname="span-horiz"/>
 <tbody>
 <row>
<entry align="center">
VB6 </entry>
 <entry align="center">
Tcl/Tk 8.3 </entry>
 </row>
 <row>
 <entry spanname="span-horiz">
Notes/différences </entry>
 </row>
 <row>
 <entry>
<para>
<programlisting>
dim a as integer dim b as integer a=1 : b=0 </programlisting>
 </para>
</entry>
 <entry>
<para>
<programlisting>
set a 1; set b 0
</programlisting>
 </para>
</entry>
 </row>
 <row>
 <entry spanname="span-horiz">
Séparateur d'instructions multiples sur une ligne. Tcl utilise un point virgule. On considère généralement que plusieurs instructions sur une ligne constituent du code mal formé, mais on utilise aussi le point virgule pour mettre en commentaire une partie d'une ligne, comme illustré ici. </entry>
 </row>
<row>
<entry>
<para>
<programlisting>
&#39; ceci est une ligne entière
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
# ceci est une ligne entière
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Commentaire sur une ligne entière. Ce langage n'a pas besoin non plus d'un espace après la marque de mise en commentaire. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
dim a as integer a=1 &#39;ceci est un commentaire sur la même ligne qu'une instruction.
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
set a 1 ;# ceci est un commentaire sur la même ligne qu'une instruction.
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Commentaire partagé avec une instruction sur une ligne. Remarquez le point virgule, utilisé comme si le commentaire est une autre instruction sur cette ligne. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
dim s as string s=&quot;/data/docs/vb6_to_tcl.htm&quot;
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
set s {/data/docs/vb6_to_tcl.htm}
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Assignation d'une chaîne entre accolades. Les substitutions en Tcl ne s'effectuent généralement pas dans une chaîne entre accolades. Si la chaîne contient des variables ou d'autres éléments qui devraient être substitués, ce sera différé, mais on pourra les substituer plus tard. On peut souvent le faire avec des instructions qui mettent en &oelig;uvre des structures de contrôle, comme &#39;if&#39; or &#39;while&#39;. Une fois que vous êtes familiarisés avec les principes de Tcl,faites en sorte d'avoir une compréhension approfondie de ce processus parce que c'est important pour progresser en Tcl. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
(Pas d'équivalence)
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
set s &quot;/data/docs/vb6_to_tcl.htm&quot;
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Assignation d'une chaîne entre guillemets. On peut effectuer toutes les substitutions (variables, commandes,antislash) à l'intérieur d'une chaîne entre guillemets. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
(Pas d'équivalence)
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
set s /data/docs/vb6_to_tcl.htm
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Assignation d'une chaîne hors des guillemets. On peut effectuer toutes les substitutions (variables, commandes,antislash) sur une chaîne située à l'extérieur de guillemets. L'interpréteur prend simplement la chaîne comme étant le troisième terme de l'instruction set (deuxième argument de l'instruction set). Ceci marche s'il n'y a pas d'espace ou certains autres caractères dans la chaîne. A utiliser avec précaution, en particulier si vous manipulez des données saisies par l'utilisateur. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
dim s as string s = vbCrLf &amp;&quot;Un logiciel libre n'est pas simplement&quot; &amp;vbCrLf _ &amp;&quot; et seulement&#39;gratuit&#39;&quot; &amp;vbCrLf _ &amp;&quot;mais offre aussi la liberté de créer&quot; &amp;vbCrLf _ &amp;&quot;et d'utiliser les meilleurs outils.&quot; &amp;vbCrLf
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
set s { Un logiciel libre n'est pas simplement &#39;gratuit&#39; mais offre aussi la liberté de créer et d'utiliser les meilleurs outils. }
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Assignation d'une chaîne multi-lignes. Remarquez la syntaxe plus encombrée du VB, qui le rend plus difficile à lire que le code Tcl. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
dim s as string dim t as string s = trim(t)
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
set s [string trim $t]
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Assignation d'une valeur de retour de fonction. Le troisième terme de cette instruction set est entre crochets. Cela signifie qu'il est lui-même une instruction qui doit être exécutée, le résultat occupant la place du troisième terme de l'instruction set. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
dim s as string dim t as string s = lcase(trim(t))
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
set s [string tolower [string trim $t]]
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Assignation d'une fonction de fonction. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
dim x as double dim y as double x = (y + 10) * 5
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
set x [expr {($y + 10) * 5}]
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Assignation du résultat d'une expression mathématique. L'interpréteur Tcl utilise l'instruction expr pour évaluer les expressions mathématiques ou logiques. Beaucoup d'autres instructions telles que &#39;if&#39; or &#39;while&#39; utilisent expr. Quand on y recourt explicitement, expr doit comporter un seul argument qui est une chaîne contenant l'expression (comme présenté ici). Cela peut sembler grossier dans les cas simples, quand vous voulez juste ajouter quelque chose à une variable. Dans ce cas, essayez d'utiliser l'instruction incr. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
dim s as string s = s &amp;&quot;ajout de texte rajouté&quot;
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
append s {ajout de texte}
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Ajouter une chaîne à une autre. En VB, c'est l'une des opérations les plus lentes, mais c'est particulièrement rapide en Tcl. La vitesse est très importante ici, parce qu'on effectue souvent cette opération dans des boucles ou des boucles imbriquées. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
dim s as string dim t as string dim u as string s = &quot;Je demanderai à &quot; &amp; t &amp; &quot; de m'envoyer &quot; &amp; trim(u) &amp; &quot; ainsi que le tarif&quot; </programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
set s &quot;Ije demanderai à $t de m'envoyer [string trim $u] ainsi que le tarif&quot;
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Construire une chaîne par substitution. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
print &quot;bonjour&quot;
</programlisting>
</para>
</entry>
<entry>
Displays bonjour.
</entry>
</row>
<row>
<entry spanname="span-horiz">
Afficher sur la console (en fait, VB affiche dans un formulaire ou dans la fenêtre de débogage. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
sub ma_procedure (byval a as integer, byval b as string)
 debug.print &quot;Je demanderai à &quot; &amp; b
end sub
function ma_fonction (byval a as integer, _ optional byval b as string = &quot;Mark&quot;) _ as string
 ma_fonction = &quot;Je demanderai à &quot; &amp; b
end function
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
proc ma_procedure {a b} {
 debug.print &quot;Je demanderai à &quot; b
}
proc ma_fonction {a {b Mark}} {
 return &quot;Je demanderai à $b&quot;
}
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Définition de procédure. Remarquez qu'en VB, la syntaxe est différente pour les procédures et les fonctions. En Tcl,on utilise la commande <command>
proc</command>
pour définir les deux. <command>
proc</command>
est une instruction ordinaire Tcl qui s'exécute comme n'importe quelle autre instruction. Son premier argument est une liste de paramètres Tcl pour la nouvelle procédure. Son deuxième argument est une grande chaîne qui contient le corps de la nouvelle procédure (le script Tcl en lui-même). <emphasis>
Important :</emphasis>
Tcl est sensible à la classe pour pratiquement toutes les opérations : toutes les références aux noms d'instructions et aux noms de variables, ainsi que par défaut les comparaisons de chaînes de caractères. Ainsi,un appel à <command>
Proc</command>
provoquera une erreur (P en majuscule),comme le ferait un appel à <varname>
Ma_procedure</varname>
, ou faire référence à la variable <varname>
B</varname>
dans <varname>
ma_procedure</varname>
(b était en minuscule). </entry>
</row>
<row>
<entry>
<para>
<programlisting>
dim i as integer if i &lt; 0 then i = 0 else i = i - 1
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
if {$i &lt; 0} {set i 0} {incr i -1}
# option possible if {$i &lt; 0} then {set i 0} else {incr i -1}
# une autre option if {$i &lt; 0} then { set i 0 } else { incr i -1 } </programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Exécution conditionnelle &#39;if&#39;. S'ils sont présents, l'instruction Tcl &#39;if&#39; ignore les mots-clés facultatifs &#39;then&#39; et &#39;else&#39;. Dans la mesure où les deux blocs de codes sont juste des chaînes,on peut les entourer d'accolades pour les formater correctement, comme on le voit. Afin d'éviter les erreurs de syntaxe, entourez aussi par des accolades toutes les expressions de test non triviales. De cette manière, les substitutions (comme $i dans notre exemple) ne seront prises en compte que lorsque l'instruction  &#39;if&#39; passera l'expression de test à l'analyseur d'expressions. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
dim i as integer i = 1 while i &lt; 2000 i = i * 2 wend
&#39;option possible i = 1 do while i &lt; 2000 i = i * 2 loop </programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
set i 1 while {$i &lt; 2000} { set i [expr {$i * 2}] }
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
&#39;while&#39; loop. Ceci est identique à l'instruction &#39;if&#39; dans laquelle il prend une expression de test comme premier argument, suivie par une chaîne de code. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
dim i as integer for i = 0 to 8 &#39;neuf répétitions 0-8 debug.print i next
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
for {set i 0} {$i &lt; 9} {incr i} { # neuf répétitions 0-8 puts $i }
# option possible for {set i 0} {$i &lt;= 8} {incr i} { # de nouveau, neuf répétitions 0-8 puts $i } # autre option possible for {set i 1} {$i &lt;= 9} {incr i} { # neuf répétitions 1-9 puts $i }
# encore une autre possible - moins lisible set i 1 for {} {[incr i] &lt;= 9} {} { # neuf répétitions 1-9 puts $i } </programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
&#39;for&#39; boucle avec compteur interne. En Tcl (comme dans tous les langages), ceci revient à une boucle &#39;while&#39;. Dans certains langages comme VB, &#39;for&#39; n'est pas aussi flexible que &#39;while&#39;. Ce n'est pas le cas en Tcl. On peut utiliser n'importe quoi comme code d'initialisation, comme expression de test pour for, comme code d'incrémentation. Ces éléments ne sont pas réservés à une utilisation particulière,comme vous pouvez le voir dans l'exemple final. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
dim c as new collection dim o as object c.add &quot;Mark&quot; c.add &quot;Roy&quot; c.add &quot;Brian&quot; for each o in c debug.print o next
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
set c [list Mark Roy Brian] foreach o $c { puts $o }
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Boucle à travers des éléments d'une structure de données. En Tcl, on utilise une structure de données en liste. Il n'y a pas d'équivalent direct en VB, mais ce qu'il y a de plus proche est une collection d'objets. Remarquez bien que les collections VB sont, et de loin, plus lentes que les listes Tcl dans des opérations classiques,parce qu'appeler des objets dans des méthodes est plus consommateur de temps système. Retenez aussi qu'il existe <emphasis>
des utilisations bien plus puissantes et créatives</emphasis>
de l'instruction foreach,qui ne sont pas montrées ici. Elles n'ont pas d'équivalent direct en VB. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
dim s as string select case s case &quot;John&quot; debug.print &quot;Mellencamp&quot; case &quot;Steve&quot; debug.print &quot;Tyler&quot; case else debug.print &quot;Inconnu&quot; end select
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
switch -exact $s { John {puts Mellencamp} Steve {puts Tyler} default {puts Inconnu} }
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Exécution d'un choix parmi plusieurs. Remarquez que la version Tcl est sensible à la casse. ça n'est pas souvent le cas en VB, en fonction de l'option &#39;option compare&#39; qui est active dans le module. L'option  <option>
-exact</option>
précise que la chaîne doit être exactement concordante,contrairement à une concordance partielle ou à une concordance d'expression rationnelle (qui n'est pas sensible à la casse). Notez aussi qu'il y a de nombreuses d'utilisations puissantes et créatives de l'instruction switch, qui ne sont pas montrées ici. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
on error goto capture debug.print a &#39;a n'a pas été déclaré. ... capture: debug.print err.number, err.description
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
if [catch { puts $a ;# a n' pas été initialisé } my_err] { puts &quot;message d'erreur: $my_err&quot; puts &quot;stack trace: $errorInfo&quot; # ces erreurs auraient été montrées # de toute façon par la l'interception d'erreur par défaut. } else { puts {Tout est correct.} # l'autre bloc est facultatif. }
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Interception d'erreur. En VB, l'interception d'erreurs de façon concise peut poser des problèmes, en particulier si des actions différentes, dépendant du code impliqué, doivent être menées. L'instruction Tcl <command>
catch</command>
résout clairement ces problèmes. De plus,Tcl fournit automatiquement une trace de la pile de code en erreur. en VB, la trace de la pile doit être explicitement construite dans le code,si l'on désire en avoir une dans l'application de production (pas dans l'IDE). C'est un avantage pour Tcl quand on débogue sur le terrain. Retenez que <command>
catch</command>
retourne un booléen 1 ou 0, que l'on utilise classiquement avec &#39;if&#39;, comme présenté ici. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
(Pas d'équivalence)
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
set i [expr $e]
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Passe une expression mathématique arbitraire à l'interpréteur pour qu'il l'évalue. Ce peut être une expression saisie par un utilisateur, ou générée antérieurement par du code. C'est l'un des aspects les plus puissants de Tcl. En VB,on ne peut pas du tout en disposer. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
(Pas d'équivalence)
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
set s [eval $c]
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Passe un code arbitraire à l'interpréteur pour qu'il l'exécute. Ce peut être un script saisi par un utilisateur, ou généré antérieurement par du code. C'est l'un des aspects les plus puissants de Tcl. En VB,on ne peut pas du tout en disposer. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
(Pas d'équivalence)
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
source my_script.tcl
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Passe un nom de fichier arbitraire à l'interpréteur pour qu'il exécute ce fichier comme un script. C'est l'un des aspects les plus puissants de Tcl. En VB,on ne peut pas du tout en disposer. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
(Pas d'équivalence)
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
set var_name marks_age incr $var_name
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Exécute des opérations sur une variable choisie arbitrairement. Le code montré ici va modifier la variable <varname>
age_de_marc</varname>
. Son nom (la chaîne &quot;age_de_marc&quot;) est stocké dans la variable <varname>
nom_de_variable</varname>
. En fait, juste avant son exécution, chaque élément de chaque instruction est soumis à une tentative de substitution par l'interpréteur. Ainsi,n'importe quelle partie d'une instruction (et même le nom de l'instruction elle-même) peut être modifiée en fonction des données ou d'un autre critère. C'est l'un des aspects les plus puissants de Tcl. En VB,on ne peut pas du tout en disposer. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
dim s as string dim li as string dim f_num as integer s = &quot;&quot; f_num = fichierlibre open &quot;mon_fichier.txt&quot; for input as #f_num while not eof(f_num) line input #f_num, li s = s &amp; li &amp; vbCrLf wend close #f_num
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
set f [open mon_fichier.txt r] set s [read $f] close $f
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Lit le fichier entier dans une variable. Ce code VB est très lent, même pour des fichiers moyennement gros. Et il n'y aucun moyen de prendre en compte les caractères de saut de ligne. Le code Tcl accepte et préserve les sauts de ligne dans les données. Il normalise aussi les différents caractères de sauts de ligne en un simple type de caractères de sauts de ligne standardisé(par défaut). Ce code s'applique de façon équivalente à des données brutes, à des listes Tcl, à des tableaux Tcl. L'option <option>
r</option>
dans l'instruction <command>
open</command>
indique qu'elle est en mode &#39;read&#39; (lecture). </entry>
</row>
<row>
<entry>
<para>
<programlisting>
dim a(1 to 3) as string a(1) = &quot;Mark&quot; a(2) = &quot;Brian&quot; a(3) = &quot;Roy&quot; &#39;aïe - il me faut plus d'éléments redim preserve a(1 to 10) as string a(4) = &quot;John&quot;
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
array set a [list 1 Mark 2 Brian 3 Roy] set a(4) John # maintenant différents types # de noms d'éléments dans le même tableau set a(Red) Hat set a(Linux,RedHat) 7.1
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Tableau contre Tableau. En VB, les tableaux sont limités à l'utilisation de nombres comme indices (En Tcl, on appelle &#39;element names&#39; les indices, ou index). Et la taille d'un tableau doit être déclarée ; pour l'agrandir il faut utiliser l'opération (lente) &#39;ReDim Preserve&#39;. Les tableaux Tcl s'agrandissent automatiquement, et disposent d'une table de hashage super efficace qui leur permet même de prendre en charge des centaines de milliers d'éléments à une vitesse supérieure. En Tcl, on utilise tous les types de données comme nom d'élément, et différents types peuvent même être mélangés dans le même tableau. Le nombre de dimensions de chaque élément n'est pas limité. Tcl fournit des moyens simples pour se déplacer dans les tableaux, ou dans certains éléments du tableau (par filtrage). Vous pouvez aussi obtenir une liste entière ou partielle des noms d'éléments, et faire d'autres opérations plus facilement qu'en VB. En VB, l'utilisation d'une partie de ses possibilités nécessite l'utilisation d'une collection ou d'un objet de dictionnaire. Chacun d'eux possède ses bizarreries et ses pièges, tels qu'une charge plus importante qu'un tableau VB. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
(Pas d'équivalence)
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
array set mon_tableau $ma_liste set ma_liste [array get mon_tableau]
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Liste vers tableau, et l'inverse. Le transfert facile et rapide entre deux structures de données primaires signifie que les outils appliqués à l'un peuvent l'être à l'autre. Ils multiplient mutuellement leur utilité. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
dim a(1 to 100) as string dim i as integer dim f_num as integer f_num = fichierlibre open &quot;mon_fichier.txt&quot; for output as #f_num for i=1 to 100 print #f_num, a(i) next close #f_num </programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
set f [open mon_fichier.txt w] set $f [array get a] close $f
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Ecrit le tableau entier. Dans ce code VB, et fréquemment dans d'autres codes VB, les sauts de ligne et d'autres caractères présents dans les données vont provoquer des erreurs à un stade ultérieur (phénomène de relecture). Cela devient un problème si votre code manipule des données saisies par un utilisateur. En Tcl, ça n'en n'est pas un, les données sont conservées tout le temps &quot;proprement&quot;. De plus, de nombreuses combinaisons de caractères de retour chariot (0x0 ou décimal 13) et de saut de ligne (0x0A ou décimal 10)sont automatiquement normalisées par défaut. Remarquez bien que ces deux exemples ne produisent pas des fichiers identiques en sortie. L'exemple Tcl, comme le VB, écrit un fichier texte. Mais le fichier Tcl sera lu (par Tcl) et aura automatiquement le même nombre d'éléments, les mêmes noms d'éléments, etc. En Tcl, la structure de données en liste est utilisée pour cela. S'en servir garantit que les données sont formatées selon une représentation concise, sans ambiguïté, textuelle. Les humains peuvent aussi le lire et y écrire. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
(Pas d'équivalence)
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
set f [open mon_fichier.txt w] puts $f [array get a blanc*] close $f
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Ecrit certains éléments d'un tableau. En VB, il faudrait utiliser une collection ou un objet de dictionnaire pour faire ça. Une boucle ferait une itération à travers tous les éléments et sélectionnerait ceux qui sont appropriés. En Tcl, le nom du tableau est <literal>
a</literal>
et une chaîne <literal>
blanc*</literal>
(sensible à la casse) est utilisée comme filtre pour sélectionner les éléments à grande vitesse. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
(Pas d'équivalence)
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
set ma_liste [lsort $ma_liste]
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Trier une liste. Le tri peut être inversé, ou ordonné numériquement, etc... On peut aussi trier une liste de sous-listes en utilisant un élément d'index. Tcl contient une suite complète d'instructions pour manipuler les structures de données en liste. Voir aussi <command>
lappend</command>
, <command>
linsert</command>
, <command>
lreplace</command>
, <command>
lsearch</command>
, <command>
concat</command>
, <command>
split</command>
, <command>
join</command>
, etc. On peut aussi imbriquer arbitrairement les listes Tcl ; l'instruction <command>
foreach</command>
s'exécutera sans problème. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
&#39; nécessite une référence aux ADO &#39; considère que nous avons une connexion nommée conn dim rs as new recordset rs.open &quot;select id, nom, age from peuple&quot;, _ ma_connexion, adOpenStatic &#39; placer ici le code rs.close set rs=nothing </programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
package require tclodbc # considère que nous avons une connexion nommée conn conn read a &quot;select id, nom, age from peuple&quot; # placer ici le code unset a ;# libération du tableau
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Renvoie un simple tableau de données d'une table de base de données. En VB, les données sont toujours retournées dans un objet 'recordset'. En Tcl,il peut être renvoyé dans un tableau et/ou dans une liste, en fonction de vos besoins et du paquetage de la base de données utilisé. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
(Pas d'équivalence)
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
package require http set httpTrans [http::geturl $pageURL] upvar #0 $httpTrans state if {$state(status) == {ok}} { puts $state(body) } </programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Retourne un document ou un fichier d'un serveur Web. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
(Pas d'équivalence)
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
regexp -all {src=[&#39;&quot;](.+?)[&#39;&quot;]} $body mes_images
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Recherche et extraction de modèles de chaînes complexes. En Tcl,on utilise les  <emphasis>
expressions rationnelles</emphasis>
pour cela. <emphasis>
Expression rationnelle</emphasis>
est une spécification de recherche de concordance de modèles de chaînes,dont le concept est similaire au modèle des cartes magiques utilisé avec l'opérateur 'like', à l'exception des stéroïdes,  <emphasis>
de tous</emphasis>
les stéroïdes. Les expressions rationnelles sont plusieurs fois plus puissantes et plus flexibles que les modèles 'like'. Pour une initiation informelle aux expressions rationnelles, voyez <ulink url="http://zez.org/article/articleprint/11">
http://zez.org/article/articleprint/11</ulink>
. L'analyseur d'expressions rationnelles de Tcl est écrit en code C optimisé, et on peut l'utiliser au travers de différentes instructions Tcl (<command>
regexp</command>
, <command>
regsub</command>
, <command>
lsearch</command>
, etc. Vous pouvez aussi utiliser les versions plus simples, moins puissantes auxquelles vous êtes habitués dans différentes instructions (<command>
glob</command>
, <command>
string match</command>
, <command>
lsearch</command>
, et d'autres encore). Cet exemple prendrait entre 15 et 50 lignes de code VB, en fonction de la robustesse et de la tolérance à des situations diverses qu'il aurait besoin d'avoir. De plus, c'est l'un des codes les plus difficiles, les plus durs à déboguer, et les plus lents que l'on puisse écrire en VB (c'est la voix de l'expérience qui parle). Ici, on obtient rapidement une liste des URLs de toutes les images d'une page HTML. </entry>
</row>
<row>
<entry>

<programlisting>
(Pas d'équivalence)
</programlisting>

</entry>

<entry>

<programlisting>
set find {&lt;tr&gt;(.*?)&lt;td&gt;(.*?)&lt;/td&gt;&lt;td&gt;(.*?)&lt;/td&gt;&lt;td&gt;(.*?)&lt;/td&gt;(.*?)&lt;/tr&gt;} set replace {&lt;tr&gt;\1&lt;td width=20%&gt;\2&lt;/td&gt;&lt;td width=40%&gt;\3&lt;/td&gt;&lt;td width=30%&gt;\4&lt;/td&gt;\5&lt;/tr&gt;} regsub -all -nocase $exp $body $replace result puts $result
</programlisting>

</entry>

</row>

<row>

<entry spanname="span-horiz">

Recherche et substitution de modèles de chaînes complexes. De nouveau,
en Tcl,on utilise les expressions rationnelles. Cet exemple prendrait
entre 40 lignes de code VB voire plus, en particulier s'il est
logiquement organisé avec suffisamment de commentaires pour qu'un
programmeur chargé de la maintenance puisse suivre. Et de plus, c'est
l'un des codes les plus difficiles, les plus durs à déboguer, et les
plus lents que l'on puisse écrire en VB. Ici, le jeu de trois cellules
dans <emphasis> chaque ligne du corps du HTML</emphasis> est
systématiquement modifié, tout en laissant le contenu de chaque cellule
inchangé.

</entry>

</row>

<row>

<entry>

<programlisting>
(Pas d'équivalence)
</programlisting>

</entry>
<entry>

<programlisting>

set handle [socket markhpc.dcisite.com 2000] set bienvenue [read $handle] close $handle

</programlisting>

</entry>
</row>
<row>
<entry spanname="span-horiz">
Crée une connexion à une interface réseau (en tant que client) et retourne des données. Dans l'exemple, nous considérons qu'un serveur écoute sur le port TCP 2000 de l'hôte spécifié. </entry>
</row>
<row>
<entry>
<para>
<programlisting>
(Pas d'équivalence)
</programlisting>
</para>
</entry>
<entry>
<para>
<programlisting>
proc bienvenue {handle client_ip client_port} { puts $handle {Bienvenue sur notre serveur d'accueil!} close $handle } socket -server bienvenue 2000
</programlisting>
</para>
</entry>
</row>
<row>
<entry spanname="span-horiz">
Met en oeuvre un serveur réseau pour répondre au client montré ci-dessus. Voici le script complet. si vous utilisez Wish (le shell fenêtré Tcl), il tournera toute la journée comme il est présenté. Si vous utilisez Wish (le shell fenêtré Tcl), ajoutez une instruction <command>
vwait</command>
à la fin, pour forcer le programme à attendre des événements plutôt que de se terminer à la fin du script. Cette différence entre les deux shells est nécessaire et intentionnelle, dans la mesure où Wish est piloté par défaut par les événementset que Tclsh ne l'est pas. </entry>
</row>
</tbody>
</tgroup></table></sect1>
<sect1 id="more">
<title>
Pour plus d'information</title>
<itemizedlist>
<listitem>
<para>
<emphasis>
Programmation Tcl/Tk et initiation : </emphasis>
Lisez l'incroyable livre de Brent Welch <emphasis>
Practical Programming in Tcl and Tk</emphasis>
. Grâce à la générosité de Brent, vous pouvez même lire et imprimer les vieilles éditions et des chapitres sélectionnés des éditions actuelles sur <ulink url="http://www.beedub.com/book">
http://www.beedub.com/book</ulink>
.</para>
</listitem>
<listitem>
<para>
<emphasis>
Téléchargements nécessaires pour développer en Tcl : </emphasis>
Voyez <ulink url="http://www.tcl.tk">
http://www.tcl.tk</ulink>
pour TclPro 1.4.1 pour tous les systèmes d'exploitation et à peu près tous les paquetages complémentaires dont vous pourriez avoir besoin. TclPro contient les deux interpréteurs (Tclsh et Wish) version 8.3, plus un excellent débogueur interactif ainsi qu'un ensemble d'outils et de bibliothèques très utiles. La version 1.4.1 est disponible au public. cependant, à la mi-2002,il semble que <ulink url="http://www.activestate.com">
ActiveState</ulink>
est en train de transformer TclPro en produit commercial. Rappelez-vous que vous pouvez toujours obtenir les interpréteurs 'standard' pour tous les systèmes d'exploitation du site <ulink url="http://tcl.sourceforge.net">
http://tcl.sourceforge.net</ulink>
étant donné que Tcl est un logiciel open source.</para>
</listitem>
<listitem>
<para>
<emphasis>
Editeurs avec coloration syntaxique, etc : </emphasis>
Pour travailler sous MS Windows, j'apprécie le produit commercial bon marché TextPad disponible à l'adresse <ulink url="http://www.textpad.com">
http://www.textpad.com</ulink>
. Actuellement, il coûte 29$ US par licence, et vous pouvez l'essayer avant de l'acheter. Téléchargez la définition de syntaxe Tcl de leur site Web. TextPad est l'éditeur pour MS Windows possédant le plus de caractéristiques que j'ai jamais vues ; il a la capacité d'émuler le comportement des éditeurs de Microsoft. Vous pouvez l'utiliser comme IDE (outil de développement) pour Tcl/Tk en l'interfaçant avec les interpréteurs et vos autres outils. Pour Unix/Linux, et peut-être bien même pour MS Windows, essayez Nedit à l'adresse <ulink url="http://www.nedit.org">
http://www.nedit.org</ulink>
. Il est libre, placé sous les termes de la GNU General Public License. C'est aussi un bon outil, qui permet aux utilisateurs de MS Windows d'être immédiatement productifs.</para>
</listitem>
<listitem>
<para>
<emphasis>
Des outils auxquelles vous penserez probablement : </emphasis>
La première chose que veulent beaucoup de programmeurs VB est d'attaquer une base de données ODBC. Allez chercher le paquetage TclODBC de <ulink url="http://www.tcl.tk">
http://www.tcl.tk</ulink>
. C'est une DLL win32 qui vous permettra d'accéder à toutes les sources de données et pilotes ODBC. Il est fourni avec de la documentation, et il y a un mini-exemple ci-dessus. Remarquez qu'il peut être comme ne pas être portable vers d'autres systèmes d'exploitation, donc vous devriez encapsuler tous les appels que vous lui ferez dans des procédures. De cette façon, vous pourrez porter votre code pour utiliser d'autres bibliothèques plus tard. Les expressions rationnelles sont en elle-même presqu'un langage de programmation puissant. De ce fait, il faut un certain temps pour les maîtriser. Le petit programme Tcl &#39;Visual RegExp&#39; m'a énormément aidé en cela. Vous l'obtiendrez à l'adresse <ulink url="http://laurent.riesterer.free.fr/regexp">
http://laurent.riesterer.free.fr/regexp</ulink>
. Il y a aussi plusieurs paquetages qui relient Tcl au monde d'ActiveX ; ainsi vous pouvez automatiser des applications MS Office, etc...</para>
</listitem>
<listitem>
<para>
<emphasis>
Sujets d'aide principaux : </emphasis>
Quand vous aurez obtenu TclPro et son fichier d'aide, allez à son index et regardez le sujet &#39;Tcl&#39;. Il y a un sommaire des règles syntaxiques du langage, et des substitutions qui le pilotent. Regardez sans faute les sujets suivants : &#39;re_syntax&#39;, &#39;tclvars&#39;, &#39;tclsh&#39;, and &#39;wish&#39;. A première vue, ils sont transcrits des pages de manuel (man pages)d'Unix/Linux, et constituent certains des meilleurs textes que j'ai jamais vu dans les aides de Windows ; si vous avez besoin de <emphasis>
matériaux de référence</emphasis>
, je ne vous recommande pas de lire ce fichier d'aide pour votre initiation, mais c'est une excellente référence de programmation.</para>
</listitem>
<listitem>
<para>
<emphasis>
&#39;Démarrer&#39; éléments du menu :</emphasis>
Après avoir installé TclPro, vous devriez regarder le menu 'Démarrer' de TclPro,et examiner le &#39;Incr Widgets Reference&#39; et le &#39;Widget Tour&#39;. Ils montrent les possibilités de l'interface graphique de Tk <emphasis>
avec le code Tcl effectivement nécessaire pour les utiliser.</emphasis>
</para>
</listitem>
<listitem>
<para>
<emphasis>
Argumentaire (comment convaincre votre direction d'utiliser Tcl/Tk) : </emphasis>
On trouvera une profusion d'informations convaincantes à l'adresse suivante <ulink url="http://www.tcl.tk">
http://www.tcl.tk</ulink>
.</para>
</listitem>
</itemizedlist>
</sect1>
<sect1 id="copyright">
 <title>
Licence et droits d'auteur</title>
 <para>
Copyright (c) 2003 Mark Hubbard.</para>
 <para>
Permission est accordée de copier, distribuer et/ou de modifier ce document selon les termes de la GNU Free Documentation Licence, version 1.2 ou ultérieure publiée par la Free Software Foundation ; sans section modifiée, sans texte de couverture de première ou de dernière page. Une copie de la license est disponible à <ulink url="http://www.gnu.org/copyleft/fdl.html">
http://www.gnu.org/copyleft/fdl.html</ulink>
, dans la section intitulée <quote>
GNU Free Documentation License</quote>
.</para>
 <para>
<emphasis>
&quot;Visual Basic,&quot; &quot;VBScript,&quot; et tous les termes relatifs sont la propriété de Microsoft <ulink url="http://www.microsoft.com">
http://www.microsoft.com</ulink>
.</emphasis>
</para>
 <para>
<emphasis>
Tcl (Tool Command Language) est un logiciel open source, créé par John Ousterhout - <ulink url="http://www.tcl.tk">
http://www.tcl.tk</ulink>
ou <ulink url="http://tcl.sourceforge.net">
http://tcl.sourceforge.net</ulink>
.</emphasis>
</para>
</sect1>
</article>

