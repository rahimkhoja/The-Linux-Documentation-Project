<!doctype linuxdoc system>

<!-- From DOS/Windows HOWTO, by Guido Gonzato -->
<!-- Tested with SGML-tools 1.0.7; it compiles fine. -->

<article>

<title> From DOS/Windows to Linux HOWTO 

<author> Par Guido Gonzato, <url url="REMOVE_MEguido@ibogfs.cineca.it"> (enlevez &laquo;REMOVE_ME&raquo;) ; adaptation française : Mark Hoebeke, <url url="mh@jouy.inra.fr">.

<date>v1.3.2, 22 Février 1999

<abstract>

Ce HOWTO est consacré à tous les (bientôt ex-?) utilisateurs de DOS
et Windows qui ont décidé de basculer vers Linux, le clone gratuit
d'UNIX. L'objectif de ce document est d'aider le lecteur à transposer
sa connaissance de DOS et Windows à l'environnement Linux, et
également de lui fournir des astuces sur la manière d'échanger des
fichiers et des ressources entre les deux systèmes d'exploitation.

</abstract>

<toc>


<sect> Introduction

<p>

<sect1> Est-ce bien Linux qu'il vous faut ?

<p>

Vous voulez basculer du monde DOS (cette définition incluant Windows)
vers Linux ? Bonne idée : Linux est techniquement supérieur au DOS, à
Windows 9x et même à Windows NT. Mais prenez garde : cela ne vous sera
peut-être pas si utile que ça. Voici les principales différences entre
DOS/Windows et Linux :

<itemize>

<item> Windows peut faire tourner Microsoft Office et des tas de
jeux ; est considéré comme facile à installer et configurer ; est
notoirement instable ; est peu performant et sujet à des plantages
fréquents. 

<item> Linux peut faire tourner StarOffice, un flopée de logiciels
techniques mais moins de jeux ; peut être difficile à installer et à
configurer ; est d'une stabilité à toute épreuve ; offre des
performances optimales et ne plante qu'extrêmement rarement.

</itemize>

C'est à vous de décider ce dont vous avez besoin. En outre, Linux vous
donne la puissance mais nécessite un temps d'apprentissage pour la
maîtriser. Ainsi, si vous voulez utiliser avant tout des logiciels du
commerce, ou si vous ne vous sentez pas d'attaque pour apprendre quelques
nouveaux concepts et commandes, vous feriez mieux de regarder
ailleurs. Soyez conscient que de nombreux débutants abandonnent à
cause des difficultés rencontrées au démarrage.

Des travaux sont en cours pour rendre Linux plus simple d'utilisation,
mais <em/n'espérez pas vous y sentir à l'aise à moins de lire pas mal
de documentation et de l'utiliser au moins pendant quelques
mois/. Linux ne vous donnera pas de résultats immédiats. En dépit de
ces avertissements, je suis confiant à 100&percnt; que si vous êtes le
bon type d'utilisateur, vous trouverez en Linux votre Nirvana
informatique. Au fait, Linux + DOS/Win peuvent coexister en toute
harmonie sur la même machine.

Prérequis pour ce howto : je supposerai que

<itemize>

<item> vous connaissez les bases des commandes et des concepts du DOS ;

<item> Linux, et éventuellement le système X Window (X11 en abrégé),
sont correctement installés sur votre PC ;

<item> votre interpréteur de commandes (ou <it/shell/, l'équivalent
de <tt/COMMAND.COM/) est <tt/bash/. 

</itemize>

Sauf indication contraire, toute l'information de ce document concerne
ce vieux méchant DOS. On trouvera des informations à propos de Windows
par-ci par-là, mais gardez à l'esprit que Windows et Linux sont
totalement différents, contrairement au DOS qui est une espèce de
parent pauvre d'UNIX.

Veuillez également noter que ce document n'est ni une introduction
exhaustive ni un guide de configuration !

La version la plus récente de ce document est disponible en différents
formats à l'adresse <url
url="ftp://sunsite.unc.edu:/pub/Linux/docs/howto">.

<sect1> Oui, c'est bien Linux. Je veux en savoir plus.

<p>

Vous avez installé Linux et les programmes dont vous avez besoin sur
le PC. Vous vous êtes créé un compte utilisateur (si ce n'est pas le
cas, tapez <tt/adduser votre_nom/ <em/maintenant !/) et Linux est en
train de tourner. Vous venez d'entrer votre nom et votre mot de passe,
et, à présent, vous regardez l'écran en vous demandant : &laquo;Et
maintenant, que faire ?&raquo;

Ce n'est pas le moment de désespérer. Vous êtes sur le point de faire
les mêmes choses que celles que vous aviez l'habitude de faire avec
DOS/Win, et beaucoup plus. Si vous étiez sous DOS/Win au lieu d'être
sous Linux, vous seriez en train de faire quelques-unes des tâches
suivantes :

<itemize>

<item> faire tourner des programmes et créer, copier, visualiser,
effacer, imprimer et renommer des fichiers ;

<item> faire des CD, des MD, des RD et des DIR dans vos répertoires ;

<item> formater des disquettes et copier des fichiers vers ou à partir
de celles-ci ;

<item> personnaliser le système ;

<item> surfer sur l'Internet ;

<item> écrire des fichiers .BAT et des programmes dans votre langage
préféré ;

<item> le 1&percnt; restant.

</itemize>

Vous serez ravi de savoir que ces tâches peuvent être accomplies sous
Linux de manière similaire au DOS. Sous DOS, l'utilisateur moyen
n'utilise qu'une fraction de la bonne centaine de commandes disponibles :
la même chose, jusqu'à un certain point, s'applique à Linux.

<sect2> Concepts introductifs

<p>

La meilleure façon d'apprendre quelque chose de nouveau est de se
jeter à l'eau. Il vous est chaudement recommandé d'expérimenter et de
jouer avec Linux : à moins de vous connecter en tant que <tt>root</tt>
cela ne peut en aucun cas endommager le système. Quelques points à
noter :

<itemize>

<item> avant tout, comment quitter Linux en toute sécurité ? Si vous
êtes devant un écran en mode texte, faites &lt;CTRL-ALT-DEL&gt;,
attendez que le système commence à redémarrer ; à ce moment-là,
éteignez le PC. Si vous travaillez sous X Windows, tapez
&lt;CTRL-ALT-BACKSPACE&gt; d'abord, puis &lt;CTRL-ALT-DEL&gt;. Il ne
faut <em/jamais/ éteindre ou redémarrer le PC directement : cela
pourrait endommager le système de fichiers ;

<item> contrairement au DOS, Linux est pourvu d'origine de mécanismes
de sécurité. Des droits d'accès sont associés aux fichiers et aux
répertoires ; par conséquent, l'utilisateur normal ne peut accéder à
certains d'entre eux, cf. <ref id="Permissions" name="Droits d'accès
et propriété">. &Agrave; l'inverse, DOS et Windows vous permettront de
rayer de la carte l'intégralité du contenu de votre disque dur ;

<item> il existe un utilisateur particulier appelé
&laquo;root&raquo; : c'est l'administrateur système qui dispose du
pouvoir de vie et de mort sur la machine. Si vous travaillez sur votre
propre PC, c'est vous qui êtes root. Travailler sous root est
<em/dangereux/ : toute erreur peut endommager sérieusement voire
détruire le système, comme avec DOS/Win. Ne travaillez pas sous root
sauf en cas de nécessité absolue ;

<item> une grande part de la complexité de Linux provient du fait
qu'il est configurable à l'extrême : tout paramètre et toute
application peuvent virtuellement être personnalisés grâce à un ou
plusieurs fichiers de configuration. Cette complexité est le prix à
payer pour la puissance ;

<item> les redirections et les <it/pipes/ sont des capacités
secondaires du DOS, mais ils sont beaucoup plus importants et plus
puissants sous Linux. Des commandes simples peuvent être mises bout à
bout pour accomplir des tâches complexes. Je vous encourage fortement
à apprendre à vous en servir.

</itemize>


<sect2> Obtenir de l'aide.

<p>

Il existe de nombreuses manières d'obtenir de l'aide avec Linux. Les
plus importantes sont de :

<itemize>

<item> <em/lire la documentation/ -- J'insiste. Bien que le HOWTO que
vous lisez en ce moment puisse servir d'introduction à Linux, il y a
plusieurs livres que vous devriez vraiment lire : le &laquo;Linux
Installation and Getting Started&raquo; par Matt Welsh (<url
url="http://sunsite.unc.edu/mdw/LDP/gs/gs.html">), le &laquo;Linux
User Guide&raquo; de Larry Greenfield (<url
url="ftp://sunsite.unc.edu/pub/Linux/docs/linux-doc-project/users-guide">)
, et la FAQ Linux (<url
url="http://sunsite.unc.edu/mdw/FAQ/Linux-FAQ.html">).  Vous devriez
vous sentir coupable jusqu'à ce que vous ayez lu au moins l'un d'entre
eux.

<item> la documentation des paquetages installés sur votre machine se
trouve souvent dans les sous-répertoires de <file>/usr/doc/</file> ;

<item> pour obtenir un peu d'aide sur les &laquo;commandes
internes&raquo; du shell, tapez <tt/help/ ou mieux, <tt/man bash/ ou
<tt/info bash/ ;

<item> pour avoir l'aide sur une commande, tapez <tt/man commande/ qui
invoque la page du manuel (<em/man/) relative à
<tt/commande/. D'autre part, vous pouvez taper <tt/info commande/ qui
invoque la page d'informations (<it/info/) traitant de <tt/commande/. 
Info est un système de documentation à base d'hypertexte, dont
l'utilisation n'est peut-être pas intuitive au début. Enfin, vous
pouvez essayer <tt/apropos commande/ ou <tt/whatis commande/. Pour
toutes ces commandes, tapez &laquo;q&raquo; pour quitter.

<item> enfin, sur l'Internet : l'endroit approprié pour obtenir de
l'aide est Usenet, par exemple dans <url
url="news:comp.os.linux.setup">. S'il vous plaît, ne m'envoyez pas de
messages d'appel à l'aide car je suis quelque peu débordé.

</itemize>


<sect1> Conventions

<p>

Tout au long de ce document, les exemples figureront souvent au format
suivant :
<tt/<...>/ est un argument obligatoire, alors que <tt/[...]/ est
optionnel.
Par exemple :

<tscreen><verb>
$ tar -tf <fic.tar> [> fic-redir]
</verb></tscreen>

<tt>fic.tar</tt> doit être spécifié, mais la redirection vers
<tt/fic_redir/ est optionnelle.

&laquo;LPM&raquo; signifie &laquo;Lisez les Pages du Manuel pour de
plus amples informations&raquo;. Je ne soulignerai jamais assez
combien il est important de lire la
documentation. &laquo;DOSWin&raquo; signifie
&laquo;DOS/Windows&raquo;.

Lorsque l'invite (<it/prompt/) d'un exemple de commande est le
symbole <tt>&num;</tt>, cette commande ne peut être lancée que
par root.

<sect> Pour les impatients

<p>

Envie de vous y mettre tout de suite ? Examinez ce tableau :

<!-- I'd like to make this an sgml table, but lynx wouldn't display it
correctly. I'll think it over. -->
<tscreen><verb>
DOS                     Linux                   Notes
------------------------------------------------------------------------------

ATTRIB (+-)attr fic    chmod <mode> fic	      completement different
BACKUP                 tar -Mcvf device dir/  idem
CD repertoire\         cd repertoire/         presque la meme syntaxe
COPY fic1 fic2	       cp fic1 fic2	      idem
DEL fic                rm fic                 attention, pas de undelete
DELTREE	repertoire     rm -R repertoire/      idem
DIR                    ls                     pas exactement la meme syntaxe
DIR fic /S             find . -name fic       completement different
EDIT fic               vi fic                 Je ne pense pas que vous aimerez
                       jstar fic	      un peu comme 'edit' sous DOS
EDLIN fic	       ed fic                 n'y pensez meme pas
FORMAT                 fdformat,
                       mount, umount          syntaxe assez differente
HELP command           man command,           meme philosophie
                       info command
MD repertoire          mkdir repertoire/      presque la meme syntaxe
MORE < fic             less fic               bien mieux
MOVE fic1 fic2	       mv fic1 fic2	      idem
NUL                    /dev/null	      idem
PRINT fic              lpr fic                idem
PRN                    /dev/lp0,
                       /dev/lp1               idem
RD repertoire          rmdir repertoire/      presque la meme syntaxe
REN fic1 fic2	       mv fic1 fic2	      ne marche pas pour plusieurs fichiers
RESTORE                tar -Mxpvf device      syntaxe differente
TYPE fic               less fic               beaucoup mieux
WIN                    startx                 a mille lieues !
</verb></tscreen>

S'il vous faut plus qu'un tableau de commandes, veuillez vous
reporter aux sections suivantes.

<sect> &Agrave; la rencontre du bash

<p>


Bonne nouvelle : avec Linux vous devez taper beaucoup moins de
caractères à l'invite car l'interpréteur de commandes <tt>bash</tt>
tape à votre place autant que possible, et dispose de fonctionnalités
d'édition de ligne du tonnerre. Pour commencer, la flèche vers le haut
rappelle les lignes de commandes précédentes ; mais il y a
plus. L'appui sur &lt;TAB&gt; complète les noms de fichiers et de
répertoires, ainsi, taper

<tscreen><verb>
$ls /uTABloTABbTAB
</verb></tscreen>

c'est comme taper
<tscreen><verb>
$ ls /usr/local/bin
</verb></tscreen>

S'il y a des ambiguïtés, comme lorsque vous tapez

<tscreen><verb>
$ ls /uTABloTABiTAB
</verb></tscreen>

<tt>bash</tt> s'arrête parce qu'il ne sait pas si vous voulez dire
<file>/usr/local/info</file> ou <file>/usr/local/include</file>. Il
faut fournir plus de caractères avant de taper &lt;TAB&gt; à nouveau.

D'autres combinaisons utiles sont &lt;ESC-BACKSPACE&gt; qui efface un
mot sur la gauche, et &lt;ESC-D&gt; qui en efface un sur la droite ;
&lt;ESC-F&gt; déplace le curseur d'un mot vers la gauche ;
&lt;CTRL-A&gt; l'amène au début de la ligne, &lt;CTRL-E&gt; vers
la fin. La touche &lt;ALT&gt; est équivalente à la touche &lt;ESC&gt;.

On s'arrête là pour le moment. Une fois habitué(e) à ces raccourcis,
vous vous lasserez très rapidement de l'invite du DOS...

<sect> Fichiers et Programmes

<p>


<sect1> Fichiers : notions préliminaires

<p>

La structure des répertoires et des fichiers sous Linux est très
similaire à celle de DOSWin. Les fichiers ont des noms qui doivent
obéir à certaines règles, ils sont stockés dans des répertoires,
certains d'entre eux sont exécutables et parmi ceux-ci, la plupart
disposent d'options. De plus, il est possible d'utiliser les caractères
<em/joker/, la redirection et les pipes. Seules quelques différences
mineures existent :

<itemize>

<item> sous DOS, les noms de fichier sont au format appelé 8.3 ;
comme dans <tt/TROPCOUR.TXT/. Linux peut faire mieux. Si vous avez
installé Linux en utilisant un système de fichiers comme ext2 ou
umsdos, vous avez le loisir d'utiliser des noms de fichier plus longs
(jusqu'à 255 caractères), et avec plus d'un point : par exemple,
<tt/Ceci_est.un.TRES_long.nom.de.fichier/. Veuillez noter que j'ai
utilisé aussi bien des majuscules que des minuscules : en fait...

<item> majuscules et minuscules dans les noms de fichier ou les
commandes sont différenciées. Par conséquent, <tt/NOMFIC.tar.tgz/ et
<tt/nomfic.tar.gz/ sont deux fichiers différents. De même, <tt/ls/ est
une commande mais <tt/LS/ est une erreur ;

<item> utilisateurs de Windows, faites attention en utilisant les
noms de fichier longs sous Linux. Si un nom de fichier contient des
espaces (ce qui n'est pas recommandé mais néanmoins possible), vous
devez l'entourer avec des guillemets à chaque fois que vous y faites
référence. Par exemple :

<tscreen><verb>
$ # la commande suivante cree un repertoire appele "Mes vieux fichiers"
$ mkdir "Mes vieux fichiers"
$ ls
Mes vieux fichiers bin tmp
</verb></tscreen>

De plus, l'usage de certains caractères est à éviter : parmi eux, il y
a <tt/!*&dollar;&amp;/.

<item> il n'existe pas d'extensions obligatoires comme .COM ou .EXE
pour les programmes ou .BAT pour les fichiers de commandes. Les
fichiers exécutables sont suivis d'un astérisque &laquo;<tt/*/&raquo;
lorsque vous faites la commande <tt/ls -F/. Par exemple :
<tscreen><verb>
$ ls -F
Je_suis_un_rep/   cindy.jpg    cjpg*   lettre_a_Joe    mon_1er_script*  vieux 
</verb></tscreen>

Les fichiers <tt/cjpg*/ et <tt/mon_1er_script*/ sont des exécutables,
autrement dit des &laquo;programmes&raquo;. Sous DOS, les copies de
sauvegarde se terminent en .BAK, alors que sous Linux elles se
terminent par une tilde &laquo;<tt/&tilde;/&raquo;. De plus, un fichier
commençant par un point est considéré comme étant caché. Exemple : le
fichier <tt/.Je.suis.un.fichier.cache/ ne sera pas visible à la suite
de la commande <tt/ls/ ;

<item> sous DOS, les options des commandes sont obtenues avec
<tt>/option</tt>, Linux utilise <tt/-option/ ou
<file/--option/. Exemple : <tt>dir /s</tt> devient <tt/ls -R/. Remarquez 
que de nombreux programmes DOS, comme <tt/PKZIP/ ou <tt/ARJ/ utilisent
les options dans le style d'UNIX.

</itemize>

&Agrave; présent, vous pouvez aborder la section <ref id="Files"
name="Traduire les commandes DOS en Linux">, mais à votre place, je
poursuivrais ici. 

<sect1> Liens symboliques

<p>

UNIX est pourvu d'un type de fichier sans équivalent sous DOS : le
lien symbolique. On peut l'imaginer comme un pointeur sur un fichier
ou un répertoire, et on peut l'utiliser en lieu et place du fichier ou
du répertoire sur lequel il pointe ; cela ressemble aux raccourcis de
Windows. Des exemples de liens symboliques sont <tt>/usr/X11</tt>,
qui pointe sur <tt>/usr/X11R6</tt>; <tt>/dev/modem</tt>, qui pointe
ou bien sur <tt>/dev/ttyS0</tt> ou bien sur <tt>/dev/ttyS1</tt>.

Pour fabriquer un lien symbolique :


<tscreen><verb>
$ ln -s <fic_ou_rep> <nomdulien>
</verb></tscreen>

Exemple :

<tscreen><verb>
$ ln -s /usr/doc/g77/DOC g77manual.txt
</verb></tscreen>

Il est alors possible de faire référence à  <tt/g77manual.txt/ au lieu
de <tt>/usr/doc/g77/DOC</tt>. Les liens apparaissent de la manière
suivante dans l'affichage du contenu des répertoires :

<tscreen><verb>
$ ls -F
g77manual.txt@
$ ls -l
(des choses et d'autres...)           g77manual.txt -> /usr/doc/g77/DOC
</verb></tscreen>


<sect1> Droits d'accès et propriété <label id="Permissions">

<p>

Sous DOS, les fichiers et les répertoires disposent des attributs
suivants : A (archive), H (caché : <it/hidden/), R (lecture seule :
<it/read-only/) et S (système). Seuls H et R ont un sens sous Linux :
les fichiers cachés sont ceux qui commencent par un point, et pour ce
qui est de l'attribut R, lisez ce qui suit.

Sous UNIX un fichier possède des &laquo;droits d'accès&raquo; et un
propriétaire, qui, à son tour, fait partie d'un
&laquo;groupe&raquo;. Regardez cet exemple :

<tscreen><verb>
$ ls -l /bin/ls
-rwxr-xr-x  1  root  bin  27281 Aug 15 1995 /bin/ls*
</verb></tscreen>

Le premier champ contient les droits d'accès au fichier
<tt>/bin/ls</tt>, qui appartient à root et au groupe bin. En laissant
de côté le reste de l'information, souvenez-vous que la signification
de <tt/-rwxr-xr-x/, de gauche à droite, est :

<tt/-/ est le type de fichier (<tt/-/ = fichier ordinaire, <tt/d/ = répertoire :
<it/directory/, l = lien etc.) ;
<tt/rwx/ sont les droits d'accès pour le propriétaire du fichier
(lecture : <it/read/, écriture : <it/write/, exécution) ;
<tt/r-x/ sont les droits d'accès pour le groupe auquel appartient le
propriétaire du fichier (lecture, exécution) ; (je n'aborderai pas le
concept de groupe, vous n'en avez pas besoin pour survivre, tant que
vous êtes débutant ;-) <tt/r-x/ sont les droits d'accès pour tous les
autres utilisateurs (lecture, exécution).

Le répertoire <tt>/bin</tt> dispose lui aussi de droits d'accès : cf.
<ref id="Directories Permissions" name="Droits d'accès aux
répertoires"> pour plus d'informations. C'est la raison pour laquelle
vous ne pouvez pas effacer le fichier <tt>/bin/ls</tt> à moins d'être
root : vous n'avez pas les droits pour le faire. Pour changer les
droits d'accès d'un fichier, la commande est :

<tscreen><verb>
$ chmod <quiXperm> <fic>
</verb></tscreen>

où <tt/qui/ peut être <tt/u/ (utilisateur, ou propriétaire), <tt/g/
(groupe) <tt/o/ (autres, <it/other/), <tt/X/ vaut <tt/+/ ou <tt/-/, et
<tt/perm/ est à choisir parmi <tt/r/ (lecture, <it/read/), <tt/w/
(écriture, <it/write/) ou <tt/x/ (exécution). Les usages courants pour
<tt/chmod/ sont les suivants :

<tscreen><verb>
$ chmod +x fichier
</verb></tscreen>

cela positionne le droit d'exécution pour le fichier.

<tscreen><verb>
$ chmod go-rw fichier
</verb></tscreen>

cela enlève les droits de lecture et d'écriture pour tous excepté le
propriétaire.

<tscreen><verb>
$ chmod ugo+rwx fichier
</verb></tscreen>

cela donne les droits de lecture, d'écriture et d'exécution à tout le monde.

<tscreen><verb>
# chmod +s fichier
</verb></tscreen>

cela fabrique un fichier de type &laquo;setuid&raquo; ou
&laquo;suid&raquo; -- un fichier que tout un chacun peut exécuter avec
les privilèges de son propriétaire. Typiquement, vous rencontrerez des
fichiers suid appartenant à root ; souvent, il s'agit de fichiers
système importants, comme le serveur X.

Un moyen plus court de faire référence aux droits d'accès est
d'utiliser les chiffres : <tt/rwxr-xr-x/ peut être exprimé comme 755
(chaque lettre correspond à un bit : <file/---/ vaut 0, <file/--x/
vaut 1, <tt/-w-/ vaut 2, <tt/-wx/ vaut 3 etc.). Cela peut sembler
difficile, mais avec un peu de pratique, vous comprendrez le
concept. <tt>root</tt>, en tant que super-utilisateur, a la
possibilité de changer les droits d'accès de quiconque. LPM.

<sect1> Fichiers : traduction des commandes <label id="Files">

<p>

&Agrave; gauche, les commandes DOS, à droite, leurs correspondants Linux.

<TSCREEN><verb>
ATTRIB:         chmod
COPY:           cp
DEL:            rm
MOVE:           mv
REN:            mv
TYPE:           more, less, cat
</verb></tscreen>

Les redirections et la tuyauterie : <tt/ < > >> |/

Les jokers : <tt/* ?/

<tt>nul:        /dev/null</tt>

<tt>prn, lpt1:  /dev/lp0 ou /dev/lp1; lpr</tt>

<sect2> Exemples

<p> 

<tscreen><verb>
DOS					Linux
---------------------------------------------------------------------

C:\GUIDO>ATTRIB +R FIC.TXT		$ chmod 400 fic.txt
C:\GUIDO>COPY JOE.TXT JOE.DOC           $ cp joe.txt joe.doc
C:\GUIDO>COPY *.* TOTAL              	$ cat * > total
C:\GUIDO>COPY FRACTALS.DOC PRN       	$ lpr fractals.doc
C:\GUIDO>DEL TEMP                       $ rm temp
C:\GUIDO>DEL *.BAK                   	$ rm * 
C:\GUIDO>MOVE PAPIER.TXT TMP\		$ mv papier.txt tmp/
C:\GUIDO>REN PAPIER.TXT PAPIER.ASC     	$ mv papier.txt papier.asc
C:\GUIDO>PRINT LETTRE.TXT             	$ lpr lettre.txt
C:\GUIDO>TYPE LETTRE.TXT             	$ more lettre.txt
C:\GUIDO>TYPE LETTRE.TXT             	$ less lettre.txt
C:\GUIDO>TYPE LETTRE.TXT > NUL    	$ cat lettre.txt > /dev/null
	n/a                             $ more *.txt *.asc
	n/a                             $ cat section*.txt | less
</verb></tscreen>

Notes:

<itemize>

<item> <tt/*/ est plus malin sous Linux : <tt/*/ désigne tous les
fichiers, sauf ceux qui sont cachés ; <tt/.*/ désigne tous les
fichiers cachés (mais également le répertoire courant
&laquo;<tt/./&raquo; et son répertoire parent &laquo;<tt/../&raquo; :
attention !) ; <tt/*.*/ ne désigne que les fichiers qui contiennent,
ou qui se terminent par un &laquo;<tt/./&raquo; ; <tt/p*r/ désigne
aussi bien &laquo;papier&raquo; que &laquo;plier&raquo; ; <tt/*c*/
désigne aussi bien &laquo;ici&raquo; que &laquo;pacha&raquo; ;


<item> lors de l'utilisation de <tt/more/, tapez &lt;ESPACE&gt; pour
parcourir le fichier, et &laquo;q&raquo; pour quitter. <tt/less/ est
plus intuitif et vous permet d'employer les flèches ; 

<item> <tt/UNDELETE/ n'existe pas, alors <em/pensez-y à deux fois/ avant
d'effacer quoi que ce soit ;

<item> en plus des <tt/&lt; &gt; &gt;&gt;/ du DOS, Linux dispose de
<tt/2&gt;/ pour rediriger les messages d'erreur (stderr) ; de plus,
<tt/2&gt;&amp;1/ redirige stderr vers stdout, alors que
<tt/1&gt;&amp;2/ redirige stdout vers stderr ;

<item> Linux possède un autre joker : les <tt/[]/. Utilisation :
<tt/[abc]*/ désigne les fichiers commençant par a, b ou c ;
<tt/*[I-N1-3]/ désigne les fichiers se terminant par I, J, K, L, M,
N, 1, 2, ou 3 ;

<item> <tt/lpr/ &lt;fic&gt; imprime un fichier en tâche de fond. Pour
vérifier l'état de la file d'impressions, utilisez <tt/lpq/ ; pour
retirer un fichier de la file, utilisez <tt/lprm/ ;


<item> il n'existe pas de <tt/RENAME/ identique à celui du DOS ; en
fait, <tt/mv *.xxx *.yyy/ ne marchera pas. Un commande du type REN est
disponible à l'adresse <url
url="ftp://sunsite.unc.edu/pub/Linux/utils/file">;

<item> utilisez <tt/cp -i/ et <tt/mv -i/ pour être averti lorsqu'un
fichier est sur le point d'être écrasé.

</itemize>


<sect1> Exécution de programmes : le multi-tâches et les sessions

<p>

Pour lancer un programme, entrez son nom comme vous le feriez sous
DOS. Si le répertoire (cf. section <ref id="Directories"
name="Utilisation des répertoires">) où se trouve le programme est
inclus dans le PATH (cf. section <ref id="System Initialisation"
name="Fichiers d'initialisation du système">), le programme
démarrera. Une exception : contrairement au DOS, sous Linux, un
programme situé dans le répertoire courant ne s'exécutera pas à moins
que ce répertoire ne soit inclus dans le
PATH. <it/Escamotage/<footnote>NdT. : En français dans le texte.</footnote> :
si <tt/prog/ est votre programme, tapez <tt>./prog</tt>.

Voici à quoi ressemble une ligne de commande typique :

<tscreen><verb>
$ commande [-o1 [-o2] ... [-on]] [arg1 [arg2] ... [argn]] [< entree] [> sortie]
</verb></tscreen>

où <tt>-o1</tt>,...,<tt>-on</tt> sont les options de la commande et
<tt/arg1/,...,<tt/argn/ sont les arguments de la commande. Il est
possible de spécifier plusieurs commandes sur une seule ligne :

<tscreen><verb>
$ commande1 ; commande2 ; ... ; commanden
</verb></tscreen>

C'est tout au sujet de l'exécution des commandes, mais on peut
facilement faire un pas de plus. L'une des principales motivations pour
l'utilisation de Linux est qu'il s'agit d'un système d'exploitation
multi-tâches -- il est capable de faire tourner plusieurs programmes
(qu'on appellera des processus) en même temps. Vous pouvez lancer des
processus en arrière-plan et continuer à travailler dans la foulée. De
plus, Linux vous permet d'avoir plusieurs sessions : c'est comme si on
travaillait sur plusieurs ordinateurs à la fois !


<itemize>

<item> Pour passer à la session 1...6 parmi les consoles
virtuelles, tapez &lt;ALT-F1&gt; ... &lt;ALT-F6&gt;

<item> Pour démarrer une nouvelle session dans la même console
virtuelle, sans quitter la session courante, tapez  <tt/su -
&lt;nomdelogin&gt;/. Par exemple :  <tt/su - root/. Cela peut être
utile pour effectuer une tâche que seul root peut accomplir, par
exemple.

<item> Pour clore une session, tapez <tt/exit/. S'il reste des jobs
arrêtés (cf. plus loin) vous en serez averti.

<item> Pour lancer un processus en arrière-plan, ajoutez une
éperluette &laquo;&amp;&raquo; à la fin de la ligne de commande :

<tscreen><verb>
$ nomduprog [-options] [arguments] [< entree] [> sortie] &
[1] 123
</verb></tscreen>

Le shell associe un numéro de job au processus (ex. : <tt/[1]/ ;
cf. plus loin), ainsi qu'un PID (<it/Process Identification
Number/<footnote>numéro d'identification du processus</footnote>) ;
123 dans notre exemple).

<item> Pour voir combien il y a de processus, tapez <tt/ps ax/. Cela
affichera la liste des processus qui tournent actuellement.

<item> Pour tuer (<em>terminate</em>) un processus, tapez <tt/kill
&lt;PID&gt;/. Vous pouvez être obligé de tuer un processus lorsque
vous ne savez pas comment le quitter proprement... &Agrave; moins
d'être root, il vous est impossible de tuer les processus d'autres
personnes. Quelquefois, un processus ne pourra être tué qu'en faisant
<tt/kill -SIGKILL &lt;PID&gt;/.

De plus, le shell vous permet d'arrêter ou de suspendre temporairement
un processus, de l'envoyer en arrière-plan ou de le remettre au
premier plan. Dans ce contexte, les processus sont appelés
&laquo;jobs&raquo;.

<item> Pour voir combien il y a de jobs, tapez <tt/jobs/. Dans ce cas,
les jobs sont identifiés par leur numéro de job, et non pas par leur
PID.

<item> Pour arrêter un processus qui tourne au premier plan, tapez
&lt;CTRL-C&gt; (cela peut ne pas marcher).

<item> Pour suspendre un processus qui tourne au premier plan, tapez
&lt;CTRL-Z&gt; (idem).

<item> Pour envoyer un processus suspendu en arrière-plan, tapez <tt/bg
&lt;%job&gt;/ (il devient alors un job).

<item> Pour amener un job au premier plan, tapez <tt/fg
&lt;%job&gt;/. Pour ramener au premier plan le dernier job envoyé en
arrière-plan, il suffit de taper <tt/fg/.

<item> Pour tuer un job, tapez <tt/kill &lt;%job&gt;/, où &lt;job&gt
peut être 1, 2, 3,...

</itemize>

&Agrave; l'aide de ces commandes, vous pouvez formater un disque,
compresser une flopée de fichiers, compiler un programme, et
décompresser et archiver le tout, tout cela en même temps, tout en
gardant la main. Essayez-donc de faire cela avec Windows, rien que pour
voir la différence de performance (si ça ne plante pas, bien sûr).

<sect1> Exécution de programmes sur des ordinateurs distants

<p>

Pour lancer un programme sur une machine distante dont le nom est
<tt/machine.distante.edu/, il suffit de faire : 



<tscreen><verb>
$ telnet machine.distante.edu
</verb></tscreen>

Après vous être connecté, démarrez votre programme préféré. Cela va
sans dire, vous devez avoir un compte utilisateur sur la machine
distante. 

Si vous disposez de X11, il vous est même possible de faire tourner une
application X sur une machine distante dont l'affichage se fera sur
votre écran X. Soit <tt/machine.distante.edu/ la machine distante
disposant de X, et <tt/machine.locale.linux/ votre machine Linux. Pour
faire tourner à partir de <tt/machine.locale.linux/ une application X
résidant sur <tt/machine.distante.edu/, il faut faire ce qui suit : 

<itemize>

<item> démarrez X11, lancez un émulateur de terminal comme <tt/xterm/
ou ses équivalents, et tapez :

<tscreen><verb>
$ xhost +machine.distante.edu
$ telnet machine.distante.edu
</verb></tscreen>

<item> après vous être connecté, tapez :

<tscreen><verb>
remote:$ DISPLAY=machine.locale.linux:0.0
remote:$ nomduprogramme &
</verb></tscreen>

(au lieu de <tt/DISPLAY.../, il se peut que vous ayez à taper
<tt/setenv DISPLAY  machine.locale.linux:0.0/. Cela dépend du shell
distant.) 

</itemize>

<it/Et voila/ !  <tt/nomduprogramme/ va maintenant démarrer sur
<tt/machine.distante.edu/ et ses affichages se feront sur votre
machine. Toutefois, il est inutile d'essayer de le faire par modem, ce
serait trop lent pour être utilisable. De plus il s'agit d'une méthode
fruste et non sécurisée : veuillez vous reporter au «Remote X Apps
mini-HOWTO» disponible à l'adresse  <url
url="http://sunsite.unc.edu/LDP/HOWTO/mini/Remote-X-Apps">.

<sect> Utilisation des répertoires <label id="Directories">

<p>

<sect1> Répertoires : notions préliminaires

<p>

Nous avons déjà vu les différences entre les fichiers sous DOSWin et
Linux. Pour ce qui est des répertoires, sous DOSWin, le répertoire racine
est <tt/&bsol;/, sous Linux c'est <tt>/</tt>. De même, les
répertoires imbriqués sont séparés par <tt/&bsol;/ sous DOSWin, et par
<tt>/</tt> sous Linux. Un exemple de chemin d'accès :

<tscreen><verb>
DOS:     C:\ARTICLES\GEOLOGIE\MI_EOC.TEX
Linux:   /home/guide/articles/geologie/mi_eocene.tex
</verb></tscreen>

Comme d'habitude, <tt/../ est le répertoire parent et <tt/./ est le
répertoire courant. Rappelez-vous que le système ne vous autorisera
pas à faire des <tt/cd/, <tt/rd/ ou des <tt/md/ n'importe où à votre
convenance. Chaque utilisateur place ses affaires dans son propre
répertoire appelé répertoire d'accueil (<it/home directory/), attribué
par l'administrateur système ; par exemple mon répertoire d'accueil est
<tt>/home/guido</tt>.

<sect1> Droits d'accès aux répertoires <label id="Directories Permissions">

<p>

Les répertoires ont également des droits d'accès. Ce que nous avons vu
dans la section <ref id="Permissions" name="Droits d'accès et propriété">
(propriétaire, groupe et autres), s'applique également aux répertoires.
Pour un répertoire, <tt/rx/ signifie que vous pouvez vous rendre dans
ce répertoire à l'aide de <tt/cd/, et <tt/w/ que vous pouvez effacer
un fichier de ce répertoire, ou le répertoire lui-même.

Par exemple, pour empêcher d'autres utilisateurs de venir fouiner dans
<tt>/home/guido/text</tt> :

<tscreen><verb>
$ chmod o-rwx /home/guido/text
</verb></tscreen>


<sect1> Répertoires: traduction de commandes <label id="Directories: Trans">

<p>

<tscreen><verb>
DIR:            ls, find, du
CD:             cd, pwd
MD:             mkdir
RD:             rmdir
DELTREE:        rm -rf
MOVE:           mv
</verb></tscreen>

<sect2> Exemples

<p>

<tscreen><verb>
DOS                                     Linux
---------------------------------------------------------------------

C:\GUIDO>DIR                            $ ls
C:\GUIDO>DIR  FIC.TXT                   $ ls fic.txt
C:\GUIDO>DIR *.H *.C                    $ ls *.h *.c
C:\GUIDO>DIR/P                          $ ls | more
C:\GUIDO>DIR/A                          $ ls -l
C:\GUIDO>DIR *.TMP /S                   $ find / -name "*.tmp"
C:\GUIDO>CD                             $ pwd
        inapplicable, cf. notes         $ cd
        idem                            $ cd  
        idem                            $ cd  /temp
C:\GUIDO>CD \AUTRES                     $ cd /autres
C:\GUIDO>CD ..\TEMP\CORBEIL             $ cd ../temp/corbeille
C:\GUIDO>MD PROGSNVX                    $ mkdir progsnvx
C:\GUIDO>MOVE PROG ..                   $ mv prog ..
C:\GUIDO>MD \PROGS\TURBO                $ mkdir /progs/turbo
C:\GUIDO>DELTREE TEMP\CORBEIL           $ rm -rf temp/corbeille
C:\GUIDO>RD PROGSNVX                    $ rmdir progsnvx
C:\GUIDO>RD \PROGS\TURBO                $ rmdir /progs/turbo
</verb></tscreen>

Notes : 

<itemize>

<item> L'utilisation de <tt/rmdir/ ne peut se faire que sur des
répertoires vides. Pour effacer un répertoire et tout son contenu,
utilisez <tt/rm -rf/ (à vos risques et périls).

<item> Le caractère &laquo;<tt/&tilde;/&raquo; est un raccourci pour
le nom de votre répertoire d'accueil. Les commandes <tt/cd/ ou <tt/cd
 / vous emmèneront dans votre répertoire d'accueil, quel que soit
l'endroit où vous êtes ; la commande <tt>cd  /tmp/</tt> vous emmènera
dans <tt>/home/votre_rep_d_accueil/tmp</tt>.

<item> <tt/cd -/ &laquo;défait&raquo; le dernier <tt/cd/.

</itemize>


<sect> Disquettes, disques durs et consorts <label id="Floppies">

<p>

Il existe deux manières de gérer les périphériques sous Linux : à la
manière du DOS, ou à celle d'UNIX. Faites votre choix.

<sect1> Gestion des périphériques &laquo;à la DOS&raquo;

<p>

La plupart des distributions Linux sont accompagnées de la suite
Mtools, un ensemble de commandes parfaitement équivalentes à leurs
correspondants DOS, mais commençant par un &laquo;m&raquo; :
<tt/mformat/, <tt/mdir/, <tt/mdel/, <tt/mmd/, etc. Ils sont même
capables de conserver les noms de fichiers longs, mais pas les droits
d'accès aux fichiers. En configurant Mtools, par l'édition d'un
fichier appelé <file>/etc/mtools.conf</file> (dont un exemple est
fourni), vous pouvez également accéder à la partition DOS/Windows, aux
lecteurs de CD--ROM et de Zip. Toutefois, pour formater une disquette,
la commande <tt/format/ ne fait pas l'affaire. Il vous faudra
préalablement exécuter, en tant que root, la commande :
<tt>fdformat /dev/fd0H1440</tt>

Note : il ne vous est pas possible d'accéder aux fichiers d'une
disquette avec une commande de type <tt>less a:fic.txt</tt>! C'est
l'inconvénient d'accéder aux disques à la manière du DOS.

<sect1> Gestion des périphériques &laquo; à la UNIX&raquo;

<p>

UNIX aborde la gestion des périphériques d'une manière totalement
différente. Il n'existe pas de volumes comme A: ou C: ; un disque, que
ce soit une disquette ou n'importe quoi d'autre, devient une partie du
système de fichiers local par une opération que l'on appelle le
&laquo;montage&raquo;. Lorsque vous n'avez plus besoin du disque,
avant de l'éjecter il vous faut le &laquo;démonter&raquo;.

Le formatage physique d'un disque est une chose, y créer un système
de fichiers en est une autre. La commande DOS <tt/FORMAT A:/ fait les
deux à la fois, mais Linux fournit des commandes séparées. Pour
formater une disquette, voyez ci-dessus ; pour y créer un système de
fichiers :

<tscreen><verb>
# mkfs -t ext2 -c /dev/fd0H1440
</verb></tscreen>

Vous pouvez utiliser <tt/dos/, <tt/vfat/ (ce qui est conseillé) ou d'autres
formats à la place de <tt/ext2/. Une fois le disque préparé, montez-le
avec la commande : 

<tscreen><verb>
# mount -t ext2 /dev/fd0 /mnt
</verb></tscreen>

en spécifiant le type adapté pour le système de fichiers si vous
n'utilisez pas <tt/ext2/. &Agrave; présent, vous pouvez accéder aux
fichiers de la disquette à l'aide de <tt>/mnt</tt> au lieu de A: ou
B:. Quelques exemples :

<tscreen><verb>
DOS                                     Linux
---------------------------------------------------------------------

C:\GUIDO>DIR A:                         $ ls /mnt
C:\GUIDO>COPY A:*.*                     $ cp /mnt/* .
C:\GUIDO>COPY *.ZIP A:                  $ cp *.zip /mnt
C:\GUIDO>EDIT A:FIC.TXT                 $ jstar /mnt/fic.txt
C:\GUIDO>A:                             $ cd /mnt
A:> _                                   /mnt/$ _
</verb></tscreen>

Lorsque vous avez terminé, et avant d'éjecter la disquette, vous
<em/devez/ la démonter avec la commande :

<tscreen><verb>
# umount /mnt
</verb></tscreen>

Bien évidemment, vous ne devez utiliser <tt/fdformat/ et <tt/mkfs/
qu'avec des disquettes non-formatées, et non pas avec celles déjà
utilisées. Si vous voulez utiliser le lecteur B:, faites référence à
<tt/fd1H1440/ et <tt/fd1/ au lieu de <tt/fd0H1440/ et <tt/fd0/ dans
les exemples ci-dessus.

Il va sans dire que ce qui s'applique aux disquettes s'applique
également à d'autres périphériques ; par exemple, vous pouvez avoir
envie de monter un autre disque dur ou un lecteur de CD--ROM. Voici
comment monter le CD--ROM :

<tscreen><verb>
# mount -t iso9660 /dev/cdrom /mnt
</verb></tscreen>

Ce qui précède était la manière &laquo;officielle&raquo; de monter les
disques, mais il y a une astuce. Comme c'est assez pénible de passer
root pour monter un disque ou un CD--ROM, chaque utilisateur peut être
autorisé à les monter de la façon suivante :
<itemize>

<item> sous root, faites ce qui suit :

<tscreen><verb>
# mkdir /mnt/floppy ; mkdir /mnt/cdrom
# chmod 777 /mnt/floppy /mnt/cd*
# # assurez-vous que le peripherique correspondant au CD-ROM est correct
# chmod 666 /dev/hdb ; chmod 666 /dev/fd*
</verb></tscreen>

<item> ajoutez les lignes suivantes à <file>/etc/fstab</file> :

<tscreen><verb>
/dev/cdrom      /mnt/cdrom  iso9660 ro,user,noauto          0       0
/dev/fd0        /mnt/floppy vfat    user,noauto             0       0
</verb></tscreen>

</itemize>

&Agrave; présent, pour monter un disquette DOS et un CD--ROM vous
pouvez faire :

<tscreen><verb>
$ mount /mnt/floppy
$ mount /mnt/cdrom
</verb></tscreen>



<file>/mnt/floppy</file>, et <file>/mnt/cdrom</file>
sont à présent accessibles à tous les utilisateurs. Souvenez-vous que
d'autoriser tout le monde à monter des disques de cette
manière est un trou de sécurité béant, si cela vous préoccupe.

Deux commandes utiles sont <tt/df/, qui donne des informations sur les
systèmes de fichiers montés, et <tt/du nomderepertoire/ qui renseigne
sur l'espace disque utilisé par le répertoire.

<sect1> Les sauvegardes <label id="Backing Up">

<p>

Il existe plusieurs paquetages pour vous aider, mais le moins que vous
puissiez faire pour obtenir une sauvegarde sur plusieurs volumes est
(sous root) :

<tscreen><verb>
# tar -M -cvf /dev/fd0H1440 rep_a_sauvegarder/
</verb></tscreen>

Assurez-vous d'avoir une disquette formatée dans le lecteur, et un
paquet d'autres sous la main.
Pour restaurer vos affaires, insérez la première disquette dans le
lecteur et faites :

<tscreen><verb>
# tar -M -xpvf /dev/fd0H1440
</verb></tscreen>


<sect> Et Windows alors ?

<p>

Le système X Window est &laquo;l'équivalent&raquo; de
Windows. &Agrave; l'opposé de Windows ou du Mac, X11 n'a pas été conçu
pour être facile d'utilisation ni esthétique, mais uniquement pour
munir les stations de travail sous UNIX de capacités
graphiques<footnote>NdT. : Et surtout de la possibilité de déporter
l'affichage sur d'autres machines au travers du
réseau</footnote>. Voici les principales différences :

<itemize>

<item> Alors que Windows adopte le même <it/look and feel/ partout
dans le monde, ce n'est pas la cas pour X11 qui est beaucoup plus
configurable. Son apparence générale est définie par un composant-clé
appelé le &laquo;gestionnaire de fenêtres&raquo; (<it/window
manager/) dont il existe une large gamme : <tt/fvwm/, élémentaire mais
agréable et peu gourmand en mémoire, <tt/fvwm2-95/, <tt/Afterstep/,
<tt/WindowMaker/, <tt/Enlightenment/  et
beaucoup d'autres. Ce gestionnaire est habituellement invoqué dans un
fichier nommé <tt/.xinitrc/.

<item> Votre gestionnaire peut être configuré de manière à ce que les
fenêtres agissent comme dans, hum, Windows : vous cliquez dessus pour
les faire venir au premier plan. Une autre possibilité est de l'amener
au premier plan lorsque la souris se déplace dessus (la fenêtre
obtient le &laquo;focus&raquo;). De plus, le placement des fenêtres
sur l'écran peut être automatique ou interactif : si, au lieu de votre
programme, il apparaît un cadre étrange, cliquez avec le bouton gauche
à l'endroit où vous voulez le faire apparaître.

<item> la plupart des fonctionnalités peuvent être personnalisées en éditant un
ou plusieurs fichiers de configuration. Lisez la documentation de
votre gestionnaire de fenêtres ; ces fichiers de configuration peuvent
être <tt/.fvwmrc/, <tt/.fvwm2rc95/, <tt/.steprc/, etc. Un fichier de
configuration type se trouve généralement dans : 
<file>/etc/X11/window-manager-name/system.window-manager-name</file>;

<item> Les applications X11 sont écrites à l'aide de bibliothèques
spéciales (les &laquo;widget sets&raquo;) ; comme il en existe
plusieurs, les applications ont des apparences différentes. Les plus
élémentaires sont celles utilisant les widgets Athena (apparence 2--D;
<tt/xdvi/, <tt/xman/, <tt/xcalc/) ; d'autres utilisent Motif
(<tt/netscape/), d'autres encore utilisent Tcl/Tk, XForms, Qt, Gtk et
en veux-tu en voilà. Presque toutes ces bibliothèques fournissent en
gros le même look & feel que Windows.

<item> Malheureusement, le mode d'interaction peut se révéler
incohérent. En l'espèce, lorsque vous sélectionnez une ligne de texte
à la souris et tapez &lt;BACKSPACE&gt;, vous vous attendez à ce que la
ligne disparaisse, pas vrai ? Cela ne fonctionne pas avec les applis
basées sur Athena, mais avec celles utilisant d'autres bibliothèques
de widgets.

<item> Le mode de fonctionnement des ascenseurs (<it/scrollbars/) et
le redimensionnement dépendent du gestionnaire de fenêtres et du
widget set. Astuce : si les ascenseurs ne se comportent pas à votre
goût, essayez d'utiliser le bouton du milieu, ou les deux boutons en
même temps pour les déplacer.

<item> Les applications n'ont pas d'icône par défaut, mais elles
peuvent en avoir un certain nombre. La plupart des gestionnaires de
fenêtres proposent un menu que l'on appelle en cliquant sur le fond de
l'écran (<it/root window/) ; il va sans dire que ce menu peut être
personnalisé. Pour changer l'apparence du fond de l'écran, utilisez
<tt/xsetroot/ ou <tt/xloadimage/.

<item> Le presse-papiers ne peut contenir que du texte, et se comporte
étrangement. Une fois un texte sélectionné, il est déjà copié dans le
presse-papiers : déplacez vous ailleurs et cliquez sur le bouton du
milieu pour le coller. Il existe une application <tt/xclipboard/
fournissant de multiples tampons pour le presse-papiers.

<item> Le glisser-déplacer est une option, et n'est disponible qu'avec
les applications et/ou les gestionnaires de fenêtres qui l'intègrent.

</itemize>

Pour économiser la mémoire, il est préférable d'utiliser des
applications utilisant les mêmes bibliothèques, mais cela peut se
révéler difficile à appliquer.

Il existe des projets visant à doter X11 d'une apparence et d'un
comportement aussi cohérents que Windows. Gnome, <url
url="http://www.gnome.org"> et KDE, <url url="http://www.kde.org">,
sont épatants. Donnez-leur une chance : vous ne regretterez plus
votre bureau Windows.

<sect> Personnalisation du système

<p>

<sect1> Fichiers d'initialisation du système <label id="System Initialisation">

<p>

Sous DOS, deux fichiers importants sont <tt/AUTOEXEC.BAT/ et
<tt/CONFIG.SYS/, utilisés lors du démarrage pour initialiser le
système, positionner quelques variables d'environnement comme PATH et
FILES, et, le cas échéant lancer un programme ou un fichier de
commandes. Sous Linux, il y a une flopée de fichiers d'initialisation,
qu'il vaut mieux ne pas bidouiller pour certains d'entre eux à moins
de savoir exactement ce que vous faites. Je vous dirai quels sont les
plus importants de toute façon :

<tscreen><verb>
FICHIERS                           	NOTES

/etc/inittab                    	pas touche pour le moment !
/etc/rc.d/*                     	idem
</verb></tscreen>

Si vous vous contentez de positionner le PATH et d'autres
variables d'environnement, ou désirez changer les messages de login,
ou souhaitez lancer automatiquement un programme après vous être
connecté, considérez les fichiers suivants :

<tscreen><verb>
FICHIERS                           	NOTES

/etc/issue                      	positionne le message de pre-connexion
/etc/motd                       	positionne le message de post-connexion
/etc/profile                    	positionne $PATH, d'autres variables etc.
/etc/bashrc                     	positionne alias et fonctions etc.
/home/votre_home/.bashrc   		positionne vos alias et fonctions
/home/votre_home/.bash_profile   ou 
/home/votre_home/.profile        	definit l'environnemement et lance vos programmes
</verb></tscreen>

Si ce dernier fichier existe (remarquez que c'est un fichier caché),
il sera lu après que vous vous soyez connecté et les commandes qu'il
contient seront exécutées.

Un exemple -- examinez ce fichier <tt/.bash_profile/:

<code>
# Je suis un commentaire
echo Environnement:
printenv | less   # equivalent de la commande SET sous DOS
alias d='ls -l'   # pour comprendre facilement ce qu'est un alias
alias up='cd ..'
echo "Je vous rappelle que le chemin est "$PATH
echo "Aujourd'hui nous sommes le `date`"  # utilise la sortie de la commande 'date'
echo "Bonjour, "$LOGNAME
# Ce qui suit est une "fonction" shell
ctgz() # Affiche le contenu d'une archive .tar.gz.
{
  for file in $*
  do
    gzip -dc ${file} | tar tf -
  done
}         
# fin du .profile
</code>

<tt/&dollar;PATH/ et <tt/&dollar;LOGNAME/, vous l'aurez deviné, sont
des variables d'environnement. Il s'en trouve beaucoup d'autres avec
lesquels on peut s'amuser ; LPM pour des applis comme <tt/less/ ou
<tt/bash/ par exemple.

Ajouter la ligne suivante à votre <file>/etc/profile</file> vous
fournira approximativement un équivalent de <tt>PROMPT $P$G</tt> :

<tscreen><verb>
export PS1="\w\\$ "
</verb></tscreen>

<sect1> Fichiers d'initialisation de programmes

<p>

Sous Linux, tout peut potentiellement être personnalisé pour convenir
à vos besoins. La plupart des programmes ont un ou plusieurs fichiers
d'initialisation que vous pouvez triturer, souvent appelés
<tt/.nomdeprogrammerc/ et situés dans votre répertoire d'accueil. Les
premiers que vous aurez envie de modifier sont :

<itemize>


<item> <tt/ .inputrc/ : utilisé par <tt/bash/ pour définir les touches
du clavier ;

<item> <tt/ .xinitrc/ : utilisé par  <tt/startx/ pour initaliser le
système X Window ;

<item> <tt/ .fvwmrc/ : utilisé par le gestionnaire de fenêtres <tt/fvwm/ ; 

<item> <tt/ .joerc, .jstarrc/ : utilisé par l'éditeur <tt/joe/ ;

<item> <tt/ .jedrc/ : utilisé par l'éditeur <tt/jed/ ;

<item> <tt/ .pinerc/ : utilisé par l'outil de traitement de courrier
électronique <tt/pine/ ;

<item> <tt/ .Xdefault/ : utilisé par de nombreux programmes X Window.

</itemize>

Pour tous ceux-ci et d'autres que vous rencontrerez tôt ou tard,
LPM. Au cas où, je vous signale l'existence du <it/Configuration
HOWTO/ disponible à l'adresse <tt> <url
url="http://sunsite.unc.edu/mdw/HOWTO/Config-HOWTO.html"> </tt>.

<sect> Le réseau : concepts

<p>

Non seulement la connexion au réseau par modem est disponible sous
Linux, mais elle est également plus stable et plus rapide. Ce dont il
s'agit, c'est &laquo;PPP&raquo;, le protocole employé pour se
connecter à l'Internet à l'aide de modems. Vous avez besoin d'un noyau
intégrant le support PPP et d'un outil pour composer les numéros et
établir la connexion.

Pour récupérer votre courrier chez votre fournisseur d'accès Internet
(<em>FAI</em>), vous aurez besoin d'un outil appelé
&laquo;récupérateur de mail&raquo; utilisant le protocole POP ;
lorsque le courrier est récupéré, tout se passera comme s'il avait été
livré directement sur votre babasse Linux. Vous utiliserez ensuite un
MUA (<em>Mail User Agent</em> ou agent utilisateur de courrier)
comme <tt>pine</tt>, <tt>mutt</tt>, <tt>elm</tt> ou l'un des nombreux
autres pour gérer votre courrier.

Alors que sous Windows, le programme de composition de numéros est
invoqué automatiquement au lancement d'une application Internet, sous
Linux, on procède dans l'autre sens : on compose d'abord le numéro,
puis on lance l'application. Un truc du nom de <tt>diald</tt> fournit
le comportement habituel. L'installation et la configuration d'un
réseau avec connexion par modem était habituellement l'une des choses
les plus difficiles à faire sous Linux, mais ce n'est plus le cas :
veuillez vous reporter au Configuration HOWTO.

Enfin, un mot du &laquo;Voisinage réseau&raquo; : il vous est possible
de faire croire aux machines Windows du réseau local que votre station
Linux est un serveur Windows NT/9x. La formule magique est Samba : il
ne s'agit pas de la danse brésilienne endiablée, mais d'une
implémentation du protocole SMB pour Linux. Rendez-vous à <url url="http://samba.anu.edu.au/samba">.

<sect> Un peu de programmation

<p>

<sect1> Les <it/shell-scripts/ : des fichiers .BAT dopés aux anabolisants <label id="Shell Scripts">

<p>

Si vous utilisiez des fichiers .BAT pour créer des raccourcis pour de
longues lignes de commandes (moi-même j'en ai fait pas mal), vous
pouvez atteindre ce but en insérant des lignes d'<it/alias/ appropriés
(cf. l'exemple ci-dessus) dans le <tt/profile/ ou le
<tt/.bash_profile/. Mais si vos .BAT étaient plus compliqués, alors
vous adorerez le langage de <it/script/ que vous offre le <it/shell/ :
il est aussi puissant que ce bon vieux QBasic, si ce n'est plus. Il
possède des variables, des structures comme <tt/while, for, case,
if... then... else/ et des tas d'autres fonctionnalités : il peut être
une bonne alternative à un &laquo;vrai&raquo; langage de
programmation.

Pour écrire un script -- l'équivalent d'un fichier .BAT sous DOS -- tout
ce que vous avez à faire c'est d'écrire un fichier ASCII contenant les
instructions, de le sauver, et de le rendre exécutable à l'aide de la
commande <tt/chmod +x &lt;fichierscript>/. Pour l'exécuter, tapez son nom.

Un mot d'avertissement. L'éditeur du système s'appelle <tt/vi/, et,
d'après mon expérience, la plupart des nouveaux utilisateurs le
trouvent très ardu. Je ne m'étendrai pas sur son utilisation, veuillez
consulter le livre de Matt Welsh ou faire une recherche sur le Net. Je
me contenterai de dire que :

<itemize>
<item> pour insérer du texte, tapez <tt>i</tt> puis votre texte ;
<item> pour effacer des caractères; tapez &lt;ESC&gt; puis
<tt>x</tt> ;
<item> pour quitter <tt/vi/ sans enregistrer, tapez &lt;ESC&gt; puis
<tt/:q!/ ;
<item> pour enregistrer et quitter, tapez &lt;ESC&gt; puis  <tt/:wq/.
</itemize>
Un bon éditeur pour débutants est <tt>joe</tt> : en le lançant avec la
commande <tt/jstar/, vous obtiendrez les mêmes raccourcis-clavier que
ceux de l'éditeur de DOSWin. <tt>jed</tt> en mode WordStar ou IDE est
même mieux. Veuillez consulter la section <ref id="Programs" name="Où
trouver les applications"> pour savoir où obtenir ces éditeurs.

L'écriture de scripts sous <tt/bash/ est un sujet tellement vaste
qu'il nécessite un livre en lui-même, et je ne creuserai pas le sujet
plus avant. Je me contenterai de vous donner un exemple de
shell-script duquel vous pourrez extraire quelques règles de base :

<code>
#!/bin/sh
# exemple.sh
# Je suis un commentaire.
# Ne changez pas la premiere ligne, elle doit se trouver a cet endroit.
echo "Ce systeme est : `uname -a`" # utilise la sortie de la commande
echo "Mon nom est $0" # variables predefinies
echo "Vous m'avez transmis les $# parametres suivants : "$*
echo "Le premier parametre est : "$1
echo -n "Quel est votre nom ? " ; read votre_nom
echo notez la difference : "salut $votre_nom" # citation avec "
echo notez la difference : 'salut $votre_nom' # citation avec '
REPS=0 ; FICS=0
for fic in `ls .` ; do
  if [ -d ${fic} ] ; then # si fic est un repertoire
    REPS=`expr $REPS + 1`  # REPS = REPS + 1
  elif [ -f ${fic} ] ; then
    FICS=`expr $FICS + 1`
  fi
  case ${fic} in
    *.gif|*jpg) echo "${fic}: image" ;;
    *.txt|*.tex) echo "${fic}: fichier texte" ;;
    *.c|*.f|*.for) echo "${fic}: fichier source" ;;
    *) echo "${fic}: fichier generique" ;;
  esac
done
echo "il y a ${REPS} repertoires et ${FICS} fichiers"
ls | grep "ZxY--!!!WKW"
if [ $? != 0 ] ; then # code de retour de la derniere commande
  echo "ZxY--!!!WKW introuvable"
fi
echo "ca suffit... tapez 'man bash' pour en savoir plus."
</code>


<sect1> &laquo;E-C-iez&raquo; par vous-même

<p>


Sous UNIX, le langage du système est le C, que vous l'aimiez ou
non. Des douzaines d'autres langages (Java, FORTRAN, Pascal, Lisp,
Basic, Perl, awk...) sont également disponibles.

En partant du principe que vous connaissez le C, voici quelques lignes
directrices pour ceux d'entre vous qui ont été trop gâtés par le Turbo
C++ ou l'un de ses cousins sous DOS. Le compilateur C de Linux
s'appelle <tt/gcc/ et n'est pourvu d'aucun des gadgets qui
accompagnent en général ses équivalents DOS : pas de IDE
(<it/Integrated Development Environment/ ou environnement de
développement intégré), ni d'aide en ligne ou de débogueur intégré
etc. Il s'agit juste d'un compilateur en ligne de commande brut de
décoffrage, très puissant et efficace. Pour compiler votre
<tt/hello.c/ de base, vous ferez :

<tscreen><verb>
$ gcc hello.c
</verb></tscreen>

ce qui créera un fichier exécutable appelé <tt/a.out/. Pour donner
un nom différent à l'exécutable, faites :

<tscreen><verb>
$ gcc -o hola hello.c
</verb></tscreen>

Pour intégrer une bibliothèque lors de l'édition de liens, ajoutez
l'option -l&lt;nomdebibli&gt;. Par exemple, pour intégrer la
bibliothèque mathématique :

<tscreen><verb>
$ gcc -o progmath progmath.c -lm
</verb></tscreen>

(L'option <tt>-l&lt;nomdebibli&gt;</tt> oblige <tt/gcc/ à intégrer la
bibliothèque <tt>/usr/lib/lib&lt;nomdebibli&gt;.so</tt>; ainsi,
<tt/-lm/ intègre <tt>/usr/lib/libm.so</tt>).

Jusque-là, tout va bien. Mais lorsque votre programme se compose de
plusieurs fichiers source, vous aurez besoin de l'utilitaire
<tt/make/. Supposons que vous ayez écrit un analyseur d'expresssions :
son fichier source s'appelle <tt/parser.c/ et il inclut (par
<tt/#include/) deux fichiers d'en-tête, <tt/parser.h/ et
<tt/xy.h/. Ensuite, vous souhaitez utiliser les routines de
<tt/parser.c/ dans un programme, disons <tt/calc.c/, qui à son tour
inclut <tt/parser.h/. Quel bazar ! Que faut-il faire pour compiler
<tt/calc.c/ ?

Vous devrez écrire un <tt/Makefile/, c'est ainsi qu'on l'appelle, qui
apprenne au compilateur quelles sont les dépendances entre fichiers
source et fichiers objet. Dans notre exemple :

<code>
# Voici Makefile, utilise pour compiler calc.c
# Appuyez sur <TAB> aux endroits indiques !

calc: calc.o parser.o
<TAB>gcc -o calc calc.o parser.o -lm
# calc depend de deux fichiers objet : calc.o et parser.o

calc.o: calc.c parser.h
<TAB>gcc -c calc.c
# calc.o depend de deux fichiers source

parser.o:  parser.c parser.h xy.h
<TAB>gcc -c parser.c
# parser.o depend de trois fichiers source

# fin du Makefile.
</code>

Enregistrez ce fichier sous le nom <tt/Makefile/ et faites <tt/make/
pour compiler votre programme ; une alternative est de l'enregistrer
sous <tt/calc.mak/ et de taper <tt/make -f calc.mak/, et, bien sûr,
LPM. Vous pouvez accéder à quelques aides sur les fonctions C, qui se
trouvent dans les pages du <tt/man/, à la section 3, par exemple,

<tscreen><verb>
$ man 3 printf
</verb></tscreen>

Pour déboguer vos programmes, utilisez <tt>gdb</tt>. Faites <tt>info
gdb</tt> pour apprendre à vous en servir.

De nombreuses bibliothèques sont disponibles ; les premières d'entre
elles qui vous seront utiles sont <tt/ncurses/ (effets en mode texte),
et <tt/svgalib/ (graphismes en mode console). Si vous vous sentez
assez enhardi pour aborder la programmation X11 (ce n'est pas si
difficile que cela), il existe des bibliothèques qui transforment
l'écriture de programmes X11 en une promenade de santé. Regardez donc
du côté de <url url="http://www.xnet.com/ blatura/linapp6.html"> en
n'oubliant pas que Gtk devient un standard Linux.

Beaucoup d'éditeurs peuvent faire office d'IDE ; <tt/emacs/ et
<tt/jed/, par exemple, sont capables de mettre en évidence la syntaxe,
faire de l'indentation automatique etc. Autrement, rapatriez le
paquetage <tt/rhide/ à partir de 
<url url="ftp://sunsite.unc.edu:/pub/Linux/devel/debuggers/">.
C'est un clone de l'IDE de Borland, et vous devriez l'apprécier.

<sect> Le 1&percnt; restant

<p>

En fait, il reste beaucoup plus que 1&percnt;...


<sect1> Utilisation de tar et gzip

<p>

Sous UNIX, il y a quelques applications très répandues pour
l'archivage et la compression de fichiers. <tt/tar/ sert à fabriquer
des archives -- comme <tt/PKZIP/ ou <tt>Winzip</tt> mais il ne fait
qu'archiver, sans compression. Pour fabriquer une nouvelle archive :

<tscreen><verb>
$ tar -cvf <nom_d_archive.tar> <fic> [fic...]
</verb></tscreen>

Pour extraire des fichiers d'une archive :

<tscreen><verb>
$ tar -xpvf <nom_d_archive.tar> [fic...]
</verb></tscreen>

Pour examiner le contenu d'une archive :

<tscreen><verb>
$ tar -tf <nom_d_archive.tar> | less
</verb></tscreen>

Vous pouvez compresser les fichiers à l'aide de <tt/compress/, mais
il est obsolète et ne devrait plus être utilisé, ou <tt/gzip/ :

<tscreen><verb>
$ compress <fic>
$ gzip <fic>
</verb></tscreen>

qui créent un fichier compressé portant l'extension <tt/.Z/
(<tt/compress/) ou <tt/.gz/ (<tt/gzip/). Ces programmes ne peuvent
compresser qu'un fichier à la fois. Pour décompresser :

<tscreen><verb>
$ compress -d <fic.Z>
$ gzip -d <fic.gz>
</verb></tscreen>

LPM.

Il existe également les utilitaires <tt/unarj/, <tt/zip/ et <tt/unzip/
(compatibles avec PK??ZIP). Les fichiers portant l'extension
<tt/.tar.gz/ ou <tt/.tgz/ (archivés avec <tt/tar/, puis compressés
avec <tt/gzip/) sont aussi communs dans le mode UNIX que les fichiers
.ZIP sous DOS. Voici comment examiner le contenu d'une archive au
format <tt/.tar.gz/ :

<tscreen><verb>
$ tar -ztf <fic.tar.gz> | less
</verb></tscreen>


<sect1> Installation d'applications <label id="Install">

<p>

Tout d'abord : l'installation de paquetages est le travail de root. La
plupart des applications Linux sont distribuées sous forme d'archives
<tt/.tar.gz/ qui contiennent typiquement un répertoire portant un nom
approprié où se trouvent tous les fichiers et/ou
sous-répertoires. Un bonne habitude est d'installer ces paquetages à
partir de <tt>/usr/local</tt> à l'aide de la commande :

<tscreen><verb>
# tar -zxf <archive.tar.gz>
</verb></tscreen>

puis de lire les fichiers README ou INSTALL. La plupart du temps,
l'application est distribuée sous forme de code source, que vous
devrez compiler pour créer les binaires ; en général, en vous
contentant de taper <tt/make/ puis <tt>make install</tt>. Si l'archive
contient un script <tt>configure</tt> lancez celui-ci d'abord. Bien
évidemment, vous devez avoir les compilateurs <tt/gcc/ ou <tt/g++/.

D'autres archives doivent être déballées à partir de <file>/</file> ;
c'est notamment le cas pour les archives <tt/.tgz/ de
Slackware. D'autres archives contiennent des fichiers mais pas de
sous-répertoires -- attention à ne pas mettre le souk ! Il faut
toujours examiner le contenu d'une archive avant de l'installer.

Debian et Red Hat ont leurs propres formats d'archives, respectivement
<tt/.deb/ et <tt/.rpm/. Ce dernier bénéficie d'une reconnaissance de
plus en plus large ; pour installer un paquetage <tt/rpm/, tapez :

<tscreen><verb>
# rpm -i paquetage.rpm
</verb></tscreen>


<sect1> Astuces indispensables 

<p>

<bf/Le défilement en arrière/ : l'appui sur &lt;SHIFT + PAG UP&gt; (la
touche grise) vous permet de remonter en arrière de quelques pages, en
fonction de la quantité de mémoire vidéo dont vous disposez.


<bf/Le nettoyage de l'écran/ : s'il vous arrive de faire <tt/more/ ou
<tt/cat/ sur un fichier binaire, votre écran peut se retrouver rempli
de caractères bizarres. Pour y remedier, tapez <tt/reset/ même si vous
n'y voyez plus rien, ou entrez cete séquence de caractères : <tt/echo
CTRL-V ESC c RETURN/. 

<bf/Le collage de texte/ : dans la console, voyez plus loin ; sous X,
cliquez et déplacez la souris en maintenant le bouton enfoncé pour
sélectionner le texte dans une fenêtre <tt/xterm/, puis cliquez avec
le bouton central (ou les deux boutons à la fois si vous avez une
souris à deux boutons) pour coller. Il existe également un
<tt/xclipboard/<footnote>NdT. : Presse-papiers sous X.</footnote> (qui
ne marche qu'avec du texte, hélas) ; ne vous laissez pas perturber par
son très long temps de réponse. 

<bf/L'utilisation de la souris/ : si vous avez installé <tt/gpm/, un
pilote de souris pour la console, alors vous pouvez cliquer et
déplacer la souris sans relâcher le bouton pour sélectionner du texte,
puis cliquer avec le bouton droit pour coller le texte
sélectionné. Cela marche d'une console virtuelle à l'autre.

<bf/Messages émis par le noyau/ : examinez <tt>/var/adm/messages</tt>,
ou <tt>/var/log/messages</tt> en étant root pour savoir ce que le
noyau a à vous dire, y compris les messages de démarrage. La commande
<tt/dmesg/ est également bien pratique.

<sect1>Où trouver les applications <label id="Programs">

<p>

Si vous vous demandez si vous pouvez ou non remplacer votre bonne
vieille application DOS/Win par un équivalent Linux, je vous propose de
parcourir les principaux &laquo;entrepôts&raquo; de logiciels pour
Linux : <url url="ftp://sunsite.unc.edu/pub/Linux">, <url
url="ftp://tsx-11.mit.edu/pub/linux">, et <url
url="ftp://ftp.funet.fi/pub/Linux">.  D'autres endroits idéaux pour
commencer sont la &laquo;Linux Applications and Utilities Page&raquo;
située à <url url="http://www.xnet.com/ blatura/linapps.shtml">, et la
page &laquo;officielle&raquo; de Linux à <url
url="http://www.linux.org">.

<sect1> Quelques trucs impossibles sous DOS

<p>

Linux peut faire tout un tas de choses qui étaient pénibles,
difficiles ou impossibles sous DOS/Win. Voici une petite liste qui
devrait vous ouvrir l'appétit :

<itemize>

<item> <tt/at/ vous permet de lancer des programmes à des heures spécifiques ;

<item> <tt/awk/ est un langages simple mais néanmoins puissant pour
manipuler des fichiers de données (mais pas seulement). Par exemple,
si <tt/data.dat/ est votre fichier contenant des données sur plusieurs
champs,

<tscreen><verb>
$ awk '$2   "abc" {print $1, "\t", $4}' data.dat
</verb></tscreen>

affiche tous les premiers et quatrièmes champs de chaque ligne de
<tt/data.dat/ dont le second champ contient &laquo;abc&raquo;.

<item> <tt/cron/ est utile pour effectuer des tâches de manière
périodique, à des dates et des heures spécifiques. Tapez <tt/man 5 crontab/.

<item> <tt/file &lt;nomdefichier&gt;/ vous indique le type de
<tt/nomdefichier/ (texte ASCII, exécutable, archive, etc.) ;

<item> <tt/find/ (cf. également la section <ref id="Directories:
Trans" name="Répertoires : traduction de commandes">) est l'une des
commandes les plus puissantes et les plus utiles. On l'utilise pour
trouver des fichiers répondant à certaines caractéristiques, et pour
effectuer des actions sur ceux-ci. L'utilisation de base de <tt/find/
est :


<tscreen><verb>
$ find <repertoire> <expression>
</verb></tscreen>

où  &lt;expression&gt; inclut les critères de recherche et les
actions. Exemples :

<tscreen><verb>
$ find . -type l -exec ls -l {} \;
</verb></tscreen>

trouve tous les fichiers qui sont des liens symboliques et montrent ce
sur quoi ils pointent ;

<tscreen><verb>
$ find / -name "*.old" -ok rm {} \;
</verb></tscreen>

trouve tous les fichiers correspondant au motif donné et les efface,
après vous avoir demandé confirmation ;

<tscreen><verb>
$ find . -perm +111
</verb></tscreen>

trouve tous les fichiers dont les droits d'accès sont 111 (exécutables) ;

<tscreen><verb>
$ find . -user root
</verb></tscreen>

trouve tous les fichiers appartenant à root. Il y a plein d'autres
possibilités -- LPM ;


<item> <tt/grep/ trouve des motifs de caractères dans des
fichiers. Par exemple, 

<tscreen><verb>
$ grep -l "geologie" *.tex
</verb></tscreen>

affiche tous les fichiers *.tex contenant le mot
&laquo;geologie&raquo;. La variante <tt/zgrep/ marche avec les fichiers
&laquo;gzippés&raquo;. LPM ;

<item> <bf/Les expressions régulières/ constituent un mécanisme
complexe mais fichtrement puissant pour effectuer des opérations de
recherche dans un texte. Par exemple, <tt>^a[^a-m]X{4,}txt$</tt>
correspond aux lignes commençant par un &laquo;a&raquo;, suivi d'un
autre caractère ne se trouvant pas dans l'intervalle a-m, suivi de de
4 ou plus &laquo;X&raquo; et finissant en &laquo;txt&raquo;. Les
expressions régulières sont utilisées avec des éditeurs avancés,
<tt>less</tt>, et de nombreuses autres applications. <tt>man grep</tt>
pour avoir une introduction ;

<item> <tt/script &lt;fichier_script&gt;/ envoie le contenu de l'écran
dans le fichier <tt/fichier_script/ jusqu'à ce que vous lanciez la
commande <tt/exit/. Utile pour le débogage ;

<item> <tt/sudo/ autorise les utilisateurs à effectuer certaines
tâches de root (par ex. : le formatage et le montage des disques.
LPM) ;

<item> <tt/uname -a/ vous renvoie de l'info sur votre système ;

<item> <tt/zcat/ et <tt/zless/ sont utiles pour parcourir et rediriger
des fichiers gzippés sans les décompresser. Par exemple :

<tscreen><verb>
$ zless fictexte.gz
$ zcat fictexte.gz | lpr
</verb></tscreen>

<item> les commandes suivantes tombent souvent à pic : <tt>bc, cal, chsh, cmp,
cut, fmt, head, hexdump, nl, passwd, printf, sort, split, strings, tac,
tail, tee, touch, uniq, w, wall, wc, whereis, write, xargs, znew.</tt> LPM.

</itemize>

<sect1> Entraînement à Unix sous DOS/Windows

<p>

Le croirez-vous ? Il existe de chouettes outils fournissant un
environnement de type UNIX sous DOS/Windows. L'un d'entre eux est la
suite Djgpp (<url url="http://www.delorie.com/djgpp">) pour DOS, alors
que Cygnus  (<url url="http://www.cygnus.com">) est un portage plus
complexe pour Win32. Les deux comprennent les mêmes outils de
développement et utilitaires GNU que sous Linux ; vous n'aurez
cependant ni la même stabilité ni les mêmes performances.

Si vous voulez avoir un avant-goût de Linux, essayez
Djgpp. Téléchargez et installez les fichiers suivants (au moment de la
rédaction de ce document, la version la plus récente est la
2.02) : <tt>djdev202.zip, bnu281b.zip, bsh1147b.zip, fil316b.zip,
find41b.zip, grep22b.zip, gwk303b.zip, lss332b.zip,
shl112b.zip.</tt>. Les instructions pour l'installation sont fournies,
et vous obtiendrez de l'aide sur <url url="news:comp.os.msdos.djgpp">.

En particulier, l'utilisation de <tt>bash</tt> sous DOSWin constitue
une bouffée d'air frais. Pour le configurer correctement, éditez le
fichier <tt>BOOT.BAT</tt> fourni pour l'adapter à votre configuration,
mettez ensuite ces fichiers dans votre répertoire d'accueil (dans la
partition Windows) en remplacement de ceux qui sont fournis :

<tscreen><verb>
# voici le  _bashrc

LS_OPTIONS="-F -s --color=yes"
alias cp='cp -i'
alias d='ls -l'
alias l=less
alias ls="ls $LS_OPTIONS"
alias mv='mv -i'
alias rm='rm -i'
alias u='cd ..'
</verb></tscreen>
 
<tscreen><verb>
# voici le  _bprof
if [ -f  /_bashrc ]; then
  .  /_bashrc
fi
PS1='\w\$ '
PS2='> '
CDPATH="$CDPATH: "
# trucs pour less(1)
LESS="-M-Q"                     # invite longue, silencieuse
LESSEDIT="%E ?lt+%lt. %f"       # edition de la ligne superieure
VISUAL="jed"                    # editeur
LESSCHARSET=latin1              # visualisation des lettre accentuees
export PS1 PS2 CDPATH LS_OPTIONS LESS LESSEDIT LESSOPEN VISUAL LESSCHARSET
</verb></tscreen>

<sect1> Les extensions courantes et les programmes correspondants

<p>

Vous pouvez rencontrer d'innombrables extensions aux noms de
fichiers. En excluant les plus exotiques (en l'occurrence les polices
etc.), voici une liste de qui est qui :

<itemize>


<item> <tt/1 ... 8/ : les pages du manuel (<tt/man/). Lisez-les avec
<tt>groff -Tascii -man &lt;file.1&gt;</tt>.

<item> <tt/arj/ : archive fabriquée avec <tt/arj/.

<item> <tt/dvi/ : fichier de sortie produit par TeX
(cf. ci-dessous). <tt/xdvi/ permet de le visualiser et <tt/dvips/ le
transforme en fichier Postscript <tt/.ps/.

<item> <tt/gz/ : archive fabriquée avec <tt/gzip/.

<item> <tt/info/ : fichier info (espèce d'alternative aux pages
man). Récupérez <tt/info/.

<item> <tt/lsm/ : fichier Linux Software Map. Il s'agit d'un fichier
ASCII ordinaire contenant la description d'un paquetage.

<item> <tt/ps/ : fichier PostScript. Pour le visualiser, réupérez
<tt/gs/ et, optionnellement <tt/ghostview/ ou <tt/gv/.

<item> <tt/rpm/ : paquetage Red Hat. Il est possible de l'installer
sur n'importe quel système à l'aide du gestionnaire de paquetages <tt/rpm/.

<item> <tt/taz, tar.Z/ : archive fabriquée avec <tt/tar/ et compressée
avec <tt/compress/.

<item> <tt/tgz, tar.gz/ : archive fabriquée avec <tt/tar/ et
compressée avec <tt/gzip/.

<item> <tt/tex/ : fichier texte à fournir en entrée à TeX, un puissant
système de composition de documents. Récupérez le paquetage <tt/tex/
disponible pour de nombreuses distributions.

<item> <tt/texi/ : fichier texinfo, peut produire aussi bien des
fichiers TeX et des fichiers info (cf. <tt/info/). Récupérez <tt/texinfo/.

<item> <tt/xbm, xpm, xwd/ : fichiers graphiques.

<item> <tt/Z/ : archive fabriquée avec <tt/compress/.

</itemize>


<sect1> Conversion de fichiers

<p>

Si vous devez échanger des fichiers entre DOS/Windows et Linux,
méfiez-vous du problème des &laquo;sauts de ligne&raquo;. Sous DOS,
chaque ligne se termine par CR/LF (plus précisément, ASCII 13 +
ASCII 10), alors que Linux se contente de LF. Si vous essayez d'éditer
un fichier DOS sous Linux, il est probable que chaque ligne se termine
par un étrange caractère &laquo;M&raquo; ; un texte Linux apparaîtra
sous DOS comme une ligne unique extrêmement longue et aucun paragraphe
ne sera présent. Il existe quelques outils, <tt/dos2unix/ et
<tt/unix2dos/, pour convertir les fichiers.

Si vos fichiers texte contiennent des caractères accentués,
assurez-vous qu'ils ont été saisis sous Windows (avec Notepad) et non
sous DOS ; sinon tous les caractères accentués seront joyeusement
mélangés.



Pour convertir des fichiers Word ou WordPerfect vers des fichiers
texte pur, le sujet est un peu plus délicat mais c'est possible. Vous
aurez besoin de l'un des outils qui se trouvent sur les sites CTAN ;
l'un d'entre eux étant <url url="ftp://ftp.tex.ac.uk">. Récupérez le
paquetage <tt/word2x/ du répertoire <file>/pub/tex/tools/</file>, ou
essayez l'un des paquetages disponibles dans le répertoire
<file>/pub/tex/support/</file>. En particulier, <tt>word2x</tt>
convertit les fichiers Word 6, alors que pour Word 7, vous aurez
besoin de <tt>mswordview</tt> (<url 
url="http://www.csn.ul.ie/ caolan/docs/MSWordView.html">)  qui les
transforme en HTML. 

<sect1> Suites bureautiques gratuites

<p>

Si la conversion de fichiers ne suffit pas, vous avez le choix de vous
faire les dents sur un paquetage (gratuit !) du type Microsoft Office.

La suite StarOffice est gratuite pour une utilisation
personnelle. Elle est volumineuse, un peu lente, mais très bonne quoi
qu'il en soit : elle offre de nombreuses fonctionnalités absentes de
Microsoft Office. Elle est également capable de lire et d'écrire des
fichiers Word et Excel, bien que la conversion ne soit pas toujours
parfaite. Page Web : <url url="http://www.stardivision.com">.

Un autre paquetage de bonne qualité est Corel WordPerfect, dont une
édition gratuite est disponible en téléchargement. Dois-je en dire
plus ? Allez la récupérer sur : <url url="http://www.corel.com">.

<sect> La fin, du moins pour l'instant <label id="The End">

<p>

Félicitations ! &Agrave; présent, vous avez quelques notions d'UNIX et
êtes prêt pour commencer à travailler. Souvenez-vous que votre
connaissance du système est encore limitée, et qu'il est préférable
d'avoir un peu plus de pratique de Linux pour l'utiliser
confortablement. Mais si tout ce que vous aviez à faire était de
récupérer un paquet d'applications pour commencer à travailler, ce que
j'ai inclus dans ce document est suffisant.

Je suis persuadé qu'il vous plaira d'utiliser Linux et que vous
continuerez votre apprentissage -- comme tout le monde. Je prends
également le pari que vous ne retournerez plus jamais sous
DOSWin ! J'espère avoir été compréhensible et avoir rendu service
à mes 3 ou 4 lecteurs.

<sect1> Droits d'auteur

<p>

Sauf mentionné explicitement, les documents Linux HOWTO sont la
propriété de leurs auteurs respectifs. Les documents Linux HOWTO
peuvent être reproduits et distribués en totalité ou en partie, sur
n'importe quel support physique ou électronique, à condition que cette
note concernant les droits d'auteur soit présente sur toutes les
copies. La redistribution commerciale est autorisée et encouragée ;
cependant, l'auteur aimerait être tenu informé de toute distribution
de ce type.

Toute traduction, tous travaux dérivés ou toute compilation intégrant
des documents Linux HOWTO doivent être couverts par cette note
concernant les droits d'auteur. En l'occurrence, vous n'avez pas le
droit de produire un travail dérivé d'un HOWTO et d'imposer des
restrictions supplémentaires à sa distribution. Des exceptions à ces
règles peuvent être accordées sous certaines conditions ; veuillez
contacter le coordinateur des Linux HOWTO à l'adresse indiquée
ci-dessous. 

Bref, nous souhaitons promouvoir la dissémination de cette information
à travers le plus grand nombre possible de canaux. Néanmoins, nous
voulons conserver les droits d'auteur des documents HOWTO, et
aimerions être tenus au courant de tout projet de redistribution des HOWTOs.

Si vous avez des questions, veuillez contacter Tim Bynum, le
coordinateur des Linux HOWTO, par courrier électronique à l'adresse
<url url="linux-howto@sunsite.unc.edu">
via email.


<sect1> Responsabilités

<p>

Le &laquo;From DOS/Windows to Linux HOWTO&raquo; a été écrit par Guido
Gonzato, <url url="REMOVE_MEguido@ibogfs.cineca.it">. Un grand
merci à Matt Welsh, l'auteur de &laquo;Linux Installation and Getting
Started&raquo; à Ian Jackson, l'auteur de &laquo;Linux frequently
asked questions with answers&raquo;, à Guiseppe Zanetti, l'auteur de
&laquo;Linux&raquo; à toutes les personnes qui m'ont envoyé des
suggestions par courrier électronique, et des remerciements
particuliers à Linux Thorvalds et GNU qui nous ont apporté Linux.

Ce document est fourni &laquo;en l'état&raquo;. Je me suis efforcé de
le rédiger avec toute l'exactitude possible, mais l'utilisation que
vous faites de l'information qu'il contient est à vos risques et
périls. Je ne pourrai en aucun cas être tenu pour responsable de
dommages résultant de l'utilisation de ce travail.

Tout retour est le bienvenu. N'hésitez pas à me contacter pour toute
question, suggestion, critique incendiaire etc.

Profitez de la vie et de Linux,

Guido   <tt/=8-)/

</article>
