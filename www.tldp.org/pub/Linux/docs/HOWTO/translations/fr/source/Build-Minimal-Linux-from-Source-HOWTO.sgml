<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook V4.1//EN" [
<!ENTITY howto         "http://www.traduc.org/docs/HOWTO/lecture/">
<!ENTITY mini-howto    "http://www.traduc.org/docs/HOWTO/mini/lecture/">
]>

<article lang="fr">

<articleinfo>

<title>Construire un système Linux minimum à partir du code source</title>

<author>
      <firstname>Greg</firstname>
      <surname>O'Keefe</surname>
      <affiliation>
        <address>
          <email>gcokeefe@postoffice.utas.edu.au</email>
        </address>
      </affiliation>
</author>
<othercredit role="traduction">
    <firstname>Dominique</firstname>
    <surname>van den Broeck</surname>
    <affiliation>
      <jobtitle>Traduction française</jobtitle>
      <address><email>dvandenbroeck@free.fr</email></address>
    </affiliation>
    <contrib>Traduction française</contrib>
</othercredit>
<othercredit role="relecture">
    <firstname>Jean-Philippe</firstname>
    <surname>Guérard</surname>
    <affiliation>
      <jobtitle>Relecture de la version française</jobtitle>
      <address><email>jean-philippe.guerard@laposte.net</email></address>
    </affiliation>
    <contrib>Relecture de la version française</contrib>
</othercredit>

<pubdate>v0.9, novembre 2000</pubdate>

<abstract>

<para>
Voici les instructions pour construire un système Linux minimum à partir 
du code source. Ce document faisait partie du guide pratique 
&laquo;&nbsp;<ulink url="&howto;From-PowerUp-To-Bash-Prompt-HOWTO.html">De la mise 
sous tension à l'invite de commande de Bash</ulink>&nbsp;&raquo;, mais 
j'ai choisi d'en faire un document indépendant, afin que chacun de ces 2 
documents restent courts et concentrés. Le système que nous construisons 
ici est réduit au minimum et n'est pas apte à réaliser un vrai travail. 
Si vous voulez monter un vrai système, lisez plutôt le <ulink url="http://www.fr.linuxfromscratch.org/">Comment faire un
système Linux à partir de zéro</ulink> (<foreignphrase>Linux from 
scratch - LFS</foreignphrase>).
</para>

</abstract>

</articleinfo>

<sect1>
<title>Ce qu'il vous faut</title>

<para>
Nous installerons une distribution de Linux telle que Red Hat sur une 
partition, et l'utiliserons pour construire un nouveau système Linux sur 
une autre partition. Je nommerai par la suite 
&laquo;&nbsp;cible&nbsp;&raquo; le système que nous construisons, et 
&laquo;&nbsp;source&nbsp;&raquo; le système que nous utilisons pour 
construire le système cible (à ne pas confondre avec <emphasis>code 
source</emphasis> que nous utiliserons aussi).
</para>

<para>
Vous allez donc avoir besoin d'une machine avec deux partitions libres.
Si vous le pouvez, utilisez une machine qui ne contienne rien
d'important. Vous pouvez utiliser un système Linux déjà existant comme
système source, mais je le déconseille. Si vous oubliez un des paramètres
des commandes que nous allons saisir, vous pourriez accidentellement
réinstaller des choses sur votre système source. Cela peut mener à des
incompatibilités, et des conflits.
</para>

<para>
Les <acronym>BIOS</acronym> des PC dont l'architecture est ancienne, 
pour la plupart des 486 et des machines antérieures, ont une limitation 
ennuyeuse. Ils ne peuvent lire les disques durs au-delà des 512 premiers 
méga-octets. Ce n'est pas vraiment un problème pour Linux, qui gère 
lui-même les disques une fois lancé. Mais pour que Linux soit chargé sur 
ces vieilles machines, le noyau doit résider quelque part en-dessous de 
512 méga-octets. Si vous utilisez une de ces machines, vous devrez créer 
une partition distincte en-dessous de 512&nbsp;Mo, à monter sur 
<filename class="directory">/boot</filename> pour chaque système 
dont la partition racine se situe au-dessus de la limite des 
512&nbsp;Mo.
</para>

<para>
La dernière fois que je l'ai fait, j'ai utilisé Red Hat 6.1 comme système
source. J'ai installé le système de base plus&nbsp;:
</para>

<itemizedlist>

<listitem><para>
cpp
</para></listitem>

<listitem><para>
egcs
</para></listitem>

<listitem><para>
egcs-c++
</para></listitem>

<listitem><para>
patch
</para></listitem>

<listitem><para>
make
</para></listitem>

<listitem><para>
dev86 
</para></listitem>

<listitem><para>
ncurses-devel
</para></listitem>

<listitem><para>
glibc-devel 
</para></listitem>

<listitem><para>
kernel-headers 
</para></listitem>

</itemizedlist>

<para>
J'ai aussi installé X-Window et Mozilla pour pouvoir lire la 
documentation facilement, mais ce n'est pas vraiment nécessaire. À la 
fin de mon travail, celui-ci avait pris environ 350&nbsp;Mo d'espace 
disque (cela semble un peu élevé, je me demande pourquoi).
</para>

<para>
Le système cible achevé prenait 650&nbsp;Mo, mais comprenait tout le 
code source et les fichiers intermédiaires. Si l'espace est limité, je 
vous conseille de faire un <command>make clean</command> après la 
construction de chaque paquet. Cela dit, cette taille surprenante est un 
peu inquiétante.
</para>

<para>
<anchor id="downloads" xreflabel="téléchargements">
Enfin, vous allez avoir besoin du code source du système que vous allez
construire. Ce sont les paquets dont nous avons parlé dans le guide 
pratique &laquo;&nbsp;<ulink url="&howto;From-PowerUp-To-Bash-Prompt-HOWTO.html">De la mise sous 
tension à l'invite de commande de Bash</ulink>&nbsp;&raquo;. On peut les 
obtenir depuis un CD, ou par l'Internet. Je donnerai les url de 
leurs sites américains et des miroirs français.
</para>

<itemizedlist>

<listitem><para>
MAKEDEV&nbsp;: <ulink url="ftp://sunsite.unc.edu/pub/Linux/system/admin/"></ulink> (USA), 
<ulink url="ftp://ftp.lip6.fr/pub/linux/sunsite/system/admin/"></ulink> 
(France).
</para></listitem>

<listitem><para>
Lilo&nbsp;: <ulink url="ftp://lrcftp.epfl.ch/pub/linux/local/lilo/"></ulink> (Suisse),
<ulink url="ftp://ftp.lip6.fr/pub/linux/sunsite/system/boot/lilo/"></ulink> 
(France).
</para></listitem>

<listitem><para>
Noyau Linux&nbsp;: utilisez un des miroirs listés sur <ulink url="http://www.kernel.org"></ulink> plutôt que <ulink url="ftp://ftp.kernel.org/pub/linux/kernel/"></ulink> (USA)
car ils sont toujours en surcharge&nbsp;; <ulink url="ftp://ftp.fr.kernel.org/pub/linux/kernel/"></ulink> (France).
</para></listitem>

<listitem><para>
GNU libc&nbsp;: la bibliothèque elle-même, ainsi que les extensions 
linuxthreads sont sur <ulink url="ftp://ftp.gnu.org/pub/gnu/glibc/"></ulink> (USA), <ulink url="ftp://ftp.lip6.fr/pub/gnu/glibc/"></ulink> (France).
</para></listitem>

<listitem><para>
Extensions de la libc GNU&nbsp;: vous aurez aussi besoin des linuxthreads et 
des extensions libcrypt. Si libcrypt est absente du fait des lois 
américaines sur l'exportation, vous pouvez la récupérer sur <ulink url="ftp://ftp.gwdg.de/pub/gnu/glibc"></ulink> les extensions 
linuxthreads sont au même endroit que la libc proprement dite.
</para></listitem>

<listitem><para>
GNU ncurses&nbsp;: <ulink url="ftp://ftp.gnu.org/gnu/ncurses"></ulink> (USA),
<ulink url="ftp://ftp.lip6.fr/pub/gnu/ncurses"></ulink> (France).
</para></listitem>

<listitem><para>
SysVinit&nbsp;: <ulink url="ftp://sunsite.unc.edu/pub/Linux/system/daemons/init/"></ulink> 
(USA), <ulink url="ftp://ftp.lip6.fr/pub/linux/sunsite/system/daemons/init/"></ulink> 
(France).
</para></listitem>

<listitem><para>
GNU Bash&nbsp;: <ulink url="ftp://ftp.gnu.org/gnu/bash/"></ulink> (USA),
<ulink url="ftp://ftp.lip6.fr/pub/gnu/bash/"></ulink> (France).
</para></listitem>

<listitem><para>
GNU sh-utils&nbsp;: <ulink url="ftp://ftp.gnu.org/gnu/sh-utils/"></ulink> 
(USA), <ulink url="ftp://ftp.lip6.fr/pub/gnu/sh-utils/"></ulink> 
(France).
</para></listitem>

<listitem><para>
util-linux&nbsp;: <ulink url="ftp://ftp.win.tue.nl/pub/linux/utils/util-linux/"></ulink> 
(Pays-Bas), <ulink url="ftp://ftp.lip6.fr/pub/linux/sunsite/system/misc/"></ulink> 
(France). Ce paquet contient <systemitem>agetty</systemitem> et 
<systemitem>login</systemitem>.
</para></listitem>

</itemizedlist>

<para>
Pour résumer, il vous faut&nbsp;:
</para>

<itemizedlist>

<listitem><para>
Une machine avec deux partitions distinctes d'environ 400&nbsp;Mo et 
700&nbsp;Mo respectivement, bien que vous puissiez sûrement vous en 
tirer avec un espace plus restreint. 
</para></listitem>

<listitem><para>
Une distribution de Linux (par exemple, un CD Red Hat), et de quoi
l'installer (par exemple, un lecteur de CD).
</para></listitem>

<listitem><para>
Les archives tar de code source listées ci-dessus. (Le format tar permet 
de regrouper plusieurs fichiers en un seul. Un fichier tar peut être 
compressé.)
</para></listitem>

</itemizedlist>

<para>
Je pars du principe que vous pouvez installer le système source vous-même,
sans aide de ma part. À partir de maintenant, je considère que c'est 
fait.
</para>

<para>
Les premiers pas de ce projet consistent à faire démarrer le noyau, et 
à le laisser &laquo;&nbsp;paniquer&nbsp;&raquo; (panic) car il ne trouve 
pas le programme <systemitem>init</systemitem>.
Cela signifie que nous allons devoir installer un noyau, et installer Lilo.
Pour que Lilo s'installe facilement, nous aurons besoin des fichiers 
spéciaux du répertoire <filename class="directory">/dev</filename> du 
système cible. Lilo en a besoin pour effectuer les accès bas niveau au 
disque, nécessaire pour écrire le secteur d'amorçage. 
<command>MAKEDEV</command> est le script qui crée ces fichiers spéciaux 
(vous pourriez bien sûr les recopier depuis le système source, mais ce 
serait tricher&nbsp;!). Mais d'abord, il nous faut un système de 
fichiers dans lequel les mettre.
</para>

</sect1>

<sect1>
<title>Le système de fichier</title>

<para>
Notre nouveau système a besoin d'un système de fichiers pour vivre. 
Donc, il nous faut tout d'abord créer ce système de fichiers en 
utilisant <command>mke2fs</command>. Ensuite il faut le monter quelque 
part. Je vous suggère <filename class="directory">/mnt/cible</filename>. Dans ce qui va 
suivre, je considère que votre système cible se trouve à cet endroit. 
Vous pouvez gagner un peu de temps en ajoutant une entrée dans 
<filename>/etc/fstab</filename> de façon à ce que le montage de votre 
système de destination se fasse automatique lors du démarrage de votre 
système source.
</para>

<para>
Lorsque nous démarrerons le système cible, ce qui se trouve dans
<filename class="directory">/mnt/cible</filename> se trouvera alors dans 
<filename class="directory">/</filename> (la racine).
</para>

<para>
Nous avons besoin d'une structure de sous-répertoires sur la cible. Jetez un
&oelig;il au standard de hiérarchie des fichiers (<foreignphrase>File 
Hierarchy Standard - FHS</foreignphrase>, voir la section <xref 
linkend="liens">) pour trouver vous-même ce qu'elle devrait être, ou 
faites simplement un <command>cd</command> vers l'endroit où la cible 
est montée et tapez aveuglément&nbsp;:
</para>

<programlisting>
mkdir bin boot dev etc home lib mnt root sbin tmp usr var
cd var; mkdir lock log run spool  
cd ../usr; mkdir bin include lib local sbin share src
cd share/; mkdir man; cd man 
mkdir man1 man2 man3 man4 man5 man6 man7 man8 man9
</programlisting>

<para>
Comme le standard de hiérarchie des fichiers et la plupart des paquets 
se contredisent en ce qui concerne l'endroit où les pages de manuel 
doivent se trouver, nous avons besoin d'un lien symbolique&nbsp;:
</para>

<programlisting>
cd ..; ln -s share/man man
</programlisting>

</sect1>

<sect1>
<title>MAKEDEV</title>

<para>
Nous mettrons le code source dans le répertoire 
<filename class="directory">/usr/src</filename> cible. Ainsi si votre 
système de fichiers cible est monté sur <filename 
class="directory">/mnt/cible</filename>, et que vos archives tar sont 
dans <filename class="directory">/root</filename>, il faudra 
faire&nbsp;:
</para>

<programlisting>
cd /mnt/cible/usr/src
tar -xzvf /root/MAKEDEV-2.5.tar.gz
</programlisting>

<para>
Ne vous comportez pas en amateur fini en copiant les archives à 
l'endroit où vous allez les décompresser ;-)
</para>

<para>
En principe, lorsque vous installez un logiciel, vous l'installez sur le
système en fonctionnement. En l'occurrence, ce n'est pas notre intention,
nous souhaitons l'installer comme si /mnt/cible était la racine du 
système de fichiers. Les différents paquets ont différentes manières de 
vous laisser faire cela. Pour MAKEDEV, vous devez faire&nbsp;:
</para>

<programlisting>
ROOT=/mnt/cible make install
</programlisting>

<para>
Vous devez rechercher ces options dans les fichiers README et INSTALL
ou faire un <command>./configure --help</command>.
</para>

<para>
Explorez le <filename>Makefile</filename> de MAKEDEV pour voir l'usage 
qu'il fait de la variable <envar>ROOT</envar>, que nous avons définie 
dans cette commande. Ensuite jetez un &oelig;il à la page de manuel en 
faisant un <command>man ./MAKEDEV.man</command> pour voir comment il 
fonctionne. Vous découvrirez que la méthode que nous devons 
utiliser pour créer ces fichiers spéciaux consiste à faire un 
<command>cd /mnt/cible/dev</command> puis un <command>./MAKEDEV 
generic</command>. Faites un <command>ls</command> pour découvrir tous 
les merveilleux fichiers spéciaux qu'il a créé pour vous&nbsp;!
</para>

</sect1>

<sect1>
<title>Le noyau</title>

<para>
Ensuite, nous devons fabriquer un noyau. Je considère que vous l'avez déjà
fait, aussi serai-je bref. Il est plus facile d'installer Lilo si le noyau
censé être monté est déjà là. Retournez dans le répertoire <filename 
class="directory">usr/src</filename> de la cible, et extrayez-y les 
sources du noyau Linux. Entrez dans l'arborescence des sources 
(<command>cd linux</command>) et configurez le noyau, en utilisant votre 
méthode préférée, par exemple <command>make menuconfig</command>. Vous 
vous faciliterez grandement la vie si vous configurez un noyau sans 
module. Si vous choisissez d'avoir des modules, vous devrez éditer 
le fichier <filename>Makefile</filename>, trouver 
<literal>INSTALL&lowbar;MOD&lowbar;PATH</literal>, et lui affecter la 
valeur <filename class="directory">/mnt/cible</filename>.
</para>

<para>
Vous pouvez maintenant taper <command>make dep</command>, <command>make 
bzImage</command>, et si vous avez configuré des modules&nbsp;: 
<command>make modules</command>, <command>make 
modules&lowbar;install</command>. Copiez le noyau 
<filename>arch/i386/boot/bzImage</filename> et le plan système 
<filename>System.map</filename> vers le répertoire d'amorçage de la 
cible <filename class="directory">/mnt/cible/boot</filename>, et nous 
seront prêts à installer Lilo.
</para>

</sect1>

<sect1>
<title>Lilo</title>

<para>
Lilo est livré avec un script très bien conçu nommé 
<command>QuickInst</command>.
Décompressez les sources de Lilo dans le répertoire des sources du système
cible, lancez ce script par la commande
<command>ROOT=/mnt/cible ./QuickInst</command>. Il vous posera plusieurs questions
concernant la manière dont vous souhaitez que Lilo soit installé.
</para>

<para>
Puisque nous avons affecté à la variable <envar>ROOT</envar> la 
partition cible, les noms des fichiers que nous lui indiquons doivent 
être relatifs à cette partition. Donc, à la question du nom du noyau à 
lancer par défaut, répondez <filename>/boot/bzImage</filename>, et 
<emphasis>non</emphasis> <filename>/mnt/cible/boot/bzImage</filename>. 
</para>

<para>
J'ai trouvé une erreur mineure dans le script, qui lui fait dire&nbsp;:
</para>

<screen>
./QuickInst: /boot/bzImage: no such file 
</screen>

<para>
Mais si vous vous contentez de l'ignorer, cela passe quand même.
</para>

<para>
Comment doit-on s'y prendre pour expliquer à 
<command>QuickInst</command> où installer le secteur d'amorçage&nbsp;? 
Quand nous redémarrerons, nous voulons avoir le choix de démarrer le 
système source ou le système cible, ou encore n'importe quel autre 
système présent sur la machine. Et nous souhaitons que l'instance de
Lilo que nous mettons en place maintenant lance le noyau de notre nouveau
système. Comment réaliser ces deux choses&nbsp;? Écartons-nous un moment 
du sujet et étudions la façon dont Lilo démarre DOS sur un système Linux 
en double-amorçage. Le fichier <filename>lilo.conf</filename> d'un tel 
système doit sûrement ressembler à ça.
</para>

<programlisting>
prompt  
timeout = 50
default = linux

image = /boot/bzImage 
	label  = linux
	root   = /dev/hda1
	read-only

other = /dev/hda2
	label = dos
</programlisting>

<para>
Si la machine est configurée de cette façon, alors le bloc de 
démarrage (<foreignphrase>Master Boot Record - MBR</foreignphrase>) est 
lu et chargé par le Bios, et lance le chargeur d'amorçage de Lilo 
(<foreignphrase>bootloader</foreignphrase>), qui affiche une invite de 
commande. Si vous tapez <literal>dos</literal> à cette invite, Lilo 
chargera le secteur d'amorçage de hda2, qui lancera DOS.
</para>

<para>
Ce que nous allons faire est exactement la même chose, à une 
différence près&nbsp;: le secteur d'amorçage de hda2 sera un autre 
secteur d'amorçage Lilo&nbsp;- celui-là même que 
<command>QuickInst</command> va installer. Donc le Lilo de la 
distribution Linux chargera le Lilo que nous avons construit, 
qui chargera le noyau que nous avons bâti. Vous verrez alors deux 
invites Lilo au redémarrage.
</para>

<para>
Pour raccourcir une longue histoire, lorsque <command>QuickInst</command>
vous demande où placer le secteur de boot, indiquez-lui l'endroit où se
trouve votre système de fichiers cible, par exemple <filename>/dev/hda2</filename>.
</para>

<para>
Maintenant modifiez le fichier <filename>lilo.conf</filename> de votre système source,
de façon à ce qu'il comprenne une ligne ressemblant à&nbsp;:
</para>

<programlisting>
other = /dev/hda2
	label = cible
</programlisting>

<para>
Lancez <command>lilo</command>, et nous devrions être capables de faire 
notre premier démarrage sur le système cible.
</para>

</sect1>

<sect1>
<title>Glibc</title>

<para>
L'étape suivante consiste à installer <systemitem>init</systemitem>, mais comme la plupart
des programmes qui tournent sous Linux, <systemitem>init</systemitem> utilise des fonctions
issues de la bibliothèque standard C GNU, glibc. Aussi 
l'installerons-nous en premier.
</para>

<para>
Glibc est un paquet très gros et très complexe. Il faut 90 heures pour 
le construire sur mon vieux 386sx&nbsp;/&nbsp;16 avec 8&nbsp;Mo de 
mémoire. Mais cela ne prend que 33 minutes sur mon Celeron 433 avec 
64&nbsp;Mo de mémoire. Je pense que la quantité de mémoire est le 
principal critère dans notre cas. Si vous n'avez que 8&nbsp;Mo de 
mémoire (ou - j'en tremble - encore moins&nbsp;!), préparez vous à une 
très longue compilation.
</para>

<para>
La documentation d'installation de glibc recommande une construction dans un
répertoire distinct. Cela vous permettra de recommencer facilement, en
supprimant simplement ce répertoire. Cela vous permet aussi d'économiser
265&nbsp;Mo d'espace disque.
</para>

<para>
Comme d'habitude, décompressez l'archive 
<filename>glibc-2.1.3.tar.gz</filename> (ou n'importe quelle autre 
version) dans <filename class="directory">/mnt/cible/usr/src</filename>. 
À présent, nous devons décompresser les extensions dans le répertoire de 
glibc. Donc, faites un <command>cd glibc-2.1.3</command>, puis 
décompressez à cet endroit les archives 
<filename>glibc-crypt-2.1.3.tar.gz</filename> et 
<filename>glibc-linuxthreads-2.1.3.tar.gz</filename>.
</para>

<para>
Maintenant, nous pouvons créer le répertoire de construction, configurer,
construire et installer glibc. Voici les commandes que j'ai utilisées, 
mais relisez vous-même la documentation et assurez-vous de faire ce qui 
est le plus approprié dans votre environnement. Toutefois, avant de 
faire tout cela, vous voudrez sans doute connaître l'espace disque qu'il 
vous reste en faisant un <command>df</command>. Vous pourrez en faire un 
autre après avoir construit et installé glibc pour en déduire son 
volume.
</para>

<programlisting>
cd ..
mkdir glibc-build
../glibc-2.1.3/configure --enable-add-ons --prefix=/usr
make
make install_root=/mnt/cible install
</programlisting>

<para>
Remarquez que nous avons ici encore une autre façon de dire au paquet 
l'endroit où s'installer.
</para>

</sect1>

<sect1>
<title>SysVinit</title>

<para>
Fabriquer et installer les binaires de SysVinit est assez simple. Il y a 
juste une petit manipulation à faire dans le fichier 
<filename>Makefile</filename>, situé dans le sous-répertoire <filename class="directory">src/</filename>. Dans les 4 dernières lignes, vous 
devez placer <literal>$(ROOT)</literal> juste devant 
<literal>/dev/initctl</literal>. Par exemple&nbsp;:
</para>

<programlisting>
@ if [ ! -p /dev/initctl ]; then \
</programlisting>

<para>
devient&nbsp;:
</para>

<programlisting>
@ if [ ! -p <emphasis role="strong">$(ROOT)</emphasis>/dev/initctl ]; then \
</programlisting>

<para>
Le fichier spécial <filename>initctl</filename> est un moyen de 
communication avec init. Par exemple, la page de manuel d'init indique 
que ce fichier doit être utilisé de préférence au signal 
<symbol>SIGPWR</symbol> pour demander à init d'arrêter le système 
lorsque l'alimentation électrique à basculé sur batterie suite à une 
panne de courant. Cette manipulation permet de s'assurer que ce fichier 
se trouvera dans le système cible, et non dans le système source.
</para>

<para>
Une fois que c'est fait, placez-vous dans le sous-répertoire <filename class="directory">src</filename>, et entrez&nbsp;:
</para>

<programlisting>
make
ROOT=/mnt/cible make install
</programlisting>

<para>
Il existe aussi beaucoup de scripts associés à 
<systemitem>init</systemitem>. Il y a des scripts d'exemple fournis dans 
le paquet SysVinit, qui fonctionnent bien. Mais vous devez les installer 
manuellement. Ils sont rangés hiérarchiquement sous <filename 
class="directory">debian/etc</filename> dans l'arborescence du code 
source. Vous pouvez recopier toute cette hiérarchie dans le répertoire
<filename class="directory">etc</filename> du système cible, avec une 
commande du style <command>cd ../debian/etc; cp -r * 
/mnt/cible/etc</command>. Évidement, vous voudrez les examiner avant de 
les recopier.
</para>

<para>
Tout est désormais en place pour permettre au noyau cible de lancer
<systemitem>init</systemitem> au redémarrage. Le problème, cette fois, viendra des scripts
qui ne pourront être exécutés car <systemitem>bash</systemitem> ne sera pas là pour les
interpréter. <systemitem>init</systemitem> tentera également de lancer des <systemitem>getty</systemitem>,
qui sont eux aussi inexistants. Redémarrez le système, et assurez-vous 
que tout le reste fonctionne correctement.
</para>

</sect1>

<sect1>
<title>Ncurses</title>

<para>
L'étape suivante consiste à mettre Bash en place, mais bash a besoin de
ncurses, aussi devons-nous installer celui-ci en premier. Ncurses remplace
termcap dans la manière de gérer les écrans texte, mais apporte également
une compatibilité descendante en prenant en charge les appels termcap. 
Dans l'objectif d'avoir un système moderne, simple et propre, je pense 
que le mieux est de désactiver l'ancienne méthode termcap. Vous pourriez 
par la suite rencontrer des problèmes avec des applications utilisant 
termcap, mais au moins vous connaîtrez les éléments qui l'utilisent. Si 
vous en avez besoin, vous pourrez recompiler ncurses avec prise en 
charge de termcap.
</para>

<para>
Les commandes que j'ai utilisées sont&nbsp;:
</para>

<programlisting>
./configure --prefix=/usr --with-install-prefix=/mnt/cible --with-shared --disable-termcap
make
make install
</programlisting>

</sect1>

<sect1>
<title>Bash</title>

<para>
Il m'a fallu beaucoup de lecture, de réflexion, de tests, et d'erreurs pour
que Bash s'installe là où je pensais qu'il devait aller. Les options de
configuration que j'ai utilisées sont&nbsp;:
</para>

<programlisting>
./configure --prefix=/mnt/cible/usr/local --exec-prefix=/mnt/cible \
            --with-curses 
</programlisting>

<para>
Une fois que vous aurez construit et installé Bash, vous devrez créer un 
lien symbolique comme ceci&nbsp;: <command>cd /mnt/cible/bin; ln -s bash 
sh</command>. Cela est dû au fait que les scripts débutent généralement 
par une ligne comme celle-ci&nbsp;:
</para>

<programlisting>
#!/bin/sh
</programlisting>

<para>
Si vous n'avez ce lien symbolique, les scripts ne fonctionneront pas, car
ils chercheront <literal>/bin/sh</literal> et non <literal>/bin/bash</literal>. 
</para>

<para>
Arrivé à ce point, vous pouvez redémarrer si vous le souhaitez. Lors 
du redémarrage, vous devriez remarquer que, maintenant, les scripts 
s'exécutent. Cependant, vous ne pourrez pas vous connecter, car il n'y 
pas encore de programmes <systemitem>getty</systemitem> ou 
<systemitem>login</systemitem>.
</para>

</sect1>

<sect1>
<title>Util-linux (getty et login)</title>

<para>
Le paquet util-linux contient <systemitem>agetty</systemitem> et 
<systemitem>login</systemitem>. Nous avons besoin des deux pour 
pouvoir nous connecter et obtenir l'invite de commande de bash. Après 
l'avoir installé, faites un lien symbolique depuis 
<filename>agetty</filename> vers <filename>getty</filename> dans le 
répertoire <filename class="directory">/sbin</filename> du système 
cible. <systemitem>getty</systemitem> est un des programmes censés se 
trouver sur tous les systèmes de type Unix, donc faire un lien est une 
meilleure idée que de modifier <filename>inittab</filename> pour qu'il 
lance <systemitem>agetty</systemitem>.
</para>

<para>
Il me reste un problème avec la compilation d'util-linux. Le paquet
contient également le programme <literal>more</literal>, et, pour ce 
programme, je n'ai pas été capable de persuader <literal>make</literal> 
de réaliser l'édition de liens avec le ncurses 5 du système cible au 
lieu du ncurses 4 du système source.
</para>

<para>
Vous aurez aussi besoin d'un fichier <filename>/etc/passwd</filename> 
sur le système cible. C'est l'endroit où le programme 
<systemitem>login</systemitem> ira vérifier si vous avez le droit de 
vous connecter. Comme il ne s'agit que d'un système jouet, vous pouvez 
vous permettre à ce niveau des choses scandaleuses, comme de ne définir 
que l'utilisateur root, sans mot de passe&nbsp;! Mettez le simplement 
dans le fichier <filename>/etc/passwd</filename> du système cible&nbsp;:
</para>

<programlisting>
root::0:0:root:/root:/bin/bash
</programlisting>

<para>
Les champs sont séparés par des deux-points, et correspondent, de gauche 
à droite, à l'identifiant de l'utilisateur, à son mot de passe 
(chiffré), à son numéro d'utilisateur, à son numéro de groupe, à son nom 
complet, à son répertoire personnel, et à son interpréteur de 
commandes par défaut.
</para>

</sect1>

<sect1>
<title>Sh-utils</title>

<para>
Le dernier paquet dont nous ayons besoin est le sh-utils GNU. Le seul 
programme nécessaire à ce niveau est <literal>stty</literal>, qui est 
utilisé dans <filename class="directory">/etc/init.d/rc</filename>, 
lui-même utilisé pour changer de niveau d'exécution et entrer dans le 
niveau initial. En fait, je possède et ai utilisé un paquet qui ne 
contient que <literal>stty</literal> mais je ne peux me souvenir d'où
il vient. Il vaut mieux utiliser le paquet GNU, car il contient d'autres
choses dont vous aurez besoin si vous voulez les ajouter au système pour 
le rendre vraiment utilisable.
</para>

<para>
Bien, ça y est. Vous devriez maintenant avoir un système qui va 
démarrer et vous donner l'invite de connexion. Saisissez-y 
<literal>root</literal>, et vous devriez accéder à l'interpréteur 
de commandes. Vous ne pourrez pas faire grand chose avec, il n'y a même 
pas la commande <command>ls</command> pour voir votre travail. Tapez 
deux fois sur la touche <keycap>Tab</keycap> pour voir les commandes 
disponibles. C'est la chose la plus intéressante que j'ai trouvée à 
faire avec.
</para>

</sect1>

<sect1>
<title>Rendre le système plus utilisable</title>

<para>
Il semblerait que nous ayons là un système plutôt inutilisable. Mais en
réalité, nous ne sommes pas très loin de pouvoir commencer à
travailler avec. L'une des premières choses à faire est de rendre le
système de fichiers racine accessible en lecture et en écriture. Il y a 
un script issu du paquet SysVinit, 
<systemitem>/etc/init.d/mountall.sh</systemitem> qui s'occupe de cela, 
et effectue un <command>mount -a</command> pour monter automatiquement 
tout ce qui est spécifié dans le fichier 
<filename>/etc/fstab</filename>. Mettez un lien symbolique du genre 
<filename>S05mountall</filename> vers lui dans le répertoire <filename 
class="directory">etc/rc2.d</filename> du système cible.
</para>

<para>
Il se peut que ce script utilise des commandes que vous n'avez pas encore
installées. Si c'est le cas, trouvez le paquet qui contient ces commandes et
installez-le. Voyez la section <xref linkend="finding"> pour avoir des indications sur la marche à suivre pour 
trouver ces paquets.
</para>

<para>
Regardez les autres scripts de <filename 
class="directory">/etc/init.d</filename>. La plupart d'entre-eux doit 
être incluse dans tout système sérieux. Ajoutez-les un à un, et 
assurez-vous que tout se lance en douceur avant d'en ajouter d'autres.
</para>

<para>
Lisez le standard de hiérarchie des fichiers (voir section <xref 
linkend="liens">). Il contient une liste des commandes qui devraient 
être dans <filename class="directory">/bin</filename> et <filename 
class="directory">/sbin</filename>. Assurez-vous que toutes ces 
commandes sont installées sur votre système. Mieux encore, trouvez la 
documentation Posix qui spécifie tout cela.
</para>

<para>
À partir de maintenant, il n'est plus question que d'ajouter de plus en
plus de paquets, jusqu'à ce que tout ce que vous souhaitez avoir se 
trouve sur votre système. Installez les outils de construction comme 
<literal>make</literal> et <literal>gcc</literal> le plus tôt possible. 
Une fois que cela sera fait, vous pourrez faire construire le système 
cible par lui-même, ce qui est bien moins complexe.
</para>

</sect1>

<sect1>
<title>Informations complémentaires</title>

<sect2 id="finding" xreflabel="astuces diverses">
<title>Astuces diverses
</title>

<para>
Si vous avez une commande appelée <command>machin</command>
sur un système Linux avec RPM, et souhaitez avoir des indications sur
l'endroit où trouver les sources, vous pouvez utiliser la commande&nbsp;:
</para>

<programlisting>
rpm -qif `which machin`
</programlisting>

<para>
Et si vous avez un CD de sources Red Hat, vous pouvez installer le code
source avec
</para>

<programlisting>
rpm -i /mnt/cdrom/SRPMS/<replaceable>ce.qu.il.vient.de.dire-1.2.srpm</replaceable>
</programlisting>

<para>
Ceci mettra l'archive, avec les patches Redhats éventuels dans
<filename class="directory">/usr/src/redhat/SOURCES</filename>. 
</para>

</sect2>

<sect2 id="liens" xreflabel="liens">
<title>Liens</title>

<itemizedlist>

<listitem><para>
Il existe un guide pratique sur la manière de construire des logiciels à 
partir de leurs sources, le <ulink 
url="&howto;Software-Building-HOWTO.html">Software Building HOWTO</ulink>.
</para></listitem>

<listitem><para>
Il existe aussi un guide pratique sur la manière de construire un 
système Linux à partir de zéro. Il met l'accent sur la construction d'un 
système réellement utilisable, plutôt que d'être un simple 
exercice&nbsp;: <ulink url="http://www.fr.linuxfromscratch.org/">Comment 
faire un système Linux à partir de zéro</ulink> (<foreignphrase>Linux 
from scratch - LFS</foreignphrase>).
</para></listitem>

<listitem><para>
Le <ulink url="http://www.pathname.com/fhs/">standard de hiérarchie
du système de fichier Unix (FHS)</ulink>. Ce standard décrit quels 
éléments doivent aller à quels endroits dans un système de fichier Unix, 
et pourquoi. Il indique également le contenu minimum requis des 
répertoires <filename class="directory">/bin</filename>, <filename 
class="directory">/sbin</filename>, et cætera. C'est une bonne référence 
si votre but est de réaliser un système minimal, mais fonctionnel. Il 
en existe une <ulink url="http://ftp.traduc.org/documents/fhs/">version 
française</ulink>.
</para></listitem>

</itemizedlist>

</sect2>

</sect1>

<sect1>
<title>Section administrative</title>

<sect2>
<title>Copyright</title>

<para>
Copyright &copy;&nbsp;1999, 2000 Greg O'Keefe. Vous êtes libre de
l'utiliser, le copier, le distribuer ou le modifier, sans obligation, selon
les termes de la licence publique générale GNU (GPL&nbsp;: <ulink 
url="http://www.gnu.org/copyleft/gpl.html">GNU General Public 
Licence</ulink>). Merci de citer l'auteur si vous utilisez tout ou 
partie de ce document dans un autre.
</para>

</sect2>

<sect2>
<title>Page principale</title>

<para>
Les mises à jour de ce document évoluent sur <ulink url="http://www.netspace.net.au/~gok/power2bash/">From Powerup 
To Bash Prompt</ulink>.
</para>

</sect2>

<sect2>
<title>Réactions</title>

<para>
J'aimerais recevoir vos commentaires, critiques et suggestions. Veuillez
s'il vous plaît me les envoyer en anglais à Greg O'Keefe 
<email>gcokeefe@postoffice.utas.edu.au</email>
</para>

</sect2>

<sect2 id="acknowledge" xreflabel="remerciements">
<title>Références et remerciements
</title>

<para>
Les noms de produits cités sont des marques déposées par leurs
propriétaires respectifs, et considérés par cette note comme reconnus
comme tels.
</para>

<para>
Il y a quelques personnes que je voudrais remercier, pour m'avoir aidé à
réaliser tout ceci.
</para>

<para>
<variablelist>

<varlistentry>
<term>Michael Emery</term>
<listitem><para>
Pour m'avoir rappelé Unios.
</para></listitem>
</varlistentry>

<varlistentry>
<term>Tim Little</term>
<listitem><para>
Pour de bonnes indications concernant <filename>/etc/passwd</filename>
</para></listitem>
</varlistentry>

<varlistentry>
<term>sPaKr dans &num;linux sur efnet</term>
<listitem><para>
Qui a soupçonné l'utilisation de <filename>/etc/services</filename> par syslog,
et m'a fait connaître la phrase &laquo;&nbsp;rolling your own&nbsp;&raquo;
(&laquo;&nbsp;fabriquez votre propre système&nbsp;&raquo;) 
pour  décrire la construction d'un système à partir des sources.
</para></listitem>
</varlistentry>

<varlistentry>
<term>Alex Aitkin</term>
<listitem><para>
Pour avoir porté Vico et son &laquo;&nbsp;verum ipsum factum&nbsp;&raquo; 
(La compréhension découle de l'expérience) à mon attention.
</para></listitem>
</varlistentry>

<varlistentry>
<term>Dennis Scott</term>
<listitem><para>
Pour avoir corrigé mon arithmétique hexadécimale.
</para></listitem>
</varlistentry>
<varlistentry>
<term>jdd</term>
<listitem>
<para>
Pour avoir mis en évidence quelques erreurs typographiques.
</para></listitem>
</varlistentry>
</variablelist>
</para>

</sect2>

<sect2>
<title>Historique des changements</title>

<variablelist>

<varlistentry>
<term>0.8 -&gt; 0.9</term>
<listitem><para>
Ajout de la manipulation du fichier <filename>makefile</filename> de 
sysvinit. Cette information est due à Gerard Beekmans, connu pour le 
&laquo;&nbsp;Linux From Scratch&nbsp;&raquo;.
</para></listitem>
</varlistentry>

<varlistentry>
<term>0.8</term>
<listitem><para>
Version initiale. Séparation de ce HOWTO du &laquo;&nbsp;From 
PowerUp to Bash Prompt&nbsp;&raquo;.
</para></listitem>
</varlistentry>

</variablelist>

</sect2>

<sect2>
<title>Améliorations prévues</title>

<itemizedlist>

<listitem><para>
Conversion au format DocBook.
</para></listitem>

</itemizedlist>

</sect2>

<sect2 id="adaptation-francaise" xreflabel="adaptation française">
<title>Adaptation française</title>

<sect3>
<title>Traduction</title>

<para>
La traduction française de ce document a été réalisée par Dominique van 
den Broeck <email>dvandenbroeck@free.fr</email>, décembre 2000 (v0.9).
</para>
</sect3>

<sect3>
<title>Relecture</title>

<para>
La relecture de ce document a été réalisée par Jean-Philippe Guérard 
<email>jean-philippe.guerard@laposte.net</email>. Les version 
précédentes ont été relues par Guillaume Allègre et Anthony Boureux.
</para>
</sect3>

</sect2>

</sect1>

</article>
