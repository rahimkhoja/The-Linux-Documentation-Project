<!doctype linuxdoc system>

<article>

<!-- Xinerama Howto (MultiHead X) -->

<title>Utilisation de l'extension Xinerama pour le multi-écran avec XFree86 V.&nbsp;4.0+
<author>Dennis Baker <tt>&lt;drbaker at softhome dot net&gt;</tt>.<newline>
Traduction française de Xavier Serpaggi <tt>&lt;xavier dot serpaggi at free dot fr&gt;</tt>.
</author>
<date>Révision&nbsp;v2.0, 2&nbsp;Novembre 2000</date>

<abstract>
Ce document décrit comment configurer XFree86 version&nbsp;4.0 ou plus, pour
utiliser plusieurs moniteurs avec l'extension Xinerama.
</abstract>

<!-- Table of contents -->
<toc>

<!-- Begin the document -->

<sect>Introduction
De nombreuses améliorations sont dues à Nico Schottelius <tt>nicos@pcsystems.de</tt>.

<sect1>Xinerama, c'est quoi&nbsp;?
<p>Pourquoi auriez-vous besoin de Xinerama&nbsp;? Et qu'est ce que c'est&nbsp;?
Les extensions Xinerama ont-été ajoutées à XFree86 à la version 4.0. Xinerama
est une extension de XFree86 Release&nbsp;6 Version&nbsp;4 (X4.0) qui permet aux
applications et aux gestionnaires de fenêtres de disposer de deux écrans
physiques (ou plus), comme un seul grand écran virtuel.
</p>
<p>La beauté des extensions Xinerama est qu'elles sont complètement
transparentes à l'utilisateur. Avant cela, les applications ne pouvaient occuper
qu'un seul affichage (<em>display</em>) et ne pouvaient pas être déplacées de
l'un à l'autre. Les gestionnaires de fenêtres devaient gérer explicitement les
deux affichages. Avec Xinerama, les gestionnaires de fenêtres et les
applications ne doivent pas être écrits spécialement dans le but de supporter
l'<em>écran virtuel</em> de plus grande taille ainsi créé.
</p>
<sect1>Directives
<p>Ce document ne prétend pas être un guide sur la mise en service de votre
moniteur ou de votre carte graphique. En réalité, je fais l'hypothèse que vous
disposez déjà d'un environnement X&nbsp;Window qui fonctionne pour votre
configuration. Je vous conseille de vous plonger dans le documentation de
XF86 pour plus d'informations.
</p>
<p>Autant que je saches il n'y a pas de limite au nombre de cartes graphiques
que vous pouvez configurer de cette manière. Il ne semble pas non plus y avoir
de problème à mélanger différents types de cartes graphiques dans une même
configuration. La configuration de test que j'utilise pour cette documentation
comporte deux cartes graphiques&nbsp;: une Fire&nbsp;GL&nbsp;1000 AGP et une
Matrox&nbsp;Millenium&nbsp;II PCI. Quel effet cela a-t-il sur l'accélération 3D,
je n'en sait rien vu que je ne l'utilise sur aucune de mes cartes.
</p>
<p>Pour ce HowTo je fais les hypothèses que vous savez éditer un fichier,
configurer une carte graphique avec X&nbsp;Window, ajouter et enlever des cartes
de votre ordinateur, démarrer et arrêter des services et suivre des instructions
simples. Si vous pensez ne pas pouvoir faire l'une de ces actions, je vous en
prie, demandez de l'aide. Je ne suis pas responsable des éventuels dommages
subis par votre ordinateur.
</p>
<sect>Prévoir
<p>Prévoir une configuration Xinerama est un processus assez immédiat. Il y a
principalement trois chose qu'il faut prendre en compte&nbsp;: la résolution, le
nombre de couleurs et le positionnement de l'écran.
</p>
<sect1>Ce dont vous avez besoin
<p>Vous aurez besoin d'au moins deux cartes graphiques (une carte <em>dual
head</em> devrait également faire l'affaire) et de deux moniteurs. Il vous
faudra également un système qui supporte XFree86 (par exemple Linux ou Solaris)
et XFree86 version&nbsp;4.0. Je fais l'hypothèse que votre configuration
fonctionne et que vos deux cartes graphiques sont supportées par XFree86.
</p>
<p>À moins que vous ayez fait une mise à jour ou installé Linux récemment, vous
disposez certainement d'une ancienne version de&nbsp;X. Vérifiez que vous
utilisez bien une version&nbsp;4.0 ou  plus récente en entrant la commande
suivante&nbsp;:
</p>
<P><tscreen><tt>papel:/home/nico/X/bin # X -version</tt></tscreen>
</p>
<P>Vous devriez obtenir quelque chose dans ce genre&nbsp;:
</p>
<P><tscreen><code>
  XFree86 Version 4.0 / X Window System
  (protocol Version 11, revision 0, vendor release 6400)
  Release Date: 8 March 2000
         If the server is older than 6-12 months, or if your card is newer
         than the above date, look for a newer version before reporting
         problems.  (see http://www.XFree86.Org/FAQ)
  Operating System: Linux 2.3.46 i686 [ELF] 
  Module Loader present
  </code></tscreen>
</p>
<p>Si la version n'est pas au moins&nbsp;4.0 (la première ligne), vous devez
procéder à une mise à jour. Pour cela vous pouvez, soit utiliser le gestionnaire
de paquetages de votre distributions, soit télécharger directement la dernière
version depuis <url url="ftp://ftp.xfree86.org/pub/XFree86/4.0/" name="le site
de XFree86"> et l'installer, ou mieux, utiliser un des <htmlurl
url="http://www.xfree86.org/4.0/ftp.html" name="miroirs">.
</p>
<p>Une fois les fichiers téléchargés, installez la nouvelle version avec le
script <tt>Xinstall.sh</tt>. Remarquez que si vous installez X de cette manière,
il ne sera pas pris en compte par le gestionnaire de paquetages de votre système
(si ce dernier en a un).
</p>
<Sect1>À-propos de la mise en place
<p>Il est possible que chacun des écran de votre configuration Xinerama ait une
résolution différente. Ceci présente certains avantages. Par exemple, cela m'a
permis d'utiliser un vieux moniteur qui ne peut afficher que du 640&times;480
avec un 17" affichant du 1280&times;1024. J'ai également entendu parler de
développeurs web et de graphistes qui utilisent un grand écran pour la
prévisualisation, plus un ou deux autres plus petits. Je pense que cette
flexibilité représente un des grands avantages des extensions Xinerama.
</p>
<p>Quelques problèmes d'interface, spécifiques à Xinerama, demeurent avec
certains gestionnaires de fenêtres (reportez-vous à la section <ref id="Window
Managers" name="Gestionnaires de fenêtres et Xinerama">). Le plus ennuyeux étant la gestion des zones mortes.
</p>
<p>Les gestionnaires de fenêtres font l'hypothèse que la zone affichable est un
rectangle dont la taille est égale à la largeur et à la hauteur totale de votre
bureau. Si vous n'utilisez pas la même résolution sur tous les écrans, votre
zone affichable ne sera pas rectangulaire. Ceci fait apparaître des <em>zones
morte</em> qui n'ont pas d'existence au niveau de votre affichage, mais que
votre gestionnaire de fenêtres va interpréter comme <em>vides</em>. Nombreux
sont les gestionnaires de fenêtres qui vont tenter d'utiliser ces zones mortes
pour placer les nouvelles fenêtres. Les fenêtres ainsi placées seront alors
inaccessibles. Avec le temps, les gestionnaires de fenêtres prennent en compte
les extensions Xinerama et ces limitations disparaissent rapidement.
</p>
<p>Les gestionnaires de fenêtres ne savent pas non plus comment maximiser
une fenêtre quand on utilise Xinerama. Ce qui se passe en général c'est que les
fenêtres sont maximisées sur tous les écrans disponibles. Netscape étalé sur
deux écrans n'est pas la disposition idéale pour naviguer sur l'Internet.
</p>
<p>Contrairement à ce qu'il est possible de faire pour les résolutions, Xinerama
n'accepte qu'une seule profondeur d'écran pour l'intégralité de l'écran virtuel.
C'est un point à bien garder en tête au moment de ressortir sa vieille carte
graphique. Si cette dernière ne peut afficher que 8&nbsp;bits, vous aurez un
grand écran, mais avec seulement 256&nbsp;couleurs.

<sect1>Agencement
<p>La décision de comment tout cela va être agencé est assez simple à prendre.
Vous devez uniquement savoir comment vont être physiquement disposés vos
moniteurs. La plupart des gens mettront simplement leurs moniteurs côte-à-côte
et disposeront d'un bureau étalé sur les deux. Il est également possible que les
affichages se superposent par endroits, ou encore, il est possible de les
disposer de manière plus compliquée. Gardez cependant en tête ce que j'ai dit
plus haut au sujet des gestionnaires de fenêtres&nbsp;: ils s'attendent à avoir
un affichage rectangulaire.
</p>

<sect>Configuration de la carte graphique
<p>Voici venu le moment idéal pour faire une sauvegarde de votre configuration
existante.
</p>
<p>J'ai personnellement procédé de la sorte&nbsp;:
</p>
<p>
<tscreen>
	<tt>root# > cp /etc/X11/XF86Config /etc/X11/XFree86Config.working</tt>
</tscreen>
</p>
<p>Avant de s'attaquer à la partie multi-écrans, il faut vous assurer que
<em>toutes</em> vos cartes graphiques fonctionnent parfaitement avec la
résolution qu'elles auront dans la configuration finale. Si ce n'est pas déjà
fait, installez et configurez chaque combinaison de carte/moniteur tels qu'ils
seront dans la configuration finale. Si vous disposez de plusieurs cartes
graphiques identiques vous pouvez en configurer une et recopier le résultat pour
les autres.
</p>
<p>Remarquez qu'il est possible de configurer et tester vos cartes graphiques
sans les changer physiquement de place. Pour cela il vous faudra utiliser la
technique de scan, décrite dans la section <ref id="PCI Bus Section"
name="Identifiant et bus&nbsp;PCI"> ci-dessous, en précisant l'ID sur le
bus&nbsp;PCI.
</p>
<p>Une fois que toutes vos cartes sont configurées, faites une sauvegarde ou
bien imprimez leur fichier de configuration. Vous en aurez besoin plus tard.
J'ai procédé comme suit&nbsp;:
</p>
<p>
<tscreen>
	<tt>root# > cp /etc/X11/XF86Config /etc/X11/XFree86Config.Matrox</tt>
</tscreen>
</p>
<p>Il se peut que le fichier de configuration soit stocké dans <tt>/etc</tt> et
voici alors ce qu'il faudra faire&nbsp;:
</p>
<p>
<tscreen>
	<tt>root# > cp /etc/XF86Config /etc/XFree86Config.Matrox</tt>
</tscreen>
</p>
<p>Si vos cartes graphiques sont identiques vous pouvez certainement vous en
sortir avec une seule copie. Cependant, ne sautez pas cette étape. Si les
instructions que je vous donne mettent votre système sans dessus dessous, ce
sont ces copies de sauvegarde qui vous sauveront.
</p>
<p>Une fois les affichages configurés, tout est pratiquement fait...
</p>
<sect>Identifiant et bus&nbsp;PCI
<p>C'est le moment, il faut mettre toutes vos cartes graphiques dans la boite et
brancher vos moniteurs. Mettez tout en place comme vous le désirez dès à présent
sinon vous devrez répéter ces étapes plus tard.
</p>
<p>Ce qui suit devra être fait depuis la console, sans que&nbsp;X ne tourne. Si
vous êtes sous&nbsp;X, quittez le. Si vous utilisez un gestionnaire comme xdm ou
gdm, vous devez arrêter le service qui lui est associé. Sous une RedHat, le plus
simple est de faire&nbsp;:
</p>
<p>
<tscreen>
	<tt>root# > telinit 3</tt>
</tscreen>
</p>
<p>Pour Debian, Storm ou Corel&nbsp;:
</p>
<p>
<tscreen>
	<tt>root# > /etc/init.d/xdm stop</tt>
</tscreen>
</p>
<p>Si aucune de ces méthode ne fonctionne, relancez votre ordinateur et démarrez
en mode <tt>single</tt> (mono utilisateur).
<!-- Ben voyons ! Faut pas prendre l'ordi a coups de pioche non plus ? -->
</p>
<p>Dans le cadre du multi-écrans vous devez, dans le fichier de configuration,
explicitement identifier chaque carte graphique. Ceci se fait en utilisant
l'identifiant (ID), que le système donne à votre carte, sur le bus&nbsp;PCI.
Pour cela, toutes les cartes graphiques doivent être enfichées.
</p>
<p>Pour connaître les ID sur le bus&nbsp;PCI, faites&nbsp;:
</p>
<p>
<label id="PCI Bus Section">
<tscreen>
	<tt>root# > XFree86 -scanpci </tt>
</tscreen>
</p>
<p>X vous donnera un code pour chaque périphérique sur le bus&nbsp;PCI.
</p>
<p>
<tscreen><code>
(0:0:0) Intel 82443BX Host
(0:1:0) Intel 82443BX AGP
(0:7:0) Intel 82371AB PIIX4 ISA
(0:7:1) Intel 82371AB PIIX4 IDE
(0:7:2) Intel 82371AB PIIX4 USB
(0:7:3) Intel 82371AB PIIX4 ACPI
(0:9:0) Adaptec 2940U/UW
(0:11:0) 3COM 3C900 10b Combo
(0:12:0) Matrox unknown card (0x2007) using a Matrox MGA 2164W
(1:0:0) unknown card (0x1092/0x0152) using a Texas Instruments Permedia 2
</code></tscreen>
</p>
<p>Le&nbsp;0 du début identifie les cartes et périphériques&nbsp;PCI, alors que
le&nbsp;1 est réservé aux cartes AGP. Dans mon cas il y a une Matrox
Millenium&nbsp;II&nbsp;(0:12:0) et une Diamond FireGL&nbsp;(1:0:0). Relevez les
numéros associés à vos cartes graphiques. Il est important que vous sachiez quel
numéro est affecté à quelle carte.
</p>
<sect>Éditer votre fichier XF86Config
<p>Si vous n'êtes pas encore perdu, rentrons dans le vif du sujet. Cette section
peut être assez déroutante, je vous suggère donc de lire la page de manuel de
XF86Config, ou du moins de la parcourir. Faites-le&nbsp;! J'attendrai...
</p>
<p>
<tscreen>
	<tt> root# > man XF86Config</tt>
</tscreen>
</p>
<sect1>Ajout de toutes les cartes graphiques
<p>Ouvrez le fichier XF86Config et descendez jusqu'à la section traitant de
moniteur (<tt>Section "Monitor"</tt>). Il faut copier les sections
<tt>Monitor</tt>, <tt>Device</tt> et <tt>Screen</tt> des différents fichiers
XF86Config de sauvegarde créés plus haut. Ces sections doivent être reportées
dans votre fichier XF86Config après les sections correspondantes dans le fichier
que vous avez ouvert. Assurez-vous que l'identifiant (<tt>Identifier</tt>) est
unique pour chaque section; vous y ferez référence plus tard.
</p>
<p>Comment ça c'est, pas clair&nbsp;! Vous devez avoir, en définitive, une
section <tt>Monitor</tt>, <tt>Device</tt> et <tt>Screen</tt> pour chacune des
combinaison carte graphique/moniteur. Si vous êtes toujours embrouillé, relisez
le paragraphe précédent. Si cela ne vous aide pas, jetez un oeil au fichier
<ref id="XF86Config"> d'exemple à la fin de ces quelques pages. Vous avez bien
lu la page de manuel, hein&nbsp;?
</p>
<sect1>Identifier vos cartes graphiques
<p>Il faut à présent ajouter les ID du bus&nbsp;PCI à la fin de chaque section
<tt>Device</tt>. C'est une option de la section. La ligne devra ressembler à
ça&nbsp;: <tt>BusID    "PCI:0:12:0"</tt>, avec <em>votre</em> identifiant,
recherché à la section <ref id="PCI Bus Section" name="Identifiant et
bus&nbsp;PCI">, en lieu et place de <tt>0:12:0</tt>. Ci-dessous, un exemple de
section <tt>Device</tt> d'une de mes cartes graphiques.
</p>
<p>
<tscreen>
<code>
Section "Device"
    Identifier  "FireGL"
    Driver      "glint"
    BusID      "PCI:1:0:0"
EndSection
</code>
</tscreen>
</p>
<p>Remarquez que même les cartes&nbsp;AGP utilisent ce format.
</p>
<sect1>Configurer la section <tt>ServerLayout</tt>
<p>À présent, il faut éditer la section <tt>ServerLayout</tt> située à la fin de
votre fichier XF86Config. La section <tt>ServerLayout</tt> permet de décrire
les écrans utilisés, leur positionnement relatifs et les unités qui leur sont
attachées. Actuellement vous devez avoir une disposition ne contenant qu'un
écran, un clavier et une souris. Vous devez ajouter chacune des sections
<tt>Screen</tt> que vous avez créées auparavant pour qu'elles fassent partie de
votre écran.
</p>
<p>Ajoutez les nouvelles références à vos écrans en vous basant sur ce qui
existe déjà. Une référence se présente sous la forme&nbsp;:
</p>
<p>
<tscreen>
	<tt>Screen "Screen 2" <it>position</it> "Screen 1"</tt>
</tscreen>
</p>
<p> Cela décrit le positionnement relatif de <tt>Screen 2</tt> et <tt>Screen
1</tt>. <tt><it>position</it></tt> peut prendre les valeurs <tt>RightOf</tt>
(<it>à droite de</it>), <tt>Below</tt> (<it>en-dessous de</it>),
<tt>Above</tt> (<it>au-dessus de</it>), <tt>LeftOf</tt> (<it>à gauche de</it>),
<tt>Absolute X Y</tt>, <tt>Relative</tt>. Les quatres premières se comprennent
d'elles mêmes comme on peut le voir sur l'exemple suivant&nbsp;:
</p>
<p>
<tscreen>
<code>
Section "ServerLayout"
    Identifier  "Simple Layout"
    Screen "Screen 2"
    Screen "Screen 1" RightOf "Screen 2"
    InputDevice "Mouse1" "CorePointer"
    InputDevice "Keyboard1" "CoreKeyboard"
EndSection
</code>
</tscreen>
</p>
<p>Vous pouvez retrouver d'autres exemples dans la section <ref id="sample
XF86Config" name="Exemples de fichiers XF86Config">.
</p>
<sect>Tester votre configuration
<p>Une fois que votre fichier XF86Config a été modifié, sauvegardez-le. Vous
pouvez à présent tester votre configuration&nbsp;:
</p>
<p>
<tscreen>
	<tt> root# > startx -- +xinerama</tt>
</tscreen>
</p>
<p>Vous pouvez à présent vous réjouir de plusieurs partenaires X... pardon, je
voulais dire moniteurs&nbsp;!
</p>
<sect>Éditer vos fichiers de démarrage
<p>Si cela a fonctionné vous voudrez probablement modifier votre
configuration&nbsp;X pour qu'il démarre directement sous ce mode. Il existe une
multitude de façons de faire ça et probablement de bien meilleures que celles
que je vais vous proposer. Voici les méthodes que j'ai utilisées pour modifier
startx et gdm.
</p>
<p>Si vous lancez X depuis une ligne de commande, ajoutez simplement l'option
<tt>+xinerama</tt> au script startx.
</p>
<p>
<tscreen>
	<tt> root# > vi /usr/X11R6/bin/startx</tt>
</tscreen>
</p>
<p>Tout à la fin du fichier, le script lance X à l'aide de la commande
<tt>xinit</tt>.
Ajoutez l'option <tt>+xinerama</tt> à la fin de cette ligne.
</p>
<p>Pour que gdm se lance avec l'option xinerama, recherchez la section
<tt>[servers]</tt> à la fin du fichier <tt>/etc/X11/gdm/gdm.conf</tt>. Ajoutez
l'option <tt>+xinerama</tt> à la fin de la ligne qui commence avec <tt>0=</tt>.
Ca devrait ressembler à ça&nbsp;:
</p>
<p>
<tscreen>
	<tt> 0=/usr/bin/X11/X +xinerama</tt>
</tscreen>
</p>
<p>Je n'ai jamais essayé d'utiliser kdm ou xdm avec Xinerama, mais j'ai eu
l'astuce suivante de la part de Dalibor <tt>&lt;dali at dali dot net dot nz&gt;</tt>.
</p>
<p>
<tscreen>
<code>
Voici les modifications faites à mes fichiers de démarrage pour une
slackware&nbsp;7.x (j'utilise KDM et x4.01)

éditez /var/X11R6/lib/xdm/Xservers
ajoutez +xinerama à la fin de la dernière ligne
soit&nbsp;:
:0 local /usr/X11R6/bin/X +xinerama

Il se trouve que KDM utilise les fichiers standard XFree de xdm, du coup
cela devrait également fonctionner avec xdm.
</code>
</tscreen>

<sect>Gestionnaires des fenêtres et Xinerama <label id="Window Managers">
<p>Comme je l'ai dit précédemment, un gestionnaire de fenêtres n'a pas besoin
d'être spécialement écrit pour supporter Xinerama. Cependant, certaines petites
améliorations apportées par les développeurs peuvent faciliter l'utilisation de
Xinerama. Les fonctionnalités souhaitées sont&nbsp;:
</p>
<p>-&nbsp;Positionnement intelligent des fenêtres. Les gestionnaires de fenêtres
ne doivent pas placer ces dernières dans les zones mortes ou à la jonction de
deux écrans. Les nouvelles fenêtres doivent être ouvertes sur le bureau courant.
</p>
<p>-&nbsp;Maximiser une fenêtre doit uniquement la maximiser sur l'écran
courant.
</p>
<p>-&nbsp;Le déplacement des fenêtres doit être sujet à résistance à la limite
de deux écrans (de la même manière qu'il y a une résistance entre deux
fenêtres).
</p>
<p>-&nbsp;Les fenêtres de dialogue et d'information ne doivent pas apparaître
sur un autre écran.
</p>
<p>J'ai cherché dans leur liste de diffusion, leurs FAQ et j'ai également envoyé
des messages aux développeurs des principaux gestionnaires de fenêtres, pour
savoir s'ils fonctionnaient avec les extensions Xinerama ou assimilées. Les
gestionnaires de fenêtres que j'ai testés sont Blackbox, Enlightenment, Sawfish,
KDE, WindowMaker et XFCE. Enlightenment et Sawfish sont les deux seuls pour
lesquels j'ai trouvé des améliorations, relatives à Xinerama, significatives
(NdT&nbsp;: ce n'est plus le cas à l'heure actuelle. Par exemple kdwm, le
gestionnaire de fenêtres de KDE, sait prendre en compte Xinerama de manière
élégante). Je donne ci-dessous une description détaillée de ce que j'ai trouvé.
<sect1>Enlightenment
<p>Tiré de leur page de nouvelles&nbsp;: dimanche 26 mars 2000
</p>
<p>E et Xinerama
</p>
<p>
<tt>
Nous avons juste terminé l'intégration du support Xinerama cette semaine. Vous
pouvez à présent disposer de la résistance au déplacement à la frontières des
écrans, les fenêtres apparaîtront toujours sur l'écran courant (sauf si vous
voulez qu'elles aillent ailleurs, soit par modification de <tt>geometry</tt>
soit parce que vous avez sauvegardé leur position), maximiser (à part le mode
<tt>absolute</tt>) se fait également sur l'écran courant. Si vous disposez de
Xinerama et que vous faites tourner un&nbsp;E CVS, testez-ça et donnez-en des
nouvelles.
</tt>
</p>
<Sect1>Sawfish
<p>J'ai découvert, en lisant la liste de diffusion de Sawfish, qu'ils
développent activement la prise en compte Xinerama. Les fonctionnalités en train
d'être écrites sont&nbsp;:
<p>-&nbsp;Empêcher que les fenêtres soient ouvertes sur plusieurs écrans.
</p>
<p>-&nbsp;Empêcher que les fenêtres soient ouvertes dans les zones mortes.
</p>
<p>-&nbsp;Résistance au déplacement entre les écrans.
</p>
<p>-&nbsp;Les mode de placement de fenêtres Ramdom et Centered positionnent ces
dernières sur l'écran courant.
</p>
<p>Ce n'ai pas testé ces fonctionnalités.
</p>
<sect>Exemples de fichiers XF86Config<label id="XF86Config">
<p>Voici mon fichier XF86Config actuel&nbsp;:
<code>
Section "Module"
    Load        "dbe"  	# extension pour le double buffer
    SubSection  "extmod"
      Option    "omit xfree86-dga"   # ne pas initialiser l'extension DGA
    EndSubSection
    Load        "type1"
    Load        "freetype"
# Chargement du module GLX
#    Load       "glx"
EndSection

Section "Files"
    RgbPath	"/usr/X11R6/lib/X11/rgb"
    FontPath   "/usr/X11R6/lib/X11/fonts/local/"
    FontPath   "/usr/X11R6/lib/X11/fonts/misc/"
    FontPath   "/usr/X11R6/lib/X11/fonts/75dpi/:unscaled"
    FontPath   "/usr/X11R6/lib/X11/fonts/100dpi/:unscaled"
    FontPath   "/usr/X11R6/lib/X11/fonts/Type1/"
    FontPath   "/usr/X11R6/lib/X11/fonts/Speedo/"
    FontPath   "/usr/X11R6/lib/X11/fonts/75dpi/"
    FontPath   "/usr/X11R6/lib/X11/fonts/100dpi/"
# Chemin de recherche des modules. Ceci est le chemin par défaut
#    ModulePath "/usr/X11R6/lib/modules"
EndSection

Section "ServerFlags"

EndSection

Section "InputDevice"
    Identifier	"Keyboard1"
    Driver	"Keyboard"
    Option "AutoRepeat" "500 30"
    Option "XkbRules"	"xfree86"
    Option "XkbModel"	"pc101"
    Option "XkbLayout"	"us"
EndSection

Section "InputDevice"
    Identifier	"Mouse1"
    Driver	"mouse"
    Option "Protocol"    "PS/2"
    Option "Device"      "/dev/psaux"
EndSection

Section "Monitor"
    Identifier  "Mini"
    HorizSync   31.5
    VertRefresh 50-90
EndSection

Section "Monitor"
    Identifier  "Impression"
    HorizSync   31.5 - 82.0
    VertRefresh 50-100
EndSection

# Carte graphique N°1, Matrox Millenium II PCI
Section "Device"
    Identifier  "Matrox"
    Driver      "mga"
    VideoRam 8192
    BusID      "PCI:0:12:0"
EndSection

# Carte graphique N°2, Fire GL 1000 AGP
Section "Device"
    Identifier  "FireGL"
    Driver      "glint"
    #VideoRam    8192
    BusID      "PCI:1:0:0"

EndSection

Section "Screen"
    Identifier  "Screen 2"
    Device      "FireGL"
    Monitor     "Impression"
    DefaultDepth 16

    Subsection "Display"
        Depth       16
        Modes       "1280x1024" "640x480"
        ViewPort    0 0
    EndSubsection
EndSection

# Mon moniteur miniature. Remarquez que j'ai utilisé l'option virtual, de
# ce fait, la hauteur sera la même que celle du moniteur le plus grand.
# Ceci n'est pas indispensable.
Section "Screen"
    Identifier  "Screen 1"
    Device      "Matrox"
    Monitor     "Mini"
    DefaultDepth 16

    Subsection "Display"
        Depth       16
        Modes       "640x480"
        ViewPort    0 0
        Virtual     640 1024
    EndSubsection
EndSection

Section "ServerLayout"
    Identifier  "Simple Layout"
    Screen "Screen 2"  
    Screen "Screen 1" Rightof "Screen 2" 
    InputDevice "Mouse1" "CorePointer"
    InputDevice "Keyboard1" "CoreKeyboard"
EndSection

</code>
<label id="sample XF86Config">
</p>
<p>Un autre exemple de section ServerLayout, avec un moniteur au-dessous de
l'autre.
<code>
Section "ServerLayout"
    Identifier  "Simple Layout"
    Screen "Screen 2"
    Screen "Screen 1" Below "Screen 2"
    InputDevice "Mouse1" "CorePointer"
    InputDevice "Keyboard1" "CoreKeyboard"
EndSection
</code>
</p>
<p>Il est également possible que les écrans se superposent. Dans cet exemple,
les deux écrans ont un recouvrement de 80&nbsp;pixels...
<code>
Section "ServerLayout"
    Identifier  "Simple Layout"
    Screen "Screen 2"
    Screen "Screen 1" Relative "Screen 2" 1200 0
    InputDevice "Mouse1" "CorePointer"
    InputDevice "Keyboard1" "CoreKeyboard"
EndSection
</code>
</p>
<sect>Crédits
<p>La majeure partie de l'introduction et de la première section sont basées sur
un document qui m'a été proposé par Nico Schottelius
<tt>&lt;nicos at pcsystems dot de&gt;</tt>. Comme cela a déjà été mentionné, les
configurations de KDM et xdm m'ont été fournies par Dalibor <tt>&lt;dali at dali
dot net dot nz&gt;</tt>.
</p>
<p>Je remercie également les nombreuses personnes qui m'ont aidé à corriger les
fautes d'othographe et qui m'ont donné des idées. J'ai, autant que possible,
essayé de prendre en compte ces remarques.
</article>
<!--
 vim:co=80:
-->
