<!doctype linuxdoc system>

<!--  Traduction du Mini-HOWTO CLOCK
 -->

<article>

<!-- Title information -->

<title>Mini HOWTO Clock
<author>Ron Bean, Dec. 1996 <tt/rbean@execpc.com/
(Adaptation française par Gacquer frédéric <tt/gacquer@neuronnexion.fr/)
<date>Dec. 1996
<abstract>
Jeudi 2 avril 1998
V 1.0.
</abstract>

<!-- Table of contents -->
<toc>

<!-- Begin the document -->


<sect>Introduction

<p> 

Les puces d'horloge temps-réel sur les cartes mères des PC (et même des stations
de travail plus onéreuses) sont de notoriété publique inexactes. Linux fourni une manière
simple pour corriger cela de manière logicielle, rendant virtuellement l'horloge
*trés* précise même sans horloge externe. Mais la plupart des personnes ne
semblent pas être au courant, pour plusieurs raisons :
  

<enum>

  <item> Ce n'est pas indiqué dans la plupart des documentations "Comment
 installer linux", et cela serait difficile de le mettre en place 
automatiquement au moment de l'installation du système (bien que pas 
impossible en théorie, si vous avez un modem).

  <item> Si vous essayez "man clock" vous obtiendrez clock(3), ce qui n'est 
pas ce que vous souhaitez. (Essayez "man 8 clock").

 <item> La plupart des gens ne semblent pas tenir compte de l'heure qu'il est de 
 toute façon.

 <item> Le peu qui y font attention régulièrement veulent utiliser le logiciel
 xntpd de louie.udel.edu pour se synchroniser à une horloge externe, comme 
un serveur réseau de temps ou une horloge radio. 

</enum>

<p>
Ce mini-howto décrit une approche de bas-niveau. Si vous êtes vraiment 
intéressé par ce genre de chose, je vous recommende vivement de passer du 
temps à <url url="http://www.eecis.udel.edu/~ntp/"> qui inclus toutes sortes 
de choses intéressantes, incluant une documentation complète sur xntpd et des 
liens sur NIST et USNO (j'ai quelques commentaires supplémentaires sur xntpd à 
la fin.)

  <em/Note/
     si vous avez plus d'un système d'exploitation sur votre machine, 
     vous devez en laisser seulement un remettre à jour l'horloge CMOS, 
     ainsi ils n'interfèrerons pas l'un envers l'autre. Si vous exécutez 
     régulièrement à la fois linux et windows sur la même machine, vous 
     pourriez éventuellement préférer quelques uns des programmes 
     sharewares de gestion de l'horloge disponible pour windows (suivre 
     les liens à partir de l'URL ci-dessus).

<sect> Utiliser le programme 'clock'
<p>
Tout ce que vous devez savoir est dans la page de manuel clock(8), mais ce 
mini-HOWTO va vous guider pas à pas.
   
   <em/Note/
       Vous devez être root pour exécuter 'clock', ou n'importe quel autre 
       programme qui modifie soit le temps système soit l'horloge CMOS.

  <sect1> Vérifier votre installation
      <p>
      Cherchez dans vos fichiers de démarrage une commande du style 
      'clock -a' ou 'clock -ua'. Selon la distribution que vous utilisez, cela 
      peut être dans <tt>/etc/rc.local</tt>, <tt>/etc/rc.d/rc.sysinit</tt>, ou dans un endroit 
      similaire.

      <p>
      Si c'est 'clock -s' ou 'clock -us', changez le 's' en 'a', puis 
      regardez si vous avez un fichier <tt>/etc/adjtime</tt>, ne contenant qu'une 
      ligne ressemblant à quelque chose comme cela :
      <tscreen><verb>
       0.000000 842214901 0.000000
      </verb></tscreen>
      <p>
      Ces nombres sont le facteur de correction (en secondes par jour), le 
      moment où l'horloge a été réajustée la dernière fois (en secondes depuis 
      le 1er janvier 1970), et les secondes partielles qui ont été arrondies 
      la dernière fois. Si vous n'avez pas ce fichier, connectez vous en tant que root et 
      créez le, avec une seule ligne qui ressemble à (que des zéros) :
  
      <tscreen><verb>
         0.0 0 0.0
      </verb></tscreen>

      <p>
      Ensuite exécutez 'clock -a' ou 'clock -ua' manuellement à partir du 
      shell pour mettre à jour le deuxième nombre (utiliser le 'u' si votre 
      horloge est configurée en Universel plutôt que temps local).

   <sect1> Mesurer le taux de dérive temporelle de votre horloge
      <p>
      
      Pour commencer, vous devez connaitre l'heure qu'il est :-). Votre temps 
      local du jour peut ou peut ne pas être exact. Ma méthode préférée est 
      d'appeler l'horloge parlante au 3699 (c'est un appel gratuit). Si vous 
      avez accés à un serveur réseau de temps, vous pouvez utiliser le 
      programme ntpdate du progiciel xntpd (utiliser le paramètre
      -b pour empêcher le noyau de cafouiller l'horloge CMOS). Sinon utiliser 
      'date -s hh:mm:ss' pour mettre l'heure système à la main, puis 
      'clock -w' pour mettre à jour l'horloge CMOS à partir de l'heure du 
      système. Vous devrez vous rappeler la dernière fois que vous avez 
      changé l'heure, donc écrivez la date quelque part où vous ne la perdrez 
      pas. Si vous avez utilisé ntpdate, faire 'date +%s' et écrire le nombre 
      de secondes depuis le 1er janvier 1970.
      <p>

      Puis revenez quelques jours ou semaines après et regardez de combien l'horloge a
      dérivé. Si vous mettez l'horloge à jour à la main, je vous recommanderais d'attendre
      au moins deux semaines, et de seulement calculer le taux de dérive le plus proche d'un
      dixième de secondes par jour. Après plusieurs mois vous pourrez obtenir le plus proche
      d'un centième de secondes par jour (quelques personnes affirment être encore plus précis
      mais je resterais prudent dans ce cas). Si vous utilisez ntpdate, vous n'aurez pas
      à attendre si longtemps, mais dans tous les cas vous pourrez toujours affiner plus tard.
      <p>
    
      Vous pouvez avoir cron qui exécute 'clock -a' à des moments réguliers pour garder 
      le temps système en accord avec le temps (corrigé) CMOS. Cette commande sera aussi
      exécutée à partir de vos fichiers de démarrage à chaque fois que vous relancerez le
      système, ainsi si vous le faites souvent (comme quelques uns d'entre nous le font),
      cela peut suffire à vos besoins.
      <p>

      Remarquez que certains programmes peuvent se plaindrent si le système saute plus d'une
      seconde à la fois, ou s'il retranche du temps. Si vous avez ce problème, vous pouvez
      utiliser xntpd ou ntpdate pour corriger le temps plus graduellement.

    <sect1> Exemple
       
      <sect2> Mettre à jour le temps
       <p>
       Se connecter root. Appeler le 3699 (vocal), écouter l'annonce de l'heure.
       Puis taper:

      <tscreen><verb>
         date -s hh:mm:ss
      </verb></tscreen>
       <p>
       Mais ne tapez Entrée que lorsque vous entendez le bip. (vous pouvez 
       utiliser 'ntpdate' ici plutôt que 'date', et éviter l'appel téléphonique).
       Cela met à jour le 'temps noyau'. Puis taper :
      
      <tscreen><verb>
       clock -w
      </verb></tscreen>
      <p>
       Cela met à jour l'horloge CMOS pour correspondre au temps noyau. 
       Puis taper:

      <tscreen><verb>
       date +%j
      </verb></tscreen>
   
       (ou 'date +%s' si vous utilisez 'ntpdate', plutôt que 'date' ci-dessus)
       et écrire le nombre qu'il vous donne pour la prochaine fois.

     <sect2> Pour remettre à jour le temps et vérifier le taux de dérive

        <p>
        Trouver la date que vous avez écrit la dernière fois. Se connecter 
        root puis taper:
        
      <tscreen><verb>
           clock -a
      </verb></tscreen>
        <p>
        Cela met à jour le temps noyau qui correspond ainsi au temps CMOS. 
        Appeler le 3699 (vocal), écouter l'annonce. Puis taper :

      <tscreen><verb>
           date
      </verb></tscreen>

        <p>
        et appuyer sur Entrée quand vous entendez le signal sonore, mais 
        alors que vous attendez, notez le temps annoncé, et ne raccrochez 
        pas de suite. Cela vous dit à quel temps votre machine pensait être, 
        quand cela aurait du être exact à la minute. Maintenant entrez :

      <tscreen><verb>
           date hh:mm:00
      </verb></tscreen>

        <p>
        utilisant la minute *après* celle qui vient juste d'être annoncée, et  
        appuyez sur entrée quand vous entendez le signal sonore à nouveau 
        (maintenant vous pouvez raccrocher). Pour hh utiliser le temps local. 
        Cela met à jour le 'temps noyau'.

        Puis taper :

      <tscreen><verb>
            clock -w
      </verb></tscreen>

        qui écrit le nouveau (correct) temps dans l'horloge CMOS. 
        Maintenant tapez :

      <tscreen><verb>
            date +%j
      </verb></tscreen>
        <p>
        (ou 'date +%s' si c'est ce que vous avez utilisé avant).
        <p>
        Vous avez maintenant trois nombres (deux dates et une heure) qui 
        vont vous permettre de calculer la dérive de temps.

      <sect2> Calculer le facteur de correction
 
       <p>
       quand vous exécutez 'date' à l'instant, est-ce que votre machine 
       était en avance ou en retard ? Si elle avançait, vous aurez à retrancher 
       quelques secondes, alors écrivez le comme un nombre négatif. Si elle 
       retardait, vous aurez à ajouter quelques secondes, alors écrivez le 
       comme positif.
       <p>

       Maintenant soustrayez les deux dates. Si vous avez utilisé 'date +%j', 
       les nombres représentent le jour de l'année (1-365, ou 1-366 pour les 
       années bissextiles).  Si vous avez passé le 1er janvier depuis votre 
       dernière modification horaire vous aurez à ajouter 365 (ou 366) au 
       deuxième nombre. Si vous avez utilisé 'date +%s' alors votre nombre 
       est en secondes, et vous aurez à le diviser par 86400 pour obtenir
       des jours.

       <p>
       Si vous avez déjà un facteur de correction dans <tt>/etc/adjtime</tt>, vous 
       aurez à tenir compte du nombre de secondes que vous avez déjà corrigé. 
       Si vous avez trop corrigé, ce nombre aura le signe opposé à celui que 
       vous venez juste de mesurer; si vous n'avez pas assez corrigé il aura 
       le même signe.  Multipliez l'ancien facteur de correction par le 
       nombre de jour, et ensuite ajouter le nouveau nombre de secondes 
       (addition signée  -- si les deux nombres ont le même signe, vous 
       obtiendrez un nombre plus grand, s'ils ont des signes opposés
       vous aurez un nombre plus petit).
       <p>

       Puis divisez le nombre total de secondes par le nombre de jours pour 
       obtenir le nouveau facteur de correction, et le mettre dans 
       <tt>/etc/adjtime</tt> à la place de l'ancien. Conservez la nouvelle date 
       (en secondes par jour) pour la prochaine fois.
       <p>

       Voici à quoi ressemble mon <tt>/etc/adjtime</tt> :

      <tscreen><verb>
            -9.600000 845082716 -0.250655
      </verb></tscreen>
       
      <em/Note/
       (on remarque que 9.6 secondes par jour c'est presque 5 minutes par mois !)

       <sect1> Quelques mots à propos de xntpd
       <p> 
       Votre système a en fait deux horloges -- l'horloge temps réel sur 
       batterie qui garde trace du temps quand le système est éteint (aussi 
       connue  comme "l'horloge CMOS", "horloge matérielle" ou "RTC") et 
       le 'temps noyau' (parfois appellée "horloge logicielle" ou "horloge 
       système") qui est basé sur l'interruption timer et qui est 
       initialisée à partir de l'horloge CMOS au démarrage du système.
       Les deux vont dériver à des rythmes différents, ainsi elles vont 
       graduellement s'écarter l'une de l'autre, tout en s'écartant du temps 'réel'.
       <p>

       Toutes les références à "l'horloge" dans la documentation de xntpd se 
       réfèrent à "l'horloge noyau". Quand vous exécutez xntpd ou timed (ou 
       n'importe quel autre programme qui utilise l'appel système adjtimex), 
       le noyau linux suppose que l'horloge du noyau est plus précise que 
       l'horloge CMOS, et remets à jour le temps CMOS toutes les 11 minutes à 
       partir de ce moment (jusqu'à ce que l'on relance l'ordinateur). Cela 
       signifie que 'clock' ne sais plus quand l'horloge CMOS a été modifié 
       la dernière fois, ainsi vous ne pouvez plus utiliser le facteur 
       de correction dans <tt>/etc/adjtime</tt>. Vous pouvez utiliser ntpdate dans 
       votre fichier de démarrage pour mettre à jour initialement l'horloge à 
       partir d'un serveur de temps avant de lancer xntpd. Si vous n'avez 
       pas toujours accés à une source fiable de temps lors
       de l'allumage de l'ordinateur, cela peut être un peu gênant -- 
       xntpd n'est pas vraiment conçu pour être utilisé dans des situations 
       comme celles là.
       <p>

       Xntpd inclue des drivers pour plusieurs horloges radio, et peut être 
       configuré pour appeler le service de temps téléphonique de NIST à des 
       temps réguliers (soyez sûr de calculer l'incidence sur votre facture 
       téléphonique lors du paramétrage de l'intervalle entre deux appels). 
       Il peut aussi appliquer un facteur de correction à l'horloge noyau
       s'il perd contact avec les autres sources pour une période de temps 
       assez longue.
       <p>

       La plupart des horloges radio coûtent 3-4000&dollar;, mais vous 
       pouvez obtenir des plans pour une 'boite gadget' peu chère (en fait un 
       modem 300 baud) qui se met entre votre ordinateur et n'importe quelle 
       radio onde courte réglée sur la station de temps canadienne CHU 
       (voir <url url="ftp://ftp.udel.edu/pub/ntp/gadget.tar.Z">). Le
       récepteur Heathkit WWV ("l'Horloge la Plus Précise") est aussi encore 
       disponible (bien que n'étant pas en kit), et coûte aux environs de
       4-500 &dollar;. Les signaux GPS contiennent aussi des informations de 
       temps, et quelques recepteurs GPS peuvent se connecter sur le port 
       série. Cela peut être la solution la moins onéreuse dans
       un futur proche.
       <p>

       En théorie, on peut écrire un programme pour utiliser le service 
       de temps téléphonique NIST pour calculer automatiquement le taux de 
       dérive de l'horloge CMOS et de l'horloge noyau. Je ne suis 
       pas au courant d'un quelconque programme démon qui 
       ferait cela, mais la plupart du code peut être emprunté à xntpd.



       
</article>
