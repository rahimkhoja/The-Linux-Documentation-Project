<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.2//EN"
"/usr/share/sgml/docbook/dtd/xml/4.2/docbookx.dtd" [
<!ENTITY howto         "http://www.traduc.org/docs/howto/lecture/">
<!ENTITY mini-howto    "http://www.traduc.org/docs/mini-howto/lecture/">
<!ENTITY guides        "http://www.traduc.org/docs/guides/lecture/">
]>

<article lang="fr">

<articleinfo>

<title>Guide pratique des disquettes d'amorçage</title>
<subtitle>Version française du <foreignphrase>Bootdisk 
HOWTO</foreignphrase></subtitle>

<author>
<firstname>Tom</firstname>
<surname>Fawcett</surname>
<affiliation>
<address><email>fawcett CHEZ croftj POINT net</email></address>
</affiliation>
</author>

<othercredit>
<firstname>Mathieu</firstname>
<surname>Decore</surname>
<affiliation>
<address><email>mdecore CHEZ linux TIRET france POINT org</email></address>
</affiliation>
<contrib>Adaptation française</contrib>
</othercredit>

<othercredit>
<firstname>Frank</firstname>
<surname>Pavageau</surname>
<affiliation>
<address><email>pavageau CHEZ imaginet POINT fr</email></address>
</affiliation>
<contrib>Adaptation française (version 3.5)</contrib>
</othercredit>

<othercredit>
<firstname>Guillaume</firstname>
<surname>Hatt</surname>
<affiliation>
<address><email>ghatt CHEZ netcourrier POINT com</email></address>
</affiliation>
<contrib>Relecture de la version française</contrib>
</othercredit>

<othercredit>
<firstname>Jean-Philippe</firstname>
<surname>Guérard</surname>
<affiliation>
<address><email>jean TIRET philippe POINT guerard CHEZ laposte POINT net</email></address>
</affiliation>
<contrib>Préparation de la publication</contrib>
</othercredit>

<releaseinfo>Version 4.5.fr.1.0</releaseinfo>
<pubdate>20 juin 2003</pubdate>

<abstract><para>
Ce document explique comment concevoir et créer ses propres disquettes
d'amorçage et disquettes racines pour Linux. Ces disquettes peuvent être
utilisées comme disques de secours, ou pour l'essai de nouveaux
composants système. Avant de tenter de créer une disquette d'amorçage,
il est recommandé d'avoir un compréhension raisonnable de
l'administration d'un système Linux. Si vous souhaitez juste créer des
disquettes de secours, lisez la <xref linkend="distbootdisks"/>.
</para></abstract>

<revhistory>

<revision>
    <revnumber>4.5.fr.1.0</revnumber>
    <date>2003-06-20</date>
    <authorinitials>MD, GH, JPG</authorinitials>
    <revremark>
        Mise à jour de la version française. Conversion en XML (MD).
    </revremark>
</revision>

<revision>
    <revnumber>4.5</revnumber>
    <date>Janvier 2002</date>
    <authorinitials>TF</authorinitials>
</revision>

<revision>
    <revnumber>4.0</revnumber>
    <date>2000-04-01</date>
    <authorinitials>TF</authorinitials>
</revision>

<revision>
    <revnumber>3.5.fr.1.0</revnumber>
    <date>Juillet 1999</date>
    <authorinitials>FP</authorinitials>
</revision>

<revision>
    <revnumber>3.5</revnumber>
    <date>Juillet 1999</date>
    <authorinitials>TF</authorinitials>
</revision>

</revhistory>

</articleinfo>

<sect1><title>Préface</title>

<note><title>Ce document peut être obsolète.</title>
<para>
Si la date sur la page de titre a plus de six mois, vérifiez la page du
Projet de documentation Linux (LDP) <ulink 
url="http://www.ibiblio.org/LDP/HOWTO/Bootdisk-HOWTO.html"></ulink> (et 
sa traduction française <ulink 
url="&howto;Bootdisk-HOWTO.html"></ulink>) au cas où une version plus 
récente s'y trouverait.
</para>
</note>

<para>
Bien que ce document soit lisible dans sa forme texte, il a
<emphasis>bien</emphasis> meilleure allure en PostScript, PDF ou HTML en
raison de la typographie utilisée.
<!--
FIXME : a verifier
 Nous vous conseillons de choisir une de ces versions. La version Info
est, pour l'instant, tellement mal générée qu'elle en est inutilisable.
-->
</para>

<sect2>

<title>Notes</title>

<para>
<indexterm><primary>noyau, versions</primary></indexterm> Graham Chapman
(<email>grahamc CHEZ zeta POINT org POINT au</email>) a
écrit le premier Bootdisk-HOWTO et en a assuré la maintenance jusqu'à la
version 3.1. Tom Fawcett (<email>fawcett CHEZ croftj POINT net</email>) 
a ajouté beaucoup d'informations pour le support du noyau 2.0, et 
effectue désormais la maintenance du document, depuis la version 3.2 qui 
contient toujours une bonne partie écrite par Chapman.  Chapman a 
disparu de la communauté Linux et personne ne sait actuellement où il se 
trouve.
</para>

<para>
Les informations contenues dans ce document concernent Linux sur 
plate-forme <trademark>Intel</trademark>. Bien des éléments doivent 
pouvoir être appliqués à Linux sur d'autres processeurs, mais nous n'en 
avons pas personnellement l'expérience, ni ne possédons d'informations 
de ce type. Si quelqu'un a expérimenté les disques d'amorce sur d'autres 
plates-formes, qu'il nous contacte.
</para>
</sect2>

<sect2>

<title>À faire</title>

<orderedlist>

<listitem><para>
User-mode-linux (<ulink
url="http://user-mode-linux.sourceforge.net/"></ulink>) semble être un
bon moyen de tester les disquettes d'amorce sans avoir à redémarrer la
machine sans arrêt. Je ne l'ai pas testé. Si quelqu'un l'a fait
fonctionner de manière significative pour fabriquer ses propres
disquettes d'amorce, merci de me le faire savoir.</para></listitem>
<listitem><para>Ré-analyser la distribution de la disquettes d'amorce et
mettre à jour la section &laquo;&nbsp;La méthode des pros&nbsp;&raquo;
</para></listitem>

<listitem><para>
Trouver jusqu'où la séquence init-getty-login peut être simplifiée, et
la remplacer. Quelque personnes m'ont dit que <command>init</command>
peut être un lien vers <command>/bin/sh</command>&nbsp;; si c'est le cas, et
que cela n'impose pas de grandes modifications, changer les instructions
pour le faire. Cela permettrait d'éliminer l'utilisation de
<command>getty</command>, <command>login</command>,
<command>gettydefs</command>, et sans doute tout ce qui concerne PAM et
NSS.
</para></listitem>

<listitem><para>
Aller à nouveau dans le code source du noyau 2.4 et écrire une
explication détaillée sur la procédure de démarrage et de chargement du
disque mémoire (seulement si je le comprends mieux). Il y a des
fonctionnalités à propos de <command>initrd</command> et les limitations
concernant les périphériques de démarrage (comme les cartes flash) que
je ne comprends pas encore.
</para></listitem>

<listitem><para>
Supprimer la section qui décrit comment mettre à jour une disquettes
d'amorce. C'est la plupart du temps source de trop de tracas.
</para></listitem>

<listitem><para>
Remplacer la commande <command>rdev</command> par les mots-clefs
<command>LILO</command>.
</para></listitem>

</orderedlist>
</sect2>

<sect2>

<title>Retours et remerciements</title>

<para>
Tout retour, bon ou mauvais, sur le contenu de ce document est le
bienvenu. Nous avons fait de notre mieux pour vérifier que les
instructions et informations ici présentes sont précises et fiables.
Merci de nous signaler toute erreur ou omission.
</para>

<para>
Nous remercions les nombreuses personnes nous ayant fourni des
corrections et suggestions. Leurs contributions ont permis d'améliorer
ce document bien au delà de ce que nous aurions pu réaliser seuls.
</para>

<para>
Envoyez vos commentaires, corrections et questions en anglais à l'auteur 
à l'adresse ci-dessus (ou au traducteur pour des problèmes dans la 
version française). Cela ne me dérange pas d'essayer de répondre à vos
questions, mais merci de lire la <xref linkend="troubleshooting"/>
d'abord.
</para>

<!--

Historique
==========

v4.5, Janvier 2003. Changements :
- Passage de la version 3.5 en XML.
- Modifications de la section « Notes » : Chapman a disparu de la 
  communauté Linux, et suppression du paragraphe précisant que les 
  informations contenues dans ce document concernent Linux sur 
  plateforme Intel.
- Modifications de la section « Démarrage » : le noyau consulte le « mot 
  disque mémoire » pour connaître le système de fichiers racine.
- Rajout dans la section « Création du système de fichiers : le 
  PÉRIPHÉRIQUE est créé avec une taille de 4096 contre 3000 ko avant, et 
  rajout d'explications sur l'importance de mettre le PÉRIPHÉRIQUE à 
  zéro.
- Modification dans la section « /dev » de l'exemple de copie des 
  périphériques avec l'option -R. Remplacement de cua par ttyS et de 
  ram par ram0. Rajout de l'explication concernant le nombre d'i-noeuds 
  non disponibles.
- Rajout dans la section « /etc » : « Ce qu'il devrait contenir dépend 
  des programmes que vous avez l'intention d'exécuter. ». Rajout de 
  gettydefs dans la liste des fichiers à configurer pour un système 
  d'amorce et racine. Rajout dans termcap de l'entrée linux. Rajout du 
  fait qu'il faut s'assurer que rc est bien exécutable et qu'il contient 
  bien une ligne #!/bin/sh.
- Rajout dans la section « Utilisation de PAM et NSS » du fait que si on 
  ne l'utilise pas, on risque de ne pas pouvoir se connecter ou utiliser 
  la disquette d'amorce. La librairie /lib/libnss_files.so.1 est 
  remplacée par /lib/libnss_files.so.X où où X vaut 1 pour une glibc 2.0 
  et 2 pour une glibc 2.1.
- Remplacement dans la section « Quelques ultimes détails » de « chdir /mnt;
  chroot /mnt /sbin/ldconfig » par « ldconfig -r /mnt ».
- Rajout dans la section « Transfert du noyau avec LILO » : vérifier que
  vous avez une version récente de LILO. Modification de « ls -l NOYAU »
  par « ls -s NOYAU ». Remplacement de « mke2fs -i 8192 » par « mke2fs -N 
  24 ».
- Ajout dans la section « Mise en place du mot disque mémoire » d'une note
  concernant la page de manuel de rdev/ramsize obsolète.
- Ajout dans la section « En cas de problème, ou l'agonie de la défaite »
  du nom du fichier des périphériques 
  /usr/src/linux/Documentation/devices.txt&nbsp;; ajout comme erreur possible
  « end_request: I/O error, dev 01:00 (ramdisk), sector NNN ».
- Ajout dans la section « Réduire la taille du système racine » de l'intro,
  de la discussion sur quelles densités de disquettes sont supportées, 
  de la section « Remplacer les utilitaires indispensables par BusyBox », 
  de BusyBox dans la section « Changez de shell », mise à jour du lien des 
  shells de remplacement (metalab.unc.edu / www.ibiblio.org).
- Déplacement de la section « Sujets divers » en section 9.
- Rajout dans la section « Construire un disque utilitaire » de la commande
  ftmt.
- Rajout de la section « Créer des CD-ROM amorçables »
- Rajout des FAQ « Comment utiliser des disquettes de haute densité (>
  1440 ko) ? Comment savoir quelles densités fonctionneront avec mon
  lecteur de disquette ? », « Comment augmenter la taille de mes disques 
  mémoire ? », « Comment faire des CD-ROM amorçables ? » et « Comment faire 
  des disquettes LS-120 amorçables ? ».
- Dans la section « Ressources et pointeurs », rajout de la distribution
  Mandrake. Changement de l'adresse metalab.unc.edu par www.ibiblio.org.
  Rajout de RIP.
- Suppression de la section « Scripts shell et Graham Chapman ».
- Suppression de la section « FAQ Linux et HOWTO ».

v3.4, Avril 1999. Changements :
- Vérification et modification d'URL.
- Déplacement des expressions NIDX. Une bogue dans sgmltools semble
  détruire tout ce qui suit NIDX sur la même ligne, alors que cela
  n'arrive pas avec IDX ou d'autres balises.
- Ajout d'un point sur le problème de « Kernel panic: VFS: Unable to
  mount root fs » qui est devenu une question récurrente.
- Suppression de l'avertissement sur le nettoyage d'utilisateurs de
  /etc/passwd. Je croyais que les archiveurs stockaient les noms
  d'utilisateurs ou de groupes, alors qu'ils stockent les UID et GID.
- Suppression d'une partie de la discussion sur les bibliothèques,
  ajout d'un point clair sur la nécessité de nettoyer les
  bibliothèques de leurs symboles de déboguage (une question récurrente
  vu la taille des nouvelles libc).
- Mise à jour des exemples de ldd et file dans la section /lib.

v3.3, Novembre 1998. Changements :
- Ajout de la section sur PAM et sa configuration
- Ajout de la section sur /lib/libnss_*
- Ajout d'une mention de l'utilitaire debugfs
- Revérification de toutes les URL et mise à jour de
  certaines. Suppression de certains noms de fichiers spécifiques afin
  que les URL pointent maintenant sur des répertoires FTP.
- Remplacement du contenu du système racine de Graham par le contenu
  de Yard, car certains choix de fichiers de Graham étaient obsolètes.
- Ajout d'un paragraphe sur les invites de login inutilisables, en
  mentionnant PAM, NSS et les mots de passe cachés.
- Nettoyage de quelques problèmes d'indexation. sgml-tools a toujours
  quelques bogues.

v3.2, Juin 1998. Changements :
- Suppression de Graham Chapman comme co-auteur, à sa demande. Ajout
  d'un paragraphe aux Notes pour lui rendre crédit pour les versions
  initiales.
- Correction de quelques commandes d'index qui produisaient des
  sorties parasites.
- Mise à jour du nom et de la version de mount sur ftp.win.tue.nl
- Dans la section « Réduction de la taille du système racine », ajout
  d'un paragraphe sur le reformatage des disquettes à de plus hautes
  densités.
- Modification du Makefile pour que la version Info de ce document ne
  soit plus générée ou distribuée, car elle est complètement
  inutilisable.
- Modifications de nombreux guillemets, correction de quelques
  commandes d'indexation.

v3.1, Mars 1998

v3.0, début 1998. Réécriture significative.

v2.3, 4 avril 1997. Changements :
- Déplacement de la première question récurrente (« Pourquoi mon disque
  ne démarre pas ? ») dans sa propre section (« En cas de problème ») et
  ajout d'information de déboguage pour Yard à celle-ci.
- Quelques changements suggérés par D.Hill et J.R.Ganuza.
- Ajout de balises ref et label à divers endroits.
- Déplacement des scripts et ressources dans l'appendice.
- Ajout d'URL pour les disques d'amorce des distributions et leurs
  miroirs.

v2.2, 1er septembre 1996. Changements :
- Correction : mise en place du mot disque mémoire sur /dev/fd0 au
  lieu de zImage.

v2.1, 18 août 1996. Changements :

Résumé : grand nettoyage pour tenir compte des différences entre les 
         versions 1.2 et 2.0 du noyau. Notamment :

- Modif : remplacement des scripts shell et des contenus de
  répertoires.
- Modif : suppression de la plupart du texte de la question récurrente
  sur les « disques mémoires trop gros ».
- Correction : mkfs -i aurait dû être mke2fs -i.
- Correction : paramètre manquant à la commande dd pour mettre à zéro
  le périphérique racine.
- Correction : suppression d'un paramètre en trop de la commande
  mke2fs de création du système racine.
- Modification : changements mineurs pour montrer la moins grande
  dépendance de l'utilitaire Bootkit.
- Modification : changement des références croisées des sections afin
  de se référer au titre de la section plutôt qu'à son numéro (un jour
  j'ajouterai des liens hyper-texte...)
- Ajout : utilisation de cpio comme alternative pour copier les
  fichiers.
- Ajout : tuyaux pour supprimer des fichiers spéciaux de périphériques
  inutiles.
- Ajout : question récurrente - que faire si rien ne se passe au
  démarrage.
- Ajout : quelques changements mineurs.

v2.0, 12 juin 1996. Changements :
- Ajout : auteur et responsable de maintenance supplémentaire, Tom
  Fawcett.
- Ajout : section 6.3, Utilisation du disque mémoire.
- Ajour : section intitiulée Création de disques d'amorce évolués,
  décrivant comment utiliser avec bonheur les modifications de disque
  mémoire des noyaux postérieurs au 1.3.48.
- Modif : réécriture de la section sur le répertoire /lib.
- Modif : quelques petits tuyaux sur les nouvelles manières d'utiliser
  un disque mémoire.

======================= FIN DE L'HISTORIQUE  -->

</sect2>

<sect2>

<title>Politique de distribution</title>

<para><foreignphrase>
Copyright &copy; 1995,1996,1997,1998,1999 by Tom Fawcett and Graham
Chapman. This document may be distributed under the terms set forth
in the Linux Documentation Project License at
<ulink url="http://www.ibiblio.org/LDP/COPYRIGHT.html">
http://www.ibiblio.org/LDP/COPYRIGHT.html</ulink>.  Please contact the
authors if you are unable to get the license.
</foreignphrase></para>

<para><foreignphrase>
Copyright &copy; 1999,2003 by Frank Pavageau and copyright &copy; 
2003 by Mathieu Decore and Guillaume Hatt for the French translation.
This document may be distributed under the terms of the Linux 
Documentation Project License, which is hereby included by reference
<ulink url="http://www.ibiblio.org/LDP/COPYRIGHT.html"></ulink>.
</foreignphrase></para>

<para><foreignphrase>
This is free documentation.  It is distributed in the hope that it will
be useful, but <emphasis>without any warranty</emphasis>; without even
the implied warranty of <emphasis>merchantability</emphasis> or
<emphasis>fitness for a particular purpose</emphasis>.
</foreignphrase></para>

<para>
Copyright &copy; 1995,1996,1997,1998,1999 Tom Fawcett et Graham
Chapman. Ce document peut être distribué sous les termes de la Licence
du Linux Documentation Project lisible à <ulink 
url="http://www.ibiblio.org/LDP/COPYRIGHT.html"></ulink>. Merci de 
contacter les auteurs si vous n'arrivez pas à récupérer la licence.
</para>

<para>
Copyright &copy; 1999 Frank Pavageau et copyright &copy; 2003 
Mathieu Decore et Guillaume Hatt pour la version française. Ce document 
est distribué sous les termes de la licence du Projet de documentation 
Linux (LDP). Cette licence est ci-incluse par référence&nbsp;: <ulink 
url="http://www.ibiblio.org/LDP/COPYRIGHT.html"></ulink>.
</para>

<para>
Cette documentation est libre. Elle est distribuée dans l'espoir d'être
utile, mais <emphasis>sans aucune garantie</emphasis>&nbsp;; sans même la
garantie implicite de <emphasis>valeur marchande</emphasis> ou de
<emphasis>correspondre à un but particulier</emphasis>.
</para>

<para>
Vous utilisez les informations contenues dans ce document à vos
propres risques. Nous déclinons toute responsabilité quant à son
contenu. L'utilisation des concepts, des exemples ou de tout autre
contenu se fait entièrement à vos propres risques.
</para>

<para>
Tous les droits sont détenus par leurs propriétaires respectifs, sauf
mention contraire explicite. L'utilisation d'un terme dans ce document
ne constitue pas une limitation à sa validité en tant que marque.
</para>

<para>
Le fait de citer un produit ou une marque particulière ne constitue
pas un endossement.
</para>

<para>
Il est fortement conseillé d'effectuer une sauvegarde de votre système
avant une installation importante ainsi qu'à intervalles réguliers.
</para>

</sect2>

<sect2>

<title>Notes du traducteur</title>

<para>
Correspondances anglais/français utilisées dans la traduction&nbsp;:
</para>
<itemizedlist>
<listitem><para>I/O&nbsp;: E/S, entrées/sorties.</para></listitem>
<listitem><para>backup&nbsp;: archive.</para></listitem>
<listitem><para>boot loader&nbsp;: chargeur, lanceur.</para></listitem>
<listitem><para>boot&nbsp;: amorce, amorcer, démarrage, démarrer.</para></listitem>
<listitem><para>boot/root disk&nbsp;: disquette d'amorce/racine.</para></listitem>
<listitem><para>dynamic library&nbsp;: bibliothèque partagée.</para></listitem>
<listitem><para>filesystem&nbsp;: système de fichiers, système.</para></listitem>
<listitem><para>inode&nbsp;: i-n&oelig;ud.</para></listitem>
<listitem><para>library&nbsp;: bibliothèque.</para></listitem>
<listitem><para>loopback device&nbsp;: périphérique de boucle.</para></listitem>
<listitem><para>package&nbsp;: paquetage.</para></listitem>
<listitem><para>path&nbsp;: chemin.</para></listitem>
<listitem><para>ramdisk&nbsp;: disque virtuel en mémoire, disque mémoire.</para>
</listitem>
<listitem><para>root device&nbsp;: périphérique racine.</para></listitem>
<listitem><para>root&nbsp;: racine.</para></listitem>
<listitem><para>runlevel&nbsp;: niveau d'exécution.</para></listitem>
<listitem><para>swap&nbsp;: pagination.</para></listitem>
</itemizedlist>

</sect2>
</sect1>

<sect1>

<title>Introduction</title>

<para>
Les disques d'amorce Linux sont utiles dans nombre de situations,
telles que&nbsp;:
</para>

<itemizedlist>
<listitem><para>Tester un nouveau noyau&nbsp;;</para></listitem>
<listitem><para>Redémarrer après un problème de disque&nbsp;: tout depuis la
perte d'un secteur d'amorce à l'atterrissage d'une tête de lecture sur
le disque&nbsp;;
</para></listitem>
<listitem><para>Réparer un système endommagé. Une petite erreur en tant
que root peut rendre le système inutilisable, et il peut alors être
nécessaire de démarrer depuis une disquette pour corriger le problème&nbsp;;
</para></listitem>
<listitem><para>Mettre à jour des fichiers critiques du système, tels
que <filename>libc.so</filename>.
</para></listitem>
</itemizedlist>

<para>
Les disques d'amorce peuvent être obtenus de différentes manières&nbsp;:
</para>

<itemizedlist>
<listitem><para>Utiliser ceux d'une distribution telle que la Slackware.
Cela vous permettra au moins de démarrer&nbsp;;
</para></listitem>
<listitem><para>Utiliser un paquetage de création de disques de secours,
prévus pour les cas d'urgence&nbsp;;
</para></listitem>
<listitem><para>Apprendre ce que nécessite le fonctionnement de chaque
type de disque, puis créer les vôtres.
</para></listitem>
</itemizedlist>

<para>
Certaines personnes choisissent la dernière solution afin de tout
faire eux-mêmes. Ainsi, si quelque chose ne marche plus, ils peuvent
se débrouiller pour corriger le problème. Et c'est un excellent moyen
pour apprendre le fonctionnement d'un système Linux.
</para>

<para>
Ce document suppose une certaine familiarité avec les concepts
d'administration d'un système Linux. Par exemple, vous devez connaître
les répertoires, les systèmes de fichiers, les disquettes. Vous devez
savoir utiliser <command>mount</command> et <command>df</command>, à
quoi servent les fichiers <filename>/etc/passwd</filename> et
<filename>fstab</filename> et quelle tête ils ont. Enfin, vous devez
savoir que la plupart des commandes dans ce <foreignphrase>howto</foreignphrase> doivent être exécutées
en tant que root.
</para>
<para>
Créer vos propres disquettes d'amorce à partir de zéro peut être
compliqué. Si vous n'avez pas lu la FAQ Linux et autres documents du
même genre, tels que le <foreignphrase>howto</foreignphrase> d'installation Linux et le Guide
d'installation de Linux, vous ne devriez pas essayer de créer des
disques d'amorce. Si vous souhaitez juste créer des disques pour
prévenir les cas urgents, il est <emphasis>bien</emphasis> plus simple
d'en récupérer des préfabriqués. Lisez l'appendice <xref
linkend="distbootdisks"/> ci-dessous pour savoir où en trouver.
</para>
</sect1>
<sect1><title>Disques d'amorce et démarrage</title>
<indexterm><primary>démarrage, fonctionnement du</primary></indexterm>
<para>
Un disque d'amorce est essentiellement un système Linux miniature et
auto-suffisant contenu sur une disquette. Il doit pouvoir effectuer
nombre d'opérations possibles sur un système Linux de taille
normale. Avant d'essayer d'en créer un, vous devez comprendre les
bases du démarrage de Linux. Nous en faisons ici une présentation qui
devrait suffire à la compréhension de la suite du document. Bien des
détails ou des possibilités ont été omis.
</para>
<sect2 id="boot"><title>Démarrage</title>
<indexterm><primary>secteur d'amorce</primary></indexterm>
<para>
Tous les PC démarrent en exécutant du code situé en mémoire morte (à
savoir, le <acronym>BIOS</acronym>) afin de charger le secteur situé au
secteur 0, cylindre 0 du <emphasis>disque d'amorce</emphasis>. Celui-ci
est habituellement le premier lecteur de disquette (appelé
<emphasis>A:</emphasis> sous DOS et <filename>/dev/fd0</filename> sous
Linux). Le <acronym>BIOS</acronym> essaye alors d'exécuter ce secteur.
Sur la plupart des disques d'amorce, le secteur 0, cylindre 0 contient&nbsp;:
</para>
<itemizedlist>
<listitem><para>soit le code d'un chargeur tel que
<command>LILO</command>, qui trouve le noyau, le charge et l'exécute
pour réaliser le démarrage proprement dit,
</para></listitem>
<listitem><para>soit le début du noyau d'un système d'exploitation, tel
que Linux.
</para></listitem>
</itemizedlist>
<para>
Si un noyau Linux a été copié directement sur une disquette, le
premier secteur du disque sera le premier secteur du noyau Linux
lui-même. Ce premier secteur continuera le démarrage en chargeant le
reste du noyau depuis le périphérique d'amorce.
</para>
<para>
Une fois que le noyau est complètement chargé, il effectue certaines
initialisations de périphériques ainsi que de ses données internes.  Une
fois qu'il est complètement initialisé, il consulte un endroit
particulier dans son image appelé le <emphasis>mot disque
mémoire</emphasis>. Ce mot précise comment et où trouver le système de
fichiers racine.  Un système de fichiers racine est simplement celui qui
est monté en tant que &laquo;&nbsp;/&nbsp;&raquo;. Il faut dire au noyau où trouver ce système
racine&nbsp;; s'il ne peut trouver d'image à charger, il s'arrête.
</para>
<para>
Dans certains cas au démarrage (souvent lors du démarrage depuis une
disquette), le système de fichiers racine est chargé dans un
<command>disque mémoire</command>, auquel le système accède ensuite en
mémoire comme s'il s'agissait d'un vrai disque. Il y a deux raisons à
un tel chargement en mémoire. Premièrement, la mémoire vive est de
plusieurs ordres de magnitude plus rapide qu'une disquette, et le
système est donc rapide&nbsp;; deuxièmement, le noyau peut charger un
<emphasis>système de fichiers compressé</emphasis> depuis la disquette
et le décompresser en mémoire, permettant ainsi de stocker plus de
fichiers sur la disquette.
</para>
<para>
Une fois le système de fichiers racine chargé et monté, vous voyez un
message tel que&nbsp;:
</para>

<programlisting format="linespecific">
VFS: Mounted root (ext2 filesystem) readonly.
</programlisting>

<indexterm
remap="ncdx"><primary><literal>init</literal></primary></indexterm>
<indexterm
remap="ncdx"><primary><literal>inittab</literal></primary></indexterm>
<indexterm
remap="ncdx"><primary><literal>sysinit</literal></primary></indexterm>
<para>
À ce moment, le système trouve le programme <command>init</command> dans
le système racine (dans <filename>/bin</filename> ou
<filename>/sbin</filename>) et l'exécute. <command>init</command> lit sa
configuration dans <filename>/etc/inittab</filename>, cherche une ligne
nommée <emphasis>sysinit</emphasis>, et exécute le script indiqué. Le
script <command>sysinit</command> est en général un fichier du genre
<filename>/etc/rc</filename> ou <filename>/etc/init.d/boot</filename>.
Le script est un ensemble de commandes shell qui mettent en place les
services de base du système, tels que&nbsp;:
</para>
<itemizedlist>
<listitem><para>Lancer <command>fsck</command> sur tous les disques
;</para></listitem>
<listitem><para>Charger les <emphasis>modules</emphasis> nécessaires du
noyau&nbsp;;</para></listitem>
<listitem><para>Lancer la pagination&nbsp;;</para></listitem>
<listitem><para>Initialiser le réseau&nbsp;;</para></listitem>
<listitem><para>Monter les disques indiqués dans
<filename>fstab</filename>.</para></listitem>
</itemizedlist>
<para>
Ce script appelle lui-même souvent nombre d'autres scripts pour réaliser
une initialisation modulaire. Par exemple, dans la structure SysVinit
habituelle, le répertoire <filename>/etc/rc.d/</filename> contient une
structure complexe de sous-répertoires dont les fichiers indiquent
comment lancer et arrêter la plupart des services du système. En revanche,
sur un disque d'amorce, le script <command>sysinit</command> est
souvent très simple.
</para>
<para>
Quand le script <command>sysinit</command> se termine, le contrôle
revient à <command>init</command>, qui entre alors dans le
<emphasis>niveau d'exécution par défaut</emphasis>, spécifié dans
<filename>inittab</filename> par le mot clé
<emphasis>initdefault</emphasis>. La ligne du niveau d'exécution indique
en général un programme tel que <command>getty</command>, responsable de
la gestion des communications par la console ou les
<filename>tty</filename>. C'est le programme <command>getty</command>
qui affiche l'invite habituelle <emphasis>login:</emphasis>. Lui-même
exécute à son tour le programme <command>login</command> pour gérer la
validation du login et mettre en place la session de l'utilisateur.
</para>
</sect2>
<sect2><title>Types de disques</title>
<para>
Après avoir revu les bases du démarrage, nous pouvons définir les
différents types de disques mis en jeu. Ces disques sont classés en
quatre catégories. Ça et là dans le document, on emploie le terme
<emphasis>disque</emphasis> pour désigner une disquette, sauf précision
contraire, bien que la majeure partie de la discussion puisse également
s'appliquer à des disques durs.
</para>
<variablelist>
<varlistentry><term>Amorce</term><listitem>
<para>
Un disque contenant un noyau pouvant être amorcé. Il peut
être utilisé pour démarrer le noyau, qui pourra alors charger un
système racine depuis un autre disque. Il est en général nécessaire
d'indiquer au noyau où se trouve ce système racine.
</para>
<para>
Souvent un disque d'amorce charge le système racine depuis une autre
disquette, mais il est possible de lui indiquer un disque dur d'où il
chargera le système racine à la place. Souvent, c'est dans le but de
tester un nouveau noyau (d'ailleurs, <command>make zdisk</command> crée
un tel disque d'amorce automatiquement à partir du code source du
noyau).
</para></listitem></varlistentry>
<varlistentry><term>Racine</term><listitem>
<para>
Un disque avec un système de fichiers contenant les
fichiers nécessaires au fonctionnement d'un système Linux. Un tel
disque ne contient pas forcément un noyau ou un chargeur.
</para>
<indexterm><primary>disque racine</primary></indexterm>
<para>
Un disque racine peut être utilisé pour faire tourner le système
indépendamment de tout autre disque, une fois le noyau amorcé. En
général le disque racine est copié automatiquement vers un disque
mémoire. Cela permet un accès au disque racine bien plus rapide, et
libère le lecteur pour une disquette d'utilitaires.
</para></listitem></varlistentry>
<varlistentry><term>Amorce/racine</term>
<listitem><para> Un disque contenant à la fois un noyau
<indexterm><primary>disque d'amorce/racine</primary></indexterm>
et un système de fichiers racine. Autrement dit, il contient tout ce
qui est nécessaire au démarrage et au fonctionnement d'un système
Linux sans disque dur. L'avantage de ce type de disque est sa
compacité&nbsp;: tout ce dont on a besoin est sur un seul
disque. Néanmoins, la taille toujours plus importante des programmes
implique une difficulté croissante pour tout faire tenir sur une seule
disquette, même avec de la compression.
</para></listitem></varlistentry>
<varlistentry><term>Utilitaire</term><listitem>
<para> Un disque contenant un système de fichier non destiné
à être monté en tant que racine. Il s'agit d'un disque de données
supplémentaires. Vous pouvez utiliser ce genre de disque pour rajouter
des utilitaires, quand vous en avez trop pour un seul disque amorce.
<indexterm><primary>disquette utilitaire</primary></indexterm>
</para></listitem></varlistentry>
</variablelist>
<para>
En général, lorsque l'on parle de &laquo;&nbsp;construire un disque 
d'amorce&nbsp;&raquo;, c'est de la création des parties amorce (noyau) 
et racine 
(fichiers) qu'il est question, soit en un seul morceau (un seul disque 
amorce/racine), soit séparément (un disque amorce et un racine). 
L'approche la plus flexible pour des disquettes de secours est 
d'utiliser des disquettes amorce et racine séparées, et une ou plusieurs 
disquettes utilitaires pour supporter le trop-plein.
</para>
</sect2>
</sect1>
<sect1 id="buildroot"><title>Construire un système racine</title>
<para>
Pour créer un système racine, il faut sélectionner les fichiers
nécessaires au système pour fonctionner. Dans cette section nous
décrivons comment créer un <emphasis>système racine
compressé</emphasis>. Une option moins courante est de créer un système
non compressé sur une disquette que l'on monte directement&nbsp;; cette
alternative est décrite dans la <xref linkend="nonramdiskroot"/>.
</para>
<sect2><title>Aperçu</title>

<para>
Un système racine doit contenir tout ce qui est nécessaire au bon
fonctionnement d'un système Linux complet. Pour cela, le disque doit
contenir un système Linux minimum&nbsp;:
</para>

<itemizedlist>

<listitem><para>La structure de base des fichiers&nbsp;;</para></listitem>

<listitem><para>Un ensemble minimum de répertoires&nbsp;:
<filename>/dev</filename>, <filename>/proc</filename>,
<filename>/bin</filename>, <filename>/etc</filename>,
<filename>/lib</filename>, <filename>/usr</filename>,
<filename>/tmp</filename>&nbsp;;
</para></listitem>

<listitem><para>Un ensemble d'utilitaires de base&nbsp;:
<command>sh</command>, <command>ls</command>, <command>cp</command>,
<command>mv</command>, et cætera&nbsp;;
</para></listitem>

<listitem><para>Un ensemble minimum de fichiers de 
configuration&nbsp;:
<command>rc</command>, <filename>inittab</filename>,
<filename>fstab</filename>, et cætera&nbsp;;
</para></listitem>

<listitem><para>Des périphériques&nbsp;: <filename>/dev/hd*</filename>,
<filename>/dev/tty*</filename>, <filename>/dev/fd0</filename>, et cætera&nbsp;;
</para></listitem>

<listitem><para>Des bibliothèques d'exécution fournissant les fonctions
de base nécessaires aux utilitaires.</para></listitem>

</itemizedlist>
<para>
Bien sûr, n'importe quel système devient utile dès que l'on peut faire
tourner quelque chose dessus, et une disquette racine ne devient en
général utilisable que lorsque vous pouvez faire quelque chose du genre
:
</para>
<itemizedlist>
<listitem><para>Contrôler un système de fichiers sur un autre disque&nbsp;;
par exemple, pour contrôler le système racine de votre disque dur, vous
devez pouvoir démarrer Linux depuis un autre disque, telle qu'une
disquette racine. Vous pouvez alors lancer <command>fsck</command> sur
votre disque racine habituel tant qu'il n'est pas monté&nbsp;;
</para></listitem>
<listitem><para>Récupérer tout ou partie de votre disque racine initial
à partir d'une sauvegarde en utilisant des utilitaires d'archivage et de
compression tels que <command>cpio</command>, <command>tar</command>,
<command>gzip</command> et <command>ftape</command>.
</para></listitem>
</itemizedlist>
<para>
Nous décrirons comment construire un système
<emphasis>compressé</emphasis>, ainsi appelé car il est compressé sur
disque et qu'une fois démarré, le noyau le décompresse dans un disque
mémoire.  <indexterm><primary>système racine,
compressé</primary></indexterm> Avec un système compressé vous pouvez
faire tenir beaucoup de fichiers (à peu près six méga-octets) sur une
disquette standard de 1440&nbsp;ko. Puisque le système de fichiers est 
bien
plus gros que la disquette, il ne peut être construit directement sur la
disquette. Il nous faut le construire ailleurs et le compresser avant de
le copier sur la disquette.
</para>
</sect2>
<sect2 id="creatingrootfs"><title>Création du système de fichiers</title>
<para>
Pour créer un tel système racine, il vous faut un autre périphérique
capable de stocker tous les fichiers avant leur compression. Ce
périphérique doit pouvoir contenir à peu près quatre
méga-octets. Plusieurs solutions s'offrent à vous&nbsp;:
</para>
<itemizedlist>
<listitem><para>Utiliser un <emphasis>disque mémoire</emphasis>
(PÉRIPHÉRIQUE = <filename>/dev/ram0</filename>). Dans ce cas, la mémoire
est utilisée pour simuler un disque physique. Le disque mémoire doit
être suffisamment grand pour contenir un système de fichiers de la bonne
taille. Si vous utilisez <command>LILO</command>, cherchez dans votre
fichier de configuration (<filename>/etc/lilo.conf</filename>) une ligne
du type&nbsp;:
</para>

<programlisting format="linespecific">
RAMDISK_SIZE = nnn
</programlisting>

<indexterm><primary>RAMDISK_SIZE, paramètre de LILO</primary></indexterm>
<para>
qui détermine combien de mémoire peut être au plus allouée à un disque
mémoire. La valeur par défaut est de 4096&nbsp;ko, ce qui devrait
suffire. Il ne sert probablement à rien de créer un tel disque mémoire
sur une machine possédant moins de 8&nbsp;Mo de RAM.
</para>
<para>
Vérifiez que vous avez un périphérique tel que
<filename>/dev/ram0</filename>, <filename>/dev/ram</filename> ou
<filename>/dev/ramdisk</filename>. Si ce n'est pas le cas, créez
<filename>/dev/ram0</filename> avec mknod (numéro majeur 1, numéro
mineur 0).
</para></listitem>
<listitem><para>Une partition de disque dur inutilisée et assez grande
(plusieurs méga-octets) est aussi une bonne solution.
</para></listitem>
<listitem><para>Utiliser un <emphasis>périphérique de boucle
(loopback)</emphasis>, qui permet d'utiliser un fichier comme s'il
s'agissait d'un périphérique normal. Avec un périphérique de boucle,
vous pouvez créer un fichier de 3 méga-octets sur votre disque dur et
construire le système de fichiers dedans.
</para>
<para>
Tapez <command>man losetup</command> pour savoir comment utiliser un
périphérique de boucle. Si vous n'avez pas <command>losetup</command>,
vous pouvez le récupérer, ainsi que des versions compatibles de
<command>mount</command> et <command>umount</command>, dans le paquetage
<emphasis>util-linux</emphasis> disponible dans le répertoire <ulink
url="ftp://ftp.win.tue.nl/pub/linux-local/utils/util-linux/">
ftp://ftp.win.tue.nl/pub/linux-local/utils/util-linux/</ulink>.
</para>
<para>
Si vous n'avez pas de périphérique de boucle
(<filename>/dev/loop0</filename>, <filename>/dev/loop1</filename>, et cætera)
sur votre système, vous devez en créer un avec <command>mknod /dev/loop0
b 7 0</command>. Une fois les exécutables <command>mount</command> et
<command>umount</command> spéciaux installés, créez un fichier
temporaire sur le disque dur suffisamment grand (par exemple,
<filename>/tmp/fsfile</filename>). Vous pouvez utiliser une commande du
type&nbsp;:
</para>

<programlisting format="linespecific">
dd if=/dev/zero of=/tmp/fsfile bs=1k count=nnn
</programlisting>

<para>
pour créer un fichier de <emphasis>nnn</emphasis> blocs.
</para>
<para>
Utilisez le nom du fichier à la place de PÉRIPHÉRIQUE ci-dessous. Quand
vous exécutez une commande <command>mount</command>, vous devez inclure
l'option <option>-o loop</option> pour dire au programme d'utiliser un
périphérique de boucle.  <indexterm><primary>périphérique de boucle
(loopback)</primary></indexterm> Par exemple&nbsp;:
</para>

<programlisting format="linespecific">
mount -o loop -t ext2 /tmp/fsfile /mnt
</programlisting>

<para>
va monter <filename>/tmp/fsfile</filename> (par périphérique de boucle)
sur le point de montage <filename>/mnt</filename>. Un coup de
<command>df</command> le confirmera.
</para></listitem>
</itemizedlist>
<para>
Après avoir choisi une de ces options, préparez le PÉRIPHÉRIQUE avec&nbsp;:
</para>

<programlisting format="linespecific">
dd if=/dev/zero of=PÉRIPHÉRIQUE bs=1k count=4096
</programlisting>

<para>
Cette commande initialise à zéro le périphérique. Cette étape est
importante pour la compression ultérieure du système de fichiers, afin
que toutes les portions inutilisées soient remplies de zéros pour une
compression maximum.  Gardez cela à l'esprit si vous déplacez ou effacez
des fichiers sur le système de fichiers. Le système de fichiers va
désallouer correctement les blocs, <emphasis>mais ne va pas les
initialiser à zéro à nouveau </emphasis>. Si vous effectuez beaucoup
d'effacements et de copies, votre système de fichiers compressé risque
d'être bien plus grand que nécessaire.
</para>
<indexterm><primary>i-n&oelig;uds, allocation</primary></indexterm>
<para>
Ensuite, créez le système de fichiers. Le noyau Linux sait charger
automatiquement deux types de système de fichiers dans un disque mémoire
: minix et ext2, avec une préférence pour ext2. Si vous le choisissez,
vous voudrez peut-être utiliser l'option <option>-i</option> afin de
créer plus d'i-n&oelig;uds que par défaut&nbsp;; <option>-i 2000</option> est une
bonne valeur qui vous évitera de tomber à court d'i-n&oelig;uds. Vous pouvez
sinon économiser des i-n&oelig;uds en supprimant pas mal de fichiers
<filename>/dev/</filename> inutiles. <command>mke2fs</command> crée par
défaut 360 i-n&oelig;uds sur une disquette de 1,44&nbsp;Mo. Je trouve 
120 i-n&oelig;uds largement suffisants pour ma disquette racine 
de secours, mais si vous conservez tous les périphériques dans le 
répertoire <filename>/dev</filename> vous dépasserez facilement les 360.
L'utilisation d'un système racine compressé permet de créer un système
de fichiers plus grand, contenant donc plus d'i-n&oelig;uds par défaut, mais
vous pourrez quand même vouloir réduire le nombre de fichiers ou
augmenter le nombre d'i-n&oelig;uds.
</para>
<para>
Vous allez donc taper une commande du genre&nbsp;:
</para>

<programlisting format="linespecific">
mke2fs -m 0 -i 2000 <replaceable>PÉRIPHÉRIQUE</replaceable>
</programlisting>

<para>
(Si vous utilisez un périphérique de boucle, le fichier que vous
utilisez doit être indiqué à la place de ce 
<replaceable>PÉRIPHÉRIQUE</replaceable>. <command>mke2fs</command> vous 
demandera alors si vous voulez vraiment faire cela&nbsp;; répondez oui.)
</para>

<indexterm><primary>périphérique de boucle (loopback)</primary></indexterm>

<para>
La commande <command>mke2fs</command> détectera automatiquement l'espace
disponible et se configurera selon ce dernier. Le paramètre <option>-m 0
</option> permet de ne pas réserver d'espace pour root, et laisse donc plus
d'espace disponible sur le disque.
</para>

<para>
Ensuite, montez le périphérique&nbsp;:
</para>

<programlisting format="linespecific">
mount -t ext2 PÉRIPHÉRIQUE /mnt
</programlisting>

<para>
(Vous devez créer un point de montage <filename>/mnt</filename> s'il
n'existe pas encore.) Dans les sections suivantes, tous les répertoires
destination sont supposés relatifs à <filename>/mnt</filename>.
</para>
</sect2>
<sect2><title>Remplissage du système de fichiers</title>
<para>
Voici un minimum raisonnable de répertoires à créer sur votre système
racine 
<footnote>
<para>
La structure de répertoires présentée ici concerne une disquette racine
seule.  Les vrais systèmes Linux obéissent à un ensemble de règles bien plus
complexes et contrôlées, appelé le <ulink 
url="http://www.pathname.com/fhs/2.2/">Filesystem Hierarchy 
Standard</ulink>, pour déterminer où les fichiers doivent aller.
</para>
</footnote>&nbsp;:
</para>
<itemizedlist>
<listitem><para> <filename>/dev</filename>&nbsp;: Périphériques, nécessaires
aux E/S&nbsp;;</para></listitem>
<listitem><para> <filename>/proc</filename>&nbsp;: Répertoire de base
nécessaire au système de fichiers proc&nbsp;;</para></listitem>
<listitem><para> <filename>/etc</filename>&nbsp;: Fichiers de configuration
du système&nbsp;;</para></listitem>
<listitem><para> <filename>/sbin</filename>&nbsp;: Exécutables systèmes
critiques&nbsp;;</para></listitem>
<listitem><para> <filename>/bin</filename>&nbsp;: Exécutables de base
considérés comme partie intégrante du système&nbsp;;</para></listitem>
<listitem><para> <filename>/lib</filename>&nbsp;: Bibliothèques partagées
nécessaires à l'exécution des programmes&nbsp;;</para></listitem>
<listitem><para> <filename>/mnt</filename>&nbsp;: Un point de montage pour la
maintenance des autres disques&nbsp;;</para></listitem>
<listitem><para> <filename>/usr</filename>&nbsp;: Utilitaires et applications
supplémentaires.</para></listitem>
</itemizedlist>
<indexterm remap="ncdx"><primary><literal>proc</literal></primary></indexterm>
<indexterm remap="ncdx"><primary><literal>mnt</literal></primary></indexterm>
<indexterm remap="ncdx"><primary><literal>usr</literal></primary></indexterm>
<para>
Trois de ces répertoires resteront vides sur les systèmes racine, il
suffit donc de les créer avec <command>mkdir</command>. Le répertoire
<filename>/proc</filename> n'est qu'une base sous laquelle le système
proc est placé. <filename>/mnt</filename> et <filename>/usr</filename>
ne sont que des points de montage utilisés une fois que le système
amorce/racine tourne. Encore une fois, il suffit de créer ces
répertoires.
</para>
<para>
Les quatre autres répertoires sont décrits dans les sections suivantes.
</para>

<sect3><title><filename>/dev</filename></title>
<para>
<indexterm><primary>périphériques, répertoire de</primary></indexterm>
Tous les systèmes Linux ont besoin d'un répertoire
<filename>/dev</filename> contenant un fichier spécial par périphérique
accessible au système. Le répertoire en lui-même est normal, et peut
être créé avec <command>mkdir</command> de la manière habituelle. Les
fichiers spéciaux de périphérique doivent par contre être créés
différemment, à l'aide de la commande <command>mknod</command>.
</para>
<para>
Il y a un raccourci par contre&nbsp;: copiez le contenu de votre répertoire
<filename>/dev</filename> existant, puis supprimez ceux dont vous n'avez
pas besoin. Il suffit juste de copier les fichiers spéciaux avec
l'option <option>-R</option>. Cela copie le répertoire sans tenter de
copier le contenu des fichiers. <emphasis>Attention à bien utiliser un R
en majuscule&nbsp;!</emphasis> Si vous utilisez l'option en minuscule
<option>-r</option>, vous allez vous retrouver en train de copier le
contenu complet de votre disque dur &mdash; ou au moins tout ce que pourra en
contenir une disquette&nbsp;! Prenez donc vos précautions, et utilisez par
exemple les commandes&nbsp;:
</para>

<programlisting format="linespecific">
cp -dpR /dev/fd[01]* /mnt/dev
cp -dpR /dev/tty[0-6] /mnt/dev
</programlisting>

<para>
en supposant que la disquette est montée sur <filename>/mnt</filename>.
Les options <option>dp</option> demandent la copie des liens symboliques
en tant que lien, plutôt que celle du fichier qui se trouve au bout de
celui-ci, et la conservation des attributs originaux des fichiers, pour
garder les bons propriétaires.
</para>
<para>
Si vous voulez le faire vous-mêmes, utilisez <command>ls -l</command>
pour afficher les numéros majeurs et mineurs des périphériques qui vous
intéressent, et créez-les sur la disquette en utilisant
<command>mknod</command>.
</para>
<para>
Quelle que soit la manière retenue pour copier les périphériques, il
faut vérifier que tous les périphériques dont vous aurez besoin sont
bien présents sur la disquette de secours. Par exemple,
<command>ftape</command> utilise les périphériques de bande, qu'il vous
faudra donc tous copier si vous comptez utiliser votre lecteur de bande
depuis le disque amorce.
</para>
<para>
À noter qu'un i-n&oelig;ud est nécessaire pour chaque fichier de
périphérique, et que les <emphasis>i-n&oelig;uds</emphasis> sont parfois une
ressource rare, spécialement sur les systèmes de fichiers sur disquette.
Il n'est donc pas idiot d'enlever du répertoire
<filename>/dev</filename> de la disquette tous les fichiers de
périphérique dont vous n'avez pas besoin. Bien des périphériques ne sont
clairement pas nécessaires sur des systèmes spécifiques. Par exemple, si
vous n'avez pas de disques SCSI vous pouvez tranquillement enlever tous
les fichiers commençant par <filename>sd</filename>. De même, si vous ne
comptez pas utiliser de port série vous pouvez supprimer tous les
fichiers commençant par <filename>ttyS</filename>.
</para>
<para>
Si, en construisant le système de fichiers, vous obtenez l'erreur&nbsp;:
</para>

<programlisting format="linespecific">
No space left on device
</programlisting>

<para>
et que la commande <command>df</command> indique qu'il reste de l'espace
disponible, c'est sans doutes qu'il n'y a plus d'i-n&oelig;ud disponible.
Un <command>df -i</command> affichera l'utilisation des i-n&oelig;uds.
</para>
<para>
<emphasis>N'oubliez pas d'inclure les fichiers suivants dans le
répertoire&nbsp;:</emphasis> <filename>console</filename>,
<filename>kmem</filename>, <filename>mem</filename>,
<filename>null</filename>, <filename>ram0</filename>,
<filename>tty1</filename>.
</para>
</sect3>
<sect3><title><filename>/etc</filename></title>
<indexterm><primary>etc, répertoire</primary></indexterm>
<para>
Ce répertoire doit contenir un certain nombre de fichiers de
configuration. Ce qu'il devrait contenir dépend des programmes que vous
avez l'intention d'exécuter. Sur la plupart des systèmes, on peut les
répartir en trois groupes&nbsp;:
</para>
<orderedlist>
<listitem><para>Nécessaires à tout moment, par exemple
<filename>rc</filename>, <filename>fstab</filename>,
<filename>passwd</filename>&nbsp;;</para></listitem>
<listitem><para>Peut-être nécessaires, mais on n'en est pas sûr
;</para></listitem>
<listitem><para>Du bazar oublié là.</para></listitem>
</orderedlist>
<para>
Les fichiers non essentiels peuvent être identifiés avec la
commande&nbsp;:
</para>

<programlisting format="linespecific">
ls -ltru
</programlisting>

<para>
Les fichiers sont classés dans l'ordre inverse de dernière date
d'accès, donc tout fichier qui n'est jamais lu peut être exclu d'une
disquette racine.
</para>
<para>
Sur mes disquettes racine, je n'ai que 15 fichiers de
configuration. Mon travail se réduit alors à gérer trois groupes de
fichiers&nbsp;:
</para>
<orderedlist>
<listitem><para>Ceux que je dois configurer pour un système d'amorce et
racine&nbsp;:
  <orderedlist>
  <listitem><para><filename>rc.d/*</filename>&nbsp;: scripts de démarrage du
système et de changement de niveau d'exécution&nbsp;;</para></listitem>
  <listitem><para><filename>fstab</filename>&nbsp;: liste des systèmes de
fichiers à monter&nbsp;;</para></listitem>
  <listitem><para><filename>inittab</filename>&nbsp;: paramètres pour le
processus <command>init</command>, le premier à être lancé au
démarrage.</para></listitem>
  <listitem><para><filename>gettydefs</filename>&nbsp;: paramètres pour le
processus <command>init</command>, le premier à être lancé au
démarrage.</para></listitem>
  </orderedlist>
</para></listitem>
<listitem><para>Ceux que je dois nettoyer pour un système d'amorce et
racine&nbsp;:
<orderedlist>
<listitem><para><filename>passwd</filename>&nbsp;: liste des utilisateurs,
des répertoires utilisateurs, et cætera&nbsp;;</para></listitem>
<listitem><para><filename>group</filename>&nbsp;: groupes d'utilisateurs
;</para></listitem>
<listitem><para><filename>shadow</filename>&nbsp;: mots de passe cachés des
utilisateurs. Il se peut que vous n'ayez pas ce fichier
;</para></listitem>
<listitem><para><filename>termcap</filename>&nbsp;: la base de données de
fonctionnalités des terminaux.</para></listitem>
</orderedlist>
Si la sécurité est importante, <filename>passwd</filename> et
<filename>shadow</filename> doivent être nettoyés pour ne pas copier de
mots de passe d'utilisateurs hors du système et pour qu'en cas de
démarrage sur disquette, les logins indésirables soient rejetés.
<indexterm><primary>récupération de fichiers</primary></indexterm>
</para>
<para>
Assurez-vous que <filename>passwd</filename> contienne au moins
<emphasis>root</emphasis>. Si vous comptez donner accès à d'autres
utilisateurs, vérifiez l'existence de leurs répertoires utilisateurs et
de leurs shells.
</para>
<para>
<filename>termcap</filename>, la base de données de terminaux, fait en
général plusieurs centaines de kilo-octets. Vous devrez faire du ménage
dans la version de votre disquette d'amorce/racine pour ne conserver que
le ou les terminaux que vous utilisez, ce qui se réduit en général à
l'entrée <emphasis>linux</emphasis> ou
<emphasis>linux-console</emphasis>.
</para></listitem>
<listitem><para>Le reste. Ils fonctionnent très bien tels quel, je ne
les modifie donc pas.
</para></listitem>
</orderedlist>
<para>
Parmi tout cela, je n'ai en réalité que deux fichiers à configurer, et
ils ne doivent contenir qu'étonnamment peu de choses.
</para>
<itemizedlist>
<listitem><para><filename>rc</filename> doit contenir&nbsp;:
</para>

<programlisting format="linespecific">
#!/bin/sh
/bin/mount -av
/bin/hostname Kangaroo
</programlisting>

<para>
Vérifiez qu'il est exécutable, qu'il contient bien une ligne
<command>#!/bin/sh</command> au début et que ce sont les bons
répertoires. Il n'est pas réellement nécessaire de lancer
<command>hostname</command>, mais cela donne juste une meilleure allure.
</para>
</listitem>
<listitem><para><filename>fstab</filename> doit au moins contenir&nbsp;:
</para>

<programlisting format="linespecific">
/dev/ram0       /       ext2    defaults
/dev/fd0        /       ext2    defaults
/proc           /proc   proc    defaults
</programlisting>

<para>
Vous pouvez copier des lignes de votre vrai <filename>fstab</filename>, 
mais vous ne devriez pas monter automatiquement de partitions de
votre disque dur&nbsp;; utilisez le mot clé <emphasis>noauto</emphasis> pour
celles-là. Votre disque peut être endommagé ou mort quand vous utilisez
le disque d'amorce.
</para></listitem>
</itemizedlist>
<para>
Votre <filename>inittab</filename> doit être modifié pour que la ligne
<command>sysinit</command> lance <command>rc</command> ou quelque autre
script basique d'amorce. De plus, si vous ne souhaitez pas que les
utilisateurs se loguent sur les ports série, commentez toutes les
entrées <command>getty</command> qui font référence à des périphériques
<filename>ttys</filename> ou <filename>ttyS</filename> à la fin de la
ligne. Laissez les ports <filename>tty</filename> pour pouvoir vous
connecter sur la console.
</para>
<para>
Un fichier <filename>inittab</filename> minimal contient ce qui suit&nbsp;:
</para>

<programlisting format="linespecific">
id:2:initdefault
si::sysinit:/etc/rc
1:2345:respawn:/sbin/getty 9600 tty1
2:23:respawn:/sbin/getty 9600 tty2
</programlisting>

<para>
Le fichier <filename>inittab</filename> décrit ce que va lancer le
système dans divers états, dont le démarrage, le passage en mode multi
utilisateurs, et cætera. Attention aux noms de fichiers référencés dans
<filename>inittab</filename>&nbsp;; si <command>init</command> ne peut
trouver le programme, le disque d'amorce s'arrêtera, et vous n'aurez
peut-être même pas de message d'erreur.
</para>

<indexterm><primary>chemins d'accès en dur</primary></indexterm>

<para>
Notez que certains programmes ne peuvent être déplacés en raison
d'autres programmes qui référencent en dur leur position. Par exemple
sur mon système, <filename>/etc/shutdown</filename> référence en dur
<filename>/etc/reboot</filename>. Si je déplace
<command>reboot</command> vers <command>/bin/reboot</command>, et que je
lance une commande <command>shutdown</command>, elle va échouer en ne
trouvant pas le fichier <command>reboot</command>.
</para>

<indexterm><primary>etc, répertoire</primary></indexterm>

<para>
Pour le reste, copiez juste tous les fichiers texte de votre répertoire
<filename>/etc</filename>, ainsi que tous les exécutables présents dans
<filename>/etc</filename> dont vous n'êtes pas sûr de pouvoir vous
passer. Basez-vous sur l'exemple de l'<xref linkend="listings"/>.  Il
vous suffira probablement de copier ces fichiers, mais les systèmes
pouvant être très différents, il n'est pas certain que le même ensemble
de fichiers sur votre système soit équivalent aux fichiers listés. La
seule méthode sûre est de partir d'<filename>inittab</filename> et d'en
déduire ce qui est nécessaire.
</para>

<para>
La plupart des systèmes utilisent maintenant un répertoire
<filename>/etc/rc.d/</filename> contenant des scripts shell pour les
différents niveaux d'exécution. Il faut au minimum avoir un script
<command>rc</command> unique, mais il peut être plus simple de carrément
copier <filename>inittab</filename> et le répertoire
<filename>/etc/rc.d</filename> depuis votre système puis de nettoyer les
scripts shell dans le répertoire <filename>rc.d</filename> pour enlever
tous les traitements inutiles pour un système sur disquette.
</para>

</sect3>

<sect3>

<title><filename>/bin</filename> et <filename>/sbin</filename></title>

<para>
<indexterm><primary>bin, répertoire</primary></indexterm>
<indexterm><primary>sbin, répertoire</primary></indexterm>
Le répertoire <filename>/bin</filename> est un endroit pratique pour
tous les utilitaires nécessaires aux opérations de base, tels que
<command>ls</command>, <command>mv</command>, <command>cat</command> et
<command>dd</command>. Voir l'<xref linkend="listings"/> pour un
exemple d'ensemble de fichiers pouvant aller dans les répertoires
<filename>/bin</filename> et <filename>/sbin</filename>. Il ne contient
aucun des utilitaires nécessaires à la récupération d'une sauvegarde,
tels que <command>cpio</command>, <command>tar</command> et
<command>gzip</command>. C'est parce que je place ceux-ci sur une
disquette utilitaire séparée, pour conserver de la place sur la
disquette d'amorce et racine. Une fois la disquette d'amorce/racine
démarrée, elle est copiée sur le disque mémoire, laissant ainsi le
lecteur de disquette libre pour en monter une autre, la disquette
utilitaire. En général je la monte sur <filename>/usr</filename>.
</para>

<para>
La création d'une <emphasis>disquette utilitaire</emphasis> est décrite
ci-dessous dans la <xref linkend="utilitydisk"/> . Il est probablement
souhaitable d'y maintenir une copie des mêmes versions d'utilitaires de
sauvegarde que ceux utilisés pour écrire les sauvegardes, histoire de ne
pas perdre de temps en essayant d'installer des versions qui ne peuvent
pas lire vos bandes de sauvegarde.
</para>
<para>
<emphasis>Vérifiez que vous y mettez les programmes suivants&nbsp;:</emphasis>
<command>init</command>, <command>getty</command> ou un équivalent,
<command>login</command>, <command>mount</command>, un shell capable de
faire tourner votre script <command>rc</command>, un lien de
<command>sh</command> vers le shell en question.
</para>
<indexterm remap="ncdx"><primary><literal>init</literal></primary></indexterm>
<indexterm remap="ncdx"><primary><literal>getty</literal></primary></indexterm>
<indexterm remap="ncdx"><primary><literal>login</literal></primary></indexterm>
<indexterm><primary>shells</primary></indexterm>
</sect3>
<sect3><title><filename>/lib</filename></title>
<para>
<indexterm><primary>bibliothèques, répertoire de</primary></indexterm>
<indexterm><primary>bibliothèques</primary></indexterm>
Vous mettez dans <filename>/lib</filename> les bibliothèques partagées
et les chargeurs nécessaires. Si les bibliothèques nécessaires ne sont pas
trouvées dans <filename>/lib</filename>, le système ne pourra pas
démarrer. Avec de la chance, un message vous expliquera pourquoi.
</para>
<para>
Pratiquement tous les programmes ont au moins besoin de la bibliothèque
<filename>libc</filename>,
<filename>libc.so.</filename><emphasis>N</emphasis>,
<emphasis>N</emphasis> étant le numéro de version courant. Vérifiez
votre répertoire <filename>/lib</filename>,
<filename>libc.so.N</filename> est en général un lien symbolique vers un
fichier avec un numéro de version complet&nbsp;:
</para>

<programlisting format="linespecific">
% ls -l /lib/libc.so*
-rwxr-xr-x   1 root     root      4016683 Apr 16 18:48 libc-2.1.1.so*
lrwxrwxrwx   1 root     root           13 Apr 10 12:25 libc.so.6 -> libc-2.1.1.so*
</programlisting>

<para>
Dans le cas présent, il vous faut <filename>libc-2.1.1.so</filename>.
Pour trouver les autres bibliothèques nécessaires, il faut lancer la
commande <command>ldd</command> sur tous les exécutables que vous
prévoyez de mettre sur la disquette. Par exemple&nbsp;:
</para>

<programlisting format="linespecific">
% ldd /sbin/mke2fs
libext2fs.so.2 => /lib/libext2fs.so.2 (0x40014000)
libcom_err.so.2 => /lib/libcom_err.so.2 (0x40026000)
libuuid.so.1 => /lib/libuuid.so.1 (0x40028000)
libc.so.6 => /lib/libc.so.6 (0x4002c000)
/lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</programlisting>

<para>
Tous les fichiers à droite sont nécessaires. Le fichier peut en
réalité être un lien symbolique.
</para>

<para>
Notez que certaines bibliothèques sont <emphasis>assez
grosses</emphasis> et ne tiendront pas facilement sur votre système
racine. Par exemple, la <filename>libc.so</filename> citée précédemment
fait environ 4 méga-octets. Vous devrez probablement nettoyer les
bibliothèques avant de les copier sur votre système racine.
Reportez-vous à la <xref linkend="slimfast"/> pour plus d'informations.
</para>
<indexterm><primary>chargeurs</primary></indexterm>
<indexterm><primary>ELF</primary></indexterm>
<indexterm><primary>a.out</primary></indexterm>
<indexterm><primary>bibliothèques, nettoyage de</primary></indexterm>
<para>
Il faut également inclure dans <filename>/lib</filename> un chargeur
pour les bibliothèques. Il s'agira soit de <filename>ld.so</filename>
(pour les bibliothèques a.out), soit de <filename>ld-linux.so</filename>
(pour les bibliothèques ELF). Les versions  récentes de
<command>ldd</command> vous indiquent de quel chargeur vous avez besoin,
comme dans l'exemple ci-dessus, mais de plus anciennes versions ne le
font pas forcément. Si vous ne savez pas duquel vous avez besoin,
utilisez la commande <command>file</command> sur la bibliothèque. Par
exemple&nbsp;:
</para>

<programlisting format="linespecific">
% file/lib/libc.so.4.7.2 /lib/libc.so.5.4.33 /lib/libc-2.1.1.so
/lib/libc.so.4.7.2: Linux/i386 demand-paged executable (QMAGIC), stripped
/lib/libc.so.5.4.33: ELF 32-bit LSB shared object, Intel 80386, version 1, stripped
/lib/libc-2.1.1.so: ELF 32-bit LSB shared object, Intel 80386, version 1, not stripped
</programlisting>

<para>
Le mot <emphasis>QMAGIC</emphasis> indique que
<emphasis>4.7.2</emphasis> est pour les bibliothèques a.out, et
<emphasis>ELF</emphasis> que <emphasis>5.4.33</emphasis> et
<emphasis>2.1.1</emphasis> sont pour les ELF.
</para>

<indexterm><primary>ELF</primary></indexterm>
<indexterm><primary>a.out</primary></indexterm>

<para>
Copiez le ou les chargeurs dont vous avez besoin sur le système racine
que vous êtes en train de construire. Les bibliothèques et chargeurs
doivent être testés <emphasis>attentivement</emphasis> avec les
exécutables inclus. Si le noyau ne peut charger une bibliothèque
nécessaire, il s'arrêtera en général brutalement, sans message d'erreur.
</para>

</sect3>

</sect2>

<sect2 id="PAMNSS">

<title>Utilisation de PAM et NSS</title>

<para>
Votre système peut utiliser des bibliothèques chargées dynamiquement
mais invisibles pour <filename>ldd</filename>. Si vous ne les incluez pas,
vous risquez de ne pas pouvoir vous connecter ou utiliser votre
disquette d'amorce.
</para>
<sect3><title>PAM (Pluggable Authentication Modules)</title>
<para>
Si votre système utilise PAM (Pluggable Authentication Modules, soit
Modules Externes d'authentification), tenez-en compte dans la
construction de votre disque d'amorce, sans quoi vous ne pourrez pas
vous connecter. En quelques mots, PAM est une méthode modulaire
sophistiquée pour authentifier les utilisateurs et contrôler leur accès
aux services. Pour déterminer simplement si votre système utilise PAM,
cherchez dans le répertoire <filename>/etc</filename> de votre disque
dur un fichier <filename>pam.conf</filename> ou un répertoire
<filename>pam.d</filename>&nbsp;; si l'un des deux existe, vous devez prévoir
un minimum de support pour PAM. (Vous pouvez aussi lancer
<filename>ldd</filename> sur votre exécutable <filename>login</filename>
; si la sortie contient <filename>libpam.so</filename>, vous avez besoin
de PAM.)
</para>
<para>
Heureusement, la sécurité est rarement un problème avec les disques
d'amorce étant donné que quiconque avec un accès physique à la
machine peut en général faire tout ce qu'il veut dessus. Vous pouvez
donc complètement désactiver PAM en créant un fichier
<filename>/etc/pam.conf</filename> simple sur votre système racine
contenant&nbsp;:
</para>

<programlisting format="linespecific">
OTHER   auth       optional     /lib/security/pam_permit.so
OTHER   account    optional     /lib/security/pam_permit.so
OTHER   password   optional     /lib/security/pam_permit.so
OTHER   session    optional     /lib/security/pam_permit.so
</programlisting>

<para>
Copiez également le fichier
<filename>/lib/security/pam_permit.so</filename> sur votre système
racine. Cette bibliothèque ne fait qu'environ 8&nbsp;ko et ne coûte donc
pas grand chose.
</para>

<para>
Notez bien que cette configuration donne à tous un accès complet aux
fichiers et services de votre machine. Si vous avez des impératifs de
sécurité sur votre disque d'amorce pour une raison ou une autre, vous
devrez copier une partie, voire l'ensemble de la configuration PAM de
votre disque dur vers le système racine. Lisez bien attentivement la
documentation de PAM, et copiez toutes les bibliothèques nécessaires
depuis <filename>/lib/security</filename> vers votre système racine.
</para>
<para>
Vous devez aussi inclure <filename>/lib/libpam.so</filename> sur le
disque racine. Mais vous le saviez déjà puisque vous avez lancé
<command>ldd</command> sur <filename>/bin/login</filename> qui vous a
montré cette dépendance.
</para>
</sect3>
<sect3><title>NSS (Name Service Switch)</title>
<para>
Si vous utilisez <emphasis>glibc</emphasis> (appelée aussi
<emphasis>libc6</emphasis>), vous devez tenir compte des services de
noms sans quoi vous ne pourrez pas vous connecter. Le fichier
<filename>/etc/nsswitch.conf</filename> contrôle les recherches dans les
bases de données pour divers services. Si vous ne comptez pas accéder à
des services du réseau (tels que des recherches DNS ou NIS), un simple
fichier <filename>nsswitch.conf</filename> comme suit suffit&nbsp;:
</para>

<programlisting format="linespecific">
passwd:     files
shadow:     files
group:      files
hosts:      files
services:   files
networks:   files
protocols:  files
rpc:        files
ethers:     files
netmasks:   files
bootparams: files
automount:  files
aliases:    files
netgroup:   files
publickey:  files
</programlisting>

<para>
Ce fichier spécifie que tous les services ne sont fournis que par des
fichiers locaux de la machine. Vous devez aussi inclure le fichier
<filename>/lib/libnss_files.so.X</filename>, où X vaut 1 pour une glibc
2.0 et 2 pour une glibc 2.1. Cette bibliothèque est chargée
dynamiquement pour gérer les recherches dans les fichiers.
</para>
<para>
Si vous comptez accéder au réseau depuis votre disque d'amorce, vous
pouvez créer un fichier <filename>nsswitch.conf</filename> plus complet.
Voir la page de manuel de <filename>nsswitch</filename> pour plus de
détails. N'oubliez pas d'inclure un fichier
<filename>/lib/libnss_</filename><emphasis>service</emphasis><filename>.so.1
</filename>
pour chaque <emphasis>service</emphasis> que vous ajoutez.
</para>
</sect3>
</sect2>
<sect2><title>Modules</title>
<para>
<indexterm><primary>modules</primary></indexterm>
Si votre noyau est modulaire, vous devez savoir quels modules vous
voudrez charger depuis votre disque d'amorce une fois le système
démarré. Il vous faudra inclure les modules <command>ftape</command> et
<command>zftape</command> si vos sauvegardes sont sur bandes, les
modules pour périphériques SCSI si vous en avez, et éventuellement ceux
pour le support PPP ou SLIP si vous souhaitez accéder au réseau en cas
d'urgence.
</para>
<indexterm remap="ncdx"><primary><literal>ftape</literal></primary></indexterm>
<para>
Ces modules doivent être placés dans <filename>/lib/modules</filename>.
Vous devez aussi inclure <command>insmod</command>,
<command>rmmod</command> et <command>lsmod</command>. Si vous souhaitez
charger les modules automatiquement, prenez <command>modprobe</command>,
<command>depmod</command> et <command>swapout</command>. Et si vous
utilisez <command>kerneld</command>, prenez le avec son fichier de
configuration <filename>/etc/conf.modules</filename>.
</para>
<para>
Néanmoins, le principal avantage d'utiliser les modules est que vous
pouvez déplacer les modules non essentiels sur un disque utilitaire et
ne les charger que lorsque c'est nécessaire, ce qui prend alors moins de
place sur le disque racine. Si vous devez gérer beaucoup de
périphériques, il vaut mieux procéder de cette manière plutôt que de
construire un seul gros noyau contenant tous les gestionnaires.
</para>
<indexterm><primary>disquette utilitaire</primary></indexterm>
<para>
<emphasis>Attention, pour démarrer avec un système de fichiers ext2
compressé, vous devez avoir inclus le support pour disque mémoire et
ext2.</emphasis> Ils ne peuvent être installés par des modules.
</para>
</sect2>
<sect2><title>Quelques ultimes détails</title>
<para>
Certains programmes, tels que <command>login</command>, se plaignent si
le fichier <filename>/var/run/utmp</filename> et le répertoire
<filename>/var/log</filename> n'existent pas.
</para>
<indexterm remap="ncdx"><primary><literal>utmp</literal></primary></indexterm>
<para>
Donc&nbsp;:
</para>

<programlisting format="linespecific">
mkdir -p /mnt/var/{log,run}
touch /mnt/var/run/utmp
</programlisting>

<para>
Enfin, après avoir installé toutes les bibliothèques dont vous avez
besoin, lancez <command>ldconfig</command> pour refabriquer
<filename>/etc/ld.so.cache</filename> sur le système racine. Le cache
indique au loader où trouver les bibliothèques. Pour refabriquer
<filename>ld.so.cache</filename>, lancez la commande suivante&nbsp;:
</para>
<indexterm remap="ncdx"><primary><literal>ldconfig</literal></primary>
</indexterm>
<indexterm remap="ncdx"><primary><literal>ld.so.cache</literal></primary>
</indexterm>

<programlisting format="linespecific">
ldconfig -r /mnt
</programlisting>

</sect2>
<sect2 id="wrappingitup"><title>C'est dans la poche</title>
<para>
Une fois le système racine construit, démontez-le, copiez-le dans un
fichier et compressez-le&nbsp;:
</para>

<programlisting format="linespecific">
umount /mnt
dd if=PÉRIPHÉRIQUE bs=1k | gzip -v9 > rootfs.gz
</programlisting>

<para>
Une fois cette étape effectuée, vous obtenez un fichier
<filename>rootfs.gz</filename> contenant votre système racine compressé.
Vérifiez sa taille pour être sûr qu'il tient sur une disquette. Si ça
n'est pas le cas vous devrez y retourner pour supprimer certains
fichiers. La <xref linkend="slimfast"/> vous donnera des astuces pour y
arriver.
</para>
</sect2>
</sect1>
<sect1><title>Choisir un noyau</title>
<para>
<indexterm><primary>noyau, choix</primary></indexterm>
Vous avez maintenant un système de fichiers racine complet et
compressé. La prochaine étape consiste à construire ou choisir un
noyau. Dans la plupart des cas, vous pouvez copier votre noyau courant
et démarrer la disquette avec. Cependant dans certains cas, vous
voudrez peut-être construire un noyau différent.
</para>
<para>
La taille peut jouer. Si vous faites une disquette d'amorce/racine
unique, le noyau va être un des plus gros fichiers de la disquette et
il vaut donc mieux essayer d'en réduire la taille au maximum. Pour ce
faire, construisez-le avec le minimum de fonctionnalités nécessaires
au bon fonctionnement du système cible. Cela implique de retirer tout
ce dont vous n'avez pas besoin. Le support réseau est un bon candidat,
tout comme le support pour tout type de disque et de périphérique dont
vous n'avez pas l'usage sur un système lancé par disquette. Comme
indiqué précédemment, votre noyau doit contenir le support pour disque
mémoire et ext2.
</para>
<para>
Une fois les fonctionnalités nécessaires déterminées, vous devez trouver
ce qu'il faut rajouter. L'utilisation la plus courante d'une disquette
d'amorce/racine est l'examen et la récupération d'un système racine
endommagé, ce qui peut nécessiter le support de certaines
fonctionnalités supplémentaires dans le noyau. Par exemple, si vos
sauvegardes sont stockées sur bande avec <command>ftape</command> pour
gérer l'accès au lecteur de bande et que vous perdez votre disque racine
ainsi que ceux contenant <command>ftape</command>, vous ne pourrez plus
récupérer vos sauvegardes depuis les bandes. Vous devrez réinstaller
Linux, rapatrier et réinstaller <command>ftape</command>, puis essayer
de lire vos sauvegardes.
</para>
<para>
Ce que je veux dire, c'est que quelle que soit la méthode d'E/S que
vous utilisez au niveau du noyau pour les sauvegardes, elle doit se
trouver aussi sur votre noyau d'amorce.
</para>
<indexterm><primary>noyau, construction à partir des sources</primary>
</indexterm>
<para>
La procédure de construction d'un noyau est décrite dans la
documentation fournie avec celui-ci. C'est assez simple à suivre, vous
pouvez donc commencer par faire un tour dans
<filename>/usr/src/linux</filename>. Si vous avez des problèmes pour
construire un noyau, vous ne devriez probablement pas essayer de faire
de disquette d'amorce/racine de toute manière. Pensez à compresser le
noyau avec <command>make zImage</command>.
</para>
</sect1>
<sect1><title>Assemblage et fabrication de la ou des disquettes</title>
<para>
Vous avez maintenant un noyau et un système de fichiers compressé. Si
vous construisez un disque d'amorce/racine unique, vérifiez que leur
taille ne dépasse pas celle du disque. Si vous avez un découpage sur
deux disquettes, vérifiez que la taille du système racine ne dépasse
pas celle de la disquette.
</para>
<para>
Il vous faut choisir entre l'utilisation de <command>LILO</command> pour
démarrer le noyau du disque d'amorce et la copie du noyau directement
sur la disquette d'amorce, sans <command>LILO</command>. L'avantage de
<command>LILO</command> est la possibilité de passer des paramètres au
noyau, ce qui peut être nécessaire pour initialiser votre matériel
(Regardez le fichier <filename>/etc/lilo.conf</filename> sur votre
machine. S'il existe et contient une ligne du type
<emphasis>append=&hellip;</emphasis>, vous avez besoin de passer des
paramètres). Son inconvénient est une complexité accrue dans la
construction du disque d'amorce, ainsi qu'une place occupée sur la
disquette légèrement plus importante. Vous devrez configurer un petit
système de fichier séparé que nous appellerons le <emphasis>système
noyau</emphasis>, où vous transférerez le noyau ainsi que quelques
autres fichiers nécessaires à <command>LILO</command>.
</para>
<indexterm remap="ncdx"><primary><literal>lilo.conf</literal></primary>
</indexterm>
<indexterm><primary>système noyau</primary></indexterm>
<indexterm><primary>noyau, paramètres</primary></indexterm>
<para>
Si vous décidez d'utiliser <command>LILO</command>, continuez la lecture
; si par contre vous voulez copier le noyau directement sur la
disquette, passez directement à la <xref linkend="withoutlilo"/>.
</para>
<sect2 id="usinglilo"><title>Transfert du noyau avec LILO</title>
<indexterm remap="ncdx"><primary><literal>LILO</literal></primary></indexterm>
<para>
La première chose à faire est de vérifier que vous avez une version
récente de <command>LILO</command>. Ensuite, il faut créer un petit
fichier de configuration pour <command>LILO</command>. Il doit
ressembler à&nbsp;:
</para>

<programlisting format="linespecific">
boot      =/dev/fd0
install   =/boot/boot.b
map       =/boot/map
read-write
backup    =/dev/null
compact
image     = NOYAU
label     = Bootdisk
root      =/dev/fd0
</programlisting>

<para>
Pour la signification de ces paramètres, voir la documentation
utilisateur de <command>LILO</command>. Il vous faudra probablement
aussi rajouter une ligne <emphasis>append=&hellip;</emphasis> à ce fichier,
comme dans le fichier <filename>/etc/lilo.conf</filename> de votre
disque dur.
</para>
<indexterm remap="ncdx">
<primary><literal>lilo.conf</literal></primary></indexterm>
<para>
Sauvez-le en tant que <filename>bdlilo.conf</filename>.
</para>
<para>
Vous devez maintenant créer un petit système de fichier, que nous
appellerons <emphasis>système noyau</emphasis>, pour le différencier du
système racine.
</para>
<para>
Tout d'abord, calculez la taille que celui-ci doit faire. Prenez la
taille de votre noyau en blocs (la taille donnée par <command>ls -s
NOYAU</command> et
ajoutez 50. Cinquante blocs sont en gros la taille nécessaire aux
i-n&oelig;uds ainsi qu'aux autres fichiers. Vous pouvez calculer le nombre
exact si vous voulez, ou simplement utiliser 50. Si vous créez un
ensemble avec deux disques, vous pouvez carrément surestimer l'espace
nécessaire puisque le disque n'est utilisé que par le noyau de toute
manière. Appelez ce nombre <emphasis>BLOCS_NOYAU</emphasis>.
</para>
<indexterm remap="ncdx"><primary><literal>BLOCS_NOYAU</literal></primary>
</indexterm>
<para>
Mettez une disquette dans le lecteur (pour simplifier, supposons qu'il
s'agit de <filename>/dev/fd0</filename>) et créez le système noyau ext2
dessus&nbsp;:
</para>

<programlisting format="linespecific">
mke2fs -N 24 -m 0 /dev/fd0 BLOCS_NOYAU
</programlisting>

<indexterm><primary>i-n&oelig;uds, allocation</primary></indexterm>
<para>
L'option <option>-N 24</option> indique que l'on souhaite 24 i-n&oelig;uds,
ce qui est largement suffisant pour ce système de fichiers.  Ensuite,
montez le système, supprimez le répertoire
<filename>lost+found</filename> et créez des répertoire
<filename>dev</filename> et <filename>boot</filename> pour
<command>LILO</command>&nbsp;:
</para>

<programlisting format="linespecific">
mount /dev/fd0 /mnt
rm -rf /mnt/lost+found
mkdir /mnt/{boot,dev}
</programlisting>

<para>
Ensuite, créez les périphériques <filename>/dev/null</filename> et
<filename>/dev/fd0</filename>. Au lieu de chercher leurs numéros de
périphériques, vous pouvez simplement les copier depuis votre disque
dur avec l'option <option>-R</option>&nbsp;:
</para>

<programlisting format="linespecific">
cp -R /dev/{null,fd0} /mnt/dev
</programlisting>

<para>
<command>LILO</command> a besoin d'une copie de son chargeur d'amorce,
<filename>boot.b</filename>, que vous pouvez trouver sur votre disque
dur. Il est d'habitude dans le répertoire <filename>/boot</filename>.
</para>

<programlisting format="linespecific">
cp /boot/boot.b /mnt/boot
</programlisting>

<para>
Enfin, copiez le fichier de configuration de <command>LILO</command> que
vous avez créé précédemment avec votre noyau. Les deux peuvent être
placés dans le répertoire racine&nbsp;:
</para>

<programlisting format="linespecific">
cp bdlilo.conf NOYAU /mnt
</programlisting>

<para>
Tout ce dont <command>LILO</command> a besoin est maintenant sur le
système noyau, vous pouvez donc le lancer. Le paramètre
<option>-r</option> de <command>LILO</command> est utilisé pour
installer le chargeur sur une autre racine que la courante&nbsp;:
</para>
<indexterm remap="ncdx"><primary><literal>LILO</literal></primary></indexterm>

<programlisting format="linespecific">
lilo -v -C bdlilo.conf -r /mnt
</programlisting>

<para>
<command>LILO</command> doit s'exécuter sans erreur, après quoi le
système noyau devrait ressembler à&nbsp;:
</para>

<programlisting format="linespecific">
total 361
  1 -rw-r--r--   1 root     root          176 Jan 10 07:22 bdlilo.conf
  1 drwxr-xr-x   2 root     root         1024 Jan 10 07:23 boot/
  1 drwxr-xr-x   2 root     root         1024 Jan 10 07:22 dev/
358 -rw-r--r--   1 root     root       362707 Jan 10 07:23 vmlinuz
boot:
total 8
  4 -rw-r--r--   1 root     root         3708 Jan 10 07:22 boot.b
  4 -rw-------   1 root     root         3584 Jan 10 07:23 map
dev:
total 0
  0 brw-r-----   1 root     root       2,   0 Jan 10 07:22 fd0
  0 crw-r--r--   1 root     root       1,   3 Jan 10 07:22 null
</programlisting>

<indexterm><primary>système noyau</primary></indexterm>

<para>
Ne vous inquiétez pas si la taille des fichiers n'est pas exactement
la même que la votre.
</para>

<para>
Laissez maintenant le disque dans le lecteur et allez à la
<xref linkend="ramdiskword"/>.
</para>
</sect2>
<sect2 id="withoutlilo"><title>Transfert du noyau sans LILO</title>
<para>
Si vous n'utilisez <emphasis>pas</emphasis> <command>LILO</command>,
transférez le noyau sur le disque d'amorce avec la commande
<command>dd</command>&nbsp;:
</para>

<programlisting format="linespecific">
% dd if=NOYAU of=/dev/fd0 bs=1k
353+1 records in
353+1 records out
</programlisting>

<para>
Dans ce exemple, <command>dd</command> a écrit 353 enregistrements
complets, plus 1 partiel, ce qui signifie que le noyau occupe les 354
premiers blocs de la disquette. Appelez ce nombre
<emphasis>BLOCS_NOYAU</emphasis> et pensez à l'utiliser dans la section
suivante.
</para>
<indexterm remap="ncdx"><primary><literal>BLOCS_NOYAU</literal></primary>
</indexterm>
<para>
Enfin, indiquez que le périphérique racine doit être la disquette
elle-même, et que le noyau doit être chargé en lecture/écriture.
</para>

<programlisting format="linespecific">
        rdev /dev/fd0 /dev/fd0
        rdev -R /dev/fd0 0
</programlisting>

<indexterm remap="ncdx"><primary><literal>rdev</literal></primary></indexterm>

<para>
Attention à bien utiliser un <option>-R</option> majuscule dans la
seconde commande <command>rdev</command>.
</para>
</sect2>
<sect2 id="ramdiskword"><title>Mise en place du mot disque mémoire</title>
<para>
Le <emphasis>mot disque mémoire</emphasis> situé dans l'image du noyau
permet de spécifier où se trouve le système racine, ainsi que d'autres
options. Le mot peut être lu et modifié avec la commande
<command>rdev</command>, et sa valeur s'interprète de la manière
suivante&nbsp;:
</para>

<programlisting format="linespecific">
bits  0-10&nbsp;:    Décalage jusqu'au début du disque mémoire, en blocs
                de 1024 octets
bits 11-13&nbsp;:    Inutilisé
bit     14&nbsp;:    Drapeau indiquant s'il faut charger un disque mémoire
bit     15&nbsp;:    Drapeau pour faire une pause avant de charger le
                système racine
</programlisting>

<para>
Si le bit 15 est mis à 1, le noyau vous demandera au moment du démarrage
de changer la disquette dans le lecteur. C'est nécessaire si vous
utilisez un ensemble de deux disques.  Il y a deux cas, suivant que vous
créez une disquette d'amorce/racine unique ou un ensemble
&laquo;&nbsp;amorce+racine&nbsp;&raquo; séparé.
</para>

<orderedlist>

<listitem><para>
Si vous créez un disque unique, le système racine compressé sera placé
juste après le noyau, et donc le décalage sera le premier bloc libre
(qui doit être au même endroit que <emphasis>BLOCS_NOYAU</emphasis>). Le
bit 14 sera mis à 1, et le bit 15 à 0.
</para>

<indexterm remap="ncdx">
<primary><literal>BLOCS_NOYAU</literal></primary></indexterm>

<para>
Supposons par exemple que vous construisiez un disque unique dont le
système racine doit commencer au bloc 253 (valeur décimale). Le mot
disque mémoire devrait valoir 253 (toujours en décimal) avec le bit 14 à
1 et le bit 15 à 0. Pour calculer sa valeur vous pouvez simplement
additionner les valeurs décimales. 253 + (2^14) = 253 + 16384 = 16637.
Si vous ne comprenez pas d'où sort ce nombre, entrez-le dans une
calculatrice scientifique et convertissez-le en binaire.
</para></listitem>

<listitem><para>
Si vous créez par contre un ensemble de deux disques, le système racine
sera au bloc zéro du second disque, et le décalage sera donc zéro. Le
bit 14 sera mis à 1 tout comme le bit 15. La valeur décimale sera donc
de 2^14 + 2^15 = 49152 dans ce cas.
</para></listitem>

</orderedlist>

<indexterm remap="ncdx"><primary><literal>rdev</literal></primary></indexterm>
<indexterm><primary>mot disque mémoire</primary></indexterm>
<indexterm><primary>disque mémoire, mot</primary></indexterm>

<para>
Après avoir bien calculé la valeur du mot disque mémoire, écrivez-le
avec <command>rdev -r</command>. Attention à utiliser la valeur
<emphasis>décimale</emphasis>. Si vous utilisez <command>LILO</command>,
l'argument de <command>rdev</command> doit être le <emphasis>chemin
d'accès au noyau monté</emphasis>, c'est à dire
<filename>/mnt/vmlinuz</filename>&nbsp;; si vous avez copié le noyau avec
<command>dd</command>, utilisez à la place le nom du périphérique du
lecteur de disquette (c'est à dire <filename>/dev/fd0</filename>).
</para>
<programlisting format="linespecific">
rdev -r NOYAU_OU_LECTEUR_DE_DISQUETTE VALEUR
</programlisting>

<para>
Si vous avez utilisé <command>LILO</command>, démontez maintenant la
disquette.
</para>

<para>
Ne croyez pas ce que dit la page de manuel de
<command>rdev</command>/<command>ramsize</command> à propos de la taille
du disque mémoire. Cette page est obsolète. À partir du noyau 2.0, le
mot disque mémoire ne détermine plus la taille du disque mémoire&nbsp;; au
lieu de cela, ce mot est déterminé à partir du tableau donné au début de
cette section. Pour une explication détaillée, voir le fichier de
documentation <filename>ramdisk.txt</filename> ou
<!-- Lien foireux - remplacé
<ulink url="http://www.linuxhq.com/kernel/v2.4/doc/ramdisk.txt.html">
http://www.linuxhq.com/kernel/v2.4/doc/ramdisk.txt.html</ulink>.
-->
<ulink url="http://www.tamacom.com/tour/linux/S/9075.html">
http://www.tamacom.com/tour/linux/S/9075.html</ulink>.
</para>
</sect2>
<sect2><title>Transfert du système racine</title>
<para>
La dernière étape concerne le transfert du système racine.
</para>
<itemizedlist>
<listitem><para>Si le système racine doit être placé sur le même disque
que le noyau, transférez-le avec <command>dd</command> et son option
<option>seek</option>, qui indique combien de blocs il faut sauter&nbsp;:
</para>

<programlisting format="linespecific">
dd if=rootfs.gz of=/dev/fd0 bs=1k seek=BLOCS_NOYAU
</programlisting></listitem>

<listitem><para>
Si le système racine doit être placé sur un second disque, sortez la
première disquette, mettez la seconde dans le disque, puis transférez-y
le système racine&nbsp;:
</para>

<programlisting format="linespecific">
dd if=rootfs.gz of=/dev/fd0 bs=1k
</programlisting></listitem>

</itemizedlist>
<para>
Bravo, vous avez fini&nbsp;! <emphasis>Vous devriez toujours tester un
disque d'amorce avant de le ranger jusqu'à la prochaine
urgence&nbsp;!</emphasis> S'il n'arrive pas à démarrer, continuez à lire.
</para>
</sect2>

</sect1>

<sect1 id="troubleshooting">

<title>En cas de problème, ou l'agonie de la défaite</title>

<para>

<indexterm><primary>problème, en cas de</primary></indexterm>

Lorsque l'on crée des disques d'amorce, les premiers essais n'amorcent
souvent pas la machine. En général, la méthode utilisée consiste à
construire le disque racine à partir de composants de votre système
actuel pour essayer d'obtenir que le système de la disquette commence
à afficher des messages sur la console. Une fois qu'il a commencé à
vous parler, la bataille est presque gagnée puisque vous pouvez voir
de quoi il se plaint et corriger les problèmes un à un jusqu'à ce que
le système fonctionne normalement. Si le système s'arrête brutalement
sans explication, il peut être difficile d'en trouver la cause. Pour
que le système en arrive au point où il commence à afficher ses
messages, un certain nombre de composants doivent être présents et
bien configurés. La procédure à suivre pour déterminer les raisons du
silence de votre système est la suivante&nbsp;:
</para>
<itemizedlist>
<listitem><para>Si vous voyez un message du genre&nbsp;:
</para>

<programlisting format="linespecific">
Kernel panic: VFS: Unable to mount root fs on XX:YY
</programlisting>

<para>
C'est un problème courant qui ne peut avoir que quelques causes. Tout
d'abord, cherchez le périphérique <emphasis>XX:YY</emphasis> dans la
liste de codes des périphériques dans le fichier
<filename>/usr/src/linux/Documentation/devices.txt</filename>&nbsp;;
s'agit-il du bon périphérique racine&nbsp;?  Si ce n'est pas le bon, vous
n'avez sans doute pas lancé <command>rdev -R</command>, ou alors sur la
mauvaise image. Si le code du périphérique est correct, vérifiez
attentivement quels gestionnaires de périphériques ont été compilés dans
le noyau. Assurez-vous que le support pour le lecteur de disquettes, les
disques mémoires et le système de fichiers ext2 sont bien inclus&nbsp;;
</para></listitem>
<listitem><para>Si vous voyez plusieurs erreurs du genre&nbsp;:
</para>

<programlisting format="linespecific">
end_request: I/O error, dev 01:00 (ramdisk), sector NNN
</programlisting>

<para>
Il s'agit d'une erreur d'E/S du périphérique disque mémoire, la plupart
du temps à cause du noyau qui tente d'écrire au-delà de la fin du
périphérique. Le disque mémoire est trop petit pour supporter la
totalité du système de fichiers. Vérifiez les message d'initialisation
du noyau pour trouver une ligne du type&nbsp;:
</para>

<programlisting format="linespecific">
Ramdisk driver initialized&nbsp;: 16 ramdisks of 4096K size
</programlisting>

<para>
Vérifiez la taille du système de fichiers
<emphasis>compressé</emphasis>. Si le disque mémoire n'est pas assez
grand, il faut l'agrandir.
</para></listitem>
<listitem><para>Vérifiez que le disque racine contient bien les
répertoires que vous croyez. Il est facile de se tromper de niveau
d'arborescence et de se retrouver avec quelque chose du genre
<filename>/racine/bin</filename> au lieu de <filename>/bin</filename>
sur votre disquette racine&nbsp;;
</para></listitem>
<listitem><para>Vérifiez qu'il y a un <filename>/lib/libc.so</filename>
avec le même lien que celui présent dans le répertoire
<filename>/lib</filename> de votre disque dur&nbsp;;
<indexterm remap="ncdx">
<primary><literal>libc.so</literal></primary></indexterm>
</para></listitem>
<listitem><para>Vérifiez que tous les liens symboliques du répertoire
<filename>/dev</filename> de votre système actuel existent également sur
le système racine, quand ces liens pointent vers des périphériques inclus
sur la disquette racine. Notamment, les liens vers
<filename>/dev/console</filename> sont souvent essentiels&nbsp;;
<indexterm><primary>périphériques, répertoire de</primary></indexterm>
</para></listitem>
<listitem><para>Vérifiez que vous avez inclus les fichiers
<filename>/dev/tty1</filename>, <filename>/dev/null</filename>,
<filename>/dev/zero</filename>, <filename>/dev/mem</filename>,
<filename>/dev/ram</filename> et <filename>/dev/kmem</filename>&nbsp;;
</para></listitem>
<listitem><para>Vérifiez la configuration de votre noyau&nbsp;: le support
pour toutes les ressources nécessaires jusqu'à l'invite de connexion 
doit être directement inclus et non pas sous forme de modules. 
<emphasis>Le support des disques mémoires et de ext2 doivent donc être 
présents dans le noyau</emphasis>&nbsp;;
</para></listitem>
<listitem><para>Vérifiez que le périphérique racine et le disque mémoire
sont correctement configurés dans le noyau.
</para></listitem>
</itemizedlist>
<para>
Une fois ces points généraux vérifiés, vous pouvez vous pencher sur
ces points plus précis&nbsp;:
</para>
<orderedlist>
<listitem><para>Vérifiez qu'<command>init</command> est présent en tant
que <filename>/sbin/init</filename> ou <filename>/bin/init</filename>,
et qu'il est exécutable&nbsp;;
</para></listitem>
<listitem><para>Lancez <command>ldd init</command> pour vérifier les
bibliothèques
<indexterm remap="ncdx"><primary><literal>init</literal></primary>
</indexterm>
d'<command>init</command>. Il n'y a normalement que
<filename>libc.so</filename>, mais sait-on jamais&hellip; Vérifiez que vous
avez bien inclus les bibliothèques et leurs chargeurs&nbsp;;
</para></listitem>
<listitem><para>Vérifiez que vous avez le bon chargeur pour vos
bibliothèques&nbsp;: <filename>ld.so</filename> pour a.out et
<filename>ld-linux.so</filename> pour ELF&nbsp;;
<indexterm><primary>chargeurs</primary></indexterm>
</para></listitem>
<listitem><para>Vérifiez le contenu de <filename>/etc/inittab</filename>
sur la disquette d'amorce et ses éventuels appels à
<command>getty</command> (ou tout autre programme du genre, tel que
<command>agetty</command>, <command>mgetty</command> ou
<command>getty_ps</command>).
</para>
<indexterm remap="ncdx"><primary><literal>inittab</literal></primary>
</indexterm>
<indexterm remap="ncdx"><primary><literal>getty</literal></primary></indexterm>
<para>
Comparez-le plusieurs fois avec l'<filename>inittab</filename> de votre
disque dur. Vérifiez les pages de manuel du programme que vous utilisez
pour être sûr de sa cohérence. <filename>inittab</filename> peut être le
morceau le plus difficile en raison de sa syntaxe et du contenu qui
dépendent de la version d'<command>init</command> utilisée et de la
nature du système. La seule manière de s'en débarrasser, c'est de lire
les pages de manuel d'<command>init</command> et
<filename>inittab</filename> afin de comprendre exactement ce que fait
le système lorsqu'il démarre. Vérifiez que
<filename>/etc/inittab</filename> contient bien une entrée concernant
l'initialisation du système. Elle doit contenir une commande lançant le
script d'initialisation du système, qui doit lui aussi exister&nbsp;;
</para></listitem>
<listitem><para>Comme pour <command>init</command>, lancez
<command>ldd</command> sur votre <command>getty</command> pour voir ses
besoins, et vérifiez que les bibliothèques et chargeurs nécessaires sont
présents sur le système racine&nbsp;;
</para></listitem>
<listitem><para>Assurez-vous d'avoir inclus un exécutable de shell (par
exemple <command>bash</command> ou <command>ash</command>) capable de
faire tourner tous vos scripts <command>rc</command>&nbsp;;
<indexterm><primary>shells</primary></indexterm>
</para></listitem>
<listitem><para>Si vous avez un fichier
<filename>/etc/ld.so.cache</filename> sur le disque de secours,
refabriquez-le (le fichier, pas le disque).
<indexterm remap="ncdx">
<primary><literal>ld.so.cache</literal></primary></indexterm>
</para></listitem>
</orderedlist>
<para>
Si <command>init</command> démarre et que vous obtenez un message du type&nbsp;:
</para>

<programlisting format="linespecific">
Id xxx respawning too fast: disabled for 5 minutes
</programlisting>

<indexterm remap="ncdx"><primary><literal>respawning too fast</literal>
</primary></indexterm>
<para>
cela provient d'<command>init</command> et indique généralement que
<command>getty</command> ou <command>login</command> meurt aussitôt
après son lancement.
</para>
<indexterm remap="ncdx"><primary><literal>init</literal></primary></indexterm>
<indexterm remap="ncdx"><primary><literal>getty</literal></primary></indexterm>
<indexterm remap="ncdx"><primary><literal>login</literal></primary></indexterm>
<para>
Vérifiez les exécutables de <command>getty</command> et
<command>login</command>, et les bibliothèques dont ils dépendent.
Vérifiez que les appels depuis <filename>/etc/inittab</filename> sont
corrects. Si vous obtenez d'étranges messages de
<command>getty</command>, cela peut signifier que les arguments dans
<filename>/etc/inittab</filename> sont faux. Les options des programmes
<command>getty</command> sont variables&nbsp;; on signale que les arguments
sont parfois incompatibles entre deux versions
d'<command>agetty</command>.
</para>
<indexterm remap="ncdx"><primary><literal>inittab</literal></primary>
</indexterm>
<para>
Si vous obtenez une invite de login et qu'après avoir entré un nom de
login valide, le système vous en demande un autre aussitôt, le problème
peut venir de PAM ou NSS. Lisez la <xref linkend="PAMNSS"/>.  Le
problème peut aussi venir du fait que vous utilisez les <emphasis>mots
de passe cachés</emphasis> et que vous n'avez pas copié le fichier
<filename>/etc/shadow</filename> sur votre disque d'amorce.
</para>
<indexterm remap="ncdx"><primary><literal>shadow</literal></primary></indexterm>
<para>
Si vous essayez de lancer un exécutable tel que <command>df</command>
présent sur votre disque de secours, mais n'obtenez qu'un message du
type&nbsp;: <emphasis>df: not found</emphasis>, vérifiez deux chose&nbsp;: (1) que
le répertoire contenant le binaire est bien dans votre PATH, et (2) que
vous avez les bibliothèques (et chargeurs) nécessaires au programme.
</para>
</sect1>
<sect1 id="slimfast"><title>Réduire la taille du système racine</title>
<para>
Parfois un système racine est trop gros pour tenir sur une disquette,
même après compression. Voici quelques techniques pour réduire sa
taille, citées par ordre décroissant d'efficacité&nbsp;:
</para>
<sect2 id="high-density"><title>Augmentez la densité du disque</title>
<para>
Par défaut, les disquettes sont formatées à 1440&nbsp;ko, mais des formats
plus denses existent. <filename>fdformat</filename> peut formater des
disques avec les tailles suivantes&nbsp;: 1600, 1680, 1722, 1743, 1760, 1840
et 1920. Lisez la page de manuel de <filename>fdformat</filename> ainsi
que <filename>/usr/src/linux/Documentation/devices.txt</filename>.
</para>
<para>
Mais quelles densités/géométries votre machine peut-elle supporter&nbsp;? Voici des
réponses (légèrement modifiées) de Alain Knaff, l'auteur de
<command>fdutils</command>.
</para>
<blockquote><attribution>Alain Knaff</attribution>
<para>
C'est plus le problème du <acronym>BIOS</acronym> que du format physique
des disquettes. Si le <acronym>BIOS</acronym> décide que tous les
numéros de secteurs supérieurs à 18 sont non valides, alors on ne peut
pas y faire grand chose. En effet, à moins de désassembler le
<acronym>BIOS</acronym>, le seul moyen de trouver la bonne valeur est en
tâtonnant. Quoiqu'il en soit, si le <acronym>BIOS</acronym> supporte les
disques ED (grande densité&nbsp;: 36 secteurs/piste et 2,88&nbsp;Mo), il y a des
chances pour que les disquettes de 1722&nbsp;ko soient également supportées.
</para>
<para>
Les disquettes super-formatées avec plus de 21 secteurs par piste ne
sont vraisemblablement pas amorçables&nbsp;: en fait, celles qui 
utilisent des secteurs de tailles non standard (1024&nbsp;octets par 
secteur au lieu de 512, par exemple) ne sont vraisemblablement pas 
démarrables. Il devrait être malgré tout possible d'écrire un programme 
de démarrage du secteur pour contourner cela. Si je me souviens bien, le 
programme <command>DOS 2m</command> en est capable, ainsi que les 
programmes <command>XDF</command> de <acronym>OS/2</acronym>.
</para>
<para>
Certains <acronym>BIOS</acronym> clament artificiellement que tout
secteur supérieur à 18 est certainement défectueux. Comme les disquettes
de 1722&nbsp;ko utilisent des secteurs supérieurs à 21, elles ne devraient
pas être amorçables. Le meilleur moyen de tester serait de formater une
disquette DOS ou syslinux en 1722&nbsp;ko et de la rendre amorçable. Si 
vous utilisez <command>LILO</command>, n'utilisez pas l'option
<option>linear</option> (sans quoi <command>LILO</command> penserait que
le format par défaut de la disquette est de 18 secteurs par piste, et la
disquette ne démarrera pas même si le <acronym>BIOS</acronym> la
supporte).
</para>
</blockquote>
</sect2>
<sect2><title>Remplacer les utilitaires indispensables par BusyBox</title>
<para>
La plupart de l'espace disque d'un système de fichiers est consommé par
des utilitaires indispensables tels que <command>cat</command>,
<command>chmod</command>, <command>cp</command>, <command>dd</command>,
<command>df</command>, et cætera. Le projet <emphasis>BusyBox</emphasis>
permet de fournir un remplacement à ces utilitaires indispensables.
BusyBox fournit un seul fichier monolithique exécutable,
<command>/bin/busybox</command>, d'environ 150&nbsp;ko, qui implémente les
fonctions de ces utilitaires. Vous pouvez créer des liens symboliques à
partir de différents programmes vers cet exécutable&nbsp;;
<command>busybox</command> voit comment il a été appelé et invoque le
code correcte. BusyBox inclut même un shell basique. BusyBox est
disponible sous forme de paquetage binaire pour plusieurs distributions,
et le code source est disponible sur le site de BusyBox.
</para>
</sect2>
<sect2><title>Changez de shell</title>
<para> Certains shells populaires sous Linux, tels que
<command>bash</command> et <command>tcsh</command>, sont gros et
nécessitent de nombreuses bibliothèques. Si vous n'utilisez pas le shell
de BusyBox, vous devriez quand même songer à remplacer le shell.
D'autres options plus légères existent, telles que
<command>ash</command>, <command>lsh</command>, <command>kiss</command>
et <command>smash</command>, bien plus petites et nécessitant peu (ou
pas) de bibliothèques. La plupart de ces shells de remplacement sont
disponibles sur
<ulink url="http://www.ibiblio.org/pub/Linux/system/shells/">
http://www.ibiblio.org/pub/Linux/system/shells/</ulink>.
Vérifiez que le shell que vous utilisez sait faire tourner les commandes
de tous les scripts <command>rc</command> que vous incluez sur le disque
d'amorce.  <indexterm><primary>shells</primary></indexterm>
</para>
</sect2>
<sect2><title>Nettoyez les bibliothèques et binaires</title>
<para>
De nombreux binaires et bibliothèques restent non nettoyés (ils
contiennent les informations pour le déboguage). Si vous lancez
<command>file</command> sur ces fichiers, il vous indiquera
<emphasis>not stripped</emphasis> si c'est le cas. Lorsque vous copiez
des binaires sur votre système racine, une bonne habitude à prendre est
d'utiliser&nbsp;:
</para>

<programlisting format="linespecific">
objcopy --strip-all ORIGINE DESTINATION
</programlisting>

<indexterm remap="ncdx"><primary><literal>strip</literal></primary></indexterm>
<indexterm remap="ncdx">
<primary><literal>objcopy</literal></primary></indexterm>
<indexterm><primary>bibliothèques, nettoyage</primary></indexterm>
<para>
Et lorsque vous copiez des bibliothèques&nbsp;:
</para>

<programlisting format="linespecific">
objcopy --strip-debug ORIGINE DESTINATION
</programlisting>

</sect2>
<sect2>
<title>Déplacez les fichiers non essentiels vers un disque
utilitaire</title>
<para>
Si certains binaires ne sont pas immédiatement nécessaires au démarrage
ou au login, vous pouvez les déplacer sur un disque utilitaire. Lisez la
<xref linkend="utilitydisk"/> pour les détails. Vous pouvez aussi
déplacer les modules vers un disque utilitaire.
<indexterm><primary>disquette utilitaire</primary></indexterm>
</para>
</sect2>
</sect1>
<sect1><title>Sujets divers</title>
<sect2 id="nonramdiskroot">
<title>Système racine sans disque mémoire</title>
<para>
<indexterm><primary>disque mémoire</primary></indexterm>
La <xref linkend="buildroot"/> explique comment construire un système
racine compressé chargé en mémoire lors du démarrage du système. Cette
méthode qui présente beaucoup d'avantages est souvent utilisée.
Néanmoins, certains systèmes possédant peu de mémoire ne peuvent se
permettre d'utiliser de la RAM pour un disque mémoire, et doivent donc
utiliser un système racine monté directement depuis la disquette.
</para>
<para>
De tels systèmes sont en réalité plus faciles à construire que les
systèmes racines compressés car on peut les créer directement sur
disquette plutôt que de passer par un autre périphérique
intermédiaire, et ne nécessitent pas de compression. Nous indiquerons
les différences de procédure par rapports aux instructions
précédentes. Si vous choisissez cette méthode, rappelez-vous bien que
vous aurez <emphasis>beaucoup moins d'espace disque</emphasis> disponible.
</para>
<orderedlist>
<listitem><para>Calculez la taille disponible pour les fichiers racines.
</para>
<para>
Si vous construisez un système d'amorce/racine unique, vous devez
arriver à faire tenir tous les blocs du noyau ainsi que tous les blocs
du système racine sur un seul disque.
</para></listitem>
<listitem><para>À l'aide de <command>mke2fs</command>, créez un système
racine de la bonne taille sur une disquette.
</para></listitem>
<listitem><para>Remplissez le système comme décrit précédemment.
</para></listitem>
<listitem><para>Après cela, démontez le système et transférez-le vers un
fichier sur le disque, mais <emphasis>sans le compresser</emphasis>.
</para></listitem>
<listitem><para>Transférez le noyau sur une disquette comme décrit
précédemment. Lorsque vous calculerez le mot disque mémoire, mettez le
bit 14 à 0 pour indiquer que le système racine ne doit pas être chargé
en mémoire. Lancez la commande <command>rdev</command> indiquée.
<indexterm remap="ncdx"><primary><literal>rdev</literal></primary></indexterm>
<indexterm><primary>mot disque mémoire</primary></indexterm>
<indexterm><primary>disque mémoire, mot</primary></indexterm>
</para></listitem>
<listitem><para>Transférez le système racine comme précédemment.
</para></listitem>
</orderedlist>
<para>
Vous pouvez prendre quelques raccourcis. Si vous construisez un système
avec deux disques, vous pouvez construire le système de fichiers racine
directement sur le second disque au lieu de le transférer sur le disque
dur puis à nouveau sur la disquette. De même, si vous construisez un
disque d'amorce/racine unique et si vous utilisez
<command>LILO</command>, vous pouvez créer un système de fichiers
<emphasis>unique</emphasis> sur toute la disquette contenant le noyau,
les fichiers de <command>LILO</command> et les fichiers racine, avant de
simplement lancer <command>LILO</command> comme dernière étape.
</para>
</sect2>
<sect2 id="utilitydisk"><title>Construire un disque utilitaire</title>
<para>
<indexterm><primary>disquette utilitaire</primary></indexterm>
Construire un disque utilitaire est assez facile&nbsp;: créez simplement
un système de fichiers sur une disquette formatée et copiez les
fichiers dessus. Pour l'utiliser depuis un disque d'amorce, montez-le
manuellement une fois le système démarré.
</para>
<para>
Les instructions précédentes indiquent qu'un disque utilitaire peut être
monté en tant que <filename>/usr</filename>. Dans ce cas, les binaires
doivent être placés dans un répertoire <filename>/bin</filename> du
disque utilitaire, afin d'être référencés si vous mettez
<filename>/usr/bin</filename> dans votre chemin. Les bibliothèques
supplémentaires nécessaires aux binaires sont à placer dans
<filename>/lib</filename> sur le disque utilitaire.
</para>
<para>
Il faut penser à plusieurs choses lorsque l'on crée un disque
utilitaire&nbsp;:
</para>
<orderedlist>
<listitem><para>Ne placez pas de binaires ou de bibliothèques essentiels
pour le système sur le disque utilitaire, puisqu'il ne sera montable qu'une
fois le système démarré&nbsp;;
</para></listitem>
<listitem><para>Vous ne pouvez pas utiliser de lecteur de disquette et
de lecteur de bande sur port disquette en même temps. Ce qui veut dire
que si votre lecteur de bande est sur un port disquette, vous ne pourrez
pas y accéder tant que votre disque utilitaire sera monté&nbsp;;
</para></listitem>
<listitem><para>L'accès aux fichiers du disque utilitaire sera lent.
</para></listitem>
</orderedlist>
<para>
L' <xref linkend="utilitylist"/> montre ce que peut contenir un tel
disque. Voici quelques idées de fichiers qui peuvent vous être utiles&nbsp;:
programmes de diagnostic et de manipulation de disques
(<command>format</command>, <command>fdisk</command>) et systèmes de
fichiers (<command>mke2fs</command>, <command>fsck</command>,
<command>debugfs</command>, <filename>isofs.o</filename>), un éditeur de
texte léger (<command>elvis</command>, <command>jove</command>), des
utilitaires de compression et archivage (<command>gzip</command>,
<command>tar</command>, <command>cpio</command>,
<command>afio</command>), de gestion de bande (<command>mt</command>,
<command>ftmt</command>, <command>tob</command>,
<command>taper</command>), de communication (<filename>ppp.o</filename>,
<filename>slip.o</filename>, <command>minicom</command>) et de gestion
de périphériques (<command>setserial</command>,
<command>mknod</command>).
</para>
</sect2>
</sect1>
<sect1 id="pros"><title>La méthode des pros</title>
<para>
Vous avez peut-être remarqué comme les disques d'amorce utilisés par
les principales distributions comme Slackware, RedHat ou Debian
paraissent plus sophistiqués que ce que décrit ce document. Les
disques d'amorce de distribution professionnelles se basent sur les
mêmes principes que ceux décrits ici, mais utilisent diverses astuces
pour satisfaire aux besoins supplémentaires de leurs disques
d'amorce. Tout d'abord, ils doivent pouvoir fonctionner sur une grande
variété de matériel et doivent donc pouvoir interagir avec
l'utilisateur et charger divers gestionnaires de
périphériques. Ensuite, ils doivent pouvoir travailler avec beaucoup
d'options d'installation différentes, de manière plus ou moins
automatique. Enfin, les disques d'amorce des distributions combinent
en général la possibilité d'installer le système avec celle de le
réparer.
</para>
<indexterm><primary>disque mémoire, initial (initrd)</primary></indexterm>
<para>
Certains disques d'amorce utilisent une fonctionnalité appelée
<command>initrd</command> (<emphasis>initial ramdisk</emphasis>, ou
<emphasis>disque mémoire initial</emphasis>). Cette fonctionnalité est
apparue aux alentours de la version 2.0.x et permet au noyau de démarrer
en deux étapes. Quand le noyau commence son démarrage, il charge une
première image de disque mémoire depuis le disque d'amorce. Ce disque
mémoire initial est un système racine contenant un programme à exécuter
avant le chargement du vrai système racine. Ce programme inspecte en
général l'environnement et/ou demande à l'utilisateur de sélectionner
diverses options de démarrage, telles que le périphérique sur lequel on
va trouver le vrai disque racine. En général, il charge des modules
supplémentaires ne faisant pas partie du noyau. Quand ce programme
initial se termine, le noyau charge la vraie image racine et continue
son démarrage normalement. Pour plus d'information sur
<command>initrd</command>, lisez
<filename>/usr/src/linux/Documentation/initrd.txt</filename> et <ulink
url="ftp://elserv.ffm.fgan.de/pub/linux/loadlin-1.6/initrd-example.tgz">
ftp://elserv.ffm.fgan.de/pub/linux/loadlin-1.6/initrd-example.tgz</ulink>.
</para>
<para>
Vous trouverez ci-dessous des résumés sur la manière dont les disques
d'installation de chaque distribution semblent marcher, après étude de
leurs systèmes de fichiers et/ou code source. Nous ne garantissons pas
l'exactitude des informations, ni qu'elles n'ont pas changé depuis les
versions indiquées.
</para>
<para>
Slackware (v.3.1) utilise un démarrage direct avec
<command>LILO</command> semblable à la description de la <xref
linkend="usinglilo"/>.  Le disque d'amorce de la Slackware affiche un
message de démarrage (<emphasis>Welcome to the Slackware Linux
bootkernel disk!</emphasis>) en utilisant le paramètre
<option>message</option> de <command>LILO</command>. Ce message indique
à l'utilisateur d'entrer une ligne  de paramètres de démarrage si
nécessaire. Après le démarrage, un système  racine est chargé depuis une
seconde disquette. L'utilisateur lance un  script de configuration
(<command>setup</command>) qui démarre l'installation. Au lieu
d'utiliser  un noyau modulaire, Slackware fournit un certain nombre de
noyaux différents, et c'est à l'utilisateur de fournir celui qui
correspond à sa configuration matérielle.
</para>
<para>
RedHat (v.4.0) utilise aussi un démarrage avec <command>LILO</command>.
Il charge un disque mémoire compressé sur le premier disque, qui fait
tourner une version personnalisée d'<command>init</command>. Ce
programme demande quels gestionnaires utiliser puis charge des fichiers
supplémentaires depuis un autre disque si nécessaire.
</para>
<para>
Debian (v.1.3) possède probablement le groupe de disques d'installation
le plus sophistiqué. Il utilise le chargeur <command>SYSLINUX</command>
pour choisir différentes options de chargement, puis utilise une image
<command>initrd</command> pour guider l'utilisateur dans l'installation.
Il semble utiliser à la fois des versions personnalisées
d'<command>init</command> et du shell.
</para>
</sect1>
<sect1 id="cdrom"><title>Créer des CD-ROM amorçables</title>
<para>
Cette section a été écrite avec la contribution de Rizwan Mohammed Darwe
(rizwan CHEZ clovertechnologies POINT com).
</para>
<para>
Cette section suppose que vous êtes familier avec la procédure et le
fonctionnement de l'écriture de CD sous Linux. Considérez ceci comme
une référence rapide pour inclure la possibilité de démarrer à partir du
CD que vous allez graver. La CD-Writing-HOWTO devrait vous donner plus
de détails.
</para>

<sect2>

<title>Qu'est-ce que El Torito&nbsp;?</title>

<para>
À partir des plates-formes x86, plusieurs <acronym>BIOS</acronym> ont
commencé à accepter les CD amorçables. Les rustines pour 
<command>mkisofs</command> sont basés sur le standard appelé 
&laquo;&nbsp;El Torito&nbsp;&raquo;. En deux mots, El Torito est une 
spécification qui indique le format qu'un CD doit respecter, afin de 
pouvoir démarrer directement sur celui-ci.
</para>

<para>
La spécification &laquo;&nbsp;El Torito&nbsp;&raquo; dit que 
<emphasis>tout</emphasis> lecteur de CD-ROM devrait fonctionner (SCSI ou 
EIDE) si le <acronym>BIOS</acronym> est compatible El Torito. Sauf que 
cela n'a été testé qu'avec des lecteurs EIDE, car aucun contrôleur SCSI 
testé ne semble supporter El Torito. La carte mère doit impérativement 
être compatible El Torito. Comment savoir si votre carte mère 
est compatible El Torito&nbsp;? Eh bien les cartes mères compatibles 
offrent le choix de démarrer à partir du disque dur, de la disquette, du 
réseau ou du CD-ROM.
</para>

</sect2>

<sect2>

<title>Comment ça marche</title>

<para>
Le standard El Torito fonctionne en faisant apparaître le lecteur de CD,
à travers les appels <acronym>BIOS</acronym>, comme un lecteur de
disquettes normal. De cette façon vous mettez simplement n'importe
quelle image de la taille d'une disquette (exactement 1440&nbsp;ko pour une
disquette de 1,44&nbsp;Mo) quelque part sur le système de fichiers ISO. Dans
l'en-tête du système de fichiers ISO vous placez un pointeur vers cette
image. Le <acronym>BIOS</acronym> va alors récupérer cette image à
partir du CD et agit comme si il démarrait à partir du lecteur de
disquettes. Cela permet à une disquette de démarrage 
<command>LILO</command>, par exemple, d'être utilisée simplement comme
si c'était une vraie disquette.
</para>
<para>
En général, les 1,44 (ou 2,88 si supportés) premiers Mo du CD-ROM
contiennent une image de la disquette créée par vous. Cette image est
traitée comme une disquette par le <acronym>BIOS</acronym> et démarrée
par celui-ci. (Avec comme conséquence, lors du démarrage à partir de la
disquette virtuelle, que votre lecteur original <emphasis>A:</emphasis>
(<filename>/dev/fd0</filename>) ne sera plus accessible, mais vous
pouvez toujours essayer <filename>/dev/fd1</filename>).
</para>
</sect2>
<sect2><title>Comment le faire marcher</title>
<para>
D'abord, il faut créer un fichier, disons <filename>boot.img</filename>,
qui est l'image exacte de la disquette que vous voulez démarrer via le
CD-ROM. Ce doit être une disquette de démarrage 1,44&nbsp;Mo. La commande
suivante permet de la créer&nbsp;:
</para>

<programlisting format="linespecific">
dd if=/dev/fd0 of=boot.img bs=10k count=144
</programlisting>

<para>
en supposant que la disquette se trouve dans le lecteur
<emphasis>A:</emphasis>.
</para>
<para>
Placez cette image quelque part dans la hiérarchie qui sera la source du
système de fichiers iso9660. C'est une bonne idée de mettre tous les
fichiers relatifs au démarrage dans leur propre répertoire
(<filename>boot/</filename> sous la racine du système de fichiers
iso9660, par exemple).
</para>
<para>
Avertissement&nbsp;: Votre disquette de démarrage <emphasis>doit</emphasis>
charger un <emphasis>initial ramdisk</emphasis> via
<command>LILO</command>, et pas le disque mémoire du noyau&nbsp;! Ceci est du
au fait que lorsque le noyau démarre, l'émulation
<acronym>BIOS</acronym> du CD comme disquette est limitée et va échouer.
<command>LILO</command> va charger le disque mémoire en utilisant les
appels disques <acronym>BIOS</acronym>, et l'émulation fonctionne
normalement.
</para>

<para>
La spécification El Torito requiert également la création d'un
<emphasis>catalogue de démarrage</emphasis>. Il s'agit d'un fichier de
2048&nbsp;octets qui n'a pas grand intérêt à part qu'il est nécessaire. 
La correction réalisée par l'auteur de <command>mkisofs</command> permet 
la création automatique de ce catalogue de démarrage, mais vous devez 
spécifier où ce catalogue doit se trouver dans la hiérarchie du système 
de fichiers iso9660. En général c'est une bonne idée de le mettre au 
même endroit que l'image de démarrage, et de l'appeler 
<filename>boot.catalog</filename>. La commande pour créer le système de 
fichiers iso9660 dans le fichier <filename>bootcd.iso</filename> est 
alors&nbsp;:
</para>

<programlisting format="linespecific">
mkisofs -r -b boot/boot.img -c boot/boot.catalog -o bootcd.iso .
</programlisting>

<para>
L'option <option>-b</option> précise l'image de démarrage à utiliser
(notez que le chemin est relatif à la racine du disque iso9660), et
l'option <option>-c</option> est pour le fichier catalogue de démarrage.
L'option <option>-r</option> va mettre les propriétaires et droits des
fichiers appropriés (voir la page de manuel de
<command>mkisofs</command>). Le &laquo;&nbsp;.&nbsp;&raquo; à la fin dit de prendre comme source
le répertoire courant.
</para>

<para>
Maintenant gravez le CD avec la commande habituelle et le voilà prêt à
démarrer.
</para>

</sect2>

<sect2>

<title>Créer des CD-ROM Win9x amorçables</title>

<para>
La première chose à faire est de récupérer une image amorçable utilisée
par le CD source. Mais vous ne pouvez pas vous contenter de monter 
le CD sous Linux et d'utiliser <command>dd</command> pour copier les 
1440 premiers kilo-octets vers une disquette ou 
un fichier <filename>boot.img</filename>. Au lieu de cela, vous devez 
simplement amorcer votre système à partir du CD-ROM source.
</para>

<para>
Lorsque vous démarrez le CD Win98 vous vous retrouvez à l'invite
<emphasis>A:</emphasis>, qui est en fait le disque mémoire. Et
<emphasis>D:</emphasis> ou <emphasis>Z:</emphasis> où se trouvent tous 
les fichiers d'installation. En utilisant la commande DOS
<command>diskcopy</command>, copiez l'image <emphasis>A:</emphasis> dans
le vrai lecteur de disquettes, qui est maintenant 
<emphasis>B:</emphasis>. La commande suivante permet de le faire&nbsp;:
</para>

<programlisting format="linespecific">
diskcopy A: B:
</programlisting>

<para>
Cela fonctionne exactement comme <command>dd</command>. Vous pouvez
essayer de démarrer à partir de ce disque fraîchement créé pour tester
si le processus de démarrage est similaire à celui du CD source. Ensuite
faites le <command>dd</command> habituel de cette disquette vers un fichier
comme <filename>boot.img</filename> et le reste sera comme d'habitude.
</para>

</sect2>
</sect1>

<sect1>

<title>Foire Aux Questions (FAQ)</title>

<qandaset defaultlabel='qanda'>

<qandaentry>
<question>
<para>
Je démarre depuis mes disques d'amorce/racine et rien ne se
passe. Que faire&nbsp;?
</para>
</question>

<answer>
<para>
Voir la section précédente <xref linkend="troubleshooting"/>.
</para>
</answer>
</qandaentry>

<qandaentry>
<question><para>
Comment fonctionne le disque d'amorce
Slackware/Debian/RedHat&nbsp;?
</para></question>

<answer><para>
Voir la section précédente <xref linkend="pros"/>.
</para></answer>
</qandaentry>

<qandaentry>
<question>
<para>
Comment utiliser des disquettes de haute densité (> 1440&nbsp;ko)&nbsp;? 
Comment savoir quelles densités fonctionneront avec mon lecteur de 
disquette&nbsp;?
</para>
</question>

<answer>
<para>
Voir dans la section précédente <xref linkend="high-density"/> les
commentaires de Alain Knaff à ce sujet. C'est la réponse la plus
crédible que je connaisse.
</para>
</answer>
</qandaentry>

<qandaentry>
<question>
<para>
Comment augmenter la taille de mes disques mémoire&nbsp;?
</para>
</question>

<answer>
<para>
Cela devrait être mieux expliqué dans le texte, mais je met une réponse
ici pour l'instant.
</para>
<para>
D'abord, <emphasis>n'essayez pas</emphasis> d'utiliser
<command>rdev</command> ou <command>ramsize</command> pour faire cela,
quoi qu'en disent leurs documentations. Le mot disque mémoire ne
détermine plus la taille des disques mémoires.
</para>
<para>
Ensuite, gardez à l'esprit que les disques mémoires sont actuellement
dynamiques&nbsp;; lorsque vous définissez la taille d'un disque mémoire vous
n'allouez pas de mémoire, vous précisez juste de combien il peut
grandir. N'ayez pas peur de choisir une taille inutilement trop grande
(par exemple 8 ou même 16&nbsp;Mo). L'espace RAM n'est pas utilisé tant que
vous n'en n'avez pas besoin. Vous pouvez définir ces limites  de
plusieurs façons différentes&nbsp;:
</para>
<orderedlist>
<listitem><para>Utilisez le paramètre <option>ramdisk_size=NNN</option>
en ligne de commande. Vous pouvez soit le rentrer à la main soit
utiliser une commande comme
<emphasis>append="ramdisk_size=NNN"</emphasis> avec
<command>LILO</command>&nbsp;;</para></listitem>
<listitem><para>Si vous utilisez <command>LILO</command>, vous pouvez
utiliser une option du noyau comme <option>ramdisk=8192K</option> dans
le fichier <filename>lilo.conf</filename>&nbsp;;</para></listitem>
<listitem><para>Changez l'option de configuration du noyau
<emphasis>CONFIG_BLK_DEV_RAM_SIZE</emphasis> et recompilez votre
noyau.</para></listitem>
</orderedlist>
</answer>
</qandaentry>

<qandaentry>
<question>
<para>
Comment faire des CD-ROM amorçables&nbsp;?
</para>
</question>

<answer>
<para>
Voir la section précédente <xref linkend="cdrom"/>.
</para>
</answer>
</qandaentry>

<qandaentry>
<question>
<para>
Comment faire des disquettes LS-120 amorçables&nbsp;?
</para>
</question>

<answer>
<para>
Comme je n'ai pas de lecteur de disquettes LS-120, les informations qui
suivent sont un résumé fourni par David Cinege du Linux Router Project.
</para>
<para>
Le LS-120 est un lecteur de disquettes IDE. Il est compatible à la fois
avec les disquettes 3,5&nbsp;&raquo; et les nouvelles disquettes de 120&nbsp;Mo. Depuis
Linux 2.0.31, celles-ci sont complètement supportées. Pour être capable de
démarrer à partir de ces disquettes, vous devez avoir un
<acronym>BIOS</acronym> qui autorise le LS-120 à être traité comme
lecteur 0 (alors que les lecteurs IDE commencent normalement à 80). Si
vous n'avez pas le support du <acronym>BIOS</acronym>, vous pouvez
acheter une petite carte IDE FloppyMAX de Promise Technologies pour
combler ce manque.
</para>
<para>
Le chargeur du noyau n'aime pas le LS-120, et meurt instantanément. Les
disques 2m non plus ne l'aiment pas et ne démarreront pas. Les
disquettes de 1,44 à 1,74&nbsp;Mo fonctionnent bien.
<command>SYSLINUX</command> fonctionne avec les disquettes de 120&nbsp;Mo à
partir de la version 1.32. Vous auriez intérêt à partitionner la
disquette et utiliser ext2 ou minix, au lieu de
<command>SYSLINUX</command>, sauf si vous avez besoin d'une
compatibilité MS-DOS.
</para>
<para>
<command>LILO</command> fonctionne bien avec des disquettes de 120&nbsp;Mo.
Voici un <filename>lilo.conf</filename> simple&nbsp;:
</para>

<programlisting format="linespecific">
         boot=/dev/hda
         compact
         disk=/dev/hda bios=0
         install=/floppy/boot.b
         map=/floppy/map
         image=/floppy/linux
         label=Linux
         append="load_ramdisk=1"
         initrd=/floppy/root.bin
         ramdisk=8192
</programlisting>

<para>
La ligne <emphasis>disk=/dev/hda bios=0</emphasis> est la ruse pour
démarrer à partir du LS-120.
</para>
</answer>
</qandaentry>

<qandaentry>
<question>
<para>
Comment faire un disque d'amorce avec un gestionnaire pour XYZ&nbsp;?
</para>
</question>

<answer>
<para>
Le plus simple est d'obtenir un noyau Slackware depuis le site miroir
de Slackware le plus proche. Les noyaux Slackware sont des noyaux
génériques contenant le plus de gestionnaires pour le plus de
périphériques différents possibles. Si vous avez un contrôleur SCSI
ou IDE, vous avez de bonnes chances de trouver un gestionnaire
correspondant dans le noyau Slackware.
</para>
<para>
Allez dans le répertoire <filename>a1</filename> et sélectionnez un
noyau SCSI ou IDE suivant votre type de contrôleur. Vérifiez dans le
fichier <filename>xxxxkern.cfg</filename> correspondant au noyau choisi
qu'il contient bien les gestionnaires que vous voulez. Si c'est le cas,
le noyau correspondant devrait pouvoir démarrer votre ordinateur.
Récupérez le fichier <filename>xxxxkern.tgz</filename> et copiez-le sur
votre disquette d'amorce comme indiqué dans la section sur la
fabrication des disques d'amorce.
</para>
<indexterm><primary>gestionnaires de périphériques</primary></indexterm>
<para>
Vous devez ensuite vérifier le périphérique racine indiqué dans le
noyau, en utilisant la commande&nbsp;:
</para>

<programlisting format="linespecific">
rdev zImage
</programlisting>

<para>
<command>rdev</command> vous montrera alors le périphérique actuellement
configuré dans le noyau. Si ce n'est pas celui que vous voulez, utilisez
<command>rdev</command> pour le changer. Par exemple, le noyau que j'ai
essayé pointait sur <filename>/dev/sda2</filename>, mais ma partition
racine SCSI est sur <filename>/dev/sda8</filename>. Pour utiliser une
disquette racine, vous devrez lancer la commande&nbsp;:
</para>

<programlisting format="linespecific">
rdev zImage /dev/fd0
</programlisting>

<para>
Si vous voulez aussi savoir comment configurer un disque racine
Slackware, cela dépasse le cadre de ce HOWTO, et je vous suggère donc
de consulter le Guide d'installation de Linux ou de récupérer la
distribution Slackware. Voir l'<xref linkend="references"/> de ce HOWTO.
</para>
</answer>
</qandaentry>

<qandaentry>
<question>
<para>
Comment mettre à jour le noyau de ma disquette d'amorce&nbsp;?
</para>
</question>

<answer>
<para>
<indexterm><primary>noyau, mise à jour</primary></indexterm>
Copiez simplement le noyau sur votre disquette d'amorce à l'aide de la
commande <command>dd</command> s'il s'agit d'une disquette d'amorce sans
système de fichier, ou par la commande <command>cp</command> pour un
disque d'amorce/racine. Reportez-vous à la <xref linkend="boot"/> de ce
HOWTO pour les détails de création d'un disque d'amorce. Le processus
décrit s'applique aussi bien à la mise à jour d'un noyau sur le disque
d'amorce.
</para>
</answer>
</qandaentry>

<qandaentry>
<question>
<para>
Comment mettre à jour ma disquette racine avec de nouveaux
fichiers&nbsp;?
</para>
</question>

<answer>
<para>
<indexterm><primary>système racine, mise à jour</primary></indexterm>
Le plus simple est de recopier le système de fichiers depuis le disque
racine vers le PÉRIPHÉRIQUE que vous avez utilisé (comme dans la
section précédente <xref linkend="creatingrootfs"/>
). Montez ensuite le système de fichiers et modifiez-le. Vous
devez vous souvenir d'où partait votre système racine et du nombre de
blocs qu'il occupait&nbsp;:
</para>

<programlisting format="linespecific">
dd if=/dev/fd0 bs=1k skip=DEBUTRACINE count=BLOCS | \
        gunzip > PÉRIPHÉRIQUE
mount -t ext2 PÉRIPHÉRIQUE /mnt
</programlisting>

<para>
Une fois les modifications effectuées, recommencez comme précédemment
(dans la <xref linkend="wrappingitup"/>)
et retransférez le système racine sur le disque. Vous ne devriez pas
avoir à retransférer le noyau ou à recalculer le mot disque mémoire si
vous ne changez pas la position de départ du nouveau système de
fichiers.
</para>
</answer>
</qandaentry>

<qandaentry>
<question>
<para>
Comment retirer <command>LILO</command> pour pouvoir redémarrer DOS&nbsp;?
</para>
</question>

<answer>
<para>
<indexterm remap="ncdx"><primary><literal>LILO</literal></primary></indexterm>
<indexterm><primary>Master Boot Record
(<acronym>MBR</acronym>)</primary></indexterm>
Ce n'est pas réellement un problème de disque d'amorce, mais il est
souvent posé. Sous Linux, vous pouvez lancer&nbsp;:
</para>

<programlisting format="linespecific">
/sbin/lilo -u
</programlisting>

<para>
Vous pouvez aussi utiliser la commande <command>dd</command> pour copier
la sauvegarde effectuée par <command>LILO</command> sur le secteur
d'amorce. Reportez-vous à la documentation de <command>LILO</command> si
vous voulez essayer.
</para>
<para>
Sous DOS et Windows vous pouvez utiliser la commande DOS&nbsp;:
</para>

<programlisting format="linespecific">
FDISK /MBR
</programlisting>

<para>
<acronym>MBR</acronym> signifie Master Boot Record (Enregistrement
d'amorce Maître), et il remplace le secteur de démarrage avec une
version propre du <acronym>DOS</acronym>, sans modifier la table de
partitions. Certains puristes n'apprécient pas cette méthode, mais même
l'auteur de <command>LILO</command>, Werner Almesberger, le suggère.
C'est facile et ça marche.
</para>
</answer>
</qandaentry>

<qandaentry>
<question>
<para>
Comment puis-je démarrer si j'ai perdu mon noyau <emphasis>et</emphasis>
mon disque d'amorce&nbsp;?
</para>
</question>

<answer><para>
Si vous n'avez pas de disque d'amorce sous la main, le plus simple est
d'obtenir un noyau Slackware pour votre type de contrôleur de disque
(IDE ou SCSI) comme décrit précédemment dans &laquo;&nbsp;Comment faire
un disque d'amorce avec un gestionnaire pour XYZ&nbsp;?&nbsp;&raquo;. Vous
pouvez alors démarrer votre ordinateur avec ce noyau, puis réparer les
dommages éventuels.
</para>
<para>
Le noyau que vous récupérerez peut ne pas avoir comme périphérique
racine ce que vous souhaitez comme disque et partition. Par exemple, le
noyau générique SCSI de Slackware utilise <filename>/dev/sda2</filename>
comme périphérique racine, alors que ma partition racine Linux se trouve
être <filename>/dev/sda8</filename>. Dans ce cas il faut changer le
périphérique racine.
</para>
<para>
Vous pouvez changer les paramètres de périphérique racine et disque
mémoire du noyau même si vous n'avez que le noyau, et un autre système
d'exploitation tel que DOS.
</para>
<para>
<command>rdev</command> modifie les paramètres du noyau en changeant les
valeurs à un décalage fixé dans le fichier du noyau, et vous pouvez donc
faire de même si vous avez un éditeur hexadécimal disponible sous
quelque système d'exploitation fonctionnant encore &mdash; par exemple,
Norton Utilities Disk Editor sous DOS. Vous devez alors vérifier puis
éventuellement modifier les valeurs dans le noyau, aux décalages
suivants&nbsp;:
</para>

<programlisting format="linespecific">
HEX     DEC  DESCRIPTION
0x01F8  504  Octet de poids faible du mot disque mémoire
0x01F9  505  Octet de poids fort du mot disque mémoire
0x01FC  508  Numéro mineur du périphérique racine&nbsp;: voir ci-dessous
0X01FD  509  Numéro majeur du périphérique racine&nbsp;: voir ci-dessous
</programlisting>

<para>
L'interprétation du mot disque mémoire était décrite dans la
précédente <xref linkend="ramdiskword"/>.
</para>
<para>
Les numéros majeurs et mineurs de périphérique doivent correspondre au
périphérique à partir duquel le système racine sera monté. Certaines
valeurs utiles parmi lesquelles vous pouvez choisir sont&nbsp;:
</para>

<programlisting format="linespecific">
DEVICE        MAJEUR MINEUR
/dev/fd0           2      0   1er lecteur de disquette
/dev/hda1          3      1   partition 1 sur le 1er disque IDE
/dev/sda1          8      1   partition 1 sur le 1er disque SCSI
/dev/sda8          8      8   partition 8 sur le 1er disque SCSI
</programlisting>

<para>
Une fois ces valeurs mises en place, vous pouvez écrire le fichier sur
une disquette en utilisant soit Norton Utilities Disk Editor, soit un
programme appelé <command>rawrite.exe</command>. Ce programme est inclus
dans toutes les distributions. C'est un programme DOS qui écrit
directement un fichier sur le disque, en commençant à partir du secteur
d'amorce, au lieu de l'écrire dans le système de fichiers. Si vous
utilisez Norton Utilities, vous devez écrire le fichier sur un disque
physique en commençant au début du disque.
</para>
</answer>
</qandaentry>

<qandaentry>
<question>
<para>
Comment faire des copies supplémentaires des disquettes
d'amorce/racine&nbsp;?
</para>
</question>

<answer>

<para>
Les supports magnétiques se détériorant avec le temps, vous devriez
conserver plusieurs copies de votre disque de secours, au cas où
l'original ne serait plus lisible.
</para>

<para>
Le plus simple pour copier une disquette quelle qu'elle soit, y compris
une disquette d'amorce ou utilitaire, est d'utiliser la commande
<command>dd</command> pour copier le contenu de la disquette originale
vers un fichier de votre disque dur, puis de réutiliser la même commande
pour recopier le fichier vers une nouvelle disquette. Notez que vous
n'avez pas besoin de monter la disquette, et ne devriez pas le faire,
car <command>dd</command> utilise l'interface directe du périphérique.
</para>

<para>
Pour copier l'original, entrez la commande&nbsp;:
</para>

<programlisting format="linespecific">
dd if=<replaceable>NOMPÉRIPHÉRIQUE</replaceable> of=<replaceable>NOMFICHIER</replaceable>
</programlisting>

<para>
où <replaceable>NOMPÉRIPHÉRIQUE</replaceable> est le nom du périphérique
du lecteur de disquette et <replaceable>NOMFICHIER</replaceable> le nom 
du fichier de sortie (sur le disque dur).
</para>

<para>
Ne pas mettre le paramètre <option>count</option> permet à
<command>dd</command> de copier la disquette en entier (2880&nbsp;blocs 
en haute densité).
</para>

<para>
Pour recopier le fichier résultant sur une nouvelle disquette, insérez
celle-ci et entrez la commande inverse&nbsp;:
</para>

<programlisting format="linespecific">
dd if=<replaceable>NOMFICHIER</replaceable> of=<replaceable>NOMPÉRIPHÉRIQUE</replaceable>
</programlisting>

<para>
À noter que la discussion précédente suppose que vous n'avez qu'un
seul lecteur de disquette. Si vous en avez deux du même type, vous
pouvez copier les disquettes à l'aide d'une commande du type&nbsp;:
</para>

<programlisting format="linespecific">
dd if=/dev/fd0 of=/dev/fd1
</programlisting>

</answer>
</qandaentry>

<qandaentry>
<question><para>
Comment puis-je démarrer sans avoir à taper 
&laquo;&nbsp;ahaxxxx=nn,nn,nn&nbsp;&raquo; à chaque fois&nbsp;?
</para></question>

<answer>

<para>
<indexterm><primary>noyau, paramètres</primary></indexterm>
Quand un périphérique disque ne peut pas être détecté automatiquement,
il faut fournir au noyau une chaîne de paramètres de commande du
périphérique, telle que&nbsp;:
</para>

<programlisting format="linespecific">
aha152x=0x340,11,3,1
</programlisting>

<para>
Cette chaîne peut être fournie de différentes manières grâce à
<command>LILO</command>&nbsp;:
</para>

<itemizedlist>

<listitem><para>
En l'entrant sur la ligne de commande à chaque démarrage du système avec 
<command>LILO</command>. C'est assez ennuyeux&nbsp;;
</para></listitem>

<listitem><para>
En utilisant le mot clé <emphasis>lock</emphasis> de 
<command>LILO</command> pour lui faire stocker la ligne de commande 
comme ligne de commande par défaut, ce qui fera utiliser à 
<command>LILO</command> les mêmes options à chaque démarrage&nbsp;;
</para></listitem>

<listitem><para>
En utilisant la directive <emphasis>append=</emphasis> dans le fichier 
de configuration de <command>LILO</command>. Attention à encadrer la 
chaîne de paramètres avec des guillemets.
</para></listitem>

</itemizedlist>

<para>
Par exemple, une ligne de commande utilisant la chaîne ci-dessus
serait&nbsp;:
</para>

<programlisting format="linespecific">
zImage aha152x=0x340,11,3,1 root=/dev/sda1 lock
</programlisting>

<para>
Cela passerait la chaîne de paramètres pour le périphérique tout en
demandant au noyau d'utiliser <filename>/dev/sda1</filename> comme
périphérique racine et de sauvegarder la ligne de commande pour la
réutiliser pour tous les démarrages futurs.
</para>
<para>
Un exemple de directive <emphasis>APPEND</emphasis> peut être&nbsp;:
</para>

<programlisting format="linespecific">
APPEND = "aha152x=0x340,11,3,1"
</programlisting>

<para>
Attention, la chaîne de paramètres ne doit PAS être entourée de
guillemets sur la ligne de commande, mais DOIT l'être dans la
directive <emphasis>APPEND</emphasis>.
</para>

<para>
Notez aussi que pour que la chaîne de paramètres soit utilisée, le noyau
doit contenir le gestionnaire pour ce type de disque. Si ce n'est pas le
cas, personne n'écoutera la chaîne de paramètres, et vous devrez
reconstruire le noyau pour inclure le gestionnaire requis. Pour plus de
détails sur la reconstruction du noyau, rendez-vous dans
<filename>/usr/src/linux</filename> et lisez le
<filename>README</filename>, ou lisez la FAQ Linux et le HOWTO
Installation. Vous pouvez aussi obtenir un noyau générique pour votre
type de disque et l'installer.
</para>

<para>
Il est fortement recommandé aux lecteurs de lire la documentation de
<command>LILO</command> avant de faire des expériences d'installation de
<command>LILO</command>. Une utilisation imprudente de la directive
<emphasis>BOOT</emphasis> peut endommager des partitions.
</para>

</answer>
</qandaentry>

<qandaentry>

<question><para>
Au démarrage, j'obtiens l'erreur &laquo;&nbsp;A: cannot execute 
B&nbsp;&raquo;. Pourquoi&nbsp;?
</para></question>

<answer><para>
<indexterm><primary>chemins d'accès en dur</primary></indexterm>
Il existe plusieurs utilitaires qui référencent en dur le nom d'autres
programmes. Ça n'arrive pas tout le temps, mais cela peut expliquer
pourquoi un exécutable peut ne pas être trouvé sur votre système même si
vous l'y voyez. Vous pouvez vérifier si un programme donné est référencé
en dur dans un autre en utilisant la commande <command>strings</command>
et en passant son résultat par <command>grep</command>.
</para>

<para>
On trouve comme exemples connus de référence en dur&nbsp;:
</para>

<itemizedlist>

<listitem><para>
<command>shutdown</command> dans certaines versions référence
<filename>/etc/reboot</filename> en dur, et <command>reboot</command>
doit donc être placé dans le répertoire <filename>/etc</filename>&nbsp;;
</para></listitem>

<listitem><para>
<command>init</command> a posé des problèmes à au moins une personne,
pour qui le noyau ne trouvait pas <command>init</command>.
</para></listitem>

</itemizedlist>

<para>
Pour corriger ces problèmes, vous pouvez soit déplacer les programmes
vers le répertoire attendu, soit changer les fichiers de configuration
(par exemple <filename>inittab</filename>) pour référencer le bon
répertoire. En cas de doute, mettez les programmes dans le même
répertoire que sur votre disque dur, et utilisez les mêmes fichiers
<filename>inittab</filename> et <filename>/etc/rc.d</filename> que sur
celui-ci.
</para></answer>

</qandaentry>

<qandaentry>

<question><para>
Mon noyau gère les disques mémoires, mais les initialise à 0&nbsp;ko
</para></question>

<answer><para>
Quand cela arrive, un message du noyau apparaîtra au moment du
démarrage, du type&nbsp;:
</para>

<indexterm><primary>disque mémoire</primary></indexterm>

<programlisting format="linespecific">
Ramdisk driver initialized&nbsp;: 16 ramdisks of 0K size
</programlisting>

<para>
C'est probablement parce que la taille a été fixée par les paramètres
du noyau à 0 au moment du démarrage. Cela peut être dû à un paramètre
oublié dans le fichier de configuration de <command>LILO</command>&nbsp;:
</para>

<programlisting format="linespecific">
ramdisk= 0
</programlisting>

<para>
Certaines vieilles distributions l'incluaient dans des exemples de
fichiers de configuration de <command>LILO</command>, et servaient à
écraser les paramètres antérieurs du noyau. Si vous trouvez une telle
ligne, supprimez-la.
</para>

<para>
Attention, si vous essayez d'utiliser un disque mémoire dont la taille
est de 0&nbsp;ko, le comportement est imprévisible et peut conduire à une
panique (panic) du noyau.
</para></answer>

</qandaentry>

</qandaset>

</sect1>

<appendix id="references">

<title>Ressources et pointeurs</title>

<para>
Lorsque vous récupérez un paquetage, prenez toujours la dernière
version, sauf si vous avez de bonnes raisons pour ne pas le faire.
</para>

<sect1 id="distbootdisks">

<title>Disques d'amorce préfabriqués</title>

<para>
Ce sont les sources des disques d'amorce des distributions.
<emphasis>Merci d'utiliser un site miroir pour réduire la charge sur ces
machines.</emphasis>
</para>

<itemizedlist>

<listitem><para>
<ulink
url="http://distro.ibiblio.org/pub/Linux/distributions/slackware/slackware-current/bootdisks/">Disques
d'amorce Slackware</ulink>, <ulink
url="http://distro.ibiblio.org/pub/Linux/distributions/slackware/slackware-current/rootdisks/">disques
racines</ulink> et <ulink url="http://www.slackware.com/getslack/">sites
miroirs Slackware </ulink>&nbsp;;
</para></listitem>

<listitem><para>
<ulink 
url="ftp://ftp.redhat.com/pub/redhat/linux/current/en/os/i386/images/">Disques 
d'amorce RedHat</ulink> et <ulink 
url="http://www.redhat.com/mirrors.html">sites miroirs Red 
Hat</ulink>&nbsp;;
</para></listitem>

<listitem><para>
<ulink
url="ftp://ftp.debian.org/debian/dists/stable/main/disks-i386/current/">
Disques d'amorce Debian</ulink> et <ulink
url="ftp://ftp.debian.org/debian/README.mirrors.html">sites miroirs
Debian</ulink>.
</para></listitem>

<listitem><para>
<ulink url="http://www.linux-mandrake.com/en/ftp.php3">Téléchargements
Mandrake</ulink>.
</para></listitem>

</itemizedlist>

<para>
En plus des disques d'amorce des distributions, les images de disques de
secours suivantes sont disponibles. Sauf précision contraire, elles sont
disponibles dans le répertoire <ulink
url="http://www.ibiblio.org/pub/Linux/system/recovery/!INDEX.html">
http://www.ibiblio.org/pub/Linux/system/recovery/!INDEX.html</ulink>.
</para>

<itemizedlist>

<listitem><para>
<acronym>RIP</acronym> est un système de démarrage/secours qui existe en
plusieurs versions&nbsp;: une qui va sur une disquette de 1,44&nbsp;Mo et une qui
va sur un CD-ROM. Il supporte les grands fichiers et plusieurs programmes
pour la maintenance des disques et le secours. Il supporte ext2, ext3,
iso9660, msdos, ntfs, reiserfs, ufs et vfat. RIP est disponible sur
<ulink
url="http://www.tux.org/pub/people/kent-robotti/looplinux/rip/index.html"></ulink>&nbsp;;
</para></listitem>

<listitem><para>
<acronym>tomsrtbt</acronym>, par Tom Oehser, est un disque
d'amorce/racine unique à base de noyau 2.0, avec de nombreux programmes
de support et fonctionnalités. Il support IDE, SCSI, les bandes, les
adaptateurs réseaux, PCMCIA et plus encore. Environ 100 programmes
utilitaires et autres outils sont inclus, pour réparer et récupérer les
disques. Le paquetage contient aussi des scripts pour désassembler et
reconstruire les images afin de pouvoir ajouter des compléments si
nécessaire&nbsp;;
</para></listitem>

<listitem><para>
<acronym>rescue02</acronym>, par John Comyns, est un disque de secours à
base de noyau 1.3.84, qui supporte IDE, Adaptec 1542 et NCR53C7,8xx. Il
est à base de binaires ELF mais contient suffisamment de commandes pour
être utilisé sur n'importe quel système. Certains modules peuvent être
chargés après le démarrage pour d'autres cartes SCSI. Il ne fonctionnera
probablement pas sur les systèmes avec 4&nbsp;Mo de RAM car il utilise
un disque mémoire de 3&nbsp;Mo&nbsp;; </para></listitem>
<listitem><para><acronym>resque_disk-2.0.22</acronym>, par Sergei
Viznyuk, est un disque d'amorce/racine complet basé sur le noyau 2.0.22,
comprenant le support pour IDE, de nombreux contrôleurs SCSI, et
ELF/a.out. Il contient aussi nombre de modules et d'utilitaires pour
réparer et récupérer un disque dur&nbsp;;
</para></listitem>

<listitem><para>
les images de <acronym>cramdisk</acronym>, à base de noyau 2.0.33,
disponibles pour machines à 4 et 8&nbsp;Mo de mémoire. Elles contiennent
l'émulation mathématique et le réseau (PPP et script dialin, NE2000,
3C509), ou le support pour lecteur ZIP sur port parallèle. Ces images de
disquettes peuvent démarrer un 386 avec 4&nbsp;Mo de RAM. Le support de
MSDOS est inclus, ce qui fait que vous pouvez les récupérer sur le
réseau vers une partition DOS.
</para>

<para>
<ulink url="http://www.ibiblio.org/pub/Linux/system/recovery/images"></ulink>
</para></listitem>

</itemizedlist>

</sect1>

<sect1>
<title>Paquetages de secours</title>

<para>
Plusieurs paquetages de création de disques de secours existent sur
www.ibiblio.org. Vous précisez à ces paquetages un ensemble de fichiers
à inclure, et le logiciel automatise (à divers degrés) la création d'un
disque d'amorce. Voir <ulink
url="http://www.ibiblio.org/pub/Linux/system/recovery/!INDEX.html">
http://www.ibiblio.org/pub/Linux/system/recovery/!INDEX.html</ulink>
pour plus d'informations. <emphasis>Vérifiez bien les dates des
fichiers</emphasis>&nbsp;: certains paquetages n'ont pas été mis à jour
depuis des années et ne supportent pas la création d'un système racine
compressé sur disque mémoire. À notre connaissance, Yard est le seul
paquetage le permettant.
</para>

</sect1>

<!--

<sect1>

<title>Scripts shell et Graham Chapman</title>

<para>
Graham Chapman a écrit un ensemble de scripts pouvant être utiles
comme exemple sur la manière de créer des disques d'amorce. Dans les
précédentes versions de ce HOWTO, les scripts apparaissaient en annexe,
mais ils ont été supprimés du document et placés sur une page web&nbsp;:
</para>

<para>
<ulink url="http://www.zeta.org.au/~grahamc/linux.html"></ulink>
</para>

<para>
Vous pourrez trouver ces scripts utiles&nbsp;; si tel est le cas, lisez
attentivement les instructions&nbsp;: par exemple, si vous précisez le
mauvais périphérique de pagination, vous verrez votre système racine
se faire complètement et définitivement effacer. Vérifiez que vous
l'avez bien configuré avant de le lancer&nbsp;!
</para>

</sect1>

-->

<sect1>

<title>LILO&nbsp;: le chargeur Linux</title>

<para>
<indexterm 
remap="ncdx"><primary><literal>LILO</literal></primary></indexterm> 
Écrit par Werner Almesberger. Excellent chargeur d'amorce, dont la
documentation comprend des informations sur le contenu du secteur
d'amorce et les premières étapes du processus de démarrage.
</para>

<para>
Ftp depuis <ulink 
url="ftp://tsx-11.mit.edu/pub/linux/packages/lilo/"></ulink>. Il est 
aussi disponible sur Metalab et ses miroirs.
</para>

</sect1>

<!--

<sect1>

<title>FAQ Linux et HOWTO</title>

<para>
Ils sont disponibles depuis de nombreuses sources. Jetez un coup
d'&oelig;il au forum Usenet <acronym>news.answers</acronym> et
<acronym>comp.os.linux.announce</acronym> (et <acronym>
fr.comp.os.linux.annonces</acronym>) pour une version française).
</para>

<para>
La FAQ est disponible sur <ulink
url="http://www.ibiblio.org/pub/Linux/docs/faqs/linux-faq"></ulink> et 
les guides pratiques (<foreignphrase>howto</foreignphrase>) sur <ulink 
url="http://www.ibiblio.org/pub/Linux/docs/HOWTO"></ulink>
(en français, sur <ulink url="http://www.traduc.org"></ulink>).
</para>

<para>
La plupart des documentations sur Linux peuvent être trouvées sur la
page principale du Linux Documentation Project <ulink
url="http://www.ibiblio.org/LDP/"></ulink>.
</para>

<para>
Si vous êtes désespéré, envoyez un courrier électronique à 
<email>mail-server CHEZ rtfm POINT mit POINT edu</email> avec le mot 
&laquo;&nbsp;<acronym>help</acronym>&nbsp;&raquo; dans le message, puis 
suivez les instructions.
</para>

</sect1>

-->

<sect1>

<title>Utilisation du disque mémoire</title>

<para>
<indexterm><primary>disque mémoire</primary></indexterm>
La documentation fournie avec le noyau Linux contient une excellente
description de la manière dont fonctionne le nouveau code de disque
mémoire. Voir
<filename>/usr/src/linux/Documentation/ramdisk.txt</filename>. C'est
écrit par Paul Gortmaker, et cela comprend une section sur la création d'un
disque mémoire compressé.
</para>

</sect1>

<sect1>

<title>Le processus de démarrage de Linux</title>

<para>
<indexterm><primary>démarrage, fonctionnement du</primary></indexterm>
Pour plus de détails sur le processus de démarrage de Linux, voici
quelques pointeurs&nbsp;:
</para>

<itemizedlist>

<listitem><para>
Le Linux System Administrators' Guide (Guide des Administrateurs
Systèmes Linux) contient une section sur le démarrage. Voir <ulink
url="&guides;sag/"></ulink>&nbsp;;
</para></listitem>

<listitem><para>
La &laquo;&nbsp;Technical overview&nbsp;&raquo; (Description technique
succincte) de <command>LILO</command> <ulink
url="http://www.ibiblio.org/pub/Linux/system/boot/lilo/lilo-t-21.ps.gz"></ulink>
décrit d'une manière extrêmement poussée le processus de démarrage, d'un
point de vue technique et bas niveau, jusqu'au moment où le noyau est
lancé&nbsp;;
</para></listitem>

<listitem><para>
Le code source est le guide ultime. Ci-dessous se trouvent quelques
fichiers du noyau relatifs au processus de démarrage. Si vous avez le
code source du noyau Linux, vous pouvez les trouver sous
<filename>/usr/src/linux</filename> sur votre machine&nbsp;; sinon, Shigio
Yamaguchi <email>shigio CHEZ wafu POINT netgate POINT net</email> a
un très sympathique navigateur hypertexte pour le noyau à <ulink
url="http://www.tamacom.com/tour/linux/index.html"></ulink>. Voici 
quelques fichiers correspondants&nbsp;:
</para>

<variablelist>

<varlistentry>
 <term>arch/i386/boot/bootsect.S,setup.S</term>
 <listitem><para>
 Contient le code assembleur pour le secteur d'amorce.
 </para></listitem>
</varlistentry>

<varlistentry>
 <term>arch/i386/boot/compressed/misc.c</term>
 <listitem><para>
 Contient le code pour décompresser le noyau.
 </para></listitem>
</varlistentry>

<varlistentry>
 <term>arch/i386/kernel/</term><listitem>
 <para>
 Répertoire contenant le code d'initialisation du noyau. setup.c
 contient le mot disque mémoire.
 </para></listitem>
</varlistentry>

<varlistentry>
 <term>drivers/block/rd.c</term><listitem>
 <para>
 Contient le gestionnaire de disque mémoire. Les procédures rd_load et
 rd_load_image chargent des blocs depuis un périphérique vers un disque
 mémoire. La procédure identify_ramdisk_image détermine le type de
 système de fichiers trouvé, et s'il est compressé.
 </para></listitem>
</varlistentry>

</variablelist></listitem>

</itemizedlist>

</sect1>

</appendix>

<appendix>

<title>Codes d'erreur du démarrage de LILO</title>

<indexterm><primary>LILO, codes d'erreur</primary></indexterm>

<para>
Les questions sur ces erreurs sont posées si souvent sur Usenet que nous
les incluons ici en tant que service public. Ce résumé est extrait de la
Documentation Utilisateur de <command>LILO</command> de Werner
Almesberger, disponible sur <ulink
url="http://www.ibiblio.org/pub/Linux/system/boot/lilo/lilo-u-21.ps.gz"></ulink>.
</para>

<para>
Quand <command>LILO</command> se charge, il affiche le mot
<command>LILO</command>. Chaque lettre est imprimée avant ou après
l'exécution d'une action spécifique. Si <command>LILO</command> échoue à
un moment donné, les lettres affichées jusque là peuvent être utilisées
pour identifier le problème.
</para>

<variablelist>

<varlistentry>
<term>(rien)</term><listitem>
<para>
Aucun morceau de <command>LILO</command> n'a été chargé. Soit
<command>LILO</command> n'est pas installé, soit la partition sur
laquelle son secteur d'amorce se trouve n'est pas active.
</para></listitem>
</varlistentry>

<varlistentry>
<term>L</term>
<listitem><para>
Le premier morceau du chargeur d'amorce a été chargé et démarré, mais
il ne peut charger le second morceau. Les codes d'erreur à deux
chiffres indiquent le type de problème. (Voir également la section
&laquo;&nbsp;Codes d'erreur disque&nbsp;&raquo;.) Ce cas indique en 
général une panne de périphérique ou une incohérence de géométrie (c'est 
à dire de mauvais paramètres disques).
</para></listitem>
</varlistentry>

<varlistentry>
<term>LI</term><listitem>
<para>
Le premier morceau du chargeur d'amorce a pu charger le second
morceau, mais n'a pas réussi à l'exécuter. Cela peut être causé par
une incohérence de géométrie ou par le déplacement de /boot/boot.b
sans lancer l'installateur de carte.
</para></listitem>
</varlistentry>

<varlistentry>
<term>LIL</term><listitem>
<para>
Le second morceau du chargeur d'amorce a été démarré, mais il ne
trouve pas la table de descripteurs dans le fichier carte. C'est en
général dû à une panne de périphérique ou une incohérence de
géométrie.
</para></listitem>
</varlistentry>

<varlistentry>
<term>LIL?</term>
<listitem><para>
Le second morceau du chargeur d'amorce a été chargé à un adresse
incorrecte. C'est en général causé par une subtile incohérence de
géométrie, ou par le déplacement de <filename>/boot/boot.b</filename>
sans lancer l'installateur de carte.
</para></listitem>
</varlistentry>

<varlistentry>
<term>LIL-</term>
<listitem><para>
La table de descripteurs est corrompue. Cela peut être dû à une
incohérence de géométrie ou au déplacement de
<filename>/boot/map</filename> sans lancer l'installateur.
</para></listitem>
</varlistentry>

<varlistentry>
<term>LILO</term>
<listitem><para>
Tous les éléments de <command>LILO</command> ont été correctement chargés.
</para></listitem>
</varlistentry>

</variablelist>

<para>
Si le <acronym>BIOS</acronym> signale une erreur lorsque
<command>LILO</command> essaye de charger une image d'amorce, le code
d'erreur correspondant est affiché. Ces codes vont de
<emphasis>0x00</emphasis> à <emphasis>0xbb</emphasis>. Reportez-vous au
Guide Utilisateur de <command>LILO</command> pour leur explication.
</para>

</appendix>

<appendix id="listings">

<title>Exemple de contenu de répertoires sur un disque racine</title>

<para>
<indexterm><primary>système racine</primary></indexterm>
Voici le contenu d'un exemple de système racine et d'une disquette
utilitaire.
</para>

<programlisting format="linespecific">
 /:
 drwx--x--x   2 root     root         1024 Nov  1 15:39 bin
 drwx--x--x   2 root     root         4096 Nov  1 15:39 dev
 drwx--x--x   3 root     root         1024 Nov  1 15:39 etc
 drwx--x--x   4 root     root         1024 Nov  1 15:39 lib
 drwx--x--x   5 root     root         1024 Nov  1 15:39 mnt
 drwx--x--x   2 root     root         1024 Nov  1 15:39 proc
 drwx--x--x   2 root     root         1024 Nov  1 15:39 root
 drwx--x--x   2 root     root         1024 Nov  1 15:39 sbin
 drwx--x--x   2 root     root         1024 Nov  1 15:39 tmp
 drwx--x--x   7 root     root         1024 Nov  1 15:39 usr
 drwx--x--x   5 root     root         1024 Nov  1 15:39 var
 /bin:
 -rwx--x--x   1 root     root        62660 Nov  1 15:39 ash
 -rwx--x--x   1 root     root         9032 Nov  1 15:39 cat
 -rwx--x--x   1 root     root        10276 Nov  1 15:39 chmod
 -rwx--x--x   1 root     root         9592 Nov  1 15:39 chown
 -rwx--x--x   1 root     root        23124 Nov  1 15:39 cp
 -rwx--x--x   1 root     root        23028 Nov  1 15:39 date
 -rwx--x--x   1 root     root        14052 Nov  1 15:39 dd
 -rwx--x--x   1 root     root        14144 Nov  1 15:39 df
 -rwx--x--x   1 root     root        69444 Nov  1 15:39 egrep
 -rwx--x--x   1 root     root          395 Nov  1 15:39 false
 -rwx--x--x   1 root     root        69444 Nov  1 15:39 fgrep
 -rwx--x--x   1 root     root        69444 Nov  1 15:39 grep
 -rwx--x--x   3 root     root        45436 Nov  1 15:39 gunzip
 -rwx--x--x   3 root     root        45436 Nov  1 15:39 gzip
 -rwx--x--x   1 root     root         8008 Nov  1 15:39 hostname
 -rwx--x--x   1 root     root        12736 Nov  1 15:39 ln
 -rws--x--x   1 root     root        15284 Nov  1 15:39 login
 -rwx--x--x   1 root     root        29308 Nov  1 15:39 ls
 -rwx--x--x   1 root     root         8268 Nov  1 15:39 mkdir
 -rwx--x--x   1 root     root         8920 Nov  1 15:39 mknod
 -rwx--x--x   1 root     root        24836 Nov  1 15:39 more
 -rws--x--x   1 root     root        37640 Nov  1 15:39 mount
 -rwx--x--x   1 root     root        12240 Nov  1 15:39 mt
 -rwx--x--x   1 root     root        12932 Nov  1 15:39 mv
 -r-x--x--x   1 root     root        12324 Nov  1 15:39 ps
 -rwx--x--x   1 root     root         5388 Nov  1 15:39 pwd
 -rwx--x--x   1 root     root        10092 Nov  1 15:39 rm
 lrwxrwxrwx   1 root     root            3 Nov  1 15:39 sh -> ash
 -rwx--x--x   1 root     root        25296 Nov  1 15:39 stty
 -rws--x--x   1 root     root        12648 Nov  1 15:39 su
 -rwx--x--x   1 root     root         4444 Nov  1 15:39 sync
 -rwx--x--x   1 root     root        19712 Nov  1 15:39 touch
 -rwx--x--x   1 root     root          395 Nov  1 15:39 true
 -rws--x--x   1 root     root        19084 Nov  1 15:39 umount
 -rwx--x--x   1 root     root         5368 Nov  1 15:39 uname
 -rwx--x--x   3 root     root        45436 Nov  1 15:39 zcat
 /dev:
 lrwxrwxrwx   1 root     root            6 Nov  1 15:39 cdrom -> cdu31a
 brw-rw-r--   1 root     root      15,   0 May  5  1998 cdu31a
 crw-------   1 root     root       4,   0 Nov  1 15:29 console
 crw-rw-rw-   1 root     uucp       5,  64 Sep  9 19:46 cua0
 crw-rw-rw-   1 root     uucp       5,  65 May  5  1998 cua1
 crw-rw-rw-   1 root     uucp       5,  66 May  5  1998 cua2
 crw-rw-rw-   1 root     uucp       5,  67 May  5  1998 cua3
 brw-rw----   1 root     floppy     2,   0 Aug  8 13:54 fd0
 brw-rw----   1 root     floppy     2,  36 Aug  8 13:54 fd0CompaQ
 brw-rw----   1 root     floppy     2,  84 Aug  8 13:55 fd0D1040
 brw-rw----   1 root     floppy     2,  88 Aug  8 13:55 fd0D1120
 brw-rw----   1 root     floppy     2,  12 Aug  8 13:54 fd0D360
 brw-rw----   1 root     floppy     2,  16 Aug  8 13:54 fd0D720
 brw-rw----   1 root     floppy     2, 120 Aug  8 13:55 fd0D800
 brw-rw----   1 root     floppy     2,  32 Aug  8 13:54 fd0E2880
 brw-rw----   1 root     floppy     2, 104 Aug  8 13:55 fd0E3200
 brw-rw----   1 root     floppy     2, 108 Aug  8 13:55 fd0E3520
 brw-rw----   1 root     floppy     2, 112 Aug  8 13:55 fd0E3840
 brw-rw----   1 root     floppy     2,  28 Aug  8 13:54 fd0H1440
 brw-rw----   1 root     floppy     2, 124 Aug  8 13:55 fd0H1600
 brw-rw----   1 root     floppy     2,  44 Aug  8 13:55 fd0H1680
 brw-rw----   1 root     floppy     2,  60 Aug  8 13:55 fd0H1722
 brw-rw----   1 root     floppy     2,  76 Aug  8 13:55 fd0H1743
 brw-rw----   1 root     floppy     2,  96 Aug  8 13:55 fd0H1760
 brw-rw----   1 root     floppy     2, 116 Aug  8 13:55 fd0H1840
 brw-rw----   1 root     floppy     2, 100 Aug  8 13:55 fd0H1920
 lrwxrwxrwx   1 root     root            7 Nov  1 15:39 fd0H360 -> fd0D360
 lrwxrwxrwx   1 root     root            7 Nov  1 15:39 fd0H720 -> fd0D720
 brw-rw----   1 root     floppy     2,  52 Aug  8 13:55 fd0H820
 brw-rw----   1 root     floppy     2,  68 Aug  8 13:55 fd0H830
 brw-rw----   1 root     floppy     2,   4 Aug  8 13:54 fd0d360
 brw-rw----   1 root     floppy     2,   8 Aug  8 13:54 fd0h1200
 brw-rw----   1 root     floppy     2,  40 Aug  8 13:54 fd0h1440
 brw-rw----   1 root     floppy     2,  56 Aug  8 13:55 fd0h1476
 brw-rw----   1 root     floppy     2,  72 Aug  8 13:55 fd0h1494
 brw-rw----   1 root     floppy     2,  92 Aug  8 13:55 fd0h1600
 brw-rw----   1 root     floppy     2,  20 Aug  8 13:54 fd0h360
 brw-rw----   1 root     floppy     2,  48 Aug  8 13:55 fd0h410
 brw-rw----   1 root     floppy     2,  64 Aug  8 13:55 fd0h420
 brw-rw----   1 root     floppy     2,  24 Aug  8 13:54 fd0h720
 brw-rw----   1 root     floppy     2,  80 Aug  8 13:55 fd0h880
 brw-rw----   1 root     disk       3,   0 May  5  1998 hda
 brw-rw----   1 root     disk       3,   1 May  5  1998 hda1
 brw-rw----   1 root     disk       3,   2 May  5  1998 hda2
 brw-rw----   1 root     disk       3,   3 May  5  1998 hda3
 brw-rw----   1 root     disk       3,   4 May  5  1998 hda4
 brw-rw----   1 root     disk       3,   5 May  5  1998 hda5
 brw-rw----   1 root     disk       3,   6 May  5  1998 hda6
 brw-rw----   1 root     disk       3,  64 May  5  1998 hdb
 brw-rw----   1 root     disk       3,  65 May  5  1998 hdb1
 brw-rw----   1 root     disk       3,  66 May  5  1998 hdb2
 brw-rw----   1 root     disk       3,  67 May  5  1998 hdb3
 brw-rw----   1 root     disk       3,  68 May  5  1998 hdb4
 brw-rw----   1 root     disk       3,  69 May  5  1998 hdb5
 brw-rw----   1 root     disk       3,  70 May  5  1998 hdb6
 crw-r-----   1 root     kmem       1,   2 May  5  1998 kmem
 crw-r-----   1 root     kmem       1,   1 May  5  1998 mem
 lrwxrwxrwx   1 root     root           12 Nov  1 15:39 modem -> ttyS1
 lrwxrwxrwx   1 root     root           12 Nov  1 15:39 mouse -> psaux
 crw-rw-rw-   1 root     root       1,   3 May  5  1998 null
 crwxrwxrwx   1 root     root      10,   1 Oct  5 20:22 psaux
 brw-r-----   1 root     disk       1,   1 May  5  1998 ram
 brw-rw----   1 root     disk       1,   0 May  5  1998 ram0
 brw-rw----   1 root     disk       1,   1 May  5  1998 ram1
 brw-rw----   1 root     disk       1,   2 May  5  1998 ram2
 brw-rw----   1 root     disk       1,   3 May  5  1998 ram3
 brw-rw----   1 root     disk       1,   4 May  5  1998 ram4
 brw-rw----   1 root     disk       1,   5 May  5  1998 ram5
 brw-rw----   1 root     disk       1,   6 May  5  1998 ram6
 brw-rw----   1 root     disk       1,   7 May  5  1998 ram7
 brw-rw----   1 root     disk       1,   8 May  5  1998 ram8
 brw-rw----   1 root     disk       1,   9 May  5  1998 ram9
 lrwxrwxrwx   1 root     root            4 Nov  1 15:39 ramdisk -> ram0
 ***  Je n'ai inclus de périphériques que pour les partitions IDE que
 ***  j'utilise. Si vous utilisez du SCSI, prenez les périphériques
 ***  /dev/sdXX à la place.
 crw-------   1 root     root       4,   0 May  5  1998 tty0
 crw-w-----   1 root     tty        4,   1 Nov  1 15:39 tty1
 crw-------   1 root     root       4,   2 Nov  1 15:29 tty2
 crw-------   1 root     root       4,   3 Nov  1 15:29 tty3
 crw-------   1 root     root       4,   4 Nov  1 15:29 tty4
 crw-------   1 root     root       4,   5 Nov  1 15:29 tty5
 crw-------   1 root     root       4,   6 Nov  1 15:29 tty6
 crw-------   1 root     root       4,   7 May  5  1998 tty7
 crw-------   1 root     tty        4,   8 May  5  1998 tty8
 crw-------   1 root     tty        4,   9 May  8 12:57 tty9
 crw-rw-rw-   1 root     root       4,  65 Nov  1 12:17 ttyS1
 crw-rw-rw-   1 root     root       1,   5 May  5  1998 zero
 /etc:
 -rw-------   1 root     root          164 Nov  1 15:39 conf.modules
 -rw-------   1 root     root          668 Nov  1 15:39 fstab
 -rw-------   1 root     root           71 Nov  1 15:39 gettydefs
 -rw-------   1 root     root          389 Nov  1 15:39 group
 -rw-------   1 root     root          413 Nov  1 15:39 inittab
 -rw-------   1 root     root           65 Nov  1 15:39 issue
 -rw-r--r--   1 root     root          746 Nov  1 15:39 ld.so.cache
 -rw-------   1 root     root           32 Nov  1 15:39 motd
 -rw-------   1 root     root          949 Nov  1 15:39 nsswitch.conf
 drwx--x--x   2 root     root         1024 Nov  1 15:39 pam.d
 -rw-------   1 root     root          139 Nov  1 15:39 passwd
 -rw-------   1 root     root          516 Nov  1 15:39 profile
 -rwx--x--x   1 root     root          387 Nov  1 15:39 rc
 -rw-------   1 root     root           55 Nov  1 15:39 shells
 -rw-------   1 root     root          774 Nov  1 15:39 termcap
 -rw-------   1 root     root           78 Nov  1 15:39 ttytype
 lrwxrwxrwx   1 root     root           15 Nov  1 15:39 utmp -> ../var/run/utmp
 lrwxrwxrwx   1 root     root           15 Nov  1 15:39 wtmp -> ../var/log/wtmp
 /etc/pam.d:
 -rw-------   1 root     root          356 Nov  1 15:39 other
 /lib:
 -rwxr-xr-x   1 root     root        45415 Nov  1 15:39 ld-2.0.7.so
 lrwxrwxrwx   1 root     root           11 Nov  1 15:39 ld-linux.so.2 -> ld-2.0.7.so
 -rwxr-xr-x   1 root     root       731548 Nov  1 15:39 libc-2.0.7.so
 lrwxrwxrwx   1 root     root           13 Nov  1 15:39 libc.so.6 -> libc-2.0.7.so
 lrwxrwxrwx   1 root     root           17 Nov  1 15:39 libcom_err.so.2 -> libcom_err.so.2.0
 -rwxr-xr-x   1 root     root         6209 Nov  1 15:39 libcom_err.so.2.0
 -rwxr-xr-x   1 root     root       153881 Nov  1 15:39 libcrypt-2.0.7.so
 lrwxrwxrwx   1 root     root           17 Nov  1 15:39 libcrypt.so.1 -> libcrypt-2.0.7.so
 -rwxr-xr-x   1 root     root        12962 Nov  1 15:39 libdl-2.0.7.so
 lrwxrwxrwx   1 root     root           14 Nov  1 15:39 libdl.so.2 -> libdl-2.0.7.so
 lrwxrwxrwx   1 root     root           16 Nov  1 15:39 libext2fs.so.2 -> libext2fs.so.2.4
 -rwxr-xr-x   1 root     root        81382 Nov  1 15:39 libext2fs.so.2.4
 -rwxr-xr-x   1 root     root        25222 Nov  1 15:39 libnsl-2.0.7.so
 lrwxrwxrwx   1 root     root           15 Nov  1 15:39 libnsl.so.1 -> libnsl-2.0.7.so
 -rwx--x--x   1 root     root       178336 Nov  1 15:39 libnss_files-2.0.7.so
 lrwxrwxrwx   1 root     root           21 Nov  1 15:39 libnss_files.so.1 -> libnss_files-2.0.7.so
 lrwxrwxrwx   1 root     root           14 Nov  1 15:39 libpam.so.0 -> libpam.so.0.64
 -rwxr-xr-x   1 root     root        26906 Nov  1 15:39 libpam.so.0.64
 lrwxrwxrwx   1 root     root           19 Nov  1 15:39 libpam_misc.so.0 -> libpam_misc.so.0.64
 -rwxr-xr-x   1 root     root         7086 Nov  1 15:39 libpam_misc.so.0.64
 -r-xr-xr-x   1 root     root        35615 Nov  1 15:39 libproc.so.1.2.6
 lrwxrwxrwx   1 root     root           15 Nov  1 15:39 libpwdb.so.0 -> libpwdb.so.0.54
 -rw-r-r---   1 root     root       121899 Nov  1 15:39 libpwdb.so.0.54
 lrwxrwxrwx   1 root     root           19 Nov  1 15:39 libtermcap.so.2 -> libtermcap.so.2.0.8
 -rwxr-xr-x   1 root     root        12041 Nov  1 15:39 libtermcap.so.2.0.8
 -rwxr-xr-x   1 root     root        12874 Nov  1 15:39 libutil-2.0.7.so
 lrwxrwxrwx   1 root     root           16 Nov  1 15:39 libutil.so.1 -> libutil-2.0.7.so
 lrwxrwxrwx   1 root     root           14 Nov  1 15:39 libuuid.so.1 -> libuuid.so.1.1
 -rwxr-xr-x   1 root     root         8039 Nov  1 15:39 libuuid.so.1.1
 drwx--x--x   3 root     root         1024 Nov  1 15:39 modules
 drwx--x--x   2 root     root         1024 Nov  1 15:39 security
 /lib/modules:
 drwx--x--x   4 root     root         1024 Nov  1 15:39 2.0.35
 /lib/modules/2.0.35:
 drwx--x--x   2 root     root         1024 Nov  1 15:39 block
 drwx--x--x   2 root     root         1024 Nov  1 15:39 cdrom
 /lib/modules/2.0.35/block:
 drwx------   1 root     root         7156 Nov  1 15:39 loop.o
 /lib/modules/2.0.35/cdrom:
 drwx------   1 root     root        24108 Nov  1 15:39 cdu31a.o
 /lib/security:
 -rwx--x--x   1 root     root         8771 Nov  1 15:39 pam_permit.so
 ***  Répertoires bases pour les montages
 /mnt:
 drwx--x--x   2 root     root         1024 Nov  1 15:39 cdrom
 drwx--x--x   2 root     root         1024 Nov  1 15:39 floppy
 /proc:
 /root:
 -rw-------   1 root     root          176 Nov  1 15:39 .bashrc
 -rw-------   1 root     root          182 Nov  1 15:39 .cshrc
 -rwx--x--x   1 root     root          455 Nov  1 15:39 .profile
 -rw-------   1 root     root         4014 Nov  1 15:39 .tcshrc
 /sbin:
 -rwx--x--x   1 root     root        23976 Nov  1 15:39 depmod
 -rwx--x--x   2 root     root       274600 Nov  1 15:39 e2fsck
 -rwx--x--x   1 root     root        41268 Nov  1 15:39 fdisk
 -rwx--x--x   1 root     root         9396 Nov  1 15:39 fsck
 -rwx--x--x   2 root     root       274600 Nov  1 15:39 fsck.ext2
 -rwx--x--x   1 root     root        29556 Nov  1 15:39 getty
 -rwx--x--x   1 root     root         6620 Nov  1 15:39 halt
 -rwx--x--x   1 root     root        23116 Nov  1 15:39 init
 -rwx--x--x   1 root     root        25612 Nov  1 15:39 insmod
 -rwx--x--x   1 root     root        10368 Nov  1 15:39 kerneld
 -rwx--x--x   1 root     root       110400 Nov  1 15:39 ldconfig
 -rwx--x--x   1 root     root         6108 Nov  1 15:39 lsmod
 -rwx--x--x   2 root     root        17400 Nov  1 15:39 mke2fs
 -rwx--x--x   1 root     root         4072 Nov  1 15:39 mkfs
 -rwx--x--x   2 root     root        17400 Nov  1 15:39 mkfs.ext2
 -rwx--x--x   1 root     root         5664 Nov  1 15:39 mkswap
 -rwx--x--x   1 root     root        22032 Nov  1 15:39 modprobe
 lrwxrwxrwx   1 root     root            4 Nov  1 15:39 reboot -> halt
 -rwx--x--x   1 root     root         7492 Nov  1 15:39 rmmod
 -rwx--x--x   1 root     root        12932 Nov  1 15:39 shutdown
 lrwxrwxrwx   1 root     root            6 Nov  1 15:39 swapoff -> swapon
 -rwx--x--x   1 root     root         5124 Nov  1 15:39 swapon
 lrwxrwxrwx   1 root     root            4 Nov  1 15:39 telinit -> init
 -rwx--x--x   1 root     root         6944 Nov  1 15:39 update
 /tmp:
 /usr:
 drwx--x--x   2 root     root         1024 Nov  1 15:39 bin
 drwx--x--x   2 root     root         1024 Nov  1 15:39 lib
 drwx--x--x   3 root     root         1024 Nov  1 15:39 man
 drwx--x--x   2 root     root         1024 Nov  1 15:39 sbin
 drwx--x--x   3 root     root         1024 Nov  1 15:39 share
 lrwxrwxrwx   1 root     root           10 Nov  1 15:39 tmp -> ../var/tmp
 /usr/bin:
 -rwx--x--x   1 root     root        37164 Nov  1 15:39 afio
 -rwx--x--x   1 root     root         5044 Nov  1 15:39 chroot
 -rwx--x--x   1 root     root        10656 Nov  1 15:39 cut
 -rwx--x--x   1 root     root        63652 Nov  1 15:39 diff
 -rwx--x--x   1 root     root        12972 Nov  1 15:39 du
 -rwx--x--x   1 root     root        56552 Nov  1 15:39 find
 -r-x--x--x   1 root     root         6280 Nov  1 15:39 free
 -rwx--x--x   1 root     root         7680 Nov  1 15:39 head
 -rwx--x--x   1 root     root         8504 Nov  1 15:39 id
 -r-sr-xr-x   1 root     bin          4200 Nov  1 15:39 passwd
 -rwx--x--x   1 root     root        14856 Nov  1 15:39 tail
 -rwx--x--x   1 root     root        19008 Nov  1 15:39 tr
 -rwx--x--x   1 root     root         7160 Nov  1 15:39 wc
 -rwx--x--x   1 root     root         4412 Nov  1 15:39 whoami
 /usr/lib:
 lrwxrwxrwx   1 root     root           17 Nov  1 15:39 libncurses.so.4 -> libncurses.so.4.2
 -rw-r-r---   1 root     root       260474 Nov  1 15:39 libncurses.so.4.2
 /usr/sbin:
 -r-x--x--x   1 root     root        13684 Nov  1 15:39 fuser
 -rwx--x--x   1 root     root         3876 Nov  1 15:39 mklost+found
 /usr/share:
 drwx--x--x   4 root     root         1024 Nov  1 15:39 terminfo
 /usr/share/terminfo:
 drwx--x--x   2 root     root         1024 Nov  1 15:39 l
 drwx--x--x   2 root     root         1024 Nov  1 15:39 v
 /usr/share/terminfo/l:
 -rw-------   1 root     root         1552 Nov  1 15:39 linux
 -rw-------   1 root     root         1516 Nov  1 15:39 linux-m
 -rw-------   1 root     root         1583 Nov  1 15:39 linux-nic
 /usr/share/terminfo/v:
 -rw-------   2 root     root         1143 Nov  1 15:39 vt100
 -rw-------   2 root     root         1143 Nov  1 15:39 vt100-am
 /var:
 drwx--x--x   2 root     root         1024 Nov  1 15:39 log
 drwx--x--x   2 root     root         1024 Nov  1 15:39 run
 drwx--x--x   2 root     root         1024 Nov  1 15:39 tmp
 /var/log:
 -rw-------   1 root     root            0 Nov  1 15:39 wtmp
 /var/run:
 -rw-------   1 root     root            0 Nov  1 15:39 utmp
 /var/tmp:
</programlisting>

</appendix>

<appendix id="utilitylist">

<title>Exemple de contenu des répertoires d'un disque utilitaire</title>

<indexterm><primary>disquette utilitaire</primary></indexterm>

<programlisting format="linespecific">
 total 579
 -rwxr-xr-x   1 root     root        42333 Jul 28 19:05 cpio
 -rwxr-xr-x   1 root     root        32844 Aug 28 19:50 debugfs
 -rwxr-xr-x   1 root     root       103560 Jul 29 21:31 elvis
 -rwxr-xr-x   1 root     root        29536 Jul 28 19:04 fdisk
 -rw-r-r---   1 root     root       128254 Jul 28 19:03 ftape.o
 -rwxr-xr-x   1 root     root        17564 Jul 25 03:21 ftmt
 -rwxr-xr-x   1 root     root        64161 Jul 29 20:47 grep
 -rwxr-xr-x   1 root     root        45309 Jul 29 20:48 gzip
 -rwxr-xr-x   1 root     root        23560 Jul 28 19:04 insmod
 -rwxr-xr-x   1 root     root          118 Jul 28 19:04 lsmod
 lrwxrwxrwx   1 root     root            5 Jul 28 19:04 mt -> mt-st
 -rwxr-xr-x   1 root     root         9573 Jul 28 19:03 mt-st
 lrwxrwxrwx   1 root     root            6 Jul 28 19:05 rmmod -> insmod
 -rwxr-xr-x   1 root     root       104085 Jul 28 19:05 tar
 lrwxrwxrwx   1 root     root            5 Jul 29 21:35 vi -> elvis
</programlisting>

</appendix>
</article>
