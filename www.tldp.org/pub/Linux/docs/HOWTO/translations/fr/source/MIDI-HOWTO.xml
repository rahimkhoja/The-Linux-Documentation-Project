<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN"
  "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd" [
<!ENTITY howto	"http://www.traduc.org/docs/howto/lecture/">
<!ENTITY guide	"http://www.traduc.org/docs/guides/lecture/">
]>

<article lang="fr">

<articleinfo>

  <title>

    Guide pratique du MIDI sous Linux

  </title>

  <subtitle>

    Version française de <foreignphrase>The Linux
    MIDI-HOWTO</foreignphrase>

  </subtitle>

  <releaseinfo>Version&nbsp;: 1.2.fr.1.0</releaseinfo> 

  <!-- La date de publication est la date de la v.f. -->

  <pubdate>2004-04-04</pubdate> 

  <revhistory> 

    <revision> 
      <revnumber>1.20.fr.0.9</revnumber> 
      <date>2004-04-04</date>
      <authorinitials>JML, ÉM, JPG</authorinitials> 
      <revremark>Première traduction française.</revremark> 
    </revision> 

    <revision> 
      <revnumber>1.20</revnumber> 
      <date>2002-05-24</date> 
      <authorinitials>PK</authorinitials>
    </revision>

    <revision> 
      <revnumber>1.10</revnumber> 
      <date>2002-04-02</date> 
      <authorinitials>PK</authorinitials>
    </revision>

    <revision> 
      <revnumber>1.00</revnumber> 
      <date>2002-01-25</date> 
      <authorinitials>PK</authorinitials>
    </revision>

  </revhistory> 

  <author>
    <firstname>Phil</firstname> 
    <surname>Kerr</surname> 
    <email>phil CHEZ plus24 POINT com</email>
  </author> 

  <othercredit role="traduction" class="translator">
    <firstname>Jean-Marc</firstname> 
    <surname>Legrand</surname> 
    <contrib>Adaptation française</contrib> 
    <email>cjm POINT legrand CHEZ wanadoo POINT fr</email>
  </othercredit> 

   <othercredit role="relecture">
     <firstname>Éric</firstname>
     <surname>Madesclair</surname>
     <contrib>Relecture de la version française</contrib>
     <email>eric TIRET m CHEZ wanadoo POINT fr</email>
   </othercredit>

  <othercredit role="relecture" class="translator">
    <firstname>Jean-Philippe</firstname>
    <surname>Guérard</surname>
    <contrib>Relecture rapide</contrib> 
    <email>fevrier CHEZ tigreraye POINT org</email>
  </othercredit> 

  <othercredit role="publication" class="copyeditor">
    <firstname>Jean-Philippe</firstname>
    <surname>Guérard</surname>
    <contrib>Préparation de la publication de la v.f.</contrib>
    <email>fevrier CHEZ tigreraye POINT org</email>
  </othercredit>
                                          
  <abstract><para>
      
    Ce document présente, et explique comment utiliser le matériel et 
    les logiciels permettant de jouer et de composer des fichier MIDI 
    sous Linux.
  
  </para></abstract> 

</articleinfo>

<sect1>

  <title>Introduction</title>

  <para>
    
    Ce document traite des points suivants&nbsp;:
  
  </para>

  <itemizedlist>
  
  <listitem><para>
  
    comment configurer votre interface MIDI&nbsp;;
  
  </para></listitem>
  
  <listitem><para>
      
    comment configurer et utiliser des synthétiseurs logiciels&nbsp;;
  
  </para></listitem>

  <listitem><para>

    comment jouer des fichiers MIDI&nbsp;;
  
  </para></listitem>

  <listitem><para>
  
    comment utiliser un séquenceur&nbsp;;
  
  </para></listitem>
  
  <listitem><para>
  
    comment contrôler du matériel MIDI externe&nbsp;;
  
  </para></listitem>

  <listitem><para>
  
    logiciels MIDI basés sur la synthèse de sons&nbsp;;
  
  </para></listitem>
  
  <listitem><para>
      
    exemples de code MIDI.
  
  </para></listitem>

  </itemizedlist>

</sect1>

<sect1>

  <title>Droits d'utilisation (<foreignphrase>Copyright of this 
  document</foreignphrase>)</title>

<!--

  La licence GFDL impose de conserver une copie du texte de ce 
  chapitre dans sa version originale.
  
-->

  <para>
    
    Copyright &copy; 2002 Phil Kerr.
  
  </para>

  <para><foreignphrase>
  
    This HOWTO is copyrighted 2002 Phil Kerr.
  
  </foreignphrase></para>

  <para>
    
    Copyright &copy; 2002 Frank Barknecht pour la <xref
    linkend="synthetiseurs-virtuels"/>.

  </para>
  
  <para><foreignphrase>
  
    The "HOWTO Use MIDI Sequencers With Softsynths" is copyright 2002
    Frank Barknecht.
  
  </foreignphrase></para>

  <para>
    
    Copyright &copy; 2004 Jean-Marc Legrand, Éric Madesclair, 
    Jean-Philippe Guérard pour la version française.
  
  </para>

  <para>
      
    Ce guide pratique est distribué sous la licence de documentation
    libre GNU (GFDL). Vous devriez avoir reçu une copie de cette licence
    avec celui-ci. Si tel n'est pas le cas, vous pouvez vous la procurer
    en version originale anglophone à cette adresse&nbsp;:
  
  </para>

  <para><foreignphrase>

    This document is distributed under the terms of the GNU Free 
    Documentation License. You should have received a copy along with 
    it. If not, it is available from:

  </foreignphrase></para>

  <para>
      
    <ulink url="http://www.fsf.org/licenses/fdl.html"/>

  </para>

  <para>
  
    Il en existe une version française non-officielle à cette
    adresse&nbsp;:
  
  </para>

  <para>
      
    <ulink url="http://cesarx.free.fr/gfdlf.html"/>

  </para>

</sect1>

<sect1>
<title>Où se procurer ce guide&nbsp;?</title>

<para>
      
  La dernière version française officielle de ce guide est disponible 
  sur&nbsp;: <ulink url="&howto;MIDI-HOWTO.html"/>.

</para>

<para>
      
  La dernière version originale de ce guide pratique est publiée
  sur&nbsp;: <ulink url="http://www.midi-howto.com"/>.

</para>

</sect1>

<sect1>
<title>Remerciements</title>

<para>
      
  Ce guide est basé sur le petit guide du MIDI-SB
  (<foreignphrase>MIDI-SB mini-HOWTO</foreignphrase>) écrit par Hideki
  Saito. Tous mes remerciements pour sa contribution à la communauté
  Linux. 

</para>

<para>
      
  Ce guide contient désormais le <quote>Guide d'utilisation des
  Séquenceurs MIDI avec des Synthétiseurs virtuels</quote> écrit par
  Frank. Tous mes remerciements, Frank.

</para>

<para>
      
  Une grande partie des exemples de code contenus dans ce guide provient
  de la liste de discussions LAD (Développeurs Audio Linux). Merci à eux
  pour m'avoir permis de les reprendre dans ce guide.

</para>

</sect1>

<sect1>
<title>
  
  Avertissement (<foreignphrase>Disclaimer</foreignphrase>)

</title>

<!--

  La licence GFDL impose de conserver une copie du texte de ce 
  chapitre dans sa version originale.
  
-->

<para>
      
  L'utilisation des informations de ce document est de votre 
  responsabilité.

</para>

<para><foreignphrase>

  Use the information in this document at your own risk. 
  
</foreignphrase></para>

<para>
      
  Je décline toute responsabilité quant au contenu de ce document.

</para>

<para><foreignphrase>

  I disavow any potential liability for the contents of this document.
  
</foreignphrase></para>

<para>
      
  L'utilisation des principes, exemples, et autres contenus de ce
  document sera entièrement de votre responsabilité.

</para>

<para><foreignphrase>

  Use of the concepts, examples, and/or other content of this document 
  is entirely at your own risk. 

</foreignphrase></para>

<para>
      
  Tous les droits d'auteur et de copyright sont la propriété de leurs
  détenteurs respectifs, sauf indication contraire. 

</para>

<para><foreignphrase>

  All copyrights are owned by their owners, unless specifically noted 
  otherwise.

</foreignphrase></para>

<para>
      
  Aucune remarque contenue dans ce document ne pourra être considérée 
  comme un jugement de valeur contre telle ou telle marque.

</para>

<para><foreignphrase>

  Use of a term in this document should not be regarded as affecting the 
  validity of any trademark or service mark.

</foreignphrase></para>

<para>
      
  Le fait de citer une marque ou un produit particulier ne saurait être 
  considérée comme une recommandation.

</para>

<para><foreignphrase>

  Naming of particular products or brands should not be seen as 
  endorsements.

</foreignphrase></para>

<para>
      
  Il vous est fortement recommandé d'effectuer une sauvegarde de votre
  système avant toute installation d'importance et de le sauvegarder
  régulièrement au cours de votre travail.

</para>

<para><foreignphrase>

  You are strongly recommended to take a backup of your system before 
  major installation and backups at regular intervals.

</foreignphrase></para>

</sect1>

<sect1>
<title>Histoire du MIDI</title>

<para>
      
  Le MIDI est un ensemble de protocoles matériels et logiciels
  permettant à des instruments de musique électroniques de communiquer
  entre eux. Le MIDI est apparu pour la première fois en 1982, et s'est
  imposé comme le standard de communication pour ce type d'instruments.
  Ce protocole fixe les paramètres physiques du matériel (connexions et
  interfaces matérielles), et permet de disposer d'un éventail précis de
  protocoles de communication pour l'échange de données musicales et
  rythmiques.

</para>

<para>
      
  Avant le MIDI, il existait d'autres protocoles de connexion, tout 
  d'abord analogiques, puis numériques. Le plus ancien, au alentours de 
  1974, permettait de transmettre des informations musicales sous forme 
  de tension électrique via les câbles de liaison entre les différents 
  claviers. Plus tard, en 1980-1981, Roland créa un protocole numérique 
  de référence, le DCB. L'association des fabricants d'instruments MIDI 
  (<foreignphrase lang="en">MIDI Manufacturers 
  Association</foreignphrase> &dash; MMA) a défini, à partir de leurs 
  propres équipements, un protocole et un câblage standards pour des 
  matériels compatibles, qui permettait à tous les matériels issus de 
  fabricants adhérent à ce standard de se connecter et de communiquer 
  entre eux.

</para>

<para>
      
  À partir de 1985, les interfaces MIDI commencèrent à apparaître sur
  les PC personnels et peu après apparurent les premiers séquenceurs
  virtuels.

</para>

</sect1>

<sect1>
  
  <title>Configurer ses périphériques MIDI</title>

<para>
      
Les périphériques MIDI sont soit intégrés à la carte son, soit inclus 
dans un matériel séparé. Les interfaces MIDI externes sont reliées soit 
au port série, soit à un port USB.

</para>

<para>
      
La première chose à faire &mdash; et la plus importante &mdash; est de
vérifier la compatibilité de votre carte son&nbsp;!

</para>

<para>
      
Les adresses suivantes peuvent vous y aider&nbsp;:

</para>

<para>
      
<ulink url="http://www.alsa-project.org/alsa-doc/"/>

</para>

<para>
      
<ulink url="http://www.4front-tech.com/osshw.html"/>

</para>

<para>
      
La façon de configurer ses périphériques MIDI varie d'une distribution
Linux à l'autre. Normalement, une carte son compatible sera configurée
correctement à l'installation du système d'exploitation. 

</para>

<para>
      
Le noyau Linux contient les pilotes OSS, et, depuis les versions 2.5, 
les pilotes ALSA. La plupart des distributions offrent un outil de 
configuration (essentiellement dédié aux cartes son). Toutefois, si vous 
utilisez le port MIDI d'une carte son, il devra être configuré 
manuellement. Sous RedHat, il faut utiliser sndconfig, sous SuSE&nbsp;: 
yast, et sous Mandrake&nbsp;: DrakConf.

</para>

<para>
      
Si aucun de ces outils n'est utilisable, ou si vous rencontrez des 
problèmes, suivez les étapes suivantes&nbsp;:

</para>

<para>
      
Est-ce que la commande <command>lsmod</command> montre des modules 
spécifiques au MIDI&nbsp;? Voici ce que l'on peut obtenir sur un système 
basé sur OSS&nbsp;:

</para>

<programlisting>
[root@beatbox]# lsmod
Module                  Size  Used by
lockd                  32208   1  (autoclean)
sunrpc                 54640   1  (autoclean) [lockd]
autofs                  9456   2  (autoclean)
usb-ohci               12624   0  (unused)
usbcore                43632   1  [usb-ohci]
hisax                 470096   0  (autoclean) (unused)
isdn                  104208   0  (autoclean) [hisax]
slhc                    4544   0  (autoclean) [isdn]
eepro100               16144   1  (autoclean)

#---- modules de cartes son
    opl3                   11376   2 
    mad16                   7968   1 
    ad1848                 16848   1  [mad16]
    sb                     34752   1  [mad16]
    uart401                 6384   1  [mad16 sb]
    sound                  58368   0  [opl3 mad16 ad1848 sb uart401]

soundlow                 464   0  [sound]
soundcore               2800   6  [sb sound]
nls_cp437               3952   2  (autoclean)
vfat                    9408   1  (autoclean)
fat                    30432   1  (autoclean) [vfat]
ide-scsi                7664   0 
</programlisting>

<para>
      
Recherchez les modules mpu401, olp3, uart401 et oss. 

</para>

<para>
      
Si vous utilisez une interface USB, n'oubliez pas de vérifier que les
modules USB correspondants apparaissent bien.

</para>

<para>
      
Pour vérifier la configuration, faites un <command>cat</command> du 
fichier <filename class="devicefile">sndstat</filename>&nbsp;:

</para>

<programlisting>
[root@beatbox]# cat /dev/sndstat 
OSS/Free:3.8s2++-971130
Load type: Driver loaded as a module
Kernel: Linux mega 2.2.17-21mdk #1 Thu Oct 5 13:16:08 CEST 2000 i686
Config options: 0

Installed drivers: 

Card config: 

Audio devices:
0: MAD16 WSS (82C930) (DUPLEX)

Synth devices:
0: Yamaha OPL3

Midi devices:
0: Mad16/Mozart

Timers:
0: System clock

Mixers:
0: MAD16 WSS (82C930)
</programlisting>

<para>
      
Nous voyons ici que le périphérique MIDI est mad16, ce qui correspond au
lsmod effectué plus haut.

</para>

<para>
      
Si rien n'apparaît concernant le MIDI, vérifiez le contenu de votre
fichier /etc/modules.conf.

</para>

<programlisting>
[root@beatbox]# cat /etc/modules.conf
alias net-pf-4 ipx 
pre-install pcmcia_core /etc/rc.d/init.d/pcmcia start 
alias usb-interface usb-ohci 
alias parport_lowlevel parport_pc 
alias block-major-11 scsi_hostadapter 
pre-install plip modprobe parport_pc ; echo 7 &gt; /proc/parport/0/irq 
alias scsi_hostadapter ide-scsi 
alias eth0 eepro100 
alias eth1 hisax 

#---- Carte Son
    alias sound-slot-0 mad16 
    options sound dmabuf=1 
    alias midi opl3 
    options opl3 io=0x388 
    options sb support=1 
    options mad16 io=0x530 irq=5 dma=0 dma16=1 mpu_io=0x300 mpu_irq=7 joystick=1
</programlisting>

<para>
      
Voici les données de sortie à vérifier dans le module /proc/modules pour
voir si les modules MIDI sont bien chargés dans le noyau.

</para>

<programlisting>
[root@mega /proc]# cat modules
0000-001f : dma1
0020-003f : pic1
0040-005f : timer
0060-006f : keyboard
0070-007f : rtc
0080-008f : dma page reg
00a0-00bf : pic2
00c0-00df : dma2
00f0-00ff : fpu
0170-0177 : ide1
01f0-01f7 : ide0
02f8-02ff : serial(auto)

#---- Périphérique MIDI
    0300-0303 : MPU-401 UART

0376-0376 : ide1
0388-038b : Yamaha OPL3
03c0-03df : vga+
03f6-03f6 : ide0
03f8-03ff : serial(auto)
0530-0533 : MAD16 WSS config
0534-0537 : MAD16 WSS
de00-de1f : Intel Speedo3 Ethernet
f000-f007 : ide0
f008-f00f : ide1
</programlisting>

<para>
      
Vous devriez trouver quelque chose ressemblant à cela. Si tel n'est pas
le cas, vous devrez installer manuellement les pilotes MIDI.

</para>

<para>
      
Si vous êtes amenés à utiliser les pilotes ALSA 0.5x, &mdash; ce que je
vous déconseille &mdash; je vous suggère de lire auparavant le Petit
guide du son avec ALSA
(<foreignphrase>Alsa-sound-mini-HOWTO</foreignphrase>) de Valentijn
Sessink que vous trouverez au lien suivant&nbsp;:

</para>

<para>
      
<ulink url="&howto;Alsa-sound.html"/>

</para>

<para>
      
Je vous recommande vivement d'utiliser des versions d'ALSA supérieures à
la version 0.9. Pour des pilotes ALSA plus récents que les versions
0.9x, je vous conseille de lire le Guide ALSA (<foreignphrase>Alsa
HOWTO</foreignphrase>) de Madhu Maddy.

</para>

<para>
      
<ulink url="http://www.alsa-project.org/alsa-doc/alsa-howto/"/>

</para>

<sect2>
<title>Installation rapide de ALSA 0.9</title>

<para>
      
Vous trouverez ci-dessous une méthode d'installation rapide des pilotes 
et des bibliothèques ALSA 9.0, ainsi que les configurations les plus 
répandues dans les applications MIDI.

</para>

<programlisting>
[root@beatbox] # tar jxvf alsa-driver....tar.bz2
[root@beatbox] # cd alsa-driver.....
[root@beatbox] # ./configure

messages - no errors

[root@beatbox] # make

messages - no errors

[root@beatbox] # make install

messages - no errors

[root@beatbox] # ./snddevices

</programlisting>

<para>
      
À ce stade, vous devez éditer le fichier /etc/modules.conf, ou, pour
certaines distributions, le fichier ALSA de votre répertoire de modules.
Il se pourrait que vous rencontriez des indications pour d'autres
matériels, non MIDI&nbsp;: soyez prudent lors de l'édition du fichier.

</para>

<para>
      
Si il existe déjà une ancienne configuration ALSA ou OSS dans ce 
fichier, vous devrez l'effacer ou, mieux encore, la commenter.

</para>

<para>
      
Vous trouverez ci-dessous un exemple typique de fichier 
<filename>modules.conf</filename>, décrivant une configuration ALSA sous 
OSS.

</para>

<programlisting>
alias char-major-116 snd
alias char-major-14 soundcore

alias snd-card-0 <replaceable>(carte son/MIDI)</replaceable>
alias sound-slot-0 snd-card-0

alias sound-service-0-0 snd-mixer-oss
alias sound-service-0-1 snd-seq-oss
alias sound-service-0-3 snd-pcm-oss
alias sound-service-0-12 snd-pcm-oss
</programlisting>

<para>
      
Remplacez l'entrée <replaceable>(carte son/MIDI)</replaceable> par la 
référence correcte à votre carte son. Vous trouverez normalement les 
informations nécessaires sur le site web ALSA.

</para>

<para>
      
Une fois les pilotes ALSA installés, vous devrez installer les fichiers
de bibliothèques d'en-têtes nécessaires au fonctionnement des programmes
basés sur ALSA. C'est ce que contient le paquet alsa-libs.

</para>

<para>
      
Assurez-vous tout d'abord que votre paquet alsa-libs correspond bien à
vos pilotes ALSA&nbsp;!

</para>

<programlisting>
[root@beatbox] # tar jxvf alsa-libs....tar.bz2
[root@beatbox] # cd alsa-libs.....
[root@beatbox] # ./configure

messages - no errors

[root@beatbox] # make

messages - no errors

[root@beatbox] # make install

</programlisting>

<para>
      
Votre système devrait alors être configuré&nbsp;!&nbsp;:o)

</para>

<para>
      
Vous pouvez le vérifier à l'aide d'un simple programme en C&nbsp;: si
vous réussissez à le compiler et l'exécuter, c'est que votre système
fonctionne bien.

</para>

<programlisting>
// Compilez ce programme test ainsi : gcc alsatest.c -o alsatest -lasound

#include &lt;stdio.h&gt;
#include &lt;alsa/asoundlib.h&gt;

int main (int argc, char *argv[])
{
  snd_seq_t *seq_handle;

  if (snd_seq_open(&amp;seq_handle, "hw", SND_SEQ_OPEN_DUPLEX, 0) &lt; 0) {
    fprintf(stderr, "Error opening ALSA sequencer.\n");
    exit(1);
  }

printf("The ALSA libraries are installed.\n");
return 0;
}
</programlisting>

</sect2>

<sect2>
<title>Les problèmes de latence</title>

<para>
      
Le MIDI est un protocole temps-réel et les réglages de latence peuvent
poser de sérieux problèmes. 

</para>

<para>
      
Désormais, plusieurs développeurs travaillent sur l'amélioration des
temps de latence, et les progrès réalisés sur le noyau font aujourd'hui
de Linux une plateforme tout à fait efficace pour le MIDI.

</para>

<para>
      
Même si les distributions Linux fonctionnent correctement sur ce point, 
les utilisateurs avancés devront installer des correctifs noyau pour 
diminuer les temps de latence. Vous trouverez plus d'informations sur 
les sites suivants&nbsp;:

</para>

<para>
      
<ulink url="http://www.gardena.net/benno/linux/audio/"/>

</para>

<para>
      
<ulink url="http://www.linuxdj.com/audio/lad/resourceslatency.php3"/>

</para>

<para>
      
Vous trouverez en outre le Petit guide de réduction des temps de latence 
(<foreignphrase lang="en">Low Latency Mini Howto</foreignphrase> &mdash; 
en anglais) à l'adresse suivante&nbsp;:

</para>

<para>
      
<ulink
url="http://web.archive.org/web/20021211025416/http://www.boosthardware.com/LAU/guide/Low_latency-Mini-HOWTO.html"/>

</para>

</sect2>

</sect1>

<sect1>
<title>Les logiciels</title>

<para>
      
L'intérêt pour des solutions MIDI basées sur Linux étant croissant, la 
liste suivante ne sera probablement pas exhaustive, mais vous donnera un 
choix représentatif d'applications MIDI.

</para>

<para>
      
Si vous êtes développeur ou utilisateur d'autres applications MIDI non
listées, merci de m'en avertir par courrier électronique.

</para>

<sect2>
<title>Les pilotes</title>

<sect3>
<title>Les pilotes ALSA</title>

<para>
      
ALSA (l'Architecture Sonore Linux Avancée &mdash; <foreignphrase 
lang="en">Advanced Linux Sound Architecture </foreignphrase>) est 
constituée de plusieurs éléments. Le premier est un pilote son 
totalement modulaire, compatible avec le chargement automatique des 
modules, l'utilisation de devfs, l'autoconfiguration isapnp, et 
permettant un accès complet aux composants audio analogique, audio 
numérique, contrôles, mixage, synthétiseur, DSP, MIDI et à la 
temporisation du matériel MIDI. Il comprend aussi un séquenceur noyau 
complet, une couche de compatibilité complète avec les applications 
libres basées sur OSS, une bibliothèque C orientée objet permettant de 
traiter et améliorer les fonctionnalités des pilotes ALSA pour certaines 
applications (client/serveur, modules d'extension, le partage et le 
mixage du son PCM, mesure du son PCM, et cætera), une interface de 
configuration du pilote, ainsi que quelques autres outils simples pour 
la configuration et la maintenance.

</para>

<para>
      
<ulink url="http://www.alsa-project.org/"/>

</para>

</sect3>

<sect3>
<title>OSS</title>

<para>
      
OSS, le Système audio ouvert, fournit des pilotes de cartes son pour
Linux et FreeBSD. Ces pilotes sont compatibles avec le son numérique, le
MIDI, les synthétiseurs virtuels et les modules de mixage intégrés aux
cartes son. Ces pilotes sonores sont conformes aux spécifications de la
bibliothèque de programmation Système audio ouvert (OSS &mdash;
<foreignphrase>Open Sound System</foreignphrase>). Le système OSS est
muni d'une interface graphique très conviviale, qui rend très simple
l'installation des pilotes ainsi que la configuration de la carte son.
Ces pilotes sont compatibles avec plus de 200 cartes son de marque et
permettent une détection automatique de la carte son,
l'autoconfiguration (<foreignphrase>Plug-n-Play</foreignphrase>),
l'utilisation des cartes son PCI et la capacité de fonctionnement audio
bidirectionnel.

</para>

<para>
      
<ulink url="http://www.opensound.com/"/>

</para>

</sect3>

<sect3>
<title>Notemidi</title>

<para>
      
Notemidi est un pilote de périphérique pour la sortie MIDI via le port
série RS-232 sur les PC portables. Notemidi peut être utilisé avec
l'interface MIDIator MS-124W, les modules de son Roland Sound Canvas, ou
les modules de son de la série Yamaha MU-x. 

</para>

<para>
      
<ulink url="http://www.michaelminn.com/linux/notemidi"/>

</para>

</sect3>

</sect2>

<sect2>
<title>Les lecteurs MIDI</title>

<sect3>
<title>KMid</title>

<para>
 
KMid est un lecteur MIDI basé sur KDE (et donc X11) pour Linux et 
FreeBSD. Il permet le défilement des textes de fichiers karaoke, et 
change la couleur du texte au fur et à mesure qu'il est joué, ce qui 
permet de le suivre facilement. KMid utilise <filename 
class="devicefile">/dev/sequencer</filename> comme périphérique de 
sortie compatible avec les synthétiseurs externes, ainsi qu'avec les 
cartes AWE, FM et GUS.

</para>

<para>
      
<ulink url="http://perso.wanadoo.es/antlarr/kmid.html"/>

</para>

</sect3>

<sect3>
<title>Pmidi</title>

<para>
      
Pmidi est un programme en lignes de commande qui permet de jouer des
fichiers MIDI sur le séquenceur ALSA. 

</para>

<para>
      
<ulink url="http://www.parabola.demon.co.uk/alsa/pmidi.html"/>

</para>

</sect3>

<sect3>
<title>TiMidity++</title>

<para>
      
TiMidity est un convertisseur MIDI vers WAVE qui utilise des 
bibliothèques de timbres dans un format compatible Gravis Ultrasound(*) 
afin de produire des données audionumériques à partir de fichiers 
General MIDI. Les données audio peuvent alors être jouées par n'importe 
quel périphérique son ou stockées sur disque. Sur une machine puissante, 
les données peuvent être jouées en temps réel.

</para>

<para>
      
<ulink url="http://timidity.sourceforge.net/"/>

</para>

</sect3>

</sect2>

<sect2>
<title>Les séquenceurs</title>

<sect3>
<title>Brahms</title>

<para>
      
Brahms est à la fois un séquenceur et un éditeur de partitions, muni de
plusieurs outils d'édition comme Score-, Pianoroll-, Drum-, et
Mastertrack Editor. Pour les développeurs C++, il est aisé de créer
d'autres outils d'édition à partir d'un module d'édition générique. Ce
programme possède aussi une fonction d'import et export MIDI. Combiné
avec aRts-0.3.4, il est possible de jouer des fichiers WAVE et d'envoyer
simultanément au synthétiseur virtuel des évènements MIDI. 

</para>

<para>
      
Ce logiciel était autrefois connu sous l'appellation Koobase.

</para>

<para>
      
<ulink url="http://brahms.sourceforge.net/"/> 

</para>

</sect3>

<sect3>
<title>Anthem</title>

<para>
      
Anthem est un séquenceur MIDI libre évolué. Anthem vous permet 
d'enregistrer, d'éditer et de jouer de la musique, en utilisant une 
technologie musicale orientée objet très sophistiquée et très appréciée.

</para>

<para>
      
<ulink url="http://anthem.sourceforge.net/"/>

</para>

</sect3>

<sect3>
<title>Jazz++</title>

<para>
      
JAZZ++ est un séquenceur audio et MIDI complet, sous Linux et Windows.

</para>

<para>
      
<ulink url="http://www.jazzware.com/cgi-bin/Zope.cgi/jazzware/"/>

</para>

</sect3>

<sect3>
<title>UltiMusE-LX </title>

<para>
      
UltiMusE-LX (<foreignphrase>the Ultimate Music Editor</foreignphrase>) 
est un logiciel de composition musicale. Non, non&nbsp;: il ne compose 
pas à votre place&nbsp;! C'est un logiciel musical graphique. Vous 
composez votre partition à l'écran à l'aide de la souris et/ou du 
clavier, jusqu'à 16 parties ou voix, avec jusqu'à 7 portées. Il permet 
d'utiliser quasiment toutes les notations standards, ainsi que les 
outils MIDI de changement d'instrument, d'événement, et de gestion en 
temps réel.

</para>

<para>
      
<ulink url="http://hometown.aol.com/knudsenmj/myhomepage/umuselx.htm"/>

</para>

</sect3>

<sect3>
<title>Melys</title>

<para>
      
Melys est une application séquenceur MIDI basé sur ALSA. Melys utilise 
le séquenceur ALSA et le combine avec les bibliothèques GNOME pour 
produire un séquenceur puissant et facile à utiliser.

</para>

<para>
      
<ulink url="http://www.parabola.demon.co.uk/melys/"/>

</para>

</sect3>

<sect3>
<title>MidiMountain Sequencer</title>

<para>
      
MidiMountain est un séquenceur qui permet d'éditer des fichiers MIDI 
standard. La facilité d'utilisation de son interface devrait aider les 
débutants à éditer et créer des séquences MIDI. MidiMountain est conçu 
pour permettre de manipuler toutes les définitions connues des fichiers 
MIDI standards et du protocole de transfert MIDI, du simple rouleau de 
piano mécanique à la manipulation des messages exclusifs systèmes 
binaires.

</para>

<para>
      
<ulink url="http://www.midimountain.com/"/>

</para>

</sect3>

<sect3>
<title>MusE</title>

<para>
      
MusE est un séquenceur MIDI pour Linux, basé sur Qt&nbsp;2.1, avec 
fonctions d'édition et d'enregistrement. Pendant que le séquenceur joue, 
vous pouvez éditer des évènements MIDI en temps réel à l'aide du rouleau 
de piano mécanique ou de l'éditeur de partition. Les évènements MIDI 
enregistrés peuvent alors être traités à part avec le menu arrangeur.

</para>

<para>
      
<ulink url="http://muse.seh.de/"/>

</para>

</sect3>

<sect3>
<title>Rosegarden</title>

<para>
      
Rosegarden est un séquenceur MIDI intégré et un éditeur de partition.

</para>

<para>

<ulink url="http://www.rosegardenmusic.com/"/>

</para>

</sect3>

</sect2>

<sect2>
<title>Consoles de mixage MIDI</title>

<sect3>
<title>tektracker</title>

<para>
      
ttrk (tektracker) est un séquenceur MIDI muni d'une interface de type 
console de mixage. Il est fait pour être utilisé en temps réel, 
notamment grâce à ses boutons de volume par piste et création de 
boucles. ttrk permet d'envoyer et de se synchroniser avec les pulsations 
d'horloge MIDI.

</para>

<para>
      
<ulink url="http://vektor.ca/audio/ttrk/"/>

</para>

</sect3>

<sect3>
<title>ShakeTracker</title>

<para>
      
ShakeTracker est un séquenceur MIDI muni d'une interface de type console
de mixage. Il fonctionne correctement et permet d'utiliser quasiment
tous les effets de mixage habituels. Ceux d'entre vous qui auront
utilisé Impulse Tracker auparavant se sentiront chez eux, et pour les
nouveaux utilisateurs, ils bénéficieront d'un système d'aide en ligne
très complet et très simple d'utilisation. La plupart des commandes et
raccourcis ressemblent à leur équivalent sur une table de mixage.

</para>

<para>
      
<ulink url="http://reduz.com.ar/shaketracker/"/>

</para>

</sect3>

</sect2>

<sect2>
<title>Éditeurs de rythmes</title>

<sect3>
<title>DrumPatterns</title>

<para>
      
DrumPatterns est un générateur de rythmes, libre et orienté internet, 
dont l'objectif est d'apprendre à créer des motifs rythmiques. Il est 
capable de vous apprendre les bases rythmiques, aussi bien que les 
rythmes les plus compliqués. Il peut éditer des graphismes, des 
partitions, des évènements MIDI, et inclut des heures d'échantillons 
d'exemples.

</para>

<para>
      
<ulink
url="http://www.linux-france.org/prj/drumpatterns/index-fr.html"/>

</para>

</sect3>

</sect2>

<sect2>
<title>Éditeurs de timbres</title>

<sect3>
<title>JSynthLib</title>

<para>

JSynthLib est un éditeur et conservateur libre de timbres, écrit en 
langage Java. Ce projet a pour but d'offrir une compatibilité avec tous 
les synthétiseurs existants, en fournissant aux utilisateurs des 
méthodes et des documentations qui leur permette de développer des 
pilotes et des éditeurs pour les synthétiseurs non compatibles, et de 
les diffuser via le projet.
</para>

</sect3>

</sect2>

<sect2>
<title>Synthétiseurs virtuels</title>

<sect3>
<title>Spiral Synth</title>

<para>
      
Spiral Synth est un synthétiseur polyphonique analogique virtuel. Il est 
capable de réutiliser des sons fabriqués par des synthétiseurs 
analogiques matériels, comme les bruits utilisés dans la musique 
électronique. Vous pouvez aussi l'utiliser pour créer les sons les plus 
bizarres. Il est compatible MIDI et il utilise la sortie sonore standard 
du système OSS libre (<filename class="devicefile">/dev/dsp</filename>).

</para>

<para>
      
<ulink url="http://www.pawfal.org/SpiralSynth/"/>

</para>

</sect3>

<sect3>
<title>UltraMaster Juno-6</title>

<para>
      
UltraMaster Juno-6 est une reproduction virtuelle fidèle du synthétiseur 
polyphonique Roland Juno-6. Il intègre la synthèse d'ondes ULTRANAMOG en 
temps-réel et en 64 bit, permet de produire des accords et des chœurs 
dans le style des années 80. Tous les paramètres peuvent être contrôlés 
en temps réel, soit via une interface graphique, soit via des actions 
sur des contrôleurs MIDI externes.

</para>

<para>
      
<ulink url="http://www.ultramaster.com/juno6/index.html"/>

</para>

</sect3>

<sect3>
<title>Pure-Data</title>

<para>
      
Pure-Data est un logiciel temps réel pour l'exécution en direct de 
pièces musicales et multimédia. Il est développé par Miller Puckette , 
sans doute en collaboration avec d'autres développeurs. Ce logiciel 
n'est pas encore abouti, mais peut tout à fait être utilisé dans le 
cadre de projets complexes. Il a été adapté sur Linux, IRIX, et Windows.

</para>

<para>
      
<ulink url="http://www.pure-data.org/"/>

</para>

</sect3>

<sect3>
<title>Csound</title>

<para>
      
Csound est un synthétiseur virtuel qui ne souffre pas des limitations
des autres synthétiseurs matériels ou logiciels de ce type. Le nombre
d'oscillateurs ou de filtres utilisables est illimité. Csound est aussi
complètement modulable, de façon à ce que chaque fonction soit
utilisable de plusieurs façons différentes.

</para>

<para>

<ulink url="http://www.csound.org/"/>.

</para>

</sect3>

<sect3>
<title>Émulateur de Synthétiseur Bristol</title>

<para>
      
Bristol est une collection d'émulateurs de synthétiseur. Il comprend 
Moog Mini, Moog Voyager, Hammond B3, Prophet 5, Juno 6, DX 7, ainsi que 
d'autres logiciels.

</para>

<para>
      
<ulink url="http://www.slabexchange.org/index.cgi?DOWNLOAD"/>

</para>

</sect3>

</sect2>

<sect2>
<title>

  Les modules d'extension (<foreignphrase>plugins</foreignphrase>)

</title>

<sect3>
<title>xmms-midi</title>

<para>
      
Il ajoute à x11amp la compatibilité avec les fichiers MIDI (via
timidity). Une interface de mixage simplifiée est disponible par le menu
de configuration. 

</para>

<para>
      
<ulink url="http://ban.joh.cam.ac.uk/~cr212/xmms-midi/"/>

</para>

</sect3>

</sect2>

<sect2>
<title>Partitions musicales</title>

<sect3>
<title>Mup</title>

<para>
      
Mup prend des données d'entrée de type texte pour les transformer en
données Postcript imprimables. Les notations standards classiques et la
notation en tablature sont toutes deux utilisables. MUP peut aussi
produire des données de sortie de type MIDI. 

</para>

<para>
      
<ulink url="http://www.arkkra.com/"/>

</para>

</sect3>

<sect3>
<title>Lilypond</title>

<para>
      
LilyPond est un logiciel de composition musicale. Il permet de réaliser 
de très belles partitions, à partir de données d'entrée très détaillées. 
LilyPond fait partie du projet GNU.

</para>

<para>
      
<ulink url="http://www.lilypond.org/"/>

</para>

</sect3>

</sect2>

<sect2>
<title>Développement</title>

<sect3>
<title>sfront</title>

<para>
      
Sfront convertit des flux de données audio MP4-SA (MPEG 4 Structured 
Audio) en programmes C très efficaces qui produisent de l'audio à 
l'exécution. MP4-SA est un format standard pour des algorithmes de son, 
combinant un langage de création de signaux audio (SAOL) avec un langage 
de notation musicale (SASL, et le traditionnel format de fichier MIDI). 
Sous Linux, sfront exploite le temps réel, les entrées-sorties audio à 
faible temps de latence, les entrées MIDI à partir de cartes son, ainsi 
que les entrées MIDI via internet utilisant le RTP et le SIP. Un serveur 
SIP hébergé sur le campus de Berkeley organise des sessions de travail. 
Le site comprend aussi une aide en ligne à propos du MP4-SA.

</para>

<para>
      
<ulink url="http://www.cs.berkeley.edu/~lazzaro/sa/index.html"/>

</para>

</sect3>

<sect3>
<title>jMax</title>

<para>
      
jMax est un système qui permet de dessiner des circuits de flux de 
données. On peut y entrer des données de type entier, symbole, liste, et 
cætera. C'est un système piloté par les événements. JMax est utilisé 
pour la création MIDI. Une autre partie de ce système, DSP, permet de 
faire circuler un signal en continu dans le circuit, ce qui est le plus 
pratique pour les sons PCM (i.&nbsp;e.&nbsp;: micros, fichiers son, et 
cætera). Ce système est extensible avec des bibliothèques partagées, 
permettant l'utilisation de différents types de gestion des données, de 
périphériques, d'interfaces, de matériels, et cætera. Les modules de 
traitement de données peuvent être traités comme des circuits et 
utilisés en tant que tel.

</para>

<para>
      
<ulink url="http://sourceforge.net/projects/jmax/"/>

</para>

</sect3>

<sect3>
<title>TSE3</title>

<para>
      
TSE3 est un puissant séquenceur en mode texte, dont les sources sont
publiques, écrit en C++. C'est un séquenceur en mode texte parce qu'il
présente toutes les fonctionnalités d'un séquenceur mais sans interface
graphique. Différentes applications séquenceur ou multimédia utilisent
TSE3 derrière leur interface graphique.

</para>

<para>
      
<ulink url="http://TSE3.sourceforge.net/"/>

</para>

</sect3>

<sect3>
<title>KeyKit</title>

<para>
      
KeyKit est un langage de programmation multi-tâches (inspiré de awk),
exclusivement réservé aux opération MIDI algorithmiques et temps réel.
Son interface graphique propose plusieurs douzaines d'outils pour
expérimenter différents algorithmes musicaux, y compris un séquenceur
multipistes et un éditeur de motifs rythmiques. L'interface et les
outils sont complètement écrits dans le langage de KeyKit. Cela permet
d'ajouter de nouveaux outils et nouvelles fonctionnalités à l'existant,
tout en utilisant le système.

</para>

<para>
      
<ulink url="http://nosuch.com/keykit/"/>

</para>

</sect3>

</sect2>

</sect1>

<sect1>
<title>Le développement MIDI</title>

<para>
      
Ceux qui souhaitent développer des applications MIDI ont souvent besoin
de bons exemples pour démarrer.

</para>

<para>
      
Les exemples suivants proviennent de la liste de discussions LAD.

</para>

<sect2>
<title>Exemple 1</title>

<para>
      
Vous trouverez ci-dessous une fonction de séquencement écrite par Dr. 
Matthias Nagorni. D'autres exemples sont disponibles sur son site (cf la 
section Liens).

</para>

<para>
      
Vous le compilez de la façon suivante&nbsp;:

</para>

<programlisting>
[phil@beatbox] $ gcc seqdemo.c -o seqdemo -lasound


#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;alsa/asoundlib.h&gt;

snd_seq_t *open_seq();
void midi_action(snd_seq_t *seq_handle);

snd_seq_t *open_seq() {

  snd_seq_t *seq_handle;
  int portid;

  if (snd_seq_open(&amp;seq_handle, "hw", SND_SEQ_OPEN_DUPLEX, 0) &lt; 0) {
    fprintf(stderr, "Error opening ALSA sequencer.\n");
    exit(1);
  }
  snd_seq_set_client_name(seq_handle, "ALSA Sequencer Demo");
  if ((portid = snd_seq_create_simple_port(seq_handle, "ALSA Sequencer Demo",
            SND_SEQ_PORT_CAP_WRITE|SND_SEQ_PORT_CAP_SUBS_WRITE,
            SND_SEQ_PORT_TYPE_APPLICATION)) &lt; 0) {
    fprintf(stderr, "Error creating sequencer port.\n");
    exit(1);
  }
  return(seq_handle);
}

void midi_action(snd_seq_t *seq_handle) {

  snd_seq_event_t *ev;

  do {
    snd_seq_event_input(seq_handle, &amp;ev);
    switch (ev-&gt;type) {
      case SND_SEQ_EVENT_CONTROLLER: 
        fprintf(stderr, "Control event on Channel %2d: %5d       \r",
                ev-&gt;data.control.channel, ev-&gt;data.control.value);
        break;
      case SND_SEQ_EVENT_PITCHBEND:
        fprintf(stderr, "Pitchbender event on Channel %2d: %5d   \r", 
                ev-&gt;data.control.channel, ev-&gt;data.control.value);
        break;
      case SND_SEQ_EVENT_NOTEON:
        fprintf(stderr, "Note On event on Channel %2d: %5d       \r",
                ev-&gt;data.control.channel, ev-&gt;data.note.note);
        break;        
      case SND_SEQ_EVENT_NOTEOFF: 
        fprintf(stderr, "Note Off event on Channel %2d: %5d      \r",         
                ev-&gt;data.control.channel, ev-&gt;data.note.note);           
        break;        
    }
    snd_seq_free_event(ev);
  } while (snd_seq_event_input_pending(seq_handle, 0) &gt; 0);
}

int main(int argc, char *argv[]) {

  snd_seq_t *seq_handle;
  int npfd;
  struct pollfd *pfd;
    
  seq_handle = open_seq();
  npfd = snd_seq_poll_descriptors_count(seq_handle, POLLIN);
  pfd = (struct pollfd *)alloca(npfd * sizeof(struct pollfd));
  snd_seq_poll_descriptors(seq_handle, pfd, npfd, POLLIN);
  while (1) {
    if (poll(pfd, npfd, 100000) &gt; 0) {
      midi_action(seq_handle);
    }  
  }
}

</programlisting>

</sect2>

<sect2>
<title>Exemple 2</title>

<para>
      
Vous trouverez ci-dessous un <quote>aiguilleur</quote> MIDI basé sur ALSA
0.9 écrit par Nick Dowell.

</para>

<programlisting>
/* Aiguilleur pour séquenceur ALSA.
   Aiguille les données d'entrée vers les sorties définies
   par le canal MIDI (à la demande de Nathaniel Virgo sur 
   Linux-Audio-Dev ;o)). Est basé sur l'exemple de fonction
   séquenceur ALSA écrit par Dr. Matthias Nagorni.
   
   Nick Dowell &lt;nixx CHEZ nixx POINT org POINT uk&gt;    */

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;alsa/asoundlib.h&gt;

int
main()
{
  snd_seq_t *seq_handle;
  snd_seq_event_t *ev;
  int i;
  int portid;              /* port d'entrée (input) */
  int oportid[16];         /* ports de sortie (outputs) */
  int npfd;
  struct pollfd *pfd;
  char txt[20];

  if (snd_seq_open(&amp;seq_handle, "hw", SND_SEQ_OPEN_DUPLEX, 0) &lt; 0) {
    fprintf(stderr, "Error opening ALSA sequencer.\n");
    exit(1);
  }

  snd_seq_set_client_name(seq_handle, "MIDI Redirect");
  
  /* open one input port */
  if ((portid = snd_seq_create_simple_port
       (seq_handle, "Input",
        SND_SEQ_PORT_CAP_WRITE | SND_SEQ_PORT_CAP_SUBS_WRITE,
        SND_SEQ_PORT_TYPE_APPLICATION)) &lt; 0) {
    fprintf(stderr, "fatal error: could not open input port.\n");
    exit(1);
  }
  /* open 16 output ports for the MIDI channels */
  for (i=0; i&lt;16; i++){
    sprintf( txt, "MIDI Channel %d", i );
    if ((oportid[i] = snd_seq_create_simple_port
         (seq_handle, txt,
          SND_SEQ_PORT_CAP_READ | SND_SEQ_PORT_CAP_SUBS_READ,
          SND_SEQ_PORT_TYPE_APPLICATION)) &lt; 0) {
      fprintf(stderr, "fatal error: could not open output port.\n");
      exit(1);
    }
  }

  npfd = snd_seq_poll_descriptors_count(seq_handle, POLLIN);
  pfd = (struct pollfd *)alloca(npfd * sizeof(struct pollfd));
  snd_seq_poll_descriptors(seq_handle, pfd, npfd, POLLIN);

  while (1)  /* main loop */
    if (poll(pfd, npfd, 1000000) &gt; 0){
      do {
        snd_seq_event_input(seq_handle, &amp;ev);
        snd_seq_ev_set_source( ev, oportid[ev-&gt;data.control.channel] );
        snd_seq_ev_set_subs( ev );
        snd_seq_ev_set_direct( ev );
        snd_seq_event_output_direct( seq_handle, ev );
        snd_seq_free_event(ev);
      } while (snd_seq_event_input_pending(seq_handle, 0) &gt; 0);
    }
  return 0;
}

</programlisting>

</sect2>

<sect2>
<title>Exemple 3</title>

<para>
      
Vous trouverez ci-dessous un exemple d'écriture de données dans 
l'interface OSS <filename class="devicefile">/dev/midi</filename> par 
Craig Stuart Sapp.

</para>

<para>
      
Vous pourrez trouver plus d'exemples sur son site (cf la section Liens).

</para>

<programlisting>
//
// Programmeur:            Craig Stuart Sapp
// Adresse électronique :  craig CHEZ ccrma POINT standford POINT edu
// Date de Création :	   Lundi 21 décembre 1998 18:00:42
// Dernière modification : Lundi 21 décembre 1998 18:00:42
// Nom de fichier :      ...linuxmidi/output/method1.c
// Langage :             C 
// $Smake: gcc -O -o devmidiout devmidiout.c &amp;&amp; strip devmidiout
//

#include &lt;linux/soundcard.h&gt;
#include &lt;unistd.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;

int main(void) {
   char* device =  "/dev/midi" ;
   unsigned char data[3] = {0x90, 60, 127};

   // étape 1: ouvre le module OSS pour écriture
   int fd = open(device, O_WRONLY, 0);
   if (fd &lt; 0) {
      printf("Error: cannot open %s\n", device);
      exit(1);
   }

   // étape 2: écrit les données MIDI dans le module OSS
   write(fd, data, sizeof(data));

   // étape 3: (en option) ferme le module OSS
   close(fd);

   return 0;
}
</programlisting>

</sect2>

</sect1>

<sect1 id="synthetiseurs-virtuels">

  <sect1info>
  <author>
    <firstname>Frank</firstname> 
    <surname>Barknecht</surname> 
    <email>barknech CHEZ ph TIRET cip POINT uni TIRET koeln POINT de</email>
  </author>
  </sect1info>

  <title>

    Guide d'utilisation de séquenceurs MIDI avec des synthétiseurs 
    virtuels

  </title>

  <subtitle>
  
    Version française du guide pratique <foreignphrase>HOWTO Use MIDI
    Sequencers With Softsynths</foreignphrase>
    
  </subtitle>

  <para>
  
    <ulink
    url="http://linux-sound.org/quick-toots/4-sequencers_and_softsynths/quick-toot-midisynth_howto.html"/>
  
  </para>

  <para>
  
    Ce guide décrit les réglages nécessaires pour contrôler un
    synthétiseur MIDI virtuel à partir d'un séquenceur MIDI et via une
    connexion MIDI virtuelle sous ALSA 0.9. Ce document peut être
    librement traduit et diffusé. Il est soumis à la licence de
    documentation libre GNU. 
  
  </para>

<sect2>

  <title>Introduction</title>

  <para>
      
  
    Les synthétiseurs virtuels, tels que Csound, Pure Data, jMax ou Spiral
    Synth Modular offrent des possibilités quasi infinies pour
    expérimenter les sons les plus usuels ou les plus inhabituels. Ils
    peuvent en outre remplacer les synthétiseurs matériels, relativement
    chers, ou ceux, souvent de mauvaise qualité, qui équipent les cartes
    son, si tant est qu'ils soient compatibles avec Linux. En
    contrepartie, composer sur ces synthétiseurs virtuels peut s'avérer
    fastidieux, comme sur Csound où l'on doit aligner des pages entières
    de chiffres pour composer, ce qui n'est pas l'idéal pour faire de la
    musique.
  
  </para>

<para>
      
Les logiciels séquenceurs MIDI virtuels permettent de rendre la tâche 
plus agréable. Ils sont munis d'une interface permettant d'insérer des 
notes et des évènements MIDI de façon pratique&nbsp;: soit par 
l'intermédiaire d'une vraie partition, soit par un rouleau de piano 
mécanique ou via une liste d'évènements MIDI, suivant vos préférences. 
D'autres types de séquenceurs virtuels permettent d'entrer les notes en 
utilisant des morceaux de pistes, comme on le faisait dans le temps en 
direct. Dernier point, non des moindres, certains séquenceurs MIDI vous 
permettent d'enregistrer vos propres musiques par l'intermédiaire d'un 
matériel externe (clavier ou autre), ce qui se révèle, pour certains 
musiciens, le moyen le plus naturel de faire de la musique.

</para>

<para>
      
D'habitude, les séquenceurs MIDI envoient leurs données vers des
périphériques MIDI qui à leur tour vont réorienter les données vers
l'extérieur, à savoir vers des synthétiseurs et des échantillonneurs
matériels. Grâce aux outils MIDI virtuels, on peut garder au sein du PC
toutes les données MIDI et les faire contrôler par un logiciel tournant
sur la même machine. Ce guide décrit tout ce qui est nécessaire pour en
arriver là. 

</para>

</sect2>

<sect2>
<title>paramétrage du matériel</title>

<para>
      
Pour le paramétrage, nous utiliserons les bibliothèques et les pilotes 
d'ALSA, ce qui doit être le cas si l'on veut utiliser sérieusement 
le son et le MIDI sous Linux. À partir de maintenant, nous supposerons 
que vous utilisez la version 0.9.0 d'ALSA. Toutefois, le module MIDI 
utilisé est aussi présent dans la version 0.5.x, ce qui rend les 
explications à venir tout aussi valables. Sous les architectures son 
OSS/Free (avec les modules de son trouvés dans les noyaux antérieurs à 
la version 2.5.x) et OSS/Linux, le module v_midi peut être utilisé, mais 
cela dépasse le cadre de ce guide.

</para>

<para>
      
Pour utiliser la carte MIDI virtuelle d'ALSA, le module snd-card-virmidi 
doit être présent. Avec la plupart des versions récentes d'ALSA (ainsi 
que dans la version 2.5.x de développement de noyau), le nom de ce 
module a été renommé <quote>snd-virmidi</quote>. Assurez-vous que vous 
avez bien pris en compte ce module&nbsp;: il pourrait vous manquer lors 
de la configuration d'ALSA, si vous n'avez pris en compte que les 
modules propres à votre carte son.

</para>

<para>
      
Vous devez charger le module virmidi pour activer les ports MIDI. Vous
pouvez les tester avec&nbsp;:

</para>

<programlisting>
$ modprobe snd-virmidi snd_index=1
</programlisting>

<para>
      
où snd_index doit être adapté au premier index de carte libre (=&nbsp;1 
si vous disposez uniquement d'une carte qui a déjà l'index 0). Cela dit, 
il est plus pratique d'adapter la configuration de vos modules pour 
qu'ils soient disponible chaque fois que vous les utilisez. Pour cela, 
il faut ajouter à la section ALSA du fichier 
<filename>/etc/modules.conf</filename> (le chemin dépend de votre 
distribution) les lignes suivantes&nbsp;:

</para>

<programlisting>
# Configure les supports pour OSS /dev/sequencer et 
# /dev/music (aussi appelé /dev/sequencer2)
#
# (Takashi Iwai nous indique qu'il n'est pas nécessaire  
# de créer des alias pour des cartes au-delà de la première
# carte, i.e., la carte 0)
#
alias sound-service-0-1 snd-seq-oss
alias sound-service-0-8 snd-seq-oss

# Configure la carte 1 (deuxième carte) en tant que carte MIDI virtuelle
alias sound-slot-1 snd-card-1
alias snd-card-1 snd-virmidi
</programlisting>

<para>
      
Désormais, votre carte MIDI virtuelle est configurée en tant que carte 
d'index 1, ce qui suppose que vous possédez une carte son réelle (ce qui 
peut s'avérer très utile). Si vous possédez comme moi une seconde carte 
son réelle, modifiez la configuration ci-dessus comme suit&nbsp;:

</para>

<programlisting>
# Configure la carte d'index 2 (troisième carte) en tant que
# carte MIDI virtuelle
alias sound-slot-2 snd-card-2
alias snd-card-2 snd-virmidi
</programlisting>

<para>
      
Si vous possédez plus de cartes son que cela, vous saurez sûrement vous
adapter.

</para>

<para>
      
Il se peut qu'il soit nécessaire de redémarrer le système ALSA, après
quoi vous devriez voir indiquée la carte son virtuelle dans le fichier
/proc/asound/cards&nbsp;:

</para>

<programlisting>
$ cat /proc/asound/cards 
0 [card0          ]: ICE1712 - M Audio Audiophile 24/96
                     M Audio Audiophile 24/96 at 0xb800, irq 5
1 [card1          ]: EMU10K1 - Sound Blaster Live!
                     Sound Blaster Live! at 0xc800, irq 11
2 [card2          ]: VirMIDI - VirMIDI
                     Virtual MIDI Card 1
</programlisting>

<para>
      
Dans cet exemple tiré de mon propre PC, ma carte VirMIDI est la
troisième, d'index 2. Cette configuration se retrouve dans le fichier
/proc/asound/devices (seul les paramètres MIDI sont affichés)&nbsp;:

</para>

<programlisting>
$ cat /proc/asound/devices 
 8: [0- 0]: raw MIDI
41: [1- 1]: raw MIDI
42: [1- 2]: raw MIDI
75: [2- 3]: raw MIDI
74: [2- 2]: raw MIDI
73: [2- 1]: raw MIDI
72: [2- 0]: raw MIDI
</programlisting>

<para>
      
Les entrées commençant par <quote>2-</quote> correspondent à ma carte 
MIDI virtuelle&nbsp;. Si vous ne possédez qu'une seule carte réelle, ces 
entrées commenceront par <quote>1-</quote>.

</para>

<para>
      
Vous pouvez obtenir un affichage plus conviviale des paramètres avec 
l'outil aconnect. Il s'agit d'un outil propre à ALSA, dont vous aurez de 
toutes façons besoin. Pour obtenir la liste des périphériques MIDI 
utilisables en sortie, appelez-le avec l'option <option>-o</option> (ou
<option>-lo</option>). Pour ceux utilisables en entrée, appelez-le avec 
l'option <option>-i</option>.

</para>

<programlisting>
$ aconnect -o
[...]
client 80: 'Virtual Raw MIDI 2-0' [type=kernel]
    0 'VirMIDI 2-0     '
client 81: 'Virtual Raw MIDI 2-1' [type=kernel]
    0 'VirMIDI 2-1     '
client 82: 'Virtual Raw MIDI 2-2' [type=kernel]
    0 'VirMIDI 2-2     '
client 83: 'Virtual Raw MIDI 2-3' [type=kernel]
    0 'VirMIDI 2-3     '
$ aconnect -i
[...]
client 80: 'Virtual Raw MIDI 2-0' [type=kernel]
    0 'VirMIDI 2-0     '
client 81: 'Virtual Raw MIDI 2-1' [type=kernel]
    0 'VirMIDI 2-1     '
client 82: 'Virtual Raw MIDI 2-2' [type=kernel]
    0 'VirMIDI 2-2     '
client 83: 'Virtual Raw MIDI 2-3' [type=kernel]
    0 'VirMIDI 2-3     '
</programlisting>

<para>
      
Les périphériques affichés correspondent aux périphériques MIDI 
compatibles OSS propres à ALSA tels que définis dans le répertoire 
/proc/asound/dev. Par exemple, le périphérique /proc/asound/dev/midiC2D0 
est le premier de notre carte MIDI virtuelle indexée 2, nommée Virtual 
Raw MIDI 2-0 par l'outil aconnect. Sous Débian, ces périphériques sont 
aussi visibles dans le répertoire <filename 
class="directory">/dev/snd/</filename>, et sont aussi liés en interne 
aux anciens répertoires de périphériques <filename 
class="devicefile">/dev/midiXX</filename>. Pour m'assurer que je pouvais 
accéder aux ports MIDI d'ALSA à partir de <filename 
class="devicefile">/dev/midiXX</filename>, je les ai renommés 
ainsi&nbsp;:

</para>

<programlisting>
$ ln -s /dev/snd/midiC2D0 /dev/midi20
$ ln -s /dev/snd/midiC2D1 /dev/midi21
[...]
</programlisting>

<para>
      
mais cela n'est pas nécessaire&nbsp;: ne le faites surtout pas chez 
vous&nbsp;!

</para>

<para>
      
Maintenant que nous avons créé et configuré une carte MIDI virtuelle, 
nous pouvons l'utiliser dans nos applications comme tout autre 
périphériques MIDI. Il vous suffit d'indiquer la référence du 
périphérique MIDI, qu'il s'agisse d'une référence compatible OSS, comme 
<filename class="devicefile">/dev/midi20</filename> ou d'un port MIDI 
ALSA comme <literal>80:0</literal>, à l'endroit approprié dans le 
paramétrage de votre séquenceur ou synthétiseur préféré.

</para>

</sect2>

<sect2>
<title>Canalisation des évènements MIDI</title>

<sect3>
<title>aconnect</title>

<para>
      
Sans autre manipulation, il ne vous sera pas possible d'envoyer des
évènements MIDI à partir de votre séquenceur vers le synthétiseur
virtuel. Pour ce faire, nous devons connecter deux ports avec, vous
l'aurez deviné, l'outil aconnect. Cet outil permet de connecter deux
ports ou plus. Les fichier obtenus avec -i ou -o plus haut nous ont déjà
indiqué les ports disponibles. Maintenant, avec une syntaxe très simple,
ces ports peuvent être connectés ainsi&nbsp;:

</para>

<programlisting>
$ aconnect <replaceable>port_d_envoi</replaceable> <replaceable>port_de_reception</replaceable>
$ aconnect 80:0 81:0
</programlisting>

<para>
      
Cette manipulation permet d'aiguiller toutes les données MIDI envoyées 
sur le port <literal>80:0</literal> vers le port 
<literal>80:1</literal>. Dans notre configuration, cela signifie que 
toute donnée entrant sur le port <filename 
class="devicefile">/dev/midi20</filename> est réorientée vers le port 
<filename class="devicefile">/dev/midi21</filename>, sur lequel elle 
peut être lue (<quote>reçue</quote>) par une autre application.

</para>

<para>
      
Si votre carte MIDI virtuelle est configurée en tant que seconde carte
(index 1), vous devez obtenir les ports suivants&nbsp;:

</para>

<programlisting>
$ aconnect -lo
client 72: 'Virtual Raw MIDI 1-0' [type=kernel]
    0 'VirMIDI 1-0     '
client 73: 'Virtual Raw MIDI 1-1' [type=kernel]
    0 'VirMIDI 1-1     '
client 74: 'Virtual Raw MIDI 1-2' [type=kernel]
    0 'VirMIDI 1-2     '
client 75: 'Virtual Raw MIDI 1-3' [type=kernel]
    0 'VirMIDI 1-3   
</programlisting>

<para>
      
Ici, vous pouvez par exemple connecter le port <literal>72:0</literal> 
(<filename class="devicefile">/dev/midi10</filename>) au port 
<literal>73:0</literal> (<filename 
class="devicefile">/dev/midi11</filename>) en tapant&nbsp;:

</para>

<programlisting>
$ aconnect 72:0 73:0
</programlisting>

<para>
      
aconnect peut nous montrer ce qui a été crée avec ses options -lo et
-li&nbsp;:

</para>

<programlisting>
$ aconnect -lo
client 72: 'Virtual Raw MIDI 1-0' [type=kernel]
    0 'VirMIDI 1-0     '
        Connecting To: 73:0
client 73: 'Virtual Raw MIDI 1-1' [type=kernel]
    0 'VirMIDI 1-1     '
        Connected From: 72:0
client 74: 'Virtual Raw MIDI 1-2' [type=kernel]
    0 'VirMIDI 1-2     '                       
client 75: 'Virtual Raw MIDI 1-3' [type=kernel]
    0 'VirMIDI 1-3
</programlisting>

<para>
      
Vous constatez que le <quote>Virtual Raw MIDI 1-0</quote> est maintenant 
connecté au <quote>Virtual Raw MIDI 1-1</quote>. Dès lors, en fonction 
de vos applications, vous pourrez lire les données MIDI envoyées à votre 
port <quote>Virtual Raw MIDI 1-0</quote> à partir du port <quote>Virtual 
Raw MIDI 1-1</quote>, ou, en reprenant le vocabulaire OSS&nbsp;: tout ce 
qui est envoyé sur le port <filename 
class="devicefile">/dev/midi10</filename> est aiguillé sur le port 
<filename class="devicefile">/dev/midi11</filename> et peut être lu à 
partir de là.

</para>

<para>
      
Vous pouvez aussi connecter plus d'un port sur un autre. Si vous faites
aconnect une deuxième fois comme ceci&nbsp;:

</para>

<programlisting>
 $ aconnect 72:0 73:0
 $ aconnect 72:0 74:0
</programlisting>

<para>
      
vous pouvez recevoir les mêmes données envoyées sur <filename 
class="devicefile">/dev/midi10</filename>, sur les ports <filename 
class="devicefile">/dev/midi11</filename> et <filename 
class="devicefile">/dev/midi12</filename>. Et bien entendu, vous risquez 
vraiment de surcharger votre système si vous créez encore plus de cartes 
MIDI virtuelles et que vous les connectez entre elles. Mais rien 
n'empêche de le faire.

</para>

<para>
      
Pour déconnecter tous les ports, faites&nbsp;:

</para>

<programlisting>
$ aconnect -x 
</programlisting>

<para>
      
Pour ne déconnecter qu'un seul port, faites&nbsp;:

</para>

<programlisting>
$ aconnect -d 72:0 74:0
</programlisting>

</sect3>

</sect2>

<sect2>
<title>Tableaux de raccordement MIDI graphiques</title>

<para>

Le tableau de raccordement MIDI ALSA (<foreignphrase>Alsa Patch 
Bay</foreignphrase>) de Bob Ham est une interface graphique très 
pratique pour la configuration MIDI d'ALSA sous Linux. Son utilisation 
est très simple et intuitive&nbsp;: sur la gauche, vous disposez des 
ports MIDI capables d'envoyer des évènements MIDI, alors que sur la 
droite, vous avez les ports capables d'en recevoir. Si vous cliquez sur 
un port de gauche, cela le sélectionne pour être connecté au port de 
droite sur lequel vous cliquez ensuite. Pour un port connecté, il suffit 
de cliquer sur le port de droite pour le déconnecter&nbsp;: un outil 
précis facile à utiliser, qui aurait presque tendance à rendre inutile 
ce qui a été dit plus haut&nbsp;!&nbsp;;o)

</para>

<sect3>
<title>aseqview</title>

<para>
      
aseqview est un autre outil très utile pour gérer les flux MIDI. Il a 
été créé par Takashi Iwai, qui fait partie des développeurs d'ALSA. Vous 
pouvez le télécharger depuis la page web d'Iwai-sama <ulink 
url="http://members.tripod.de/iwai/alsa.html" />, mais il est souvent 
inclus dans les distributions. Cet outil graphique a été créé pour 
visualiser et modifier les évènements MIDI pendant qu'ils transitent par 
votre PC. Il peut aussi orienter les données MIDI vers d'autres ports, 
tout comme aconnect. Cela peut s'avérer utile lorsque vous devez 
utiliser le séquenceur OSS, qu'aconnect est parfois incapable 
d'utiliser. Si vous lancez aseqview sans aucune option, vous obtenez une 
jolie interface graphique et un nouveau port MIDI. Le port par défaut 
est nommé <literal>128:0</literal>, et il ressemble à cela&nbsp;:

</para>

<programlisting>
client 128: 'MIDI Viewer' [type=user] 
   0 'Viewer Port 0 ' 
</programlisting>

<para>
      
Avec ce port, toutes les manipulations effectuées plus haut avec
aconnect sont possibles. Si vous souhaitez seulement connecter le port
aseqview à un autre port, aseqview peut le faire par lui-même avec
l'option -d&nbsp;:

</para>

<programlisting>
$ aseqview -d 73:0 &amp;
</programlisting>

<para>
      
Cela connecte le port <literal>128:0</literal> au port 
<literal>73:0</literal> dès le démarrage d'aseqview.

</para>

<para>
      
Il existe d'autre outils graphiques de connexion, avec des fonctions
très similaires. Maarten de Boer a utilisé la plupart des sources
aconnect d'origine pour écrire une interface graphique appelée
<quote>aconnectgui</quote> à l'aide de l'outil FLTK. Vous pouvez la
trouver à l'adresse <ulink url="http://www.iua.upf.es/~mdeboer/"/>.
C'est, à mon avis, l'interface la plus agréable à utiliser.

</para>

<para>
      
Personnellement, j'utilise kaconnect, sans doute parce son nom est court 
et donc plus rapide à taper. kaconnect a été développé par Dr. Matthias 
Nagorni de SuSE, au sein d'une série d'outils et de synthétiseurs 
virtuels pour ALSA, les kalsatools. Ne vous méprenez pas sur le 
<quote>k</quote	>&nbsp;: ce logiciel n'a pas besoin de KDE. Il utilise 
directement les bibliothèques graphiques QT. kaconnect, et d'autres 
logiciels, sont disponibles sur <ulink 
url="http://www.suse.de/~mana/kalsatools.html"/>.

</para>

</sect3>

</sect2>

<sect2>
<title>Applications</title>

<para>
      
Dans ce dernier chapitre, je veux vous montrer quelques exemples 
d'utilisation des connections virtuelles MIDI dans diverses 
applications. Mettons que je dispose d'une carte VirMIDI, troisième sur 
mon système, utilisant les ports MIDI ALSA <literal>80:0</literal> à 
<literal>83:0</literal>, ce qui correspond aux périphériques OSS 
MIDI&nbsp;: <filename class="devicefile">/dev/midi20</filename> à 
<filename class="devicefile">/dev/midi23</filename>, et aux 
périphériques ALSA MIDI&nbsp;: <filename 
class="devicefile">/dev/snd/midiC2D0</filename> à <filename 
class="devicefile">/dev/snd/midiC2D3</filename>. Le deux premiers 
d'entre eux ont été connectés de la façon suivante&nbsp;:

</para>

<programlisting>
$ aconnect 80:0 81:0
</programlisting>

<para>
      
Ce qui signifie que toutes les données envoyées au port <filename 
class="devicefile">/dev/midi20</filename> (ou port 
<literal>80:0</literal> ou <filename 
class="devicefile">/dev/snd/midiC2D0</filename>) peuvent être maintenant 
lues sur le port <filename class="devicefile">/dev/midi21</filename> (ou 
port <literal>80:1</literal> ou <filename 
class="devicefile">/dev/snd/midiC2D1</filename>).

</para>

</sect2>

<sect2>
<title>Les séquenceurs</title>

<sect3>
<title>MusE</title>

<para>
      
MusE est un séquenceur virtuel complet écrit par Werner Schweer,
disponible à l'adresse&nbsp;: <ulink url="http://muse.seh.de."/>. Nous
devons configurer le port MIDI virtuel comme port de sortie (output)
dans le menu <quote>Config-&gt;MIDI Ports</quote>. Avec MusE, les ports
sont désignés par leur dénomination ALSA, du type <quote>VirMIDI
X-X</quote>. 

</para>

<para>
      
Assurez-vous d'avoir bien sélectionné le bon port comme port de sortie
pour le canal sur lequel vous souhaitez que le synthétiseur oriente et
joue les données MIDI.

</para>

<para>
      
Pour des raisons que j'ignore, je n'ai pas pu utiliser <quote>VirMIDI 
2-0</quote> comme sortie avec MusE 0.4.9. Ce devrait être pourtant la 
bonne sortie pour recevoir les données sur le port <quote>VirMIDI 
2-1</quote>, mais j'ai dû l'utiliser d'une autre façon. Je ne sais pas 
pourquoi. On peut aussi utiliser les ports <filename 
class="devicefile">midi02</filename> ou <filename 
class="devicefile">midi2</filename>.

</para>

</sect3>

<sect3>
<title>ttrk</title>

<para>
      
ttrk, développé par Billy Biggs, est un petit séquenceur très simple
muni d'une interface de mixage. Il peut sortir toutes ses données MIDI
vers n'importe lequel des ports configurés dans le fichier
$HOME/.ttrkrc. 

</para>

</sect3>

<sect3>
<title>Shaketracker</title>

<para>
      
Le Shaketracker de Juan Linietsky reprend une interface de mixage MIDI
semblable à celle de ttrk, avec toutefois une transposition complète des
effets classiques de mixage sur les données MIDI. Malheureusement, il
utilise comme sortie MIDI le séquenceur d'OSS (<filename class="devicefile">/dev/sequencer</filename>), et non
les périphériques MIDI natifs (<literal>raw MIDI</literal>). Je n'ai pas
pu le faire fonctionner avec aconnect. Toutefois, il possède un
environnement qui inclut aseqview. Si l'on démarre aseqview avant
Shaketracker, le gestionnaire de piste reconnaîtra et utilisera les
ports de aseqview. Il suffit de le sélectionner dans le menu <quote>User
Devices</quote> de Shaketracker, où il figure sous son nom ALSA
<quote>Viewer Port 0</quote>.

</para>

<para>
      
Il peut être pratique de donner à ce périphérique utilisateur un nom
plus explicite que <quote>Null Output</quote>. 

</para>

<para>
      
Si nous démarrons aseqview sans option, nous aurons besoin de connecter 
le port aseqview avec le port du synthétiseur virtuel. Mais, comme dit 
précédemment, nous pourrions aussi démarrer directement aseqview avec un 
port de destination. N'oubliez pas d'utiliser le menu User Device pour 
chacune des pistes qui doit aller vers le synthétiseur virtuel. Je fais 
toujours tourner Shaketracker avec un script qui démarre aseqview, 
attend la création des ports, et démarre enfin Shaketracker:

</para>

<programlisting>
#!/bin/sh
aseqview -d 81:0 &amp;
# sleep 2 seconds to let aseqview do its work:
sleep 2
shaketracker
</programlisting>

</sect3>

</sect2>

<sect2>
<title>Synthétiseurs virtuels</title>

<sect3>
<title>Pure Data</title>

<para>
      
Miller Puckette est le génie qui se cache derrière Pure Data, un 
synthétiseur logiciel libre et un environnement de développement 
multimédia. Pure Data est issu de MAX et est à la base de l'extension 
MAX MSP. Pure Data peut aussi utiliser des périphériques MIDI natifs 
pour lire les évènements MIDI. Il faut, pour cela, indiquer quels 
périphériques utiliser avec l'option <option>-midiindev 
<replaceable>numéro_de_périphérique</replaceable></option>. Cependant, 
la manière d'indiquer quel périphérique utiliser est assez déroutante. 
Voici la façon de faire&nbsp;: pour utiliser <filename 
class="devicefile">/dev/midi0</filename>, démarrez Pure Data avec 
<option>-midiindev 1</option>, pour utiliser <filename 
class="devicefile">/dev/midi1</filename> démarrez-le avec 
<option>-midiindev 2</option> et ainsi de suite. Vous devez donc 
indiquer le numéro de port +&nbsp;1. Un autre exemple&nbsp;: pour 
<filename class="devicefile">/dev/midi21</filename> démarrez Pure Data 
avec l'option <option>-midiindev 22</option>.

</para>

<para>
      
Pure Data offre aussi un guide d'aide&nbsp;: <quote>Test audio and 
MIDI</quote>, ce qui peut vraiment aider pour détecter le bon 
périphérique MIDI.

</para>

</sect3>

<sect3>
<title>Csound</title>

<para>
      
Csound est l'ancêtre de quasiment tous les synthétiseurs virtuels 
actuels, et il a contribué à l'évolution du MIDI. Lancer 
<userinput>csound --help</userinput> vous indiquera comment configurer 
le port d'entrée MIDI. Faites

<option>-M <replaceable>nom_du_port</replaceable></option>

ou 

<option>--midieventdev=<replaceable>nom_du_port</replaceable></option>

et vous pourrez lire les données MIDI en temps réel.

</para>

<para>
      
Ainsi, dans notre exemple, nous lancerons Csound de la façon
suivante&nbsp;:

</para>

<programlisting>
$ csound -M /dev/midi22 -o devaudio midi.csd
</programlisting>

</sect3>

<sect3>
<title>Conclusion</title>

<para>
      
Dorénavant, vous devriez pouvoir vous débrouiller avec tous les
synthétiseurs virtuels pour orchestrer de la musique créée et jouée par
un séquenceur MIDI. Bien sûr, des outils comme aconnect et aseqview ne
sont pas nécessaires pour utiliser un séquenceur virtuel. Vous pouvez
tout aussi bien rediriger les flux de données MIDI qui arrivent sur
votre PC à partir d'un séquenceur externe ou d'un clavier MIDI
directement vers le synthétiseur virtuel sans passer par l'étape du
séquenceur MIDI. Vous devez simplement <quote>aconnecter</quote> le
matériel MIDI externe à votre synthétiseur virtuel ou sur le
synthétiseur embarqué sur votre carte son. Ou faire l'inverse&nbsp;: Pure Data,
Csound ou des environnements comme KeyKit vous permettent de créer des
évènements MIDI de façon algorithmique, ce qui est presque impossible
avec des logiciel de type Cubase. Avec aconnect, vous pouvez aiguiller
les évènements MIDI vers n'importe quel logiciel capable de les jouer. 

</para>

</sect3>

</sect2>

<sect2>
<title>Remerciements</title>

<para>
      
L'auteur souhaite remercier Takashi Iwai pour son aide technique lors de
l'élaboration de ce document et pour ses précieux conseils en Japonais.
Merci, Takashi&nbsp;!

</para>

</sect2>

</sect1>

<sect1>
<title>Liens Utiles</title>

<para>
      
Vous trouverez ci-dessous une liste de liens vers des sites traitant du
MIDI sous Linux. 

</para>

<para>
      
<ulink url="http://www.linux-sound.org/" /> Logiciels audio et MIDI
sous Linux. Une mine de renseignements sur le MIDI et l'audio.

</para>

<para>
      
<ulink url="http://www.linuxdj.com/audio/lad/" /> La liste de
discussions des développeurs Audio sous Linux. Pour toute discussion
sur le développement MIDI.

</para>

<para>
      
<ulink url="http://www.linuxdj.com/audio/quality"/> Le guide Linux de la
qualité audio.  Un bon chapitre sur les cartes MIDI, essentiel pour
créer son studio Linux. 

</para>

<para>
      
<ulink url="http://www.alsa-project.org/"/> Le projet ALSA &mdash;
Pilotes audio et MIDI.

</para>

<para>
      
<ulink url="http://www.4front-tech.com/"/> OSS &mdash; Pilotes audio et
MIDI.

</para>

<para>
      
<ulink url="http://www.gardena.net/benno/linux/audio/"/> Correctif de 
minimisation des temps de latence.

      </para>

<para>
      
<ulink url="http://ccrma-www.stanford.edu/~craig/articles/linuxmidi/"/> 
Introduction à la programmation MIDI sous Linux. Craig Stuart Sapp 
décrit les outils de base pour écrire du MIDI en C ou C++ pour des 
pilotes OSS.

</para>

<para>
      
<ulink url="http://www.suse.de/~mana"/> Excellente collection de
programmes C pour ALSA 0.9 MIDI et PCM, par Dr. Matthias Nagorni.

</para>

</sect1>

<sect1>
<title>Commentaires et corrections</title>

<para>
      
Comme toujours, un guide évolue dans le temps. Je vous encourage à me 
transmettre (en anglais) vos suggestions ou informations sur les 
nouvelles applications et les développements intéressants du MIDI sous 
Linux.

</para>

<para>
      
Par leur grande variété, les cartes son sont parfois difficiles à 
configurer, notamment parce qu'elles ont plusieurs niveaux de pilotes et 
d'options de configuration. Les meilleures sources de renseignement en 
cas de dysfonctionnement sont les sites web de ALSA et OSS, mais aussi 
les forums, ainsi que les listes de discussions consacrées à l'audio 
sous Linux.

</para>

</sect1>

<colophon>

<title>Adaptation française des guides pratiques Linux</title>

<para>

  L'adaptation française de ce document a été réalisée dans le cadre du
  Projet de traduction des Guides pratiques Linux.

</para>

<para>

  Vous pourrez lire d'autres guides pratiques traduits et en apprendre 
  plus sur ce projet en allant sur le site de l'association <ulink 
  url="http://wiki.traduc.org">Traduc.org</ulink>.

</para>

<para>

  Si vous souhaitez apporter votre contribution, n'hésitez pas à nous
  rejoindre, nous serons heureux de vous accueillir.

</para>

<para>
    
  N'hésitez pas à faire parvenir vos commentaires et suggestions 
  concernant l'adaptation française de ce document à l'adresse&nbsp;:
    
  <email>commentaires CHEZ traduc POINT org</email>.

</para>

</colophon>

</article>
