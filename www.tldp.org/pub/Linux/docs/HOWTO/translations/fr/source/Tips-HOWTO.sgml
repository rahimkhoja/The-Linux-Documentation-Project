<!doctype linuxdoc system>

<article>

<title> Astuces Linux HOWTO
<author> <url name="Paul Anderson"
      url="mailto:paul@geeky1.ebtech.net">, traduit par <url
name="Arnaud Gomes-do-Vale" url="mailto:gomesdv@mail.dotcom.fr"> et
     <url name="Nat Makar&eacute;vitch"
      url="mailto:nat@nataa.fr.eu.org">
<date> v3.6, Juin 1998
traduction du 2 janvier 1999
<abstract>
Ce document contient ces astuces et r&eacute;glages difficiles
&agrave; trouver qui rendent Linux un peu plus sympathique.
</abstract>

<toc>


<sect> Introduction

<p>
Ce document est le <bf/Linux Astuces HOWTO/ (titre original&nbsp;: <bf/Linux
Tips HOWTO/), une liste de trucs et d'optimisations bien pratiques,
qui contribuent &agrave; rendre Linux plus agr&eacute;able. Tout ce
qui est ici sort ou bien de ma t&ecirc;te, ou bien de l'ancien Astuces
HOWTO (apr&egrave;s tout, pourquoi enlever des astuces qui
marchent&nbsp;?) Alors envoyez-moi vos astuces
pr&eacute;f&eacute;r&eacute;es (NdT&nbsp;: en anglais&nbsp;!) pour que je puisse
les inclure dans la prochaine version du Linux Astuces HOWTO.

Paul Anderson <em/R&eacute;dacteur de "Linux TIPS HOWTO"/

<tt/panderso@ebtech.net/


<sect> Astuces simples


<sect1> Un truc pratique pour syslog. <em/Paul Anderson, r&eacute;dacteur 
      du Linux Astuces HOWTO/.

<p>
Editez le ficher <tt>/etc/syslog.conf</tt> et ajoutez-y la ligne
suivante&nbsp;:

<tscreen><verb>
# Tout envoyer sur tty8
*.*                                      /dev/tty8
</verb></tscreen>

Attention&nbsp;: PENSEZ &Agrave; UTILISER DES TABULATIONS&nbsp;! Syslog n'aime pas
les espaces.


<sect1> Un script pour afficher les HOWTO compact&eacute;s. <em/Didier 
      Juges,/ <tt/dj@destin.nfds.net/.

<p>
De d&eacute;butant &agrave; d&eacute;butant, voici un petit script qui
facilite la lectures des howto. Mes howto sont dans
<tt>/usr/doc/faq/howto/</tt> et sont compressés avec
<tt/gzip/. Les fichiers s'appellent <tt/XXX-HOWTO.gz/, où XXX est le
titre. J'ai appel&eacute; le script suivant <tt/howto/ et je l'ai
plac&eacute; dans <tt>/usr/local/sbin/</tt>&nbsp;:

<tscreen><code>
#!/bin/sh
if [ "$1" = "" ]; then
    ls /usr/doc/faq/howto | less
else
    gunzip -c /usr/doc/faq/howto/$1-HOWTO.gz | less
fi
</code></tscreen>

Appel&eacute; sans argument, il affiche la liste des howto
disponibles. Quand on lui passe en argument la premi&egrave;re partie
du nom du fichier (avant le trait d'union), il d&eacute;compacte le
document (en laissant l'original intact) et l'affiche &agrave;
l'&eacute;cran.

Par exemple, pour afficher le document <tt/Serial-HOWTO.gz/, tapez&nbsp;:
<tscreen><verb>
$ howto serial
</verb></tscreen>


<sect1> Reste-t-il assez de place libre&nbsp;? <em/Hans Zoebelein,/
     <tt/zocki@goldfish.cube.net/.

<p>
Voici un script qui v&eacute;rifie &agrave; intervalles
r&eacute;guliers qu'il reste de la place sur tout ce qui est
mont&eacute; (disques durs, CDROM, disquettes...)

En cas de p&eacute;nurie d'espace libre, un message est affich&eacute;
&agrave; l'&eacute;cran toutes les X secondes et un courrier
&eacute;lectronique est envoy&eacute; pour chaque
p&eacute;riph&eacute;rique qui d&eacute;borde.

<tscreen><code>
#!/bin/sh

#
# $Id: Tips-HOWTO.sgml,v 1.2 1999/02/02 02:11:38 arnaud Exp $
#

#
# Depuis que j'ai &eacute;t&eacute; confront&eacute; &agrave; des
# messages d'erreur myst&eacute;rieux pendant les compilations
# quand les fichiers temporaires remplissaient mes disques, j'ai
# &eacute;crit &ccedil;a pour &ecirc;tre averti avant que les disques
# ne soient pleins.
#
# Si &ccedil;a a empech&eacute; vos serveurs d'exploser, envoyez
# les courriers de remerciement &agrave; zocki@goldfish.cube.net.
# Si votre site flambe &agrave; cause de &ccedil;a, d&eacute;sol&eacute;
# mais je vous avais pr&eacute;venu: c'est votre probl&egrave;me
# Si vous savez vraiment vous servir de sed, excusez moi :)
#

#
# Lancez-le et vous pouvez l'oublier: mettez "check_hdspace &"
# dans rc.local. Il v&eacute;rifie l'espace libre toutes les
# $SLEEPTIME secondes. Vous pouvez m&ecirc;me surveiller vos
# disquettes et vos bandes.  :)
# Si l'espace libre est inf&eacute;rieur &agrave; $MINFREE (Ko),
# le script va afficher un message d'avertissement et envoyer un
# courrier &agrave; $MAIL_TO_ME pour chaque p&eacute;riph&eacute;rique
# concern&eacute;. D&egrave;s qu'il y a &agrave; nouveau plus de place
# libre que la limite, le syst&egrave;me d'envoi de courrier est 
# r&eacute;amorc&eacute;.
#

# RESTE &Agrave; FAIRE:
# Des $MINFREE diff&eacute;rents pour chaque p&eacute;riph&eacute;rique
# Nettoyer les r&eacute;pertoires /*tmp des vieilleries en cas de
#           p&eacute;nurie d'espace.


DEVICES='/dev/sda2 /dev/sda8 /dev/sda9' # vos disques
MINFREE=20480                           # la limite
SLEEPTIME=10                            # secondes entre deux v&eacute;rifications
MAIL_TO_ME='root@localhost'             # la personne &agrave; avertir


# ------- rien &agrave; changer en dessous (j'esp&egrave;re :) -------

MINMB=0
ISFREE=0
MAILED=""
let MINMB=$MINFREE/1024         # oui, on fait &ccedil;a bien :)

while [ 1 ]; do
        DF="`/bin/df`"
	        for DEVICE in $DEVICES ; do
		ISFREE=`echo $DF | sed s#.\*$DEVICE" "\*[0-9]\*""\*[0-9]\*" "\*## | sed s#" ".\*##`
		
		if [ $ISFREE -le $MINFREE ] ; then
			let ISMB=$ISFREE/1024
			echo  "WARNING: $DEVICE only $ISMB mb free." >&2
			#echo "more stuff here" >&2
			echo -e "\a\a\a\a"
			
			if [ -z  "`echo $MAILED | grep -w $DEVICE`" ] ; then
				echo "WARNING: $DEVICE only $ISMB mb free.      (Trigger is set to $MINMB mb)" \
				| mail -s "WARNING: $DEVICE only $ISMB mb free!" $MAIL_TO_ME
				MAILEDH="$MAILED $DEVICE"
				MAILED=$MAILEDH
                                # rajoutez ce qu'il reste &agrave; faire
                                # par exemple nettoyer les */tmp
			fi
			elif [ -n  "`echo $MAILED | grep -w $DEVICE`" ] ; then
                                # Enlever le marqueur de courrier si
                                # l'espace disponible remonte
                                # au-dessus de la limite. Pour pouvoir
                                # envoyer un nouveau message en cas de 
                                # besoin.
				MAILEDH="`echo $MAILED  | sed s#$DEVICE##`"
				MAILED=$MAILEDH
			fi
			
		done
		sleep $SLEEPTIME

done
</code></tscreen>
<p>


<sect1> Un utilitaire pour nettoyer vos fichiers journaux
     (logs). <em/Paul Anderson, r&eacute;dacteur du Linux Astuces
      HOWTO/.

<p>
Si vous &ecirc;tes comme moi, vous avez une liste de diffusion avec
430 inscrits et plus de 100 messages qui arrivent tous les jours par
UUCP. Qu'est-ce qu'un bidouilleur peut bien faire avec ces
&eacute;normes fichiers journaux&nbsp;? Il peut installer
<tt/chklogs/. <tt/chklogs/ a &eacute;t&eacute; &eacute;crit par Emilio
Grimaldo, <tt/grimaldo@panama.iaehv.nl/, et la version 1.8 actuelle
est disponible sur
<tt>ftp.iaehv.nl:/pub/users/grimaldo/chklogs-1.8.tar.gz</>. C'est
tr&egrave;s simple &agrave; installer (il faut bien s&ucirc;r lire le
contenu du r&eacute;pertoire <tt>doc</>). Une fois le paquetage
install&eacute;, rajoutez une entr&eacute;e &agrave; votre crontab&nbsp;:

<tscreen><verb>
# Lance chklogs tous les jours &agrave; 21h
00 21 * * *          /usr/local/sbin/chklogs -m
</verb></tscreen>

Pendant que vous y &ecirc;tes, n'oubliez pas de dire &agrave; l'auteur
&agrave; quel point vous appr&eacute;ciez son logiciel :)


<sect1> Un script pratique pour nettoyer les fichiers
     <tt/core/. <em/Otto Hammersmith/.

<p>
Cr&eacute;ez un fichier <tt>rmcores</> (l'auteur l'appelle
<tt>handle-cores</>) contenant ceci&nbsp;:

<tscreen><code>
#!/bin/sh
USAGE="$0 <directory> <message-file>"

if [ $# != 2 ] ; then
        echo $USAGE
        exit
fi

 echo Deleting...
find $1 -name core -atime 7 -print -type f -exec rm {} \;

echo e-mailing
for name in `find $1 -name core -exec ls -l {} \; | cut -c16-24`
do
        echo $name
        cat $2 | mail $name
done

</code></tscreen>

Et utilisez cron pour le lancer &agrave; intervalles r&eacute;guliers.


<sect1> D&eacute;placement de r&eacute;pertoires inter partitions Linux (filesystems). <it/Alan Cox,/ <tt/A.Cox@swansea.ac.uk/.
<p>
<tscreen><verb>
(cd /r&eacute;pertoire_source && tar cf - . ) | (cd /r&eacute;pertoire_cible && tar xvf -)
</verb></tscreen>

<it>[ Et pas cd /r&eacute;pertoire_source; tar...etc., qui laisse la
possibilit&eacute; de bousiller un r&eacute;pertoire en cas de
probl&egrave;me. Merci &agrave; Jim Dennis, <tt/jim@starshine.org/,
qui me l'a signal&eacute;. -le r&eacute;dacteur ]</it>


<sect1> Trouver les plus gros r&eacute;pertoires. <em/Mick Ghazey/.

<p>
Vous vous &ecirc;tes d&eacute;j&agrave; demand&eacute; quels
&eacute;taient les plus gros r&eacute;pertoires sur votre machine&nbsp;?
Voici une fa&ccedil;on de les trouver.

<tscreen><verb>
du -S | sort -n
</verb></tscreen>


<sect1> La Linux Gazette.

<p>
Bravo et merci &agrave; John Fisk, le cr&eacute;ateur de la Linux
Gazette. C'est un excellent magazine en ligne, qui plus est
<bf/GRATUIT&nbsp;!/ Que demander de plus&nbsp;? Vous pouvez le trouver &agrave;
l'adresse&nbsp;:

<tscreen><verb>
http://www.linuxgazette.com
</verb></tscreen>

Au fait, il s'av&egrave;re que (1) la LG est maintenant mensuelle et
(2) elle n'est plus maintenue par John Fisk, mais par l'&eacute;quipe
de SSC.


<sect1> Indication permettant de r&eacute;soudre le probl&egrave;me pos&eacute; par le VPATH du GNU make version 3.7. <it/Ted Stern,/ <tt/stern@amath.washington.edu/.

<p>
J'ignore si ce probl&egrave;me concerne de nombreux utilisateurs mais
l'une des caract&eacute;ristiques de la version 3.7 du GNU make ne
m'enthousiasme pas. Il s'agit du comportement d'un VPATH sur
r&eacute;pertoire absolu. Un robuste patch corrige cela, vous pourrez
l'obtenir aupr&egrave;s de Paul D. Smith
<tt>&lt;psmith@wellfleet.com></tt> <footnote>Veuillez r&eacute;diger
votre courrier en anglais !  NDT</footnote>.  Ce dernier poste dans le
groupe gnu.utils.bug un article contenant ce patch et sa documentation
apr&egrave;s parution de chaque nouvelle version du GNU make.  En ce
qui me concerne... il est install&eacute; sur tous les
syst&egrave;mes auxquels j'ai acc&egrave;s !


<sect1> Comment interdire &agrave; ma machine de lancer fsck apr&egrave;s chaque d&eacute;marrage&nbsp;? <it/Dale Lutz,/ <tt/dal@wimsey.com/.

<p>
R&eacute;ponse&nbsp;: Apr&egrave;s recompilation du noyau le syst&egrave;me
de fichiers est consid&eacute;r&eacute; comme non
v&eacute;rifi&eacute; ("marked as dirty"), ce qui implique que fsck
sera mis en action lors de chaque d&eacute;marrage. Pour &eacute;viter
cela lancer :
<tscreen><verb>
rdev -R /zImage 1
</verb></tscreen>
Cela modifie le noyau qui, d&egrave;s lors, consid&egrave;re que le
syst&egrave;me de fichiers est sain.

<p>
Note&nbsp;: Ajoutez, si vous employez LILO, 
<tt/read-only/ &agrave; la section de l'image de boot
de votre fichier de configuration LILO (souvent nomm&eacute; /etc/lilo/config ou /etc/lilo.conf).


<sect1> Comment &eacute;viter les lancements de fsck, au boot, d&ucirc;s au "device busy"&nbsp;? <it/Jon Tombs,/ <tt/jon@gtex02.us.es/.
<p>
Si votre syst&egrave;me conna&igrave;t de fr&eacute;quentes erreurs de type
"device busy" au d&eacute;marrage qui laissent le syst&egrave;me de
fichiers dans un &eacute;tat exigeant un <tt>fsck</tt>, veuillez suivre
les recommandations suivantes :

Ajoutez, au fichier <tt>/etc/rc.d/init.d/halt</tt> ou
<tt>/etc/rc.d/rc.0</tt>, la ligne
<tscreen><verb>
mount -o remount,ro /mount.dir
</verb></tscreen>
pour tous vos syst&egrave;mes de fichiers mont&eacute;s, sauf la
racine, avant l'invocation de umount -a. Cela signifie que si, pour
une quelconque raison, "shutdown" ne parvient pas &agrave; tuer tous
les processus puis d&eacute;monter les partitions ces derni&egrave;res
seront malgr&eacute; tout consid&eacute;r&eacute;es comme saines lors
du red&eacute;marrage.  Cette astuce a consid&eacute;rablement
&eacute;court&eacute; le temps de d&eacute;marrage de mon
syst&egrave;me !


<sect1> Comment trouver les plus gros fichiers sur votre disque
dur. <it/Simon Amor,/ <tt/simon@foobar.co.uk/.

<p>
<tscreen><verb>
ls -l | sort +4n
</verb></tscreen>

Pour ceux d'entre vous qui sont vraiment &agrave; l'&eacute;troit,
&ccedil;a prend du temps, mais &ccedil;a marche bien&nbsp;:

<tscreen><verb>
cd /
ls -lR | sort +4n
</verb></tscreen>


<sect1> Comment imprimer sur des pages avec marges ? <it/Mike Dickey,/ <tt/mdickey@thorplus.lib.purdue.edu/.

<p>
<tscreen><code>
        #!/bin/sh
        # /usr/local/bin/print
        # Une simple sortie format&eacute;e pour permettre de
        # perforer les feuilles afin de les mettre dans un classeur

        cat $1 | pr -t -o 5 -w 85 | lpr
</code></tscreen>


<sect1>
M&eacute;thode permettant de rechercher des expressions rationnelles dans des fichiers. <it/Raul Deluth Miller,/ <tt/rockwell@nova.umd.edu/.
<p>
Je d&eacute;signe, par "expressions rationnelles", les <tt>regexp</tt>
de "grep" et consorts.
<p>
J'ai appel&eacute; ce script "forall" et l'utilise ainsi :
<tscreen><verb>
forall /usr/include grep -i ioctl
forall /usr/man grep ioctl
</verb></tscreen>
Voici le script forall:
<tscreen><code>
#!/bin/sh
if [ 1 = `expr 2 \> $#` ]
then
        echo Syntaxe: $0 repertoire commande [arguments]
        exit 1
fi
dir=$1
shift
find $dir -type f -print | xargs "$@"
</code></tscreen>


<sect1> Un script pour faire le m&eacute;nage derri&egrave;re les
     programmes qui cr&eacute;ent des fichiers de sauvegarde.

<p>
Voici un petit script de deux lignes qui parcourt une arborescence et
qui y efface les fichiers de sauvegarde (# et &tilde;) d'emacs, les fichiers
.o, et les fichiers .log de TeX. Il compacte &eacute;galement les
fichiers .tex et README. Sur mon syst&egrave;me, je l'ai appel&eacute;
"squeeze".

<tscreen><code>
#!/bin/sh
#SQUEEZE efface les fichiers superflus et compacte les fichiers .tex
#et README.
#Par Barry tolnas, tolnas@sun1.engr.utk.edu
#
echo nettoyage de $PWD
find  $PWD \( -name \*~ -or -name \*.o -or -name \*.log -or -name \*\#\) -exec
rm -f {} \;
find $PWD \( -name \*.tex -or -name \*README\* -or -name \*readme\* \) -exec gzip -9 {} \;
</code></tscreen>


<sect1> Comment trouver le processus qui occupe le plus de
     m&eacute;moire. <em/Simon Amor/.

<p>
<tscreen><verb>
ps -aux | sort +4n
</verb></tscreen>
-OU-
<tscreen><verb>
ps -aux | sort +5n
</verb></tscreen>


<sect1> Configuration de <tt/vi/ pour la programmation en C. <em/Paul
      Anderson, r&eacute;dacteur du Linux Astuces HOWTO/.

<p>
Je passe beaucoup de temps &agrave; programmer en C, et j'ai pris le
temps de configurer vi pour me faciliter la t&acirc;che. Voici le
contenu de mon fichier <tt/.exrc/&nbsp;:

<tscreen><code>
set autoindent
set shiftwidth=4
set backspace=2
set ruler
</code></tscreen>

Qu'est-ce que &ccedil;a fait&nbsp;? <tt/autoindent/ force vi &agrave;
indenter automatiquement toutes les lignes qui suivent la
premi&egrave;re ligne indent&eacute;e, <tt/shiftwidth/ impose une
taille de 4 espaces pour ^T, <tt/backspace/ configure la touche
d'espacement arri&egrave;re, et <tt/ruler/ force l'affichage des
num&eacute;ros de lignes. Notez que pour placer le curseur sur une
ligne donn&eacute;e, par exemple la ligne 20, vous pouvez utiliser&nbsp;:

<tscreen><verb>
vi +20 monfichier.c
</></tscreen>


<sect1> Utilisation de ctags pour faciliter la programmation

<p>
Beaucoup de bidouilleurs ont d&eacute;j&agrave; ctags sur leur
machine, mais ne s'en servent pas. Cela peut &ecirc;tre tr&egrave;s
pratique pour &eacute;diter des fonctions sp&eacute;cifiques. Supposez
que vous avez une fonction dans l'un des nombreux fichiers sources
contenus dans un r&eacute;pertoire pour un programme que vous
&ecirc;tes en train d'&eacute;crire, et que vous voulez &eacute;diter
cette fonction pour faire une mise &agrave; jour. Appelons cette
fonction foo(). Vous ne savez pas non plus o&ugrave; elle se trouve
dans le fichier source. C'est l&agrave; que ctags peut &ecirc;tre
tr&egrave;s pratique. Quand vous le lancez, ctags cr&eacute;e un
fichier nomm&eacute; <tt/tags/ dans le r&eacute;pertoire courant, qui
contient la liste de toutes les fonctions, le fichier source dans
lequel elles se trouvent et leur emplacement dans ce fichier
source. Le fichier <tt/tags/ ressemble &agrave; &ccedil;a&nbsp;:

<tscreen><code>

ActiveIconManager	iconmgr.c	/^void ActiveIconManager(active)$/
AddDefaultBindings	add_window.c	/^AddDefaultBindings ()$/
AddEndResize	resize.c	/^AddEndResize(tmp_win)$/
AddFuncButton	menus.c	/^Bool AddFuncButton (num, cont, mods, func, menu, item)$/
AddFuncKey	menus.c	/^Bool AddFuncKey (name, cont, mods, func, menu, win_name, action)$/
AddIconManager	iconmgr.c	/^WList *AddIconManager(tmp_win)$/
AddIconRegion	icons.c	/^AddIconRegion(geom, grav1, grav2, stepx, stepy)$/
AddStartResize	resize.c	/^AddStartResize(tmp_win, x, y, w, h)$/
AddToClientsList	workmgr.c	/^void AddToClientsList (workspace, client)$/
AddToList	list.c	/^AddToList(list_head, name, ptr)$/
</code></tscreen>

Pour &eacute;diter, par exemple, AddEndResize() avec vim, tapez&nbsp;:

<tscreen><verb>
vim -t AddEndResize
</verb></tscreen>

Cela va ouvrir le bon fichier dans l'&eacute;diteur et placer le
curseur au d&eacute;but de la fonction.


<sect1> Pourquoi sendmail se bloque-t-il pendant 5 minutes au
     d&eacute;marrage d'une Red Hat&nbsp;? <em/Paul Anderson/.

<p>
C'est un probl&egrave;me assez courant, presque au point d'en faire
une FAQ. Je ne sais pas si Red Hat corrige l'erreur dans sa
distributions, mais vous pouvez r&eacute;parer &ccedil;a
vous-m&ecirc;me. Si vous regardez dans votre fichier
<tt>/etc/hosts</>, vous allez trouver quelque chose qui ressemble
&agrave; &ccedil;a&nbsp;:

<tscreen><verb>
127.0.0.1        localhost        votremachine
</verb></tscreen>

Quand sendmail d&eacute;marre, il fait une recherche sur le nom de
votre machive (<tt/votremachine/ dans l'exemple). Ensuite, il trouve
que l'adresse IP de la machine est 127.0.0.1; sendmail n'aime pas
&ccedil;a et recommence la recherche. Il continue comme &ccedil;a
pendant un moment avant d'abandonner. Corriger ce probl&egrave;me est
tr&egrave;s facile&nbsp;: &eacute;ditez votre fichier <tt>/etc/hosts</> et
mettez-y quelque chose comme &ccedil;a&nbsp;:

<tscreen><verb>
127.0.0.1        localhost
10.56.142.1      votremachine
</verb></tscreen>


<sect1> Comment configurer une Red Hat pour avoir <tt/ls/ en couleurs?
     <em/Paul Anderson,/ <tt/paul@geeky1.ebtech.net/.

<p>
La distribution Red Hat est fournie avec color-ls (ls en couleurs),
mais je n'arrive pas &agrave; comprendre pourquoi ils ne le
configurent pas pour utiliser les couleurs par d&eacute;faut. Voici
une fa&ccedil;on d'arranger &ccedil;a.

Commencez par taper <tt/eval `DIRCOLORS`/

Puis <tt/alias ls='ls --color=auto'/

Enfin, mettez la ligne "<tt/alias ...../" dans votre
<tt>/etc/bashrc</>.


<sect1> Comment trouver quelle biblioth&egrave;que de /usr/lib
     contient une fonction donn&eacute;e&nbsp;? <em/Pawel Veselow/.

<p>
Vous &ecirc;tes en train de compiler un programme et vous avez
oubli&eacute; de lier une biblioth&egrave;que n&eacute;cessaire? Et
gcc qui ne donne que les noms des fonctions manquantes... Voici une
commande pour trouver ce que vous cherchez&nbsp;:

<tscreen><verb>
for i in *; do echo $i:;nm $i|grep tgetnum 2>/dev/null;done
</verb></tscreen>

Remplacez <tt/tgetnum/ par le nom de la fonction que vous cherchez.


<sect1> J'ai compil&eacute; un petit programme en C, mais quand je le
     lance, je ne vois aucun r&eacute;sultat&nbsp;!

<p>
Vous avez compil&eacute; le programme et cr&eacute;&eacute; un
programme appel&eacute; <tt/test/, non? Linux a d&eacute;j&agrave; un
programme <tt/test/, qui teste si une certaine condition est vraie et
qui n'affiche aucun r&eacute;sultat &agrave; l'&eacute;cran. Pour
lancer votre programme <tt/test/, tapez <tt>./test</tt>.


<sect> Astuces d&eacute;taill&eacute;es


<sect1> Linux et Windows peuvent utiliser une m&ecirc;me partition pour le swap ! <it/Tony Acero,/ <tt/ace3@midway.uchicago.edu/.

<p><enum>
<item> Formater la partition sous DOS puis y disposer le fichier d'&eacute;change
de Windows. Ne pas employer Windows tout de suite afin de laisser ce
fichier compl&egrave;tement "vide" pour faciliter son compactage.

<item> D&eacute;marrer Linux et sauver ce fichier dans un fichier.
Exemple (cas d'une partition de "swap" commun nomm&eacute;e /dev/hda8) :
<tscreen><verb>
dd if=/dev/hda8 of=/etc/dosswap
</verb></tscreen>
<item> Compacter le fichier de swap :
<tscreen><verb>
gzip -9 /etc/dosswap
</verb></tscreen>
<item> Ajouter au fichier /etc/rc la ligne suivante afin de pr&eacute;parer et
installer la partition de swap lorsqu'elle est employ&eacute;e par Linux :
<em/XXXXX repr&eacute;sente ici le nombre de blocs que compte la partition de swap/
<tscreen><verb>
mkswap /dev/hda8 XXXXX
swapon -av   
</verb></tscreen>
Ajoutez une ligne destin&eacute;e &agrave; cette partiton de swap dans le fichier /etc/fstab

<item> 
Si les programmes init et shutdown employ&eacute;s utilisent /etc/brc ajouter
&agrave; ce fichier les lignes suivantes&nbsp;:
<tscreen><verb>
swapoff -av
zcat /etc/dosswap.gz | dd of=/dev/hda8 bs=1k count=100
</verb></tscreen>
Dans le cas contraire il vous faudra invoquer ces commandes avant chaque fin
de session Linux (placer ces commandes dans un script...)
</enum>
Note : dd ne traite que 100 blocs car j'ai empiriquement d&eacute;termin&eacute; que rien
ne sert d'en &eacute;crire davantage&nbsp;!

&gt
&gt  Quels sont les avantages et inconv&eacute;nients de cette m&eacute;thode ?

Avantages&nbsp;: gain d'espace disponible sur le disque !

Inconv&eacute;nients&nbsp;: si l'&eacute;tape de restauration du fichier d'&eacute;change Windows n'est
pas automatique il ne faudra pas n&eacute;gliger, sous Linux et avant chaque
red&eacute;marrage "vers" Windows, de lancer les commandes charg&eacute;es de cette remise
en place.


<sect1> R&eacute;cup&eacute;ration de fichiers effac&eacute;s. <em/Michael Hamilton,/ <tt/michael@actrix.gen.nz/.

<p>
Voici une astuce dont j'ai eu besoin &agrave; quelques reprises.

La r&eacute;cup&eacute;ration d'un fichier texte par une personne
d&eacute;sesp&eacute;r&eacute;e.

Si vous effacez un fichier texte par accident, par exemple un courrier
&eacute;lectronique ou le produit d'une nuit de programmation, tout
n'est pas perdu. Si le fichier a eu le temps d'aller jusqu'au disque,
c'est &agrave; dire s'il a exist&eacute; pendant plus de 30 secondes,
il est possible que son contenu se trouve encore sur la partition.

Vous pouvez le rechercher dans la partition en utilisant la commande
grep.

Par exemple, r&eacute;cemment, j'ai effac&eacute; un courrier
&eacute;lectronique par accident. J'ai imm&eacute;diatement
cess&eacute; toute activit&eacute; qui aurait pu modifier le contenu
de la partition&nbsp;: je me suis abstenu de sauvegarder quoi que ce soit,
de compiler quoi que ce soit, etc. En d'autres occasions, je suis
all&eacute; jusqu'&agrave; passer le syst&egrave;me en mode
mono-utilisateur et d&eacute;monter le syst&egrave;me de fichiers.

J'ai ensuite utilis&eacute; la commande egrep sur la partition&nbsp;: dans
mon cas, le message se trouvait dans <tt>/usr/local/home/michael/</>,
et donc d'apr&egrave;s la sortie de df, dans <tt>/dev/hdb5</>.

<tscreen><verb>
   sputnik3:~ % df
   Filesystem         1024-blocks  Used Available Capacity Mounted on
   /dev/hda3              18621    9759     7901     55%   /
   /dev/hdb3             308852  258443    34458     88%   /usr
   /dev/hdb5             466896  407062    35720     92%   /usr/local

   sputnik3:~ % su
   Password:
   [michael@sputnik3 michael]# egrep -50 'ftp.+COL' /dev/hdb5 > /tmp/x
</verb></tscreen>

Je suis extr&ecirc;mement prudent quand je manipule des partitions,
donc j'ai bien pris le temps de m'assurer que je comprenais la syntaxe
de cette commande AVANT de presser la touche Entr&eacute;e. Dans ce
cas, le message contenait la mot "ftp", puis un peu de texte suivi du
mot "COL". Le message faisait une vingtaine de lignes, donc j'ai
utilis&eacute; -50 pour avoir toutes les lignes assez proches de la
phrase. Il m'est d&eacute;j&agrave; arriv&eacute; d'utiliser -3000
pour &ecirc;tre s&ucirc;r de r&eacute;perer toutes les lignes d'un
code source. J'ai redirig&eacute; le sortie de egrep vers une autre
partition pour &eacute;viter d'&eacute;craser le message que je
recherchais.

J'ai ensuite utilis&eacute; la commande strings pour examiner le
r&eacute;sultat.

<tscreen><verb>
  strings /tmp/x | less
</verb></tscreen>

Effectivement, le message &eacute;tait l&agrave;.

Cette m&eacute;thode peut ne pas &ecirc;tre efficace si tout ou partie
de l'espace disque a d&eacute;j&agrave; &eacute;t&eacute;
r&eacute;utilis&eacute;.

Cette astuce n'est probablement utilisable que sur un syst&egrave;me
mono-utilisateur. Sur un syst&egrave;me multi-utilisateurs avec
beaucoup d'activit&eacute; sur les disques, l'emplacement que vous
avez lib&eacute;r&eacute; peut tr&egrave;s bien d&eacute;j&agrave;
avoir &eacute;t&eacute; r&eacute;utilis&eacute;. Et pour la plupart
nous ne pouvons pas nous permettre d'enlever la machine de sous les
pieds de nos utilisateurs d&egrave;s que nous avons besoin de
r&eacute;cup&eacute;rer un fichier.

Sur mon syst&egrave;me personnel, cette astuce a &eacute;t&eacute;
bien pratique &agrave; environ trois occasions ces quelques
derni&egrave;res ann&eacute;es&nbsp;-&nbsp;g&eacute;n&eacute;ralement
apr&egrave;s que j'ai d&eacute;truit accidentellement une partie de
mon travail du jour. Si ce que je fais survit assez longtemps pour
progresser de fa&ccedil;on significative, je le sauvegarde sur une
disquette, donc je n'ai pas souvent besoin de ce truc.


<sect1> Comment utiliser le marqueur d'immutabilit&eacute;. <em/Jim
      Dennis,/ <tt/jadestar@rahul.net/.

<p>
Utilisez le marqueur d'immutabilit&eacute;.

Juste apr&egrave;s avoir install&eacute; et configur&eacute; votre
syst&egrave;me, faites un tour dans <tt>/bin</>, <tt>/sbin</>,
<tt>/usr/bin</>, <tt>/usr/sbin</>, <tt>/usr/lib</> et autres, et
n'h&eacute;sitez pas &agrave; vous servir de la commande "<tt/chattr
+i/". Appliquez-la aussi aux fichiers du noyau &agrave; la
racine. Maintenant, "<tt>mkdir /etc/.dist</>" et copiez-y toute
l'arborescence contenue dans <tt>/etc</> (je le fais en deux
&eacute;tapes en utilisant <tt>/tmp/etcdist.tar</> pour &eacute;viter
la r&eacute;cursion). (Vous pouvez aussi vous contenter de
<tt>/etc/.dist.tar.gz</>). Et placez-y un marqueur
d'immutabilit&eacute;.

Tout cela sert &agrave; limiter les d&eacute;g&acirc;ts que vous
pouvez faire en tant que root. Vous &eacute;viterez ainsi
d'&eacute;craser des fichiers avec une redirection mal
contr&ocirc;l&eacute;e, et vous ne risquez pas de rendre le
syst&egrave;me inutilisable &agrave; cause d'une espace mal
plac&eacute;e dans une commande "<tt/rm -fr/"&nbsp;; vous pouvez toujours
faire tr&egrave;s mal &agrave; vos donn&eacute;es, mais vos binaires
et vos biblioth&egrave;ques seront &agrave; l'abri.

De plus, cela pr&eacute;vient, ou du moins complique, l'exploitation
d'un certain nombre de trous de s&eacute;curit&eacute;&nbsp;; en effet,
beaucoup d'attaques de ce type &eacute;crasent un fichier au moyen
d'un quelconque programme SUID qui <em>ne permet pas
d'ex&eacute;cuter une commande arbitraire</em>.

Le seul inconv&eacute;nient se pr&eacute;sente &agrave; l'installation
de divers logiciels syst&egrave;me. D'un autre c&ocirc;t&eacute;,
&ccedil;a emp&ecirc;che l'&eacute;crasement accidentel de fichiers par
"<tt/make install/". Si vous oubliez de lire le Makefile et
d'appliquer <tt/chattr -i/ aux fichiers qui doivent &ecirc;tre
&eacute;cras&eacute;s (et aux r&eacute;pertoires auxquels vous voulez
ajouter des fichiers), le make &eacute;choue, et il suffit d'utiliser
chattr avant de le relancer. Vous pouvez aussi en profiter pour
d&eacute;placer vos anciens binaires, biblioth&egrave;ques et autres
dans un r&eacute;pertoire <tt>.old/</>, les renommer, les archiver ou
autre.


<sect1> Une suggestion quant &agrave; l'endroit o&ugrave; mettre ce
     que vous rajoutez.

<p>
Tout ce que vous rajoutez doit se trouver sous <tt>/usr/local</> ou
<tt>/usr/local/`hostname`</>!

Si votre distribution laisse <tt>/usr/local</> vide, cr&eacute;ez
<tt>/usr/local/src</>, <tt>/usr/local/bin</>, etc. et utilisez-les. Si
votre distribution met des choses dans <tt>/usr/local</>, cr&eacute;ez
<tt>/usr/local/`hostname`</> et donnez-lui le mode +w pour le groupe
wheel (en plus, je le rends SUID et SGID pour m'assurer que les
membres du groupe wheel ne peuvent toucher qu'&agrave; leurs propres
fichiers et que tous les nouveaux fichiers vont appartenir au groupe
wheel).

Maintenant, forcez-vous &agrave; <em>TOUJOURS</em> placer
les nouveaux paquetages sous
<tt>/usr/local/src/.from/$OU_JE_L_AI_EU</> (pour les fichiers .tar ou
autres) et &agrave; les compiler sous <tt>/usr/local/src</> (ou
<tt>.../$HOSTNAME/src</>). Assurez-vous qu'ils s'installent sous la
hi&eacute;rarchie locale. Si quelque chose *doit obligatoirement*
&ecirc;tre install&eacute; dans <tt>/bin</> ou <tt>/usr/bin</> ou
autre, cr&eacute;ez un lien symbolique depuis la hi&eacute;rarchie
locale vers tout ce qui est install&eacute; ailleurs.

La raison de tout &ccedil;a, m&ecirc;me si &ccedil;a repr&eacute;sente
plus de travail, est que &ccedil;a permet de trouver facilement ce qui
doit &ecirc;tre sauvegard&eacute; et r&eacute;install&eacute; en cas
de r&eacute;installation compl&egrave;te depuis le m&eacute;dia de
distribution (habituellement un CD &agrave; l'heure actuelle). En
utilisant un r&eacute;pertoire <tt>/usr/local/src/.from</>, vous
gardez aussi une trace de la provenance de vos sources, ce qui est
utile pour trouver les mises &agrave; jour et qui peut s'av&eacute;rer
critique pour suivre les listes d'annonces de s&eacute;curit&eacute;.

Un de mes syst&egrave;mes personnels (celui que j'utilise) a
&eacute;t&eacute; mont&eacute; avant que je n'applique moi-m&ecirc;me
cette politique. Je ne "sais" toujours pas en quoi il diff&egrave;re
du syst&egrave;me de base "tel qu'install&eacute;". Et cela
bien que je n'ai chang&eacute; que tr&egrave;s peu de choses
quant &agrave; sa configuration et que je suis le *seul* &agrave;
l'utiliser.

A contrario, tous les syst&egrave;mes que j'ai mis en place au travail
(o&ugrave; j'ai &eacute;t&eacute; bombard&eacute; administrateur
syst&egrave;me) ont &eacute;t&eacute; configur&eacute;s de cette
fa&ccedil;on. Ils ont &eacute;t&eacute; administr&eacute;s par
plusieurs personnes ext&eacute;rieures et autres membres du
d&eacute;partement informatique, et ils ont subi de nombreuses mises
&agrave; jour et installations de logiciels. Pourtant, j'ai une
id&eacute;e tr&egrave;s pr&eacute;cise de ce qui a &eacute;t&eacute;
rajout&eacute; *apr&egrave;s* l'installation et la configuration
initiales.


<sect1> Conversion de tous les fichiers d'un r&eacute;pertoire en
     minuscules. <em/Justin Dossey,/ <tt/dossey@ou.edu/.

<p>
J'ai remarqu&eacute; quelques proc&eacute;dures difficiles ou
superflues recommand&eacute;es dans les trucs et astuces du
num&eacute;ro 12 <footnote>NdT&nbsp;: Apparemment, cette section est
tir&eacute;e de la Linux Gazette</>. Comme il y en a plusieurs, je
vous adresse ce message.

<tscreen><code>
#!/bin/sh
         # lowerit
	 # convertit les noms de tous les fichiers du r&eacute;pertoire
	 # courant en minuscules
         # n'affecte que les fichiers, pas les sous-r&eacute;pertoires
	 # demande confirmation avant d'&eacute;craser un fichier existant
	 for x in `ls`
	   do
	   if [ ! -f $x ]; then
	     continue
	     fi
	   lc=`echo $x  | tr '[A-Z]' '[a-z]'`
	   if [ $lc != $x ]; then
	     mv -i $x $lc
	   fi
	   done
</code></tscreen>

Voil&agrave; un long script. Je n'&eacute;crirais pas un script pour
&ccedil;a&nbsp;; j'utiliserais plut&ocirc;t la commande suivante&nbsp;:

<tscreen><verb>
for i in * ; do [ -f $i ] && mv -i $i `echo $i | tr '[A-Z]' '[a-z]'`;
done;
</verb></tscreen>

Ce contributeur dit qu'il a &eacute;crit le script de cette
fa&ccedil;on pour des raisons de lisibilit&eacute; (voir plus bas).

Pour l'astuce suivante, qui traite de l'ajout et de la suppression
d'utilisateurs, Geoff s'en sort bien jusqu'&agrave; la derni&egrave;re
&eacute;tape. Rebooter&nbsp;? J'esp&egrave;re qu'il ne reboote pas &agrave;
chaque fois qu'il supprime un utilisateur. Les deux premi&egrave;res
&eacute;tapes suffisent. De toutes fa&ccedil;ons, quels processus cet
utilisateur pourrait-il laisser tourner&nbsp;? Un bot IRC&nbsp;? Tuez simplement
les processus avec&nbsp;:

<tscreen><verb>
kill -9 `ps -aux |grep ^<nom d'utilisateur> |tr -s " " |cut -d " " -f2`
</verb></tscreen>

Par exemple, pour l'utilisateur foo:

<tscreen><verb>
kill -9 `ps -aux |grep ^foo |tr -s " " |cut -d " " -f2`
</verb></tscreen>

Cette question &eacute;tant class&eacute;e, passons au mot de passe de
root oubli&eacute;.

La solution donn&eacute;e dans la Gazette est la plus universelle,
mais pas la plus facile. Aussi bien avec LILO qu'avec Loadlin, le
param&egrave;tre "single" permet de lancer directement le shell par
d&eacute;faut au d&eacute;marrage, sans entrer de login ni de mot de
passe. &Agrave; partir de l&agrave;, il suffit de changer ou d'enlever
le mot de passe probl&eacute;matique, avant de taper "<tt/init 3/"
pour passer en mode multi-utilisateurs. De cette fa&ccedil;on, un seul
reboot&nbsp;; de l'autre, deux reboots.

Justin Dossey.


<sect1> Mise &agrave; jour de Sendmail. <em/Paul Anderson,/
     <tt/paul@geeky1.ebtech.net/

<p>
Nous partons d'une source propre. Commencez par vous procurer le code
source de sendmail. J'ai t&eacute;l&eacute;charg&eacute; la version
8.9.0, qui est comme vous pouvez le voir &agrave; la pointe du
progr&egrave;s. Je l'ai r&eacute;cup&eacute;r&eacute;e depuis
ftp.sendmail.org:/pub/sendmail/sendmail-8.9.0.tar.gz

Il p&egrave;se &agrave; peu pr&egrave;s un m&eacute;ga-octet, et
sachant que j'utilise la version 8.7.6, je crois que &ccedil;a vaut le
co&ucirc;t. Si &ccedil;a marche, vous en entendrez s&ucirc;rement
parler&nbsp;; sinon, je n'aurai plus de courrier et je ne pourrai pas
distribuer la nouvelle version de ce HOWTO :)

Maintenant que vous avez t&eacute;l&eacute;charg&eacute; le source,
d&eacute;compactez-le. Cela va cr&eacute;er un sous-r&eacute;pertoire
<tt/sendmail-8.9.0/ dans le r&eacute;pertoire courant. Placez-vous
dans ce sous-r&eacute;pertoire et lisez les fichiers <tt/README/ et
<tt/RELEASE_NOTES/ (et soyez &eacute;poustoufl&eacute; par toutes les
am&eacute;liorations qu'ils ont apport&eacute;es). Maintenant,
placez-vous dans <tt/src/. C'est l&agrave; que vous allez faire le
plus gros du travail.

<em>Une remarque au passage&nbsp;: Sendmail est un programme petit, puissant
et bien &eacute;crit. Le binaire <tt/sendmail/ lui-m&ecirc;me a mis
moins de 5 minutes &agrave; compiler sur mon 5x86 133 avec 32 Mo de
RAM&nbsp;! La totalit&eacute; de la compilation et de l'installation (sans
compter la configuration) ont pris moins de 15 minutes&nbsp;!</>

Je n'utilise pas BIND sur mon syst&egrave;me, donc j'ai cherch&eacute;
les lignes suivantes&nbsp;:

<tscreen><code>
# ifndef NAMED_BIND
#  define NAMED_BIND    1       /* use Berkeley Internet Domain Server */
# endif
</code></tscreen>

et j'ai remplac&eacute; le 1 par un 0:

<tscreen><code>
# ifndef NAMED_BIND
#  define NAMED_BIND    0       /* use Berkeley Internet Domain Server */
# endif
</code></tscreen>

Sur la Debian 1.3, <tt/db.h/ est install&eacute; par d&eacute;faut
dans <tt>/usr/include/db</>, au lieu de <tt>/usr/include</> o&ugrave;
sendmail esp&egrave;re le trouver. Placez-vous successivement dans les
sous-r&eacute;pertoires <tt/src/, <tt/mailstats/, <tt/makemap/,
<tt/praliases/, <tt/rmail/ et <tt/smrsh/ et &eacute;xecutez la
commande suivante&nbsp;:

<tscreen><verb>
 ./Build -I/usr/include/db
</verb></tscreen>

Ensuite, <tt/cd ../ et tapez <tt/make install/. Voil&agrave;&nbsp;! La
version 8.9.0 de Sendmail doit maintenant &ecirc;tre install&eacute;e&nbsp;!
Bien s&ucirc;r, &ccedil;a suppose que vous avez d&eacute;j&agrave;
votre configuration d'origine. Pour que tout marche bien sur mon
syst&egrave;me, comme j'h&eacute;berge des listes de diffusion
gratuites utilisant majordomo, j'ai ajout&eacute; la ligne suivante au
d&eacute;but de mon <tt>/etc/sendmail.cf</>&nbsp;:

<tscreen><code>
O DontBlameSendmail=forwardfileinunsafedirpath, forwardfileinunsafedirpathsafe
</code></tscreen>

Sendmail 8.9.0 est &agrave; l'heure actuelle plut&ocirc;t bavard
&agrave; propos des permissions des r&eacute;pertoires et des
fichiers, et il va se plaindre &agrave; propos des r&eacute;pertoires
et des fichiers qui autorisent l'acc&egrave;s en &eacute;criture pour
le groupe ou pour tout le monde parmi les fichiers d'alias ou
<tt/.forward/. Bien qu'il ne soit pas recommand&eacute; d'inhiber ces
avertissements, je suis toujours seul &agrave; la console et j'ai
trouv&eacute; que ce trou de s&eacute;curit&eacute; mineur
n'&eacute;tait en fait pas g&ecirc;nant. C'est vous qui voyez.


<sect1> Quelques astuces pour les administrateurs syst&egrave;me
     d&eacute;butants. <em/Jim Dennis,/ <tt/jadestar@rahul.net/

<p>
Cr&eacute;ez et tenez &agrave; jour un fichier
<tt>/README.`hostname`</> ou <tt>/etc/README.`hostname`</>
<em>[&nbsp;ou &eacute;ventuellement
<tt>/usr/local/etc/README.`hostname`</> - le
r&eacute;dacteur&nbsp;]</>

Absolument, &agrave; compter du <em>premier jour</em> de l'administration
d'un syst&egrave;me, prenez des notes dans un fichier journal. Vous
pouvez mettre "vi /README.$(hostname)" sur une ligne du fichier
<tt/.bash_logout/ de root. Une autre fa&ccedil;on de faire est
d'&eacute;crire un script <tt/su/ ou <tt/sudo/ qui fait quelque chose
comme &ccedil;a&nbsp;:

<tscreen><verb>
                function exit \
                        { unset exit; exit; \
                          cat ~/tmp/session.$(date +%y%m%d) \
                          >> /README.$(hostname) && \
                          vi /README.$(hostname)
                          }
                script -a ~/tmp/session.$(date +%y%m%d)
                /bin/su.org -
</verb></tscreen>

(utilise la commande tap&eacute;e pour cr&eacute;er une trace de la
session et cr&eacute;e une fonction pour automatiser la mise &agrave;
jour du fichier journal).

J'admets que je n'ai pas implant&eacute; cette automatisation -
jusqu'&agrave; maintenant je me suis repos&eacute; sur ma
discipline. Cependant j'ai envisag&eacute; l'id&eacute;e (au point
d'&eacute;crire les scripts et les fonctions que vous avez sous les
yeux). Une chose qui me retient est la commande "script"
elle-m&ecirc;me. Je pense qu'il va falloir que je me procure les
sources et que je rajoute une paire de param&egrave;tres (pour
arr&ecirc;ter l'enregistrement du script depuis la ligne de commandes)
avant de me mettre &agrave; utiliser &ccedil;a.

Ma derni&egrave;re suggestion (pour cette fois)&nbsp;:

La variable PATH de root devrait contenir <tt>PATH=~/bin</>.

C'est tout. Rien d'autre dans le PATH de root. Tout ce que root peut
faire est fourni par un lien symbolique dans <tt>~/bin</>, un alias,
une fonction shell, un script ou un binaire situ&eacute; dans
<tt>~/bin</>, ou bien la commande est tap&eacute;e avec un chemin
d'acc&egrave;s explicite.

De cette fa&ccedil;on, toute personne utilisant le compte root se rend
compte (parfois douloureusement) &agrave; quel point elle fait
confiance aux binaires. L'administrateur avis&eacute; d'un
syst&egrave;me multi-utilisateurs va en plus parcourir
r&eacute;guli&egrave;rement son r&eacute;pertoire <tt>~/bin</> et ses
fichiers <tt>~/.*history</> pour y chercher des
r&eacute;p&eacute;titions et des moyens de les contourner.

L'administrateur vraiment motiv&eacute; va rep&eacute;rer les
encha&icirc;nements qui peuvent &ecirc;tre automatis&eacute;s, les
endroits o&ugrave; des v&eacute;rifications peuvent &ecirc;tre
ajout&eacute;es, et les t&acirc;ches pour lesquelles les
privil&egrave;ges de root peuvent &ecirc;tre abandonn&eacute;es (comme
lancer un &eacute;diteur, un agent de transport de courrier
&eacute;lectronique ou autre gros programme pouvant ex&eacute;cuter
des scripts qui *pourraient* &ecirc;tre inclus dans des fichiers de
donn&eacute;es - comme vi (<tt>./.exrc</>) ou emacs (<tt>./.emacs</>)
ou m&ecirc;me, plus insidieux, $EXINIT et les macros contenues au
d&eacute;but ou &agrave; la fin des documents). Bien s&ucirc;r, les
commandes de ce genre peuvent &ecirc;tre lanc&eacute;es avec quelque
chose comme &ccedil;a&nbsp;:

<tscreen><verb>
                cp $donn&eacute;es $r&eacute;pertoire_utilisateur/tmp
                su -c $commande_d_origine $param&egrave;tres
                cp $r&eacute;pertoire_utilisateur/tmp $donn&eacute;es
</verb></tscreen>

(... o&ugrave; les d&eacute;tails d&eacute;pendent de la commande).

Ces derni&egrave;res pr&eacute;cautions sont pour la plupart
superflues pour la machine personnelle ou la station
"mono-utilisateur". Mais elles repr&eacute;sentent une tr&egrave;s
bonne mani&egrave;re d'administrer un gros syst&egrave;me
multi-utilisateurs, particuli&egrave;rement dans le cas d'un
acc&egrave;s public (comme les machines de netcom).


<sect1> Comment configurer <tt>xdm</tt> pour qu'il permette de choisir le syst&egrave;me h&ocirc;te ? <it/Arrigo Triulzi,/ <tt/a.triulzi@ic.ac.uk/.

<p><enum>
<item> Modifier le  fichier lan&ccedil;ant xdm lors du d&eacute;marrage
(probablement nomm&eacute; /etc/rc/rc.6 ou /etc/rc.local) de fa&ccedil;on que la section
de xdm contienne :
<tscreen><verb>
/usr/bin/X11/xdm
exec /usr/bin/X11/X -indirect hostname
</verb></tscreen>
<item> Modifier le fichier /usr/lib/X11/xdm/Xservers et commenter la ligne
invoquant le serveur sur la machine locale (commence par "0:")

<item> Relancer le syst&egrave;me... tout doit fonctionner&nbsp;!
</enum>
<p>
J'ajoute cette section apr&egrave;s avoir su&eacute; une semaine durant sur ce probl&egrave;me&nbsp;!

Attention : certaines anciennes versions de la distribution SLS (1.1.1)
exigent qu'un param&egrave;tre "-nodaemon" accompagne l'invocation d'xdm.
Les version ult&eacute;rieures ne pr&eacute;sentent <bf/PAS/ cette caract&eacute;ristique.

</article>
