<!doctype linuxdoc system>
<article>
<title>RedHat Linux KickStart HOWTO
<author>Martin Hamilton <tt/&lt;martinh@gnu.org>/
&nl;
Traduction: Laurent Martin <tt>&lt;l_martin@worldnet.fr&gt;</tt>
<date>v0.1, 28 septembre 1998

<abstract>
Ce HOWTO décrit brièvement comment utiliser le système 
<em>KickStart</em> de RedHat pour rapidement installer un grand nombre 
de systèmes Linux identiques. Pour les utilisateurs expérimentés, on 
décrit comment modifier la procédure d'installation de KickStart pour 
l'adapter à ses propres besoins et donne quelques indications pour créer 
des paquetages RPM.
</abstract>


<toc>

<sect>Copyright

<p>Copyright (c) 1998 Martin Hamilton, tous droits de reproduction 
réservés. Ce document est un &laquo;&nbsp;document
libre&nbsp;&raquo;. Vous pouvez le modifier ou le redistribuer si vous 
respectez les termes de la version 2 ou ultérieure de la <url
name="GNU General Public License"
url="http://www.gnu.org/copyleft/gpl.html"> 


<sect>Page sur la Toile

<p>Si vous avez obtenu ce document dans le répertoire HOWTO d'un site
Linux ou sur un CD-ROM, vous pouvez vérifier la page <url
name="KickStart HOWTO" url="http://wwwcache.ja.net/dev/kickstart/">  

pour voir s'il n'y a pas une nouvelle version de disponible.  


<sect>Introduction

<p>La version 5 de Linux RedHat est livrée avec un utilitaire peu
connu (et jusqu'à aujourd'hui quasiment pas documenté) appelé
<em>KickStart</em>. Il vous permet d'automatiser (presque) toute
l'installation d'une distribution Linux RedHat et notamment:

<itemize>
<item>la sélection de la langue;
<item>la configuration réseau et la sélection des sources de la
distribution; 
<item>la sélection du clavier;
<item>l'installation de l'utilitaire de démarrage (ex: lilo); 
<item>le partitionnement du disque et la création du système de fichiers;
<item>la sélection de la souris;
<item>la configuration du serveur X-Window;
<item>la sélection de la zone géographique;
<item>la sélection du mot de passe de l'utilisateur <em>root</em>;
<item>la sélection des paquetages à installer.
</itemize>

<p>Les utilisateurs perspicaces d'une distribution RedHat auront
probablement réalisé qu'il s'agit des principales étapes de
l'installation manuelle d'une distribution RedHat. KickStart vous
permet d'automatiser le processus d'installation en plaçant les
informations que vous rentreriez normalement au clavier dans un
fichier de configuration. 

<p><em>Mais attendez, il y a mieux!</em>

<p>Une fois le processus d'installation achevé, KickStart vous permet
de spécifier une liste de commandes shell que vous souhaitez voir
exécutées. Cela signifie que vous pouvez automatiquement installer des
logiciels locaux qui ne font pas partie de la distribution 
RedHat (et oui, il existe bien d'autres logiciels libres que ceux
fournis avec la distribution RedHat! Certains ne peuvent, pour des
raisons légales, être distribués par RedHat, par exemple: les systèmes
de cryptage <tt>ssh</tt> et <tt>PGP</tt>) et procéder aux derniers
réglages nécessaires pour rendre votre nouveau système d'exploitation 
parfaitement opérationnel.


<sect>Prérequis

<p>Il y a deux manières d'utiliser KickStart. La première est de
copier le fichier de configuration de KickStart sur une disquette
d'amorçage RedHat. La seconde est d'utiliser une disquette d'amorçage
classique et de récupérer ce fichier de configuration via le réseau. 

<p>Dans les deux cas, vous aurez besoin:

<enum> 
<item>de machines utilisant un processeur Intel (i386) - KickStart ne
semble marcher que sur ces machines au moment où j'écris ces lignes; 
<item>du fichier de configuration de KickStart - nous en reparlerons
dans la prochaine section; 
<item>d'une disquette d'amorçage RedHat - de préférence celle du 
répertoire <em>updates</em>, pour profiter des dernières mises à jour
et corrections des gestionnaires de périphérique;
<item>des entrées DNS pour les adresses IP que vous allez utiliser -
optionnel, mais cela évitera que le processus d'installation ne vous 
demande sans cesse le domaine de votre machine; 
</enum>

<p>Si vous souhaitez récupérer le fichier de configuration via le
réseau, vous aurez également besoin: 

<enum>
<item>d'un serveur BOOTP/DHCP pour le réseau sur lequel seront
installées vos machines. Certains serveurs alloueront automatiquement
les nouvelles adresses dans une plage donnée (par exemple: <url
name="le serveur BOOTP CMU"
url="ftp://ftp.ntplx.net/pub/networking/bootp/"> avec
les extensions d'adressage dynamique). 
<item>d'un serveur NFS sur la m&ecirc;me machine que le serveur BOOTP
avec une copie de la distribution RedHat montée dessus et le fichier
de configuration de KickStart dans un répertoire <em>/kickstart</em>
exporté par NFS. 
</enum>

<p>Il doit être possible de se passer du serveur BOOTP - cela est
implicite dans la documentation de KickStart. Mais je n'ai pas essayé 
moi-même. De même, il doit être possible de procéder à l'installation
depuis un CD-ROM plutôt que depuis un serveur NFS. Si vous essayez
l'une de ces deux possibilités, faites moi savoir comment vous avez 
procéder pour que je puisse l'indiquer dans ce document.

<p>Notez qu'il n'est pas absolument indispensable que le serveur NFS 
contienne la distribution RedHat et le fichier de configuration
KickStart, cela rend juste les choses un petit peu plus simples
de tout avoir à un seul endroit.


<sect>Préparation d'une disquette d'amorçage

<p>Tout ce que vous avez à faire est de copier le fichier de
configuration de KickStart sur la disquette d'amoçage RedHat sous le 
nom <em>ks.cfg</em>:

<tscreen><verb>
  mcopy ks.cfg a:
</verb></tscreen><p>

<p>La disquette est particulièrement remplie, et vous pourriez avoir 
besoin de détruire certains fichiers pour faire de la place. J'ai
réussi à mettre mon fichier de configuration sur la disquette en
supprimant tous les fichiers de messages qu'affiche normalement
<tt>SYSLINUX</tt>: 

<tscreen><verb>
  mdel a:\*.msg
</verb></tscreen>

<p>Vous pouvez également éditer le fichier de configuration de
<tt>SYSLINUX</tt>: <em>syslinux.cfg</em>. Il est situé à la racine de
la disquette d'amorçage. Le fichier <em>syslinux.cfg</em> suivant
permet de passer immédiatement en mode KickStart lorsque la machine
démarre: 

<tscreen><verb>
  default ks
  prompt 0
  label ks
    kernel vmlinuz
    append ks=floppy initrd=initrd.img
</verb></tscreen>


<sect>Configuration de BOOTP/DHCP et NFS

<p>Si vous vous demandez ce que peuvent bien être ces BOOTP et DHCP,
une description détaillée est disponible sur le <url name="site
DHCP" url="http://www.dhcp.org/">. NFS est documenté en détail
dans le NFS HOWTO.  

Dans la configuration NFS + BOOTP/DHCP que nous considérons, le
fichier de configuration de KickStart doit &ecirc;tre montable par NFS 
par la machine que l'on installe à partir de
<em>/kickstart/IPADDR-kickstart</em> sur le serveur BOOTP/DHCP, où
<em>IPADDR</em> est l'adresse IP de la nouvelle machine. Par exemple 
<em>/kickstart/198.168.254.254-kickstart</em> pour la machine
<em>198.168.254.254</em>.

En théorie, il doit &ecirc;tre possible de modifier cet emplacement en 
renvoyant le paramètre <tt>bf</tt> (<em>boot file</em>) dans la
réponse du serveur BOOTP/DHCP. Il doit m&ecirc;me &ecirc;tre possible
d'avoir ces fichiers montés par NFS à partir d'une autre machine.

Pour exporter par NFS certains répertoires à partir d'une machine
Linux existante, créez le fichier <em>/etc/exports</em> avec un
contenu ressemblant à:

<tscreen><verb>
/kickstart *.swedish-chef.org(ro,no_root_squash)
/mnt/cdrom *.swedish-chef.org(ro,no_root_squash)
</verb></tscreen>

Notez que si vous n'avez pas enregistrer les adresses IP que vous
allez utiliser dans le DNS, le serveur NFS ou le portmapper RPC risque 
de vous rejeter. Vous pouvez probablement vous en sortir en indiquant
les paires adresse IP/masque réseau dans les fichiers de
configuration:

<tscreen><verb>
/kickstart 198.168.254.0/255.255.255.0(ro,no_root_squash)
</verb></tscreen><p>

et dans <em>/etc/hosts.allow</em>:<p>

<tscreen><verb>
ALL: 194.82.103.0/255.255.255.0: ALLOW
</verb></tscreen><p>

Soyez conscient que si vous indiquez le mot de passe de <em>root</em>
dans le fichier de configuration de KickStart ou exportez par NFS des 
répertoires contenant des informations sensibles, vous devrez prendre
soin de rendre ces informations accessibles à aussi peu de personnes
que possible. Cela peut &ecirc;tre fait en restreignant les
permissions des répertoires exportés, par exemple en indiquant un
h&ocirc;te ou un sous-réseau particulier plut&ocirc;t qu'un domaine
entier.

La plupart des serveurs NFS requièrent que vous indiquiez à
<tt/mountd/ et <tt/nfsd/ (sur certaines versions d'Unix, ils sont
précédés du préfixe <tt/rpc./) que le fichier <em>/etc/exports</em> a
été modifié - habituellement en envoyant un <tt>SIGHUP</tt>. Il existe
souvent un programme ou un script appelé <tt>exportfs</tt> qui fera
cela pour vous, par exemple:

<tscreen><verb>
# exportfs -a
</verb></tscreen><p>

Si NFS ne fonctionne pas lorsque votre machine démarre, les répertoires 
pourront ne pas &ecirc;tre exportés automatiquement. Essayez de
redémarrer la machine ou lancer les programmes suivants sous <em>root</em>:

<tscreen><verb>
# portmap
# rpc.nfsd
# rpc.mountd
</verb></tscreen><p>

Comme mentionné précédemment, sur certains système le préfixe
<tt>rpc.</tt> n'est pas utilisé. Dans les distributions Unix les plus
récentes, ces programmes se trouvent dans le répertoire
<em>/usr/sbin</em> qui peut ne pas encore &ecirc;tre dans votre
variable PATH. Le programme <tt>portmap</tt> est parfois appelé
<tt>rpcbind</tt>, sous Solaris par exemple.

Si vous utilisez le serveur BOOTP CMU avec DHCP et les extensions
d'adressage dynamique évoqué plus haut, une entrée du fichier
<em>/etc/bootptab</em> (<em>/etc/bootptab</em> est l'emplacement
normal du fichier de configuration de BOOTP/DHCP) devrait ressembler à
cela: 

<tscreen><verb>
  .dynamic-1:ip=198.168.254.128:T254=0x30:T250="ds=198.168.254.2:
  dn=swedish-chef.org:sm=255.255.255.0:gw=198.168.254.1:
  dl=0xFFFFFFFF":
</verb></tscreen><p>

(passages à la ligne pour plus de clarté)

Cette ligne indique que les nouvelles machines se verront affecter
dynamiquement une adresse commençant à <em>198.168.254.128</em> et
continuant pour les 48 adresses (la valeur héxadécimale <em>30</em>)
suivantes. Chaque client recevra en retour la valeur de
<em>T250</em>. Dans notre exemple, cela donne:

<itemize>
<item> le serveur DNS (<tt>ds</tt>) à <em>198.168.254.2</em>; 
<item> le nom de domaine (<tt>dn</tt>) à <em>swedish-chef.org</em>; 
<item> le masque du sous-réseau  (<tt>sm</tt>) à
<em>255.255.255.0</em>; 
<item> la passerelle par défaut (<tt>gw</tt>) à
<em>198.168.254.1</em>; 
<item> la durée de vie  (<tt>dl</tt>) (combien de temps l'adresse sera 
valide) à &laquo;&nbsp;pour toujours&nbsp;&raquo;.
</itemize><p>

Il semble qu'un grand nombre de versions de ce serveur ne gèrent pas
l'adressage dynamique. Pour celles-ci, vous devrez énumérer les
adresses physiques (typiquement MAC Ethernet) de chacune des machines
à installer dans <em>/etc/booptab</em>. Ces entrées devraient
ressembler à quelque chose comme:

<tscreen><verb>
bork.swedish-chef.org:\
  ip=198.168.254.128:\
  ha=0000E8188E56:\
  ds=198.168.254.2:\
  dn=swedish-chef.org:\
  sm=255.255.255.0:\
  gw=198.168.254.1:\
  dl=0xFFFFFFFF":
</verb></tscreen>

Notez que le paramètre <tt>ha</tt> correspond à l'adresse physique de
la machine à installer.

<sect>Le fichier de configuration de KickStart

<p>Le fichier de configuration se compose de trois sections principales: 

<enum>
<item>informations sur le système, partionnement des disques et
configuration réseau;
<item>paquetages RedHat à installer;
<item>commandes shells à exécuter après l'installation.
</enum>

Il existe d'autres possibilités que nous n'aborderons pas ici mais qui 
<bf>pourraient</bf> marcher. Pour de plus amples informations,
regardez l'exmple de fichier de configuration de KickStart dans
<em>misc/src/install/ks.samp</em> et le fichier <em>doc/README.ks</em>
dans le répertoire <em>i386</em> d'une distribution RedHat sur votre
CD-ROM ou sur un site miroir de RedHat.


<sect1>Information système

<p>Les commandes que j'ai utilisées sont:


<descrip>
<tag/lang/Configuration de la langue, pour l'anglais:
<tscreen><verb>
lang en
</verb></tscreen>
<tag/network/Configuration du réseau, pour utiliser BOOTP/DHCP:
<tscreen><verb>
network --bootp
</verb></tscreen>
<tag/nfs/serveur NFS et répertoire à partir duquel l'installation
doit avoir lieu:
<tscreen><verb>
nfs --server chicken.swedish-chef.org /mnt/cdrom
</verb></tscreen>
pour utiliser le serveur NFS <em>chicken.swedish-chef.org</em> et
essayer de monter la distribution RedHat à partir du répertoire
<em>/mnt/cdrom</em>. 
<tag/keyboard/Sélection du type de clavier, pour un clavier anglais:
<tscreen><verb>
keyboard uk
</verb></tscreen>
<tag/zerombr/Efface le secteur d'amorçage du disque (MBR) - enlève
tous les programmes de lancement pouvant s'y trouver.
<tag/clearpart/Efface les partitions existantes, pour supprimer toutes
les partitions disque avant l'installation:
<tscreen><verb>
clearpart -all
</verb></tscreen>
<tag/part/Partionne le disque, pour créer un système de fichier de 500Mo:
<tscreen><verb>
part / --size 500
</verb></tscreen>
<tag/install/Effectue une nouvelle installation de RedHat.
<tag/mouse/Définit la souris utilisée, pour une souris PS/2 ou compatible:
<tscreen><verb>
mouse ps/2
</verb></tscreen>
<tag/timezone/Définit le fuseau horaire, pour l'heure anglaise:
<tscreen><verb>
timezone --utc Europe/London
</verb></tscreen>
<tag/rootpw/Définit le mot de passe initial de <em>root</em>, basé sur
un mot de passe déjà crypté:
<tscreen><verb>
rootpw --iscrypted XaacoeGPmf/A.
</verb></tscreen>
<tag/lilo/Installe le programme LILO, pour l'installer dans le secteur 
d'amorçage du disque (MBR):
<tscreen><verb>
lilo --location mbr
</verb></tscreen>
<tag/%packages/Paquetages à installer - voir ci-après.
<tag/%post/Commandes shells à lancer après l'installation - voir ci-après.
</descrip>

Notez que le répertoire dans lequel KickStart va chercher la
distribution RedHat doit contenir un sous-répertoire <em>RedHat</em> qui
contient la distribution RedHat pour la plate-forme considérée. Dans
notre exemple, nous devrions avoir quelque chose comme:

<tscreen><verb>
/mnt/cdrom/RedHat
/mnt/cdrom/RedHat/base
/mnt/cdrom/RedHat/contents
/mnt/cdrom/RedHat/i386
/mnt/cdrom/RedHat/instimage
/mnt/cdrom/RedHat/RPMS
/mnt/cdrom/RPM-PGP-KEY
</verb></tscreen><p>

Si vous souhaitez créer vos propres mots de passe cryptés, il vous
suffit d'utiliser Perl:

<tscreen><verb>
% perl -e 'print crypt("schmurrdegurr", "Xa") . "\n";'p
</verb></tscreen><p>

Autres options que je n'ai pas testées:

<descrip>
<tag/cdrom/Installe à partir d'un CD-ROM plut&ocirc; que du réseau.
<tag/device/Déclare explicitement les détails d'un périphérique, par
exemple: 
<tscreen><verb>
device ethernet 3c509 --opts "io=0x330, irq=7"
</verb></tscreen>
D'autres valeurs de <tt>device</tt> sont possibles dont <tt>scsi</tt>
pour les contr&ocirc;leurs SCSI et <tt>cdrom</tt> pour les
gestionnaires de CD-ROM propriétaires. 
<tag/upgrade/Met à jour une installation existante au lieu d'en
installer une nouvelle.
<tag/xconfig/Configure le serveur X-Window, la carte graphique et le
moniteur, par exemple:
<tscreen><verb>
xconfig --server "Mach64" --monitor "tatung cm14uhe"
</verb></tscreen>
</descrip>

Je n'ai pas beaucoup creusé cette dernière option car je ne prévois
pas d'utiliser X sur les machines installées avec KickStart. Si vous
le faites, tenez moi au courant. 

Voici à quoi ressemble maintenant la première partie du fichier de
configuration de KickStart:

<tscreen><verb>
lang en
network --bootp
nfs --server chicken.swedish-chef.org /mnt/cdrom
keyboard uk
zerombr yes
clearpart --all
part / --size 500
part swap --size 120
install
mouse ps/2
timezone --utc Europe/London
rootpw --iscrypted XaacoeGPmf/A.
lilo --location mbr
</verb></tscreen><p>


<sect1>Paquetages à installer

<p>La partie du fichier de configuration de KickStart consacrée aux 
paquetages débute par une ligne avec la directive <tt>%packages</tt>.
Elle est suivie par l'un des deux types de spécifications de
paquetage: des paquetages peuvent &ecirc;tre installés
individuellement en donnant le nom de leur RPM (sans la version ni la
plate-forme), des groupes de paquetages peuvent &ecirc;tre installés
en donnant le nom de leur groupe. 

Voici un exemple de la section des paquetages d'un fichier de
configuration de KickStart:

<tscreen><verb>
%packages
@ Base
netkit-base
bind-utils
ncftp
rdate
tcp_wrappers
traceroute
cmu-snmp
</verb></tscreen><p>

Bien, à quoi correspondent ces groupes? Il y a un grand nombre de
groupes définis par défaut dans un fichier nommé <em>base/comps</em>
dans le répertoire racine de la distribution RedHat. Voici ceux que
l'on pouvait y trouver au moment où j'écris ces lignes:

<itemize>
<item> Base;
<item> Gestionnaire d'imprimante;
<item> Système X-Window;
<item> Outils Mail/WWW/News;
<item> Connexion DOS/Windows;
<item> Gestionnaires de fichiers;
<item> Manipulation graphique;
<item> Jeux sous X-Window;
<item> Jeux en mode console;
<item> Gestionnaires multimédia sous X-Window;
<item> Console Multimedia;
<item> Serveur d'impression;
<item> Station en réseau;
<item> Station en <em>dial-up</em>;
<item> Serveur de news;
<item> Serveur NFS;
<item> Connection SMB (Samba) ;
<item> Connexion IPX/Netware(tm);
<item> Serveur FTP anonyme/Gopher;
<item> Serveur Web;
<item> Serveur de noms DNS;
<item> Serveur Postgres (SQL);
<item> Gestion de réseau;
<item> TeX;
<item> Emacs;
<item> Emacs avec X-Window;
<item> Développement en C;
<item> Bibliothèques de développement;
<item> Développement en C++ ;
<item> Development sous X-Window;
<item> Documentation supplémentaire.
</itemize>

<p>Vous noterez qu'ils correspondent aux différentes configurations qui vous sont proposées lors de l'installation manuelle. Notez également que certains paquetages sont présents dans plusieurs groupes, sans que cela pose de problème lors de l'installation. L'entrée d'un groupe dans la liste <em>comps</em> ressemble à quelque chose comme:

<tscreen><verb>
0 Extra Documentation
sag
lpg
howto
faq
man-pages
end
</verb></tscreen>

<p>Il semble que les groupes dont le nom est précédé d'un <em>1</em>
fasse partie de l'installation par défaut. Il semble donc possible de
pousser un peu plus loin la personnalisation du processus
d'installation en créant ses propres groupes ou en redéfinissant les
groupes existant. Gardez moi au courant si vous essayez de le faire. 

<sect1>Commandes shell après l'installation

<p>C'est probablement la fonctionnalité la plus intéressante et en
tous cas celle qui n'a pas d'équivalent direct dans le processus
d'installation manuel. Ce que nous pouvons faire ici est de définir un
ensemble de commandes de niveau shell qui seront exécutées une fois 
l'installation terminée (partitionnement du disque, installation des
paquetages, etc.) 

<p>Cette section débute par la directive <tt>%post</tt> dans le
fichier de configuration de KickStart.  Vous pouvez ensuite utiliser
tous les utilitaires qui viennent d'&ecirc;tre installés sur votre
nouvelle machine Linux, par exemple:

<tscreen><verb>
%post
ln -s /etc/rc.d/init.d /etc/init.d
ln -s /etc/rc.d/rc.local /etc/rc.local
ln -s /usr/bin/md5sum /usr/bin/md5
ln -s /usr/bin/perl /usr/local/bin/perl
chmod ug-s /bin/linuxconf
mkdir /var/tmp/tmp
perl -spi -e 's!image=/boot/vmlinuz-.*!image=/boot/vmlinuz!' /etc/lilo.conf
rm /etc/rc.d/rc*.d/*sendmail
</verb></tscreen>

<p>Vous pouvez également rediriger les flux standards:

<tscreen><verb>
cat <<EOF >>/etc/passwd
squid:*:102:3500:Squid Proxy:/usr/squid:/bin/bash
EOF

cat <<EOF >>/etc/group
cache:x:3500:
EOF
</verb></tscreen><p>

Modifier les scripts de lancement:

<tscreen><verb>
cat <<EOF >>/etc/rc.local
echo 8192 > /proc/sys/kernel/file-max
echo 32768 > /proc/sys/kernel/inode-max 

[ -x /usr/sbin/sshd ] && /usr/sbin/sshd
[ -x /usr/sbin/cfd ] && /usr/sbin/cfd

EOF
</verb></tscreen><p>

Définir les entrée de <em>crontab</em>:

<tscreen><verb>
cat <<EOF >/tmp/crontab.root
# Keep the time up to date
0,15,30,45 * * * * /usr/sbin/ntpdate -s eggtimer 2>&1 >/dev/null
# Recycle Exim log files
1 0 * * * /usr/exim/bin/exicyclog
# Flush the Exim queue
0,15,30,45 * * * * /usr/exim/bin/exim -q
EOF

crontab /tmp/crontab.root
rm /tmp/crontab.root
</verb></tscreen><p>

Et m&ecirc;me installer d'autres RPM que vous avez créés:

<tscreen><verb>
rpm -i ftp://chicken.swedish-chef.org/rpms/squid.rpm
rpm -i ftp://chicken.swedish-chef.org/rpms/ssh.rpm
rpm -i ftp://chicken.swedish-chef.org/rpms/exim.rpm
rpm -i ftp://chicken.swedish-chef.org/rpms/cfengine.rpm
rpm -i ftp://chicken.swedish-chef.org/rpms/linux.rpm

ssh-keygen -b 1024 -f /etc/ssh_host_key -N ""
depmod -a
</verb></tscreen><p>

<sect>L'installation 

<p>Démarrer la machine à installer à partir de la disquette d'amorçage
RedHat comme d'habitude, mais au lieu de presser
<tt>ENTR&Eacute;E</tt> à l'invite du programme <tt>SYSLINUX</tt>,
tapez <tt>linux ks</tt>.

<p>Si vous avez de la chance, c'est tout ce que vous aurez à faire!

<p>Si vous avez modifié la disquette d'amorçage comme mentionné
plus haut, vous n'avez m&ecirc;me pas besoin de vous préoccuper de ce
qui suit :-)

<p>Comme nous ne faisons qu'automatiser les différentes étapes du
processus d'installation RedHat, une bo&icirc;te de dialogue peut
appara&icirc;tre au cas où KickStart n'arrive pas à déterminer ce
qu'il doit faire. Le cas le plus probable est qu'il ne détecte pas
automatiquement votre carte réseau, il vous demandera alors de lui
fournir son IRQ et son adresse mémoire d'entrée/sortie.

<sect>Montage des disquettes d'amorçage et supplémentaire

<p>La disquette d'amorçage RedHat <tt>boot.img</tt> est au format
MS-DOS et utilise le programme <tt>SYSLINUX</tt> pour se lancer. La
disquette supplémentaire <tt>supp.img</tt> est au format Linux
ext2. Si votre noyau intègre la gestion des périphériques 
<em>loopback</em>, vous pouvez monter ces deux fichiers dans votre
système de fichiers:

<tscreen><verb>
# mkdir -p /mnt/boot /mnt/supp
# mount -o loop -t msdos boot.img /mnt/boot
# mount -o loop supp.img /mnt/supp
</verb></tscreen>

<p>Vous devriez maintenant &ecirc;tre capable de voir et de manipuler
les fichiers des disquettes d'amorçage et supplémentaire
respectivement sous <em>/mnt/boot</em> et <em>/mnt/supp</em>. Ouf!
Notez que d'anciennes versions de <tt>mount</tt> peuvent ne pas
&ecirc;tre capables de gérer l'option <tt>-o loop</tt>. Dans ce cas,
vous devrez utiliser <tt>losetup</tt> pour configurer le périphérique
<em>loopback</em> pour chacun des fichiers:

<tscreen><verb>
# losetup /dev/loop0 boot.img
# mount -t msdos /dev/loop0 /mnt/boot
</verb></tscreen><p>

<p>Vous aurez peut-&ecirc;tre également besoin d'utiliser
explicitement l'option <tt>-t ext2</tt> lorsque vous monterez la
disquette supplémentaire. Cependant, les personnes ayant une
distribution Linux récente ne devraient pas avoir à se soucier de
cela.

<p>Bien s&ucirc;r, si vous ne voulez pas prendre de risque
<!-- ATT -->, vous pouvez utiliser les véritables disquettes
plut&ocirc;t que leurs images. Si votre temps est précieux, vous
préférerez probablement utiliser les périphériques <em>loopback</em>
car vous pourrez alors utiliser des images des disquettes plut&ocirc;t
que de supporter les temps d'attente liés à la lecture de véritables
disquettes. 


<sect>Modifier l'installateur RedHat

<p>Si vous voulez modifier la procédure d'installation
elle-m&ecirc;me, son code source se trouve sur le CD-ROM RedHat ou sur
le site miroir RedHat le plus proche dans le répertoire
<em>misc/src/install</em> à partir du répertoire racine
<em>i386</em>. 

<p>Si vous examinez la disquette d'amorçage RedHat, vous verrez qu'en 
plus du noyau <em>vmlinuz</em>, il y a un gros fichier
<em>initrd.img</em>: 

<tscreen><verb>
-rwxr-xr-x   1 root     root          559 May 11 15:48 boot.msg
-rwxr-xr-x   1 root     root          668 May 11 15:48 expert.msg
-rwxr-xr-x   1 root     root          986 May 11 15:48 general.msg
-rwxr-xr-x   1 root     root       968842 May 11 15:48 initrd.img
-rwxr-xr-x   1 root     root         1120 May 11 15:48 kickit.msg
-r-xr-xr-x   1 root     root         5352 May 11 15:48 ldlinux.sys
-rwxr-xr-x   1 root     root          875 May 11 15:48 param.msg
-rwxr-xr-x   1 root     root         1239 May 11 15:48 rescue.msg
-rwxr-xr-x   1 root     root          402 May 11 15:48 syslinux.cfg
-rwxr-xr-x   1 root     root       444602 May 11 15:48 vmlinuz
</verb></tscreen>

<p>Vous l'aurez deviné, il s'agit d'un autre sytème de fichiers au
format ext2 enregistré comme un fichier - mais avec un truc en
plus. Il est compressé! Vous pouvez le décompresser et le monter: 

<tscreen><verb>
# gzip -dc /mnt/boot/initrd.img >/tmp/initrd.ext2
# mkdir /mnt/initrd
# mount -o loop /tmp/initrd.ext2 /mnt/initrd
</verb></tscreen><p>

<p>La partie probablement la plus importante de ce système de fichiers 
est sa collection de modules chargeables par le noyau qui sont sur la
disquette d'amorçage. Si vous souhaitez intégrer la nouvelle version
d'un gestionnaire, vous devrez soit remplacer <em>vmlinuz</em> par un
nouveau noyau dans lequel ce gestionnaire sera lié statiquement, soit
remplacer ce gestionnaire dans la collection de modules. Que dire
d'autre sinon que vous pouvez supprimer certains modules pour faire de 
la place sur la disquette!

La collection de modules est le fichier <em>modules/modules.cgz</em>.
Devinez-vous de quoi il s'agit? Et bien croyez le ou non, c'est une
archive <tt>cpio</tt> compressée! Voici comment l'utiliser:

<tscreen><verb>
# gzip -dc /mnt/initrd/modules/modules.cgz >/tmp/modules.cpio
# cpio -itv <modules.cpio >modules.listing
# mkdir modules
# cpio -idumv <../modules.cpio
</verb></tscreen><p>

<p>Je ne crois pas qu'il existe actuellement sous Linux une façon
d'accéder de manière transparente aux systèmes de fichiers compressés 
(en tous cas avec les distributions les plus courantes). Faites le moi
savoir si vous avez des informations là-dessus! 

<p>Si vous modifier quelque chose, rappelez vous:

<enum>
<item>utilisez <tt>cpio</tt> pour recréer l'archive. La façon de
procéder est laissée en exercice au lecteur ...
<item>utilisez <tt>gzip</tt> pour compresser cette archive;
<item>copiez la dans <em>/mnt/initrd</em>, ou dans tout autre endroit
où vous avez placé l'archive <em>initrd.img</em> décompressée;
<item>démontez <em>/mnt/initrd</em> (ou comme vous l'avez appelé);
<item>compressez le nouvel <em>initrd.img</em> avec <tt>gzip</tt>;
<item>copiez l'archive sur la disquette d'amorçage:
<em>/mnt/boot/initrd.img</em> dans notre exemple; 
<item>démonter la disquette d'amorçage: <em>/mnt/boot</em>.  
</enum>

<p>Vous pouvez maintenant créer de nouvelles disquettes d'amorçage
avec:

<tscreen><verb>
# cat boot.img >/dev/fd0
</verb></tscreen><p>


<sect>Créer vos propres RPM

<p>Le format des paquetages RPM est déjà abondamment documenté,
notamment dans le livre <em>Maximum RPM</em> d'Ed Bailey que vous
pouvez télécharger depuis le <url name="site RPM"
url="http://www.rpm.org/"> ou trouver dans toutes les
bonnes librairies! Cette section présente quelques trucs pour les gens
pressés. 
 
<p>Les paquetages RPM sont construits à partir d'un fichier de
spécification. Il consiste (de la m&ecirc;me manière que le fichier de 
configuration de KickStart) d'un ensemble d'étapes à accomplir pour
construire le paquetage - on suppose que vous avez à le construire à
partir des sources, potentiellement pour plusieurs plates-formes, et
avez besoin d'y appliquer des corrections avant la compilation. Une
fois construit et installé, un fichier RPM sera créé à partir des
fichiers et des répertoires que vous avez spécifiés comme étant
associés au paquetage. Il est important de noter que RPM n'a aucune
idée des fichiers et répertoires liés à un paquetage donné - vous
devez le lui dire.

<p>Voici un exemple de spécification pour une version personnalisée du
<url name="du serveur Cache WWW  Squid"
url="http://squid.nlanr.net/">: 

<tscreen><verb>
Summary: Squid Web Cache server
Name: squid
Version: 1.NOVM.22
Release: 1
Copyright: GPL/Harvest
Group: Networking/Daemons
Source: squid-1.NOVM.22-src.tar.gz
Patch: retry-1.NOVM.20.patch
%description
Juste une première tentative d'empaquetage d'un serveur Squid pour
l'installer facilement sur notre serveur RedHat Linux

%prep
%setup
%build
configure --prefix=/usr/squid
perl -spi -e 's!#( -DALLOW_HOSTNAME_UNDERSCORES)!$1!' src/Makefile
make

%install
make install

%files
/usr/squid
</verb></tscreen><p>

<p>Voici comment construire ce RPM:

<tscreen><verb>
% mkdir -p SOURCES BUILD SRPMS RPMS/i386
% cp ~/squid-1.NOVM.22-src.tar.gz SOURCES
% cp ~/retry-1.NOVM.20.patch SOURCES
% rpm -ba squid-1.NOVM.22+retry-1.spec
</verb></tscreen><p>

<p>Cela va créer automatiquement un sous-répertoire dans le répertoire 
<em>BUILD</em> dans lequel il va déballer le code source et lui
appliquer les corrections (de nombreuses options concernant les
corrections sont disponibles, voir le livre pour plus de détails). RPM 
va maintenant automatiquement construire le paquetage en lançant
<tt>configure</tt> suivi de <tt>make</tt>, l'installer avec <tt>make
install</tt> et prendre une ``photo'' des fichiers situés dans
<em>/usr/squid</em>. C'est cette dernière qui va constituer le binaire 
RPM du logiciel Squid.

<p>Notez que l'on peut insérer des commandes shell au cours des phases 
de décompression, construction et d'installation, par exemple des
appels en <tt>perl</tt> pour modifier des paramètres de compilation.

<p>Le fichier RPM final sera placé dans le répertoire <em>RPMS</em>
dans le sous-répertoire de la plate-forme correspondante
<em>i386</em>. Dans notre exemple, il s'appelera
<em>squid-1.NOVM.22-1.i386.rpm</em>. Notez que le nom du fichier est
créé en collant les valeurs de certains des paramètres du fichier de
spécification: <tt>Name</tt>, <tt>Version</tt> et <tt>Release</tt>
suivi de la plate-forme, <em>i386</em> dans ce cas. Gardez cela en
mémoire lorsque vous créerez des RPM afin d'éviter de leur donner des
noms exagérément longs.

Il est également intéressant de savoir que l'on peut contruire des RPM 
sans avoir à reconstruire tout le paquetage, par exemple:

<tscreen><verb>
Summary: Linux 2.0.35 kernel + filehandle patch + serial console patch
Name: linux
Version: 2.0.35+filehandle+serial_console
Release: 1
Copyright: GPL
Group: Base/Kernel
Source: linux-2.0.35+filehandle+serial_console.tar.gz
%description
C'est juste une première tentative de créer un paquetage du noyau
Linux avec ses corrections pour l'installation de notre serveur RedHat 
Linux.

%prep
echo

%setup
echo

%build
echo

%install
echo

%post
/sbin/lilo

%files
/lib/modules/2.0.35
/boot/vmlinuz
</verb></tscreen><p>

<p>Dans ce cas, nous créons simplement un RPM composé du fichier
<em>/boot/vmlinuz</em> et du contenu du répertoire
<em>/lib/modules/2.0.35</em>, et exécutons <em>/sbin/lilo</em> après
que le paquetage a été installé sur une nouvelle machine.
Si vous connaissez une meilleure façon d'écrire le fichier de
spécification, faites le moi savoir.


<sect>FAQ/Liste de voeux

<p><bf/Q:/ Peut-on appliquer automatiquement toutes les corrections de
RPM? Et comment? 

<p><bf/R1:/Copiez les RPMs que vous voulez installer dans le répertoire RPMS
 à partir duquel l'installation aura lieu, supprimez les anciens RPMs
et mettez à jour le fichier <em>/RedHat/base/hdlist</em> avec le
détail des nouveaux RPMs. Voir ci-dessous un script d'Eric Doutreleau
qui fait cela pour vous. Si vous le faites vous-même, souvenez-vous de
lancer <em>genhdlist</em> après! 

<p><bf>R2:</bf>Essayer ce script Perl: <url name="patchup"
url="http://wwwcache.ja.net/dev/patchup/">. Il compare les
RPMs que votre système a installé avec ceux présents dans un
répertoire donné et fournit une liste de  ceux qu'il pense vous
devriez mettre à jour. Il peut même les installer pour vous si vous
lui faites confiance. 

<p><bf>R3:</bf><htmlurl name="rpm2hml"
url="http://rufus.w3.org/linux/rpm2html/"> est une version
bien plus puissante (12Mo de C contre une page de Perl!) de R2.  

<p><bf>Q:</bf> Un unique fichier de configuration sur le serveur
d'installation pour tous les clients, peut-être une solution de repli
après avoir essayé <em>IPADDR-kickstart</em>?  

<bf/R:/ ?

<p><bf>Q:</bf>Plus de souplesse lorsque les chose vont mal - par
exemple demander un chemin alternatif si la distribution ne se trouve
pas sur le CD-ROM. 

<bf/R:/ ?

<p><bf>Q:</bf> Exclusion explicite de paquetages - par exemple touts
sauf <em>sendmail</em>.

<bf/R:/ ?

<p><bf>Q:</bf>Choisir quels services sont lancés automatiquement au
démarrage par les scripts dans <em>/etc/rc.d/</em>.

<p><bf>R:</bf> L'utilitaire <em>chkconfig</em> vous permet de
configurer les services qui doivent être lancés au démarrage. Vous
pouvez l'utiliser parmi les scripts lancés après l'installation par
exemple pour lancer <em>ypbind</em> dans les <em>runlevel</em> 3, 4 et
5: 

<tscreen><verb>
chkconfig --level 345 ypbind on
</verb></tscreen><p>

et il va lancer ypbind sur le niveau 345.

<bf/Q:/ Quand les commandes shell de la section <tt>%post</tt>
s'exécutent, envoyer leur sortie vers une autre console plut&ocirc;
que d'écrire sur l'écran principal. <em>Cela peut-il &ecirc;tre fait
dans la section des commandes shell en utilisant <tt>open</tt>?</em>. 

<bf/R:/ Pas de problème! Il suffit de faire quelque chose comme:

<tscreen><verb>
  exec >/dev/tty5
</verb></tscreen><p>

<bf/Q:/ Le code de création de système de fichiers vérifie-t-il
existence de blocs défectueux?

<bf/R:/ Si vous passez sur la console sur laquelle les sorties de la
création du système de fichiers sont affichées, vous ne verrez aucune
mention indiquant que le test `read-only' a été effectué.

<sect>Crédits

<p>Remerciements à Eric Doutreleau pour ses informations sur
<em>chkconfig</em>, l'adaptation du fichier de configuration de
<tt>SYSLINUX</tt> et pour son script Perl d'actualisation des RPM.

<sect>Annexe

<p>Voici le script d'Eric pour ajouter les RPM actualisés dans les
répertoires de la distribution RedHat:



<tscreen><verb>
#!/usr/bin/perl
# 
$redhatdir="/cdrom/i386"; 
$rpmdir="/cdrom/i386/RedHat/RPMS/"; 
$updatedir="/cdrom/updates/"; 
@OTHERDIR=($updatedir); 
foreach $dir (@OTHERDIR) 
  { 
    print "update for $dir\n"; 
    system(" find $dir -name \"*.rpm\" -exec cp {} $rpmdir \\; "); 
  } 
chdir($contribdir) || die "peux pas aller dans $contribdir $!\n"; 
system("chmod -R 755 $redhatdir"); 
chdir($rpmdir) || die "problem to go in $rpmdir $!\n"; 
# 
# remove the old file  
# 
opendir(DIR,'.'); 
@package=grep(/\.rpm$/,readdir(DIR)); 
foreach $file (@package) 
  { 
    $file =~ /(.*)\-([\d+|\.]+\w*)\-(\d+)\.[i386|noarch].*/; 
    $nom=$1; 
    $version=$2; 
    $buildvers=$3;
    if ($NOM{$nom})
      {
	$version2=$VERSION{$nom};
	$buildver2=$BUILDVERS{$nom};
	$file2=$FILE{$nom};
	$nom2=$NOM{$nom};
	if ( $version2 gt $version )
	  {
	    print "$file2 is newer than $file\n";
	    unlink($file);
	  }
	else 
	  {
	    if ( $version2 lt $version )
	      {
		print "$file is newer than $file2\n";
		unlink($file2);
		$VERSION{$nom}=$version;
		$BUILDVERS{$nom}=$buildvers;
		$FILE{$nom}=$file;
		$NOM{$nom}=$nom;
	      }
	    else
	      {
		# print "$file2 $file same version version\n";
		if ( $buildver2 > $buildvers )
		  {
		    print "$file2 : $buildver2 est mieux que $file : $buildvers\n";
		    unlink($file);
		  }
		else
		  {
		    print "$file2 : $buildver2 is older than $file : $buildvers\n";
		    unlink($file2);
		    $VERSION{$nom}=$version;
		    $BUILDVERS{$nom}=$buildvers;
		    $FILE{$nom}=$file;
		    $NOM{$nom}=$nom;
		  }
	      }
	  }
      }
    else
      {
	$VERSION{$nom}=$version;
	$BUILDVERS{$nom}=$buildvers;
	$FILE{$nom}=$file;
	$NOM{$nom}=$nom;
      }
  }

# we do the hard thing here 
# 
system("$redhatdir/misc/src/install/genhdlist $redhatdir"); 
</verb></tscreen>

</article>

