<HTML
><HEAD
>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-2">
<TITLE
>C++ dlopen mini-HOGYAN</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.76b+
"/></HEAD
><BODY
CLASS="article"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="title"
><A
NAME="AEN2"/>C++ dlopen mini-HOGYAN</H1
><H3
CLASS="author"
><A
NAME="AEN4"
>Aaron Isotton</A
></H3
><DIV
CLASS="affiliation"
><DIV
CLASS="address"
><P
CLASS="address"
>aaron@isotton.com</P
></DIV
></DIV
><P
CLASS="pubdate"
>2003.08.12<BR/></P
><DIV
CLASS="revhistory"
><TABLE
WIDTH="100%"
BORDER="0"
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
COLSPAN="3"
><B
>Verziótörténet</B
></TH
></TR
><TR
><TD
ALIGN="LEFT"
>Verzió: 1.03</TD
><TD
ALIGN="LEFT"
>2003.08.12</TD
><TD
ALIGN="LEFT"
>Átdolgozta: AI</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Referencia hozzáadása a GLib dinamikus modul betöltõjérõl.
	Köszönet érte G. V. Sriraam-nak.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Verzió: 1.02</TD
><TD
ALIGN="LEFT"
>2002.12.08</TD
><TD
ALIGN="LEFT"
>Átdolgozta: AI</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>GYIK hozzáadása. Kisebb változtatások.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Verzió: 1.01</TD
><TD
ALIGN="LEFT"
>2002.06.30</TD
><TD
ALIGN="LEFT"
>Átdolgozta: AI</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Frissített magyarázat a virtuális dekonstuktorokról. 
		   Kisebb változtatások.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Verzió: 1.00</TD
><TD
ALIGN="LEFT"
>2002.06.19</TD
><TD
ALIGN="LEFT"
>Átdolgozta: AI</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>A &#8222;Szerzõi jog és licenc&#8221; fejezet az elejére 
	került. &#8222;A dokumentumban használt kifejezések&#8221; fejezet hozzáadása. Kisebb változtatások.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Verzió: 0.97</TD
><TD
ALIGN="LEFT"
>2002.06.19</TD
><TD
ALIGN="LEFT"
>Átdolgozta: JYG</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Egy kis szótár, valamint mondat-szintû változtatások.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Verzió: 0.96</TD
><TD
ALIGN="LEFT"
>2002.06.12</TD
><TD
ALIGN="LEFT"
>Átdolgozta: AI</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Irodalomjegyzék hozzáadása. Az extern
	függvények és változók leírásának javítása.</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Verzió: 0.95</TD
><TD
ALIGN="LEFT"
>2002.06.11</TD
><TD
ALIGN="LEFT"
>Átdolgozta: AI</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Kisebb javítások.</TD
></TR
></TABLE
></DIV
><DIV
><DIV
CLASS="abstract"
><A
NAME="AEN47"/><P
></P
><P
>C++ függvények és osztályok betöltése 
      a <TT
CLASS="function"
>dlopen</TT
> API segítségével.</P
><P
></P
></DIV
></DIV
><HR/></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Tartalomjegyzék</B
></DT
><DT
>1. <A
HREF="#intro"
>Bevezetõ</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#copyright"
>Szerzõi jog és licenc</A
></DT
><DT
>1.2. <A
HREF="#disclaimer"
>A felelõsség teljes elhárítása</A
></DT
><DT
>1.3. <A
HREF="#credits"
>Közremûködõk</A
></DT
><DT
>1.4. <A
HREF="#feedback"
>Visszajelzés</A
></DT
><DT
>1.5. <A
HREF="#AEN85"
>A dokumentumban használt kifejezések</A
></DT
><DT
>1.6. <A
HREF="#AEN106"
>Magyar fordítás</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#theproblem"
>A probléma</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#mangling"
>&#8222;Név szétszedése&#8221;</A
></DT
><DT
>2.2. <A
HREF="#AEN137"
>Osztályok</A
></DT
></DL
></DD
><DT
>3. <A
HREF="#thesolution"
>A megoldás</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#externC"
><TT
CLASS="literal"
>extern "C"</TT
></A
></DT
><DT
>3.2. <A
HREF="#loadingfunctions"
>Függvények betöltése</A
></DT
><DT
>3.3. <A
HREF="#loadingclasses"
>Osztályok betöltése</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#faq"
>Gyakran Ismételt Kérdések</A
></DT
><DT
>5. <A
HREF="#seealso"
>További információ</A
></DT
><DT
><A
HREF="#AEN304"
>Irodalomjegyzék</A
></DT
></DL
></DIV
><DIV
CLASS="section"
><H1
CLASS="section"
><A
NAME="intro"/>1. Bevezetõ</H1
><P
>&#13;      UNIX C++ programozókban felmerülõ gyakori kérdés, 
      hogyan töltsenek be dinamikusan C++ függvényeket és osztályokat
       a <TT
CLASS="function"
>dlopen</TT
> használatával.
    </P
><P
>Tény, hogy nem minden esetben egyszerû ez, és némi 
      magyarázatot igényel. Ez van leírva ebben a mini-HOGYANban.
      </P
><P
>Egy átlagos <SPAN
CLASS="systemitem"
>C</SPAN
>
      és <SPAN
CLASS="systemitem"
>C++</SPAN
> programozási nyelv ismeret
      valamint a 
     <TT
CLASS="function"
>dlopen</TT
> API ismerete szükséges ahhoz, hogy 
     megérthesd ezt a dokumentumot.</P
><P
>Ez a HOGYAN elsõdleges a <A
HREF="http://www.isotton.com/howtos/C++-dlopen-mini-HOWTO/"
TARGET="_top"
>http://www.isotton.com/howtos/C++-dlopen-mini-HOWTO/</A
> webhelyen található meg.</P
><DIV
CLASS="section"
><HR/><H2
CLASS="section"
><A
NAME="copyright"/>1.1. Szerzõi jog és licenc</H2
><P
>&#13;        This document, <EM
>C++ dlopen mini HOWTO</EM
>, is
        copyrighted (c) 2002 by <EM
>Aaron Isotton</EM
>.
        A dokumentum a Free Software Foundation által kiadott GNU Free
	Documentation License 1.1-es vagy újabb verziójában foglalt
	feltételek keretein belül másolható, terjeszthetõ és/vagy
	módosítható; invariáns fejezet, elsõ és hátsó
	borítólapszöveg nincsen.
	</P
></DIV
><DIV
CLASS="section"
><HR/><H2
CLASS="section"
><A
NAME="disclaimer"/>1.2. A felelõsség teljes elhárítása</H2
><P
>&#13;         A dokumentum tartalmáért nincs felelõsségvállalás. Az
	 elgondolásokat, példákat és információkat a saját
	 felelõsségedre használd. Elõfordulhatnak hibák és
	 pontatlanságok, amelyek a rendszered sérülését okozhatják.
	 Minden óvatosság ellenére bármily hihetetlen, a szerzõ(k)
	 semmilyen felelõsséget nem vállal(nak).
      </P
><P
>&#13;         Minden szerzõi jog fenntartva az eredeti tulajdonosának,
	 amennyiben másként nincs jelölve. A dokumentumban használt
	 szakkifejezések semmilyen párhuzamot nem képviselnek
	 védjegyekre, szervíz márkákra vonatkozólag. Egyedi alkotások
	 vagy védjegyek nevesítése nem hozzájárulások.
      </P
></DIV
><DIV
CLASS="section"
><HR/><H2
CLASS="section"
><A
NAME="credits"/>1.3. Közremûködõk</H2
><P
>&#13;        Örömmel mondok köszönetet az alábbi személyeknek
	(abc sorrendben):
      </P
><P
></P
><UL
><LI
><P
>Joy Y Goodreau <TT
CLASS="email"
>&lt;<A
HREF="mailto:joyg (at) us.ibm.com"
>joyg (at) us.ibm.com</A
>&gt;</TT
> 
	  a szerkesztésért.</P
></LI
><LI
><P
>D. Stimitis <TT
CLASS="email"
>&lt;<A
HREF="mailto:stimitis (at) idcomm.com"
>stimitis (at) idcomm.com</A
>&gt;</TT
>
            rámutatott néhány kérdésre a formázással és a
	    név szétszedéssel kapcsolatban valamit az 
	    <TT
CLASS="literal"
>extern "C"</TT
>-vel kapcsolatban.
            </P
></LI
></UL
></DIV
><DIV
CLASS="section"
><HR/><H2
CLASS="section"
><A
NAME="feedback"/>1.4. Visszajelzés</H2
><P
>&#13;	Visszajelzést szívesen fogadok.
	A megjegyzéseidet, kritikádat és a hozzájárulásaidat
	a <TT
CLASS="email"
>&lt;<A
HREF="mailto:aaron@isotton.com"
>aaron@isotton.com</A
>&gt;</TT
> címre küldheted.
      </P
></DIV
><DIV
CLASS="section"
><HR/><H2
CLASS="section"
><A
NAME="AEN85"/>1.5. A dokumentumban használt kifejezések</H2
><P
></P
><DIV
CLASS="variablelist"
><DL
><DT
><TT
CLASS="function"
>dlopen</TT
> API</DT
><DD
><P
>A <TT
CLASS="function"
>dlclose</TT
>,
              <TT
CLASS="function"
>dlerror</TT
>,
              <TT
CLASS="function"
>dlopen</TT
> és
              <TT
CLASS="function"
>dlsym</TT
> függvények, amik leírása a
              <TT
CLASS="literal"
>dlopen(3)</TT
> kézikönyv oldalon található.</P
><P
>Megjegyezzük, hogy mi a 
              <SPAN
CLASS="QUOTE"
>"<TT
CLASS="function"
>dlopen</TT
>"</SPAN
> kifejezést a
              <TT
CLASS="function"
>dlopen</TT
> <EM
>függvényre</EM
> 
	      magára, és
	      a <SPAN
CLASS="QUOTE"
>"<TT
CLASS="function"
>dlopen</TT
> API"</SPAN
> kifejezést az
              <EM
>egész API</EM
>-ra használjuk.</P
></DD
></DL
></DIV
></DIV
><DIV
CLASS="section"
><HR/><H2
CLASS="section"
><A
NAME="AEN106"/>1.6. Magyar fordítás</H2
><P
>&#13;    A magyar fordítást <A
HREF="mailto: szferi[kukac]einstein.ki.iif[pont]hu"
TARGET="_top"
>Szalai Ferenc</A
> készítette (2004.04.17).
    A lektorálást <A
HREF="mailto:dacas@freemail.hu_NO_SPAM"
TARGET="_top"
>Daczi László</A
> végezte el (2004.05.04). Utoljára javítva 2004.05.05.-én (r2).
    A dokumentum legfrissebb változata megtalálható a <A
HREF="http://tldp.fsf.hu/index.html"
TARGET="_top"
>Magyar Linux Dokumentációs Projekt</A
> honlapján.
    </P
></DIV
></DIV
><DIV
CLASS="section"
><HR/><H1
CLASS="section"
><A
NAME="theproblem"/>2. A probléma</H1
><P
>Néha futásidõben kellene betölteni programkönyvtárakat (és 
      használni a függvényeiket). Ez leginkább akkor szükséges,
      ha valamilyen plug-in vagy modul architektúrájú programot írsz.
      </P
><P
>A C nyelvben a program könyvtárak betöltése igen egyszerû 
       (<TT
CLASS="function"
>dlopen</TT
>, <TT
CLASS="function"
>dlsym</TT
> és
      <TT
CLASS="function"
>dlclose</TT
> meghívása elegendõ). C++-al ez egy
      kicsit bonyolultabb.
      A C++ program könyvtárak betöltésének nehézséget részint a
      <A
HREF="#mangling"
>&#8222;nevek szétszedése&#8221;</A
>,
      részben pedig az a tény okozza, hogy a <TT
CLASS="function"
>dlopen</TT
> 
      API C-ben lett írva, így nem teszi lehetõvé osztályok egyszerû 
      betöltését.</P
><P
>Mielõtt bemutatnánk a programkönyvtárak betöltését,
    C++-ban megvizsgáljuk a &#8222;név szétszedési&#8221; problémát egy kicsit
    alaposabban. Azt ajánlom akkor is olvasd el ezt a részt,
    ha nem érdekel, mert segít megérteni mi is a probléma
    és mi a megoldása.</P
><DIV
CLASS="section"
><HR/><H2
CLASS="section"
><A
NAME="mangling"/>2.1. &#8222;Név szétszedése&#8221;</H2
><P
>Minden C++ programban (vagy programkönyvtárban vagy
      tárgykód állományban) minden nem statikus függvény
      a bináris állományban <EM
>szimbólumokkal</EM
> van 
      reprezentálva. Ezek a szimbólumok speciális karaktersorozatok,
      amik egyértelmûen azonosítják a függvényt a programban,
      programkönyvtárban vagy tárgykód állományban.</P
><P
>C-ben a szimbólum nevek megegyeznek a függvények
      neveivel: az <TT
CLASS="function"
>strcpy</TT
> függvény szimbóluma
      <TT
CLASS="computeroutput"
>strcpy</TT
> és így tovább.
      Ez azért lehetséges, mert C-ben két nem statikus függvénynek
      nem lehet azonos a neve.</P
><P
>Mivel a C++ engedélyezi az átdefiniálást (overloading -
      különbözõ függvények azonos névvel, de különbözõ argumentumokkal),
      valamint számos új tulajdonsága van, ami a C-nek nincs &#8212; 
      mint osztályok, tagfüggvények, kivétel kezelés &#8212; 
      ezért nem lehetséges a függvények nevét egyszerûen szimbólumnévnek
      használni. A C++ ezt az problémát az úgynevezett 
      <EM
>&#8222;név szétszedéssel&#8221;</EM
> (mangling) oldja meg. 
      Ez úgy mûködik, hogy a a függvények és egyéb szükséges 
      információk (mint az argumentumok száma és mérete) alapján létrehoz 
      egy csak a fordító számára értelmes karaktersorozatot, amit az szimbólum
      névnek tud használni.
      A <TT
CLASS="function"
>foo</TT
> 
      függvény ilyen módon elõállított neve így nézhet ki például:
      <TT
CLASS="computeroutput"
>foo@4%6^</TT
>.  Vagy nem is
      feltétlen kell tartalmaznia a <SPAN
CLASS="QUOTE"
>"foo"</SPAN
> szót magát.</P
><P
> Az egyik probléma ezzel az eljárással az, hogy a
      C++ standard (jelenleg [<SPAN
CLASS="citation"
>ISO14882</SPAN
>])
      nem definiálja ennek a menetét. Így minden
      fordító a saját módszerét használja. Néhány fordító
      meg is változtatja az algoritmust verzióról verzióra 
      (különösen a g++ 2.x és 3.x között).
      Ezért ha ki is találtad, hogy a te fordítód hogyan 
      is mûködik e tekintetben (és így be fogod tudni tölteni
      a függvényeidet a <TT
CLASS="function"
>dlsym</TT
> segítségével)
      ez valószínûleg csak a te fordítóddal fog mûködni és
      használhatatlan lesz annak következõ verziójával.</P
></DIV
><DIV
CLASS="section"
><HR/><H2
CLASS="section"
><A
NAME="AEN137"/>2.2. Osztályok</H2
><P
>A másik probléma a <TT
CLASS="function"
>dlopen</TT
> API-val,
      az, hogy csak <EM
>függvények</EM
> betöltését
      támogatja. Általában azonban egy C++ programkönyvtárban
      egy osztályt publikálsz, amit a programodban használni szeretnél. 
      Ezen osztály használatához egy példányt
      kell belõle készítened, de ez nem is olyan könnyû.
      </P
></DIV
></DIV
><DIV
CLASS="section"
><HR/><H1
CLASS="section"
><A
NAME="thesolution"/>3. A megoldás</H1
><DIV
CLASS="section"
><H2
CLASS="section"
><A
NAME="externC"/>3.1. <TT
CLASS="literal"
>extern "C"</TT
></H2
><P
>&#13;      	A C++-nak van egy speciális kulcsszava arra, hogy
	függvényeket C kötéssel definiáljuk. Ez az <TT
CLASS="literal"
>extern "C"</TT
>. 
	Az a függvény ami <TT
CLASS="literal"
>extern "C"</TT
>-ként lett definiálva
	annak függvényneve szimbólumként használható akárcsak egy
	C függvénynek. Ezért csak nem-tagfüggvények deklarálhatók
        <TT
CLASS="literal"
>extern "C"</TT
> segítségével, és ezeket nem lehet
	átdefiniálni.</P
><P
>Habár van néhány megkötés az <TT
CLASS="literal"
>extern
        "C"</TT
> függvényekre, mégis igen hasznosak, mivel dinamikusan
	betölthetõek a <TT
CLASS="function"
>dlopen</TT
> segítségével akárcsak
	a C függvények.</P
><P
>Ez <EM
>nem</EM
> jelenti azt, hogy az 
      <TT
CLASS="literal"
>extern "C"</TT
>-vel definiált függvények nem
      tartalmazhatnak C++ kódot. Az ilyen függvények teljes értékû C++ függvények,
      kihasználhatják a C++ lehetõségeit és bármilyen típusú argumentummal
      rendelkezhetnek.</P
></DIV
><DIV
CLASS="section"
><HR/><H2
CLASS="section"
><A
NAME="loadingfunctions"/>3.2. Függvények betöltése</H2
><P
>C++ a függvények úgy tölthetõek be mint C-ben; a 
        <TT
CLASS="function"
>dlsym</TT
> segítségével. A betölteni kívánt
	függvényeket <TT
CLASS="literal"
>extern "C"</TT
>-vel kell jelölnöd,
	hogy a C-szerû szimbólum névképzést kikényszerítsd.</P
><DIV
CLASS="example"
><A
NAME="AEN162"/><P
><B
>Példa 1. Egy függvény betöltése</B
></P
><P
>main.cpp:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>#include &lt;iostream&gt;
#include &lt;dlfcn.h&gt;


int main() {
    using std::cout;
    using std::cerr;

    cout &lt;&lt; "C++ dlopen demo\n\n";

    // open the library
    cout &lt;&lt; "Opening hello.so...\n";
    void* handle = dlopen("./hello.so", RTLD_LAZY);
    
    if (!handle) {
        cerr &lt;&lt; "Cannot open library: " &lt;&lt; dlerror() &lt;&lt; '\n';
        return 1;
    }
    
    // load the symbol
    cout &lt;&lt; "Loading symbol hello...\n";
    typedef void (*hello_t)();
    hello_t hello = (hello_t) dlsym(handle, "hello");
    if (!hello) {
        cerr &lt;&lt; "Cannot load symbol 'hello': " &lt;&lt; dlerror() &lt;&lt;
            '\n';
        dlclose(handle);
        return 1;
    }
    
    // use it to do the calculation
    cout &lt;&lt; "Calling hello...\n";
    hello();
    
    // close the library
    cout &lt;&lt; "Closing library...\n";
    dlclose(handle);
}
</PRE
></FONT
></TD
></TR
></TABLE
><P
>hello.cpp:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>#include &lt;iostream&gt;

extern "C" void hello() {
    std::cout &lt;&lt; "hello" &lt;&lt; '\n';
}
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><P
>A <TT
CLASS="function"
>hello</TT
> függvény a 
        <TT
CLASS="filename"
>hello.cpp</TT
> állományban van definiálva, mint
	<TT
CLASS="literal"
>extern "C"</TT
>.
	A <TT
CLASS="filename"
>main.cpp</TT
>-ben töltõdik be a 
	<TT
CLASS="function"
>dlsym</TT
>
	hívással. A függvényt <TT
CLASS="literal"
>extern "C"</TT
>-vel kell megjelölni,
	mert különben nem tudjuk biztosan a hozzá tartozó szimbólumnevet.
	</P
><DIV
CLASS="warning"
><P
></P
><TABLE
CLASS="warning"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/warning.gif"
HSPACE="5"
ALT="Figyelem"/></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Két típusa létezik az <TT
CLASS="literal"
>extern "C"</TT
> 
	deklarációnak: <TT
CLASS="literal"
>extern
            "C"</TT
> ahogy fent is használtuk, és <TT
CLASS="literal"
>extern "C" {
            &#8230; }</TT
> a deklaráció kapcsos zárójelek között.
          Az elsõ (inline) forma egy deklaráció ami egyszerre extern
          és C nyelvû kiértékelést ír elõ, míg a második csak a nyelvi elõírást
	  befolyásolja. Az alábbi két deklaráció ekvivalens:
          
          <DIV
CLASS="informalexample"
><A
NAME="AEN180"/><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>extern "C" int foo;
extern "C" void bar();
            </PRE
></FONT
></TD
></TR
></TABLE
><P
></P
></DIV
>
           és
          <DIV
CLASS="informalexample"
><A
NAME="AEN182"/><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>extern "C" {
     extern int foo;
     extern void bar();
 }</PRE
></FONT
></TD
></TR
></TABLE
><P
></P
></DIV
>

	  Ahogy nincs különbség 
          <TT
CLASS="literal"
>extern</TT
> és a
          nem-<TT
CLASS="literal"
>extern</TT
> <EM
>függvény</EM
>
          függvénydeklarációk között sem. 
	  Ez mindaddig nem jelent problémát amíg nem deklarálsz változókat.
	  Ha <EM
>változókat</EM
> deklarálsz tartsd észben, hogy

          <DIV
CLASS="informalexample"
><A
NAME="AEN188"/><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>extern "C" int foo;</PRE
></FONT
></TD
></TR
></TABLE
><P
></P
></DIV
>
            és
          <DIV
CLASS="informalexample"
><A
NAME="AEN190"/><P
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>extern "C" {
    int foo;
}</PRE
></FONT
></TD
></TR
></TABLE
><P
></P
></DIV
>
          
           <EM
>nem</EM
> ugyanaz a dolog.</P
><P
>További részleteket találsz a 
          [<SPAN
CLASS="citation"
>ISO14882</SPAN
>], 7.5 fejezetében, 
          különös tekintettel a 7. bekezdésre
	  vagy a [<SPAN
CLASS="citation"
>STR2000</SPAN
>],
          9.2.4. paragrafusában.</P
><P
>Mielõtt bármi extra dolgot csinálnál az extern változókkal,
	ajánlott elolvasni a &#8222;<A
HREF="#seealso"
>További információ</A
>&#8221; 
	fejezetben felsorolt dokumentumokat.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="section"
><HR/><H2
CLASS="section"
><A
NAME="loadingclasses"/>3.3. Osztályok betöltése</H2
><P
>Az osztályok betöltése egy kicsit komplikáltabb, mert
        nekünk az osztály egy <EM
>példányára</EM
>
	van szükségünk, nem csak egy függvényre mutató mutatóra.
        </P
><P
>Nem tudjuk létrehozni az osztály egy példányát a 
        <TT
CLASS="literal"
>new</TT
> operátor segítségével, mert
	az osztály nincs definiálva a futtatható állományban, és mert
	nem tudjuk a nevét.</P
><P
>A megoldás a polimorfizmus segítségével adódik.
      Egy alap <EM
>interfész</EM
> osztályt definiálunk
      a <EM
>futtatható állományban</EM
> 
      virtuális tagfüggvényekkel, és egy származtatott
        <EM
>implementációs</EM
> osztályt 
	<EM
>a modulban</EM
>. Általában az interfész 
	absztrakt osztály (egy osztály absztrakt, ha minden függvénye
	virtuális).</P
><P
>A dinamikus osztálybetöltést általában plug-in-okban  
      használják &#8212; Ezeknek egy világosan definiált interfészt kell
      használniuk &#8212; Egy interfészt és az azt implementáló osztályokat
      kell definiálnunk.</P
><P
>Ezek után - még mindig a modulban - definiálunk két további
      segédfüggvényt (úgynevezett <EM
>class factory 
      functions</EM
>). Az egyik függvény ezek közül
      elkészíti egy példányát az osztálynak, és egy arra irányított mutatót ad vissza.
      Míg a másik egy osztályra irányított mutatót kap (amit a factory készített) és felszabadítja azt. Ezt a két függvényt <TT
CLASS="literal"
>extern
          "C"</TT
> direktívával jelöljük meg.</P
><P
>Ahhoz, hogy osztályt tölts be modulból csak a két factory
      függvényt kell betöltened a <TT
CLASS="function"
>dlsym</TT
>
      segítségével. Szerkeszteni (link) ugyanúgy kell, mint ahogy azt <A
HREF="#loadingfunctions"
>ebben részben tettük a 
	hello függvénnyel</A
>. Ezek után már
	annyi példányt tudsz létrehozni és felszabadítani az osztályból,
	amennyit csak akarsz.</P
><DIV
CLASS="example"
><A
NAME="AEN216"/><P
><B
>Példa 2. Egy osztály betöltése</B
></P
><P
>Itt mi most egy általános <TT
CLASS="classname"
>polygon</TT
>
          osztályt használunk, mint interfész és egy származtatott 
          <TT
CLASS="classname"
>triangle</TT
> osztályt, mint implementációt.</P
><P
>main.cpp:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>#include "polygon.hpp"
#include &lt;iostream&gt;
#include &lt;dlfcn.h&gt;

int main() {
    using std::cout;
    using std::cerr;

    // load the triangle library
    void* triangle = dlopen("./triangle.so", RTLD_LAZY);
    if (!triangle) {
        cerr &lt;&lt; "Cannot load library: " &lt;&lt; dlerror() &lt;&lt; '\n';
        return 1;
    }

    // load the symbols
    create_t* create_triangle = (create_t*) dlsym(triangle, "create");
    destroy_t* destroy_triangle = (destroy_t*) dlsym(triangle, "destroy");
    if (!create_triangle || !destroy_triangle) {
        cerr &lt;&lt; "Cannot load symbols: " &lt;&lt; dlerror() &lt;&lt; '\n';
        return 1;
    }

    // create an instance of the class
    polygon* poly = create_triangle();

    // use the class
    poly-&gt;set_side_length(7);
        cout &lt;&lt; "The area is: " &lt;&lt; poly-&gt;area() &lt;&lt; '\n';

    // destroy the class
    destroy_triangle(poly);

    // unload the triangle library
    dlclose(triangle);
}
</PRE
></FONT
></TD
></TR
></TABLE
><P
>polygon.hpp:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>#ifndef POLYGON_HPP
#define POLYGON_HPP

class polygon {
protected:
    double side_length_;

public:
    polygon()
        : side_length_(0) {}

    void set_side_length(double side_length) {
        side_length_ = side_length;
    }

    virtual double area() const = 0;
};

// the types of the class factories
typedef polygon* create_t();
typedef void destroy_t(polygon*);

#endif
</PRE
></FONT
></TD
></TR
></TABLE
><P
>triangle.cpp:</P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="programlisting"
>#include "polygon.hpp"
#include &lt;cmath&gt;

class triangle : public polygon {
public:
    virtual double area() const {
        return side_length_ * side_length_ * sqrt(3) / 2;
    }
};


// the class factories

extern "C" polygon* create() {
    return new triangle;
}

extern "C" void destroy(polygon* p) {
    delete p;
}
</PRE
></FONT
></TD
></TR
></TABLE
></DIV
><P
>Néhány dolgot meg kell jegyeznünk az osztályok betöltésével
      kapcsolatban:</P
><P
></P
><UL
><LI
><P
>Az osztályt létrehozó és felszabadító függvényeket <EM
>meg kell írnod</EM
>.
	  Soha <EM
>ne</EM
> szabadítsd fel a példányokat a
            <TT
CLASS="literal"
>delete</TT
> operátorral a futtatható állományon
	    belül. Mindig add vissza azokat a modulnak.
	    Ez azért szükséges, mert a <TT
CLASS="literal"
>new</TT
> és a
            <TT
CLASS="literal"
>delete</TT
> C++ operátorok 
	    használata nem feltétlenül konzekvens. Ezért lehetséges, hogy egy pár nélküli
            <TT
CLASS="literal"
>new</TT
> vagy
            <TT
CLASS="literal"
>delete</TT
> hívás az oka a memória-szivárgásnak vagy
            segmentation fault-nak.
	    Ugyanez igaz akkor is, ha különbözõ standard programkönyvtárakat használsz a modulban és futtatható állományban.</P
></LI
><LI
><P
>Az interfész osztály dekonstruktorának virtuálisnak
	  kell lennie szinte minden esetben. <EM
>Lehetséges</EM
>
	  egy meglehetõsen ritka eset, amikor ez nem feltétlen szükséges.
	  Ez a megkötés nem okoz problémát, mert az általa keletkezõ többletterhelés (overhead)
	  elhanyagolható.</P
><P
>Ha az alap osztályodnak nincs szükséges dekonstruktorra
	  akkor is definiálj egy üreset (és <TT
CLASS="literal"
>virtual</TT
>-t),
	  különben elõbb vagy utóbb <EM
>problémáid lesznek</EM
>.
	  Ezt garantálom. Többet tudhatsz meg errõl a problémáról 
          a <A
HREF="http://www.parashift.com/c++-faq-lite/"
TARGET="_top"
>C++ FAQ lite</A
> webhelyen található comp.lang.c++ GYIK 20. fejezetébõl.</P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="section"
><HR/><H1
CLASS="section"
><A
NAME="faq"/>4. Gyakran Ismételt Kérdések</H1
><DIV
CLASS="qandaset"
><DL
><DT
>4.1. <A
HREF="#AEN249"
>Windowst használok és nem találom a 
          <TT
CLASS="filename"
>dlfcn.h</TT
> header állományt a PC-men! 
	  Mi a probléma?</A
></DT
><DT
>4.2. <A
HREF="#AEN265"
>Létezik bármilyen <TT
CLASS="function"
>dlopen</TT
>-kompatibilis
	    illesztõfelület a Windows <TT
CLASS="function"
>LoadLibrary</TT
>
	    API-jához?</A
></DT
></DL
><DIV
CLASS="qandaentry"
><DIV
CLASS="question"
><P
><A
NAME="AEN249"/><B
>4.1. </B
>Windowst használok és nem találom a 
          <TT
CLASS="filename"
>dlfcn.h</TT
> header állományt a PC-men! 
	  Mi a probléma?</P
></DIV
><DIV
CLASS="answer"
><P
><B
> </B
>A probléma, mint mindig a Windows. Nincs 
	  <TT
CLASS="filename"
>dlfcn.h</TT
> header Windows-on és nincs
          <TT
CLASS="function"
>dlopen</TT
> API sem. Van egy hasonló
	  API a <TT
CLASS="function"
>LoadLibrary</TT
> függvénnyel.
	  A legtöbb itt leírt dolog alkalmazható erre is.
	  Továbbá használhatod a libltdl (a libtool része) programkönyvtárat, hogy 
          <SPAN
CLASS="QUOTE"
>"emuláld"</SPAN
> a <TT
CLASS="function"
>dlopen</TT
>-t
	  számos platformon.</P
><P
>Olvasd el a <A
HREF="http://tldp.fsf.hu/HOWTO/Program-Library-HOWTO-hu/index.html"
TARGET="_top"
>Programkönyvtár HOGYAN</A
> (<A
HREF="http://www.dwheeler.com/program-library"
TARGET="_top"
>Program Library HOWTO</A
>) 4. fejezetét (<A
HREF="http://tldp.fsf.hu/HOWTO/Program-Library-HOWTO-hu/dl-libraries.html"
TARGET="_top"
>Dinamikusan betölthetõ (Dynamically Loaded; DL) programkönyvtárak</A
>; <A
HREF="http://www.dwheeler.com/program-library/Program-Library-HOWTO/dl-libraries.html"
TARGET="_top"
>Dynamically Loaded (DL) Libraries</A
>). Ez további információkkal szolgál olyan
	    technikákról, amelyekkel platformfüggetlenül tölthetsz be
	    programkönyvtárakat és készíthetsz osztályokat.</P
></DIV
></DIV
><DIV
CLASS="qandaentry"
><DIV
CLASS="question"
><P
><A
NAME="AEN265"/><B
>4.2. </B
>Létezik bármilyen <TT
CLASS="function"
>dlopen</TT
>-kompatibilis
	    illesztõfelület a Windows <TT
CLASS="function"
>LoadLibrary</TT
>
	    API-jához?</P
></DIV
><DIV
CLASS="answer"
><P
><B
> </B
>Nem tudok róla és nem hiszem, hogy valaha is lesz olyan, ami
	  a <TT
CLASS="function"
>dlopen</TT
> összes lehetõségét támogatni
	  fogja.</P
><P
>Vannak alternatív megoldások: libtltdl (a libtool része),
	    ami a különbözõ dinamikus betöltõ API-khoz nyújt egységes
	    felületet, köztük a <TT
CLASS="function"
>dlopen</TT
> és a 
	    <TT
CLASS="function"
>LoadLibrary</TT
> API-khoz is.  
	    Egy másik lehetõség a <A
HREF="http://developer.gnome.org/doc/API/glib/glib-dynamic-loading-of-modules.html"
TARGET="_top"
>&#13;	      Dynamic Loading of Modules</A
> (A GLib dinamikus modul betöltés).  
	      Használd ezeket a jobb platformfüggetlenség biztosítása érdekében.
	     Én soha nem használtam õket, így nem tudom megmondani neked mennyire
	     stabilak és hogyan mûködnek.</P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="section"
><HR/><H1
CLASS="section"
><A
NAME="seealso"/>5. További információ</H1
><P
></P
><UL
><LI
><P
>A <TT
CLASS="function"
>dlopen(3)</TT
> kézikönyv oldalai. 
	  Ez kifejti a <TT
CLASS="function"
>dlopen</TT
> API célját és a használatát.
          </P
></LI
><LI
><P
>A <A
HREF="http://www.linuxjournal.com/article.php?sid=3687"
TARGET="_top"
>&#13;            <I
CLASS="citetitle"
>Dynamic Class Loading for C++ on
              Linux</I
></A
> cikk James Norton tollából a
          <A
HREF="http://www.linuxjournal.com/"
TARGET="_top"
>Linux
            Journal</A
>-on.</P
></LI
><LI
><P
>A kedvenc C++ referenciád a <TT
CLASS="literal"
>extern
            "C"</TT
>-ról, öröklõdésrõl, virtuális függvényekrõl,
          <TT
CLASS="literal"
>new</TT
> és <TT
CLASS="literal"
>delete</TT
>
	  operátorokról. A [<SPAN
CLASS="citation"
>STR2000</SPAN
>] ajánlott.</P
></LI
><LI
><P
>[<SPAN
CLASS="citation"
>ISO14882</SPAN
>]</P
></LI
><LI
><P
>A <A
HREF="http://tldp.fsf.hu/HOWTO/Program-Library-HOWTO-hu/index.html"
TARGET="_top"
>Programkönyvtár HOGYAN</A
> (<A
HREF="http://www.dwheeler.com/program-library"
TARGET="_top"
>Program Library
            HOWTO</A
>) mintent tartalmaz,
	    amire valaha szükséged lesz statikus, megosztott és dinamikusan
	    betölthetõ programkönyvtárakkal kapcsolatban. Melegen ajánlott.
            </P
></LI
><LI
><P
>A <A
HREF="http://tldp.org/HOWTO/GCC-HOWTO/index.html"
TARGET="_top"
>Linux GCC
            HOWTO</A
>-ból többet tudhatsz meg arról, hogyan készíthetsz
	    programkönyvtárakat GCC-vel.</P
></LI
></UL
></DIV
><A
NAME="AEN304"
></A
><HR/><H1
><A
NAME="AEN304"/>Irodalomjegyzék</H1
><DIV
CLASS="bibliomixed"
><A
NAME="AEN305"
></A
><P
CLASS="bibliomixed"
>&#13;      ISO14482 <I
>ISO/IEC 14482-1998 &#8212; The
        C++ Programming Language</I
>. PDF és nyomtatott
	könyv formájában is elérhetõ a <A
HREF="http://webstore.ansi.org/"
TARGET="_top"
>http://webstore.ansi.org/</A
> webhelyen.
    </P
></DIV
><DIV
CLASS="bibliomixed"
><A
NAME="AEN310"
></A
><P
CLASS="bibliomixed"
>&#13;      STR2000
      <SPAN
CLASS="AUTHOR"
>Bjarne Stroustrup</SPAN
>
      <I
>The C++ Programming Language</I
>, Special
        Edition.
      ISBN 0-201-70073-5.
      Addison-Wesley.
    </P
></DIV
></DIV
></BODY
></HTML
>
