<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="LinuxDoc-Tools 0.9.21">
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-2">

 <TITLE>A bekapcsolástól a bash promptig</TITLE>
</HEAD>
<BODY>
<H1>A bekapcsolástól a bash promptig</H1>

<H2>Greg O'Keefe, <CODE>gcokeefe@postoffice.utas.edu.au</CODE></H2>v0.9, 2000 november
<HR>
<EM>Ez a dokumentum röviden leírja,  hogy mi történik egy Linux rendszerben
a gép bekapcsolásától a bash prompt megjelenéséig. Ezek megértése hasznos lehet, amikor problémákat
kell megoldanod vagy be kell állítanod a rendszert.</EM>
<HR>
<H2><A NAME="s1">1. Bevezetés</A></H2>

<P>Idegesítõnek tartottam, hogy sok olyan dolog történik a Linux gépem belsejében,
amit nem értek. Ha Te is, úgy mint én, szeretnéd igazán megérteni a rendszered
mûködését ahelyett, hogy csak a használatát tanulod meg, ez a dokumentum egy jó
kiindulási pont lehet. Ez a fajta háttérismeret kellhet akkor is, ha elsõrangú
linuxos problémamegoldó szeretnél lenni.</P>
<P>Feltételezem, hogy van egy mûködõ Linux géped, és tudsz néhány alapvetõ dolgot
a Unix-ról és a PC hardverérõl. Ha nem, akkor nagyon jó kiindulási alap a tanuláshoz
az Eric S. Raymond-féle
<A HREF="http://www.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO.html">The Unix and Internet Fundamentals HOWTO</A> (A Unix és az Internet alapjai HOGYAN).
Ez rövid, nagyon olvasmányos doksi és lefedi az alapokat.</P>
<P>A dokumentum fõ irányvonala az, hogy a Linux hogyan indul el. Ezen felül egy 
részletesebb tanulmányi forrás próbál lenni. Minden részhez mellékeltem gyakorlatokat is.
Ha ténylegesen megcsinálsz néhányat közülük, sokkal többet tanulsz, mint csak
az olvasással.</P>
<P>Remélem, néhány olvasó vállalkozik a tudomásom szerinti legjobb,  a Linux megismerését 
segítõ feladatra, ami a rendszer forráskódból való felépítése. Az olasz filozófus, 
Giambattista Vico (1668-1744) szerint "verum ipsum factum", vagyis "a dolgokat 
készítésük közben értjük meg igazán".  Köszönet Alexnek (lásd 
<A HREF="#acknowledge">Köszönetnyilvánítások</A>) 
az idézetért.</P>
<P>Ha el szeretnéd készíteni a saját Linuxodat, elolvashatod még Gerard Beekman 
<A HREF="http://www.linuxfromscratch.org">Linux From Scratch HOWTO</A>-ját (Linux a kezdetektõl HOGYAN, LFS).
Ez részletes útbaigazítást ad egy teljes, használható rendszer forráskódból való
felépítésérõl. A LFS weboldalán levelezõlistát is találsz, ami azoknak szól, akik
ezen a módon építenek fel rendszereket.
Néhány instrukció,  ami régebben része volt ennek a dokumentumnak, most már egy
másik leírásban található meg, címe "Minimális Linux rendszer építése forráskódból",
és itt található meg:
<A HREF="http://www.netspace.net.au/~gok/power2bash/">From PowerUp to Bash Prompt honlapja</A>.
Elmagyarázzák, hogyan "játsszunk" a rendszerrel, tisztán mint tanulási gyakorlat.</P>
<P>A csomagok abban a sorrendben jelennek meg, amelyikben a rendszer indulási folyamatában
is részt vesznek. Ez azt jelenti, hogy ha ebben a sorrendben telepíted fel õket,
újraindítást csinálhatsz minden telepítés után, és láthatod, hogy a rendszer minden
egyes alkalommal közelebb visz ahhoz, hogy megkapd a bash prompt-ot. Van ebben
egy bizonyosságot erõsítõ érzés.</P>
<P>Azt ajánlom, hogy elõször olvasd el a részek fõ szövegeit, átugorva a gyakorlatokat
és hivatkozásokat. Ezután döntsd el, milyen mélységû szakértelmet akarsz elérni,
és mennyi erõfeszítést vagy hajlandó rááldozni. Ezután kezdd el megint az elejétõl,
végigcsinálva a gyakorlatokat és a kiegészítõ olvasmányokat áttanulmányozva.</P>

<H2><A NAME="s2">2. Hardver</A></H2>

<P>Amikor bekapcsolod a számítógépet, az leteszteli magát, hogy minden rendben
mûködik-e. Ezt "bekapcsolási önteszt"-nek (POST) hívják. Ezután a bootstrap
loader nevû, a ROM BIOS-ban található program keres egy bootszektort. A bootszektor
egy lemez elsõ szektora, és egy kis programkódot tartalmaz, ami képes egy
operációs rendszer betöltésére. A bootszektorokat a bûvös 0xAA55=43603 számmal
jelölik meg, ez a 0x1FE=510-es bájtnál található. Ez a szektor utolsó két bájtja.
Ezen a módon képes eldönteni a hardver, hogy a szektor  bootszektor vagy sem.</P>
<P>A bootstrap loader egy listával rendelkezik arról, hogy hol keressen bootszektort.
Az én régi gépem elõször az elsõdleges floppy-meghajtón kereste, majd az elsõdleges
merevlemezen. A modern gépek ezenkívül CD-ROM-on is kereshetik. Ha megtalálja a 
bootszektort, betölti a memóriába, és átadja a vezérlést az operációs rendszert
betöltõ programra.
Egy tipikus Linux rendszeren ez a LILO elsõ fokozatú (first stage) betöltõje. Ezen 
kívül persze még sok más módon lehet betöltetni a rendszert. Lásd a <EM>LILO User's Guide</EM>-ot 
részletekért. Lásd még a 
<A HREF="#lilo-links">LILO</A> részt URL-ekért.</P>

<P>Természetesen még rengeteg mindent lehetne mondani arról, hogy mit csinál a PC 
hardvere, de ez nem ennek a helye. Errõl a témáról sok jó könyvet olvashatsz .</P>

<H2><A NAME="ss2.1">2.1 Beállítás</A>
</H2>

<P>A gép néhány információt tárol önmagáról a CMOS-ban. Ez magában foglalja a gépben található
lemezek és memória adatait/jellemzõit. A gépben lévõ BIOS tartalmaz egy programot,
amivel ezeket a beállításokat módosítani lehet. Figyeld meg a géped indulásakor
megjelenõ üzeneteket, ezek egyike tájékoztat az ehhez valóó hozzáférés módjáról. Az én gépemen a "Delete" gombot
kell megnyomni, mielõtt elkezdené betölteni az operációs rendszert.</P>

<H2><A NAME="hardware-ex"></A> <A NAME="ss2.2">2.2 Gyakorlatok</A>
</H2>

<P>Nagyon jó módszere a hardverrõl való ismeretszerzésnek, ha használt alkatrészekbõl
épít egy gépet az ember. Végy legalább egy 386-ost, amin már könnyûszerrel futtathatsz
Linuxot. Nem fog sokba kerülni. Kérdezgess körbe, hátha valaki tud is adni olyan
részegységeket, amire szükséged van.</P>

<P>Nézz körül a Neten, töltsd és fordítsd le, majd készíts egy indítólemezt az
<A HREF="http://www.netspace.net.au/~gok/resources">Unios</A>-nak. (Volt egy
honlapjuk: 
<A HREF="http://www.unios.org">http://www.unios.org</A>, de ez már eltûnt.)
Ez csak egy bootolható "Helló világ!" program, alig több mint 100 sornyi assembler kód.
Jó volna látni olyan formátumban, hogy a GNU assembler, az "<CODE>as</CODE>" is megértse.</P>

<P>Nyisd meg egy hexa-editorral az Unios indítólemezének képfájlját. Ez a fájl 512
bájt méretû, pontosan egy szektornyi. Keresd meg a bûvös 0xAA55-ös számot. Tedd
ugyanezt egy indítófloppy-val vagy a saját gépeddel. Használhatod a "<CODE>dd</CODE>"
programot egy fájlba való kimásoláshoz: <CODE>dd if=/dev/fd0 of=boot.sector</CODE>.
Légy <EM>nagyon</EM> óvatos, hogy az "<CODE>if</CODE>" (bemeneti fájl) és "<CODE>of</CODE>"
(kimeneti fájl) jól legyen megadva!</P>
<P>Nézd meg a LILO betöltõjének forráskódját.</P>

<H2><A NAME="ss2.3">2.3 További információ</A>
</H2>

<P>
<UL>
<LI>
<A HREF="http://www.tldp.org/HOWTO/Unix-and-Internet-Fundamentals-HOWTO.html">The Unix and Internet Fundamentals HOWTO</A>,
szerzõ Eric S. Raymond,
különösen a 3. fejezet: <EM>What happens when you switch on a computer?</EM> (Mi történik, ha bekapcsolod a számítógépet?)
</LI>
<LI>Az elsõ fejezet a <EM>The LILO User's Guide</EM>-ból kitûnõ magyarázatot ad
a PC lemezpartíciókról és a bootolásról. Lásd a 
<A HREF="#lilo-links">LILO</A> fejezetet URL-ekért.
</LI>
<LI><EM>Az úJ Peter Norton Programmer's Guide to the IBM PC &amp; PS/2</EM>,
szerzõ Peter Norton és Richard Wilton, kiadó Microsoft Press, 1988.
Van egy újabb Norton-könyv, ami jól néz ki, de még nem engedhetem meg magamnak!
</LI>
<LI>A PC-k fejlesztésérõl szóló más könyvek egyike</LI>
</UL>
</P>

<H2><A NAME="s3">3. LILO</A></H2>

<P>Amikor a számítógép betölt egy bootszektort egy normál Linux rendszeren,
valójában a LILO egy részé tölti be, amit "elsõ fokozatú betöltõnek"
hívnak. Ez egy kicsi program, aminek nincs más szerepe, mint betölteni és futtatni
a "második fokozatú betöltõt".</P>

<P>A második fokozatú betöltõ ad egy készenléti jelet (ha úgy állították be) és
betölti az általad választott operációs rendszert.</P>

<P>Amikor a rendszer elindult, mûködik, és futtatod a <CODE>lilo</CODE>-t, akkor valójában
a "map installer"-t futtatod. Ez kiolvassa a <CODE>/etc/lilo.conf</CODE> konfigurációs fájlt,
kiírja a betöltõket és az információkat az általa betölthetõ operációs rendszerekrõl
a merevlemezre.</P>

<P>Rengeteg egyéb módja van még a rendszered betöltésének. Amit leírtam, a legkézenfekvõbb 
és "normál" mód, legalábbis egy Linuxot, mint fõ operációs rendszert futtató
gép számára. A LILO felhasználói kézikönyv többféle példát sorol fel a "betöltési 
koncepciókról". Megéri elolvasni, és néhányat kipróbálni közülük.</P>

<H2><A NAME="ss3.1">3.1 Beállítás</A>
</H2>

<P>A LILO konfigurációs fájlja a <CODE>/etc/lilo.conf</CODE>. Létezik kézikönyv-oldala: 
gépeld be a <CODE>man lilo.conf</CODE> parancsot a megtekintéséhez. A fõ dolog a <CODE>lilo.conf</CODE>-ban
egy bejegyzés mindenhez, amit a LILO be tud tölteni.  A Linux esetében ez tartalmazza
a kernel helyét, és hogy melyik lemezpartíciót kell gyökér fájlrendszerként
befûzni. Más operációs rendszereknél a fõ információ az, hogy melyik partícióról
bootoljanak.</P>

<H2><A NAME="ss3.2">3.2 Gyakorlatok</A>
</H2>

<P><EM>VIGYÁZAT:</EM> nagyon vigyázz ezekkel a gyakorlatokkal. Nagyon könnyû elrontani
valamit, tönkretenni a master boot rekordot és használhatatlanná tenni a rendszert.
Bizonyosodj meg, hogy van egy mûködõ mentõlemezed, és tudod is használni arra, hogy
visszaállítsd a dolgokat. Lásd alább a hivatkozást a tomsrtbt-re, arra a mentõlemezre
amit én használok és ajánlok. A legjobb az, ha olyan gépet használsz amelyiknél
mindez nem számít.</P>
<P>Telepítsd a LILO-t egy floppy-ra. Nem számít a nincs más rajta, csak egy
kernel - kapsz majd egy "kernel pánik"-ot, amikor készen áll az init betöltésére, de
legalább tudod, hogy a LILO mûködik.</P>
<P>Ha akarod, még tovább léphetsz és megnézheted, mekkora rendszert tudsz felrakni
a floppy-ra. Ez valószínûleg a második legjobb Linux-tanulási tevékenység. Lásd a
Bootdisk HOWTO-t (Indítólemez HOGYAN, URL alább) és a tomsrtbt-t (URL alább) tippekért.</P>
<P>Tölsd be az Unios-t a LILO-val (lásd a 
<A HREF="#hardware-ex">hardver gyakorlatok</A>
részt URL-ekért). Extra gyakorlatként nézd meg, végre tudod-e hajtani ezt egy floppy-lemezen.</P>

<P>Készíts egy boot-ciklust. Töltesd be a master boot rekord-beli LILO-val az egyik
elsõdleges partícióban lévû boot szektort, majd azzal újra a MBR-beli LILO-t...
Esetleg használd a MBR-t és mind a négy elsõdleges partíciót egy öt lépéses ciklushoz. Süti!</P>

<H2><A NAME="ss3.3">3.3 További információ</A>
</H2>

<P>
<A NAME="lilo-links"></A> 
<UL>
<LI>A LILO kézikönyv-oldala</LI>
<LI>A LILO csomag
(
<A HREF="ftp://lrcftp.epfl.ch/pub/linux/local/lilo/">lilo</A>),
ami tartalmazza a "LILO User's Guide"-ot is
<CODE>lilo-u-21.ps.gz</CODE> (vagy egy újabb verzió).
Talán már megvan neked ez a dokumentum.
Nézd meg a <CODE>/usr/doc/lilo</CODE> vagy valami hasonló helyen.
A postscript verzió jobb, mint a sima szöveg,
mivel diagramokat és táblázatokat is tartalmaz.</LI>
<LI>A 
<A HREF="http://www.toms.net/rb">tomsrtbt</A>, a legjobb egyfloppy-s disztribúció.
Nagyon jó mentõlemezként is.</LI>
<LI>
<A HREF="http://www.tldp.org/HOWTO/Bootdisk-HOWTO/">A Bootdisk HOWTO</A> (Indítólemez HOGYAN)</LI>
</UL>
</P>



<H2><A NAME="s4">4. A Linux kernel</A></H2>

<P>A kernel valójában nagyon sok mindent csinál. Úgy gondolom jó összefoglalása
a dolgoknak az, hogy ráveszi a hardvert, azt tegye amit a programok akarnak,
méghozzá hatékonyan és jól.</P>

<P>A processzor egyszerre csak egy utasítást tud végrehajtani, de a Linux rendszerek látszólag
több dolgot is végeznek egyszerre. A kernel ezt úgy éri el, hogy nagyon gyorsan váltogatja a
feladatokat. Ezzel a lehetõ legjobban ki lehet használni a processzort, úgy, hogy követjük melyik
folyamat kész a futásra, és melyik várakozik valamire - mint például egy rekordra egy merevlemez
fájlból, vagy egy billentyû leütésére. Ezt nevezik ütemezésnek (scheduling).</P>


<P>Ha egy program nem csinál semmit, nem kell a memóriában lennie. Még egy olyan programnak is ami
csinál valamit, lehet, hogy vannak olyan részei amik nem csinálnak semmit. Mindegyik folyamat
(process) címzési tartománya fel van osztva lapokra. A kernel nyilvántartja, melyik folyamat
melyik lapja van a legtöbbet használva. Azokat a lapokat, amik kevésbé használtak, ki lehet
helyezni a csere (swap) partícióra. Amikor megint szükség van rájuk, egy másik nem használt lapot lehet
kihelyezni. Ez a virtuális memóriakezelés. </P>

<P>Ha már fordítottál saját kernelt, észrevehetted milyen sok az eszközfüggõ beállítás.
A kernel sok egyedi kódot tartalmaz, a különbözõ hardverekkel történõ kommunikáláshoz, valamint hogy szép
egységes felületet mutasson az alkalmazások felé.</P>

<P>Szintén a kernel irányítja a fájlrendszert, a folyamatok közötti kommunikációt, és egy
csomó hálozati dolgot. </P>

<P>Amikor a kernel betöltõdött, az elsõ dolog amit csinál, hogy egy "<CODE>init</CODE>" programot
keres és lefuttaja.</P>

<H2><A NAME="ss4.1">4.1 Beállítás</A>
</H2>

<P>A kernel beállításának legnagyobb része akkor történik, amikor futtatod a "<CODE>make
menuconfig</CODE>"-ot
vagy a "<CODE>make xconfig</CODE>"-ot az <CODE>/usr/src/linux/</CODE> könyvtárban, (vagy bárhol máshol, ahol a
Linux kernel forráskód van). Újra tudod állítani az alapértelmezett video módot, gyökér (root)
fájlrendszert, csere (swap) eszközt és a RAM disk méretét, ha az "<CODE>rdev</CODE>"-et használod.
Ezeket - vagy
még több paramétert - a lilo is át tud adni a kernelnek. Adhatsz a lilo-nak paramétereket a
lilo.conf fájlban, vagy a lilo promptjánál, hogy átadja ezeket az információkat. Például ha
a hda3-at akarod használni mint root fájlrendszert a hda2 helyett, begépelheted hogy:</P>
<P>
<PRE>
        LILO: linux root=/dev/hda3
</PRE>
</P>

<P>Ha forrásból építesz rendszert, sokkal egyszerûbbé teheted az életet, ha "monolitikus" kernelt
csinálsz. Ez azt jelenti, hogy nincsenek moduljai. Ekkor nem kell kernel modulokat másolni a cél
rendszerbe.</P>

<P>FIGYELEM: A <CODE>System.map</CODE> fájlt a kernel logger (naplózó) használja, hogy meghatározza a
modulneveket generáló üzeneteket. A <CODE>top</CODE> nevû program szintén használja ezt az
információt. Amikor a kernelt a célrendszerbe másolod, másold át a "<CODE>System.map</CODE>"-ot is.</P>

<H2><A NAME="ss4.2">4.2 Gyakorlatok</A>
</H2>

<P>Egy kis gondolkodnivaló: a <CODE>/dev/hda3</CODE> egy különleges fájl, ami leír egy merevlemez
particiót. De egy olyan fájlrendszeren van, mint bármelyik másik fájl. A kernel meg akarja
tudni, hogy melyik particiót csatolja fel (mount), mint gyökér fájlrendszert - de még nincs is
fájlrendszere. Mégis hogyan tudja olvasni a <CODE>/dev/hda3</CODE> partíciót, hogy megtudja melyik lemezrészt
csatolja?</P>


<P>Ha még nem tetted meg, készíts saját kernelt. Olvass el minden súgóinformációt az opciókhoz.</P>

<P>Próbáld ki, mekkora a legkisebb kernel ami még mûködik. Sokat tanulhatsz abból, ha kihagyod a
felesleges dolgokat!</P>

<P>Olvasd el a "The Linux Kernel"-t (URL alább), és közben keresd meg a forráskód azon részeit,
amire hivatkozik. A könyv (amint ezt írom) a 2.0.33-as kernel verzióval foglalkozik, ami elég
öreg már. Könnyebb követni, ha letöltöd ezt az öreg verziót, és ott olvasod a forrást.
Fantasztikus érzés "process" és "page" nevû C kóddarabokat találni. </P>

<P>Hackelj! Próbálj meg extra üzeneteket vagy valami mást kiíratni.</P>

<H2><A NAME="Kernel"></A> <A NAME="ss4.3">4.3 További információ</A>
</H2>

<P>
<UL>
<LI><CODE>/usr/src/linux/README</CODE> és a  
<CODE>/usr/src/linux/Documentation/</CODE> tartalma 
(Lehet, hogy ezek máshol vannak a Te rendszereden)</LI>
<LI> 
<A HREF="http://mirror.aarnet.edu.au/linux/LDP/HOWTO/Kernel-HOWTO.html">Kernel HOWTO</A> (Kernel HOGYAN)</LI>
<LI>A kernel beállításakor olvasható segítség a
<CODE>make menuconfig</CODE> vagy <CODE>make xconfig</CODE> használatakor</LI>
<LI> 
<A HREF="http://mirror.aarnet.edu.au/linux/LDP/LDP/">The Linux Kernel (és más LDP útmutatók)</A> (A Linux Kernel)</LI>
<LI>  forráskód, lásd a
<A HREF="http://www.netspace.net.au/~gok/power2bash">Building a Minimal Linux System from Source Code</A> (Minimális Linux rendszer
építése forrásból) doksit URL-ekért</LI>
</UL>
</P>


<H2><A NAME="s5">5. A GNU C könyvtár</A></H2>

<P>A következõ dolog, ami a számítógép bekapcsolásakor történik, hogy betöltõdik és lefut az
init. Azonban az init - mint majdnem minden program - függvényeket használ más
könyvtárakból.</P>

<P>Talán már láttál C nyelvû példaprogramot, mint ez is:</P>

<P>
<PRE>
        main() {
                printf("Hello World!\n");
        }
</PRE>
</P>
<P>A programban nincs leírva mi az a "<CODE>printf</CODE>", honnan is jön ez? Ez a standard C könyvtárakból
- egy GNU/Linux rendszeren a glibc - származik. Ha Visual C++ alatt fordítod le, akkor ugyanannak a
standard
függvénynek a Microsoftos változatából jön. Milliárdnyi van ezekbõl a standard függvényekbõl
a matematikához, stringekhez, dátumhoz/idõhöz, memóriafoglaláshoz és így tovább. A Unix (beleértve
a Linuxot) alatt minden vagy C-ben van írva, vagy nagyon úgy kell tennie mintha abban lenne írva.
Egyszóval minden program tudja használni ezeket a függvényeket.</P>

<P>Ha belenézel a <CODE>/lib</CODE> könyvtárba, sok olyan fájlt fogsz látni, amit
<CODE>libvalami.so</CODE>-nak vagy
<CODE>libvalami.a</CODE>-nak hívnak. Ezek a függvények könyvtárai. A glibc csak a GNU változata
ezeknek a
függvényeknek.</P>

<P>Két módon használhatják a programok ezeket a függvénykönyvtárakat. Ha <EM>statikusan</EM>
kapcsolódnak egy programhoz, ezek a függvények belemásolódnak a végrehajtható fájlba, amikor
létrejön. Ez az, amire a <CODE>libvalami.a</CODE> könyvtárak valók. Ha <EM>dinamikusan</EM>
kapcsolódnak egy
programhoz (ez az alapértelmezés), akkor amikor a program fut és szüksége van a függvény
kódjára, meghívja azt a <CODE>libvalami.so</CODE> fájlokból.</P>

<P>Az "<CODE>ldd</CODE>" parancsra van szükséged, ha meg akarod tudni, melyik függvénykönyvtárat
használja egy
bizonyos program. Itt vannak például azok a függvénykönyvtárak, amiket a "<CODE>bash</CODE>" használ:</P>

<P>
<PRE>
        [greg@Curry power2bash]$ ldd /bin/bash
                libtermcap.so.2 => /lib/libtermcap.so.2 (0x40019000)
                libc.so.6 => /lib/libc.so.6 (0x4001d000)
                /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)
</PRE>
</P>

<H2><A NAME="ss5.1">5.1 Beállítás</A>
</H2>

<P>Néhány a könyvtárakban lévõ függvény attól függ, hogy helyileg hol vagy. Például mi itt
Ausztráliában a dátumokat így írjuk: nn/hh/éé, de az amerikaiak hh/nn/éé -et írnak. Van egy
program ami a "<CODE>glibc</CODE>" csomagban van, "<CODE>localedef</CODE>" a neve. Ez lehetõvé
teszi ezek beállítását.</P>

<H2><A NAME="ss5.2">5.2 Gyakorlatok</A>
</H2>

<P>Használd az "<CODE>ldd</CODE>" parancsot, hogy megtudd, milyen programkönyvtárakat használnak a kedvenc
alkalmazásaid.</P>

<P>Használd az "<CODE>ldd</CODE>"-t arra, hogy megtudd, milyen könyvtárakat használ az "<CODE>init</CODE>".</P>

<P>Készíts egy játék könyvtárat, egy vagy két függvénnyel. Az "<CODE>ar</CODE>" programmal lehet létrehozni
õket. Az "<CODE>ar</CODE>" kézikönyv-oldalából megtudhatod ennek menetét.
Írj, fordíts le és csatolj egy programot ami ezt a könyvtárat használja.</P>

<H2><A NAME="ss5.3">5.3 További információ</A>
</H2>

<P>
<UL>
<LI>  forráskód, lásd a
<A HREF="http://www.netspace.net.au/~gok/power2bash">Building a Minimal Linux System from Source Code</A>
doksit URL-ért</LI>
</UL>
</P>



<H2><A NAME="s6">6. Init</A></H2>

<P>Csak a "System V" stílusú "init"-rõl beszélek, amit a Linux rendszerek a leginkább használnak.
Vannak más megoldások is. Valójában bármilyen programot berakhatsz az <CODE>/sbin/init</CODE>-be, amit a
kernel le fog futtatni, amint betöltõdött.</P>

<P>Az "<CODE>init</CODE>" feladata, hogy minden úgy mûködjön ahogy kell. Leellenõrzi a fájlrendszereket és
felcsatolja õket. Lefuttatja a "démonokat", hogy naplózzák a rendszerüzeneteket, hálózatkezelést
csináljanak,
kiszolgáljanak web oldalakat, figyeljenek az egeredre stb. Szintén ez indítja a getty folyamatokat, amik
kirakják a bejelentkezõ (login) promptot a virtuális terminálodra.</P>

<P>Van egy nagyon komplikált történet a "futási szintek" (run-levels) közötti kapcsolásról,
de a legnagyobb részét kihagyom, és csak a rendszer indulásáról beszélek. </P>

<P>Az" init" beolvassa az <CODE>/etc/inittab</CODE> fájlt, ez írja le mit csináljon. Általában elõször
lefuttat egy inicializáló szkriptet. A program, ami végrehajtja (soronként) ezt a szkriptet, a
bash, ugyanaz a program ami kiírja a parancssorodat. Debian rendszereken az inicializáló szkript
az <CODE>/etc/init.d/rcS</CODE>, Red Hat-en a <CODE>/etc/rc.d/rc.sysinit</CODE>. Ez az, ami a
fájlrendszereket leellenõrzi és
felcsatolja, beállítja az órát és a csere (swap) területet, beállítja a gép hálózati nevét
(hostname) stb. </P>

<P>Ezután egy másik szkript indul el, ami elvisz az alapértelmezett futási szintre. Ez csak
annyit jelent, hogy elindul néhány alrendszer. Van egy pár könyvtár, az <CODE>/etc/rc.d/rc0.d,
/etc/rc.d/rc1.d, ..., /etc/rc.d/rc6.d</CODE> Red Hat alatt, vagy az <CODE>/etc/rc0.d , /etc/rc1.d, ...,
/etc/rc6.d</CODE> Debian alatt, ami a futási szintekhez tartozik. Ha a 3-as futási szinten vagyunk
Debianban, akkor a szkript lefuttatja az összes "S"-el (start rövidítése) kezdõdõ szkriptet az
<CODE>/etc/rc3.d</CODE>-ben. Ezek a szkriptek valójában csak linkek más szkriptekhez egy másik
könyvtárban, amit általában "<CODE>init.d</CODE>"-nek hívnak.</P>

<P>Tehát az "<CODE>init</CODE>" meghívja a futási szint (run-level) szkriptünket, és más "S"-el kezdõdõ
szkripteket keres egy könyvtárban. Megtalálhatja elsõként az <CODE>S10syslog</CODE>-ot. A számok
megmondják
a (run-level) szkriptnek, milyen sorrendben futtassa le õket. Ebben az esetben az <CODE>S10syslog</CODE>
hajtódik
végre elõször, mivel nincs S00 ... S09 kezdetû szkript. De az <CODE>S10syslog</CODE> valójában csak egy
link az
<CODE>/etc/init.d/syslog</CODE>-hoz, ami egy rendszernaplózást (system logger) elindító és leállító
szkript. Mivel a link "S"-el kezdõdik, a (run-level) szkript tudja, hogy végre kell hajtania a
<CODE>syslog</CODE>-ot egy "start" paraméterrel. Vannak ennek megfelelõ, "K"-val (kill - megölni)
kezdõdõ linkek,
amik meghatározzák, mi és milyen sorendben legyen leállítva, amikor elhagyjuk a futási szintet. </P>

<P>Ha meg akarod változtatni az alrendszerek alapértelmezett indítását, létre kell
hoznod ezeket a linkeket az <CODE>rcN.d</CODE> könyvtárban, ahol N az alapértelmezett futási szint az
<CODE>inittab</CODE> fájlodban. </P>

<P>Az utolsó fontos dolog, amit az "init" csinál, hogy elindít pár <CODE>getty</CODE>-t. Ezek "respawned"
állapotúak, ami azt jelenti, hogy ha leállnak, akkor az "<CODE>init</CODE>"  egyszerûen újraindítja
õket. A legtöbb disztribució hat virtuális terminált indít. Lehet, hogy kevesebbet akarsz a
memóspórolás érdekében, vagy többet, amivel egy csomó dolgot hagyhatsz futni és gyorsan
váltogathatsz köztük ha szükséged
van rájuk. Lehet, hogy akarsz majd futtatni egy <CODE>getty</CODE>-t szöveges terminálnak vagy modemes
betárcsázáshoz. Ebben az estben át kell szerkesztened az <CODE>inittab</CODE> fájlodat.</P>

<H2><A NAME="ss6.1">6.1 Beállítás</A>
</H2>

<P>A <CODE>/etc/inittab</CODE> az "init" legfelsõ szintû konfigurációs fájlja.</P>

<P>Az <CODE>rcN.d</CODE> könyvtárak, ahol N = 0, 1, ..., 6, határozzák meg, milyen alrendszerek
indulnak el.</P>

<P>Valahol az "init" által elindított szkriptekben, a <CODE>mount -a</CODE>  parancs kerül végrehajtásra. Ez
annyit jelent, hogy felcsatolódik az összes fájlrendszer, aminek fel kell csatolódnia. Ez az
<CODE>/etc/fstab</CODE>
fájlban van leírva. Ha meg akarod változtatni, hogy hova és mi
csatolódjon, amikor a rendszered elindul, ezt a fájlt kell átszerkesztened. Az <CODE>fstab</CODE>
fájlnak van egy kézikönyv (man) oldala is.</P>

<H2><A NAME="ss6.2">6.2 Gyakorlatok</A>
</H2>

<P>Keresd meg alapértelmezett futási szintedhez tartozó <CODE>rcN.d</CODE> könyvtáradat és adj ki egy
<CODE>ls -l</CODE>
parancsot, hogy lásd milyen fájlokhoz kapcsolódnak a linkek.</P>

<P>Változtasd meg a rendszereden futó getty-k számát.</P>

<P>Törölj minden alrendszert, amire nincs szükséged, az alapértelmezett futási szinten.</P>

<P>Nézd meg, milyen közel jutottál a kezdéshez.</P>

<P>Telepíts egy floppy-ra lilo-t, kernelt és egy statikusan linkelt "hello world" programot, amit
nevezz el <CODE>/sbin/init</CODE>-nek, és figyeld ahogy bebootol és kiírja: hello.</P>

<P>Nézd figyelmesen a rendszered indulását és jegyzetelj, milyen üzeneteket ír ki arról ami
történik. Esetleg nyomtass ki egy részt a rendszernaplóból (<CODE>/var/log/messages</CODE>). Ezután az
<CODE>inittab</CODE>-bal kezdve, fusd át az összes szkriptet és figyeld meg, melyik kódrészlet mit
csinál.
Berakhatsz extra start üzeneteket is, mint például:</P>
<P>
<PRE>
        echo "Hello, en vagyok a rc.sysinit"
</PRE>
</P>
<P>Ez jó gyakorlat arra is, hogy megtanuld a Bash shell alatti szkriptírást. A szkriptek közül
néhány eléggé komplikált. Legyen kéznél egy jó Bash referenciakönyv.</P>

<H2><A NAME="ss6.3">6.3 További információ</A>
</H2>

<P>
<UL>
<LI>Létezik kézikönyv-oldal az <CODE>inittab</CODE> és <CODE>fstab</CODE> fájlokhoz. 
Megnézheted a "<CODE>man inittab</CODE>" begépelésével.</LI>
<LI>A Linux System Administrators Guide tartalmaz egy
<A HREF="http://mirror.aarnet.edu.au/linux/LDP/LDP/">jó részt</A> az init-rõl.</LI>
<LI>  forráskód, lásd a  
<A HREF="http://www.netspace.net.au/~gok/power2bash">Building a Minimal Linux System from Source Code</A> doksit URL-ért.
        </LI>
</UL>
</P>


<H2><A NAME="s7">7. A fájlrendszer</A></H2>

<P>Ebben a fejezetben a fájlrendszer szót két különbözõ értelemben fogom használni. Vannak
fájlrendszerek a lemez particiókon és más eszközökön, és van egy fájlrendszer, amit a futó
Linux alól látsz. A Linuxban "felcsatolod" (mount) a lemezes fájlrendszereket
az operációs rendszer fájlrendszerére. </P>

<P>Az elõzõ fejezetben megemlítettem, hogy az" init" szkriptek leellenõrzik és felcsatolják a
fájlrendszereket. Ezt az "<CODE>fsck</CODE>" és a "<CODE>mount</CODE>" parancsok végzik el.</P>

<P>A merevlemez csak egy nagy tárhely, ahova egyeseket és nullákat írhatsz. A fájlrendszer erre rárak
egy szerkezetet, és ettõl néz ki úgy, mintha fájlok lennének könyvtárakon belül és azok is
további könyvtárakon belül... Minden fájlnak van egy leíró táblája (inode), ami nyilvántartja
kié a fájl, mikor hozták létre és hol vannak a részei. A könyvtárakat is inode-ok írják
le, de ezekben a tárolódik, hogy hol találhatók azoknak a fájloknak az inode-jai, amik a
könyvtárban
vannak. Ha a rendszer  olvasni akarja a <CODE>/home/greg/bigboobs.jpeg</CODE> fájlt, elõször megkeresi a
gyökér
(root) / könyvtár leíró tábláját a "superblock"-ban, ezután megkeresi a / tartalmában
lévõ <CODE>home</CODE> könyvtár inode-ját, ezután megkeresi a <CODE>/home</CODE> tartalmában lévõ
<CODE>greg</CODE> könyvtár
inode-ját, ezután megkeresi a <CODE>bigboobs.jpeg</CODE> leíró tábláját, ami jelzi melyik
lemezblokkot kell olvasnia.</P>

<P>Ha hozzáfûzünk egy kis adatot egy fájl végéhez, megeshet, hogy elõször az adat íródik ki,
mielõtt a leíró tábla frissülne (ami jelezné, hogy az új blokkok a fájlhoz tartoznak),
vagy fordítva. Ha ezen a ponton áramszünet következik be, megsérülhet a fájlrendszer. Ez az a
dolog, amit az "<CODE>fsck</CODE>" megpróbál felderíteni és kijavítani.</P>

<P>A "mount" parancs egy eszközön lévõ fájlrendszert hozzáad a használatban lévõ rendszered
hierarchiájához. Általában a kernel csak olvasható módban csatolja fel a (root) fájl
rendszert. A "mount" parancsot használják arra, hogy újra felcsatolják írható-olvasható módban,
miután az "<CODE>fsck</CODE>" leellenõrizte, hogy minden rendben.</P>

<P>A Linux támogat másfajta fájlrendszereket is: msdos, vfat, minix stb. Egy bizonyos fájlrendszer
részletei el vannak vonatkoztatva egy virtuális fájlrendszerre (VFS). Nem megyek bele a
részletekbe, van egy vita errõl a "A Linux Kernel"-ben (lásd a 
<A HREF="#Kernel">A Linux Kernel fejezetet</A> URL-ért).</P>

<P>Egy teljesen más fájlrendszer csatolódik be a <CODE>/proc</CODE> könyvtárba. Valójában ez csak a
kernelben
lévõ dolgok megjelenítése. Mindegyik - a rendszerben futó folyamatnak (process) - van egy
könyvtára, ahol a folyamat száma a könyvtár neve. Vannak ott fájlok is, mint például
<CODE>interrupts</CODE>
(megszakítások) és <CODE>meminfo</CODE>, amik elárulják, hogy hogyan használja a gép a hardvert.
Nagyon sokat
tanulhatsz a <CODE>/proc</CODE> felfedezése közben.</P>

<H2><A NAME="ss7.1">7.1 Beállítás</A>
</H2>

<P>Vannak az "<CODE>mke2fs</CODE>" parancsnak (ami ext2 fájlrendszert hozza létre) paraméterei is. Ezek
ellenõrzik a
blokkok méretét, a leíró táblák (inode) számát stb. Olvasd el az "<CODE>mke2fs</CODE>" kézikönyv-oldalát
részletekért.</P>

<P>Hogy mi hova csatolódik a fájlrendszereden, az <CODE>/etc/fstab</CODE> fájlban dõl el. Ennek is
van kézikönyv-oldala.</P>

<H2><A NAME="ss7.2">7.2 Gyakorlatok</A>
</H2>

<P>Készíts egy nagyon kicsi fájlrendszert, és nézd meg egy hexa editorral. Azonosítsd az
inode-okat, szuperblokkokat és a fájl összetevõket.</P>

<P>Biztos vagyok benne, vannak eszközök amik visszadják a fájlrendszered grafikus kinézetét.
Keress egyet, próbáld ki, és küldj egy URL-t és leírást nekem e-mailben!</P>

<P>Nézd meg az ext2 fájlrendszer kódját a kernelben.</P>

<H2><A NAME="ss7.3">7.3 További információ</A>
</H2>

<P>
<UL>
<LI>A "The Linux Kernel" címû LDP könyv 9. fejezete kitûnõ leírást ad a fájlrendszerekrõl.
Megtalálhatod például. a TLDP egyik ausztrál
<A HREF="http://mirror.aarnet.edu.au/linux/LDP/LDP/">tüköroldalán</A>.</LI>
<LI>A "<CODE>mount</CODE>" parancs az util-linux csomag része, van egy hivatkozás hozzá a
<A HREF="http://www.netspace.net.au/~gok/power2bash">Building a Minimal Linux System from Source Code</A> doksiban.</LI>
<LI>A "<CODE>mount</CODE>, "<CODE>fstab</CODE>", "<CODE>fsck</CODE>"," <CODE>mke2fs</CODE>"
és a <CODE>proc</CODE> kézikönyv-oldalai.</LI>
<LI>A <CODE>Documentation/proc.txt</CODE> fájl a Linux forrásában elmagyarázza a
<CODE>/proc</CODE> fájlrendszert.</LI>
<LI>Az EXT2 fájlrendszer segédprogramjai, az
<A HREF="http://web.mit.edu/tytso/www/linux/e2fsprogs.html">ext2fsprogs</A> honlapja, vagy az
<A HREF="ftp://mirror.aarnet.edu.au/pub/linux/metalab/system/filesystems/ext2/">ext2fsprogs</A> ausztrál tüköroldal. Itt van még egy Ext2fs-áttekintés,
bár már régi és nem olyan olvasmányos, mint a "The Linux Kernel" 9. fejezete.</LI>
<LI>  
<A NAME="FHS"></A> 
<A HREF="ftp://tsx-11.mit.edu/pub/linux/docs/linux-standards/fsstnd/">Unix Fájlrendszer Standard</A>.
Másik 
<A HREF="http://www.pathname.com/fhs/">link</A> a Unix Fájlrendszer Standard-hoz.
Ez leírja, minek hova kell kerülnie egy Unix fájlrendszerben, és miért.
Szintén ebben található egy leírás arról, hogy a
<CODE>/bin</CODE>, <CODE>/sbin</CODE> stb. könyvtáraknak mit kell tartalmaznia.
Jó referencia, ha a célod egy minimális, mégis teljes rendszer megépítése.</LI>
</UL>
</P>


<H2><A NAME="s8">8. Kernel démonok</A></H2>

<P>Ha kiadod a "<CODE>ps aux</CODE>" parancsot, valami ehhez hasonlót fogsz látni:</P>

<P>
<PRE>
USER       PID %CPU %MEM  SIZE   RSS TTY STAT START   TIME COMMAND
root         1  0.1  8.0  1284   536   ? S    07:37   0:04 init [2]
root         2  0.0  0.0     0     0   ? SW   07:37   0:00 (kflushd)
root         3  0.0  0.0     0     0   ? SW   07:37   0:00 (kupdate)
root         4  0.0  0.0     0     0   ? SW   07:37   0:00 (kpiod)
root         5  0.0  0.0     0     0   ? SW   07:37   0:00 (kswapd)
root        52  0.0 10.7  1552   716   ? S    07:38   0:01 syslogd -m 0
root        54  0.0  7.1  1276   480   ? S    07:38   0:00 klogd
root        56  0.3 17.3  2232  1156   1 S    07:38   0:13 -bash
root        57  0.0  7.1  1272   480   2 S    07:38   0:01 /sbin/agetty 38400 tt
root        64  0.1  7.2  1272   484  S1 S    08:16   0:01 /sbin/agetty -L ttyS1
root        70  0.0 10.6  1472   708   1 R   Sep 11   0:01 ps aux
</PRE>
</P>

<P>Ez a rendszerben futó folyamatok listája. Az információ a <CODE>/proc</CODE> fájlrendszerbõl (amit az elõzõ részben már említettem)
származik. Figyeld meg, hogy az "<CODE>init</CODE>" az egyes számú folyamat. A "kflushd", "kupdate", "kpiod" és a "kswapd" a 2, 3, 4 és 5-ös számú
folyamatok. Van azonban valami furcsa: nézd meg mind a virtuális tárolási méret (SIZE), mind a valódi tárolási méret (RSS)
nevû oszlopokat. Ezeknél a folyamatoknál nullák szerepelnek. Hogyhogy egy folyamat nem használ memóriát?</P>

<P>Ezek a folyamatok a kernel démonok. A kernel legnagyobb része egyáltalán nem mutatkozik a folyamatlistákon.
Csak úgy találhatod ki mennyi memóriát használnak, ha kivonod a gépben lévõ memóriából a rendelkezésre álló
memória mennyiségét. A kernel démonok az "init" után indulnak el, így kapnak folyamatszámot ugyanúgy, mint a normál folyamatok.
De a kódjuk és adataik a kernel részére lefoglalt memóriában van.</P>

<P>A COMMAND oszlop bejegyzéseinél zárójelek vannak, mivel a <CODE>/proc</CODE> fájlrendszer nem tartalmaz parancssori
információkat ezekrõl a folyamatokról.</P>

<P>Tehát mire is valók ezek a kernel démonok? E dokumentum elõzõ verzióiban volt egy segítségkérõ rész,
mivel nem tudtam sokat róluk. A következõ történet az erre adott válaszokból (amiért nagyon hálás vagyok) lett összerakva.
Szívesen fogadom a további okosításokat, referenciákat és kiigazításokat!</P>

<P>A bevitel és kivitel <EM>puffereken</EM> (buffers) keresztül történik a memóriában. Ettõl gyorsabban mennek a dolgok.
Amit a programok írnak, a memóriában lehet tartan - egy pufferben - ezután nagyobb (hatékonyabb) darabokban lehet a lemezre írni.
A "<CODE>kflushd</CODE>" és "<CODE>kupdate</CODE>" démonok ezt a munkát végzik: a "<CODE>kupdate</CODE>" periodikusan lefut
(5 másodpercenként?), hogy leellenõrizze van-e használt puffer (dirty buffers). Ha igen, utasítja a "<CODE>kflushd</CODE>" démont,
hogy írja ki õket a lemezre.</P>

<P>A folyamatoknak gyakran semmi dolguk, és azoknak amik éppen futnak, gyakran nincs arra szükségük,
hogy az össszes kódjukat és adataikat a memóriában tartsák. Ez azt jelenti, hogy jobb hasznát vesszük a memóriánknak,
ha a futó programok éppen nem használt részeit kiírjuk a merevlemez csere (swap) partíciójára. Az adat szükséges ki- és
bemozgatását a memóriába (-ból) a "<CODE>kpiod</CODE>" és a "<CODE>kswapd</CODE>" végzi. Minden másodpercben vagy valahogy így,
a "<CODE>kswapd</CODE>" felébred, hogy leellenõrizze a memória helyzetét, és ha szükség van valamire a memóriában -
ami a lemezen található - vagy nincs elég szabad memória, a "<CODE>kpiod</CODE>" hívódik meg.</P>

<P>Lehet, hogy a "<CODE>kapmd</CODE>" démon is fut a rendszereden, ha az automatikus áramgazdálkodás (automatic power management)
be van fordítva a kerneledbe.</P>


<H2><A NAME="ss8.1">8.1 Beállítás</A>
</H2>

<P>Az "<CODE>update</CODE>" programal lehet beállítani a "<CODE>kflushd</CODE>" és a "<CODE>kswapd</CODE>" démonokatt.
Próbáld az "<CODE>update -h</CODE>" parancsot kiadni valami információért.</P>

<P>A csere partíciót be lehet kapcsolni a "<CODE>swapon</CODE>", és ki lehet kapcsolni a "<CODE>swapoff</CODE>" paranccsal.
Az init szkript (<CODE>/etc/rc.sysinit</CODE> vagy <CODE>/etc/rc.d/rc.sysinit</CODE>) általában meghívja a "<CODE>swapon</CODE>"-t,
amint a rendszer elindul. Azt mondták nekem, hogy a "<CODE>swapoff</CODE>" praktikus, ha áramot akarunk spórolni laptopon.</P>

<H2><A NAME="ss8.2">8.2 Gyakorlatok</A>
</H2>

<P>Csinálj egy <CODE>update -d</CODE>-t, és figyeld a dumát az utolsó sorban a "threshold for buffer fratricide"-rõl.
Most már van egy érdekes fogalmad, járj utána!</P>

<P>Lépj be a <CODE>/proc/sys/vm</CODE> könyvtárba és adj ki egy "<CODE>cat</CODE>" parancsot az ott lévõ fájlokra.
Figyeld meg, mi mindenre tudsz rájönni ezáltal.</P>

<H2><A NAME="ss8.3">8.3 További információ</A>
</H2>

<P>A Linux Dokumentációs Projekt "The Linux Kernel" dokumentuma
(lásd 
<A HREF="#Kernel">A Linux kernel</A> fejezetet URL-ért)</P>

<P>A Linux kernel forráskódja, ha elég bátor vagy!
A "<CODE>kswapd</CODE>" kódja a <CODE>linux/mm/vmscan.c</CODE>-ben,
a "<CODE>kflushd</CODE>" és "<CODE>kupdate</CODE>" kódja pedig a
<CODE>linux/fs/buffer.c</CODE> fájlban van.</P>



<H2><A NAME="s9">9. Rendszernaplózó</A></H2>

<P>Az "init" elindítja a "<CODE>syslogd</CODE>" és a "<CODE>klogd</CODE>" démonokat. Ezek üzeneteket írnak a naplófájlokba.
A kernel üzeneteit a "<CODE>klogd</CODE>" kezeli, míg a "<CODE>syslogd</CODE>" más folyamatok üzeneteit intézi.
A fõ naplófájl a <CODE>/var/log/messages</CODE>. Jól teszed, ha elõször itt keresel ha valami baj van a rendszereddel.
Gyakran található ott egy fontos nyom.</P>

<H2><A NAME="ss9.1">9.1 Beállítás</A>
</H2>

<P>Az <CODE>/etc/syslog.conf</CODE> fájl írja le a naplózóknak, hogy milyen üzenetet hova írjanak.
Az üzeneteketet az azonosítja, hogy milyen folyamattól és milyen prioritással érkeznek.
Ez a fájl olyan sorokból áll, amik jelzik, hogy az x folyamattól y prioritással érkezõ üzenetek z-hez menjenek,
ahol z lehet egy fájl, tty, nyomtató, távoli ügyfél (remote host) vagy bármi más.</P>

<P>FIGYELEM: A Syslognak szüksége van az <CODE>/etc/services</CODE> fájlra. A services fájl portokat jelöl ki.
Nem vagyok benne biztos, hogy a syslognak kell egy port, amivel így tud naplófájlt készíteni távoli gépre is (remote logging),
vagy ahhoz is egy portra van szükség, hogy a helyi gépre naplófájlt készítsen (local logging), vagy csak az <CODE>/etc/services</CODE>-t
használja, hogy az általad beírt folyamatneveket az <CODE>/etc/syslog.conf</CODE> port számokká konvertálja.</P>

<H2><A NAME="ss9.2">9.2 Gyakorlatok</A>
</H2>

<P>Vess egy pillantást a rendszernaplódra. Keress egy üzenetet amit nem értesz, és találd ki mit jelent.</P>

<P>Küld ki az üzeneteidet egy tty-re. (állítsd vissza miután megcsináltad)</P>

<H2><A NAME="ss9.3">9.3 További információ</A>
</H2>

<P>Ausztrál sysklogd 
<A HREF="http://mirror.aarnet.edu.au/pub/linux/metalab/system/daemons/">tükör</A></P>


<H2><A NAME="s10">10. Getty és bejelentkezés</A></H2>

<P>A getty program teszi lehetõvé, hogy bejelentkezzhess egy soros eszközön keresztül mint például egy virtuális terminál,
szöveges terminál, vagy egy modem. Kiírja a bejelentkezõ parancssort (login prompt). Miután beírtad a felhasználói nevedet,
a getty átadja azt a "<CODE>login</CODE>"-nak, ami megkérdezi a jelszót, leellenõrzi, és ad egy shellt.</P>

<P>Sok használható getty van. Néhány disztribució- beleértve a Red Hat-et - egy nagyon kicsit használnak,
aminek a neve "<CODE>mingetty</CODE>", ez csak virtuális terminálokkal mûködik.</P>

<P>A "<CODE>login</CODE>" program az util-linux csomag része, amiben található egy másik getty is, aminek "<CODE>agetty</CODE>" a neve,
és jól mûködik. Szintén ebben a csomagban van az <CODE>"mkswap", "fdisk", "passwd", "kill", "setterm", "mount", "swapon", "rdev", "renice",
"more"</CODE> és még sok más program.</P>

<H2><A NAME="ss10.1">10.1 Beállítás</A>
</H2>

<P>Az üzenet, amit a képernyõd tetején látsz a login prompt-al együtt, az <CODE>/etc/issue</CODE>
fájlból származik. A getty-kat általában a <CODE>/etc/inittab</CODE>-ból indítjuk. 
A login a felhasználói jellemzõket a <CODE>/etc/passwd</CODE>-ben ellenõrzi, illetve,
ha árnyékjelszavakat használsz, a <CODE>/etc/shadow</CODE>-ban.</P>

<H2><A NAME="ss10.2">10.2 Gyakorlatok</A>
</H2>

<P>Készíts "kézzel" egy <CODE>/etc/passwd</CODE> fájlt. A jelszavak üresek lehetnek, és 
a "<CODE>passwd</CODE>" programmal változtathatod meg, ha belépsz. Lásd a fájl kézikönyv-
oldalát. Használd a "<CODE>man 5 passwd</CODE>" parancsot ehhez, hogy ne a program, hanem
a fájl kézikönyvét kapd meg.</P>


<H2><A NAME="s11">11. Bash</A></H2>

<P>Ha adsz a "<CODE>login</CODE>"-nak egy érvényes felhasználói név - jelszó párost,
ellenõrzi azt az <CODE>/etc/passwd</CODE> állományban, hogy megtudja melyik shell-t indítsa el neked.
Linux rendszeren ez legtöbbször a "<CODE>bash</CODE>". A "<CODE>bash</CODE>" dolga a parancsaid
értelmezése, illetve gondoskodni ezek végrehajtásáról. Egyszerre felhasználói felület
és programnyelv-értelmezõ (programming language interpreter - a lektor).</P>

<P>Mint felhasználói felület beolvassa parancsaidat, és végre is hajtja ezeket
- amennyiben  un. "belsõ" parancsok, mint például a "<CODE>cd</CODE>"  - illetve megkeresi és futtatja a programot,
- ha az egy un. "külsõ" parancs, mint például a "<CODE>cp</CODE>" vagy a "<CODE>startx</CODE>".
Olyan megszokott dolgokat is csinál, mint például megjegyzi az elõzõleg kiadott parancsokat
valamint kiegészíti a fájlneveket.</P>

<P>Már láttuk a "<CODE>bash</CODE>"-t mûködni, mint
programnyelv-értelmezõ. A szkriptek, amiket az "<CODE>init</CODE>" a rendszer elindításáért futtat,
általában shell szkriptek, amelyeket a "<CODE>bash</CODE>" hajt végre. Egy rendes
programnyelv, a szokásos parancssoros rendszereszközökkel nagyon hatásos
kombinációt alkot, ha tudod mit csinálsz.
Például sokat kellett foltoznom (patch - a ford.)
egy könyvtárnyi forráskódon a minap.
Mindezt egyetlen sorral végre tudtam hajtani:</P>
<P>
<PRE>
for f in /home/greg/sh-utils-1.16*.patch; do patch -p0 &lt; $f; done;
</PRE>
</P>

<P>Ez megvizsgálja az összes olyan fájlt a home könyvtáramban, aminek a neve
"<CODE>sh-utils-1.16</CODE>"-al kezdõdik, és "<CODE>.patch</CODE>"-el végzõdik. Mindezt ciklusban
teszi, beállítja az "<CODE>f</CODE>" változót, majd végrehajtja a
"<CODE>do</CODE>" és "<CODE>done</CODE>" közötti parancsot. Ebben az esetben 11 folt volt,
de könnyen lehetett volna akár 3000 is.</P>

<H2><A NAME="ss11.1">11.1 Beállítás</A>
</H2>

<P>Az <CODE>/etc/profile</CODE> fájl határozza meg a bash viselkedését/mûködését a teljes rendszerre vonatkozóan.
Amit ide beraksz, az hatással lesz mindenkire, aki a bash shellt használja a rendszereden.
Különbözõ dolgokat fog csinálni, például könyvtárakat ad hozzá a "<CODE>PATH</CODE>"-hoz, vagy beállítja a "<CODE>MAIL</CODE>"
környezeti változót.</P>

<P>A billentyûzet alapbeállítása gyakran kívánnivalót hagy maga után.
A readline az, ami ezt irányítja. Ez egy különálló csomag, ami a
parancssori csatolófelületet irányítja, rendelkezésre bocsátja
a parancssori történetet (command history) és fájlnév-kiegészítést,
csakúgy mint néhány fejlettebb sorszerkesztési módot.
Ez bele van szerkesztve a bash-ba. Alapértelmezésként a
readline a home könyvtáradban lévû <CODE>.inputrc</CODE> fájl
használatára van beállítva. Az INPUTRC változó használható arra,
hogy a bash számára felülírjuk ezt. Például a Red Hat 6 rendszerben az
"<CODE>INPUTRC</CODE>" értéke <CODE>/etc/inputrc</CODE> az <CODE>/etc/profile</CODE>
fájlban. Ez azt jelenti, hogy a backspace, delete, home és end
billentyûk mindenkinek nagyszerûen mûködnek.</P>

<P>A bash a teljes rendszerre vonatkozó beállítások beolvasása után
a személyes beállításokat tartalmazó fájlt keresi meg. Ellenõrzi a
home könyvtáradat, <CODE>.bash_profile</CODE>, <CODE>.bash_login</CODE> és <CODE>.profile</CODE>
fájlok után kutatva. Ezek közül az elsõ létezõt futtatja. Ha a bash mûködésén
szeretnél változtatni úgy, hogy a többiekre ne legyen hatással, akkor azt itt tedd meg.
Például sok alkalmazás környezeti változókat használ a mûködésének beállítására.
Nekem van egy "<CODE>EDITOR</CODE>" változóm, ami a "<CODE>vi</CODE>" programra van beállítva,
így én ezt használhatom a Midnight Commanderben (egy kiváló karakteres fájlkezelõ) az õ saját
szövegszerkesztõje helyett.</P>


<H2><A NAME="ss11.2">11.2 Gyakorlatok</A>
</H2>

<P>A bash alapjait könnyû megtanulni. De ne állj meg itt:
hihetetlen mélységei vannak. Tedd szokásoddá, hogy
mindig jobb utat keresel egy dolog véghezvitelére.</P>

<P>Olvass shell szkripteket, keresd meg azokat a részeket, amelyeket nem értesz.</P>

<H2><A NAME="ss11.3">11.3 További információ</A>
</H2>

<P>
<UL>
<LI>Létezik egy "Bash Reference Manual" (Bash referencia kézikönyv) amely részletes, de nehezen érthetõ</LI>
<LI>Van egy  O'Rielly könyv amely a Bash-ról szól, de nem vagyok biztos abban, hogy ez jó</LI>
<LI>én nem ismerek több szabadon használható, jó és naprakész ismertetõt a "bash"-ról. Ha Te igen, kérlek
küld el nekem e-mailben az URL-t</LI>
<LI>  forráskódokra mutató hivatkozásokért látogass el a
<A HREF="http://www.netspace.net.au/~gok/power2bash">Building a Minimal Linux System from Source Code</A>
honlapra</LI>
</UL>
</P>


<H2><A NAME="s12">12. Parancsok</A></H2>

<P>A legtöbb dolgot a bash-ban olyan parancsok segítségével végezheted el, mint a <CODE>cp</CODE>.
Ezen parancsok legtöbbje kis program, bár van néhány - például a "<CODE>cd</CODE>"  - amely be van építve a shell-be.</P>

<P>A parancsok csomagokban vannak, legtöbbjüket a Free Software Foundation (Szabad Szoftver Alapítvány) készíti.
Ahelyett, hogy itt felsorolnám a csomagokat, átirányítalak a
<A HREF="http://www.linuxfromscratch.org">Linux From Scratch HOWTO</A> (Linux a kezdetektõl HOGYAN) honlapra.
Ez egy teljes és frissen tartott listája a Linux rendszerben lévõ csomagoknak,
valamint útmutatás ahhoz, hogyan készítsük el ezeket.</P>


<H2><A NAME="s13">13. Befejezés</A></H2>

<P>Az egyik legjobb dolog a Linuxban - szerény véleményem szerint -
hogy a belsejébe nézhetsz és megtudhatod miként mûködik.
Remélem, legalább annyira élvezed ezt mint én, és ez kis jegyzet segít abban, hogy ezt megtedd.</P>

<H2><A NAME="s14">14. Adminisztráció</A></H2>

<H2><A NAME="ss14.1">14.1 Szerzõi jog</A>
</H2>

<P>Eme dokumentum szerzõi jogait (c) 1999, 2000 Greg O'Keefe birtokolja.
Díjazás nélkül használhatod, másolhatod, terjesztheted vagy módosíthatod a
<A HREF="http://www.gnu.org/copyleft/gpl.html">GNU General Public Licence</A> feltételei szerint.
Kérlek említsd meg nevem, amennyiben ezt a dokumentumot részben vagy egészben felhasználod egy másik dokumentumban.</P>

<H2><A NAME="ss14.2">14.2 Magyar fordítás</A>
</H2>

<P>A magyar fordítást 
<A HREF="mailto:ckoller@mailbox.hu_NO_SPAM">Koller Csaba</A> készítette (2002.11.25).
A lektorálást 
<A HREF="mailto:dacas@freemail.hu_NO_SPAM">Daczi László</A> és 
<A HREF="mailto:laca@janus.gimsz.sulinet.hu_NO_SPAM">Szíjjártó László</A> végezte el (2003.07.18).
Bármilyen fordítással kapcsolatos észrevételt a 
<A HREF="mailto:linuxhowto@sch.bme.hu_NO_SPAM">linuxhowto@sch.bme.hu</A> címre küldjetek.
Eme dokumentum legfrissebb változata megtalálható a 
<A HREF="http://tldp.fsf.hu/index.html">Magyar Linux Dokumentációs Projekt</A> honlapján.</P>

<H2><A NAME="ss14.3">14.3 Honlap</A>
</H2>

<P>A dokumentum legutolsó változatát a
<A HREF="http://www.netspace.net.au/~gok/power2bash">From Powerup To Bash Prompt</A> honlapon találod meg,
csakúgy mint a párját, a "Building a Minimal Linux System from Source Code" leírást.</P>

<P>A francia fordítás a
<A HREF="http://www.freenix.fr/unix/linux/HOWTO/From-PowerUp-To-Bash-Prompt-HOWTO.html">From Powerup To Bash Prompt</A> honlapon található, köszönet érte Dominique van den Broeck-nek.
A japán fordítást Yuji Senda készíti el hamarosan, ha nem lenne a
<A HREF="http://www.linux.or.jp/JF">Japanese Documentation and FAQ Project</A>
honlapon máris.</P>




<H2><A NAME="ss14.4">14.4 Visszajelzés</A>
</H2>

<P>Bármilyen megjegyzésedrõl, kritikádról és ajánlásodról szeretnék hallani,
a dokumentum fejlesztése érdekében. Kérlek küld el ezeket nekem: 
<A HREF="mailto:gcokeefe@postoffice.utas.edu.au">Greg O'Keefe</A>.</P>


<H2><A NAME="acknowledge"></A> <A NAME="ss14.5">14.5 Köszönetnyilvánítások</A>
</H2>

<P>A terméknevek az illetõ cégek által bejegyzett védjegyek, erre
való tekintettel ez itt megemlítésre került.</P>

<P>Szeretnék pár embernek köszönetet mondani azért, hogy segítettek ennek a doksinak a létrehozásában.</P>

<P>
<DL>

<DT><B>Michael Emery</B><DD><P>Emlékeztetett az Unios-ra.</P>
<DT><B>Tim Little</B><DD><P>Néhány ötletet adott az <CODE>/etc/passwd</CODE>-höz.</P>
<DT><B>sPaKr on #linux in efnet</B><DD><P>Rámutatott, hogy a syslogd-nak az <CODE>/etc/services</CODE>-re van szüksége,
és megismertetett a "rolling your own" kifejezéssel annak érdekében,
hogy leírjam egy rendszer forráskódból történõ felépítésének menetét.</P>
<DT><B>Alex Aitkin</B><DD><P>Felhívta a figyelmem Vico-ra, az õ mondása a "verum ipsum factum"
(jelentése: a dolgokat készítésük közben ismerjük meg igazán).</P>
<DT><B>Dennis Scott</B><DD><P>Kijavította a hexadecimális számításaimat.</P>
<DT><B>jdd</B><DD><P>Rámutatott néhány helyesírási hibára.</P>
<DT><B>David Leadbeater</B><DD><P>Közremûködött a kernel démonokról szóló rész megalkotásában.</P>
<DT><B>Dominique van den Broeck </B><DD><P>Lefordította a dokumentumot franciára.</P>
<DT><B>Matthieu Peeters </B><DD><P>Néhány hasznos információt adott a kernel démonokról.</P>
<DT><B>John Fremlin</B><DD><P>Néhány hasznos információt adott a kernel démonokról.</P>
<DT><B>Yuji Senda</B><DD><P>Elkészítette a japán fordítást.</P>
<DT><B>Antonius de Rozari</B><DD><P>Közremûködött a GNU assembler UNIOS változatának létrehozásában
(lásd a források fejezetet a honlapon).</P>
</DL>
</P>

<H2><A NAME="ss14.6">14.6 Változások története</A>
</H2>

<H3>0.8 -> 0.9 (2000 november)</H3>

<P>
<UL>
<LI>Hozzáadtam néhány Matthieu Peeterstõl
és John Fremlin-tõl származó információt a
kernel démonokról és a <CODE>/proc</CODE> fájlrendszerrõl.</LI>
</UL>
</P>

<H3>0.7 -> 0.8 (2000 szeptember)</H3>

<P>
<UL>
<LI> Kivettem a rendszerépítésrõl szóló útmutatót, és egy külön dokumentumba raktam,
ezért néhány hivatkozást beszúrtam.</LI>
<LI> A honlapot átraktam a 
<A HREF="http://learning.taslug.org.au/power2bash">learning@TasLUG</A>-ról,
<A HREF="http://www.netspace.net.au/~gok/power2bash">a saját tárhelyemre</A>.</LI>
<LI> Nem sikerült beraknom a dokumentumba sok - különbözõ emberektõl származó - 
hasznos anyagot. Talán legközelebb :(</LI>
</UL>
</P>

<H3>0.6 -> 0.7</H3>

<P>
<UL>
<LI>nagyobb hangsúly a magyarázaton és kissebb a rendszerépítésen.
A rendszerépítési információt külön fejezetbe raktam
és megrövidítettem.
Az ez iránt érdeklõdõk olvassák el Gerard Beekman "Linux From Scratch" (Linux a kezdetektõl) 
címû mûvét.</LI>
<LI>David Leadbeater néhány magyarázatának hozzáadása</LI>
<LI>pár hivatkozás javítása, és egy hozzáadása az unios letöltéséhez a
learning.taslug.org.au/resources webhelyrõl</LI>
<LI>hivatkozások tesztelése és javítása</LI>
<LI>általános újraírás és csinosítás</LI>
</UL>
</P>

<H3>0.5 -> 0.6</H3>

<P>
<UL>
<LI>a változások történetének hozzáadása</LI>
<LI>néhány teendõ hozzáadása</LI>
</UL>
</P>

<H2><A NAME="ss14.7">14.7 Tennivalók</A>
</H2>

<P>
<UL>
<LI>elmagyarázni mindent a következõkrõl: kernel modulok, depmod, modprobe, insmod
(elõször utána kell néznem!)</LI>
<LI>megemlíteni a /proc fájlrendszert itt</LI>
<LI>docbook sgml formátumba konvertálni a doksit</LI>
<LI>további útmutatók hozzáadása - talán a nagyobb útmutatásokból külön fejezetet készítve -
mint például egy minimális rendszer készítése 
egy linux összeállításból, fájlról-fájlra</LI>
<LI>a makefile hack-et hozzáadni a bash építési útmutatóhoz - lásd az "easter" megjegyzésekben.</LI>
</UL>
</P>

</BODY>
</HTML>
