  The Linux Ftape-HOWTO
  Claus-Justus Heine, <heine@math1.rwth-aachen.de>
  v3.0, agosto 1998

  Questo HOWTO tratta dell'essenziale che si può fare e che non si deve
  fare sotto Linux con il driver ftape per le unità a nastro per con­
  troller floppy.  In particolare tratta della versione piú aggiornata,
  la ftape-4.02, disponibile al momento della stesura di questo docu­
  mento.  Questo HOWTO va inteso come un primo passo di aiuto e fonte di
  informazione.  Il driver ftape interfaccia le unità compatibili
  QIC-40, QIC-80, QIC-3010 e QIC-3020, e le unità Iomega Ditto 2GB e
  Ditto Max.  Gli standard QIC-3010 e QIC-3020 sono anche conosciuti
  come ``Travan'' (TR-2 e TR-3).  Queste unità si collegano al con­
  troller per disco floppy (FFDDCC) che possono essere o un FDC interno o
  parte di alcune unità a nastro per controller floppy su porta paral­
  lela.  Riferirsi alla sezione ``Unità supportate'' per ulteriori
  informazioni.  ftape nnoonn ricopre argomenti riguardanti unità a nastro
  SCSI o QIC-02.  Unità a nastro DAT sono tipicamente (sempre?) connesse
  ad un controller SCSI.  Questo non è l'unico documento HOWTO per
  Linux.  È possibile ottenere una lista degli HOWTO dal Linux HOWTO
  Index, mentre i veri e propri HOWTO possono essere prelevati (via ftp)
  da sunsite.unc.edu:pub/Linux/doc/HOWTO (questo è il sito ``uffi­
  ciale'') o via World Wide Web da the Linux Documentation Project home
  page.  Traduzione di Lorenzo Cappelletti, <L.Cappelletti@POBoxes.com>.
  ______________________________________________________________________

  Indice Generale



  1. Legalese
  2. Storia delle revisioni
  3. Preliminari
     3.1 Altre sorgenti di informazione
     3.2 Contatti
     3.3 Cos'è ftape
     3.4 Note alla traduzione

  4. Come procurarsi e installare ftape
     4.1 Come procurarsi ftape
     4.2 Differenze fra le versioni ftape-2.x, ftape-3.x e ftape-4.x
     4.3 Installare il driver con i kernel v2.0.x e precedenti
     4.4 Installare il driver con kernel v2.1.x e successivi
     4.5 Seguire lo sviluppo del driver ftape
     4.6 Utilizzare assieme ftape e floppy

  5. Cura e manutenzione del nastro e dell'unità a nastro
     5.1 Formattazione
        5.1.1 È possibile formattare nastri sotto Linux?
        5.1.2 Che programmi di formattazione è possibile utilizzare sotto DOS?
     5.2 Ritensionamento
     5.3 Pulizia dell'unità
     5.4 Riparare le cartucce sbobinate [despooled]

  6. Hardware supportato
     6.1 Unità a nastro supportate
     6.2 Controller speciali supportati
        6.2.1 Colorado FC-10, FC-20
        6.2.2 Mountain MACH-2
        6.2.3 Iomega Tape Accelerator II
        6.2.4 Iomega Ditto Dash e altri controller da 2Mbps
        6.2.5 Controller Iomega Ditto EZ PnP
     6.3 Unità a nastro non supportate
     6.4 Utilizzare un'unità a nastro esterna con ftape
     6.5 Schede madri PCI ftape

  7. Archiviare e ripristinare i dati
     7.1 Scrivere un archivio su di un nastro
     7.2 Ripristinare un archivio
     7.3 Provare un archivio
     7.4 Mettere piú di un backup su di un nastro
     7.5 Aggiungere file ad un archivio
     7.6 Eseguire il mount o l'unmount dei nastri

  8. Creare un floppy di partenza in caso di emergenze per ftape
  9. Domande poste frequentemente
  10. FAQ: domande relative alla «Compilazione ed installazione di Ftape»
     10.1 Che versione di Ftape devo utilizzare?
     10.2 Sto riscontrando problemi nel cercare di far girare l'unità XYZ con il kernel 2.0.xx con il driver compilato staticamente.  Come faccio a rimediare?
     10.3 Sto lavorando con Linux/SMP e il sistema si congela quando tento di accedere ai device di Ftape!
     10.4 Perché depmod si lamenta di certi ``undefined symbols'' [simboli indefiniti]?
     10.5 insmod dice che la versione del kernel è sbagliata.
     10.6 insmod dice che kernel 1.2.0 e 1.2.0 differiscono.
     10.7 Provando a compilare Ftape si ottiene l'errore: «modversions.h: no such file or directory».
     10.8 In ogni caso, cosa sono questi ``versioned symbols'' [simboli di versione]?
     10.9 Mi sembra di avere sftape invece di zftape.  Quando lancio il comando ftmt status, ottengo una risposta che, nei documenti di Ftape, corrisponde a sftape (/dev/qft0: Invalid argument).  Perché?
     10.10 La mia scheda DASH/FC-20/Exabyte Accelerator funziona sotto Microsoft Windows, ma ottengo un errore di tipo ``unità non trovata'' in var/log/messages/ quando provo ad utilizzarlo sotto Linux.
     10.11 I trasferimenti DMA di Ftape danno errori di ECC.
     10.12 Aiuto!  Sto avendo dei ``dmaalloc() failed'' nel mio file di syslog.
     10.13 Syslogd lavora in continuazione quando gira Ftape.
     10.14 Come posso cambiare il trace-level?
     10.15 Sto avendo problemi con Ftape.  Sto utilizzando l'ultima versione di Ftape prelevata dall'home-page di Ftape e credo di aver individuato un bug vero.  Cosa devo fare?

  11. FAQ: domande relative all'«utilizzo di Ftape»!
     11.1 Quanto va veloce Ftape?
     11.2 Quando scrivo su alcuni dei miei nastri, sembra che perda un sacco di tempo a ``lustrarsi le scarpe'' o nel riposizionamento, invece di trasferire dati.  C'è qualcosa che non va nel mio sistema?
     11.3 Devo far ripartire il mondo DOS per formattare i nastri?
     11.4 È possibile formattare nastri Ditto 2GB con ftape?
     11.5 È possibile formattare nastri Ditto Max o Max Pro con ftape?
     11.6 Ftape rileva piú settori danneggiati con nastri QIC-3020 di quanto non faccia DOS.
     11.7 Non ci sono problemi se non sento il nastro muoversi quando impartisco un comando fsf o bsf con mt?
     11.8 Perché il mio programma di backup XYZ si lamenta di errori di tipo ``Invalid argument'' [argomento non valido]?
     11.9 Errori I/O e FDC: alcune spiegazioni.
     11.10 Perché ottengo errori del tipo «/dev/qft0: No such device» [/dev/qft0: nessun device come questo]?
     11.11 Ottengo un ``device busy'' [periferica occupata] quando eseguo backup multipli su di un nastro utilizzando alcuni script.
     11.12 Come faccio a... con tar?
     11.13 Che dimensione per i blocchi devo utilizzare con tar?
     11.14 Dove posso trovare i binari, i sorgenti e le pagine man di tar, mt, cpio e dd?
     11.15 Se utilizzo la compressione dell'unità a nastro, è sbagliato sfruttare anche la compressione di zftape.  O sarebbe meglio non utilizzare la compressione dell'unità e lasciare che faccia tutto zftape?
     11.16 Com'è la compressione di zftape a confronto di quella, diciamo, di gzip -9?
     11.17 Non utilizzo la compressione, ma sento che l'interfaccia zftape se ne sta andando.  Cosa posso fare?
     11.18 Ftape dice «This tape has no 'Linux raw format'» [questo nastro non è nel ``formato elementare Linux''].
     11.19 Posso scambiare nastri con qualcuno che utilizza il DOS?
     11.20 Come funziona mt eom quando si comincia a sovrascrivere un nastro dalla metà?
     11.21 Quando eseguivo dei backup prima di utilizzare taper, sotto ftape 2.0.29 la mia unità non supportava l'fsf, mentre sotto il nuovo zftape lo supporta.  Perché dovrebbe e cos'è esattamente l'fsf?
     11.22 Qual'è esattamente la differenza fra ftape e zftape?
     11.23 Qual'è la differenza fra una periferica riavvolgente ed una non-riavvolgente?
     11.24 C'è qualcuno che potrebbe dirmi come utilizzare mt per riavvolgere la mia unità TR-3 dopo aver registrato un archivio con zftape, cosí da poterlo verificare?
     11.25 ``Non-riavvolgente'' significa che «non si riavvolge automaticamente», giusto?  Non sta ad indicare che sotto nessuna circostanza non si riavvolgerà, vero?  Ho provato ad utilizzare /dev/zqft0 ed il nastro è stato subito riavvolto.
     11.26 Qual'è la differenza fra ciò che mt considera un record e ciò che considera un file?
     11.27 Riutilizzare nastri con zftape senza riformattare il nastro.
     11.28 Questo script permette di ottenere un semplice indice di un pacchetto zftape utilizzando lo ioctl TIOCVOLINFO.

  12. FAQ: Domande relative alle «Unità e nastri»
     12.1 Chi sono i buoni produttori di nastri Travan?
     12.2 Dove posso ottenere gli standard QIC?
     12.3 L'unità Iomega Ditto 2GB è supportata?
     12.4 L'unità Iomega Ditto Max è supportata?
     12.5 L'unità Iomega Ditto Max Pro è supportata?

  13. FAQ: Miscellanea!
     13.1 Come ci si iscrive alla mailing-list di Ftape?
     13.2 Come uscire dalla mailing-list di Ftape?
     13.3 Link ad informazioni correlate.

  14. Eseguire il debug del driver di ftape
     14.1 Il kernel/ftape si pianta quando faccio...  Questo è un baco?
     14.2 Va bene, è un baco... cioè, una caratteristica.  Come faccio a spedire un rapporto?

  15. Contributi


  ______________________________________________________________________

  11..  LLeeggaalleessee


  L'ftape-HOWTO per Linux può essere riprodotto e ditribuito, per intero
  o in parte, ferme restando le seguenti condizioni:



        Copyright (c) 1993-1996 by Kai Harrekilde-Petersen Email:
       khp@dolphinics.no

       Copyright (c) 1996-1997 by Kevin Johnson Email: kjj@pobox.com

       Copyright (c) 1998 by Claus-Justus Heine Email:
       heine@math1.rwth-aachen.de



  Il ``Linux ftape-HOWTO'' è un documento libero; è possibile riprodurlo
  e/o modificarlo sotto le condizioni della versione 2 (o, a seconda
  della propria opinione, di ogni altra versione successiva) della GNU
  General Public License come pubblicata dalla Free Software Foundation.

  Questo HOWTO è distribuito nella speranza che risulti utile, ma SENZA
  ALCUNA GARANZIA; neppure di COMMERCIABILITÀ o IDONEITÀ AD UN
  PARTICOLARE SCOPO. È possibile ridistribuire copie di GNU Ftape-HOWTO
  nei termini della GNU General Public License.

  L'autore incoraggia la distribuzione su larga scala di questo
  documento per usi personali o commerciali, fermo restando che il
  copyright di cui sopra rimanga intatto e che l'utilizzo sia conforme
  alla GNU General Public License.  In sostanza è"possibile copiare e
  ridistribuire questo documento liberamente o mediante compenso.
  Nessun permesso esplicito è richiesto dall'autore per la riproduzione
  di questo documento con qualsiasi mezzo, fisico o elettronico.

  Da notarsi che lavori derivati e traduzioni di questo documento devono
  aderire alla GNU General Public License e il copyright originale deve
  rimanere intatto.  Se si contribuisce con nuovo materiale a questo
  documento, si deve rendere il codice sorgente (cioè il sorgente SGML)
  disponibile per le proprie revisioni.  Si prega di rendere disponibili
  revisioni e aggiornamenti direttamente all'autore: contattare
  <heine@math1.rwth-aachen.de> a mezzo posta elettronica.  Questo
  permetterà all'autore di unire gli aggiornamenti e di rendere
  disponibili revisioni organiche alla comunità Linux.

  L'autore incoraggia i distributori di software per Linux con ogni
  mezzo di utilizzare questo HOWTO come installazione e guida per
  l'utente.  Dato il copyright di cui sopra, è resa libera la stampa e
  la distribuzione di copie di questo documento con il proprio software.
  Cosí facendo si potrebbe includere un breve ``supplemento
  all'installazione'' per la propria release o modificare le sezioni
  rilevanti di questa opera per riflettere il proprio prodotto.

  All'autore (ed al traduttore) farebbe piacere venire a conoscenza di
  ogni progetto di pubblicazione e distribuzione commerciale di questo
  HOWTO.  In questo modo possiamo assicurare un aggiornamento continuo
  con l'uscita delle nuove revisioni e, se una nuova versione fosse
  dietro l'angolo, ritardare la pubblicazione dell'HOWTO finché la nuova
  revisione non viene reasa disponibile.

  Se si sta distribuendo questo HOWTO commercialmente, donazioni,
  royalty e/o copie stampate sono particolarmente apprezzate dall'autore
  (e dal traduttore).  Contribuendo in questo modo, si dimostra il
  supporto per il ``free software'' e l'(Italian) Linux Documentation
  Project.

  Per domande o commenti, si prega di contattare l'autore all'indirizzo:


        heine@math1.rwth-aachen.de



  oppure il traduttore all'indirizzo:


        lency@dei.unipd.it



  Ricordo che non ci e` consentito rimuovere il testo originale inglese
  della licenza e che questo non ha alcun valore legale ma puramente
  informativo. Ecco quindi la versione originale.

  The Linux ftape-HOWTO is a free document; you may reproduce and/or
  modify it under the terms of version 2 (or, at your option, any later
  version) of the GNU General Public License as published by the Free
  Software Foundation.

  This HOWTO is distributed in thg hope that it will be useful, but
  WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  General Public License for more details.

  The author encourages wide distribution of this document for personal
  or commercial use, provided that the above copyright notice remains
  intact and the provisions of the GNU General Public License are
  adhered to.  The summary is that you may copy and distribute this
  document free of charge, or for a profit.  No explicit permission is
  required from the author for reproduction of this document in any
  medium, physical or electronic.

  Note that derivative works and translations of this document must be
  placed under the GNU General Public License, and the original
  copyright notice must remain intact.  If you have contributed new
  material to this document, you must make the source code (e.g., SGML
  source) available for your revisions.  Please make revisions and
  updates available directly to the author: Contact heine@math1.rwth-
  aachen.de via Internet e-mail.  This will allow the author to merge
  updates and provide consistent revisions to the Linux community.

  The author encourages distributors of Linux software in any medium to
  use the HOWTO as an installation and user guide.  Given the copyright
  above, you are free to print and distribute copies of this document
  with your software.  If doing so, you may wish to include a short
  ``installation supplement'' for your relecse, or modify the relevant
  sections of this book to reflect your product.

  The author would like to know of any plans to publish and distribute
  this HOWTO commercially.  In this way, we can ensure that you are kept
  up-to-date with new revisions.  And, should a new version be right
  around the corner, you might wish to delay your publication of the
  HOWTO until it is available.

  If you are distributing this HOWTO commercially, donations, royalties,
  and/or printed copies are greatly appreciated by the author.
  Contributing in this way shows your support for free software and the
  Linux Documentation Project.

  If you have questions or comments, please contact the author at

  heine@math1.rwth-aachen.de


  22..  SSttoorriiaa ddeellllee rreevviissiioonnii



     vveerrssiioonnee 33..00 ((aaggoossttoo,, 11999988))

        ·  aggiunte alla lista dell'hardware supportato;

        ·  nuova sezione sulle differenze fra le versioni di ftape;

        ·  puntatore all'_F_t_a_p_e_-_F_A_Q e all'_F_t_a_p_e _m_a_n_u_a_l;

        ·  aggiornamento all'ftape-4.02;

        ·  aggiunte alle FAQ;

        ·  aggiornate tutte le URL.


     vveerrssiioonnee 22..00 ((mmaarrzzoo 1155,, 11999977))

        ·  aggiornamento all'ftape v2.11 e v3._x_x;

        ·  molti aggiornamenti.


     vveerrssiioonnee 11..99 ((sseetttteemmbbrree 2200,, 11999966))

        ·  nuovi manutentori di ftape e dell'HOWTO;

        ·  alcune correzzioni minori di formattazione e grammatica;

        ·  aggiornamento per Linux v2.0;

        ·  inizio dell'integrazione di alcune informazioni su ftape di
           Andrew Martin.


     vveerrssiioonnee 11..88 ((mmaaggggiioo 2222,, 11999966))

        ·  modifica del copyright in GNU GPL v2;

        ·  l'indirizzo e-mail del manutentore è cambiato;

        ·  aggiornamento a ftape-2.08;

        ·  ftape è ora una parte della distribuzione del kernel.


     vveerrssiioonnee 11..77..11 ((ffeebbbbrraaiioo 1133,, 11999966))

        ·  aggiornamento a ftape-2.06b.


     vveerrssiioonnee 11..77 ((ggeennnnaaiioo 2288,, 11999966))

        ·  aggiornamento a ftape-2.06 e modules-1.3.57.


     vveerrssiioonnee 11..66..22 ((ggeennnnaaiioo 2233,, 11999966))

        ·  aggiunta l'unità Connor TST3200R;

        ·  aggiornate informazioni su FDC a 2Mbps.


     vveerrssiioonnee 11..66..11 ((ggeennnnaaiioo 1166,, 11999966))

        ·  Correzioni minori.


     vveerrssiioonnee 11..66 ((ggeennnnaaiioo 1100,, 11999966))

        ·  nuovo manutentore di ftape;

        ·  aggiornamento a v2.05;

        ·  aggiunte nuove unità.


  33..  PPrreelliimmiinnaarrii



  33..11..  AAllttrree ssoorrggeennttii ddii iinnffoorrmmaazziioonnee



     ffttaappee vveerrssiioonnee 33
        ftape-3._x viene fornito con un proprio manuale contenuto nel
        pacchetto ftape-3.04d e disponibile presso i siti abituali.
        Vedere ``Procurarsi Ftape''.


     ffttaappee vveerrssiioonnee 44
        Anche ftape-4._x ha un pacchetto di documentazione chiamato
        ftape-doc disponibile presso gli stessi siti.  Questo HOWTO,
        allora, focalizzerà la sua attenzione anche sull'ftape-4._x ed è
        inteso come un punto di partenza verso la documentazione
        disponibile.  Vedere ``Procurarsi Ftape''.


     ffttaappee--ttoooollss
        Il pacchetto ftape-tools (che contiene preziose utility per
        ftape) viene fornito con un proprio manuale.  Vedere
        ``Procurarsi Ftape''.


     FFttaappee--FFAAQQ
        Le Ftape-FAQ sono incluse testualmente in questo manuale, mentre
        versioni piú recenti posso essere visionate all'url
        http://www.correct.nl/~ftape.



  33..22..  CCoonnttaattttii


  Il manutentore del codice sorgente per l'ftape è Claus Heine
  <heine@math1.rwth-aachen.de>.  Possiede una pagina web all'indirizzo
  http://www-math.math.rwth-aachen.de/~LBFM/claus/ftape/.

  Per problemi o domande su ftape è possibile mandare un messaggio alla
  mailing-list di Linux Tape utilizzando l'indirizzo linux-
  tape@vger.rutger.edu (vedere ``Seguire lo sviluppo di ftape'' piú
  avanti).  C'era anche un newsgroup che copiava i messaggi della
  mailing-list, ma è sparito un po' di tempo fa.

  Anch'io utilizzo un'unità a nastro (è il solo modo con cui eseguo dei
  backup con Linux :-).  Esito, però, a dare raccomandazioni su quale
  hardware comprare.  Riferirsi alla sezione ``Unità supportate'' e
  ``Unità non supportate'' per una lista di unità supportate e non
  supportate.

  È meglio provare ad inviare un riassunto dei problemi riscontrati
  corredati da qualche rimedio, anche se solo parziale.  È gradito un
  messaggio contenente una copia di tali rimedi anche alla mailing-list
  di Linux Tape raggiungibile all'indirizzo <linux-
  tape@vger.rutgers.edu>, cosicché possano essere aggiunti all'HOWTO e/o
  alle FAQ.

  Nel caso questo manuale facesse parte di una distribuzione su carta o
  su CD-ROM, è conveniente dare un'occhiata alla pagina principale
  del Linux Documentation Project, o via ftp all'indirizzo
  ftp://sunsite.unc.edu:/pub/Linux/doc/HOWTO, per vedere se esiste una
  versione piú recente.  Questo potrebbe potenzialmente far risparmiare
  un sacco di problemi.

  Nel caso mi si volesse spedire un messaggio, gradirei che venisse
  inserita la stringa ftape nella linea di ``Subject:''.  Questo aiuterà
  ad assicurare che il messaggio non venga perso.  Comunque è meglio
  scrivere alla mailing-list di Linux Tape <linux-
  tape@vger.rutgers.edu>, invece di contattare me direttamente.



  33..33..  CCooss''èè ffttaappee


  ftape è un driver che controlla vari tipi di periferiche a nastro di
  basso costo da collegarsi al controller dell'unità floppy.

  ftape non è un programma di backup; è un driver di periferica che
  permette di utilizzare l'unità a nastro (cosí come il driver per la
  SoundBlaster 16 permette di utilizzare la scheda sonora) attraverso il
  file di periferica /dev/[n]qft[0-3].

  ftape fu originariamente scritto da Bas Laarhoven <bas@vimec.nl>, con
  un «piccolo aiuto da parte dei suoi amici» per organizzare l'ECC
  (Error Correcting Code [codice per la correzione d'errore]).  ftape è
  protetto da copyright da parte di Bas sotto la GNU General Public
  License, che, in parole povere, dice: «vai avanti e condividi questo
  con il mondo, basta che non impedisci ad altre persone di copiarselo
  ulteriormente».

  ftape è stato sottoposto a diversi cambiamenti da allora. Mentre la
  serie Linux-2.0._x del kernel contiene ancora l'ftape-2.08, la serie
  v2.1._x e presto la serie v2.2.*  arriveranno con l'ftape-3._x (magari
  anche con la ftape-4.02, ma ciò non è ancora chiaro nel momento in cui
  sto scrivendo), che differisce in alcuni punti dal driver ftape-2._x.
  A partire dalla versione 3.00 il driver ftape è stato mantenuto da me
  (Claus-Justus Heine); è stato cambiato e migliorato in diversi ambiti
  ed è stato aggiunto supporto per nuovo hardware.

  ftape è abbastanza stabile e lo è stato per diverso tempo fino ad ora.
  È sufficientemente sicuro per backup critici (ma è sempre una buona
  idea controllare i propri backup, cosí da evitare spiacevoli sorprese
  prima o poi).

  ftape supporta tanto le unità conformi allo standard QIC-117 e ad uno
  degli standard QIC-80, QIC-40, QIC-3010 e QIC-3020, quanto le unità
  Iomega Ditto 2GB e Ditto Max, che non sono piú strettamente conformi
  agli standard QIC.

  ftape può pilotare unità connesse all'FDC interno cosí come certe
  unità a nastro per porta parallela.

  ftape non supporta né le unità QIC-02, IDE (ATAPI), né le unità SCSI.
  Le unità SCSI sono accessibili come /dev/[n]st[0-7] e sono supportate
  dal kernel attraverso i driver SCSI.  In caso di necessità, per le
  unità a nastro SCSI è possible leggere lo SCSI-HOWTO.  Le unità a
  nastro ATAPI sono supportate dal kernel a partire dalla versione
  1.3.46.  Vedere la sezione ``Unità supportate'' e ``Unità non
  supportate'' per una lista delle unità supportate e non supportate.



  33..44..  NNoottee aallllaa ttrraadduuzziioonnee


  Nel testo originale si fa pesantemente riferimento a termini quali
  ``floppy tape drive'', ``device driver'' ed ``ftape driver'' per
  riferirsi alle varie parti hardware e software che compongono un
  sistema di backup in ambiente Linux.  Per non generare confusione,
  nella traduzione si è cercato di tenere ben distinte le varie
  componenti utilizzando i seguenti termini:

     UUnniittàà aa nnaassttrroo ppeerr ccoonnttrroolllleerr ffllooppppyy
        Il termine _f_l_o_p_p_y _t_a_p_e _d_r_i_v_e_r sta ad indicare quelle unità a
        nastro da connettersi al controller per floppy.  Nel testo si
        utilizzeranno sinonimi piú brevi quali _u_n_i_t_à _a _n_a_s_t_r_o o _u_n_i_t_à.


     DDrriivveerr ftape
        Si tratta del software vero e proprio, quello in grado di
        tradurre le richieste da parte dei programmi di backup in
        sequenze di comandi interpretabili dall'unità a nastro.
        Sinonimi usati correntemente nel testo sono _d_r_i_v_e_r, ftape,
        ftape-2._x, ftape-3._x ed ftape-4._x.


     FFiillee ddii ppeerriiffeerriiccaa
        Il termine _d_e_v_i_c_e _d_r_i_v_e_r indica i file speciali contenuti nella
        directory /dev attraverso i quali il driver ftape dialoga con
        l'unità.  Sinonimi di questo termine sono _d_e_v_i_c_e e _p_e_r_i_f_e_r_i_c_a.


  Per aiutare chi si avvicina per la prima volta a questo tipo di
  periferiche e per non disorientare chi, invece, ha già familiarità con
  esse, si è deciso di tradurre tutti i termini tecnici relativi al
  mondo delle unità a nastro, ma di lasciare indicato fra parentesi
  quadre il relativo termine in lingua inglese.

  Commento a parte merita la sezione sulla compatibilità hardware.  Dal
  testo originale si può comprendere come sia il risultato di un _c_o_l_l_a_g_e
  di informazioni provenienti da diverse persone.  Ho fatto del mio
  meglio per cercare di dare un significato alle frasi che compongono la
  sezione.



  44..  CCoommee pprrooccuurraarrssii ee iinnssttaallllaarree ffttaappee



  44..11..  CCoommee pprrooccuurraarrssii ffttaappee


  Le versioni v.2.0._x del kernel includono la versione 2.08 di ftape.
  Consiglio, pertanto, di procurarsi l'ultima versione del pacchetto
  contenete il codice sorgente completo per ftape.  È una versione piú
  nuova, contiene file che non sono contenuti nella distribuzione del
  kernel v2.0._x e include documentazione molto migliore su come
  installare ftape.  Le versioni di kernel v2.1._x a sucessive contengono
  la versione 3.04 di ftape.


  È consigliabile scaricare l'ultima versione stabile di ftape, cioè la
  4.02 nel momento in cui sto scrivendo, disponible presso

  http://www-math.math.rwth-aachen.de/~LBFM/claus/ftape/archives.html


  cosí come presso

  ftp://sunsite.unc.edu/pub/Linux/kernel/tapes/.

  Probabilmente è opportuno procurarsi anche i pacchetti ftape-doc e
  ftape-tools disponibili dagli stessi siti.

  Se, tuttavia, si vuole fare uso dell'ftape-2.08 che viene fornito con
  i kernel v2.0._x, si tenga presente che si è in possesso di una
  versione del driver veramente datata, che non supporta correttamente
  le unità QIC-3020 a 2Mbps, né le unità Ditto 2GB, né le unità Ditto
  Max o qualsiasi tipo di unità su porta parallela.  La sezione ``Unità
  supportate'' fornisce dettagliate informazioni a proposito di quali
  versioni di ftape supportano determinati hardware.


  44..22..  DDiiffffeerreennzzee ffrraa llee vveerrssiioonnii ffttaappee--22.. xx ,, ffttaappee--33.. xx  ee ffttaappee--44.. xx


  ftape-3._x e ftape-4._x fanno uso di un'interfaccia per file system che
  fu implementata per un gruppo di release chiamato zftape.  In effetti
  il modulo che implementa l'interfaccia VVFFSS (Virtual File System) di
  ftape-3._x e anche di ftape-4._x è chiamata zftape.o e il suo codice
  sorgente C all'interno dell'albero del kernel si trova in
  [/usr/src/linux/]drivers/char/ftape/zftape/.

  ftape-2._x (cioè la versione contenuta ancora nel kernel v2.0._x) usa
  un'altra interfaccia di file system che fu implementata dall'autore
  originale di ftape Bas Larhoven.


     MMaarrccaattoorrii ddii ffiillee
        La differenza concettuale fra l'ftape-2._x e le versioni
        successive di ftape sta nel modo in cui i _m_a_r_c_a_t_o_r_i _d_i _f_i_l_e sono
        implementati.

        Le _u_n_i_t_à _a _n_a_s_t_r_o _p_e_r _c_o_n_t_r_o_l_l_e_r _f_l_o_p_p_y non hanno dei veri
        marcatori di file. (-- I mmaarrccaattoorrii ddii ffiillee sono usati per
        distinguere fra differenti backup se sono stati scritti piú
        backup sul nastro.  Le unità SCSI e QIC-150 hanno _v_e_r_i marcatori
        di file, cioè fra due differenti backup ci sono delle regioni
        sul nastro nelle quali vengono scritti dati speciali in modo
        tale che la logica dell'unità possa rilevare tali marcatori
        quando il nastro viene avvolto a velocità (possibilmente+
        elevata sopra tali marcatori.--) Poiché l'obiettivo
        dell'interfaccia del file system di ftape fu fin dal principio
        quello di provvedere ad un'interfaccia che potesse essere usata
        con le usuali utility per nastri presenti su sistemi Unix e
        simili (per esempio mt), gli sviluppatori di ftape cominciarono
        ad emulare i marcatori di file salvando le posizioni del nastro,
        che indicavano dove doveva trovarsi il marcatore del file, in
        determinati campi dei segmenti d'intestazione. (-- sseeggmmeennttoo
        dd''iinntteessttaazziioonnee [header segment] si riferisce ad una regione
        all'inizio del nastro grande due volte 29kB, che contiene alcune
        informazioni importanti circa il formato e la dimensione del
        nastro, e alcune informazioni di stato.--)

        Però gli standard QIC definivano già una regione speciale nella
        quale salvare tali informazioni, il cosiddetto sseeggmmeennttoo ddeellllaa
        ttaabbeellllaa ddii vvoolluummee [volume table segment].  A partire
        dall'ftape-3._x questo _s_e_g_m_e_n_t_o _d_e_l_l_a _t_a_b_e_l_l_a _d_i _v_o_l_u_m_e viene
        sfruttato al posto dei campi di dati non utilizzati nel segmento
        d'intestazione.  Come risultato è possibile usare la propria
        cartuccia con differenti sistemi operativi nel senso che il
        programma di backup per Win o DOS capiranno che certe regioni
        del nastro sono già occupate da dati, ed ftape-3._x e successivi
        rilevereranno le regioni utilizzate dai programmi per DOS e Win.
        Ciò nonostante non è possibile estrarre un backup DOS sotto
        Linux, né estrarre un volume scritto da ftape sotto DOS, fatto
        salvo il caso in cui ci si sia cimentati nella scrittura di un
        software apposito per conto proprio.


     IInntteerrffaacccciiaa IIOOCCTTLL
        Ci sono alcune differenze nell'interfaccia IIOOCCTTLL (-- Questa
        interfaccia di _c_o_n_t_r_o_l_l_o _I_/_O è utilizzata, per esempio, da mt
        per riavvolgere il nastro, saltare al marcatore di file
        successivo o eseguire ogni altra operazione sul nastro.--) fra
        ftape-2._x e ftape-3._x e successivi.  Una dettagliata descrizione
        può essere trovata nell'ftape-manual contenuto nel pacchetto
        ftape-doc.  Vedere la sezione ``Come procurarsi Ftape''.


     FFoorrmmaattttaazziioonnee
        La formattazione delle cartucce è supportata ssoolloo con ftape-3.x
        e successivi.  Conviene procurarsi il pacchetto ftape-tools che
        contiene il programma ftformat che si interfaccia con il driver
        per formattare le cartucce.  Vedere la sezione ``Come procurarsi
        Ftape''.  Il pacchetto ftape-tools viene distribuito con
        documentazione (piú o meno) dettagliata, cosí il caso della
        formattazione delle cartucce non viene trattato in questo
        documento.


     CCoommpprreessssiioonnee
        ftape-3._x supportava una compressione software ``al volo'',
        trasparente all'utente.  Questa caratteristica (o _b_a_c_o) è
        sparita con ftape-4._x poiché rendeva veramente molto difficili
        ulteriori miglioramenti riguardo all'affidabilità dei backup.
        Questo significa che ftape-4._x viene distribuito senza supporto
        alla compressione.

        Nonostante questo una ddeeccoommpprreessssiioonnee di archivi compressi
        prodotti con ftape-3._x èè supportata per evitare che programmi di
        backup pre-esistenti falliscano là dove un filtro a livello
        utente non è sufficiente a preservare la compatibilità.  Si
        pensi, per esempio, a taper che chiama autonomamente gli ioctl
        MTIOC, invece di affidarsi al programma mt per eseguire le
        operazioni sul nastro.

  L'ftape-manual presente nel pacchetto ftape-doc contiene informazioni
  molto piú dettagliate riguardanti l'interfaccia del file system di
  ftape, cosí come contiene note implementative che esulano dallo scopo
  di questo HOWTO.  Vedere ``Come procurarsi Ftape'' per informazioni su
  come ottenere il manuale.



  44..33..  IInnssttaallllaarree iill ddrriivveerr ccoonn ii kkeerrnneell vv22..00.. xx  ee pprreecceeddeennttii


  La seguente sezione fornisce alcune utili informazioni
  sull'installazione della versione 4._x nnoonn ancora distribuita con
  l'albero dei sorgenti del kernel, ma che deve essere scaricata
  separatamente.  Vedere la sezione ``Procurarsi ftape'' sopra.

  Una volta scaricato il codice sorgente (probabilmente
  ftape-4.02-tar.gz), dare il comando tar dopo aver scelto in quale
  directory riporre il codice sorgente.  Io consiglio /usr/src/ o ~/src.
  Quando il file tar viene estratto, tutto il suo contenuto finirà in
  una subdirectory ftape-4.02, cosicché alla fine si otterrà,
  proseguendo con l'esempio dato, qualcosa del tipo /usr/src/ftape-4.02
  o ~/src/ftape-4.02.

  NNOOTTAA:: non è possibile compilare ftape-4.02 nel kernel v2.0._x.  Invece
  bisogna configurare il kernel affinché nnoonn compili il driver ftape e
  seguire le istruzioni per l'installazione contenute nella
  distribuzione ftape-4.02 e installare l'ftape-4.02 come modulo.

  Leggere il file README.  La lettura di README è necessaria.  Si trova
  in cima all'albero, tanto per dire.  Se ci sono file specifici che
  README dice di leggere, conviene farlo.  Renderà il procedimento molto
  meno complicato.

  NNoonn procedere con la compilazione del pacchetto finché non sono stati
  letti i file README appropriati ed il file INSTALL.

  Dopodiché è necessario editare il file MCONFIG e configurare il
  pacchetto secondo le proprie specifiche hardware.  Il file MCONFIG
  contiene molte spiegazione, tanto che dovrebbe essere facile seguirlo.

  Ciò nonostante molte opzioni della configurazione hardware possono
  essere specificate attraverso l'impostazione dei parametri letti nella
  fase caricamento del modulo, cosí molti prametri specificati nel file
  MCONFIG possono mantenere le impostazioni di default senza che ci sia
  il bisogno di ricompilare il driver per cambiare l'indirizzo di I/O o
  il valore d'interrupt.  Il file INSTALL ed il file modules/insert
  contengono esempi su come specificare i parametri appropriati del
  modulo durante il suo caricamento da parte del kernel, quindi non mi
  inoltrerò in maggiori dettagli.

  Se si sta usando un kernel linux-v1.3._x, sarebbe opportuno considerare
  un aggiornamento alla versione 2.0._x.  La versione 1.3._x era la
  release di sviluppo antecedente la release di produzione v2.0._x.



  44..44..  IInnssttaallllaarree iill ddrriivveerr ccoonn kkeerrnneell vv22..11..xx ee ssuucccceessssiivvii


  (* Forse ftape-4.02 verrà incluso nel kernel v2.2._x, ma questo non è
  chiaro durante la stesura di questo documento.  Questo HOWTO verrà
  rivisto appropriatamente quando ciò sarà chiaro.  Cosí, per ora, è
  necessario riferirsi alla sezione precedente ``Installare il driver
  con i kernel v2.0.x e precedenti'' ed evitare il contenuto di questa
  sezione.  *)


  Il kernel di Linux v2.1._x e successivi contiene già ftape-4._x cosicché
  non è necessario scaricare il pacchetto per il driver del kernel
  ftape-4._x.

  ftape-4._x, in quanto incluso nelle versioni v2.1._x del kernel, può
  essere completamente configurato utilizzando i menú di configurazione
  del kernel (o con make menuconfig o con make xconfig).  È anche
  disponibile un aiuto in linea che documenta l'impostazione di ogni
  parametro che starò a ripetere qui.

  Le impostazioni dei vari parametri disponibili al momento del boot o
  del caricamento del modulo sono spiegati nel file

  [/usr/src/linux/]Documentation/ftape.txt

  delle distribuzioni Linux-v2.1._x e successive del kernel.



  44..55..  SSeegguuiirree lloo ssvviilluuppppoo ddeell ddrriivveerr ffttaappee


  Nel caso si voglia seguire lo sviluppo del driver ftape, è possibile
  iscriversi alla mailing-list ``Linux Tape'' <linux-
  tape@vger.rutgers.edu>.  Per fare questo, spedire una e-mail che
  contenga ``subscribe linux-tape'' _n_e_l _c_o_r_p_o del messaggio a
  <majordomo@vger.rutgers.edu>.  Ad iscrizione avvenuta, verrà spedito
  un messaggio di benvenuto nel quale viene spiegato come postare
  effettivamente i messaggi e come uscire dalla lista.  Si prega di
  ssaallvvaarree qquueessttoo mmeessssaaggggiioo iinn uunn ppoossttoo ssiiccuurroo.

  Vorrei far notare che io non ho, ripeto NNOONN HHOO, alcun potere speciale
  concernente questa mailing-list.  Se ci si trova nei guai con la
  lista, non serve prendersi il disturbo per dirmelo.  Posso solo
  stringermi nelle spalle e risponderti con un po' della mia simpatia
  (ma questo non ti permetterà di uscire dalla lista).



  44..66..  UUttiilliizzzzaarree aassssiieemmee ffttaappee  ee ffllooppppyy


  Se si fa utilizzo dell'unità a nastro per controller floppy con un FDC
  standard, l'unità floppy e l'unità a nastro non possono essere
  utilizzate assieme, in quanto condividono lo stesso hardware, l'FDC,
  ed il floppy ed ftape non comunicano l'uno con l'altro.  Cosí, se è
  montato un floppy e si prova ad accedere all'unità a nastro, ftape si
  lamenterà del fatto che non riesce ad impadronirsi dell'IRQ6 e
  terminerà.  Questo diventa un problema vero e proprio quando si crea
  un disco d'emergenza da utilizzare con ftape.  La soluzione consiste
  nel caricare il disco di boot/root in un ramdisk e poi smontare il
  floppy, oppure avere due controller floppy.



  55..  CCuurraa ee mmaannuutteennzziioonnee ddeell nnaassttrroo ee ddeellll''uunniittàà aa nnaassttrroo



  55..11..  FFoorrmmaattttaazziioonnee


  Prima che un nastro possa essere utilizzato, deve essere formattato.
  Il processo di formattazione distribuisce l'informazione dei settori
  sul nastro.  Altre interfaccie a nastro non richiedono tipicamente la
  formattazione.  La ragione per la quale le unità a nastro per
  controller floppy la richiedono, risiede nel fatto che hanno bisongo
  di essere visti come dei floppy (piuttosto rozzo, ma che caspita...
  funziona :-)???



  55..11..11..  ÈÈ ppoossssiibbiillee ffoorrmmaattttaarree nnaassttrrii ssoottttoo LLiinnuuxx??


  Sí, è possibile, se si utilizza ftape-3.04d o superiori.  Per
  formattare una cartuccia c'è bisogno di uno strumento a livello utente
  chiamato ftformat come quello contenuto nella distribuzione di ftape-
  tools (vedere la sezione ``Procurarsi ftape'').

  Il pacchetto ftape-tools viene distribuito con un proprio manuale,
  cosí non c'è bisogno che ripeta qui come utilizzare ftformat.

  55..11..22..  CChhee pprrooggrraammmmii ddii ffoorrmmaattttaazziioonnee èè ppoossssiibbiillee uuttiilliizzzzaarree ssoottttoo
  DDOOSS??


  I seguenti si sa che funzionano:


  ·  il software (tape.exe) della Colorado Memory System

  ·  Conner Backup Basics v1.1 e tutte le versioni Windows

  ·  Norton Backup

  ·  QICstream versione 2

  ·  Tallgrass FileSecure v1.52

  ·  Escom Powerstream 3.0 (qs3.exe -- QICstream v3?)

  Questi programmi è risaputo che contengono piú o meno errori:


  ·  Conner Backup Basics 1.0

  ·  il programma per nastri Colorado Windows

  ·  CP Backup (spreca spazio su nastro, ma, a parte questo, va bene)

  Come regola generale, la maggior parte del software sotto DOS dovrebbe
  funzionare.  Il Conner Backup Basics v1.0 ha un parametro errato
  (qualcuno non era riuscito a leggere correttamente le specifiche
  QIC-80!), che è stato corretto nella versione 1.1.  Ciò nonostante
  ftape riesce a rilevare questo inconveniente e ad aggirarlo.  Dennis
  T. Flaherty (<dennisf@denix.elk.miles.com>) ha detto che i proprietari
  del Conner C250MQ possono ottenere la nuova v1.1 chiamando la Conner
  al numero 1-800-4Conner (negli Stati Uniti) e chiedere l'aggiornamento
  (per il prezzo nominale del floppy).  La versione per Windows dovrebbe
  lavorare bene.  Alcune versioni del programma per nastri della
  Colorado sotto Windows hanno un errore dovuto ad uno scarto unitario
  nel numero dei segmenti.  ftape rileva ed aggira anche questo bug.

  Il Central Point Backup può essere utilizzato, ma spreca prezioso
  spazio su nastro quando incontra una porzione danneggiata.

  NOTA: se si sta utilizzando un programma per la formattazione sotto
  DOS che non è stato menzionato qui, pregherei di spedirmi le
  informazioni piú rilevanti all'indirizzo <heine@math1.rwth-aachen.de>,
  affinché possa aggiornare la lista.



  55..22..  RRiitteennssiioonnaammeennttoo


  I nastri QIC sono particolarmente sensibili alla tensione del nastro.
  Il motivo sta nel fatto che i nastri per le unità da connettere al
  controller floppy sono pre-formattati con informazioni sui settori,
  mentre per altri tipi di nastro le informazioni di sincronismo vengono
  scritte sul nastro, cosí come avviene per i dati.  Se il nastro si
  tende e i campi per il sincronismo vanno fuori sincronismo, si
  otterranno degli errori in lettura.  Il problema è peggiore con i
  nastri piú lunghi.

  È una buona idea ritensionare i nastri nuovi un po' di volte prima di
  utilizzarli e formattarli.  Si dovrebbe, inoltre, provare a
  ritensionare il nastro quando si cominciano ad avere degli errori di
  lettura.  Sarebbe anche una buona idea ritensionare il nastro prima di
  un backup.


  55..33..  PPuulliizziiaa ddeellll''uunniittàà


  Il rivestimento sul nastro è un composto di ossido.  Quando il nastro
  viene trascinato sopra la testina di lettura, ha la tendenza a
  depositarvi sopra una sottile quantità di residuo.  Si dovrebbe
  utilizzare periodicamente un pulisci-nastri seguendo le specifiche per
  l'unità in questione.  Pulisci-nastri dovrebbero essere disponibili
  presso qualsiasi rivenditore di nastri.

  Un'ulteriore nota sulla pulizia del nastro.  È opportuno pulire
  l'unità dopo il primo uso di un nastro nuovo di zecca.  Un nastro
  nuovo di zecca lascerà tipicamente un quantità abbastanza
  considerevole di residui la prima volta che viene utilizzato.

  Grazie a Neal Friedman per la spiegazione ed il suggerimento di
  inserire questa informazione nell'HOWTO.



  55..44..  RRiippaarraarree llee ccaarrttuuccccee ssbboobbiinnaattee [[ddeessppoooolleedd]]


  In rare occasioni può accadere che l'unità a nastro non rilevi i
  marcatori di EEOOTT (End Of Tape [fine del nastro]) correttamente.
  Questi marcatori sono semplicemente dei buchi nel nastro che vengono
  rilevati dall'unità con dei piccoli foto-transistor (o qualcosa di
  simile).

  Il manuale dell'unità a nastro in possesso fornirà probabilmente
  opportuni accenni su come pulire questi rilevatori di EOT.

  Ciò nonostante, se il rilevamento dell'EOT fallisce, l'unità a nastro
  ``sbobina'' la cartuccia in quanto il nastro non è incollato alle
  bobine, ma trattenuto solo per frizione.

  Ci sono dettagliate istruzioni su come aggiustare tali nastri
  sbobinati alla pagina Web di Iomega:

  http://www.iomega.com/support/techs/ditto/3006.html

  e alla pagina Web della Hewlett Packard:

  http://www.hp.com/isgsupport/cms/docs/lpg12020.html

  Se le pagine non dovessero trovarsi nell'esatta locazione data sopra,
  provare a girovagare un po' fra le pagine di HP o Iomega finché non si
  riesce a trovare le informazioni di cui si ha bisgono.



  66..  HHaarrddwwaarree ssuuppppoorrttaattoo



  66..11..  UUnniittàà aa nnaassttrroo ssuuppppoorrttaattee


  Tutte le unità che sono compatibili con lo standard QIC-117 _e con uno
  tra gli standard QIC-30, 80, 3010 e 3020 dovrebbero funzionare
  correttamente.  Anche le unità QIC-WIDE e Travan sono supportate (TR-1
  è semplicemente un QIC-80 con nastri da 8mm, mentre TR-2 e TR-3 sono
  anche conosciute come QIC-3010 e 3020 rispettivamente).  Le unità
  Iomega Ditto 2GB e Ditto Max sono ugualmente supportate nonostante non
  siano completamente conformi agli standard QIC.  Sono supportati anche
  alcune unità da collegare alla porta parallela.

  Alcuni commenti riportati piú avanti a proposito di potenziali
  problemi con determinate unità sono molto datati, ma non ho
  accessibilità a tutti i tipi di hardware e quindi non posso provarli
  tutti.

  Taluni resoconti riportati di seguito sono stati commentati da me
  (<heine@math1.rwth-aachen.de>) in questo modo:


       Questo è un commento.


  Attualmente la lista delle unità funzionanati con ftape è:


     AAllllooyy RReettrriieevveerr 225500


     AArrcchhiivvee 55558800ii,, XXLL99225500ii


     CCoolloorraaddoo DDJJ--1100,, DDJJ--2200 ((ccoonnoosscciiuuttii aanncchhee ccoommee:: JJuummbboo 112200,, JJuummbboo 225500))


     CCoolloorraaddoo 11440000
        <kosowsky@bellini.harvard.edu> ha riportato un problema durante
        un backup 1G utilizzando taper.


     uunniittàà aa nnaassttrroo ppeerr ppoorrttaa ppaarraalllleellaa CCoolloorraaddoo TTrraakkkkeerree

        Supporto aggiunto da Jochen Hoenicke
        <Jochen.Hoenicke@Informatik.Uni-Oldenburg.DE>.


     HHPP CCoolloorraaddoo TT11000000

          I problemi riferiti sono probabilmente ormai superati.
          In particolare lo zftape del quale si parla non esiste
          piú e il driver ftape è in realtà l'ftape-2.08.


     Funziona con nastri 3M Travan 400M (TR-1) e nastri da 120M.  È
     stato riscontrato che mt esce improvvisamente, mentre con backup
     che utilizzano tar funziona bene.  Con cpio si consiglia l'uso di
     ftape al posto di zftape.
     (<millner@millner.bevc.blacksburg.va.us>)

     Sono stati riscontrati problemi con zftape consistenti in un
     continuo arresto e partenza dell'unità
     (<75104.1756@compuserve.com>).  Sembra sia un problema del nastro
     che gira troppo velocemente per il computer; il buffer DMA viene
     svuotato prima che sia riempito nuovamente.  Le versioni piú
     recenti di zftape non eseguono questa operazione se si utilizza un
     programma di backup opportunamente veloce e un buffer DMA
     sufficientemente grande.
     (<millner@millner.bevc.blacksburg.va.us>).


     CCoonnnneerr CC225500MMQQ((TT))
        Il 250Q sembra generi errori in scrittura e frequenti
        riposizionamenti. (Frank Stuess presso Nacamar Data
        Communications)


          Errori in scrittura non sono necessariamente causati
          dall'unità a nastro, ma anche da cartucce rovinate.
          Anche riposizionamenti frequenti possono essere causati
          da cartucce rovinate, ma possono essere causati anche da
          errori di _o_v_e_r_r_u_n, indice di problemi di comunicazione
          fra il controller FDC e quello DMA.



     CCoonnnneerr TTSSMM442200RR,, TTSSMM885500RR
        I modelli 400 e 800 funzionano solo con nastri TR-1.


          Non so se questo stava ad indicare che le unità citate
          non funzionano con le normali cartucce DC-2120 da 120MB o
          che i nastri TR-3 non possono essere letti.  Queste unità
          non erano state progettate per quest'ultimo tipo di nas­
          tro. E allora?



     CCoonnnneerr TTSSTT33220000RR
        Funziona con nastri TR-3 ad 1Mbps (cioè solo con capacità da
        1600M).  Funziona con nastri QIC-WIDE 400M (il Sony 5122?)
        (<chris@cs.wmich.edu>).  Funziona con nastri TR-3, QIC-3010 e
        QIC-3020.  Viene distribuito con un FDC da 2MB che utilizza il
        controller Promise 2300+ da 1Mbps (<kjh@pollux.usc.edu>).

        Sembra che il diver floppy non riesca piú a leggere dischi a
        bassa densità.  Bisogna perdere un po' di tempo con i canali
        IRQ, quelli degli indirizzi ed i canali DMA
        (<chris@yakkocs.wmich.edu>).


          Il TST3200R va bene con ftape.



     CCoonnnneerr TTSSTT880000RR
        Il TST800R funziona con nastri TR-1, Sony QW5122F (210M) e
        DC2120.


          Funziona bene con ftape, almeno fino all'ftape-2.07.
          L'ho utilizzato personalmente finché non si è colato un
          transistor dell'unità, probabilmente a causa di un sur­
          riscaldamento precedente.



     CCoonnnneerr CCTTTT33220000

        Il CTT3200 è probabilmente identico allo Iomega Ditto 3200.
        Funziona con il controller da 2Mbps fornito, ma sembra non
        funzionare sotto DOS su alcune macchine (<jmorris@dtx.net>).



     CCoonnnneerr 11..77GG TTaappeessttoorr ((TTSSMM11770000RR))

        Funziona con nastri di tipo QIC-WIDE (<pschmidt@slip.net>).
        Parzialmente lavora con QIS-3200.  Se si utilizza il controller
        HSC-2, il canale DMA deve essere cambiato (incrementato di 1
        -canale 2?- modificare il Makefile).  Successivamente è
        necessario modificare il Makefile di ftape per riflettere questo
        cambiamento.  Nonostante ciò, ftape si comporta in maniera un
        po' bizzarra con questo (non viene fornito alcun numero di
        versione) (<ttait@tiac.net>).  Potrebbe non funzionare a 2Mbps
        (QIC-3020) con il controller HSC.  L'unità si ferma con un
        messaggio del tipo "dumb tape stop" che fino ad ora non è stato
        compreso.  (<ttait@tiac.net>).


          Nessuna informazione recente disponibile.



     EEssccoomm oo AArrcchhiivvee ((HHoorrnneett)) 3311225500QQ


     EExxaabbyyttee EEXXBB--11550000
        Funziona con nastri QIC-3010.


     EExxaabbyyttee TTRR--33

     IIrrwwiinn 8800SSXX,, IInnssiigghhtt 8800MMbb


     IIoommeeggaa 225500


     IIoommeeggaa DDiittttoo TTaappee IInnssiiddeerr 442200,, 11770000


     IIoommeeggaa DDiittttoo TTaappee IInnssiiddeerr 33220000
        Questa è l'unità che utilizzo io.  Le impostazioni di default
        dei jumper non funzionano.  Lasciare invariati l'IRQ e
        l'indirizzo della porta di I/O (6 e 0x370, rispettivamente), ma
        cambiare il DMA da 3 a 2.  (Kevin Johnson <kjj@pobox.com>).


          Fare riferimento al file MCONFIG delle distribuzioni di
          ftape piú recenti per altri suggerimenti sulla porta di
          I/O, l'IRQ ed il canale DMA.


     Potrebbe essere necessario aggiungere {0x08882, 80,
     wake_up_colorado, "Iomega 3200"} al file vendors.h per le versioni
     di ftape piú vecchie.

     Sono stati riscontrati problemi con ftape 2.07 ed il kernel
     1.12.13.  Tra tutte le combinazioni possibili di acceleratori,
     etc., l'unità potrebbe essere accessibile (su alcuni sistemi) una
     volta sola (<erwin@box.nl>).  Inoltre, dopo il primo accesso, l'uso
     successivo del nastro restituisce un messaggio di protezioni in
     scrittura (<erwin@box.nl>, <M.J.Ammerlaan@dutiwy.twi.tudelft.nl>).

     C'è stato anche un caso nel quale il nastro è stato sbobinato.


          Ciò potrebbe essere stato causato da un sensore di EOT
          sporco e non è necessariamente un effettivo malfunziona­
          mento hardware (tranne quando è il malfunzionamento a
          sporcare il sensore di EOT...).

     Un altro problema è stato riscontrato durante la creazione di
     archivi (con dd).  Può partire bene, ma quando l'unità comincia ad
     utilizzare dd, si ferma ed il nastro viene riavvolto fino al
     principio.  Successivamente comincia a far girare il nastro in
     continuazione senza fermarsi.  Sembra che tutto ciò accada quando
     il driver chiede al nastro di fermarsi.  Ciò dovrebbe causare
     l'arretramento del nastro di 3 segmenti, ed invece viene riportato
     all'inizio.  Una correzione dell'errore è stata postata, ma il
     problema non è stato risolto.


          Dovrebbe essere stato aggiustato in qualche versione fra
          l'ftape-3.00 e l'ftape-4.00.  Sfortunatamente l'utile
          comando di fast-skipping (salto veloce) di tutte le unità
          a nastro per controller floppy è vveerraammeennttee scarno.
          Recenti versioni di ftape hanno aggirato il problema.
          Suggerisco di procurarsi l'ultima versione del driver
          ftape qualora si avesse esperienza di questo problema.



     IIoommeeggaa DDiittttoo 880000 IInnssiiddeerr
        Funziona con nastri TR1, TR2, o DC2120 (<klein@informatik.uni-
        rostock.de>).


     IIoommeeggaa DDiittttoo 22GGBB
        Supporto aggiunto da Jochen Hoenicke
        <Jochen.Hoenicke@Informatik.Uni-Oldenburg.DE> all'ftape-3._x_x e
        successivi.

        Non è possibile formattare cartucce, la scrittura è possibile
        solo con speciali cartucce Ditto 2GB (limite hardware, non è una
        mancanza di ftape).


     IIoommeeggaa DDiittttoo MMaaxx

     IIoommeeggaa DDiittttoo MMaaxx PPrroo
        Supportato a partire dall'ftape-4.00.  Grazie a Tim Jones
        <tjones@estinc.com>.

        Non è possibile formattare cartucce, la scrittura è possibile
        solo con speciali cartucce Ditto Max (limite hardware, non è una
        mancanza di ftape).

        Non sono stato in grado di far funzionare il Ditto Max con altri
        file di periferica all'infuori di /dev/[n]qft0.  Non so se
        questa è una caratteristica del Ditto Max o del controller Ditto
        EZ che ho collegato al Ditto Max.

        (* Non c'è bisogno di comprare un Fitto Max Pro per utilizzare
        le cartucce da 5/10GB.  Con ftape non ci sono sostanziali
        differenze fra il Ditto Max e il Ditto Max Pro.  *)


     IIoommeeggaa DDiittttoo 880000//33220000//22GGBB//MMaaxx//MMaaxx PPrroo EEaassyy ((ppoorrttaa ppaarraalllleellaa))
        Supportato a partire dall'ftape-4.00 con il driver per FDC bpck-
        fdc.


     MMoouunnttaaiinn FFSS88000000


     RReevveeaall TTBB11440000

        È stato riferito che non funziona con il kernel 1.3.79 ed ftape
        (nessuna versione fornita) o con il kernel 1.2.13 e zftape 1.04
        (<colin@colina.demon.co.uk>).


          La versione del driver ftape appena menzionata è ormai
          vecchia.  Se tuttavia si possiede una tale ``bestia'',
          procurarsi una versione del driver ftape piú recente.



     SSuummmmiitt SSEE 115500,, SSEE 225500


     TTaallllggrraassss FFSS330000
        Con un Tallgrass FS300 e un AHA1542B è necessario aumentare il
        tempo di bus-on / bus-off del 1542B.  Antti Virjo
        (<klanvi@uta.fi>) dice che portare CMD_BUSON_TIME a 4 e
        CMD_BUSOFF_CMD a 12 in linux/drivers/scsi/aha1542.c permette di
        attuare il trucchetto.


     TTeeaacc 880000


     SSiisstteemmaa ddii bbaacckkuupp ccoonn uunniittàà aa nnaassttrroo MMeemmoorreexx


     WWaannggtteekk 33004400FF,, 33008800FF


  È sempre possibile controllare la lista piú recente delle unità
  riconosciute da ftape, guardando nel file vendors.h della
  distribuzione di ftape.

  Anche se non voglio garantire il buon funzionamento di un'unità
  piuttosto che un'altra, è stato detto che il Colorado DJ-20 è
  piuttosto rumoroso, quando paragonato ad un, diciamo, Conner C250MQ.
  Per inciso, è stato detto che il Colorado è 5-10 volte piú rumoroso
  del Conner. Ma, poiché non ho mai avuto né l'uno né l'altro, non posso
  dirlo con certezza.


       Se possiedi un'unità a nastro che funziona bene, ma non è
       listata qui, o se hai delle correzioni per le informazioni
       riportate sopra, ti pregherei di spedire una mail al manu­
       tentore dell'HOWTO (<heine@math1.rwth-aachen.de>).



  66..22..  CCoonnttrroolllleerr ssppeecciiaallii ssuuppppoorrttaattii


  I controller ad alta velocità dedicati, supportati da ftape, sono i
  seguenti:


  ·  Colorado FC-10, FC-20

  ·  Mountain MACH-2

  ·  Iomega Tape Accelerator II

  ·  controller da 2Mbps (utilizzanti l'fdc i82078-1)


  ·  il controller Iomega Ditto EZ 4Mbps PnP


  66..22..11..  CCoolloorraaddoo FFCC--1100,, FFCC--2200


  Il supporto per il controller FC-10 è stato aggiunto alla versione
  1.12 del driver di ftape.  Vedere i file RELEASE-NOTES e Makefile
  nella distribuzione di ftape.  Dalla versione 2.03 di ftape, il
  controller FC-20 comincerà a funzionare, ma solo ad 1Mb/s (controllare
  le note di release!).


  66..22..22..  MMoouunnttaaiinn MMAACCHH--22


  Il supporto per il controller MACH-2 è stato aggiunto all'ftape-1.14d.


  66..22..33..  IIoommeeggaa TTaappee AAcccceelleerraattoorr IIII


  Per usare lo Iomega Tape Accelerator II (da nnoonn confondersi con lo
  Iomega Ditto Dash!), utilizzare -DMACH2 e configurare correttamente i
  valori per l'indirizzo I/O di base, l'IRQ e il DMA.  Funziona (secondo
  prove empiriche fatte da Scott Bailey <sbailey@xcc.mc.xerox.com>)
  almeno con l'ftape-2.02.


  66..22..44..  IIoommeeggaa DDiittttoo DDaasshh ee aallttrrii ccoonnttrroolllleerr ddaa 22MMbbppss


  Lo Iomega Ditto Dash e tutti gli altri controller da 2Mbps usano il
  chip 82078-1 della Intel, che può lavorare a 2Mbps.  Il chip è
  supportato pienamente a partire dall'ftape-3.00.


  66..22..55..  CCoonnttrroolllleerr IIoommeeggaa DDiittttoo EEZZ PPnnPP


  Questo controller richiede l'utilizzo del cosiddetto pacchetto
  isapnptools per essere configurato.  È disponibile presso

  http://www.roestock.demon.co.uk/isapnptools/

  Il controller produce troppi errori di _o_v_e_r_r_u_n quando viene utilizzato
  alla massima velocità di 4Mbps.  Né Tim Jones <tjones@estinc.com> né
  io <heine@math1.rwth-aachen.de> siamo stati in grado di trovare una
  macchina che potesse far lavorare il controller a 4Mbps.  3Mbps
  sembrano andare bene.

  Se il Ditto EZ viene configurato per utilizzare il DMA 2 (il canale
  DMA usato dal controller del floppy), il drive del floppy non
  funzionerà piú.  Non è di alcuna utilità disabilitare il gate DMA dei
  controller (come nel caso di altri controller ad alta velocità), cosí
  non può esserci alcun aiuto nemmeno dalla modifica di ftape.



  66..33..  UUnniittàà aa nnaassttrroo nnoonn ssuuppppoorrttaattee



  ·  Alcune unità per porta parallela non funzionano ancora. Altre vanno
     bene.

  ·  Irwin AX250L / Accutrak 250. (non è un'unità QIC-80)

  ·  IBM Internal Tape Backup Unit (identica all'unità Irwin AX250L)

  ·  COREtape light

  L'Irwin AX250L (e l'IBM Internal Tape Backup Unit) non funziona con
  ftape.  Questo è dovuto al fatto che supporta solo il QIC-117, ma non
  lo standard QIC-80 (utilizza il formato proprietario della Irwin
  ``servoe (Rhomat)'').  Non so nulla del formato Rhomat, né dove
  trovare qualche informazione.  Mi dispiace.

  Il COREtape light non accetta i comandi di inizializzazione, ma ce ne
  stiamo occupando.  Questo problemino lascia l'unità inutilizzabile.



  66..44..  UUttiilliizzzzaarree uunn''uunniittàà aa nnaassttrroo eesstteerrnnaa ccoonn ffttaappee


  Se si possiede un controller floppy provvisto di un connettore femmina
  DB37 fissato alla staffa (alcuni piedini servono per alimentare
  l'unità) è possibile utilizzarlo con ftape.  Va bene, questa frase non
  era proprio ovvia.  Proviamo in questo modo: alcuni FDC (quelli
  proprio vecchi) hanno un connettore DB37 sulla staffa per connettere
  unità floppy esterne.

  Se si costruisce un cavo adatto per collegare il connettore DB37 (del
  FDC) alla propria unità a nastro esterna, è possibile utilizzare ftape
  per controllare la propria unità.

  Ciò è dovuto al fatto che dal punto di vista di un programma non c'è
  differenza fra un connettore esterno ed uno interno.  Cosí, dal punto
  di vista di ftape, sono identici.


  ·  Pin 20-37: MASSA

  ·  1: +12 Volt (ALIMENTAZIONE)

  ·  2: +12 Volt ritorno (MASSA)

  ·  3: +5 Volt ritorno (MASSA)

  ·  4: +5 Volt (ALIMENTAZIONE)

  ·  5: 2

  ·  6: 8

  ·  7: 10

  ·  8: 12

  ·  9: 14

  ·  10: 16

  ·  11: 18

  ·  12: 20

  ·  13: 22

  ·  14: 24

  ·  15: 26

  ·  16: 28

  ·  17: 30

  ·  18: 32

  ·  19: 34

  Il connettore per l'alimentazione è del tipo ``mini'', come quello
  delle unità floppy da 3.5".  L'idea è quella di collegare uno dei
  connettori per l'alimentazione della PSU (-- Si tratta
  dell'alimentatore interno al computer (N.d.T.)--) al connettore
  presente sulla scheda.  Se si intende utilizzare solo un cavo, ci si
  dovrà procurare un cavo da 50 fili e utilizzare piú fili per
  l'alimentazione (e la massa, per ciò che serve).

  Nessuno mi ha confermato che funzioni.  Fatemi sapere i risultati se
  ci provate.



  66..55..  SScchheeddee mmaaddrrii PPCCII ffttaappee


  Sfortunatamente alcune schede madri PCI causano problemi quando si
  tenta di far girare ftape.  Alcune persone hanno avuto modo di provare
  che ftape non gira su computer con tecnologia PCI, mentre non fanno
  una grinza su di un normale 386DX con tecnologia ISA.  Se si presenta
  un problema come questo, fare riferimento al file README.PCI nella
  distribuzione di ftape.


       Un controller per floppy ha bisogno di un controller DMA su
       bus ISA per i suoi trasferimenti di memoria.  Sembra che il
       controller DMA ISA non ottenga il controllo sulla memoria
       abbastanza frequentemente su alcuni sistemi basati sul PCI.



  77..  AArrcchhiivviiaarree ee rriipprriissttiinnaarree ii ddaattii


  Questa sezione descrive alcune semplici utilizzi di tar ed mt.  Altri
  esempi si possono trovare nell'ftape-manual del pacchetto ftape-doc.
  L'ftape-tools contiene alcuni semplici ambienti di test automatizzati
  tipo DejaGnu (-- Pacchetto per scrivere test automatizzati.--) Vedere
  la sezione ``Procurarsi Ftape'' per informazioni su dove scaricare
  questi pacchetti addizionali.


  77..11..  SSccrriivveerree uunn aarrcchhiivviioo ssuu ddii uunn nnaassttrroo


  È possibile utilizzare ``tar'', ``ttdd'', ``cpio'' e ``afio''.  Ci
  sarà bisogno di utilizzare ``mt'' per ottenere il massimo dalle
  potenzialità dai nastri e dal driver ftape.  Per cominciare consiglio
  tar, in quanto permette di archiviare molte directory e di estrarre
  successivamente file separati dall'archivio.  cpio crea archivi piú
  piccoli ed è generalmente piú flessibile di tar, ma gli mancano alcuni
  caratteristiche come l'etichettamento dei volumi.  afio crea backup
  nei quali ogni file è compresso individualmente e poi concatenato.
  Questo permette di accedere ai file ``dopo'' il punto di errore.  Se
  si utilizzano file archiviati con tar e compressi con gzip, tutti i
  dati dopo il punto di errore sono persi! (secondo me, questa è una
  buona ragione per _n_o_n utilizzare la compressione sui backup).  Quale
  sia la scelta piú opportuna dipende dalla situazione e dalle
  caratteristiche diverse da programma a programma.  Consiglio di dare
  un'occhiata ad ogni programma ed a rivedere le opzioni che ognuno di
  essi fornisce.  È possibile che questo HOWTO possa fornire maggiori
  dettagli al riguardo in futuro.

  Ci sono ulteriori link che puntano a programmi di backup all'indirizzo
  http://www-math.math.rwth-aachen.de/~LBFM/claus/ftape/ nella sezione
  software della pagina.

  Per eseguire il backup del proprio albero dei sorgenti del kernel
  utilizzando tar, impartire i seguenti comandi (dove si assume che i
  sorgenti si trovino in /usr/src/linux):


               # cd /usr/src
               # tar cf /dev/ftape linux



  Questo non comprime i file, ma fa girare un po' il nastro.  Se si
  vuole la compressione (e si possiede il tar 1.11.2), è sufficiente
  aggiungere il flag -z (-- tar assume che il primo argomento sia
  un'opzione, cosicché il ``-'' non è necessario, cioè i seguenti due
  comandi eseguono la stessa operazione: ``tar xzf /dev/ftape'' e ``tar
  -xzf /dev/ftape''--)

  cioè: ``tar czf /dev/ftape linux ''.

  Per maggiori istruzione su come utilizzare tar, dd ed mt consultare le
  _m_a_n_-_p_a_g_e e i file _t_e_x_i_n_f_o ottenuti con le rispettive distribuzioni.



  77..22..  RRiipprriissttiinnaarree uunn aarrcchhiivviioo


  Va bene, ora ripristiniamo il backup dei sorgenti del kernel
  effettuato alla sezione precedente ``Scrivere un archivio su di un
  nastro''.  Per fare questo digitare semplicemente:



               tar xf /dev/ftape



  Se si è utilizzata la compressione, si dovrà digitare:



               tar xzf /dev/ftape



  Quando si utilizza la compressione, gzip si lamenterà di dati
  ridondanti subito dopo la fine dell'archivio (e ciò condurrà ad un
  messaggio di ``broken pipe'').  Tutto ciò può essere tranquillamente
  ignorato.

  Per altri programmi di utilità, consultare la pagina di manuale.



  77..33..  PPrroovvaarree uunn aarrcchhiivviioo


  tar possiede un'opzione (-d) per rilevare le differenze fra due
  archivi.  Per testare il proprio backup dei sorgenti del kernel
  digitare:



               tar df /dev/ftape



  Se non si possiede la _m_a_n_-_p_a_g_e di tar, non tutto è perduto (ancora);
  tar possiede un'opzione interna per listare i flag disponibili:
  provare con ``tar --help 2>&1 | less''.


  77..44..  MMeetttteerree ppiiúú ddii uunn bbaacckkuupp ssuu ddii uunn nnaassttrroo


  Per mettere piú di un backup su di un nastro si deve possedere
  l'utility mt.  Probabilmente è già installata sul sistema se si
  possiede una delle distribuzioni principali (cioè Slackware o Debian).

  Programmi come tar e cpio generano un singolo archivio per il nastro
  (Tape ARchive) e non sanno nulla circa l'utilizzo di piú file o il
  posizionamento di un nastro.  Non fanno altro che leggere o scrivere
  su di un file di periferica.  mt sa perfettamente come muovere il
  nastro avanti ed indietro, ma non sa assolutamente come estrarre i
  dati dal nastro.  Come probabilmente si avrà già intuito, la
  combinazione di tar o cpio con mt permette il trucco.

  Utilizzando il device nqft[0-3] (nftape), è possibile posizionare il
  nastro con mt al posto giusto (``mt -f /dev/nqft0 fsf 2'' indica di
  andare avanti di due ``marcatori di file'', cioè di due file tar) e
  poi utilizzare tar o cpio per leggere o scrivere i dati rilevanti.

  L'utilizzo piú comune delle periferiche non-riavvolgenti è quello di
  aggiungere un altro backup ad un nastro esistente.  Qui di seguito ci
  sono i passi dettagliati con una breve spiegazione per una
  comprensione migliore.


  ·  Inserire il nastro nell'unità.  Su alcune unità questo potrebbe
     causare il riavvolgimento del nastro.

  ·  Impartire un comando di ``fine nastro'' (End-of-Tape) alle
     periferiche _n_o_n-riavvolgenti.



               mt -f /dev/n???? eof



  Il nastro dovrebbe essere ora posizionato alla fine dei dati (End-of-
  Data o EEOODD).  Il nastro non si muoverà finché:

     ·  un programma non aprirà la periferica;

     ·  la periferica riavvolgente verrà chiusa;

     ·  il modulo di ftape verrà rimosso dalla memoria kernel (rmmod);

     ·  il nastro verrà espulso.


  L'utilizzo di ``mt eof'' dovrebbe risultare piú veloce con i nastri
  QIC.

  ·  L'operazione successiva comincerà dal marcatore EOD.  Se si vuole
     intraprendere un'operazione di scrittura, questa aggiungerà un
     nuovo ``file''.  Se si intraprende un'operazione di lettura, questa
     fallirà con un EOF.  Il marcatore di EOD per molti formati di
     nastro è, in effetti, due marcatori di EOF consecutivi, anche se,
     dalla versione 3._x_x, ftape utilizza la tavola di volume, come
     specificato nello standard QIC-113, per emulare i marcatori di
     file, cosicché non ci sono due marcatori di file consecutivi nel
     punto di EOD.  La scrittura dei marcatori di EOF viene effettuata o
     dal driver o dall'hardware nel momento in cui riceve un close().


  ·  Questo è il momento in cui vengono effettivamente scritti i dati
     sul nastro.

  ·  Questo punto è importante.  OOrraa rriiaavvvvoollggeerree iill nnaassttrroo.  ftape
     mantiene nella propria cache alcune informazioni inerenti i
     segmenti di intestazione del nastro che vengono aggiornati ssoolloo
     qquuaannddoo iill nnaassttrroo vviieennee rriiaavvvvoollttoo.  L'utilizzo della cache è
     necessario in quanto il riavvolgimento del nastro e l'aggiornamento
     dei segmenti di intestazione richiede una notevole quantità di
     tempo.  L'altra faccia della medaglia è che si perderanno
     informazioni se si esegue un'operazione di scrittura e non si
     riavvolge il nastro.



  77..55..  AAggggiiuunnggeerree ffiillee aadd uunn aarrcchhiivviioo


  «C'è un modo per espandere un archivio mettendo un file sul nastro e,
  successivamente. aggiungerne altri?»

  No.  La documentazine di tar dice di utilizzare ``tar -Ar'', ma non
  funziona.  Questa è una limitazione del driver ftape corrente.



  77..66..  EEsseegguuiirree iill mmoouunntt oo ll''uunnmmoouunntt ddeeii nnaassttrrii


  Poiché un nastro non ha un ``filesystem'' su di esso, non si esegue il
  mount o l'unmount di un nastro.  Per effettuare un backup, inserire
  semplicemente il nastro ed impartire i comandi di tar (o qualsiasi
  altro comando si utilizzi per accedere al nastro).



  88..  CCrreeaarree uunn ffllooppppyy ddii ppaarrtteennzzaa iinn ccaassoo ddii eemmeerrggeennzzee ppeerr ffttaappee


  (* Nel momento in cui scrivo (agosto 1998), ricordo di aver letto di
  diversi set di dischi d'emergenza sul news-group cc..oo..ll..aa..
  (comp.os.linux.announce).  Alcuni di quei pacchetti potrebbero
  effettivamente produrre un insieme di dischetti per le partenze
  d'emergenza piú sofisticato.  È opportuno controllare di persona.  Io
  non ho provato a creare un dischetto di emergenza con le recenti
  versioni di ftape.  *)


  Questa sezione è stata scritta da Claus Tøndering <ct@login.dknet.dk>.

  Una volta diventati felici possessori di un'unità a nastro e di
  diversi nastri pieni zeppi di backup, probabilmente verrà spontaneo
  porsi questa domanda: «Se qualcosa va storto e perdo completamente il
  contenuto del mio hard-disk, come faccio a ripristinare i miei file
  dal nastro?»

  Ciò di cui si ha bisogno è un disco floppy d'emergenza, che contenga
  abbastanza file da permettere la partenza di Linux e di ripristinare
  l'hard-disk dal nastro.

  La prima cosa da fare è leggere il ``The Linux Bootdisk HOWTO''
  scritto da Graham Chapman <grahamc@zeta.org.au>.  Questo documento
  contiene praticamente tutto ciò che bisogna sapere per creare un kit
  di partenza con dischi floppy d'emergenza.  I paragrafi seguenti
  contegono alcune altre informazioni che renderanno la vita un po' piú
  semplice quando si seguiranno le procedure di Graham Chapman.


  ·  Non c'è effettivamente bisogno di /etc/init, /etc/inittab,
     /etc/getty e /etc/rc.d/* sul floppy.  Se Linux non trova /etc/init,
     farà partire /bin/sh dalla console, cosa che va benissimo per
     ripristinare il sistema.  Cancellando questi file si guadagna dello
     spazio sul floppy, cosa di cui, probabilmente, si ha bisogno.

  ·  È meglio cercare un versione ridotta di /bin/sh.  Spesso è
     possibile trovarla sui floppy di boot che si ottengono con una
     distriuzione Linux.  Questo, ancora, permette di guadagnare
     ulteriore spazio.  Personalmente suggerisco ash, estremamente
     ridotta (circa 62kB) e gran parte compatibile con bash.

  ·  L'/etc/fstab che verrà incluso nel floppy dovrebbe assomigliare a
     qualcosa del genere:



       /dev/fd0        /               minix   defaults
       none            /proc           proc    defaults
       /dev/hda        /mnt            ext2    defaults



  Una volta fatto partire il sistema dal floppy, impartire il comando
  seguente:



       mount -av



  ·  Assicurarsi che il driver per il floppy non sia montato quando si
     accede all'unità a nastro!  In caso contrario è possibile ottenere
     in risposta il seguente messaggio di errore:



        Unable to grab IRQ6 for ftape driver



  Questo significa che èè nneecceessssaarriioo caricare il floppy in un _r_a_m_d_i_s_k.

  La sfortunata conseguenza di questo è che i programmi necessari a
  ripristinare i file dal nastro non possono risiedere su di un floppy
  separato.  A questo punto si hanno due opzioni:

     1. Salvare tar (cpio, afio o qualsiasi altro programma di backup si
        utilizzi) sul floppy di root.  Qui è dove si sfrutta tutto lo
        spazio addizionale creato nei passi precedenti.

     2. Prima di cominciare a ripristinare il nastro, copiare tar (cpio,
        afio o quant'altro) sul proprio hard-disk e caricarli da là.


  ·  Oltre ai programmi di backup, ci sarà probabilmente bisogno anche
     di mt sul floppy di root.

  ·  Assicurarsi che il device del nastro (tipicamente /dev/nqfto) sia
     presente sul floppy di root.

  ·  Infine, pprroovvaarree iill ttuuttttoo!! Ovviamente non consiglio di distruggere
     il contenuto dell'hard-disk per vedere se si è in grado di
     ripristinare tutto.  Consiglio, invece, di provare a far partire il
     sistema dai dischi di emergenza e di assicurasi di poter almeno
     listare il contenuto dei backup presenti sul nastro.



  99..  DDoommaannddee ppoossttee ffrreeqquueenntteemmeennttee


  (* Questa è l'inclusione testuale della raccolta delle domande poste
  piú frequentemenete sull'Ftape, che sono mantenute da Johan De Wit e
  che possono essere visionate in rete all'indirizzo
  http://www.correct.nl/~ftape.  Poiché l'SGML Linuxdoc non contiene le
  sotto-sotto-sezioni nell'indice, ho aggiunto la parola FAQ alle
  sezioni del documento FAQ originale.  *)

  QQuueessttaa rraaccccoollttaa ddii FFAAQQ ppoottrreebbbbee eesssseerree lleeggggeerrmmeennttee ddaattaattaa iinn qquuaannttoo èè
  ssttaattaa ffaattttaa mmeennttrree llaa vveerrssiioonnee 33..0044dd ddeell ddrriivveerr ftape era la piú
  recente.  Se qualche risposta data nelle FAQ contraddice ogni altra
  affermazione di questo HOWTO, si prega di non considerare la risposta
  della FAQ e di spedire a me (<heine@math1.rwth-aachen.de>), cosí come
  al manutentore dell'Ftape-FAQ (Johan De Wit <jo@correct.nl>), una nota
  al riguardo.


  Nella lettura di questo documento è possibile incontrare riferimenti
  ai seguenti indirizzi:


  ·  Il manutentore delle FAQ di Ftape:

     Johan De Wit <jo@correct.nl>


  ·  Il manutentore di Ftape:

     Claus-Justus Heine   <claus@momo.math.rwth-aachen.de>


  ·  L'home-page di Ftape:

     <http://www-math.math.rwth-aachen.de/~LBFM/claus/ftape/>


  ·  Mirror dell'home-page di Ftape:

     <http://www.torque.net/ftape/>

     Un ringraziamento va a:

     Grant R. Guenther <grant@torque.net>

     <http://www.info-systems.com/ftape/>

     Un ringraziamento va a:

     Jakob Curdes <jc@info-systems.com>

     <http://www.newwave.net/~joshg/ftape/>

     Un ringraziamento va a:

     Josh Goins <joshg@newwave.net>


  ·  L'Ftape-HOWTO

     <http://sunsite.unc.edu/LDP/HOWTO>


  ·  La mailing-list di Ftape:

     <linux-tape@vger.rutgers.edu>


  Ci sono sicuramente molte mancanze.  Non ci si faccia problemi a voler
  migliorare queste FAQ.  Il modo migliore per farlo è quello di mandare
  messaggi alla mailing-list di Ftape nel caso ci siano domande che non
  trovano risposta qui.

  Inoltre, se si sta già leggendo regolarmente la mailing-list e si ha
  l'impressione che alcune domande vengano poste frequentemente, è
  possibile senza alcun problema spedire la domanda, con l'eventuale
  risposta, nel formato indicato qui sotto al manutentore delle _F_A_Q _d_i
  _F_t_a_p_e ed anche alla mailing-list di Ftape.

  Se si inviano messaggi relativi alle FAQ, si prega di non dimenticarsi
  di prependere la parola ``[[FFAAQQ]]'' all'oggetto del proprio messaggio.
  Si prega di non aggiungere la parola ``FAQ'' all'oggetto se il
  messaggio non è inerente alle FAQ.

  Questo per ora è tutto.

  Claus-Justus Heine.



  1100..  FFAAQQ:: ddoommaannddee rreellaattiivvee aallllaa ««CCoommppiillaazziioonnee eedd iinnssttaallllaazziioonnee ddii
  FFttaappee»»



  1100..11..  CChhee vveerrssiioonnee ddii FFttaappee ddeevvoo uuttiilliizzzzaarree??


  Sempre l'ultima versione stabile che si _s_u_p_p_o_n_e sia disponibile agli
  indirizzi ftp://sunsite.unc.edu/pub/Linux/kernel/tapes e http://www-
  math.math.rwth-aachen.de/~LBFM/claus/ftape/.

  Nel momento in cui sto scrivendo, l'ultima versione stabile è la
  ftape-4.02.

  <risposta di Claus Heine>



  1100..22..  SSttoo rriissccoonnttrraannddoo pprroobblleemmii nneell cceerrccaarree ddii ffaarr ggiirraarree ll''uunniittàà XXYYZZ
  ccoonn iill kkeerrnneell 22..00.. xxxx  ccoonn iill ddrriivveerr ccoommppiillaattoo ssttaattiiccaammeennttee..  CCoommee
  ffaacccciioo aa rriimmeeddiiaarree??


  La versione predefinita di _F_t_a_p_e inclusa con i sorgenti del kernel
  2.0._x_x è la 2.08 o la 2.09 ed è alquanto datata.  Si prega di
  aggiornare i _d_r_i_v_e_r _d_i _F_t_a_p_e all'ultima versione disponibile all'home-
  page di Ftape.

  <risposta di Tim Jones>



  1100..33..  SSttoo llaavvoorraannddoo ccoonn LLiinnuuxx//SSMMPP ee iill ssiisstteemmaa ssii ccoonnggeellaa qquuaannddoo
  tteennttoo ddii aacccceeddeerree aaii ddeevviiccee ddii FFttaappee!!


  È necessario aggiungere -D__SMP__ alla variabile KERNEL_OPT nel file
  MCONFIG.  Nelle versioni di ftape piú aggiornate è sufficiente
  togliere il commento ad alcune linee presenti nel file MCONFIG.

  <risposta di Claus Heine>



  1100..44..  PPeerrcchhéé ddeeppmmoodd  ssii llaammeennttaa ddii cceerrttii ````uunnddeeffiinneedd ssyymmbboollss'''' [[ssiimm­­
  bboollii iinnddeeffiinniittii]]??


  Si ignorino i messaggi d'errore di depmod.  Il problema è che i _m_o_d_u_l_i
  _d_i _F_t_a_p_e devono essere compilati senza la caratteristica del _c_h_e_c_k_s_u_m
  di versione (cioè CONFIG_MODVERSIONS) con i kernel 2.0.*;.  Questo non
  comporta alcun problema, anche quando i moduli vengono utilizzati con
  un kernel che supporta questa caratteristica; solo che depmod
  erroneamente si lamenta di certi simboli indefiniti.  Si ignorino le
  lamentele di depmod e si provi ad inserire i moduli nonostante queste
  lamentele:



        modprobe zftape



  Se non funziona, c'è qualcosa di sbagliato.

  <risposta di Claus Heine>



  1100..55..  iinnssmmoodd  ddiiccee cchhee llaa vveerrssiioonnee ddeell kkeerrnneell èè ssbbaagglliiaattaa..


  Il programma insmod può confrontare la versione del kernel con la
  versione per la quale _F_t_a_p_e è stato compilato in due modi: può
  direttamente comparare il numero di versione del kernel registrato nel
  _m_o_d_u_l_o _d_i _F_t_a_p_e con la versione del kernel che sta girando, oppure, se
  sia il kernel che _F_t_a_p_e sono stati compilati con i simboli di
  versione, confrontare la versione dei simboli utilizzati dal kernel.

  Se la versione di GCC è stata aggiornata alla v2.7.0 o successive, è
  necessario ricompilare le utility dei moduli con gcc v2.7._x.

  Versioni di insmod piú recenti permettono di ``forzare'' l'inserimento
  di un modulo nel kernel, anche se la stringa di versione non è
  corretta.

  <dall'Ftape-HOWTO>



  1100..66..  iinnssmmoodd  ddiiccee cchhee kkeerrnneell 11..22..00 ee 11..22..00 ddiiffffeerriissccoonnoo..


  Ci si è ricordati di applicare il patch ksyms.c al kernel?  Se non lo
  si è fatto, leggere il file README.linux-1.2 nella distribuzione dei
  sorgenti.

  <dall'Ftape-HOWTO>



  1100..77..  PPrroovvaannddoo aa ccoommppiillaarree FFttaappee ssii oottttiieennee ll''eerrrroorree:: «« mmooddvveerr­­
  ssiioonnss..hh:: nnoo ssuucchh ffiillee oorr ddiirreeccttoorryy »»..


  Il file modversions.h viene creato quando il kernel è compilato con il
  flag di configurazione CONFIG_MODVERSIONS attivato.  Con questa
  opzione abilitata, il file verrà creato durante il passo make dep.

  Un consiglio piú pratico: make mrproper rimuoverà
  /usr/include/linux/modversions.h.  È necessario riconfigurare il
  kernel ed impartire un make dep per riottenere il file.

  <dall'Ftape-HOWTO>



  1100..88..  IInn ooggnnii ccaassoo,, ccoossaa ssoonnoo qquueessttii ````vveerrssiioonneedd ssyymmbboollss'''' [[ssiimmbboollii
  ddii vveerrssiioonnee]]??


  Rispondendo affermativamente al CONFIG_MODVERSIONS durante il make
  config, tutti i simboli esportati dal kernel, cioè i simboli che i
  moduli caricabili possono ``vedere'', vengono aumentati per
  comprendere una somma di controllo attraverso i tipi dei parametri di
  chiamata/ritorno.  Ciò permette ad insmod di rilevare se la
  definizione di una variabile o funzione nel kernel è cambiata dal
  tempo in cui _F_t_a_p_e è stato compilato.

  Questo assicura un alto grado di sicurezza, tale da evitare un
  tracollo del kernel nel caso si utilizzi un modulo vecchio con il
  proprio kernel.

  Se si abilita CONFIG_MODVERSIONS nel kernel, assicurarsi di aver tolto
  il commento da

  -DMODVERSIONS -include /usr/include/linux/modversions.h


  alla linea MODULE_OPT nel Makefile di _F_t_a_p_e.  Viceversa, se non si ha
  CONFIG_MODVERSIONS abilitato, assicurarsi di avere la linea commen­
  tata.

  <dall'Ftape-HOWTO>



  1100..99..  MMii sseemmbbrraa ddii aavveerree ssffttaappee iinnvveeccee ddii zzffttaappee..  QQuuaannddoo llaanncciioo iill
  ccoommaannddoo ffttmmtt ssttaattuuss ,, ootttteennggoo uunnaa rriissppoossttaa cchhee,, nneeii ddooccuummeennttii ddii
  FFttaappee,, ccoorrrriissppoonnddee aa ssffttaappee (( //ddeevv//qqfftt00:: IInnvvaalliidd aarrgguummeenntt ))..  PPeerrcchhéé??


  Ci sono (almeno) due possibili cause a questo problema:

  ·  Tutte le versioni Ftape-3.*; precedenti alla 3.04 installano i
     moduli in /lib/modules/misc invece di /lib/modules/uname -r/misc.
     Poiché modprobe cerca in /lib/modules/misc/ come ultima risorsa, ci
     potrebbe essere un vecchio modulo ftape.o disperso in
     /lib/modules/_u_n_a_m_e _-_r/misc che modprobe trova prima (``uname -r''
     sta per la versione del kernel).  In questo caso rimuovere il
     vecchio modulo ftape.o.

  ·  Il proprio kernel ha il supporto per _F_t_a_p_e compilato. In questo
     caso riconfigurare il proprio kernel senza il supporto per _F_t_a_p_e
     (CONFIG_FTAPE), ricompilarlo ed installarlo.

  <risposta Claus Heins>



  1100..1100..  LLaa mmiiaa sscchheeddaa DDAASSHH//FFCC--2200//EExxaabbyyttee AAcccceelleerraattoorr ffuunnzziioonnaa ssoottttoo
  MMiiccrroossoofftt WWiinnddoowwss,, mmaa ootttteennggoo uunn eerrrroorree ddii ttiippoo ````uunniittàà nnoonn ttrroovvaattaa''''
  iinn vvaarr//lloogg//mmeessssaaggeess// qquuaannddoo pprroovvoo aadd uuttiilliizzzzaarrlloo ssoottttoo LLiinnuuxx..


  Probabilmente si sta provando ad utilizzare le stesse impostazioni di
  IRQ e DMA dell'FDC installato.  Ciò non funziona per le versioni di
  _F_t_a_p_e precedenti alla 3.03b.  Si prega di aggiornare il _d_r_i_v_e_r _d_i
  _F_t_a_p_e all'ultima versione disponibile dall'home-page di Ftape.

  <risposta di Tim Jones>



  1100..1111..  II ttrraassffeerriimmeennttii DDMMAA ddii FFttaappee ddaannnnoo eerrrroorrii ddii EECCCC..


  Sono spiacente di dover dire che ci sono alcune schede SVGA e schede
  Ethernet che non decodificano correttamente i propri indirizzi.
  Questo tipicamente accade quando i buffer di _F_t_a_p_e si trovano
  nell'intervallo 0x1a0000-0x1c0000.  In qualche modo i cicli di
  scrittura DMA vengono rovinati ed ogni altro byte scritto ottiene un
  valore sbagliato (0xff).  Questi problemi si sono avuti sia con schede
  SVGA che schede Ethernet.  Siamo a conoscenza di almeno una (cattiva?)
  scheda VGA ATI 16bit che provoca questo.
  La soluzione piú semplice consiste nel mettere la scheda in uno slot
  ad 8bit (spesso non è abbastanza riconfigurare la scheda per
  trasferimenti ad 8bit).  Spostare il buffer di _F_t_a_p_e lontano
  dall'intervallo della VGA è solo una soluzione parziale.  Tutti i
  buffer DMA utilizzati in Linux possono avere questo problema!  Vorrei
  che fosse chiaro questo concetto: questo non ha niente a che fare con
  il software di _F_t_a_p_e.

  <dall'Ftape-HOWTO>



  1100..1122..  AAiiuuttoo!!  SSttoo aavveennddoo ddeeii ```` ddmmaaaalllloocc(()) ffaaiilleedd '''' nneell mmiioo ffiillee ddii
  ssyysslloogg..


  Si dovrebbe vedere questo solo se si sta tentando di eseguire un
  insmod con il modulo ftape.o.  Provare a lanciare prima swapout.
  Viene fornito con i sorgenti di _F_t_a_p_e distribuito singolarmente.  Non
  compare nei sorgenti di _F_t_a_p_e che vengono forniti con il kernel.

  Qui di seguito è riportato un esempio di come si possa impostare il
  file rc.local per un suo utilizzo.



       # Install the Floppy Tape Driver
       if [ -f /boot/modules/`uname -r`/misc/ftape.o ]; then
          echo Installing ftape for Linux `uname -r`
          swapout
          insmod /boot/modules/`uname -r`/misc/ftape.o
       fi



  Si noti che questo problema non compare se il _d_r_i_v_e_r _d_i _F_t_a_p_e viene
  compilato nel kernel.

  <dall'Ftape-HOWTO>



  1100..1133..  SSyyssllooggdd llaavvoorraa iinn ccoonnttiinnuuaazziioonnee qquuaannddoo ggiirraa FFttaappee..


  Le opzioni in fase di compilazione NO_TRACE e NO_TRACE_AT_ALL in _F_t_a_p_e
  controllano l'ammontare dei log di sistema.  Aggiungere tutto quello
  che si ritiene opportuno alla linea FTAPE_OPT nel Makefile e
  ricompilare.

  <dall'Ftape-HOWTO>



  1100..1144..  CCoommee ppoossssoo ccaammbbiiaarree iill ttrraaccee--lleevveell??


  Ci sono tre modi per fare questo (in ordine di preferenza personale).
  Quando ci arriveremo, qui ci sono i significati dei vari trace-level.


  ·  0 bugs [bachi]

  ·  1 + errors [errori]

  ·  2 + warnings [avvertimenti]

  ·  3 + information [informazioni]

  ·  4 + more information [informazini ulteriori]

  ·  5 + program flow [flusso del programma]

  ·  6 + FDC/DMA info [informazioni FDC/DMA]

  ·  7 + data flow [flusso dei dati]

  ·  8 + everything else [qualsiasi altra cosa]


  1. UUttiilliizzzzaarree insmod per cambiare trace-level: se si sta utilizzando
     il meccanismo dei moduli per caricare il driver di _F_t_a_p_e, è
     possibile specificare il trace-level come opzione del comando
     insmod.



       /sbin/insmod ftape.o tracing=<trace-level>



  2. UUttiilliizzzzaarree mt per cambiare trace-level: il driver di _F_t_a_p_e ha un
     hack (-- taglio--) che permette all'opzione fsr di mt di venir
     utilizzata per impostare il trace-level.  zftape non ha questo
     hack.



       mt -f /dev/ftape fsr <trace-level>



  L'utilizzo del comando fsr in mt è un _h_a_c_k e probabilmente sparirà o
  cambierà col tempo.

  3. RRiiccoommppiillaarree ppeerr ccaammbbiiaarree ttrraaccee--lleevveell:: il file tracing.c contiene
     una linea int tracing = 3;.  Cambiare il 3 in ciò che si ritiene
     opportuno e ricompilare.

  <dall'Ftape-HOWTO>



  1100..1155..  SSttoo aavveennddoo pprroobblleemmii ccoonn FFttaappee..  SSttoo uuttiilliizzzzaannddoo ll''uullttiimmaa vveerr­­
  ssiioonnee ddii FFttaappee pprreelleevvaattaa ddaallll''hhoommee--ppaaggee ddii FFttaappee ee ccrreeddoo ddii aavveerr iinnddii­­
  vviidduuaattoo uunn bbuugg vveerroo..  CCoossaa ddeevvoo ffaarree??


  Controllare l'home-page di Ftape per una versione ancora piú recente.
  Poi controllare che le FAQ contenute nel pacchetto non riportino il
  problema riscontrato.  Successivamente provare a controllare che il
  manuale che arriva con la _d_i_s_t_r_i_b_u_z_i_o_n_e _d_i _F_t_a_p_e non menzioni i
  problema.

  Non c'è bisogno di leggere l'intero manuale.  Piú semplicemente si
  cerchi nell'indice analitico una parola che possa riferirsi al proprio
  problema e leggere il paragrafo relativo.
  Se ancora si è convinti di aver trovato un baco, allora postare una
  domanda di carattere generale che descriva il problema nella mailing-
  list di Linux-Tape, ma non allegare tutto il log dell'errore di _F_t_a_p_e.
  Se ci siamo già imbattuti nel problema in passato, faremo sapere dove
  si trova la soluzione.  Se, invece, non lo abbiamo mai visto, il
  manutentore di Ftape probabilmente richiederà l'intero log d'errore
  (ottenuto dal proprio file dei messaggi di sistema).

  <risposta di Tim Jones>



  1111..  FFAAQQ:: ddoommaannddee rreellaattiivvee aallll''««uuttiilliizzzzoo ddii FFttaappee»»!!



  1111..11..  QQuuaannttoo vvaa vveellooccee FFttaappee??


  È possibile ottenere velocità di backup e ripristino abbastanza
  rispettabili con _F_t_a_p_e: con un Colorado DJ-20 ed un controller Adaptec
  1542CF sono state misurate delle velocità di trasferimento
  continuative di 4.25MB/min (senza compressione) con un archivio tar da
  70MB, mentre si stava confrontando l'archivio sul nastro con i dati su
  di un disco IDE.  La velocità di _F_t_a_p_e dipende fortemente dalla
  velocità di trasferimento del proprio FDC: l'AHA1542CF è un FDC di
  tipo "post-1991 82077" che permette di inviare 1Mb/s di dati
  all'unità.  Se si possiede un FDC che permette di spedire 500kb/s di
  dati, si otterrà una velocità di trasferimento dimezzata (beh, ovvio).



  1111..22..  QQuuaannddoo ssccrriivvoo ssuu aallccuunnii ddeeii mmiieeii nnaassttrrii,, sseemmbbrraa cchhee ppeerrddaa uunn
  ssaaccccoo ddii tteemmppoo aa ````lluussttrraarrssii llee ssccaarrppee'''' oo nneell rriippoossiizziioonnaammeennttoo,,
  iinnvveeccee ddii ttrraassffeerriirree ddaattii..  CC''èè qquuaallccoossaa cchhee nnoonn vvaa nneell mmiioo ssiisstteemmaa??


  Ci sono stati un paio di casi di ``lustramento di scarpe''.  Questo
  accade quando il nastro sembra correre avanti ed indietro senza fine.
  Ciò è stato notato con un Jumbo 250 (<74407.3051@compuserve.com>) e
  con uno Iomega 250 Ditto Insider (<tom@opus.cais.com>).  Nell'ultimo
  caso si stava utilizzando Linux ELF con hard-disk SCSI (connesso ad un
  Adaptec 1542cf).  Pregerei di contattarmi nel caso si abbia un
  aggiornamento al riguardo.

  <dall'Ftape-HOWTO>

  Probabilmente no.  Se si sta eseguendo il backup di un gran numero di
  file di dimensione inferiore ai 2kB, bisognerà abituarsi a conviverci.
  In questo caso il riposizionamento è causato da un accesso
  spropositato al file system.  Se si sta eseguendo il backup di file di
  sistema normali, questo può essere dovuto a sporco o stiratura del
  nastro della cartuccia.  Con una semplice ritensionatura del nastro
  tutto dovrebbe sparire.  Provare con



       ftmt -f /dev/zqft0 reten



  per ritensionare il nastro.  Se la ritensionatura non risolve il
  problema e accade solo con certi nastri, può essere opportuno
  sostituire il nastro in questione.

  <risposta di Tim Jones>

  Se si utilizza afio come strumento di backup, è possibile fargli
  scrivere un gran numero di buffer in un colpo solo utilizzando il flag
  -c.  Utilizzare un valore opportuno in modo da fornire dati
  sufficienti per molti dei singoli passaggi punto-a-punto sopra il
  nastro.  Per il mio sistema, le seguanti impostazioni vanno abbastanza
  bene, in quanto fanno fermare il nastro, a sistema scarico, un numero
  di volte relativamente basso ad ogni passaggio:



       find /usr/local -xdev -print | afio -o -v -f -b 10240 -c 800 /dev/qft0



  Nel mio caso sto scrivendo 800x1024 byte per ogni scrittura sul
  nastro, cioè cira 8MB.

  Non ho fatto molte esperienze con queste impostazioni, cosí qualcuno
  potrebbe volerne cercare di migliori.

  Probabilemente altre utility di backup possono essere modificate per
  utilizzare una tecnica simile.

  <risposta di Michael Hamilton>

  Il tar di GNU non utilizza i buffer in questo modo.  Il programma di
  backup commerciale bru è in grado di trattare buffer multipli
  utilizzando memoria condivisa; questo funziona solo quando si sta
  scrivendo archivi compressi con bru (indipendentemente dal fatto che
  si stia utilizzando la compressione di _F_t_a_p_e).

  Un altro modo per sopperire al problema potrebbe essere quello di
  utilizzare piú buffer DMA nel _d_r_i_v_e_r _F_t_a_p_e _d_e_l _k_e_r_n_e_l:



       mt -f /dev/qft0 setdrvbuffer $((6*32786))



  $((6*32786)) dovrebbe venir espansa dalla propria shell quando se ne
  utilizzi una Bourne-compatibile.  Questo produce un impatto negativo
  sulla memoria di sistema: i buffer DMA di _F_t_a_p_e non possono essere
  utilizzati da nessun'altra parte del kernel, né da nessun'altra
  applicazione.  E la memoria contenente il kernel non può essere messa
  nella partizione di swap.  Se si decidesse di utilizzare questo tipo
  di bufferizzazione multipla, è conveniente scaricare il driver non
  appena il suo utilizzo è terminato.

  <risposta di Claus Heine>


  1111..33..  DDeevvoo ffaarr rriippaarrttiirree iill mmoonnddoo DDOOSS ppeerr ffoorrmmaattttaarree ii nnaassttrrii??


  No, se si sta usando l'ultima versione dei _d_r_i_v_e_r _d_i _F_t_a_p_e disponibile
  all'home-page di Ftape.

  Per formattare un nastro QIC-80, TR-1, TR-3, QICWide 3010 o 3020,
  procurarsi l'ultima versione di ftape e l'ultima versione del
  pacchetto ftape-tools (dallo stesso sito) e leggere la documentazione
  dell'utility ftformat inclusa nel pacchetto ftape-tools.
  (* Non provare a formattare nastri Ditto 2GB.  *)

  (* Non provare a formattare nastri Ditto Max o Max Pro.  *)

  <risposta di Tim Jones e Claus Heine>



  1111..44..  ÈÈ ppoossssiibbiillee ffoorrmmaattttaarree nnaassttrrii DDiittttoo 22GGBB ccoonn ffttaappee??


  Non è possibile formattare nastri Ditto 2GB con unità a nastro Ditto
  2GB, cosí come non è assolutamente possibile riformattare nastri Ditto
  2GB in modo tale da poter essere utilizzati ancora da unità a nastro
  Ditto 2GB.

  Questa è una limitazione hardware dell'unità a nastro Ditto 2GB.  Non
  c'è possibilità di aiuto a livello software, cioè non è una mancanza
  di ftape.



  1111..55..  ÈÈ ppoossssiibbiillee ffoorrmmaattttaarree nnaassttrrii DDiittttoo MMaaxx oo MMaaxx PPrroo ccoonn ffttaappee??


  No, il Ditto Max non può formattare nastri.

  Questa è una limitazione hardware dell'unità a nastro Ditto 2GB.  Non
  c'è possibilità di aiuto a livello software, cioè non è una mancanza
  di ftape.



  1111..66..  FFttaappee rriilleevvaa ppiiúú sseettttoorrii ddaannnneeggggiiaattii ccoonn nnaassttrrii QQIICC--33002200 ddii
  qquuaannttoo nnoonn ffaacccciiaa DDOOSS..


  Se si presta attenzione alla differenza, si noterà che _F_t_a_p_e rileva
  sempre 2784 settori in piú di DOS.

  Il numero che _F_t_a_p_e riporta è corretto (ovviamente :-).  Tutti i
  nastri QIC-3020 correttamente formattati hanno 2784 settori in
  posizioni predefinite che sono marcati nella mappa dei settori
  danneggiati.  Quotando dalle specifiche:


       Le tracce 5,7,9,11,13,15,17,19,21,23,25 e 27 comprese nei 4
       segmenti o dell'EOT o del BOT sono disposte per aumentare i
       tassi d'errore per via delle hole imprints [impronte del
       buco?].  Per questo motivo queste regioni devono essere map­
       pate come danneggiate nel momento della formattazione ed
       ascritte nella mappa dei settori danneggiati per indicare
       che tutti i settori all'interno dei segmenti identificati
       sono danneggiati.??


  Questo fornisce 12 tracce * 2 * 4 segmenti * 29 settori = 2784
  settori.

  Cosí _F_t_a_p_e preferisce riportare il numero effettivo di settori che non
  possono essere utilizzati sul nastro, mentre DOS fornisce un numero
  piú ottimistico indicando una migliore qualità del nastro.  Il
  comportamento di _F_t_a_p_e, comunque, potrebbe cambiare in futuro per
  rilevare una formattazione corretta e mostrare due numeri separati.
  In ogni caso a questo, per ora, non è riservata un'alta priorità.

  I nastri QIC-3010 sono simili ai QIC-3020 al riguardo.

  <dall'Ftape-HOWTO>



  1111..77..  NNoonn ccii ssoonnoo pprroobblleemmii ssee nnoonn sseennttoo iill nnaassttrroo mmuuoovveerrssii qquuaannddoo
  iimmppaarrttiissccoo uunn ccoommaannddoo ffssff  oo bbssff  ccoonn mmtt ??


  No.  L'unità semplicemente aggiorna un contatore interno quando riceve
  questi comandi.  Il nastro dovrebbe muoversi alla posizione corretta
  con l'accesso in lettura o scrittura all'unità successivo.

  <dall'Ftape-HOWTO>



  1111..88..  PPeerrcchhéé iill mmiioo pprrooggrraammmmaa ddii bbaacckkuupp XXYYZZ  ssii llaammeennttaa ddii eerrrroorrii ddii
  ttiippoo ````IInnvvaalliidd aarrgguummeenntt'''' [[aarrggoommeennttoo nnoonn vvaalliiddoo]]??


  zftape richiede che i dati vengano scritti come multipli della
  dimensione dei blocchi minima fissata.  Questo è un comportamento
  tipico per una periferica a nastro.  Ci sono tre modi per eliminare
  questi errori:

  ·  impostare la dimensione dei blocchi di _F_t_a_p_e alla dimensione dei
     blocchi utilizzati dal programma di backup.  L'esempio sottostante
     è applicabile ad afio:



       mt -f /dev/qft0 setblk 5120



  ·  se non si vuole utilizzare la compressione di _F_t_a_p_e, è anche
     possibili usare:



       mt -f /dev/qft0 setblk 0



  per attivare la modalità di dimensione variabile dei blocchi di _F_t_a_p_e
  ed essere in grado di scrivere i dati sul nastro in porzioni arbi­
  trarie (mmaa la compressione interna non funziona con questa
  impostazione).  Quando si avesse l'intenzione di utilizzare KBackup,
  questo è il solo modo per farlo lavorare assieme ad _F_t_a_p_e (perlomeno
  dovrebbe funzionare, ma non so con esattezza se lo fa).

  ·  informare il proprio programma di backup circa la dimensione di
     default di 10kB dei blocchi di _F_t_a_p_e (che è anche il valore tipico
     per GNU tar).  Per afio è possibile utilizzare il seguente comando:



       afio -b 10k ...


  È opportuno leggersi la sezione ``Tape blocks'' del manuale
  (utilizzare l'indice analitico per andare direttamente alla sezione
  relativa).

  Quando si utilizza la compressione interna di GNU tar con versione di
  GNU tar antecedente la tar-1.12, è necessario lanciare tar con
  l'opzione --block-compress impostata su re-block.  In caso contrario
  tar comprimerà i dati che legge e li scriverà in porzioni arbitrarie
  sul nastro.

  Eesempio:


       tar -czvf /dev/qft0 --block-compress /etc



  AAtttteennzziioonnee:: non si dovrebbe utilizzare la compressione interna di tar
  con grandi backup, in quanto ciò produce un enorme blocco compresso
  del flusso di dati.  Se un tale archivio viene rovinato proprio
  all'inizio, è veramente difficile ripristinarlo.

  <risposta di Claus Heine>



  1111..99..  EErrrroorrii II//OO ee FFDDCC:: aallccuunnee ssppiieeggaazziioonnii..


  Se si ottengono i seguenti messaggi, questo è ciò che fa per te!

  ·  fdc-io.c (ft_handle_perpend) - Your FDC does not support QIC-3020
     [l'FDC non supporta il QIC-3020].

  ·  Cannot write to /dev/qft0: I/O error [non posso scrivere su
     /dev/qft0: errore di I/O].

  La spiegazione:

  ``FDC'' significa ``Floppy Disk Controller'' [controllore per dischi
  floppy].  Il problema è che il proprio controller floppy deve essere
  in grado di supportare qualcosa chiamato ``perpendicular mode'' [modo
  perpendicolare], per essere in grado di leggere e scrivere cartucce
  QIC-3020/QIC-3010 (cioè cartucce TR-3).  Per quanto ne sappia, tutti
  gli FDC che sono in grado di trasferire dati ad almeno 1Mb/s
  supportano anche il ``perpendicular mode'' (l'aggettivo
  ``perpendicolare'' si riferisce alla direzione della magnetizzazione
  delle particelle ferro magnetiche sul nastro).

  Questo significa che è necessario procurarsi un altro FDC.  Oppure
  dare un'occhiata in qualche negozio per computer e chiedere di una
  scheda di controllo I/O che sia in grado di supportare floppy da
  2.88MB (che implica un velocità di trasferimento di 1Mb/s ed il modo
  perpendicolare).

  È possibile anche procurarsi i cosiddetti ``controller ad alta
  velocità'', che supportano anche trasferimenti da 2Mb/s.  Questi
  controller sono basati su un FDC Intel 82078.  Iomega vende tali
  schede sotto il nome di ``Ditto Dash''.  Penso che anche Exabyte venda
  i suoi controller da 2Mb/s separatamente, mentre Seagate fornisce
  l'unità TR-3 (cioè TST-3200) con questi controller inclusi.

  <risposta di Claus Heine>


  1111..1100..  PPeerrcchhéé ootttteennggoo eerrrroorrii ddeell ttiippoo «« //ddeevv//qqfftt00:: NNoo ssuucchh ddeevviiccee »»
  [[//ddeevv//qqfftt00:: nneessssuunn ddeevviiccee ccoommee qquueessttoo]]??


  Supponiamo che il problema sia il seguente. Il modulo _F_t_a_p_e è caricato
  correttamente nel kernel:



       /usr/src/ftape-3.03b-970603# lsmod
        Module         Pages    Used by
        ftape             22          0



  ma accade che:


       $ ftmt -f /dev/qft0 status
       ftmt: /dev/qft0: No such device



  La soluzione: è necessario anche caricare il modulo _z_f_t_a_p_e_._o.  Con
  Ftape-3.* il modulo _f_t_a_p_e_._o non implementa l'interfaccia VFS.  Questo
  è fatto da _z_f_t_a_p_e_._o.

  <risposta di Claus Heine>



  1111..1111..  OOtttteennggoo uunn ````ddeevviiccee bbuussyy'''' [[ppeerriiffeerriiccaa ooccccuuppaattaa]] qquuaannddoo eesseegguuoo
  bbaacckkuupp mmuullttiippllii ssuu ddii uunn nnaassttrroo uuttiilliizzzzaannddoo aallccuunnii ssccrriipptt..


  I messaggi di ``periferica occupata'' possono verificarsi mentre le
  _f_i_l_e _d_i _p_e_r_i_f_e_r_i_c_a _d_i _F_t_a_p_e sono ancora mantenute aperte da alcuni
  programmi.  Non appena la chiamata di sistema close() viene
  completata, il flag di occupato viene azzerato.  Potrebbe darsi che
  bru, o altri programmi, abbiano eseguito un fork di un figlio che
  ritarda a morire?

  Sí, questo riproduce il problema:


       tar -cvvzf /dev/nqft0 --block-compress ; mt rewind



  È possibile omettere --block-compress se si sta utilizzando un
  versione di GNU tar piú recente.

  Comunque questo non è un baco di _F_t_a_p_e.  Sembra che il processo tar
  genitore esca prima che suo figlio abbia chiuso il device del nastro.
  So comunque, per aver studiato il codice di tar alcuni anni fa, che
  tar attende correttamente che il proprio genitore muoia.

  In ogni caso, il messaggio di occupato significa semplicemente che la
  variabile ``busy'' [occupato] è ancora mantenuta ad un valore logico 1
  (zftape/zftape-init.c), e questo significa semplicemente che c'è
  ancora un processo in giro che tiene il device del nastro aperto.


  Penso di aver capito il motivo (solo nel caso di tar in quanto di
  questo ho il codice sorgente).

  Se si utilizza tar con la compressione abilitata, allora viene
  eseguito un fork di un figlio che diventerà il compressore tramite
  l'esecuzione di gzip o qualcos'altro.  Prima della chiamata a
  execlp(), il figlio eseguirà un fork di un nipote di suo padre tar.
  Questo nipote eseguirà l'effettvo lavoro di I/O sul nastro.



       tar - fork() - scrive verso il figlio di tar
               |
         figlio di tar - fork() - gzip (eseguirà un pipe al nipote di tar)
                           |
                     nipote di tar - apre l'archivio



  Ora, il genitore tar aspetta che suo figlio muoia.  gzip sicuramente
  non aspetta il nipote in quanto gzip è il risultato di un execlp().

  Ciò che non so è se il nipote dovrebbe essere implicitamente aspettato
  dal genitore tar o se la funzione wait() aspetta anche i nipoti.

  Comunque questo sembra essere il problema: il genitore tar è uscito
  mentre suo nipote è ancora occupato a chiudere l'archivio.  In
  condizioni normali difficilmente si noterà questo problema se la
  funzione close() viene portata a termine velocemente (cioè file
  regolari, periferiche a blocchi e magari altri device per nastri?), ma
  non è un baco di _F_t_a_p_e, mentre lo è nei programmi di backup, nel
  kernel o forse nel codice d'uscita delle libc.

  Non so se le considerazione fatte in precedenza si possono essere
  applicate anche a bru.  Se non ci sono nipoti e il processo padre
  attende in maniera corretta suo figlio, allora non ci dovrebbero
  essere problemi.

  <risposta di Claus Heine>



  1111..1122..  CCoommee ffaacccciioo aa...... ccoonn ttaarr ??


  Queste sono propriamente domande per tar: si prega di leggersi la
  pagina man e la pagina info realtive.  Se non sono installate sul
  sistema, provare con



       tar  --help 2>&1 | less



  Se la propria versione di tar è la v1.11.1 o precedente, si consideri
  l'opportunità di aggiornarla alla v1.11.8.  Questa versione può
  chiamare GNU zip direttamente (cioè supporta l'opzione -z) e possiede
  un elaborato help incluso.  Inoltre tutto può essere compilato in
  ambiente Linux.

  <dall'Ftape-HOWTO>


  1111..1133..  CChhee ddiimmeennssiioonnee ppeerr ii bblloocccchhii ddeevvoo uuttiilliizzzzaarree ccoonn ttaarr ??


  Se si fa uso della compressione (ed anche piú in generale), può
  tornare a proprio favore specificare a tar che deve spezzettare
  l'uscita in blocchi grossi.  Poiché _F_t_a_p_e taglia i dati in blocchi da
  29kB, un ``-b58'' dovrebbe essere ottimo.

  «Perché 29kB?» mi sembra di sentir gridare.  Beh, lo standard QIC-80
  specifica che tutti i dati debbano essere protetti da un Error
  Correcting Code [codice per la correzione d'errore] (ECC).  Il codice
  specificato nello standard QIC-80 è conosciuto come codice Reed-
  Solomon (R-S).  Il codice R-S considera 29 byte di dati e genera 3
  byte di parità.  Per aumentare le prestazioni del codice ECC, i byte
  di parità sono generati su 29 settori da 1kB.  Cosí _F_t_a_p_e prende 29kB
  di dati, aggiunge 3kB di parità ECC e scrive 32kB sul nastro alla
  volta.  Per questa ragione _F_t_a_p_e scriverà e leggerà sempre blocchi da
  32kB per essere in grado di rilevare (e correggere) eventuali errori.

  Se si possiede una spiccata curiosità e si vuole conoscere di piú, è
  possibile dare un'occhiata ai file ecc.c ed ecc.h per una spiegazione
  del codice e un riferimento a testi sui codici Reed-Solomon.

  <dall'Ftape-HOWTO>



  1111..1144..  DDoovvee ppoossssoo ttrroovvaarree ii bbiinnaarrii,, ii ssoorrggeennttii ee llee ppaaggiinnee mmaann  ddii
  ttaarr ,, mmtt ,, ccppiioo  ee dddd ??


  Tutti questo strumenti sono stati sviluppati dal progetto GNU ed i
  sorgenti (cosí come le pagine man) possono essere prelevate da
  praticamente ogni sito ftp nel mondo (inclusi ftp.funet.fi,
  tsx-11.mit.edu, e sunsite.unc.edu).  In ogni caso possono essere
  prelevati dal sito ufficiale GNU: prep.ai.mit.edu
  [18.71.0.38]:/pub/gnu.  Le ultime versioni (ad oggi 12 settembre 1996)
  sono:



       cpio:   2.4.2 (cpio-2.4.2.tar.gz)
       dd:     3.13 (fileutils-3.13.tar.gz)
       mt:     2.4.2 (cpio-2.4.2.tar.gz)
       tar:    1.11.8 (tar-1.11.8.tar.gz)
       gzip:   1.2.4 (gzip-1.2.4.tar.gz)



  Tutto quanto può essere compilato in ambiente Linux successivo alla
  versione v1.0.4, libc v4.5.19 e gcc v2.5.8.

  <dall'Ftape-HOWTO>



  1111..1155..  SSee uuttiilliizzzzoo llaa ccoommpprreessssiioonnee ddeellll''uunniittàà aa nnaassttrroo,, èè ssbbaagglliiaattoo
  ssffrruuttttaarree aanncchhee llaa ccoommpprreessssiioonnee ddii zzffttaappee ..  OO ssaarreebbbbee mmeegglliioo nnoonn uuttii­­
  lliizzzzaarree llaa ccoommpprreessssiioonnee ddeellll''uunniittàà ee llaasscciiaarree cchhee ffaacccciiaa ttuuttttoo zzffttaappee
  ??


  Non è cosí sbagliato come utilizzare la compressione due volte (che
  sarebbe il caso in cui si utilizza la compressione dell'unità assieme
  alla compressione di _f_t_a_p_e), ma non ha senso.  Non si guadagna un
  maggior compressione, ma solo cicli di CPU sprecati.

  La compressione dell'unità dovrebbe essere abbastanza sicura, in
  quanto l'unità comprime singoli file, a differenza di tar -czf..., che
  fa dell'intero flusso di dati un grande blocco compresso.  Questa,
  infatti, è una pessima idea con backup seri, in quanto un singolo byte
  rovinato all'inizio dell'archivio può rendere inutilizzabile l'intero
  archivio, o, almeno, ne rende piuttosto difficoltoso un suo recupero.

  <risposta di Claus Heine>



  1111..1166..  CCoomm''èè llaa ccoommpprreessssiioonnee ddii zzffttaappee  aa ccoonnffrroonnttoo ddii qquueellllaa,, ddiiccii­­
  aammoo,, ddii ggzziipp --99 ??


  gzip -9 è migliore (cioè si può ottenere una maggiore compressione).
  La compressione di _z_f_t_a_p_e è paragonabile al programma Un*x compress,
  ma dovrebbe essere piú veloce, e lo è rispetto a gzip.

  <risposta di Claus Heine>



  1111..1177..  NNoonn uuttiilliizzzzoo llaa ccoommpprreessssiioonnee,, mmaa sseennttoo cchhee ll''iinntteerrffaacccciiaa
  zzffttaappee  ssee nnee ssttaa aannddaannddoo..  CCoossaa ppoossssoo ffaarree??


  Si utilizzi l'_i_n_t_e_r_f_a_c_c_i_a _z_f_t_a_p_e, senza caricare il modulo _z_f_t_-
  _c_o_m_p_r_e_s_s_o_r.  Il device allora diventa /dev/qft0.

  <risposta di Tim Jones>



  1111..1188..  FFttaappee ddiiccee «« TThhiiss ttaappee hhaass nnoo ''LLiinnuuxx rraaww ffoorrmmaatt'' »» [[qquueessttoo
  nnaassttrroo nnoonn èè nneell ````ffoorrmmaattoo eelleemmeennttaarree LLiinnuuxx'''']]..


  Si ottiene questa lamentela se non si è _c_a_n_c_e_l_l_a_t_o il proprio nastro
  appena formattato.  Questo accade perché _F_t_a_p_e si aspetta un ``magic
  header'' [intestazione magica] sul nastro per sapere di essere in
  grado di interpretare il segmento di intestazione a suo modo (cioè con
  i marcatori di file).  Per eliminare il problema, impartire il
  comando:


  mt -f /dev/nftape erase



  <dall'Ftape-HOWTO>



  1111..1199..  PPoossssoo ssccaammbbiiaarree nnaassttrrii ccoonn qquuaallccuunnoo cchhee uuttiilliizzzzaa iill DDOOSS??


  No.  Il software per DOS è conforme alle specifiche QIC-80 circa la
  disposizione del filesystem di DOS e non dovrebbe essere un grosso
  problema scrivere un programma che possa leggere e scrivere il formato
  DOS.  Infatti, scommetto che creare un'interfaccia utente graziosa
  sarebbe un problema piú grande.


  <dall'Ftape-HOWTO>



  1111..2200..  CCoommee ffuunnzziioonnaa mmtt eeoomm  qquuaannddoo ssii ccoommiinncciiaa aa ssoovvrraassccrriivveerree uunn
  nnaassttrroo ddaallllaa mmeettàà??


  Per inciso, EOM è l'acronimo di ``End Of recorded Media'' [fine del
  supporto di registrazione], la posizione esattamente dopo tutti i dati
  già registrati sul nastro.

  Non si può utilizzare i ``file'' del nastro come file di un ordinario
  filesystem.  In linea di principio, un nastro non permette nient'altro
  che aggiungere nuovi dati in coda all'EOM.  Ciò nonostante, se ci si
  posiziona proprio nel mezzo dei dati già registrati e si comincia a
  scrivere, allora l'unità prima cancella tutti i file successivi (cosí
  da spostare l'EOM alla posizione effettiva) e poi comincia a scrivere.
  Cosí il nuovo EOM, terminato il processo di scrittura, si trova dopo i
  dati appena registrati.  Una delle conseguenze di quanto sopra, è che,
  ovviamente, quella scrittura sul nastro nel mezzo dell'area già
  registrata è distruttiva, nel senso che non solo sovrascrive il
  ``file'' sopra il quale la testina era posizionata, ma cancella anche
  tutti i file che seguono.

  <dall'Ftape-HOWTO>

  <risposta di Claus Heine>



  1111..2211..  QQuuaannddoo eesseegguuiivvoo ddeeii bbaacckkuupp pprriimmaa ddii uuttiilliizzzzaarree ttaappeerr ,, ssoottttoo
  ffttaappee 22..00..2299 llaa mmiiaa uunniittàà nnoonn ssuuppppoorrttaavvaa ll''ffssff,, mmeennttrree ssoottttoo iill nnuuoovvoo
  zzffttaappee  lloo ssuuppppoorrttaa..  PPeerrcchhéé ddoovvrreebbbbee ee ccooss''èè eessaattttaammeennttee ll''ffssff??


  Probabilmente non funzionava prima perché non si era utilizzato un



       mt -f /dev/rft0 erase



  prima di scrivere i dati sulla cartuccia.  Questo nnoonn èè ppiiúú
  necessario.

  Ma ``mt fsf'', cosa significa?  Le unità a nastro non registrano i
  file in modo che si possa utilizzare un


  cp qualche_file /dev/la_mia_unità



  o in modo da essere capaci di montare un'unità a nastro cosí come si
  monta un hard-disk.  Non è possibile fare altro con un'unità a nastro
  se non scrivere dati in maniera sequenziale su di essa.

  Poiché queste è abbastanza scomodo, qualcuno ha inventato qualcosa che
  è conosciuto con il nome di _f_i_l_e _m_a_r_k o _e_o_f _m_a_r_k (_e_o_f è l'acronimo di
  ``End Of File'' [fine del file]).  Questi marcatori non separano i
  file di cui è stato fatto il backup sull'unità a nastro, ma separano
  solo i blocchi di dati (qualsiasi cosa i dati possano rappresentare).

  Normalmente i driver del kernel dell'unità a nastro si occupano di
  scrivere questi marcatori di file quando il device del nastro viene
  chiuso, cioè con



       tar -cf /dev/nqft0 /bin
       tar -cf /dev/nqft0 /etc
       mt -f /dev/nqft0 rewind



  si otterrebbe un backup di tutti i file sotto /bin ed /etc.  Quando il
  primo tar termina, il driver del kernel si occuperà della scrittura di
  un marcatore di file sul nastro alla posizione corrente e, quando
  termina il seconfo processo tar, un altro marcatore di file viene
  scritto sulla cartuccia in quella posizione.  Ora, il motivo di questi
  marcatori di file consiste nel fatto che è possibile saltare fra
  archivi differenti presenti sul nastro piú velocemente di come si
  potrebbe fare con un rilettura sequenziale dei dati.

  I comandi che fanno questo sono:

     mmtt ffssff
        cvanzamento veloce al prossimo marcatore di file verso l'EOT
        (End Of Tape [fine del nastro]),


     mmtt bbssff
        avanzamento veloce al prossimo marcatore di file verso il BOT
        (Begin Of Tape [inizio del nastro]).

  Cosí, per estrarre il secondo archivio nell'esempio precedente, non è
  necessario rileggere il primo archivio, ma procedere come segue:



       mt -f /dev/nqft0 rewind
       mt -f /dev/nqft0 fsf
       tar -xvf /dev/nqft0



  <risposta di Claus Heine>



  1111..2222..  QQuuaall''èè eessaattttaammeennttee llaa ddiiffffeerreennzzaa ffrraa ffttaappee  ee zzffttaappee ??


  Quando _F_t_a_p_e era ancora giovane, c'erano due versioni dei driver per
  unità a nastro, una delle quali venne chiamata _z_f_t_a_p_e per via della
  sua compressione interna eseguita al volo e trasparente all'utente.
  Se questa sia una caratteristica positiva od un baco (in quanto non
  strettamente necessario che sia fatta dal codice del kernel) è
  un'altra questione.  Comunque sia, l'interfaccia ioctl e l'uso dei
  marcatori di file forniti da _z_f_t_a_p_e erano notevolmente superiore e con
  meno bachi.  Inoltre _z_f_t_a_p_e permette di utilizzare cartucce a nastro
  per floppy con differenti sistemi operativi.  Beh, non è possibile
  scambiare dati, ma _f_t_a_p_e non sovrascriverà i volumi creati con il
  proprio programma Windoze e viceversa.

  Oggi giorno _F_t_a_p_e è il nome dell'intero pacchetto di driver per unità
  a nastro via controller floppy, eedd ftape.o è il nome del file del
  modulo kernel che implementa il supporto hardware a basso livello.
  zftape ha cessato di esistere come un pacchetto separato, mentre la
  nuova versione di _F_t_a_p_e (da ftape-3.00) contiene un modulo zftape.o
  che si appoggia ad ftape.o (cioè diventa necessario caricare eennttrraammbbii
  i moduli per essere in grado di accedere alla propria unità) e
  implementa l'interfaccia del sistema di file e le caratteristiche
  avanzate della precedente versione di zftape.

  <risposta di Claus Heine>



  1111..2233..  QQuuaall''èè llaa ddiiffffeerreennzzaa ffrraa uunnaa ppeerriiffeerriiccaa rriiaavvvvoollggeennttee eedd uunnaa
  nnoonn--rriiaavvvvoollggeennttee??


  Beh, i file delle periferiche a nastro riavvolgenti riavvolgono il
  nastro al BOT (Begin Of Tape [inizio del nastro]), cioè



       tar -cvf /dev/qft0 /bin



  riavvolgerà la cartuccia quando il lavoro di tar è terminato.  Invece



       tar -cvf /dev/nqft0 /bin



  nnoonn riavvolgerà la cartuccia e lascierà la testina di
  lettura/scrittura nella possizione corrente.

  Periferiche riavvolgenti dovrebbero essere utilizzate quando si
  effettuano backup singoli; periferiche non-riavvolgenti dovrebbero
  essere utilizzate quando si eseguono backup multipli, a meno che non
  ci sia bisogno di tutto lo spazio fino all'EOM (End Of recorded Media
  [fine del supporto di registrazione]) prima di aggiungere un altro
  archivio.

  Le periferiche non-riavvolgenti ddeevvoonnoo essere utilizzate quando si
  invia un qualsiasi comando di movimento all'unità a nastro, come



       mt -f /dev/nqft0 fsf



  perché, quando il processo mt termina, l'unità a nastro viene chiusa e
  ciò comporta un riavvolgimento della cartuccia con le periferiche
  riavvolgenti.

  <risposta di Claus Heine>



  1111..2244..  CC''èè qquuaallccuunnoo cchhee ppoottrreebbbbee ddiirrmmii ccoommee uuttiilliizzzzaarree mmtt  ppeerr
  rriiaavvvvoollggeerree llaa mmiiaa uunniittàà TTRR--33 ddooppoo aavveerr rreeggiissttrraattoo uunn aarrcchhiivviioo ccoonn
  zzffttaappee ,, ccoossíí ddaa ppootteerrlloo vveerriiffiiccaarree??


  Beh, dipende.  Se il nastro è ancora posizionato all'interno del
  volume appena scritto, un ``mt bsf 1'' (o equivalentemente ``mt bsf'')
  farà ritornare il nastro proprio all'inizio di quel volume (questo è
  il modo in cui tar --verify lavora).  Se il nastro è già posizionato
  ddooppoo il marcatore di file che indica la fine dell'ultimo volume
  scritto, allora è neccessario impartire un ``mt bsf 2''.

  La logica che sta dietro a tutto ciò è la seguente: Il ``contatore
  MTBSF'' viene decrementato di tante unità quanti sono i marcatori di
  file contati, il nastro viene fermato e successivamente posizionato
  sull'EOT dell'ultimo marcatore di file saltato.  Questo significa che
  un mt bsf 2 posizionerà il nastro esattamente all'inizio del
  precedente volume.

  <risposta di Claus Heine>



  1111..2255..  ````NNoonn--rriiaavvvvoollggeennttee'''' ssiiggnniiffiiccaa cchhee ««nnoonn ssii rriiaavvvvoollggee aauuttoommaattii­­
  ccaammeennttee»»,, ggiiuussttoo??  NNoonn ssttaa aadd iinnddiiccaarree cchhee ssoottttoo nneessssuunnaa cciirrccoossttaannzzaa
  nnoonn ssii rriiaavvvvoollggeerràà,, vveerroo??  HHoo pprroovvaattoo aadd uuttiilliizzzzaarree //ddeevv//zzqqfftt00  eedd iill
  nnaassttrroo èè ssttaattoo ssuubbiittoo rriiaavvvvoollttoo..


  Corretto: ``auto-riavvolgente'' significa che il nastro viene
  riavvolto quando il file di periferica viene chiusa; ``non-
  riavvolgente'' sta ad indicare che il nastro non è automaticamente
  riavvolto quando la periferica viene chiusa (ma, ovviamente, è
  possibile utilizzare i comandi bsf ed fsf di movimento del nastro per
  posizionare la testina in qualsiasi posizione si desideri).

  <risposta di Claus Heine>



  1111..2266..  QQuuaall''èè llaa ddiiffffeerreennzzaa ffrraa cciiòò cchhee mmtt  ccoonnssiiddeerraa uunn rreeccoorrdd ee cciiòò
  cchhee ccoonnssiiddeerraa uunn ffiillee??


  Un record è il quantitativo minimo di byte che verranno accettati dal
  nastro in una singola operazione di lettura/scrittura (tranne che nel
  modo ``variable block size mode [modalità dimensione blocco
  variabile]'', per la quale dovrebbe rappresentare il quantitativo di
  dati effettivamente scritti in una singola operazione di scrittura).

  Per zftape ogni accesso per lettura o scrittura deve essere un
  multiplo di una dimensione di blocco fissa (fissa, ma regolabile con
  MTSETBLK).  La dimensione di blocco è un ``tape record [record del
  nastro]'' (come viene chiamata nella pagina di manuale di GNU mt) ed
  assume un valore di 10kB per zftape.

  Un ``file'' (nella terminologia delle pagine di manuale di mt) è un
  termine ben definito.  Sta ad indicare un'area del nastro fra due
  marcatori di file.  Questo non è un file come lo è quello di un
  filesystem, nel senso che possiede un nome, delle modalità di accesso,
  può essere spostato o copiato con cp, mv, rm, etc.

  Al contrario, è semplicemente l'area del nastro che è stata registrata
  in una sessione di backup, la sua fine è marcata con un marcatore di
  file del nastro e il suo inizio è delimitato da un BOT o dal marcatore
  del ``file'' precedente.  Questi ``file'' di nastro sono oggetti che
  possono essere saltati con i comandi mt bsf ed mt fsf.

  <risposta di Claus Heine>



  1111..2277..  RRiiuuttiilliizzzzaarree nnaassttrrii ccoonn zzffttaappee  sseennzzaa rriiffoorrmmaattttaarree iill nnaassttrroo..


  Proviamo a rispondere alle seguenti domande:

  ·  C'è un buon metodo per cancellare o rimuovere dati, o almeno volumi
     dal nastro, senza riformattarlo?

  ·  È possibile sovrascrivere l'ultimo volume di un nastro senza fare
     un disastro?

  ·  È possibile sovrascrivere gli ultimi volumi senza fare danni?

  ·  È possibile cancellare l'ultimo volume?

  Se si desidera ``cancellare'' un'intera cartuccia, digitare
  semplicemente:



       mt -f /dev/qft0 erase



  Questo cancellerà la tavola dei volumi (cioè i marcatori di file).

  Con le versioni di ftape o zftape antecedenti la 3._x era possibile
  sovrascrivere volumi già presenti sulla cartuccia.  Ho rimosso questa
  caratteristica in quanto mi è stato riferito che ha già causato la
  perdita di dati con alcuni programmi di backup.

  Se, invece, si necessita di rimuovere alcuni volumi dal nastro, allora
  si deve utilizzare il programma



       vtblc



  che viene distribuito con il pacchetto ftape-tools scaricabile dallo
  stesso sito del pacchetto dei driver del kernel di ftape.  Si prega di
  fare riferimento alla documentazione contenuta nel pacchetto ftape-
  tools per maggiori informazioni.

  Se si desidera semplicemente riutilizzare vecchi nastri, allora è
  sufficiente impartire un



       mt rewind



  Se il nastro si trova al BOT (Begin Of Tape [inizio del nastro]),
  allora ogni accesso in scrittura al nastro cancellerà implicitamente
  tutti i marcatori di file e sovrascriverà i dati già presenti sul
  nastro.

  <risposta di Claus Heine>



  1111..2288..  QQuueessttoo ssccrriipptt ppeerrmmeettttee ddii ootttteenneerree uunn sseemmpplliiccee iinnddiiccee ddii uunn
  ppaacccchheettttoo zzffttaappee  uuttiilliizzzzaannddoo lloo iiooccttll TTIIOOCCVVOOLLIINNFFOO ..


  Qui di seguito viene riportato un piccolo script in perl/bash che list
  il contenuto di una cartuccia utilizzando lo specifico ioctl
  ``volinfo'' di zftape.  Spero che permetta di capire come trattare
  questo tipo di esigenza.

  Ciò che fondamentalmente fa è:

  1. riavvolgere la cartuccia;

  2. impartire il comando volinfo



          claus@thales:~$ mt volinfo
          file number          = 1
          block size           = 10240
          physical space used  =  522.0 kilobytes
          real size of volume  =  520.0 kilobytes



  analizzandone il contenuto e posizionando i valori in varibili appro­
  priate;

  3. saltare al volume successivo con mt fsf;

  4. uscire se questo produce un errore (EOD), oppure saltare al secondo
     passo.

  LLoo ssccrriipptt iinn PPeerrll



  ______________________________________________________________________
  #!/usr/bin/perl
  #
  #     Copyright (C) 1997 Claus-Justus Heine
  #
  # This program is free software; you can redistribute it and/or modify
  # it under the terms of the GNU General Public License as published by
  # the Free Software Foundation; either version 2, or (at your option)
  # any later version.
  #
  # This program is distributed in the hope that it will be useful,
  # but WITHOUT ANY WARRANTY; without even the implied warranty of
  # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  # GNU General Public License for more details.
  #
  # You should have received a copy of the GNU General Public License
  # along with this program; see the file COPYING.  If not, write to
  # the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
  #
  #   This script implements a simple contents listing for the zftape
  #   package using the MTIOCVOLINFO ioctl.
  #

  $version = <<EOT;
  listtape-1.0 -- a perl script to list the contents of a floppy tape cartridge
  under Linux using the zftape driver

  RCS \$Revision: 1.16 $
  RCS \$Date: 1999/04/05 20:18:16 $
  EOT

  $tapedev = "/dev/tape";
  $usage"= <<EOT;
  Usage: listtape [options ...]

  Mandatory or optional arguments to long options are mandatory or optional
  for short options too.

  -f, --file=FILE       Tape device to use. Default is  "/dev/tape".
  -h, --help            Print this help.
  -?                    Same as '-h'.
  --usage           Same as '-h'.
  -V, --version         Print version information.

  Author: Claus-Justus Heine <claus\@momo.math.rwth-aachen.de>
  EOT

  while ($ARGV[0] =~ /^-/) {
  $_ = shift;
  if (/--file/) {$_ = shift; $tapedev = $_; next;}
  if (/-f/) {$_ = shift; $tapedev = $_; next;}
  if (/--help/) { print $usage; exit 0; }
  if (/-h/) { print $usage; exit 0; }
  if (/--usage/) { print $usage; exit 0; }
  if (/-\?/) { print $usage; exit 0; }
  if (/--version/) { print $version; exit 0; }
  if (/-V/) { print $version; exit 0; }
  die $usage;
  }

  &open_tape($tapedev, "status");
  while(<FTMT>)
  {
  $online = 1 if (/.*online.*/);
  }

  if (! $online) { die "No cartridge present.\n"; }

  &mtop($tapedev, "rewind");

  printf "%11s%12s%20s%20s\n",
  "file number", "block size", "volume size", "tape space";

  while (1)
  {
  &open_tape($tapedev, "volinfo");
  while (<FTMT>) {
  if (/^file number\s*=\s*([0-9]*)$/) { $filenumber = $1; }
  if (/^block size\s*=\s*([0-9]*)$/) { $blocksize = $1; }
  if (/^physical space used\s*=\s*([[0-9]*.*)/) { $rawsize = $1; }
  if (/^real size of volume\s*=\s*([[0-9]*.*)/) { $size = $1; }
  }
  close(FTMT);
  if (&mtop($tapedev, "fsf 1") != 0) {
  &mtop($tapedev,"rewind");
  print "\nRemaining space: $rawsize\n";
  print "Tape block size: $blocksize\n";
  exit 0;
  }
  printf "%6d          %5d  %20s%20s\n",
      $filenumber, $blocksize, $size, $rawsize;
  }

  sub mtop
  {
  local ($tape, $operation) = @_;
  local ($exitval);
  system "ftmt -f $tape $operation > /dev/null 2>&1";
  }

  sub open_tape
  {
  local ($tape, $operation) = @_;
  local ($command);

  $command = "ftmt -f " . $tape . " " . $operation . " |";
  open(FTMT, $command) || die "Couldn't open $command -- $!\n";
  }
  ______________________________________________________________________



  LLoo ssccrriipptt iinn BBaasshh



  ______________________________________________________________________
  #! /bin/bash
  #
  #     Copyright (C) 1997 Claus-Justus Heine
  #
  # This program is free software; you can redistribute it and/or modify
  # it under the terms of the GNU General Public License as published by
  # the Free Software Foundation; either version 2, or (at your option)
  # any later version.
  #
  # This program is distributed in the hope that it will be useful,
  # but WITHOUT ANY WARRANTY; without even the implied warranty of
  # MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  # GNU General Public License for more details.
  #
  # You should have received a copy of the GNU General Public License
  # along with this program; see the file COPYING.  If not, write to
  # the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
  #
  #   This script implements a simple contents listing for the zftape
  #   package using the MTIOCVOLINFO ioctl.
  #

  #
  # insert better option parsing here
  #
  TAPEDEV=${1-/dev/tape}

  if ! echo $TAPEDEV | grep "/dev/n"
  then
  TAPEDEV=/dev/n$(basename $TAPEDEV)
  fi

  if ! [ -c $TAPEDEV ]
  then
  echo $TAPEDEV is not a character device!  1>&2
  exit 1
  fi

  if ! mt -f $TAPEDEV rewind
  then
  echo Could not rewind $TAPEDEV - no cartridge present?  1>&2
  exit 1
  fi

  echo -e "\nContents of $TAPEDEV:\n"

  printf "%11s%12s%20s%20s\n" "file number" "block size" "volume size" "tape space"

  trap "rm -f /tmp/$0.$$" exit

  while true
  do
  if ! foo=$(mt -f $TAPEDEV volinfo |cut -f 2 -d =)
  then
  echo $TAPEDEV doesn\'t seem to be a floppy tape device 1>&2
  exit 1
  fi
  #
  # "echo foo | read foo" will not work as the "read foo" is executed in
  # another shell.
  #
  echo $foo > /tmp/$0.$$
  read file blksz used usedunit size sizeunit < /tmp/$0.$$
  if ! mt -f $TAPEDEV fsf 1 > /dev/null 2>&1
  then
  echo -e "\nRemaining space: $used $usedunit"
  echo -e "Tape block size: $blksz"
  if ! mt -f $TAPEDEV rewind
  then
      echo Rewind of $TAPEDEV failed 1>&2
      exit 1
  fi
  exit 0
  fi
  printf "%6d          %5d  %20s%20s\n"\
  $file $blksz "$size $sizeunit" "$used $usedunit"
  done
  ______________________________________________________________________



  <risposta di Claus Heine>



  1122..  FFAAQQ:: DDoommaannddee rreellaattiivvee aallllee ««UUnniittàà ee nnaassttrrii»»



  1122..11..  CChhii ssoonnoo ii bbuuoonnii pprroodduuttttoorrii ddii nnaassttrrii TTrraavvaann??


  Ero lo UNIX Product Manager presso l'Archive Corp (prima della
  confusione Conner/Seagate) e realizzavamo test estensivi di supporti a
  nastro per la certificazione di compatibilità, inclusi
  ritensionamento, consistenza ``flaking'' e di lunghezza.  Dai
  risultati dei test, scegliemmo il meglio di questi prodotti
  manufatturieri, certificati su commessa di etichette private, come
  nostro supporto.  Qui di seguito è riportato l'ordine con cui
  selezionammo i rivenditori fino al 1995 (quando persi il contatto con
  il gruppo ATI):


     QQIICC

        1. 3M (ora conosciuto come Imation)

        2. QMaxell/Sony (in associazione)

        3. (BTW - Iomega utilizza supporti con etichetta privata della
           Sony)

     44MMMM

        1. Fuji

        2. Maxell/Sony (in associazione - è un trend?)

     88MMMM

        1. Fuji/Exabyte - che credemmo essere un prodotto OEM della Fuji
           (in associazione - cosí tanto per un trend!)

        2. Sony

        3. Maxell

     DDLLTT

        1. Maxell

        2. Sony

  Comunque avevamo altri venditori in lista che risultarono essere, in
  generale, una versione con etichetta privata di una delle etichette
  maggiori di cui sopra.  Le eccezioni furono Verbatim e DIC.  Entrambi
  i supporti di queste aziende ebbero delle discrepanze di tassi e
  lunghezza tali che non potemmo certificarli ed, anzi, avvertimmo i
  rivenditori indicando loro che non potevamo offrire alcun tipo di
  garanzia circa il risultato di un buon backup con l'utilizzo dei
  supporti prodotti da queste aziende.

  Inoltre, da quando vengono all'EST, ho trovato che i supporti Verbatim
  non valgono il prezzo che costano.  Avevamo 11 nastri di tipo R-Extra
  e QIC-Extra (QICXL) che risultarono inutilizzabili dopo poco meno di
  20 passaggi ognuno.

  Anche se questa è la mia opinione personale, essa è basata su nove
  anni di esperienza con problemi reali.  Consiglio vivamente Imation/3M
  per gli utenti QIC/Travan, supporti Fuji per gli utenti 4MM,
  Exabyte/Fuji per 8MM e supporti etichettati DEC per utenti DLT.

  <risposta di Tim Jones>


  1122..22..  DDoovvee ppoossssoo ootttteenneerree ggllii ssttaannddaarrdd QQIICC??


  Se si ha intenzione di aiutare nello sviluppo di _F_t_a_p_e od aggiungere
  alcune utility (per esempio un programma per la formattazione dei
  nastri), sarà necessario procurarsi gli standard QIC appropriati.  Gli
  standard da ottenere sono: QIC-80, QIC-117, QIC-3010 e QIC-3020.
  QIC-117 descrive come i comandi vengano inviati all'unità a nastro
  (incluse le temporizzazioni), tanto che, probabilmente, non ce ne sarà
  mai bisogno.  QIC-80/3010/3020 descrivono la parte a livello
  superiore, come lo strato nastro, il codice ECC, il filesystem
  standard.  È possibile prelevare gli standard QIC da seguenti
  indirizzi:



       Quarter Inch Cartridge Drive Standards, Inc.
       311 East Carrillo Street
       Santa Barbara, California 93101
       Phone: (805) 963-3853
       Fax:   (805) 962-1541



  Oss.: sono sotto il nome di ``Freeman Associates, Inc'' nell'elenco
  telefonico.

  <dall'Ftape-HOWTO>



  1122..33..  LL''uunniittàà IIoommeeggaa DDiittttoo 22GGBB èè ssuuppppoorrttaattaa??


  Sí, se si sta utilizzando la versione di ftape 3._x o successive dei
  _d_r_i_v_e_r _d_i _F_t_a_p_e dall'home-page di Ftape o da
  ftp://sunsite.unc.edu/pub/Linux/kernel/tapes.


  <risposta di Tim Jones>

  Poiché il Ditto 2GB è un nastro TR-3 (anche se può salvare solo 1GB
  invece di 1.6GB come fanno le unità TR-3 regolari), è necessario
  utilizzare un FDC (FDC è l'acronimo di Floppy Disk Controller
  [controllore per disco floppy]) capace di trasferimenti da 1Mb/s.
  Nessun problema, invece, se si possiede una scheda acceleratrice (cioè
  il controller Ditto Dash).  Altrimenti provare a comperare un FDC che
  dichiari di essere in grado di pilotare floppy da 2.88MB, in quanto
  questo implica che l'FDC sia in grado di trasferimenti da 1Mb/s.

  _F_t_a_p_e registra l'indice massimo dell'FDC nei file log del kernel in
  questo modo:


  ftape-ctl.c (ftape_init_drive) - Highest FDC supported data rate: 500 Kbps.



  <risposta di Claus Heine>



  1122..44..  LL''uunniittàà IIoommeeggaa DDiittttoo MMaaxx èè ssuuppppoorrttaattaa??


  Sí, se si sta utilizzando una versione 4.02 o successive come _d_r_i_v_e_r
  _d_i _F_t_a_p_e dall'home-page di Ftape o da
  ftp://sunsite.unc.edu/pub/Linux/kernel/tapes.

  <risposta di Claus Heine>



  1122..55..  LL''uunniittàà IIoommeeggaa DDiittttoo MMaaxx PPrroo èè ssuuppppoorrttaattaa??


  Sí, ma se si desidera utilizzare le cartucce da 5GB (10GB con la
  compressione) non ce n'è bisogno.  Con ftape non sembra ci sia alcuna
  differenza fra il Ditto Max e il Ditto Max Pro.

  <risposta di Claus Heine>



  1133..  FFAAQQ:: MMiisscceellllaanneeaa!!



  1133..11..  CCoommee ccii ssii iissccrriivvee aallllaa mmaaiilliinngg--lliisstt ddii FFttaappee??


  Ci si può iscrivere spedendo un messaggio di posta elettronica
  all'indirizzo



       majordomo@vger.rutgers.edu



  con l'unica linea nel corpo del messaggio



       subscribe linux-tape

  Si prega di salvare la risposta ottenuta da majordomo in un posto
  sicuro in quanto contiene istruzioni su come uscire dalla mailing-
  list.

  <risposta di Claus Heine>



  1133..22..  CCoommee uusscciirree ddaallllaa mmaaiilliinngg--lliisstt ddii FFttaappee??


  Spedire un messaggio di posta elettronica a



       majordomo@vger.rutgers.edu



  con l'unica linea nel corpo del messaggio



       unsubscribe linux-tape MIO@INDIRIZZO.E-MAIL



  dove MIO@INDIRIZZO.E-MAIL deve essere sostituito con l'indirizzo di
  posta elettronica utilizzato al momento della sottoiscrizione alla
  lista.  Notare che si deve aver ricevuto una e-mail con le istruzioni
  su come uscire dalla mailing-list nel momento in cui ci si è iscritti.

  <risposta di Claus Heine>



  1133..33..  LLiinnkk aadd iinnffoorrmmaazziioonnii ccoorrrreellaattee..


  <http://www.uwsg.indiana.edu/usai/library/backups.html>

  Si stanno cercando altri link!!!



  1144..  EEsseegguuiirree iill ddeebbuugg ddeell ddrriivveerr ddii ffttaappee



  1144..11..  IIll kkeerrnneell// ffttaappee  ssii ppiiaannttaa qquuaannddoo ffaacccciioo......  QQuueessttoo èè uunn bbaaccoo??


  No, questa è una sua caratteristica :-)

  Seriamente, il buon software non si pianta.  Soprattutto il kernel non
  o non ddoovvrreebbbbee piantarsi.  Se il kernel si pianta quando si sta
  eseguendo ftape ed è possibile dimostrare che è proprio ftape a
  confondere le cose, riferirsi ad esso come ad un «Bug That Should Be
  Fixed [baco da correggere».  Spedire una mail al manutentore
  (<heine@math1.rwth-aachen.de>) ed alla maling-list di Ftape.



  1144..22..  VVaa bbeennee,, èè uunn bbaaccoo...... cciiooèè,, uunnaa ccaarraatttteerriissttiiccaa..  CCoommee ffaacccciioo aa
  ssppeeddiirree uunn rraappppoorrttoo??


  Primo.  Assicurasi di essere in grado di riprodurre il problema.
  Errori spuri sono un spina nel sedere, in quanto sono praticamente
  impossibili da correggere :-/ La seguente è un breve lista di
  controllo:


  ·  versione di kernel e patch applicati;

  ·  versione di ftape;

  ·  modello e produttore dell'unità a nastro;

  ·  tipo di bus di espansione (EISA, ISA, PCI, o VL-bus);

  ·  il modo in cui si è esposto il problema;

  ·  cosa è andato storto sul proprio sistema;

  ·  non cancellare il kernel ed il file ftape.o.  Potrei aver bisogno
     di provare alcune patch o un test differente sul sistema.

  Aumentare il trace-level a 4 o 5 ed eseguire ancora il comando che ha
  dato problemi (non farlo se si ha paura di perdere dati o di
  danneggiare il proprio hardware; non c'è assolutamente alcuna garanzia
  né per i dati persi né per i danni all'hardware causati da ftape.
  Ricordarselo!).  Aumentando il trace-level oltre il 5, probabilmente
  non ha alcun senso, in quanto ciò si ripercuote sulle temporizzazioni
  del driver in un modo tale da non farlo piú lavorare bene.  Estrarre i
  dati di debug dal file di log del kernel o da /proc/kmsg, a seconda di
  dove vengono raccolti.  Provare a dare un'occhiata a cosa ftape sputa
  fuori.  Il tutto dovrebbe risultare alquanto incomprensibile di primo
  acchito, ma è possibile estrarre informazioni utili dal file di log.
  Molti messaggi hanno un nome di funzione preposto per facilitare la
  localizzazione del problema.  Dare un'occhiata al codice sorgente e
  non solo gridare «Al lupo!», senza averci provato.  Se la propria
  versione di kernel (o di ftape, per ciò che importa) è ``vecchia'',
  quando confrontata con uno degli ultimi kernel, provare a prelevare un
  kernel piú recente (o anche l'ultima) e vedere se il problema sparisce
  sotto il nuovo kernel.  Quando si posta il proprio rapporto, includere
  le informazioni riguardanti la versioni di ftape, la versione del
  kernel, il tipo di bus di espansione (ISA, VL-bus, PCI o EISA),
  velocità del bus, controller floppy e tipo di unità a nastro.
  Riportare esattamente cosa si è fatto, cosa è accaduto al proprio
  sistema.  Alcune persone hanno potuto provare come ftape non giri su
  sistemi con bus PCI, mentre girava senza problemi su normali macchine
  con bus ISA basate su processore 386DX (vedere la sezione ``Schede
  madri PCI ftape'' su macchine PCI sopra),

  Inoltre si prega di pensare anche a quei poveri diavoli che
  effettivamente _p_a_g_a_n_o per il loro accesso ad Internet (come me):
  evitare di postare un (enorme) file di log di ftape senza una ragione.
  Invece si potrebbe descrivere il problema e offrirsi di spedire il log
  alle parti interessate.

  Inviare il proprio bug a <linux-tape@vger.rutgers.edu>.  Se si vuole,
  si può spedire una mail con il bug anche a <heine@math1.rwth-
  aachen.de>.

  1155..  CCoonnttrriibbuuttii


  La seguente è una lista di persone distinte che hanno contribuito al
  documento HOWTO di ftape.  La lista è stata aggiunta recentemente da
  qualcuno che si è aggiunto a metà cammino.  Le mie scuse piú sentite
  se ho innavvertitamente dimenticato qualcuno di importante nella
  lista.  È possibile visionare un altro tentativo di raccolata di
  questo tipo di informazione nella ``Hall of Fame'' di Ftape.

  Johan De Wit <jo@correct.nl>: il manutentore delle FAQ di Ftape;

  Kevin Johnson <kjj@pobox.com>: il manutentore precedente dell'Ftape-
  HOWTO;

  Kai Harrekilde-Petersen <khp@dolphinics.no>: il manutentore precedente
  di ftape e dell'HOWTO;

  Andrew Martin <martin@biochemistry.ucl.ac.uk>: molte aggiunte
  all'HOWTO;

  Bas Laarhoven <bas@vimec.nl>: l'autore originale di ftape.



