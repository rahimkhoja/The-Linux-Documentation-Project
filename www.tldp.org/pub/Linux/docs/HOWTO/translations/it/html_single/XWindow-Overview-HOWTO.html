<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>X Window System Architecture Overview HOWTO</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"></HEAD
><BODY
CLASS="ARTICLE"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>X Window System Architecture Overview HOWTO</A
></H1
><H3
CLASS="AUTHOR"
><A
NAME="AEN4"
>Daniel Manrique</A
></H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
><CODE
CLASS="EMAIL"
>&#60;<A
HREF="mailto:roadmr@entropia.com.mx"
>roadmr@entropia.com.mx</A
>&#62;</CODE
>&nbsp;</P
></DIV
></DIV
><DIV
CLASS="REVHISTORY"
><TABLE
WIDTH="100%"
BORDER="0"
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
COLSPAN="3"
><B
>Diario delle Revisioni</B
></TH
></TR
><TR
><TD
ALIGN="LEFT"
>Revisione 1.0.1</TD
><TD
ALIGN="LEFT"
>2001-05-22</TD
><TD
ALIGN="LEFT"
>Revisionato da: dm</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Alcune correzioni grammaticali, indicate da Bill Staehle</TD
></TR
><TR
><TD
ALIGN="LEFT"
>Revisione 1.0</TD
><TD
ALIGN="LEFT"
>2001-05-20</TD
><TD
ALIGN="LEFT"
>Revisionato da: dm</TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>Release iniziale LDP.</TD
></TR
></TABLE
></DIV
><DIV
><DIV
CLASS="ABSTRACT"
><P
></P
><A
NAME="AEN21"
></A
><P
>		Questo documento fornisce una panoramica dell'architettura del sistema 
		X Window, aiuta a comprendere meglio la sua progettazione
		e spiega quali componenti si integrano con X e collaborano per formare
		un ambiente grafico. Inoltre illustra le scelte a disposizione per quanto
		riguarda componenti come window manager, librerie, toolkit di widget 
		e ambienti desktop.
		Traduzione a cura di Silvio Donnini, e-mail: scaudi at alice dot it
		Revisione a cura di Giulio Daprel&agrave; e-mail: daprela at pluto dot it
	</P
><P
></P
></DIV
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Sommario</B
></DT
><DT
>1. <A
HREF="#PREFACE"
>Prefazione</A
></DT
><DT
>2. <A
HREF="#INTRODUCTION"
>Introduzione</A
></DT
><DT
>3. <A
HREF="#ARCH-OVERVIEW"
>Architettura del sistema X Window: una panoramica</A
></DT
><DT
>4. <A
HREF="#WINDOW-MANAGERS"
>I Window Manager</A
></DT
><DT
>5. <A
HREF="#CLIENT-APPLICATIONS"
>Applicazioni client</A
></DT
><DT
>6. <A
HREF="#TOOLKITS"
>Widget library o toolkit</A
></DT
><DT
>7. <A
HREF="#SO-FAR"
>Cosa abbiamo finora</A
></DT
><DT
>8. <A
HREF="#DESKTOP-ENVIRONMENTS"
>Per fortuna esistono gli ambienti desktop</A
></DT
><DT
>9. <A
HREF="#SPECIFIC-DESKTOP-ENVIRONMENTS"
>Ambienti desktop specifici</A
></DT
><DT
>10. <A
HREF="#FIT-TOGETHER"
>Come si integra il tutto</A
></DT
><DT
>11. <A
HREF="#A-DAY"
>Una giornata nei panni di un sistema X</A
></DT
><DT
>12. <A
HREF="#COPYRIGHT"
>Copyright and License</A
></DT
></DL
></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="PREFACE"
>1. Prefazione</A
></H2
><P
>Questo documento fornisce una panoramica dell'architettura del sistema 
X Window, aiuta a comprendere meglio la sua progettazione
e spiega quali componenti si integrano con X e collaborano per formare
un ambiente grafico. Inoltre illustra le scelte a disposizione per quanto
riguarda componenti come window manager, librerie, toolkit di widget 
e ambienti desktop.</P
><P
>Indaghiamo su diversi concetti che vengono menzionati spesso ma potrebbero
risultare un po' oscuri per coloro che non hanno un background tecnico
riguardante widget, toolkit, window manager e ambienti desktop.
Vengono forniti alcuni esempi di come questi componenti interagiscono
durante l'uso quotidiano delle applicazioni.</P
><P
>Questo documento &egrave; deliberatamente non troppo tecnico.
&Egrave; basato sulla conoscenza empirica dell'autore sull'argomento,
e, bench&eacute; sia inteso principalmente come un'introduzione non
tecnica, sono bene accetti tutti i tipi di commenti, esempi, spiegazioni 
e correzioni tecniche al riguardo. Tutte le domande e i commenti
su questo documento sono benvenuti e l'autore pu&ograve; essere raggiunto
tramite l'indirizzo <A
HREF="mailto:roadmr@entropia.com.mx"
TARGET="_top"
><I
CLASS="CITETITLE"
>roadmr@entropia.com.mx</I
></A
>.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INTRODUCTION"
>2. Introduzione</A
></H2
><P
>Ai tempi in cui Unix era cosa nuova, intorno al 1970, le interfacce
grafiche erano solo stranezze con cui si giocherellava nei laboratori
(lo Xerox's PARC per la precisione). Al giorno d'oggi, comunque, ogni
sistema operativo che vuole essere un minimo competitivo ha bisogno
di un sottosistema GUI (Infaccia Grafica per l'Utente). Le GUI sono
ritenute pi&ugrave; facili da usare. Ma questo non interessa granch&eacute;
ad un utente di Unix, sistema che &egrave; sempre stato, tradizionalmente
e in un certo suo modo, abbastanza insensibile alle esigenze di usabilit&agrave;
dei propri utenti, preferendo la versatilit&agrave; alla facilit&agrave;
d'uso. Tuttavia ci sono parecchi motivi per cui una GUI &egrave;
desiderabile anche su un sistema Unix. Per esempio, data la natura 
multitasking di Unix, &egrave; naturale avere in ogni momento molti 
programmi che girano sulla stessa macchina. Una GUI d&agrave; pi&ugrave; 
controllo su come i programmi sono visualizzati sullo schermo, fornendo 
strumenti per gestire moltissimi programmi in contemporanea.
E poi alcune informazioni rendono di pi&ugrave; in formato grafico
(alcune, addirittura, possono essere visualizzate solo in forma grafica;
come il porno e altri dati intrinsecamente grafici).</P
><P
>Storicamente Unix ha ricevuto molti miglioramenti provenienti
da ambienti accademici. Un buon esempio &egrave; il codice di rete
di BSD, aggiunto alla fine degli anni '70, che era, ovviamente, il
risultato del lavoro  svolto all'universit&agrave; della California, a Berkeley.
Anche il sistema X Window (anche detto X, ma mai X Windows), che
rappresenta le fondamenta per la maggior parte dei sottosistemi GUI
dei sistemi Unix moderni (inclusi Linux e i vari BSD), &egrave; il prodotto
di un progetto universitario, ovvero il progetto Athena del Massachusetts 
Institute of Technology (MIT).</P
><P
>Unix &egrave; sempre stato fin dai suoi inizi multiutente, multitasking 
e time sharing. Inoltre, da quando vi sono state incorporate
tecnologie di rete, ha avuto la capacit&agrave; di permettere a un utente
di connettersi da remoto e lavorare sul sistema. Precedentemente ci&ograve;
era fattibile o collegandosi via terminale seriale o attraverso una connessione
di rete (il leggendario telnet).</P
><P
>Quando giunse il tempo di sviluppare un sistema GUI che potesse girare
principalmente sotto Unix, questi concetti vennero tenuti a mente e
incorporati nella progettazione. In realt&agrave; X ha una struttura
piuttosto complessa, cosa che &egrave; spesso stata menzionata come uno
svantaggio. Tuttavia, proprio grazie alla sua struttura, esso &egrave; 
anche un sistema molto versatile, e ci&ograve; diverr&agrave; molto chiaro
quando spiegheremo come si incastrano fra loro le parti che vanno a comporre una GUI.</P
><P
>Prima di andare a vedere l'architettura di X, &egrave; necessario
parlare un po' della sua storia e di come esso sia arrivato
sui sistemi Linux.</P
><P
>X &egrave; stato sviluppato dal progetto Athena e rilasciato nel 1984.
Nel 1988 un ente chiamato "Consorzio X" prese le redini del progetto,
e ad oggi gestisce il suo sviluppo e la sua distribuzione. Le specifiche 
di X sono disponibili al pubblico, mossa saggia che ha reso X onnipresente. 
Ecco come venne alla luce XFree86: XFree86 &egrave; l'implementazione di 
X sulle nostre macchine Linux. XFree86 funziona anche su altri sistemi 
operativi, come i vari *BSD, OS/2 e forse altri. Inoltre, nonostante il 
suo nome, XFree86 &egrave; disponibile per diversi tipi di processore.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="ARCH-OVERVIEW"
>3. Architettura del sistema X Window: una panoramica</A
></H2
><P
>L'architettura di X &egrave; client-server. Le applicazioni
stesse sono dei client; esse comunicano con il server e inviano
delle richieste, ricevendo informazioni dal server.</P
><P
>Il server X ha il controllo esclusivo dello schermo e dei servizi
richiesti dai client. A questo punto i vantaggi di questo modello sono 
abbastanza chiari. Le applicazioni (client) hanno solo bisogno di sapere 
come comunicare con il server e non si devono preoccupare dei dettagli 
del dispositivo grafico fisico. Al livello base, un client dice al server 
cose del tipo "disegna una linea che va da qui a qui", oppure "visualizza
questo testo, usando questi caratteri, in questo punto dello schermo".</P
><P
>&Egrave; come se stessimo usando una libreria grafica per scrivere la 
nostra applicazione. Tuttavia il modello di X fa un passo in pi&ugrave;. 
Non si limita a poter essere usato solo da un client che risiede sulla 
stessa macchina del server. Il protocollo usato per far comunicare client 
e server pu&ograve; funzionare anche attraverso una rete, e in realt&agrave; 
qualsiasi "meccanismo di comunicazione inter-processo che fornisca un 
flusso di byte affidabile". Ovviamente il modo preferito di far comunicare 
un client e un server remoto &egrave; attraverso i protocolli TCP/IP. 
Evidentemente il modello di X &egrave; veramente potente; l'esempio 
classico &egrave; quello in cui si fa girare un'applicazione che impegna
pesantemente il processore su un computer Cray, un'applicazione che 
gestisce un database su un server Solaris, un'applicazione di posta 
elettronica su un mail server BSD, un programma di visualizzazione su un 
server SGI e poi si visualizza tutto sullo schermo di una workstation Linux.</P
><P
>Fin qui abbiamo visto che il server X &egrave; quello che si occupa
della visualizzazione vera e propria. E, siccome &egrave; il server
X che gira sulla macchina fisica su cui l'utente sta lavorando,
&egrave; responsabilit&agrave; del server X gestire tutta
l'interazione effettiva con l'utente. Incluso leggere i movimenti
del mouse e l'input della tastiera. Tutte queste informazioni sono
passate al client, che ovviamente dovr&agrave; reagire ad esse.</P
><P
>X fornisce una libreria, chiamata Xlib, che gestisce tutte le comunicazioni
client-server di basso livello. Sembra ovvio quindi che il client
debba invocare le funzioni contenute in Xlib per fare quello che deve fare.</P
><P
>A questo punto tutto sembra andare per il verso giusto. Abbiamo
un server che si occupa dell'output visivo e dell'input, applicazioni
client e un meccanismo per farle comunicare tra loro. Nel figurarsi
un'interazione ipotetica tra un client e un server, il client potrebbe
chiedere al server di farsi assegnare un'area rettangolare dello schermo.
Essendo un client, non mi interessa dove vengo messo sullo schermo.
Dico solo al server: "dammi un area di dimensioni X per Y in pixel" e
poi chiamo funzioni per eseguire azioni del tipo "disegna una linea da qui a qui",
"dimmi se l'utente sta muovendo il mouse sopra la mia area dello schermo", 
e cos&igrave; via.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="WINDOW-MANAGERS"
>4. I Window Manager</A
></H2
><P
>Ad ogni modo non abbiamo mai menzionato come faccia il server
X a gestire la manipolazione delle aree di visualizzazione dei client
su schermo (chiamate anche finestre). &Egrave; ovvio, a chiunque abbia 
usato una GUI, che bisogna avere il controllo su delle "finestre client". 
Tipicamente l'utente pu&ograve; muoverle e ordinarle, cambiarne le 
dimensioni, minimizzarle o massimizzarle. Come fa a gestire tali compiti 
il server X? La risposta &egrave;: non lo fa.</P
><P
>Uno dei principi fondamentali di X &egrave;: "noi forniamo il meccanismo, 
ma non la politica". E cos&igrave;, bench&eacute; il server X fornisca 
un modo (meccanismo) per manipolare le finestre, non dice come si deve 
comportare effettivamente questa manipolazione (politica).</P
><P
>Tutta questa roba strana riguardo a meccanismi e politiche si riduce
ad un solo precetto: &egrave; responsabilit&agrave; di un altro programma
gestire lo spazio su schermo. Questo programma decide dove piazzare
le finestre, fornisce il meccanismo per far specificare all'utente
l'aspetto delle finestre, le posizioni e la loro dimensione; solitamente 
fornisce "decorazioni" come i titoli delle finestre, cornici e pulsanti 
che ci danno il controllo della finestra stessa. Questo programma, che 
gestisce le finestre, &egrave; chiamato "window manager".</P
><P
>"Il window manager in X &egrave; solo un altro client -- non &egrave;
parte del sistema X Window, bench&eacute; goda di privilegi speciali --
qundi non esiste un unico window manager; ce ne sono molti, che
supportano diverse modalit&agrave; di interazione con l'utente
e diversi schemi di posizionamento delle finestre, decorazioni,
gestione della tastiera, della mappa colori e del focus."</P
><P
>L'architettura X fornisce i mezzi ad un window manager per eseguire
tutte queste azioni sulle finestre; ma non fornisce un vero
e proprio window manager.</P
><P
>Ci sono, ovviamente, moltissimi di window manager, poich&eacute;, dal
momento che il window manager &egrave; un componente esterno, &egrave;
(relativamente) facile scriverne uno che si adatti alle proprie
esigenze, ovvero le proprie preferenze sul look delle finestre, il loro
comportamento, la posizione in cui si vuole che si trovino, etc. Alcuni
window manager sono semplicistici e bruttini (twn); alcuni hanno un
aspetto vivace e includono praticamente tutto a parte un lavandino
(enlightenment); poi ci sono tutte le vie di mezzo: fvwm, amiwm, icewm, 
windowmaker, afterstep, sawfish, kwm e tantissimi altri. Ci sono
window manager per tutti i gusti.</P
><P
>Un window manager &egrave; un "meta-client", il cui obbiettivo di base 
&egrave; quello di gestire altri client. La maggior parte dei window 
manager fornisce qualche strumento aggiuntivo (e alcuni ne forniscono 
tantissimi). Comunque una funzionalit&agrave; che sembra presente nella 
maggior parte dei window manager &egrave; un sistema per lanciare le 
applicazioni. Alcuni forniscono un box dove si possono scrivere comandi 
standard (che possono essere usati per lanciare applicazioni client). 
Altri hanno dei rifiniti menu appositi di qualche tipo. Non ci sono 
standard in proposito comunque; di nuovo, poich&eacute; X non detta alcuna 
politica su come una applicazione client dovrebbe essere lanciata, questa 
funzionalit&agrave; va implementata nei programmi client. Mentre 
tipicamente di ci&ograve; si occupa il window manager (e ciascuno l fa 
in modo diverso), &egrave; concepibile avere applicazioni client il cui 
solo scopo &egrave; lanciare altre applicazioni client, si pensi ad un 
pannello di lancio dei programmi. E di certo sono state scritte molte 
applicazioni per lanciare programmi.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CLIENT-APPLICATIONS"
>5. Applicazioni client</A
></H2
><P
>Spostiamo per un momento l'attenzione sui programmi client. Si pensi
di voler scrivere un programma client da zero, usando solo gli
strumenti forniti da X. Ci si accorgerebbe presto che Xlib &egrave;
un tool abbastanza spartano, e che fare cose come posizionare pulsanti
sullo schermo, testo e controlli elaborati (barre si scorrimento e
pulsanti radio) &egrave; incredibilmente complicato.</P
><P
>Fortunatamente, qualcun altro si &egrave; preso la briga di
implementare questi controlli e di presentarceli in forma utilizzabile:
una libreria. Questi controlli sono conosciuti come "widget" e 
ovviamente la libreria &egrave; chiamata "widget library".
Quindi io devo solo richiamare una funzione di questa libreria
con qualche parametro e ottenere che un pulsante sia visualizzato
sullo schermo. Esempi di widget includono menu, pulsanti, pulsanti radio,
barre di scorrimento e canvas.</P
><P
>Un "canvas" (tela per dipinti) &egrave; un tipo di widget interessante, 
dal momento che &egrave; essenzialmente una sottoarea dell'applicazione
client in cui si pu&ograve; disegnare. Comprensibilmente, poich&eacute;
non si dovrebbe usare Xlib direttamente (perch&eacute; ci&ograve; interferirebbe
con il lavoro della widget library) la libreria stessa fornisce un
modo di fare dei disegni arbitrari all'interno del widget canvas.</P
><P
>Poich&eacute; &egrave; la widget library che si occupa di disegnare
realmente gli elementi sullo schermo, cos&igrave; come di interpretare
le azioni dell'utente e trasformarle in input per le applicazioni, la
libreria usata &egrave; largamente responsabile per l'aspetto e il comportamento
di ogni client. Dal punto di vista di uno sviluppatore, una libreria widget
ha anche le sue API (insiemi di funzioni), ed &egrave; questo aspetto
che potrebbe farlo scegliere tra una particolare widget library e un'altra.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="TOOLKITS"
>6. Widget library o toolkit</A
></H2
><P
>La widget library originale, sviluppata per il progetto Athena,
si chiama prevedibilmente Athena widget library, conosciuta anche
come Athena widgets. &Egrave; molto primitiva, molto brutta
e non &egrave; intuitiva per gli standard odierni (per esempio, 
una barra di scorrimento o uno slider non si possono trascinare:
per scorrere in su o in gi&ugrave; si devono cliccare rispettivamente
il pulsante destro e quello sinistro). Come tale non viene granch&eacute;
utilizzata ai giorni nostri.</P
><P
>Proprio come accade per i window manager, ci sono molti toolkit,
progettati per scopi differenti. Uno dei primi toolkit &egrave;
il famoso Motif, che faceva parte dell'ambiente grafico Motif
della Open Software Foundation, e consiste in un window manager
e di un toolkit. In questo documento non tratteremo la storia della OSF.
Il toolkit Motif, essendo superiore ad Athena widgets, divenne
di largo utilizzo tra gli anni '80 e i primi '90.</P
><P
>Ai giorni nostri Motif non &egrave; una scelta popolare. Non &egrave;
software libero, e ci vuole denaro per ottenere una licenza per
sviluppare con OSF Motif (ovvero compilare i propri programmi con esso),
bench&eacute; si possa distribuire liberamente un file binario linkato 
dinamicamente a Motif. Forse l'applicazione Motif pi&ugrave; conosciuta, 
ameno per gli utenti Linux, &egrave; Netscape Navigator/Communicator 
(precedente a Mozilla).</P
><P
>Per un po' Motif &egrave; stato il solo toolkit decente disponibile,
e c'&egrave; molto software Motif in giro. Ovviamente si &egrave;
iniziato a sviluppare delle alternative, e oggi ci sono molti
toolkit, come XForms, FLTK, e altri.</P
><P
>Non si sente molto parlare di Motif al momento, in particolare nel
mondo del software libero. La ragione &egrave; che ora ci sono
alternative migliori, in termini di licenza, prestazioni (Motif &egrave;
ritenuto molto esoso in termini di risorse) e funzioni offerte.</P
><P
>Uno di questi toolkit, il famoso e usatissimo Gtk, &egrave;
stato creato specificamente per rimpiazzare Motif nell'ambito
del progetto GIMP (una possibile interpretazione di "Gtk" &egrave;
"GIMP Toolkit", sebbene, data la sua enorme diffusione, potrebbe
anche significare "GNU Toolkit"). Gtk adesso &egrave; molto
popolare, perch&eacute; relativamente leggero, ricco di
funzioni, estendibile, ed &egrave; per intero software libero.
La release 0.6 di GIMP includeva nel changelog l'affermazione:
"Bloatif has been zorched" ("Bloatif" &egrave; un gioco di parole 
fra bloat (pesante) e Motif, "zorched" deriva da "zorch", 
che nel dialetto hacker ha un significato che varia molto a seconda
del contesto. Qui suona come "il pesante Motif &egrave; stato
eclissato" n.d.T.).
Questa frase &egrave; il testamento della pesantezza di Motif.</P
><P
>Un altro toolkit molto popolare oggi &egrave; Qt. Non era molto
conosciuto prima dell'avvento del progetto KDE, che utilizza Qt per
tutti gli elementi della sua GUI. Di certo non affronteremo la questione
della licenza d'uso di Qt, n&eacute; la dicotomia KDE/GNOME.
Abbiamo parlato di pi&ugrave; di Gtk perch&eacute; la sua storia come
rimpiazzo di Motif &egrave; interessante; Qt viene menzionato
brevemente perch&eacute; &egrave; estremamente popolare.</P
><P
>Infine, un'altra alternativa degna di nota &egrave; LessTif.
Il nome &egrave; un gioco di parole con Motif (La "Mo" di Motif
viene pronunciata con un suono che somiglia a "more" (pi&ugrave;), quindi la parola LessTif
&egrave; creata sostituendo "Mo" con "Less" (meno) n.d.T.), LessTif
mira ad essere un'alternativa (libera e compatibile dal punto di vista
dell'interfaccia di programmazione) a Motif. Non &egrave; chiaro
fino a che punto LessTif miri ad essere usato per progetti a s&eacute;,
piuttosto che per aiutare coloro che hanno gi&agrave; del codice scritto 
utilizzando Motif a passare immediatamente ad un'alternativa libera 
mentre pianificano il passaggio ad un altro toolkit.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SO-FAR"
>7. Cosa abbiamo finora</A
></H2
><P
>A questo punto abbiamo un'idea dell'architettura client-server
di X, dove i client sono i nostri programmi applicativi. Con questo 
sistema grafico client-server possiamo usare parecchi window manager,
che gestiscono tutto quello che viene visualizzato sullo schermo;
abbiamo anche le nostre applicazioni client, che sono ci&ograve; che 
comunemente usiamo per lavorare. Tali applicazioni possono essere state
programmate utilizzando molti toolkit diversi.</P
><P
>Qui le cose cominciano a farsi complicate. Ogni window manager
ha un approccio diverso alla gestione dei client; il comportamento
e le decorazioni variano. Inoltre, anche i client possono comportarsi ed
essere visualizzati in maniera diversa tra loro a seconda del toolkit usato.
Poich&eacute; non c'&egrave; niente che dica che gli sviluppatori debbano
usare lo stesso toolkit per ogni loro applicazione, &egrave; perfettamente
plausibile che un utente stia lavorando con diciamo sei diverse
applicazioni, ognuna scritta con un toolkit diverso, e che tutte si 
comportino e vengano visualizzate diversamente. Ci&ograve; crea 
confusione perch&eacute; il comportamento delle applicazioni non &egrave;
consistente. Se si &egrave; mai usato un programma scritto con Athena 
widgets si noter&agrave; che non &egrave; molto simile a qualunque altra 
cosa scritta con Gtk. E si ricorder&agrave; la difficolt&agrave; di usare 
tutte queste applicazioni con un look &#38; feel diverso. Questi difetti
annullano il vantaggio di avere a disposizione un'interfaccia grafica.</P
><P
>Da un punto di vista pi&ugrave; tecnico, usare molti toolkit diversi
aumenta l'utilizzo delle risorse. I sistemi operativi moderni supportano
il concetto di librerie condivise dinamicamente (dynamic shared libraries).
Ci&ograve; significa che se ho due o tre applicazioni che usano Gtk come
libreria linkata dinamicamente, quelle due o tre applicazioni condivideranno
la stessa copia di Gtk, sia sul disco che in memoria: non c'&egrave; 
spreco di risorse. Se invece ho un'applicazione Gtk, un'applicazione Qt, 
qualcosa che usa Athena, un programma basato su Motif come Netscape, un 
programma che usa FLTK e un altro che usa XForms, sto caricando sei 
diverse librerie in memoria, una per ciascun toolkit. Bisogna tenere 
presente che tutti i toolkit forniscono in definitiva le stesse funzionalit&agrave;.</P
><P
>Ci sono altri problemi. Il modo in cui si lanciano i programmi varia
da un window manager all'altro. Alcuni hanno un gradevole menu per lanciare
le applicazioni, altri no e si aspettano che l'utente apra un box
per lanciare comandi, o usi una determinata combinazione di tasti, o
ancora apra un terminale xterm e lanci tutte le applicazioni richiamandole
da riga di comando. Ancora una volta non ci sono standard e le cose
si fanno complicate.</P
><P
>Infine ci sono alcune caratteristiche utili che ci aspettiamo da una GUI 
e che fin qui non abbiamo trattato. Cose come un'utility di configurazione 
(o "pannello di controllo") o un file manager grafico, che certamente 
possono essere scritte come applicazioni client. E in tipico stile free 
software ci sono centinaia di file manager e centinaia di programmi per 
la configurazione del sistema, che prevedibilmente apportano ulteriore 
confusione al gi&agrave; difficile compito di avere a che fare con molti 
componenti software diversi.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="DESKTOP-ENVIRONMENTS"
>8. Per fortuna esistono gli ambienti desktop</A
></H2
><P
>Ecco dove si inserisce il concetto di ambiente desktop.
L'idea &egrave; che un ambiente desktop fornisce un insieme di
strumenti e linee guida per standardizzare tutto ci&ograve; che
abbiamo menzionato in modo da minimizzare i problemi citati.</P
><P
>Il concetto di ambiente desktop &egrave; nuovo per chi si avvicina
a Linux per la prima volta, poich&eacute; altri sistemi operativi
(come Windows e Mac OS) lo danno per scontato. Per esempio MacOS, che &egrave;
una delle interfacce grafiche pi&ugrave; antiche, fornisce un look &#38; feel
molto consistente attraverso tutta la sessione di utilizzo del sistema. 
Il sistema operativo fornisce molte delle caratteristiche utili menzionate: 
un file manager predefinito (il finder), un pannello di controllo
che gestisce l'intero sistema, un singolo toolkit che deve essere usato
da tutte le applicazioni (in modo che tutte vengano visualizzate
allo stesso modo). Le finestre delle applicazioni sono gestite dal
sistema (per essere precisi dal window manager). E infine ci sono delle
linee guida che dicono agli sviluppatori come si dovrebbero comportare
le proprie applicazioni, raccomandano disposizione e visualizzazione dei
componenti, e suggeriscono comportamenti consistenti con le altre applicazioni
del sistema. Tutto ci&ograve; per ottenere una maggiore uniformit&agrave;
e facilit&agrave; d'uso.</P
><P
>A questo punto sorge una domanda: perch&eacute; gli sviluppatori di X
lo hanno progettato in maniera cos&igrave; particolare? Ha senso 
chiederselo, perch&egrave; si sarebbero evitati tutti i problemi
menzionati in precedenza. La risposta &egrave; che nel progettare X i 
suoi creatori hanno scelto di renderlo il pi&ugrave; possibile flessibile. 
Tornando al paradigma politica/meccanismo, MacOS fornisce principalmente 
politiche. I meccanismi ci sono, solo che gli sviluppatori non vengono 
incoraggiati ad occuparsene. Il risultato &egrave; che si perde in 
versatilit&agrave;: se non mi piace il modo in cui MacOS gestisce le 
finestre o il toolkit non ha le funzioni di cui ho bisogno, non posso
farci niente. Ci&ograve; non accade sotto X, bench&eacute; come visto il 
prezzo della flessibilit&agrave; sia una maggiore complessit&agrave;.</P
><P
>Sotto Linux/Unix e X si riduce tutto a mettersi d'accordo su qualcosa
e continuare ad usarlo. Prendiamo ad esempio KDE. KDE include un solo
window manager (kwm), che gestisce e controlla il comportamento delle
nostre finestre. Raccomanda l'utilizzo di un certo toolkit grafico (Qt),
in modo che ogni applicazione KDE venga visualizzata allo stesso modo
fintanto che essa resta sullo schermo. KDE estende ulteriormente Qt
fornendo un insieme di librerie specifiche per l'ambiente (kdelibs)
che servono per eseguire operazioni frequenti come creare menu, finestre
"about", barre degli strumenti, comunicare tra programmi diversi,
stampare, selezionare file ecc. Queste rendono il lavoro del programmatore
pi&ugrave; facile e standardizzano il modo in cui si comportano
queste funzioni speciali. KDE fornisce inoltre un insieme di linee
guida per la progettazione ai programmatori, con l'intenzione di
rendere uniforme il comportamento e gli aspetti visivi delle
applicazioni di coloro che le seguono. Infine, KDE fornisce, come parte
dell'ambiente, un pannello di lancio (kpanel), un file manager standard
(che &egrave; al momento Konqueror) e un'utility di configurazione 
(pannello di controllo) da cui si possono controllare molti aspetti del 
proprio sistema, da impostazioni come lo sfondo del desktop e il colore
della barra del titolo delle finestre alla configurazione dell'hardware.</P
><P
>Il pannello KDE &egrave; l'equivalente della barra delle applicazioni
di MS Windows. Fornisce un punto d'accesso centrale da cui lanciare applicazioni,
e permette anche a piccole applicazioni, chiamate "applet", di venire
visualizzate al suo interno. Ci&ograve; include funzionalit&agrave; come
il piccolo orologio senza il quale la maggior parte degli utenti non
pu&ograve; vivere.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SPECIFIC-DESKTOP-ENVIRONMENTS"
>9. Ambienti desktop specifici</A
></H2
><P
>Abbiamo usato KDE come esemio, ma non &egrave; assolutamente il primo
ambiente desktop per i sistemi Unix. Forse uno dei primi &egrave; CDE
(Common Desktop Environment), un altro parente di OSF. 
A quanto dice la FAQ di CDE: "Common Destktop Environment &egrave;
un desktop standard per Unix, che fornisce i suoi servizi all'utente
finale, all'amministratore di sistema e agli sviluppatori di applicazioni
su molte piattaforme." La chiave qui &egrave; la consistenza. Tuttavia
CDE non era cos&igrave; facile e ricco di caratteristiche come invece 
avrebbe dovuto. Insieme a Motif, CDE &egrave; praticamento scomparso dal 
mondo del software libero, essendo stato rimpiazzato da alternative migliori.</P
><P
>Sotto Linux gli ambienti desktop pi&ugrave; popolari sono KDE
e GNOME, ma non sono i soli. Una veloce ricerca su Internet 
riveler&agrave; una mezza dozzina di ambienti desktop: GNUStep,
ROX, GTK+XFce, UDE, per nominarne alcuni. Tutti forniscono le
funzionalit&agrave; di base che abbiamo menzionato in precedenza.
GNOME e KDE hanno avuto il supporto maggiore sia dalla comunit&agrave; 
che dall'industria, cosicch&eacute; essi sono i pi&ugrave; avanzati
e mettono a disposizione dell'utente e delle applicazioni
una grande quantit&agrave; di servizi.</P
><P
>Abbiamo menzionato KDE e i componenti che forniscono servizi specifici
sotto tale ambiente. Da buon ambiente desktop, GNOME &egrave; simile
sotto questo punto di vista. La differenza pi&ugrave; ovvia
&egrave; che GNOME non detta l'utilizzo di alcun window manager
(nel modo in cui KDE fa con kwm). Il progetto GNOME ha sempre cercato di 
rimanere agnostico rispetto alla questione dei window manager, 
riconoscendo che molti utenti rimangono molto affezionati al proprio
window manager preferito, e che forzarli ad usare qualcosa che gestisce
le finestre in modo diverso li allontanerebbe. In principio GNOME 
favoreggiava il window manager Enlightenment e al momento il loro window 
manager preferito &egrave; Sawfish, ma il pannello di controllo di GNOME 
ha sempre avuto una sezione che permetteva di selezionare un window manager.</P
><P
>Oltre a ci&ograve;, GNOME usa il toolkit Gtk e fornisce un insieme
di funzioni di alto livello attraverso l'insieme di librerie
gnome-libs. GNOME ha il suo insieme di linee guida per la programmazione
per consentire un comportamento consistente tra tutte le applicazioni
supportate, fornisce un pannello (chiamato semplicemente "pannello"),
un file manager (gmc, bench&eacute; probabilmente sar&agrave; sostituito
da Nautilus), e un pannello di controllo (il centro di controllo gnome).</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="FIT-TOGETHER"
>10. Come si integra il tutto</A
></H2
><P
>Ogni utente &egrave; libero di usare l'ambiente desktop che preferisce. 
Il risultato finale &egrave; che se si usa un sistema con solo KDE o 
solo GNOME, allora il look &#38; feel dell'ambiente &egrave; molto consistente 
e tutte le applicazioni interagiscono molto bene tra loro. Ci&ograve; 
semplicemente non era possibile quando le applicazioni erano scritte con 
una miriade di diversi toolkit. La moltitudine di strumenti forniti dai 
moderni ambienti desktop sotto Linux permette altri simpatici trucchetti, 
come architetture a componenti (KDE ha Kparts e GNOME usa il framework 
di componenti Bonobo), che fanno s&igrave; che si possano creare cose 
come documenti testuali che contengono un foglio di calcolo o un grafico, 
strumenti di stampa globali simili ai contesti di stampa che si trovano 
sotto Windows, e tutte cose che rendono possibile ad utenti pi&ugrave; 
avanzati di far interagire e collaborare le applicazioni in modi interessanti.</P
><P
>Secondo la concezione Unix di "ambiente desktop" si possono avere
programmi di un ambiente che girano in un altro. &Egrave; concepibile 
che io possa usare Konqueror sotto GNOME, o Gnumeric sotto KDE. Dopo 
tutto sono solo programmi. Ovviamente l'idea di ogni ambiente desktop 
&egrave; la consistenza, quindi ha senso usare solo applicazioni 
progettate per il proprio particolare ambiente; tuttavia se l'utente 
vuole avere a che fare con un'applicazione che sembra "fuori luogo" e 
non interagisce bene con il resto dell'ambiente, liberissimo di farlo.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="A-DAY"
>11. Una giornata nei panni di un sistema X</A
></H2
><P
>Questo &egrave; un esempio di come procede una tipica sessione GNOME
in un ambiente desktop moderno su un sistema Linux.
Le cose funzionano in maniera simile ad altri ambienti, fermo
restando che il sistema alla base sia X.</P
><P
>Quando un sistema Linux fa partire X, il server X si avvia e 
inizializza il dispositivo grafico, aspettando richieste dai client.
Per primo parte un programma chiamato gnome-session e inizializza
la sessione di lavoro. Una sessione include cose come applicazioni
usate di frequente, la loro posizione su schermo e cose simili.
Poi viene avviato il pannello. Il pannello appare in fondo (di
solito) ed &egrave; una specie di cruscotto per un ambiente a finestre.
Permetter&agrave; di lanciare programmi, vedere quali sono
in esecuzione e di controllare l'ambiente di lavoro.
Poi si avvia il window manager. Visto che stiamo usando
GNOME potrebbe essere uno dei tanti, ma in questo caso
assumiamo che sia Sawfish. Infine viene avviato il file manager (gmc o 
Nautilus). Il file manager gestisce la presentazione delle icone
del desktop. A questo punto l'ambiente GNOME &egrave; pronto.</P
><P
>Fin qui tutti i programmi che sono stati avviati sono client, che si 
connettono al server X. Nel caso specifico il server X risiede sullo 
stesso computer, ma come abbiamo visto prima ci&ograve; non &egrave; necessario.</P
><P
>Apriamo un terminale xterm per scrivere qualche comando. Quando 
clicchiamo sull'icona xterm, il pannello fa partire l'applicazione xterm. 
&Egrave; un'altra applicazione client X, quindi essa si avvia, si 
connette al server X e comincia a visualizzare i suoi elementi. Quando 
il server X assegna lo spazio su schermo ad xterm, fa in modo che il 
window manager (Sawfish) decori la finestra con una bella barra del 
titolo e decida dove essa debba apparire sullo schermo.</P
><P
>Ora navighiamo un po'. Clicchiamo sull'icona di Netscape sul pannello
e parte un browser. Bisogna ricordare che questo browser non usa
le librerie di GNOME n&eacute; il toolkit Gtk. Sembra un po' fuori
luogo... inoltre non interagisce in maniera molto fluida con il
resto dell'ambiente. Ora apriamo il menu "File". Motif
fornisce i controlli che appaiono sullo schermo, quindi
&egrave; compito della libreria di Motif quello di usare la libreria
Xlib per disegnare su schermo i componenti necessari a visualizzare
il menu e fare in modo che si possa selezionare l'opzione "exit"
per chiudere l'applicazione.</P
><P
>Ora apriamo un foglio di calcolo Gnumeric e incominciamo a lavorarci.
Ad un certo punto abbiamo bisogno di usare xterm, quindi ci clicchiamo
sopra. Sawfish vede questa azione ed essendo incaricato della gestione
delle finestre porta xterm in primo piano e gli concede il focus di modo
che ci si possa lavorare.</P
><P
>Dopodich&eacute;, torniamo al nostro foglio di calcolo; avendo finito
di modificarlo vorremmo stampare il nostro documento. Gnumeric &egrave;
un'applicazione GNOME, quindi pu&ograve; usare gli strumenti forniti
dall'ambiente GNOME. Quando stampiamo Gnumeric richiama la libreria
gnome-print, che comunica effettivamente con la stampante e produce
la copia su carta di cui ho bisogno.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="COPYRIGHT"
>12. Copyright and License</A
></H2
><P
>Copyright (c) 2001 by Daniel Manrique</P
><P
>    Permission is granted to copy, distribute and/or modify this document
    under the terms of the <A
HREF="http://www.gnu.org/copyleft/fdl.html"
TARGET="_top"
><I
CLASS="CITETITLE"
>GNU Free Documentation
    License</I
></A
>, Version 1.1 or any later version 
    published by the Free Software Foundation with no Invariant Sections, 
    no Front-Cover Texts, and no Back-Cover Texts.  A copy of the license
    can be found <A
HREF="http://www.gnu.org/copyleft/fdl.html"
TARGET="_top"
>here</A
>.
   </P
></DIV
></DIV
></BODY
></HTML
>