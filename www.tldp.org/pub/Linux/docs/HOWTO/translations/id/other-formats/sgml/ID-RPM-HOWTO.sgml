<!doctype linuxdoc system>
<article>

<!-- Title Info -->


<title>RPM HOWTO (RPM saat stasioner.....:-))
<Author>Donnie Barnes, <tt/djb@redhat.com/ diterjemahkan oleh Julian Adhi .N, adhi@semarang.wasantara.net.id,
http://adhi.base.org</Author>
<date>v2.0, 8 April 1997 diterjemahkan 30 Desember 1997
<!-- Copyright 1997, Red Hat Software -->

<toc>

<sect>Perkenalan
<p>RPM adalah <em><bf/R/ed Hat <bf/P/ackage <bf/M/anager</em> (Pengatur Paket Aplikasi
dari Red Hat). Meskipun mengandung nama Red Hat dalam namanya, RPM dimaksudkan
untuk menjadi sistem pemaketan terbuka yang tersedia luas untuk digunakan
semua orang. RPM mengizinkan para pengguna untuk menggunakan kode sumber
(<em>source code</em>) untuk perangkat lunak baru dan memaketkannya ke dalam
bentuk <em>source</em> dan binernya, di mana bentuk binernya mudah dipasang
(di-<em>install</em>) dan dilacak dan <em>source</em>nya dapat dibangun lagi
dengan mudah. RPM juga memelihara sebuah database (informasi) dari semua
paket dan file-filenya yang dapat digunakan untuk verifikasi paket dan
meminta informasi tentang file dan / atau paket.

<p>Perusahaan Perangkat Lunak Red Hat memberikan dorongan kepada vendor-vendor
distribusi lain untuk menyempatkan waktu melihat RPM dan menggunakannya
untuk distribusi-distribusi mereka. RPM agak fleksibel dan mudah digunakan,
meskipun RPM menyediakan pondasi untuk sistem yang sangat luas. RPM juga
benar-benar terbuka dan tersedia, namun kami sangat menghargai juga laporan
<em>bug</em> dan perbaikan-perbaikan. Izin diberikan untuk menggunakan dan
mendistribusikan RPM tanpa royalti di bawah GPL.

<p>Dokumen yang lebih lengkap, tersedia pada buku tentang RPM, yang ditulis
oleh Ed Bailey, yaitu &quot;Maximum RPM&quot;. Buku itu tersedia untuk
didownload atau dibeli di www.redhat.com

<sect>Sekilas tentang RPM

<p>Pertama-tama, biarkan penulis mendudukkan beberapa filosofi di belakang
RPM. Salah satu gol desainnya adalah memperbolehkan pengguna untuk menggunakan
<em>source</em> yang mula-mula. Dengan RPP (pembentuk sistem pemaketan kami
di mana tak sebuah RPM pun diperoleh), <em>source</em> paket kami adalah
<em>source</em> yang telah di-<em>hack</em>. Secara teoritis, seseorang dapat
memasang (meng<em>install</em>) sebuah <em>source</em> dari RPP dan kemudian
membuatnya tanpa masalah. Tetapi <em>source</em> itu bukanlah yang asli,
dan tak ada referensi seperti perubahan apa yang kami lakukan untuk membuatnya,
untuk didapatkan. Seseorang harus mendownload <em>source</em> yang mula-mula
secara terpisah. Dengan RPM, anda mendapatkan <em>source</em> yang asli dengan
sebuah <em>patch</em> (penambal) yang kami gunakan untuk mengkompilasinya.
Kami memandangnya sebagai sebuah keuntungan besar. Mengapa ? Ada beberapa
alasan. Pertama, bila sebuah versi program baru datang, anda tidak perlu
harus memulai dari <em>scratch </em>untuk mendapatkannya terkompilasi di
bawah RHL. Anda dapat melihat <em>patch</em> untuk memeriksa apakah yang
mungkin anda harus lakukan. Semua standar <em>compile-in</em> mudah ditampilkan
dengan cara ini.

<p>RPM juga didesain untuk mempunyai pilihan permintaan yang kuat. Anda
dapat mengerjakan pencarian melewati seluruh database untuk paket atau
hanya file tertentu. Anda juga dapat dengan mudah menemukan paket manakah
yang memiliki sebuah file dan dari manakah datangnya. File-file RPM itu
sendiri adalah arsip yang terkompres (termampatkan), tetapi anda dapat
meminta paket secara individual dengan mudah dan cepat, karena sebuah kepala
(<em>header</em>) biner yang lazim ditambahkan ke paket dengan segala sesuatu
yang mungkin anda inginkan yaitu apa yang terkandung dalam bentuk terkompresnya.
Ia juga memperbolehkan pencarian cepat.

<p>Kemampuan (<em>feature</em>) lain yang kuat adalah kemampuannya untuk
memeriksa (<em>verify</em>) paket-paket. Bila anda khawatir bahwa anda menghapus
sebuah file penting untuk beberapa paket, lakukan verifikasi dengan RPM.
Anda akan diberitahu penyimpangan-penyimpangan apa pun. Di saat itu, anda
dapat memasang ulang (<em>reinstall</em>) paket bila diperlukan. File konfigurasi
apa pun yang anda punyai, diamankan dengan baik.

<p>Kami ingin mengucapkan terima kasih kepada orang-orang dari distribusi
BOGUS untuk ide-ide dan konsep yang tergabungkan dalam RPM. Pada saat RPM
telah ditulis secara lengkap oleh Red Hat Software, operasinya berdasarkan
pada kode yang ditulis oleh BOGUS (PM dan PMS)

<p>
<sect>Informasi Umum

<sect1>Cara mendapatkan RPM

<p>Cara terbaik mendapatkan RPM adalah memasang (meng<em>install</em>) Red
Hat Linux. Bila anda tidak ingin mengerjakan itu, anda masih dapat memperoleh
dan menggunakan RPM. RPM dapat diperoleh dari <url url="ftp://ftp.redhat.com/pub/redhat/code/rpm"
name = "ftp://ftp.redhat.com">

<sect1>Syarat-syarat yang diperlukan RPM

<p>Syarat utama untuk menjalankan RPM adalah cpio 2.4.2 atau lebih tinggi.
Pada saat sistem ini dimaksudkan untuk digunakan dengan Linux, mungkin
sangat bagus digunakan di dalam sistem Unix yang lain. RPM punya ... dalam
faktanya, kompilasi untuk SunOS, Solaris, AIX, Irix, AmigaOS, dan lainnya.
Penulis ingatkan, paket biner yang dibuat di sistem Unix yang berbeda tidaklah
saling kompatibel.

<p>Itu semua adalah syarat minimal untuk memasang RPM. Untuk membangun
(<em>build</em>) RPM dari <em>source</em>, anda juga membutuhkan segala sesuatu
yang dalam keadaan normal diperlukan untuk membangun sebuah paket, seperti
gcc, make, dll.

<sect>Menggunakan RPM

<p>Dalam bentuknya yang paling sederhana, RPM dapat digunakan untuk meng<em>install</em>
paket : 

<tscreen><verb>
rpm -i foobar-1.0-1.i386.rpm
</verb></tscreen>

<p>Perintah sederhana berikutnya adalah untuk meng<em>-uninstall</em> sebuah
paket :

<tscreen><verb>
rpm -e foobar
</verb></tscreen>

<p>Salah satu yang lebih kompleks tetapi perintah yang sangat berguna mengizinkan
anda untuk meng<em>install</em> paket via FTP. Bila anda terkoneksi ke jaringan
dan menginginkan meng<em>install</em> sebuah paket baru, semua yang anda
inginkan adalah memerinci file itu dengan URL yang valid, seperti :

<p><TT>rpm -i ftp://ftp.pht.com/pub/linux/redhat/rh-2.0-beta/RPMS/foobar-1.0-1.i386.rpm</TT>

<p>Catatan, RPM akan meminta dan / atau meng<em>install</em> lewat FTP.

<p>Meskipun perintah tersebut adalah perintah yang sederhana, rpm dapat
digunakan dalam sejumlah besar cara seperti yang dapat dilihat dari pesan
penggunaan :

<tscreen><verb>
RPM version 2.3.9
Copyright (C) 1997 - Red Hat Software
This may be freely redistributed under the terms of the GNU Public License

usage: rpm {--help}
       rpm {--version}
       rpm {--initdb}   [--dbpath <dir>]
       rpm {--install -i} [-v] [--hash -h] [--percent] [--force] [--test]
                        [--replacepkgs] [--replacefiles] [--root <dir>]
                        [--excludedocs] [--includedocs] [--noscripts]
                        [--rcfile <file>] [--ignorearch] [--dbpath <dir>]
                        [--prefix <dir>] [--ignoreos] [--nodeps]
                        [--ftpproxy <host>] [--ftpport <port>]
                        file1.rpm ... fileN.rpm
       rpm {--upgrade -U} [-v] [--hash -h] [--percent] [--force] [--test]
                        [--oldpackage] [--root <dir>] [--noscripts]
                        [--excludedocs] [--includedocs] [--rcfile <file>]
                        [--ignorearch]  [--dbpath <dir>] [--prefix <dir>] 
                        [--ftpproxy <host>] [--ftpport <port>]
                        [--ignoreos] [--nodeps] file1.rpm ... fileN.rpm
       rpm {--query -q} [-afpg] [-i] [-l] [-s] [-d] [-c] [-v] [-R]
                        [--scripts] [--root <dir>] [--rcfile <file>]
                        [--whatprovides] [--whatrequires] [--requires]
                        [--ftpuseport] [--ftpproxy <host>] [--ftpport <port>]
                        [--provides] [--dump] [--dbpath <dir>] [targets]
       rpm {--verify -V -y} [-afpg] [--root <dir>] [--rcfile <file>]
                        [--dbpath <dir>] [--nodeps] [--nofiles] [--noscripts]
                        [--nomd5] [targets]
       rpm {--setperms} [-afpg] [target]
       rpm {--setugids} [-afpg] [target]
       rpm {--erase -e} [--root <dir>] [--noscripts] [--rcfile <file>]
                        [--dbpath <dir>] [--nodeps] [--allmatches]
                        package1 ... packageN
       rpm {-b|t}[plciba] [-v] [--short-circuit] [--clean] [--rcfile  <file>]
                        [--sign] [--test] [--timecheck <s>] specfile
       rpm {--rebuild} [--rcfile <file>] [-v] source1.rpm ... sourceN.rpm
       rpm {--recompile} [--rcfile <file>] [-v] source1.rpm ... sourceN.rpm
       rpm {--resign} [--rcfile <file>] package1 package2 ... packageN
       rpm {--addsign} [--rcfile <file>] package1 package2 ... packageN
       rpm {--checksig -K} [--nopgp] [--nomd5] [--rcfile <file>]
                           package1 ... packageN
       rpm {--rebuilddb} [--rcfile <file>] [--dbpath <dir>]
       rpm {--querytags}
</verb></tscreen>


<p>Anda dapat menemukan lebih detil dalam 'what' untuk pilihan-pilihan
tersebut di atas dalam halaman manual (<em>man pages</em>) RPM.

<sect>Sekarang apa yang <em/dapat/ anda lakukan dengan RPM ?

<p>RPM adalah alat yang sangat berguna, dan seperti yang anda lihat, punya
beberapa pilihan (<em>option</em>). Jalan terbaik untuk menjelaskannya adalah
dengan melihat beberapa contoh. Saya menyertakan contoh pemasangan/penghapusan
(<em>install/uninstall</em>) di atas, dengan demikian di sini adalah beberapa
contoh lain :

<itemize>
<item>Marilah beranggapan anda menghapus beberapa file secara tak sengaja,
tetapi anda tidak mengetahui dengan pasti apa yang anda hapus. Bila anda
menginginkan melakukan verifikasi terhadap sistem anda secara keseluruhan
dan melihat apa yang mungkin hilang, anda akan mengetik :

<tscreen><verb>rpm -Va</verb></tscreen>

<item>Mari beranggapan anda menjalankan sebuah file yang anda tidak kenali.
Untuk mencari milik paket mana file itu, ketikkan :

<tscreen><verb>rpm -qf /usr/X11R6/bin/xjewel</verb></tscreen>

Keluarannya mungkin seperti :

<tscreen><verb>xjewel-1.6-1</verb></tscreen>

<item>Anda menemukan sebuah paket RPM koules, tetapi anda tak tahu apakah
itu. Untuk menemukan beberapa informasi padanya, kerjakan :

<tscreen><verb>rpm -qpi koules-1.2-2.i386.rpm</verb></tscreen>

Keluarannya mungkin seperti ini : 

<tscreen><verb>Name        : koules                      Distribution: Red Hat Linux Colgate
Version     : 1.2                               Vendor: Red Hat Software
Release     : 2                             Build Date: Mon Sep 02 11:59:12 1996
Install date: (none)                        Build Host: porky.redhat.com
Group       : Games                         Source RPM: koules-1.2-2.src.rpm
Size        : 614939
Summary     : SVGAlib action game with multiplayer, network, and sound support
Description :
This arcade-style game is novel in conception and excellent in execution.
No shooting, no blood, no guts, no gore.  The play is simple, but you
still must develop skill to play.  This version uses SVGAlib to
run on a graphics console.
</verb></tscreen>

<item>Sekarang anda ingin melihat file apakah yang diisntall oleh RPM koules.
Anda harus mengerjakan ini :

<tscreen><verb>
rpm -qpl koules-1.2-2.i386.rpm</verb></tscreen>

Keluarannya adalah :
<tscreen><verb>
/usr/doc/koules
/usr/doc/koules/ANNOUNCE 
/usr/doc/koules/BUGS 
/usr/doc/koules/COMPILE.OS2
/usr/doc/koules/COPYING
/usr/doc/koules/Card
/usr/doc/koules/ChangeLog
/usr/doc/koules/INSTALLATION
/usr/doc/koules/Icon.xpm
/usr/doc/koules/Icon2.xpm
/usr/doc/koules/Koules.FAQ
/usr/doc/koules/Koules.xpm
/usr/doc/koules/README
/usr/doc/koules/TODO
/usr/games/koules
/usr/games/koules.svga
/usr/games/koules.tcl
/usr/man/man6/koules.svga.6
</verb></tscreen>
</itemize>
Ini semua adalah contoh belaka. Orang yang kreatif dapat berpikir tentang
kemudahannya, sekali anda telah mengenal (familiar) [dengan] RPM.

<sect>Membuat File RPM Sendiri

<p>Membangun RPM adalah cukup mudah untuk dikerjakan, khususnya bila anda
dapat mengambil perangkat lunak yang anda coba paketkan untuk membangun
dirinya.

<p>Prosedur dasar untuk membangun RPM sebagai berikut :

<itemize>
<item>Pastikan <tt>/etc/rpmrc</> telah diset untuk sistem anda. 
<item>Pastikan kode sumber (<em>source code</em>) yang dibutuhkan untuk membangun
RPM ada dalam sistem anda. 
<item>Buat tambalan (<em>patch</em>) dari setiap perubahan yang harus anda
buat ke dalam <em>source</em> untuk mendapatkannya dibangun dengan benar.
<item>Buat sebuah file spesikasi untuk paket. 
<item>Pastikan segala sesuatunya dalam tempat yang benar. 
<item>Bangun (<em>build</em>) paketnya dengan RPM.
</itemize>

<p>Dalam operasi yang normal, RPM membangun baik paket dalam biner maupun
dalam <em>source</em>.

<sect1>File rpmrc

<p>Sampai saat ini, konfigurasi RPM hanya tersedia via file <tt>/etc/rpmrc</>.
Sebuah contoh, seperti :

<tscreen><verb>
require_vendor: 1
distribution: I roll my own!
require_distribution: 1
topdir: /usr/src/me
vendor: Mickiesoft
packager:  Mickeysoft Packaging Account <packages@mickiesoft.com>

optflags: i386 -O2 -m486 -fno-strength-reduce
optflags: alpha -O2
optflags: sparc -O2

signature: pgp
pgp_name: Mickeysoft Packaging Account
pgp_path: /home/packages/.pgp

tmppath: /usr/tmp

</verb></tscreen>

Baris <tt/require_vendor/ menyebabkan RPM mensyaratkan bahwa ia menemukan
baris vendor. Ini dapat terjadi dari <tt>/etc/rpmrc</> atau dari <em>header</em>
file spesifikasi itu sendiri. Untuk menonaktifkannya, ganti nomor ke 0.
Hal yang sama untuk baris require_distribution dan require_group.

Baris berikutnya adalah baris distribution. Anda dapat mendefinisikannya
di sini atau nanti di <em>header</em> file spesifikasi. Saat membangun sebuah
distribusi tertentu, adalah ide bagus untuk memastikan baris ini adalah
benar, bahkan meski tidak disyaratkan. Baris vendor bekerja dengan cara
yang sama, tetapi dapat berupa apa pun (sebagai contoh Joe's Software and
Rock Music Emporium).

RPM sekarang juga mendukung paket dalam banyak arsitektur. File /rpmrc
dapat mengendalikan sebuah variabel ``optflags'' untuk membangun sesuatu
yang memerlukan arsitektur yang spesifik. Lihat bagian berikutnya untuk
mengetahui bagaimana menggunakan variabel ini.

Dalam tambahan untuk makro yang di atas, ada beberapa lagi. Anda dapat
menggunakan :

<tscreen><verb>
rpm --showrc
</verb></tscreen>

untuk menemukan bagaimana tag ter-set dan flag apa saja yang tersedia.

<sect1>File Spesifikasi

<p>Kami akan memulai diskusi tentang file spesifikasi. File spesifikasi
diperlukan untuk membangun sebuah paket. File spesisikasi adalah gambaran
tentang perangkat lunak dengan instruksinya tentang bagaimana untuk membangunnya
dan sebuah daftar file untuk semua file biner yang ter<em>install</em>.

Anda akan menginginkan menamai file spesifikasi anda, mengacu kepada
konvensi standar. Namanya seharusnya seperti ini nama paket-tanda hubung-nomor
versi-tanda hubung-nomor rilis-titik-spec.

Ini contoh file spesifikasi yang kecil (vim-3.0-1.spec):
<tscreen><verb>
Summary: ejects ejectable media and controls auto ejection
Name: eject
Version: 1.4
Release: 3
Copyright: GPL
Group: Utilities/System
Source: sunsite.unc.edu:/pub/Linux/utils/disk-management/eject-1.4.tar.gz
Patch: eject-1.4-make.patch
Patch1: eject-1.4-jaz.patch
%description
This program allows the user to eject media that is autoejecting like
CD-ROMs, Jaz and Zip drives, and floppy drives on SPARC machines.

%prep
%setup
%patch -p1
%patch1 -p1

%build
make RPM_OPT_FLAGS="$RPM_OPT_FLAGS"

%install
install -s -m 755 -o 0 -g 0 eject /usr/bin/eject
install -m 644 -o 0 -g 0 eject.1 /usr/man/man1

%files
%doc README COPYING ChangeLog

/usr/bin/eject
/usr/man/man1/eject.1
</verb></tscreen>


<sect1>Header

<p>Header mempunyai field standar yang anda perlu isi.
Ada sedikit keberatan memang. Fieldnya harus diisi seperti ini :

<itemize>
<item><tt/Summary/: Ini adalah satu baris yang menggambarkan paket anda. 
<item><tt/Name/: Ini harusnya nama string dari nama file rpm yang anda rencanakan
untuk digunakan. 
<item><tt/Version/: Ini adalah string versi dari file rpm yang anda rencanakan
untuk dipakai. 
<item><tt/Release/: Ini adalah nomor rilis untuk versi paket yang sama (contoh,
bila kita membuat sebuah paket dan menjumpainya agak rusak dan ingin membuatnya
lagi, paket berikutnya akan mempunyai nomor rilis 2). 
<item><tt/Icon/: Ini adalah nama icon yang digunakan untuk perangkat instalasi
level tinggi yang lain (seperti ``glint''-nya Red Hat). Filenya harus berupa
file .gif dan ditempatkan di direktori SOURCES. 
<item><tt/Source/: Baris ini menunjuk ke lokasi HOME dari file <em>source</em> yang
asli. Baris ini dipakai bila anda ingin mendapatkan <em>source </em>lagi
atau mengecek untuk versi yang lebih baru. Keberatannya : Nama file pada
baris ini HARUS cocok dengan nama file yang anda punyai dalam sistem anda
(contoh, jangan mendownload file <em>source</em> dan mengganti namanya).
Anda dapat memberi spesifikasi lebih dari satu file <em>source</em> menggunakan
baris seperti : 
<tscreen><verb>
Source0: blah-0.tar.gz 
Source1: blah-1.tar.gz 
Source2: fooblah.tar.gz
</verb></tscreen>

File-file ini akan ada di direktori SOURCES. (Struktur direktori akan
didiskusikan dalam bagian berikutnya, &quot;Hirarki Direktori 'Source'&quot;

<item><tt/Patch/: Ini akan mengeset tempat dimana anda dapat menemukan tambalannya
(<em>patch</em>-nya), bila anda membutuhkannya untuk mendowloadnya lagi.
Keberatan : Nama filenya harus cocok dengan yang anda gunakan saat anda
membuat <em>patch </em>anda. Anda mungkin juga menginginkan mempunyai lebih
dari satu file <em>patch</em> seperti anda punya banyak <em>source</em>. Anda
harus mengerjakan sesuatu seperti ini :
<tscreen><verb>
Patch0: blah-0.patch 
Patch1: blah-1.patch 
Patch2: fooblah.patch
</verb></tscreen>

<p>File-file ini akan ada di direktori SOURCES.

<item><tt/Copyright/: Baris ini memberitahu bagaimana status hak cipta sebuah
paket. Anda harus menggunakan sesuatu seperti GPL, BSD, MIT, public domain,
distributable, atau commercial. 

<item><tt/BuildRoot/: Baris ini mengizinkan anda untuk menspesifikasikan sebuah
direktori sebagai <em>root</em> (akar) untuk membangun dan meng<em>install
</em>paket baru. Anda dapat menggunakannya untuk mengetes paket anda sebelum
meng<em>install</em>nya dalam mesin anda. 

<item><tt/Group/: Baris ini digunakan untuk memberitahu program instalasi level
tinggi (seperti ``glint''-nya Red Hat) ke mana menempatkan program tertentu
dalam hirarki struktur. Grup pohon (<em>tree</em>) kelihatan seperti ini:
<tscreen><verb>
Applications
    Communications
    Editors
	Emacs
    Engineering
    Spreadsheets
    Databases
    Graphics
    Networking
    Mail
    Math
    News
    Publishing
	TeX
Base
    Kernel
Utilities
    Archiving
    Console
    File
    System
    Terminal
    Text
Daemons
Documentation
X11
    XFree86
	Servers
    Applications
	Graphics
	Networking
    Games
	Strategy
	Video
    Amusements
    Utilities
    Libraries
    Window Managers
Libraries
Networking
    Admin
    Daemons
    News
    Utilities
Development
    Debuggers
    Libraries
	Libc
    Languages
 	Fortran
	Tcl
    Building
    Version Control
    Tools
Shells
Games
</verb></tscreen>


<item><tt/%description/ Ini bukanlah benar-benar item <em>header</em>, tetapi seharusnya
digambarkan di akhir <em>header</em>. Anda membutuhkan satu tag gambaran
per paket dan / atau sub-paket. Ini adalah field multi-baris yang harus
digunakan untuk memberikan sebuah gambaran yang lengkap dari paket itu.
</itemize>

<sect1>Persiapan

<p>Ini adalah bagian kedua dalam file spesifikasi. Ini digunakan untuk
mendapatkan <em>source</em> yang siap dibangun. Di sini anda memerlukan apa
pun yang dibutuhkan untuk mendapatkan <em>source</em> telah tertambal dan
setup seperti yang mereka inginkan dikerjakan dengan 'make'.

<p>Satu hal yang harus dicatat : Setiap bagian ini adalah benar-benar hanya
sebuah tempat untuk mengeksekusi script shell. Anda dapat membuat sebuah
script sh dengan mudah dan menaruhnya setelah tag <tt/&percnt;prep/ untuk
melakukan unpack dan menambal <em>source</em> anda. Kami membuat makro untuk
membantu dalam hal ini, bagaimana pun juga.

<p>Yang pertama dari makro-makro ini adalah makro <tt/&percnt;setup/. Dalam
bentuk yang paling sederhana (tanpa pilihan baris perintah), dia akan melakukan
unpack <em>source</em> dan melakukan cd ke direktori <em>source</em>. Hal itu
juga akan disertai pilihan (<em>option</em>) :

<itemize>
<item><tt/-n name/ akan mengeset nama dari direktori yang dibuat kepada nama yang
terdaftar. Standarnya adalah <tt/&dollar;NAME-&dollar;VERSION/. Kemungkinan
lain termasuk <tt/&dollar;NAME, &dollar;{NAME}&dollar;{VERSION}/,
atau apa pun file tar utama gunakan. (Harap dicatat bahwa variabel ``&dollar;''
di sini adalah bukan variabel yang nyata yang tersedia di bawah file spesifikasi.
Mereka sesungguhnya digunakan di tempat nama sampel. Anda perlu menggunakan
nama asli dan versi dalam paket anda, bukan sebuah variabel.)

<item><tt/-c/ akan membuat dan melakukan cd kepada direktori bernama sebelum mengerjakan
proses untar.

<item><tt/-b/ akan melakukan untar Source&num; sebelum berpindah direktori
ke dalamnya (dan ini membuat tak berlaku dengan -c karena itu jangan kerjakan
ini). Ini hanya berguna untuk paket yang mempunyai <em>source</em> banyak.

<item><tt/-a/ &num; akan melakukan untar Source&num; sesudah berpindah
ke direktorinya.

<item><tt/-T/ pilihan ini melakukan overrides aksi standar dari proses untarring
<em>source</em> dan memerlukan pilihan -b 0 atau -a 0 untuk mendapatkan file
<em>source</em> utama dikenai proses untar. Anda memerlukannya saat ada <em>source</em>
kedua.

<item><tt/-D/ Jangan menghapus direktori sebelum unpacking. Ini hanya berguna
di mana anda mempunyai lebih dari satu makro setup. Ini seharusnya digunakan
dalam makro setup sesudah yang pertama (tetapi jangan pernah di makro yang
pertama). 
</itemize>

<p>Makro berikutnya yang tersedia adalah makro <tt/%patch/. Makro ini membantu
mengotomatiskan proses penerapan <em>patch </em>ke <em>source</em>. Makro ini
memerlukan beberapa pilihan, diperlihatkan di bawah ini :

<itemize>
<item><tt/&num/; akan menerapkan Patch&num; sebagai file penambal (<em>patch</em>).

<item><tt/-p &num/; memerinci sejumlah direktori untuk dibuka untuk perintah
patch(1).

<item><tt/-P/ Aksi standarnya adalah menerapkan Patch (atau Patch0). Tanda ini
menahan aksi standar dan akan memerlukan sebuah 0 untuk mendapatkan file
<em>source</em> utama di-untar. Pilihan ini berguna dalam sedetik atau lebih
makro <em>patch</em> yang memerlukan sebuah nomor berbeda dibandingkan dengan
makro pertama.

<item>Anda dapat juga mengerjakan <tt/&percnt;patch&num;/ sebagai ganti
dari mengetik perintah asli: <tt/&percnt;patch &num; -P/
</itemize>

<p>Itu seharusnya adalah semua makro yang anda perlukan. Setelah anda meyakinkan
semuanya benar, anda dapat juga mengerjakan setup yang lain yang anda perlukan
untuk dikerjakan via script bertipe <tt/sh/. Apa pun yang anda sertakan sampai
makro &percnt;build (didiskusikan dalam bagian berikutnya) adalah menjalankannya
via sh. Lihat contoh di atas untuk ketikan dari sesuatu yang anda mungkin
inginkan untuk dikerjakan di sini.

<sect1>Membangun (Build)

<p>Pada dasarnya tak ada makro apa pun untuk bagian ini. Anda seharusnya
hanya meletakkan perintah apa pun di sini yang akan anda pakai untuk membangun
perangkat lunak, sekali anda melakukan untar <em>source</em>nya, menambalnya
dan melakukan cd ke dalam direktori. Ini hanyalah set perintah yang lain
yang dilewatkan ke sh, sehingga perintah sah (legal) apa pun dapat pergi
ke sini (termasuk komentar). Direktori kerja anda saat ini di-reset dalam
setiap bagian ini ke tingkat atas dari direktori sumber, jadi ingatlah
itu baik-baik. Anda dapat melakukan cd ke dalam subdirektori bila diperlukan.

<sect1>Memasang (<em>Install</em>)

<p>Sebenarnya tak ada makro apa pun di sini. Anda hanya ingin meletakkan
perintah apa pun di sini yang diperlukan untuk meng<em>install</em>. Bila
anda punya 'make install' tersedia untuk anda dalam paket yang anda bangun,
letakkan itu di sini. Bila tidak, anda dapat menambal makefile untuk sebuah
make install dan hanya mengerjakan sebuah 'make install' di sini, atau
anda dapat meng<em>install</em> mereka secara manual dengan perintah sh.
Anda dapat mempertimbangkan direktori anda saat ini untuk menjadi tingkat
atas dari direktori <em>source</em>.

<sect1>Pilihan Script <em>Install</em>/<em>Uninstall</em> pre dan post

<p>Anda dapat membuat script dijalankan sebelum dan sesudah instalasi dan
uninstalasi dari paket biner. Sebuah alasan utama untuk itu adalah mengerjakan
sesuatu seperti menjalankan ldconfig setelah instalasi atau memindahkan
paket yang berisikan libraries / kepustakaan yang dipakai bersama (<em>shared</em>).
Makro untuk setiap script adalah sebagai berikut :

<itemize>
<item><tt/&percnt;pre/ adalah makro untuk mengerjakan script pre-install.
<item><tt/&percnt;post/ adalah makro untuk mengerjakan script post-install.
<item><tt/&percnt;preun/ adalah makro untuk mengerjakan script pre-uninstall.
<item><tt/&percnt;postun/ adalah makro untuk mengerjakan script post-uninstall.
</itemize>

<p>Isi dari bagian ini seharusnya hanyalah beberapa bentuk dari script,
meski anda tidak membutuhkan <tt>&num;!/bin/sh</>.

<sect1>File-file

<p>Ini adalah bagian di mana anda harus melihat file-file paket biner.
RPM tak punya cara lain untuk mengetahui file biner apa yang sudah di<em>install</em>
sebagai hasil dari make install. Ada jalan untuk mengetahuinya. Beberapa
menyarankan untuk melakukan find sebelum dan sesudah paket di<em>install</em>.
Dengan sistem <em>multiuser</em> (banyak pemakai), ini tak dapat diterima
seperti file lain mungkin telah dibuat selama sebuah proses pembangunan
paket yang menyebabkan tak ada yang dikerjakan dengan paket itu sendiri.

<p>Ada beberapa makro tersedia untuk mengerjakan beberapa hal yang istimewa.
Mereka terdaftar dan digambarkan di sini :

<itemize>
<item><tt/&percnt;doc/ digunakan untuk menandai dokumentasi dalam paket <em>source</em>
yang anda ingin <em>install</em> di dalam instalasi biner. Dokumen akan dipasang
dalam /usr/doc/&dollar;NAME-&dollar;VERSION-&dollar;RELEASE.
Anda dapat melihat banyak dokumen dengan perintah baris dengan makro ini,
atau anda dapat melihatnya semua secara terpisah dengan menggunakan sebuah
makro untuk setiap dokumennya.
<item><tt/&percnt;config/ digunakan untuk menandai file konfigurasi dalam
sebuah paket. Ini menyertakan file seperti sendmail.cf, passwd, dll. Bila
anda kemudian melakukan <em>uninstall</em> sebuah paket berisikan file konfigurasi,
semua file yang tak berubah akan dihapus dan file yang berubah akan dipindahkan
ke nama lama mereka dengan sebuah .rpmsave ditambahkan ke nama file-nya.
Anda dapat melihat banyak file dengan makro ini.
<item><tt/&percnt;dir/ menandai sebuah direktori tunggal dalam sebuah daftar
file untuk disertakan sebagaimana dimilki oleh sebuah paket. Standarnya,
bila anda melihat sebuah nama direktori TANPA sebuah makro &percnt;dir,
SEGALA SESUATU dalam direktori itu disertakan dalam daftar file dan kemudian
dipasang (<em>installed</em>) sebagai bagian dari paket itu. 
<item><tt/&percnt;files -f &lt;filename&gt;/ akan mengizinkan anda
untuk melihat file anda dalam beberapa file arbitrary di dalam direktori
pembangunan <em>source</em>.Ini menyenangkan dalam kasus di mana anda mempunyai
sebuah paket yang dapat membangun daftar file miliknya. Anda kemudian hanyalah
menyertakan daftar file di sini dan anda tidak harus mendaftarkan file
secara spesifik.
</itemize>

<p>Keberatan terbesar dalam daftar file adalah daftar direktori-direktori.
Bila anda mendaftarkan <tt>/usr/bin</> secara tak sengaja, paket biner anda akan
berisi setiap file dalam <tt>/usr/bin</> di sistem anda.

<sect1>Cara membangunnya !

<sect2>'Source' Pohon Direktori

<p>Pertama kali yang anda butuhkan adalah <em>build tree </em>yang terkonfigurasi
dengan benar. Ini dapat dikonfigurasi menggunakan file <tt>/etc/rpmrc</>. Sebagian
besar orang akan hanya menggunakan /usr/src.

<p>Anda mungkin memerlukan membuat direktori selanjutnya untuk membuat
sebuah <em>build tree </em>:

<itemize>
<item><tt/BUILD/ adalah direktori di mana semua proses pembangunan terjadi oleh
RPM. Anda tak harus mengerjakan test anda untuk dibangun di mana saja pada
khususnya, tetapi ini adalah di mana RPM akan mengerjakannya sendiri.
<item><tt/SOURCES/ adalah direktori di mana anda seharusnya meletakkan file tar
<em>source</em> asli anda dan <em>patch</em> anda. Ini adalah tempat di mana
RPM akan mencari dalam keadaan standar.
<item><tt/SPECS/ adalah direktori di mana semua file yang spesifikasi harus berada.
<item><tt/RPMS/ adalah tempat di mana RPM akan meletakkan semua file biner RPM
saat proses pembangunan.
<item><tt/SRPMS/ adalah tempat di mana semua <em>source</em> RPM akan diletakkan.
</itemize>

<sect2>Mengetes pembangunan

<p>Pertama kali yang anda mungkin akan inginkan adalah mengambil <em>source</em>
untuk membangun secara bersih tanpa RPM. Untuk mengerjakan ini, lakukan
'unpack' pada <em>source</em>, dan rubah nama direktori ke<tt/&dollar;NAME.orig/.
Lalu lakukan 'unpack' pada <em>source</em> lagi. Gunakan <em>source </em>ini
untuk membangunnya. Pergilah ke dalam direktori <em>source</em> dan ikuti
instruksi untuk membangunnya. Bila anda harus menyunting sesuatu, anda
akan membutuhkan sebuah <em>patch</em>. Sekali anda memilihnya untuk dibangun,
bersihkan direktori <em>source</em>nya. Pastikan dan hapus file apa pun yang
diambil dari sebuah script <tt/configure/. Lalu lakukan <tt/cd/ kembali, keluar
dari direktori <em>source</em> ke induknya. Kemudian anda akan mengerjakan
sesuatu seperti :

<tscreen><verb>diff -uNr dirname.orig dirname &gt;../SOURCES/dirname-linux.patch</verb></tscreen>

Ini akan membuat sebuah <em>patch</em> untuk anda yang anda gunakan dalam
file spesifikasi anda. Catatan bahwa ``linux'' yang anda lihat dalam nama
<em>patch </em>adalah hanya sebuah identifier. Anda mungkin ingin menggunakan
sesuatu yang lebih bisa menggambarkan seperti ``config'' atau <em>bugs</em>
untuk menggambarkan mengapa anda harus membuat sebuah <em>patch</em>.

Sebuah ide yang bagus juga untuk melihat file <em>patch</em> yang anda
buat sebelum menggunakannya untuk memastikan tak ada file biner yang terselip
secara tak sengaja.

<sect2>Membuat Daftar File

<p>Sekarang, anda telah mempunyai <em>source</em> yang akan dibangun dan
tahu bagaimana mengerjakannya, membangunnya, dan memasangnya. Lihatlah
keluaran dari urutan pemasangan dan membangun daftar file anda dari hal
itu untuk digunakan dalam file spesifikasi. Kami pada umumnya membangun
file spesifikasi secara paralel dengan semua langkah ini. Anda dapat membuat
salah satu inisial dan mengisinya ke dalam bagian yang mudah, dan lalu
mengisikan ke dalam langkah lain sebagaimana anda lakukan.

<sect2>Membangun sebuah Paket dengan RPM
<p>Sekali anda punya sebuah file spesifikasi, anda siap untuk mencoba dan
membangun paket anda. Cara yang paling bermanfaat untuk mengerjakan ini
adalah dengan sebuah perintah seperti :

<tscreen><verb>rpm -ba foobar-1.0.spec</verb></tscreen>

Ada pilihan lain yang berguna dengan switch <tt/-b/ seperti :

<itemize>
<item><tt/p/ berarti kerjakan bagian persiapan dari file spesifikasi.
<item><tt/l/ adalah sebuah cek daftar yang mengerjakan beberapa pengecekan atas
<tt/&percnt;files/.
<item><tt/c/ mengerjakan prep dan compile. Ini berguna manakala anda tak yakin
kalau-kalau <em>source</em> akan dibangun seluruhnya. Kelihatannya tak berguna
karena anda mungkin ingin 'memainkan' <em>source</em>nya sendiri sampai ia
dibangun dan kemudian memulai menggunakan RPM, tetapi sekali anda menjadi
terbiasa menggunakan RPM, anda akan menemukan kemudahan dalam menggunakannya.
<item><tt/i/ mengerjakan persiapan, kompilasi dan instalasi.
<item><tt/b/ persiapan, kompilasi, instalasi dan membangun sebuah paket biner
saja.
<item><tt/a/ membangun seluruhnya (baik <em>source</em> dan paket binernya).
</itemize>

<p>Ada beberapa modifier dalam switch <tt/-b/, yaitu :

<itemize>
<item><tt/--short-circuit/ akan melompat langsung ke tahap yang telah ditentukan
(hanya dapat digunakan dengan c dan i).
<item><tt/--clean/ menghapus bangunan pohon saat usai.
<item><tt/--keep-temps/ akan mengamankan semua file temporer dan script yang dibuat
dalam /tmp. Anda sesungguhnya dapat melihat file-file apa yang dibuat dalam
/tmp menggunakan option <tt/-v/.
<item><tt/--test/ tidak menjalankan tingkat yang sebenarnya, tetapi tetap mengamankan
-temp.
</itemize>

<sect1>Pengetesan

<p>Sekali anda telah memiliki sebuah rpm <em>source</em> dan biner untuk
paket anda, anda perlu mengetesnya. Cara paling mudah dan terbaik adalah
menggunakan mesin yang benar-benar berbeda dari seseorang di mana anda
membangun di atasnya dalam rangka mengetes. Sesudah itu, anda hanya harus
mengerjakan make install di mesin anda sendiri, sehingga seharusnya ia
sudah terpasang dengan cukup baik. 

<p>Anda dapat mengetik <TT>rpm -u namapaket</TT> atas sebuah paket untuk
mengetesnya, tetapi cara itu tidak dapat dipercaya, karena dalam membangun
sebuah paket, anda telah mengerjakan <TT>make install</TT>. Bila anda meninggalkan
sesuatu di luar daftar file anda, ia tidak akan di-<em>uninstall</em>. Anda
akan kemudian meng<em>install</em> ulang paket biner dan sistem anda akan
menjadi lengkap lagi, tetapi rpm anda masih belum lengkap. Pastikan dan
ingat-ingat bahwa hanya karena anda melakukan <TT>rpm -ba namapaket</TT>,
kebanyakan orang memasang paket anda akan hanya mengerjakan <TT>rpm -i
namapaket</TT>. Patikan anda tidak mengerjakan apa pun dalam bagian pemasangan
atau <em>install</em> yang akan diperlukan untuk dikerjakan saat binernya
terpasang secara otomatis.

<sect1>Apa dapat yang dikerjakan dengan RPM baru anda

<p>Sekali anda telah membuat RPM anda sendiri atas sesuatu (diasumsikan
sesuatu yang belum pernah di-RPM-kan), anda dapat melakukan kontribusi
pekerjaan anda ke yang lain (juga diasumsikan anda me-RPM-kan sesuatu yang
didistribusikan dengan bebas). Untuk mengerjakan itu, anda ingin melakukan
upload paketnya ke <url url = "ftp://ftp.redhat.com"
name="ftp://ftp.redhat.com">

<sect1>Sekarang Mau Apa Lagi?

<p>Silakan lihat bagian di atas dalam Pengetesan
dan Apa yang dikerjakan dengan RPM baru anda.
Kami ingin semua ketersediaan RPM dapat kami ambil, dan kami ingin 'mereka'
menjadi RPM yang baik. Silakan ambil waktu untuk mengetes mereka sebaik
mungkin, dan kemudian ambil waktu untuk meng-uploadnya untuk keuntungan
semua orang. Juga, silakan memastikan anda hanya melakukan upload perngkat
lunak yang tersedia dengan gratis. Perangkat lunak komersial dan shareware
tak seharusnya di-upload kecuali mereka punya hak cipta dan dinyatakan
bahwa hal ini diizinkan. Ini termasuk perangkat lunak dari Netscape, ssh,
pgp, dll.

<sect>Pembangunan RPM multi-arsitektur

<p>Sekarang RPM dapat digunakan untuk membangun paket untuk Intel i386,
Digital Alpha yang menjalankan Linux, dan Sparc. RPM juga dilaporkan bekerja
dalam SGI dan workstation HP dengan baik. Ada beberapa kemampuan yang membuat
pembangunan dalam <em>platform</em>-<em>platform</em> tersebut menjadi mudah,
Pertama adalah directive ``optflags'' yang ada dalam <tt>/etc/rpmrc</>. Ini dapat
digunakan untuk mengeset flag yang digunakan saat membangun perangkat lunak
ke arsitektur yang spesifik. Kemampuan lain adalah makro ``arch'' dalam
file spesifikasi. Mereka dapat digunakan untuk mengerjakan sesuatu yang
berbeda berdasarkan atas arsitektur dimana anda membangunnya. Kemampuan
yang lain lagi adalah directive ``Exclude'' dalam <em>header</em> / kepalanya.

<sect1>Contoh file spesikasi

<p>Bagian di bawah ini adalah file spesifikasi dari paket ``fileutils''.
Ini adalah setup untuk dibangun di atas Alpha dan Intel.

<tscreen><verb>
Summary: GNU File Utilities
Name: fileutils
Version: 3.16
Release: 1
Copyright: GPL
Group: Utilities/File
Source0: prep.ai.mit.edu:/pub/gnu/fileutils-3.16.tar.gz
Source1: DIR_COLORS
Patch: fileutils-3.16-mktime.patch

%description
These are the GNU file management utilities.  It includes programs
to copy, move, list, etc, files.

The ls program in this package now incorporates color ls!

%prep
%setup

%ifarch alpha
%patch -p1
autoconf
%endif
%build
configure --prefix=/usr --exec-prefix=/
make CFLAGS="$RPM_OPT_FLAGS" LDFLAGS=-s

%install
rm -f /usr/info/fileutils*
make install
gzip -9nf /usr/info/fileutils*

.
.
.

</verb></tscreen>

<sect1>Optflags

<p>Dalam contoh tersebut, anda melihat bagaimana directive ``optflags''
digunakan dalam <tt>/etc/rpmrc</>. Bergantung kepada arsitektur mana anda membangunnya,
harga yang wajar diberikan kepada RPM_OPT_FLAGS. Anda harus menambal Makefile
untuk paket anda untuk menggunakan variabel ini di tempat directive yang
normal yang mungkin anda gunakan seperti -m486 dan -O2. Anda dapat merasakan
perasaan yang nyaman untuk kebutuhan apa yang harus dikerjakan dengan meng<em>install</em>
paket <em>source</em> ini dan kemudian melakukan unpack <em>source</em> dan
menguji Makefile. Setelah itu lihatlah <em>patch</em> untuk Makefile dan
lihat perubahan apa yang harus dibuat.

<sect1>Makro

<p>Makro <tt/%ifarch/ sangat penting secara keseluruhan. Banyak waktu akan diperlukan
untuk membuat sebuah <em>patch</em> atau dua yang spesifik ke satu arsitektur
saja. dalam kasus ini, RPM akan mengizinkan anda untuk menerapkan <em>patch</em>
itu untuk satu arsitektur saja.

Dalam contoh di atas fileutils mempunyai <em>patch</em> untuk mesin 64
bit. Dengan jelas, ini seharusnya diterapkan untuk Alpha saat ini. Jadi,
kami menambahkan sebuah makro %ifarch di sekitar <em>patch</em> 64 bit seperti
ini :

<tscreen><verb>
%ifarch axp
%patch1 -p1
%endif
</verb></tscreen>
<itemize>
<p>Hal tersebut akan memastikan bahwa <em>patch</em> itu tidak diterapkan
untuk semua arsitektur, kecuali alpha.
</itemize>

<sect1>Membuat perkecualian Arsitektur dari Paket

<p>Anda dapat memelihara <em>source</em> RPM dalam satu direktori untuk semua
paltform, kami telah mengimplementasikan kemampuan untuk ``mengecualikan''
paket dari proses pembangunan dalam arsitektur tertentu. Dengan ini anda
masih dapat mengerjakan sesuatu seperti 

<tscreen><verb>
rpm --rebuild /usr/src/SRPMS/*.rpm
</verb></tscreen>

dan mendapatkan paket yang benar sudah dibangun. Bila anda belum membuat
porting sebuah aplikasi dalam <em>platform</em> tertentu, semua yang harus
anda lakukan adalah menambahkan sebuah baris, seperti :

<tscreen><verb>
ExcludeArch: axp
</verb></tscreen>

ke dalam kepala dari file spesifikasi dari paket <em>source</em>. Kemudian
bangun ulang paketnya di atas <em>platform</em> dimana ia telah dibangun
di atasnya. Anda akan mempunyai paket <em>source</em> yang dibangun di atas
Intel dan dapat dengan mudah berpindah ke atas Alpha.

<sect1>Penyelesaian Akhir

<p>Menggunakan RPM untuk membuat paket multi-arsitektur pada umumnya lebih
mudah dikerjakan daripada mendapatkan paket itu sendiri dibangun dalam
kedua tempat. Seperti lebih dari paket yang dibangun, ini akan menjadi
mudah, bagaimana pun juga. Sebagaimana lazimnya, bantuan yang terbaik saat
anda mulai bingung dalam membangun sebuah RPM adalah melihat paket <em>source</em>
yang mirip.

<sect>Pemberitahuan Hak Cipta

<p>Dokumen ini dan isinya dilindungi dengan undang-undang Hak Cipta. Distribusi
ulang dari dokumen ini diizinkan sejauh isinya tetap lengkap dan tidak
diganti. Dengan kata lain, anda boleh memformat ulang dan mencetak ulang
atau mendistribusikan ulang saja.

</article>