<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.7">
 <TITLE>RPM HOWTO (RPM saat stasioner.....:-)): Membuat File RPM Sendiri</TITLE>
 <LINK HREF="ID-RPM-HOWTO-7.html" REL=next>
 <LINK HREF="ID-RPM-HOWTO-5.html" REL=previous>
 <LINK HREF="ID-RPM-HOWTO.html#toc6" REL=contents>
</HEAD>
<BODY>
<A HREF="ID-RPM-HOWTO-7.html">Next</A>
<A HREF="ID-RPM-HOWTO-5.html">Previous</A>
<A HREF="ID-RPM-HOWTO.html#toc6">Contents</A>
<HR>
<H2><A NAME="s6">6. Membuat File RPM Sendiri</A></H2>

<P>Membangun RPM adalah cukup mudah untuk dikerjakan, khususnya bila anda
dapat mengambil perangkat lunak yang anda coba paketkan untuk membangun
dirinya.
<P>
<P>Prosedur dasar untuk membangun RPM sebagai berikut :
<P>
<UL>
<LI>Pastikan <CODE>/etc/rpmrc</CODE> telah diset untuk sistem anda. </LI>
<LI>Pastikan kode sumber (<EM>source code</EM>) yang dibutuhkan untuk membangun
RPM ada dalam sistem anda. </LI>
<LI>Buat tambalan (<EM>patch</EM>) dari setiap perubahan yang harus anda
buat ke dalam <EM>source</EM> untuk mendapatkannya dibangun dengan benar.</LI>
<LI>Buat sebuah file spesikasi untuk paket. </LI>
<LI>Pastikan segala sesuatunya dalam tempat yang benar. </LI>
<LI>Bangun (<EM>build</EM>) paketnya dengan RPM.</LI>
</UL>
<P>
<P>Dalam operasi yang normal, RPM membangun baik paket dalam biner maupun
dalam <EM>source</EM>.
<P>
<H2><A NAME="ss6.1">6.1 File rpmrc</A>
</H2>

<P>Sampai saat ini, konfigurasi RPM hanya tersedia via file <CODE>/etc/rpmrc</CODE>.
Sebuah contoh, seperti :
<P>
<BLOCKQUOTE><CODE>
<PRE>
require_vendor: 1
distribution: I roll my own!
require_distribution: 1
topdir: /usr/src/me
vendor: Mickiesoft
packager:  Mickeysoft Packaging Account &lt;packages@mickiesoft.com>

optflags: i386 -O2 -m486 -fno-strength-reduce
optflags: alpha -O2
optflags: sparc -O2

signature: pgp
pgp_name: Mickeysoft Packaging Account
pgp_path: /home/packages/.pgp

tmppath: /usr/tmp
</PRE>
</CODE></BLOCKQUOTE>
<P>Baris <CODE>require_vendor</CODE> menyebabkan RPM mensyaratkan bahwa ia menemukan
baris vendor. Ini dapat terjadi dari <CODE>/etc/rpmrc</CODE> atau dari <EM>header</EM>
file spesifikasi itu sendiri. Untuk menonaktifkannya, ganti nomor ke 0.
Hal yang sama untuk baris require_distribution dan require_group.
<P>Baris berikutnya adalah baris distribution. Anda dapat mendefinisikannya
di sini atau nanti di <EM>header</EM> file spesifikasi. Saat membangun sebuah
distribusi tertentu, adalah ide bagus untuk memastikan baris ini adalah
benar, bahkan meski tidak disyaratkan. Baris vendor bekerja dengan cara
yang sama, tetapi dapat berupa apa pun (sebagai contoh Joe's Software and
Rock Music Emporium).
<P>RPM sekarang juga mendukung paket dalam banyak arsitektur. File /rpmrc
dapat mengendalikan sebuah variabel ``optflags'' untuk membangun sesuatu
yang memerlukan arsitektur yang spesifik. Lihat bagian berikutnya untuk
mengetahui bagaimana menggunakan variabel ini.
<P>Dalam tambahan untuk makro yang di atas, ada beberapa lagi. Anda dapat
menggunakan :
<P>
<BLOCKQUOTE><CODE>
<PRE>
rpm --showrc
</PRE>
</CODE></BLOCKQUOTE>
<P>untuk menemukan bagaimana tag ter-set dan flag apa saja yang tersedia.
<P>
<H2><A NAME="ss6.2">6.2 File Spesifikasi</A>
</H2>

<P>Kami akan memulai diskusi tentang file spesifikasi. File spesifikasi
diperlukan untuk membangun sebuah paket. File spesisikasi adalah gambaran
tentang perangkat lunak dengan instruksinya tentang bagaimana untuk membangunnya
dan sebuah daftar file untuk semua file biner yang ter<EM>install</EM>.
<P>Anda akan menginginkan menamai file spesifikasi anda, mengacu kepada
konvensi standar. Namanya seharusnya seperti ini nama paket-tanda hubung-nomor
versi-tanda hubung-nomor rilis-titik-spec.
<P>Ini contoh file spesifikasi yang kecil (vim-3.0-1.spec):
<BLOCKQUOTE><CODE>
<PRE>
Summary: ejects ejectable media and controls auto ejection
Name: eject
Version: 1.4
Release: 3
Copyright: GPL
Group: Utilities/System
Source: sunsite.unc.edu:/pub/Linux/utils/disk-management/eject-1.4.tar.gz
Patch: eject-1.4-make.patch
Patch1: eject-1.4-jaz.patch
%description
This program allows the user to eject media that is autoejecting like
CD-ROMs, Jaz and Zip drives, and floppy drives on SPARC machines.

%prep
%setup
%patch -p1
%patch1 -p1

%build
make RPM_OPT_FLAGS="$RPM_OPT_FLAGS"

%install
install -s -m 755 -o 0 -g 0 eject /usr/bin/eject
install -m 644 -o 0 -g 0 eject.1 /usr/man/man1

%files
%doc README COPYING ChangeLog

/usr/bin/eject
/usr/man/man1/eject.1
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<H2><A NAME="ss6.3">6.3 Header</A>
</H2>

<P>Header mempunyai field standar yang anda perlu isi.
Ada sedikit keberatan memang. Fieldnya harus diisi seperti ini :
<P>
<UL>
<LI><CODE>Summary</CODE>: Ini adalah satu baris yang menggambarkan paket anda. </LI>
<LI><CODE>Name</CODE>: Ini harusnya nama string dari nama file rpm yang anda rencanakan
untuk digunakan. </LI>
<LI><CODE>Version</CODE>: Ini adalah string versi dari file rpm yang anda rencanakan
untuk dipakai. </LI>
<LI><CODE>Release</CODE>: Ini adalah nomor rilis untuk versi paket yang sama (contoh,
bila kita membuat sebuah paket dan menjumpainya agak rusak dan ingin membuatnya
lagi, paket berikutnya akan mempunyai nomor rilis 2). </LI>
<LI><CODE>Icon</CODE>: Ini adalah nama icon yang digunakan untuk perangkat instalasi
level tinggi yang lain (seperti ``glint''-nya Red Hat). Filenya harus berupa
file .gif dan ditempatkan di direktori SOURCES. </LI>
<LI><CODE>Source</CODE>: Baris ini menunjuk ke lokasi HOME dari file <EM>source</EM> yang
asli. Baris ini dipakai bila anda ingin mendapatkan <EM>source </EM>lagi
atau mengecek untuk versi yang lebih baru. Keberatannya : Nama file pada
baris ini HARUS cocok dengan nama file yang anda punyai dalam sistem anda
(contoh, jangan mendownload file <EM>source</EM> dan mengganti namanya).
Anda dapat memberi spesifikasi lebih dari satu file <EM>source</EM> menggunakan
baris seperti : 
<BLOCKQUOTE><CODE>
<PRE>
Source0: blah-0.tar.gz 
Source1: blah-1.tar.gz 
Source2: fooblah.tar.gz
</PRE>
</CODE></BLOCKQUOTE>


File-file ini akan ada di direktori SOURCES. (Struktur direktori akan
didiskusikan dalam bagian berikutnya, &quot;Hirarki Direktori 'Source'&quot;
</LI>
<LI><CODE>Patch</CODE>: Ini akan mengeset tempat dimana anda dapat menemukan tambalannya
(<EM>patch</EM>-nya), bila anda membutuhkannya untuk mendowloadnya lagi.
Keberatan : Nama filenya harus cocok dengan yang anda gunakan saat anda
membuat <EM>patch </EM>anda. Anda mungkin juga menginginkan mempunyai lebih
dari satu file <EM>patch</EM> seperti anda punya banyak <EM>source</EM>. Anda
harus mengerjakan sesuatu seperti ini :
<BLOCKQUOTE><CODE>
<PRE>
Patch0: blah-0.patch 
Patch1: blah-1.patch 
Patch2: fooblah.patch
</PRE>
</CODE></BLOCKQUOTE>


<P>File-file ini akan ada di direktori SOURCES.
<P>
</LI>
<LI><CODE>Copyright</CODE>: Baris ini memberitahu bagaimana status hak cipta sebuah
paket. Anda harus menggunakan sesuatu seperti GPL, BSD, MIT, public domain,
distributable, atau commercial. 
</LI>
<LI><CODE>BuildRoot</CODE>: Baris ini mengizinkan anda untuk menspesifikasikan sebuah
direktori sebagai <EM>root</EM> (akar) untuk membangun dan meng<EM>install</EM>paket baru. Anda dapat menggunakannya untuk mengetes paket anda sebelum
meng<EM>install</EM>nya dalam mesin anda. 
</LI>
<LI><CODE>Group</CODE>: Baris ini digunakan untuk memberitahu program instalasi level
tinggi (seperti ``glint''-nya Red Hat) ke mana menempatkan program tertentu
dalam hirarki struktur. Grup pohon (<EM>tree</EM>) kelihatan seperti ini:
<BLOCKQUOTE><CODE>
<PRE>
Applications
    Communications
    Editors
        Emacs
    Engineering
    Spreadsheets
    Databases
    Graphics
    Networking
    Mail
    Math
    News
    Publishing
        TeX
Base
    Kernel
Utilities
    Archiving
    Console
    File
    System
    Terminal
    Text
Daemons
Documentation
X11
    XFree86
        Servers
    Applications
        Graphics
        Networking
    Games
        Strategy
        Video
    Amusements
    Utilities
    Libraries
    Window Managers
Libraries
Networking
    Admin
    Daemons
    News
    Utilities
Development
    Debuggers
    Libraries
        Libc
    Languages
        Fortran
        Tcl
    Building
    Version Control
    Tools
Shells
Games
</PRE>
</CODE></BLOCKQUOTE>


</LI>
<LI><CODE>%description</CODE> Ini bukanlah benar-benar item <EM>header</EM>, tetapi seharusnya
digambarkan di akhir <EM>header</EM>. Anda membutuhkan satu tag gambaran
per paket dan / atau sub-paket. Ini adalah field multi-baris yang harus
digunakan untuk memberikan sebuah gambaran yang lengkap dari paket itu.</LI>
</UL>
<P>
<H2><A NAME="ss6.4">6.4 Persiapan</A>
</H2>

<P>Ini adalah bagian kedua dalam file spesifikasi. Ini digunakan untuk
mendapatkan <EM>source</EM> yang siap dibangun. Di sini anda memerlukan apa
pun yang dibutuhkan untuk mendapatkan <EM>source</EM> telah tertambal dan
setup seperti yang mereka inginkan dikerjakan dengan 'make'.
<P>
<P>Satu hal yang harus dicatat : Setiap bagian ini adalah benar-benar hanya
sebuah tempat untuk mengeksekusi script shell. Anda dapat membuat sebuah
script sh dengan mudah dan menaruhnya setelah tag <CODE>%prep</CODE> untuk
melakukan unpack dan menambal <EM>source</EM> anda. Kami membuat makro untuk
membantu dalam hal ini, bagaimana pun juga.
<P>
<P>Yang pertama dari makro-makro ini adalah makro <CODE>%setup</CODE>. Dalam
bentuk yang paling sederhana (tanpa pilihan baris perintah), dia akan melakukan
unpack <EM>source</EM> dan melakukan cd ke direktori <EM>source</EM>. Hal itu
juga akan disertai pilihan (<EM>option</EM>) :
<P>
<UL>
<LI><CODE>-n name</CODE> akan mengeset nama dari direktori yang dibuat kepada nama yang
terdaftar. Standarnya adalah <CODE>$NAME-$VERSION</CODE>. Kemungkinan
lain termasuk <CODE>$NAME, ${NAME}${VERSION}</CODE>,
atau apa pun file tar utama gunakan. (Harap dicatat bahwa variabel ``$''
di sini adalah bukan variabel yang nyata yang tersedia di bawah file spesifikasi.
Mereka sesungguhnya digunakan di tempat nama sampel. Anda perlu menggunakan
nama asli dan versi dalam paket anda, bukan sebuah variabel.)
</LI>
<LI><CODE>-c</CODE> akan membuat dan melakukan cd kepada direktori bernama sebelum mengerjakan
proses untar.
</LI>
<LI><CODE>-b</CODE> akan melakukan untar Source# sebelum berpindah direktori
ke dalamnya (dan ini membuat tak berlaku dengan -c karena itu jangan kerjakan
ini). Ini hanya berguna untuk paket yang mempunyai <EM>source</EM> banyak.
</LI>
<LI><CODE>-a</CODE> # akan melakukan untar Source# sesudah berpindah
ke direktorinya.
</LI>
<LI><CODE>-T</CODE> pilihan ini melakukan overrides aksi standar dari proses untarring
<EM>source</EM> dan memerlukan pilihan -b 0 atau -a 0 untuk mendapatkan file
<EM>source</EM> utama dikenai proses untar. Anda memerlukannya saat ada <EM>source</EM>
kedua.
</LI>
<LI><CODE>-D</CODE> Jangan menghapus direktori sebelum unpacking. Ini hanya berguna
di mana anda mempunyai lebih dari satu makro setup. Ini seharusnya digunakan
dalam makro setup sesudah yang pertama (tetapi jangan pernah di makro yang
pertama). </LI>
</UL>
<P>
<P>Makro berikutnya yang tersedia adalah makro <CODE>%patch</CODE>. Makro ini membantu
mengotomatiskan proses penerapan <EM>patch </EM>ke <EM>source</EM>. Makro ini
memerlukan beberapa pilihan, diperlihatkan di bawah ini :
<P>
<UL>
<LI><CODE>#</CODE>; akan menerapkan Patch# sebagai file penambal (<EM>patch</EM>).
</LI>
<LI><CODE>-p #</CODE>; memerinci sejumlah direktori untuk dibuka untuk perintah
patch(1).
</LI>
<LI><CODE>-P</CODE> Aksi standarnya adalah menerapkan Patch (atau Patch0). Tanda ini
menahan aksi standar dan akan memerlukan sebuah 0 untuk mendapatkan file
<EM>source</EM> utama di-untar. Pilihan ini berguna dalam sedetik atau lebih
makro <EM>patch</EM> yang memerlukan sebuah nomor berbeda dibandingkan dengan
makro pertama.
</LI>
<LI>Anda dapat juga mengerjakan <CODE>%patch#</CODE> sebagai ganti
dari mengetik perintah asli: <CODE>%patch # -P</CODE></LI>
</UL>
<P>
<P>Itu seharusnya adalah semua makro yang anda perlukan. Setelah anda meyakinkan
semuanya benar, anda dapat juga mengerjakan setup yang lain yang anda perlukan
untuk dikerjakan via script bertipe <CODE>sh</CODE>. Apa pun yang anda sertakan sampai
makro %build (didiskusikan dalam bagian berikutnya) adalah menjalankannya
via sh. Lihat contoh di atas untuk ketikan dari sesuatu yang anda mungkin
inginkan untuk dikerjakan di sini.
<P>
<H2><A NAME="ss6.5">6.5 Membangun (Build)</A>
</H2>

<P>Pada dasarnya tak ada makro apa pun untuk bagian ini. Anda seharusnya
hanya meletakkan perintah apa pun di sini yang akan anda pakai untuk membangun
perangkat lunak, sekali anda melakukan untar <EM>source</EM>nya, menambalnya
dan melakukan cd ke dalam direktori. Ini hanyalah set perintah yang lain
yang dilewatkan ke sh, sehingga perintah sah (legal) apa pun dapat pergi
ke sini (termasuk komentar). Direktori kerja anda saat ini di-reset dalam
setiap bagian ini ke tingkat atas dari direktori sumber, jadi ingatlah
itu baik-baik. Anda dapat melakukan cd ke dalam subdirektori bila diperlukan.
<P>
<H2><A NAME="ss6.6">6.6 Memasang (<EM>Install</EM>)</A>
</H2>

<P>Sebenarnya tak ada makro apa pun di sini. Anda hanya ingin meletakkan
perintah apa pun di sini yang diperlukan untuk meng<EM>install</EM>. Bila
anda punya 'make install' tersedia untuk anda dalam paket yang anda bangun,
letakkan itu di sini. Bila tidak, anda dapat menambal makefile untuk sebuah
make install dan hanya mengerjakan sebuah 'make install' di sini, atau
anda dapat meng<EM>install</EM> mereka secara manual dengan perintah sh.
Anda dapat mempertimbangkan direktori anda saat ini untuk menjadi tingkat
atas dari direktori <EM>source</EM>.
<P>
<H2><A NAME="ss6.7">6.7 Pilihan Script <EM>Install</EM>/<EM>Uninstall</EM> pre dan post</A>
</H2>

<P>Anda dapat membuat script dijalankan sebelum dan sesudah instalasi dan
uninstalasi dari paket biner. Sebuah alasan utama untuk itu adalah mengerjakan
sesuatu seperti menjalankan ldconfig setelah instalasi atau memindahkan
paket yang berisikan libraries / kepustakaan yang dipakai bersama (<EM>shared</EM>).
Makro untuk setiap script adalah sebagai berikut :
<P>
<UL>
<LI><CODE>%pre</CODE> adalah makro untuk mengerjakan script pre-install.</LI>
<LI><CODE>%post</CODE> adalah makro untuk mengerjakan script post-install.</LI>
<LI><CODE>%preun</CODE> adalah makro untuk mengerjakan script pre-uninstall.</LI>
<LI><CODE>%postun</CODE> adalah makro untuk mengerjakan script post-uninstall.</LI>
</UL>
<P>
<P>Isi dari bagian ini seharusnya hanyalah beberapa bentuk dari script,
meski anda tidak membutuhkan <CODE>#!/bin/sh</CODE>.
<P>
<H2><A NAME="ss6.8">6.8 File-file</A>
</H2>

<P>Ini adalah bagian di mana anda harus melihat file-file paket biner.
RPM tak punya cara lain untuk mengetahui file biner apa yang sudah di<EM>install</EM>
sebagai hasil dari make install. Ada jalan untuk mengetahuinya. Beberapa
menyarankan untuk melakukan find sebelum dan sesudah paket di<EM>install</EM>.
Dengan sistem <EM>multiuser</EM> (banyak pemakai), ini tak dapat diterima
seperti file lain mungkin telah dibuat selama sebuah proses pembangunan
paket yang menyebabkan tak ada yang dikerjakan dengan paket itu sendiri.
<P>
<P>Ada beberapa makro tersedia untuk mengerjakan beberapa hal yang istimewa.
Mereka terdaftar dan digambarkan di sini :
<P>
<UL>
<LI><CODE>%doc</CODE> digunakan untuk menandai dokumentasi dalam paket <EM>source</EM>
yang anda ingin <EM>install</EM> di dalam instalasi biner. Dokumen akan dipasang
dalam /usr/doc/$NAME-$VERSION-$RELEASE.
Anda dapat melihat banyak dokumen dengan perintah baris dengan makro ini,
atau anda dapat melihatnya semua secara terpisah dengan menggunakan sebuah
makro untuk setiap dokumennya.</LI>
<LI><CODE>%config</CODE> digunakan untuk menandai file konfigurasi dalam
sebuah paket. Ini menyertakan file seperti sendmail.cf, passwd, dll. Bila
anda kemudian melakukan <EM>uninstall</EM> sebuah paket berisikan file konfigurasi,
semua file yang tak berubah akan dihapus dan file yang berubah akan dipindahkan
ke nama lama mereka dengan sebuah .rpmsave ditambahkan ke nama file-nya.
Anda dapat melihat banyak file dengan makro ini.</LI>
<LI><CODE>%dir</CODE> menandai sebuah direktori tunggal dalam sebuah daftar
file untuk disertakan sebagaimana dimilki oleh sebuah paket. Standarnya,
bila anda melihat sebuah nama direktori TANPA sebuah makro %dir,
SEGALA SESUATU dalam direktori itu disertakan dalam daftar file dan kemudian
dipasang (<EM>installed</EM>) sebagai bagian dari paket itu. </LI>
<LI><CODE>%files -f &lt;filename&gt;</CODE> akan mengizinkan anda
untuk melihat file anda dalam beberapa file arbitrary di dalam direktori
pembangunan <EM>source</EM>.Ini menyenangkan dalam kasus di mana anda mempunyai
sebuah paket yang dapat membangun daftar file miliknya. Anda kemudian hanyalah
menyertakan daftar file di sini dan anda tidak harus mendaftarkan file
secara spesifik.</LI>
</UL>
<P>
<P>Keberatan terbesar dalam daftar file adalah daftar direktori-direktori.
Bila anda mendaftarkan <CODE>/usr/bin</CODE> secara tak sengaja, paket biner anda akan
berisi setiap file dalam <CODE>/usr/bin</CODE> di sistem anda.
<P>
<H2><A NAME="ss6.9">6.9 Cara membangunnya !</A>
</H2>

<H3>'Source' Pohon Direktori</H3>

<P>Pertama kali yang anda butuhkan adalah <EM>build tree </EM>yang terkonfigurasi
dengan benar. Ini dapat dikonfigurasi menggunakan file <CODE>/etc/rpmrc</CODE>. Sebagian
besar orang akan hanya menggunakan /usr/src.
<P>
<P>Anda mungkin memerlukan membuat direktori selanjutnya untuk membuat
sebuah <EM>build tree </EM>:
<P>
<UL>
<LI><CODE>BUILD</CODE> adalah direktori di mana semua proses pembangunan terjadi oleh
RPM. Anda tak harus mengerjakan test anda untuk dibangun di mana saja pada
khususnya, tetapi ini adalah di mana RPM akan mengerjakannya sendiri.</LI>
<LI><CODE>SOURCES</CODE> adalah direktori di mana anda seharusnya meletakkan file tar
<EM>source</EM> asli anda dan <EM>patch</EM> anda. Ini adalah tempat di mana
RPM akan mencari dalam keadaan standar.</LI>
<LI><CODE>SPECS</CODE> adalah direktori di mana semua file yang spesifikasi harus berada.</LI>
<LI><CODE>RPMS</CODE> adalah tempat di mana RPM akan meletakkan semua file biner RPM
saat proses pembangunan.</LI>
<LI><CODE>SRPMS</CODE> adalah tempat di mana semua <EM>source</EM> RPM akan diletakkan.</LI>
</UL>
<P>
<H3>Mengetes pembangunan</H3>

<P>Pertama kali yang anda mungkin akan inginkan adalah mengambil <EM>source</EM>
untuk membangun secara bersih tanpa RPM. Untuk mengerjakan ini, lakukan
'unpack' pada <EM>source</EM>, dan rubah nama direktori ke<CODE>$NAME.orig</CODE>.
Lalu lakukan 'unpack' pada <EM>source</EM> lagi. Gunakan <EM>source </EM>ini
untuk membangunnya. Pergilah ke dalam direktori <EM>source</EM> dan ikuti
instruksi untuk membangunnya. Bila anda harus menyunting sesuatu, anda
akan membutuhkan sebuah <EM>patch</EM>. Sekali anda memilihnya untuk dibangun,
bersihkan direktori <EM>source</EM>nya. Pastikan dan hapus file apa pun yang
diambil dari sebuah script <CODE>configure</CODE>. Lalu lakukan <CODE>cd</CODE> kembali, keluar
dari direktori <EM>source</EM> ke induknya. Kemudian anda akan mengerjakan
sesuatu seperti :
<P>
<BLOCKQUOTE><CODE>
<PRE>
diff -uNr dirname.orig dirname &gt;../SOURCES/dirname-linux.patch
</PRE>
</CODE></BLOCKQUOTE>
<P>Ini akan membuat sebuah <EM>patch</EM> untuk anda yang anda gunakan dalam
file spesifikasi anda. Catatan bahwa ``linux'' yang anda lihat dalam nama
<EM>patch </EM>adalah hanya sebuah identifier. Anda mungkin ingin menggunakan
sesuatu yang lebih bisa menggambarkan seperti ``config'' atau <EM>bugs</EM>
untuk menggambarkan mengapa anda harus membuat sebuah <EM>patch</EM>.
<P>Sebuah ide yang bagus juga untuk melihat file <EM>patch</EM> yang anda
buat sebelum menggunakannya untuk memastikan tak ada file biner yang terselip
secara tak sengaja.
<P>
<H3>Membuat Daftar File</H3>

<P>Sekarang, anda telah mempunyai <EM>source</EM> yang akan dibangun dan
tahu bagaimana mengerjakannya, membangunnya, dan memasangnya. Lihatlah
keluaran dari urutan pemasangan dan membangun daftar file anda dari hal
itu untuk digunakan dalam file spesifikasi. Kami pada umumnya membangun
file spesifikasi secara paralel dengan semua langkah ini. Anda dapat membuat
salah satu inisial dan mengisinya ke dalam bagian yang mudah, dan lalu
mengisikan ke dalam langkah lain sebagaimana anda lakukan.
<P>
<H3>Membangun sebuah Paket dengan RPM</H3>

<P>Sekali anda punya sebuah file spesifikasi, anda siap untuk mencoba dan
membangun paket anda. Cara yang paling bermanfaat untuk mengerjakan ini
adalah dengan sebuah perintah seperti :
<P>
<BLOCKQUOTE><CODE>
<PRE>
rpm -ba foobar-1.0.spec
</PRE>
</CODE></BLOCKQUOTE>
<P>Ada pilihan lain yang berguna dengan switch <CODE>-b</CODE> seperti :
<P>
<UL>
<LI><CODE>p</CODE> berarti kerjakan bagian persiapan dari file spesifikasi.</LI>
<LI><CODE>l</CODE> adalah sebuah cek daftar yang mengerjakan beberapa pengecekan atas
<CODE>%files</CODE>.</LI>
<LI><CODE>c</CODE> mengerjakan prep dan compile. Ini berguna manakala anda tak yakin
kalau-kalau <EM>source</EM> akan dibangun seluruhnya. Kelihatannya tak berguna
karena anda mungkin ingin 'memainkan' <EM>source</EM>nya sendiri sampai ia
dibangun dan kemudian memulai menggunakan RPM, tetapi sekali anda menjadi
terbiasa menggunakan RPM, anda akan menemukan kemudahan dalam menggunakannya.</LI>
<LI><CODE>i</CODE> mengerjakan persiapan, kompilasi dan instalasi.</LI>
<LI><CODE>b</CODE> persiapan, kompilasi, instalasi dan membangun sebuah paket biner
saja.</LI>
<LI><CODE>a</CODE> membangun seluruhnya (baik <EM>source</EM> dan paket binernya).</LI>
</UL>
<P>
<P>Ada beberapa modifier dalam switch <CODE>-b</CODE>, yaitu :
<P>
<UL>
<LI><CODE>--short-circuit</CODE> akan melompat langsung ke tahap yang telah ditentukan
(hanya dapat digunakan dengan c dan i).</LI>
<LI><CODE>--clean</CODE> menghapus bangunan pohon saat usai.</LI>
<LI><CODE>--keep-temps</CODE> akan mengamankan semua file temporer dan script yang dibuat
dalam /tmp. Anda sesungguhnya dapat melihat file-file apa yang dibuat dalam
/tmp menggunakan option <CODE>-v</CODE>.</LI>
<LI><CODE>--test</CODE> tidak menjalankan tingkat yang sebenarnya, tetapi tetap mengamankan
-temp.</LI>
</UL>
<P>
<H2><A NAME="ss6.10">6.10 Pengetesan</A>
</H2>

<P>Sekali anda telah memiliki sebuah rpm <EM>source</EM> dan biner untuk
paket anda, anda perlu mengetesnya. Cara paling mudah dan terbaik adalah
menggunakan mesin yang benar-benar berbeda dari seseorang di mana anda
membangun di atasnya dalam rangka mengetes. Sesudah itu, anda hanya harus
mengerjakan make install di mesin anda sendiri, sehingga seharusnya ia
sudah terpasang dengan cukup baik. 
<P>
<P>Anda dapat mengetik <CODE>rpm -u namapaket</CODE> atas sebuah paket untuk
mengetesnya, tetapi cara itu tidak dapat dipercaya, karena dalam membangun
sebuah paket, anda telah mengerjakan <CODE>make install</CODE>. Bila anda meninggalkan
sesuatu di luar daftar file anda, ia tidak akan di-<EM>uninstall</EM>. Anda
akan kemudian meng<EM>install</EM> ulang paket biner dan sistem anda akan
menjadi lengkap lagi, tetapi rpm anda masih belum lengkap. Pastikan dan
ingat-ingat bahwa hanya karena anda melakukan <CODE>rpm -ba namapaket</CODE>,
kebanyakan orang memasang paket anda akan hanya mengerjakan <CODE>rpm -i
namapaket</CODE>. Patikan anda tidak mengerjakan apa pun dalam bagian pemasangan
atau <EM>install</EM> yang akan diperlukan untuk dikerjakan saat binernya
terpasang secara otomatis.
<P>
<H2><A NAME="ss6.11">6.11 Apa dapat yang dikerjakan dengan RPM baru anda</A>
</H2>

<P>Sekali anda telah membuat RPM anda sendiri atas sesuatu (diasumsikan
sesuatu yang belum pernah di-RPM-kan), anda dapat melakukan kontribusi
pekerjaan anda ke yang lain (juga diasumsikan anda me-RPM-kan sesuatu yang
didistribusikan dengan bebas). Untuk mengerjakan itu, anda ingin melakukan
upload paketnya ke 
<A HREF="ftp://ftp.redhat.com">ftp://ftp.redhat.com</A><P>
<H2><A NAME="ss6.12">6.12 Sekarang Mau Apa Lagi?</A>
</H2>

<P>Silakan lihat bagian di atas dalam Pengetesan
dan Apa yang dikerjakan dengan RPM baru anda.
Kami ingin semua ketersediaan RPM dapat kami ambil, dan kami ingin 'mereka'
menjadi RPM yang baik. Silakan ambil waktu untuk mengetes mereka sebaik
mungkin, dan kemudian ambil waktu untuk meng-uploadnya untuk keuntungan
semua orang. Juga, silakan memastikan anda hanya melakukan upload perngkat
lunak yang tersedia dengan gratis. Perangkat lunak komersial dan shareware
tak seharusnya di-upload kecuali mereka punya hak cipta dan dinyatakan
bahwa hal ini diizinkan. Ini termasuk perangkat lunak dari Netscape, ssh,
pgp, dll.
<P>
<HR>
<A HREF="ID-RPM-HOWTO-7.html">Next</A>
<A HREF="ID-RPM-HOWTO-5.html">Previous</A>
<A HREF="ID-RPM-HOWTO.html#toc6">Contents</A>
</BODY>
</HTML>
