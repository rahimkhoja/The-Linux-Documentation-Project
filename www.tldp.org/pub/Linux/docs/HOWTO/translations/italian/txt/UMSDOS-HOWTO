  Linux UMSDOS HOW-TO
  Jacques Gelinas, jacques@solucorp.qc.ca
  v1.1, 13 novembre 1995

  _U_m_s_d_o_s è un file system Linux. Esso provvede un'alternativa al
  filesystem _E_X_T_2. La proprietà principale consiste nel poter condi­
  videre facilmente i dati con _M_s_-_D_O_S utilizzando la stessa partizione.
  Questo documento spiega prima come usare Umsdos in configurazioni
  diverse, poi spiega queste operazioni e tenta di provvedere alcune
  informazioni per dare la possibilità di decidere se _U_m_s_d_o_s è una buona
  scelta (vedere ``Perché UMSDOS'' in fondo al documento).  Questo docu­
  mento è stato tradotto da Michele Dalla Sivestra,
  dalla@maya.dei.unipd.it, ultima revisione il 05/02/96.
  ______________________________________________________________________

  Indice Generale


  1. UMSDOS: Cos'è?
     1.1 Storia
     1.2 Disponibilità
     1.3 Distrizioni supportanti Umsdos
     1.4 Sito base
     1.5 Documentazione tecnica
     1.6 Chi lo scrisse

  2. Umsdos come partizione di root
     2.1 Il concetto di pseudo-root
     2.2 Cose da sapere sullo pseudo-root

  3. Vari aspetti sul funzionamento di Umsdos
     3.1 Opzioni di mount
     3.2 Impostare i parametri per la directory di root
     3.3 Swap o non swap

  4. Come avviare un sistema Umsdos
     4.1 Loadlin
     4.2 Da floppy
     4.3 LILO
     4.4 Come ottimizzare una partizione Umsdos
     4.5 Aspetti avanzati

  5. Principi base
     5.1 Introduzione
     5.2 Umsdos può sostituire il filesystem Ms-DOS.
     5.3 Promozione di directory
     5.4 Come promuovere: /sbin/umssync
     5.5 Usare /sbin/umssync all'avvio
     5.6 Come UN-promuovere
     5.7 Cosa succede con i file creati durente una sessione DOS?

  6. Installazione/Disinstallazione e alcuni trucchi
     6.1 Lo pseudo-root /mnt/linux
     6.2 Preparare /mnt/linux
     6.3 Come assicurarsi che /mnt/linux sia impostata correttamente
     6.4 Oops releasing pseudo root...
     6.5 Come disinstallare un sistema Umsdos
     6.6 Spostare un sistema Umsdos in altri dischi DOS
     6.7 Come installare più sistemi Umsdos.

  7. Impostare una sezione Linux in una partizione DOS
  8. Perché UMSDOS
     8.1 Il vantaggio di Umsdos
     8.2 A chi serve
     8.3 Conclusioni

  ______________________________________________________________________

  11..  UUMMSSDDOOSS:: CCooss''èè??



  11..11..  SSttoorriiaa


  Il progetto _U_m_s_d_o_s fu iniziato nel 1992 e reso disponibile in rete nel
  gennaio 1994 come patch. Esso fu incluso nella distribuzione standard
  del kernel in luglio, partendo dal kernel 1.1.36.

  _U_m_s_d_o_s fu poi adottato nella distribuzione _S_l_a_c_k_w_a_r_e anche se non era
  ancora ufficialmente incluso nel kernel.

  _U_m_s_d_o_s fu migliorato dal kernel 1.1.60. Le sue performance sono state
  notevolmente potenziate, specialmente in scrittura. Dalla versione
  1.1.70 è abbastanza stabile.

  L'errore più grosso fu risolto in _L_i_n_u_x 1.2.2. Questo bug causava
  angoscia agli utenti (alcuni file venivano silenziosamente rinominati,
  dando l'impressione che fossero eliminati). Attenzione che la
  _S_l_a_c_k_w_a_r_e 2.2 ha la release del kernel 1.2.1, per cui ha ancora questo
  bug.


  11..22..  DDiissppoonniibbiilliittàà


  Esso è disponibile come patch per il kernel 1.0.x. È compreso con il
  kernel 1.2. Esso può essere compilato o caricato come modulo.
  Attenzione: se si intende caricare _U_m_s_d_o_s come modulo, si deve usare
  anche il fs Ms-DOS come modulo. Questo viene da una limitazione nel
  sistema dei moduli (alcuni simboli sono solo esportati quando i driver
  sono installati come moduli).


  11..33..  DDiissttrriizziioonnii ssuuppppoorrttaannttii UUmmssddooss


  Penso che solo _S_l_a_c_k_w_a_r_e supporti umsdos. Potrei sbagliarmi, quindi
  mandatemi informazioni per correggere questo.


  11..44..  SSiittoo bbaassee


  L'home site di _U_m_s_d_o_s è sunsite.unc.edu. Vedere nella directory
  /pub/Linux/system/Filesystems/umsdos.


  11..55..  DDooccuummeennttaazziioonnee tteeccnniiccaa


  C'è abbastanza documentazione sulle caratteristiche interne di _U_m_s_d_o_s.
  È disponibile sia in formato HTML e sia testo insieme ai file di
  utilità.

  Per quello che so, la versione HTML non è ancora disponibile in linea
  su un sito web. È necessario scaricarla, separare i file (un-tar) e
  leggerla localmente.



  11..66..  CChhii lloo ssccrriissssee


  Jacques Gelinas, jacques@solucorp.qc.ca.


  22..  UUmmssddooss ccoommee ppaarrttiizziioonnee ddii rroooott



  22..11..  IIll ccoonncceettttoo ddii ppsseeuuddoo--rroooott


  Con _U_m_s_d_o_s, _L_i_n_u_x può essere installato in una partizione standard
  DOS. _L_i_n_u_x è installato come secondo (o terzo) S. O. della partizione.
  Per evitare collisioni nei nomi (potrebbe esserci già una directory
  bin o tmp nel drive C:), _U_m_s_d_o_s usa un piccolo trucco: lo pseudo-root.

  Tutti i file _L_i_n_u_x sono installati in una sottodirectory DOS chiamata
  linux, generalmente C:\LINUX. La normale struttura directory
  _L_i_n_u_x_/_U_n_i_x finisce lì. Così si ha


  ·

     C:\LINUX\BIN



  ·

     C:\LINUX\ETC



  ·

     C:\LINUX\LIB



  ·

     C:\LINUX\ROOT



  ·

     C:\LINUX\SBIN



  ·

     C:\LINUX\TMP



  ·

     C:\LINUX\USR



  ·

     C:\LINUX\VAR



  Quando si avvia _U_m_s_d_o_s, esso esplora se esiste la directory linux e
  poi /linux/etc. Se esistono, viene attivata la modalità pseudo-root.

  Generalmente, la modalità pseudo-root imposta la partizione di root a
  C:\LINUX dando l'aspetto convenzionale delle directory di _U_n_i_x.


  ·

     /bin



  ·

     /etc



  ·

     /lib



  ·

     /root



  ·

     /sbin



  ·

     /tmp



  ·

     /usr



  ·

     /var



  A questa lista ne viene aggiunta una nuova chiamata DOS. Questa è una
  directory virtuale.



  22..22..  CCoossee ddaa ssaappeerree ssuulllloo ppsseeuuddoo--rroooott



  ·  Questa modalità può essere commutata solamente all'avvio. Non c'è
     modo per attivarla con un comando mount.

  ·  Questo meccanismo è solamente una visione diversa di un normale
     filesystem _U_m_s_d_o_s. Questo significa che una partizione normalmente
     usata come partizione di root può essere montata normalmente. Non
     c'è nessun effetto pseudo-root.

     Per esempio, se si avvia Linux con un disco di manutenzione e si
     monta la partizione di root in /mnt, si troveranno tutte le
     directory di Linux in /mnt/linux/bin, /mnt/linux/etc e così via.



  33..  VVaarrii aassppeettttii ssuull ffuunnzziioonnaammeennttoo ddii UUmmssddooss



  33..11..  OOppzziioonnii ddii mmoouunntt


  Si possono usare le stesse opzioni di mount come per i filesystem Ms-
  DOS.  L'opzione conv= è ambigua su un sistema _U_m_s_d_o_s. Suggerisco di
  evitarla. Generalmente le opzioni da guardare sono


  ·  uid=

  ·  gid=

  ·  umask=

  Ricordarsi che la gestione _U_m_s_d_o_s non promuove le directory nello
  stesso modo dei filesystem _M_s_-_D_O_S. Le opzioni precedenti sono
  applicate globalmente a tutte le directory non promosse. _u_i_d imposta
  il proprietario di default, _g_i_d imposta il gruppo di default e _u_m_a_s_k
  imposta i permessi di default.


  33..22..  IImmppoossttaarree ii ppaarraammeettrrii ppeerr llaa ddiirreeccttoorryy ddii rroooott


  umssetup fu creato per impostare durante il funzionamento il
  proprietario della partizione di root. Per altre partizioni _U_m_s_d_o_s si
  possono usare le opzioni di mount oppure umssetup. Il modo migliore
  per le partizioni non di root è di mettere le opzini in /etc/fstab.
  Qui c'è un esempio. Mettete questo in /etc/rc.d/rc.S.



       /sbin/umssetup -u jack -g group -m 0755 /



  33..33..  SSwwaapp oo nnoonn sswwaapp


  Usare un file di swap è generalmente più lento di una partizione di
  swap. Esso è comunque molto più flessibile. Si può impostare un file
  di swap in una partizione _U_m_s_d_o_s nello stesso modo con cui lo si fa
  con ogni altro filesystem _L_i_n_u_x. Per esempio, per impostare un file di
  swap da 8 Mb nella directory di root:



       dd if=/dev/zero bs=1024k count=8 of=/swap
       mkswap /swap 8192
       sync
       swapon /swap



  Fatto questo, inserire la linea seguente in /etc/fstab



       /swap   swap    swap    default



  E il file di swap verrà attivato ad ogni avvio (generalmente c'è un
  ``swapon -a'' in /etc/rc.d/rc.S).


  44..  CCoommee aavvvviiaarree uunn ssiisstteemmaa UUmmssddooss



  44..11..  LLooaaddlliinn


  Il pacchetto lodlin15.tgz disponibile a sunsite.unc.edu in
  /pub/Linux/system/Bootutils. Questa utility è adatta per avviare un
  sistema _U_m_s_d_o_s. Generalmente tutto quello che bisogna fare è



       Avviare DOS
       C:\>loadlinx zimage root=D:



  dove zimage è una normale immagine kernel (compressa) semplicemente
  copiata nel drive DOS. D: è il drive DOS dove è stato installato
  _L_i_n_u_x.


  44..22..  DDaa ffllooppppyy


  Avviare un sistema _U_m_s_d_o_s da floppy non è diverso da avviare un
  sistema _E_x_t_2. È necessaria un'immagine del kernel configurata per
  localizzare la partizione _U_m_s_d_o_s di root. Questo viene fatto
  normalmente usando il comando rdev. La seguente sequenza inizializza
  un'immagine e la mette su un floppy.



       rdev zImage /dev/hda1
       rdev -R zImage 0
       dd if=zImage bs=8192 of=/dev/fd0


  Se questo sembra confuso, formattare un disco di avvio DOS e mettere
  in esso i seguenti file


  ·  loadlin.exe

  ·  loadlinx.exe

  ·  zimage

  e impostare l'autoexec.bat come questo



       loadlinx zimage rw root=C:



  44..33..  LLIILLOO


  LILO, il caricatore ufficiale di _L_i_n_u_x può anche essere usato
  all'avvio di un sistema _U_m_s_d_o_s. Comunque non ho esperienza con questo.
  Dal 1.1.60 dovrebbe funzionare. Scrivetemi una email se sapete
  qualcosa.


  44..44..  CCoommee oottttiimmiizzzzaarree uunnaa ppaarrttiizziioonnee UUmmssddooss


  Può essere fatto usando un qualsiasi strumento DOS. Non c'è niente di
  particolare sui file prodotti da _U_m_s_d_o_s. E _U_m_s_d_o_s non si aspetta
  niente di particolare (struttura directory, intestazioni directory...)
  dal filesystem sottostante.

  Da quello che so non ci sono strumenti _L_i_n_u_x per fare ciò.


  44..55..  AAssppeettttii aavvaannzzaattii


  _U_m_s_d_o_s si affida sul file --linux-.--- il quale si affida sulla
  directory _D_O_S. Alcuni utenti potrebbero voler provare un po'.
  L'utility udosctl inclusa nel pacchetto umsdos_progs (contenente
  umssync e umssetup) permette semplici operazioni sulle directory
  (liste, eliminazioni) indipendentemente dal file --linux-.--- e dalla
  directory _D_O_S.


  55..  PPrriinncciippii bbaassee



  55..11..  IInnttrroodduuzziioonnee


  _U_m_s_d_o_s mappa i file _L_i_n_u_x direttamente in file _M_s_-_D_O_S.  Questa è
  l'unica trasformazione. Il contenuto dei file non è assolutamente
  modificato. _U_m_s_d_o_s lavora solo sui nomi. Per file speciali (link e
  dispositivi per esempio) è introdotta una gestione speciale.

  Per ogni directory c'è un file chiamato --linux-.---.


  55..22..  UUmmssddooss  ppuuòò ssoossttiittuuiirree iill ffiilleessyysstteemm MMss--DDOOSS ..


  L'_U_m_s_d_o_s è un superset per usi generali del filesystem _M_s_-_D_O_S di
  Linux. In effetti questa capacità e flessibilità crea molta confusione
  su _U_m_s_d_o_s. Vediamo il perché. Provate a montare un floppy appena
  formattato _D_O_S come qui.



       mount -t umsdos /dev/fd0 /mnt



  E scrivere questo:



       ls / >/mnt/LONGFILENAME
       ls -l /mnt



  Si otterrà il seguente risultato



       -rwxr-xr-x   1 root     root          302 Apr 14 23:25 longfile



  Sembra che il filesystem _U_m_s_d_o_s non sia molto di più (in realtà non
  proprio) del normale filesystem  _M_s_-_D_O_S di _L_i_n_u_x.


  55..33..  PPrroommoozziioonnee ddii ddiirreeccttoorryy


  Qui sta il trucco. Finché non si promuove una directory _D_O_S, essa
  verrà gestita allo stesso modo sia dal filesystem _M_s_-_D_O_S che dal
  filesystem _U_m_s_d_o_s. _U_m_s_d_o_s usa uno speciale file in ogni subdirectory
  per registrare le traduzioni tra le capacità estese (nomi lunghi,
  proprietari ecc.) del filesystem _U_m_s_d_o_s e i limiti di _M_s_-_D_O_S. Questo
  file è invisibile agli utenti _U_m_s_d_o_s, ma visibile quando si avvia _D_O_S.
  Per evitare di ingombrare la partizione _D_O_S con questi file
  (--linux-.---) non utilizzati, il file è ora opzionale. Se assente,
  _U_m_s_d_o_s diventa simile a _M_s_-_D_O_S.

  Quando una directory è promossa, ogni operazione verrà fatta con la
  piena semantica normalmente disponibile agli utenti _U_n_i_x e _L_i_n_u_x. E
  tutte le subdirectory create successivamente saranno silenziosamente
  promosse.

  Questa caratteristica permette di organizzare logicamente la
  partizione _D_O_S in zone _D_O_S e zone _L_i_n_u_x. È importante capire che
  questi file --linux-.--- occupano spazio (generalmente 2k per
  directory). Il _D_O_S generalmente usa cluster larghi (grandi 16k per
  partizioni da 500 Mb), quindi evitare di mettere --linux-.--- ovunque
  permette di guadagnare spazio.



  55..44..  CCoommee pprroommuuoovveerree:: //ssbbiinn//uummssssyynncc


  Una directory può essere promossa in ogni momento usando
  /sbin/umssync. Promuovere una directory significa fare le seguenti
  operazioni


  ·  Creare un --linux-.---.

  ·  Stabilire una relazione tra --linux-.--- e l'attuale contenuto
     della directory.

  /sbin/umssync mantiene un esistente file --linux-.---. Non lo crea da
  zero ogni volta. Semplicemente aggiunge le informazioni mancanti (file
  creati durante una sessione _D_O_S). Esso rimuove anche i file che non
  esistono più nella directory _D_O_S da --linux-.---.  umssync prende il
  nome da questo. Esso sincronizza --linux-.--- con la sottostante
  directory _D_O_S.


  55..55..  UUssaarree //ssbbiinn//uummssssyynncc  aallll''aavvvviioo


  È una buona idea mettere una chiamata a /sbin/umssync alla fine del
  file /etc/rc.d/rc.S se non c'è già. Il comando seguente è adeguato per
  molti sistemi:



       /sbin/umssync -r99 -c -i+ /



  L'opzione -c previene umssync dal promuovere directory. Esso aggiorna
  solamente i --linux-.--- esistenti.

  Questo comando è utile se si accede alla directory _L_i_n_u_x durante una
  sessione _D_O_S. _L_i_n_u_x non ha mezzi efficienti per capire che una
  directory è stata modificata da _D_O_S, così _U_m_s_d_o_s non può fare
  l'operazione _u_m_s_s_y_n_c quando necessario.


  55..66..  CCoommee UUNN--pprroommuuoovveerree


  Rimuovere il file --linux-.--- usando il _D_O_S. Tutto qui.


  55..77..  CCoossaa ssuucccceeddee ccoonn ii ffiillee ccrreeaattii dduurreennttee uunnaa sseessssiioonnee DDOOSS ??


  Finché non si usa umssync su una directory dove i file sono stati
  aggiunti o rimossi da _D_O_S, si noteranno alcuni problemi:


  ·  Non va in crash e nemmeno crea problemi maggiori, soltanto alcune
     noie.

  ·  I file creati da _D_O_S

     ·  sono invisibili in _L_i_n_u_x;

     ·  quando si crea un file con lo stesso nome si otterrà un
        messaggio di errore indicante che il file esiste già;
     ·  questo crea più confusione che problemi reali. Non viene
        danneggiato il filesystem.


  ·  I file eliminati da _D_O_S non creano problemi. _U_m_s_d_o_s noterà
     l'assenza al primo accesso. Verrà stampato un messaggio (e
     generalmente riportato in /var/adm/syslog).


  66..  IInnssttaallllaazziioonnee//DDiissiinnssttaallllaazziioonnee ee aallccuunnii ttrruucccchhii


  L'installazione di _U_m_s_d_o_s non è molto diversa dall'installazione di un
  filesystem ordinario (es. _E_x_t_2) _L_i_n_u_x.

  Ci sono due principali differenze.


  66..11..  LLoo ppsseeuuddoo--rroooott //mmnntt//lliinnuuxx


  La normale sequenza di operazioni per l'installazione è


  1. Impostare una partizione con fdisk e formattarla.

  2. Montarla come /mnt relativa al root disk di installazione.

  3. Copiare tutti i pacchetti in /mnt

  Con _U_m_s_d_o_s, il primo passo non è richiesto (non è lo scopo di _U_m_s_d_o_s
  il non dover formattare?).

  È possibile installare un sistema _U_m_s_d_o_s semplicemente copiando tutti
  i pacchetti in /mnt. Questo certamente funziona. Ma questo creerà una
  marea di subdirectory nella root directory _D_O_S (C:\) e non è quello
  che si vorrebbe. Questa è la ragione per cui tutte le installazioni
  _U_m_s_d_o_s usano lo pseudo-root. E questa è la maggior differenza tra una
  normale installazione _E_x_t_2 e _U_m_s_d_o_s: tutti i file sono copiati in
  /mnt/linux.


  66..22..  PPrreeppaarraarree //mmnntt//lliinnuuxx


  /mnt/linux non è una directory ordinaria. Essa è stata promossa in
  modo da gestire correttamente i filename lunghi di _L_i_n_u_x e i file
  speciali (link, dispositivi). I passi richesti per impostare
  /mnt/linux sono:


  1. mkdir /mnt/linux

  2. umssync /mnt/linux

  È tutto!


  66..33..  CCoommee aassssiiccuurraarrssii cchhee //mmnntt//lliinnuuxx  ssiiaa iimmppoossttaattaa ccoorrrreettttaammeennttee


  Anche se l'impostazione di /mnt/linux è molto semplice, ci sono alcuni
  pacchetti di installazione che la sbagliano. Come è possibile?

  I maggiori problemi di installazione nascono da una incompatibilità
  del programma umssync. _U_m_s_d_o_s è stato aggiornato in Linux 1.1.88 (non
  ricordo esattamente) e una falla fu scoperta in umssync. Per evitare
  confusione nella comunità di _L_i_n_u_x, fu deciso di aumentare il livello
  richesto per tutti gli strumenti _U_m_s_d_o_s. Le versioni precedenti sono
  semplicemente rifiutate.

  Sembra che molte distribuzioni non abbiano aggiornato l'utility
  umssync nel loro disco di installazione.

  Ci sono molte distribuzioni come queste. Il risultato è che la
  directory /mnt/linux non è promossa, e quindi verranno troncati i nomi
  lunghi e rifiutati tutti i file speciali.

  È possibile fare un test all'inizio dell'installazione per vedere se
  qualcosa non va. Grazie al meccanismo della pseudo console di _L_i_n_u_x,
  si può farlo senza lasciare il programma di installazione. Fare i
  seguenti passi:


  1. Premere Alt-F2 (il tasto Alt e contemporaneamente il tasto F2).

  2. Loggarsi come root

  3. cd /mnt/linux

     Se questo fallisce, si sta facendo la prova troppo presto. Il
     momento migliore per farlo è alla fine della selezione dei
     pacchetti.

  4. >TOTO

  5. ls -l

     Si dovrebbe vedere un file vuoto TOTO in maiuscolo. Se lo si vede
     in minuscolo, qualcosa è andato storto. Provare a fare di nuovo
     umssync. umssync può essere usato tutte le volte che si vuole senza
     problemi.

     umssync .

     Se non ci sono messaggi di errore, provare il test TOTO di nuovo.
     Se TOTO appare, allora tutto è OK. A volte è un difetto di queste
     installazioni, ma è stato posto rimedio. Continuare.

  6. Premere Alt-F1 per tornare nella schermata di installazione.

  Se il test fallisce, il miglior rimedio è prelevare un nuovo disco di
  root per l'installazione. Si può generalmente riparare il disco di
  root installando una nuova versione di umssync. Questo non è
  difficile, ma richiede un sistema con _L_i_n_u_x funzionante. Si deve
  semplicemente montare il disco di root e sostituire il programma
  umssync con uno nuovo.


  66..44..  OOooppss rreelleeaassiinngg ppsseeuuddoo rroooott......


  Molte delle installazioni che falliscono, lo fanno stampando questo
  strano messaggio. Questo non è un bug di _U_m_s_d_o_s benché il il messaggio
  sembri strano. Queste sono le possibili cause.


  ·  Il più comune.

     L'installazione _S_l_a_c_k_w_a_r_e tenta di impostare un file di swap
     all'inizio dell'installazione. Per fare ciò chiede all'utente di
     selezionare una partizione (dos), quindi la monta ed imposta il
     file di swap.

     Quando si installa un sistema _S_l_a_c_k_w_a_r_e, è necessario impostare la
     partizione di destinazione prima di installare. Questo generalmente
     monta la partizione DOS in /mnt, crea /mnt/linux e vi applica
     umsssync.

     Questo è problema più comune: molti utenti dimenticano di impostare
     la partizione di destinazione (``target partition''), e vanno
     direttamente al resto dell'installazione. Siccome /mnt è già
     montata, questo errore passa inosservato. Questo fa sì che
     /mnt/linux non sia impostata correttamente (non promossa). Tutti i
     file speciali e nomi lunghi non possono essere creati in modo
     corretto.

  ·  Utility umssync non corretta.

     /mnt/linux è impostata erroneamente. Generalmente è causata da una
     utility umssync difettosa nel disco di installazione di root.

  ·  Vecchio bug di _U_m_s_d_o_s.

     C'è un bug in _U_m_s_d_o_s anteriore a _L_i_n_u_x _1_._2_._2. La modalità pseudo-
     root non viene attivata correttamente se il file /etc/init è
     assente. init è adesso localizzato in /sbin. Si può risolvere
     prelevando un nuovo kernel. Questo è raccomandato perché altri bug
     sono stati scoperti e risolti in 1.2.2.

     Se non è possibile l'aggiornamento, fare questo


     1. Avviare il disco di installazione.

     2. Loggarsi come root.

     3. mount -t umsdos /dev/hdXX /mnt

        dove /dev/hdXX è la partizione _D_O_S.

     4. cd /mnt/linux/etc

     5. ln -s ../sbin/init init

     6. cd /

     7. Ctrl-Alt-Canc

     8. Avviare _U_m_s_d_o_s normalmente.


  Sfortunatamente i primi due problemi (problemi di installazione)
  producono un'installazione completamente inutilizzabile. Disintallate
  (sezione successiva) e reinstallate di nuovo.



  66..55..  CCoommee ddiissiinnssttaallllaarree uunn ssiisstteemmaa UUmmssddooss


  Una cosa semplice di _U_m_s_d_o_s e il suo meccanismo di pseudo-root e che
  lo si può disinstallare senza problemi. Si deve semplicemente avviare
  _D_O_S ed eliminare ricorsivamente le directory linux. Questo è tutto.
  _U_m_s_d_o_s non richiede driver speciali nel config.sys, e non crea niente
  di speciale fuori dalla directory linux.


  66..66..  SSppoossttaarree uunn ssiisstteemmaa UUmmssddooss  iinn aallttrrii ddiisscchhii DDOOSS


  Questo può essere fatto da _L_i_n_u_x o da _D_O_S. Si devono copiare
  ricorsivamente le directory linux da un drive all'altro. Dopo di ciò
  si devono sistemare i meccanismi di avvio e il file /etc/fstab.

  _U_m_s_d_o_s può vivere in qualsiasi drive _D_O_S. Non è necessario installarlo
  nel drive C:, non è nemmeno importante averlo nel primo disco fisso.

  In effetti si può decidere di avere parecchie installazioni _U_m_s_d_o_s su
  drive diversi anche solo per eseguire prove.


  66..77..  CCoommee iinnssttaallllaarree ppiiùù ssiisstteemmii UUmmssddooss ..


  Come installare una serie di sistemi _L_i_n_u_x in poco tempo?

  I sistemi _U_m_s_d_o_s vivono nel mondo _D_O_S. Se ne possono quindi sfruttare
  i vantaggi se si vuole installare facilmente _L_i_n_u_x.

  Si può installare e configurare un sistema _U_m_s_d_o_s per conto proprio.
  Quando si è soddisfatti della configurazione e dei diversi pacchetti
  installati, si può avviare _D_O_S e copiare l'intera directory linux nel
  file server _D_O_S. Quindi si può andare in altre stazioni _D_O_S e copiare
  semplicemente i file dal disco di rete al disco locale. Tutto qui.
  Aggiornare solamente lo script di avvio (_L_o_a_d_l_i_n) e via.

  Con piccoli ritocchi (Hostname, indirizzo IP), chiunque riuscirà ad
  installare un sistema _L_i_n_u_x in pochi minuti.

  I lettori attenti potrebbero notare che installare un sistema _L_i_n_u_x
  copiando un sistema funzionante va bene anche per altri sistemi _L_i_n_u_x,
  compresi i sistemi basati su _E_x_t_2.

  Una cosa bella di _L_i_n_u_x è che non ci sono file nascosti che devono
  essere installati da particolari programmi di installazione.



  77..  IImmppoossttaarree uunnaa sseezziioonnee LLiinnuuxx  iinn uunnaa ppaarrttiizziioonnee DDOOSS


  _U_m_s_d_o_s può essere utile anche agli utenti _E_x_t_2 (il filesystem _L_i_n_u_x
  originale). Una situazione comune è questa:


  ·  _L_i_n_u_x diventa il sistema operativo di preferenza e la partizione di
     _L_i_n_u_x comincia ad essere piena.

  ·  La partizione _D_O_S accumula polvere, diventando mezza vuota.

  ·  Si finisce improvvisamente lo spazio nella partizione _E_x_t_2.

  ·  Non si è ancora sicuri di voler sbarazzarsi del _D_O_S.

  A questo punto arriva _U_m_s_d_o_s a salvare la situazione. Si può impostare
  una directory nella partizione _D_O_S e usarla senza restringerne l'uso
  per _L_i_n_u_x. Per esempio, diciamo di voler impostare una nuova directory
  chiamata "extra" nel drive C:. E si vuole che questa directory diventi
  una normale directory _L_i_n_u_x. Eseguire questo (assumiamo che C: sia
  /dev/hda1).



  mkdir /c
  /sbin/mount -t umsdos /dev/hda1 /c
  mkdir /c/extra
  umssync /c/extra



  Questo deve essere fatto con i privilegi di root.

  Impostando opportunamente /etc/fstab, si potrà sempre accedere alla
  directory /c/extra.



  88..  PPeerrcchhéé UUMMSSDDOOSS


  Spiegare come usare o installare un sistema _U_m_s_d_o_s non è abbastanza.
  Molta gente cerca informazioni circa l'uso di _U_m_s_d_o_s o no.


  88..11..  IIll vvaannttaaggggiioo ddii UUmmssddooss


  Il vantaggio di _U_m_s_d_o_s è di semplificare l'installazione di _L_i_n_u_x. Un
  altro vantaggio è la sua semplice disinstallazione.  L'idea di base
  era quella di promuovere la diffusione di _L_i_n_u_x.  L'installazione di
  un nuovo OS in un sistema è sempre dolorosa.  _O_S_/_2 per esempio
  contamina la directory root di C: con una serie di nuove directory. Se
  siete esperti come me, esso eliminerà anche i file config.sys e
  autoexec.bat.

  La caratteristica dello pseudo-root di _U_m_s_d_o_s evita questa invasione
  indesiderata. _L_i_n_u_x può essere disinstallato senza effetti secondari.


  88..22..  AA cchhii sseerrvvee


  Se si ha un piccolo disco fisso, _U_m_s_d_o_s permette di condividere lo
  spazio tra _D_O_S e _L_i_n_u_x. Un disco sotto i 300 Mb è a mio avviso in
  disco piccolo. Questa opinione si basa sulla dimensione dei diversi
  pacchetti disponibili oggi. Un comune word processor può occupare
  anche 70 Mb se si scelgono tutte le caratteristiche.

  Se si ha un drive grande, si può decidere di riservare una partizione
  a _L_i_n_u_x con il filesystem _E_x_t_2. _E_x_t_2 usa cluster di dimensione più
  piccola rispetto al _D_O_S (1k infatti), così installando molti file
  piccoli si spreca meno spazio che in una partizione _U_m_s_d_o_s.


  88..33..  CCoonncclluussiioonnii


  A questo punto confrontiamo _U_m_s_d_o_s con _E_x_t_2.


  ·  La gestione delle directory è più veloce con _E_x_t_2. Questo a causa
     della doppia struttura delle directory di _U_m_s_d_o_s.

  ·  L'accesso ai file (lettura e scrittura) è probabilmente più veloce
     con _U_m_s_d_o_s che con _E_x_t_2. Questo per la semplicità del filesystem
     _F_A_T usato dal _D_O_S.

     Attenzione che questa semplicità ha i suoi costi:
     ·  Un massimo di circa 65.000 file o cluster per partizione. Questo
        comporta che una partizione da 500 Mb userà cluster da 16 k. In
        altre parole, un file contenente un singolo byte userà 16 k di
        spazio su disco.

     ·  Tutto è controllato dalla _F_A_T localizzata all'inizio del disco
        fisso. Il filesystem _D_O_S è probabilmente più fragile a causa di
        questo.

     ·  Nessun provvedimento per evitare la frammentazione dei file. Un
        sistema _U_m_s_d_o_s è generalmente usato come stazione di lavoro per
        utente singolo. In questo caso non fa molta differenza. In un
        sistema multi-utente, i file vengono dispersi nel disco,
        diminuendo la velocità di accesso.

  ·  I link simbolici sono memorizzati in file normali. Se si intende
     averne tanti, si vedrà che _U_m_s_d_o_s usa molto più spazio confrontato
     con _E_x_t_2.



