<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>RedHat Linux KickStart HOWTO</TITLE>


</HEAD>
<BODY>
<H1>RedHat Linux KickStart HOWTO</H1>

<H2>Martin Hamilton <CODE>&lt;martinh@gnu.org&gt;</CODE>,
Vertaald door: Ellen Bokhorst <CODE>&lt;bokkie@nl.linux.org&gt;</CODE></H2>v0.2, 11 januari 1999
<P><HR>
<EM>In deze HOWTO wordt beknopt beschreven hoe het RedHat Linux
<EM>KickStart</EM> systeem te gebruiken om snel grote aantallen
identieke Linux boxen te installeren. Voor geavanceerde gebruikers
beschrijven we hoe de Kickstart installatieprocedure naar eigen
inzicht aan kan worden gepast en geven we een beknopte leidraad voor het
zelf samenstellen van RPM packages.</EM>
<HR>
<H2><A NAME="s1">1. Copyright</A></H2>

<P>Copyright (c) 1998 Martin Hamilton, Alle rechten gereserveerd. Dit is
vrije documentatie; je kunt het onder de voorwaarden van versie
2 of later van de 
<A HREF="http://www.gnu.org/copyleft/gpl.html">GNU General Public License</A> opnieuw distribueren en/of
aanpassen.
<H2><A NAME="s2">2. Homepage</A></H2>

<P>
<P>Als je aan dit document via een Linux HOWTO mirrorsite of een CD-ROM
bent gekomen, wil je wellicht de
<A HREF="http://wwwcache.ja.net/dev/kickstart/">KickStart HOWTO home page</A>
er nog op nazien of hier een nieuwere versie van in omloop is.
<H2><A NAME="s3">3. Introductie</A></H2>

<P>
<P>RedHat Linux versie 5 komt met een weinig bekend (en tot nu, niet 
erg gedocumenteerde) faciliteit genaamd
<EM>KickStart</EM>.  Hiermee kun je (bijna) alles van de RedHat Linux installatie
automatiseren, waaronder:
<P>
<UL>
<LI> Selecteren van de taal</LI>
<LI> Netwerkconfiguratie en selecteren van de distributiebron</LI>
<LI> Toetsenbordkeuze</LI>
<LI> Bootloader installatie (b.v. lilo)</LI>
<LI> Diskpartitionering en aanmaak bestandssysteem</LI>
<LI> Muiskeuze</LI>
<LI> X Window systeem serverconfiguratie</LI>
<LI> Keuze van de tijdszone</LI>
<LI> Keuze van een (initieel) root wachtwoord</LI>
<LI> Welke packages te installeren</LI>
</UL>
<P>Scherpzinnige RedHat gebruikers zullen zich inmiddels waarschijnlijk hebben
gerealiseerd dat dit in belangrijke mate de hoofdstappen zijn die een
handmatige installatie van een RedHat Linux systeem inhouden.
KickStart maakt het je mogelijk een script te schrijven voor het
reguliere installatieproces, door de informatie die je normaal gesproken
op het toetsenbord op zou geven in een configuratiebestand te plaatsen.
<P><EM>Maar wacht - er is meer :-)</EM>
<P>Na het normale installatieproces te hebben be&euml;indigd, laat KickStart
je ook een lijst specificeren met opdrachten op niveau van de shell die
je zou willen hebben uitgevoerd. Dit betekent dat je automatisch extra
lokale software kunt installeren die niet als onderdeel van RedHat Linux
wordt gedistribueerd (ja, er zijn zelfs meer vrij verkrijgbare 
softwareprogramma's dan datgene dat je bij de RedHat distributie krijgt.
Een aantal kunnen vanwege wettelijke gronden niet door RedHat worden
gedistribueerd, b.v. de <CODE>ssh</CODE> en <CODE>PGP</CODE> encryptie systemen). 
Mogelijk heb je die nodig voor een volledig functioneel besturingssysteem.
<H2><A NAME="s4">4. Eerste vereisten</A></H2>

<P>Er zijn twee benaderingen bij een KickStart installatie - &eacute;&eacute;n
daarvan is eenvoudigweg je KickStart configuratiebestand naar een RedHat
bootdiskette kopi&euml;ren. De andere is gebruik te maken van een
reguliere bootdiskette en je Kickstart configbestand via het netwerk
ophalen.
<P>In beiden gevallen heb je nodig:
<P>
<OL>
<LI> Intel (i386) klasse computers - waarmee KickStart alleen schijnt
te werken tijdens moment van schrijven.</LI>
<LI> KickStart configbestand - hier zullen we het in de volgende sectie
over hebben.</LI>
<LI> RedHat bootdisk - bij voorkeur uit de <EM>updates</EM>
directory, om voordeel te hebben van eventuele correcties/updates van drivers.</LI>
<LI> DNS records voor de IP-adressen die je zal gaan gebruiken - optioneel,
maar zal de installatie onderbreken doordat het je vraagt naar de 
domeinnaam van je computer.</LI>
</OL>
<P>Als je je configbestand over het netwerk op wilt halen, zal je het via
NFS moeten exporteren, dit is de enige toegangsmethode die op het moment
wordt ondersteund. Het configbestand laat je een andere NFS server specificeren
waar het de RedHat distributie zelf van ophaalt.
<P>Je kunt voor je computer een statisch IP-adres configureren - b.v. een speciaal
adres gereserveerd voor KickStart installaties. Als alternatief kun je
KickStart opgeven een BOOTP/DHCP server te gebruiken om het IP-adres op te
halen als je het niet als vaststaand adres in het configbestand wilt coderen.
Een aantal servers zal nieuwe adressen in een gegeven bereik automatisch
toewijzen, zoals b.v. 
<A HREF="ftp://ftp.ntplx.net/pub/networking/bootp">de CMU BOOTP server met dynamische adresseringsextensies</A>.
<P>Meer informatie over NFS en BOOTP/DHCP is te vinden in Appendix A.
<H2><A NAME="s5">5. Instellen van een bootdiskette</A></H2>

<P>
<P>In essentie is alles wat je moet doen je KickStart configbestand naar
<EM>/ks.cfg</EM> op de RedHat bootdiskette kopi&euml;ren, b.v.
<P>
<BLOCKQUOTE><CODE>
<PRE>
  mcopy ks.cfg a:
</PRE>
</CODE></BLOCKQUOTE>
<P>De RedHat bootdiskette is echter tamelijk vol, en wellicht bemerk je
dat je een aantal van de andere bestanden moet verwijderen om ruimte
te maken voor het KickStart configbestand. Het lukte mij voldoende ruimte
vrij te maken door de diverse berichtbestanden te verwijderen
die normaal gesproken worden weergegeven door de
<CODE>SYSLINUX</CODE> bootloader, b.v.
<P>
<BLOCKQUOTE><CODE>
<PRE>
  mdel a:\*.msg
</PRE>
</CODE></BLOCKQUOTE>
<P>Een andere benadering zou kunnen zijn de drivers voor een deel van de
hardware die je toch niet hebt weg te gooien, zie de sectie over het
aanpassen van de bootdiskette hieronder.
<P>Wellicht dat je ook <EM>syslinux.cfg</EM>, het <CODE>SYSLINUX</CODE>
configbestand wilt wijzigen. Ook deze is op de RedHat bootdiskette
in de top level directory terug te vinden.
De volgende <EM>syslinux.cfg</EM> bijvoorbeeld zal
er voor zorgen dat automatisch, zonder de normale onderbreking,
de KickStart mode wordt ingegaan als de computer opstart:
<P>
<BLOCKQUOTE><CODE>
<PRE>
  default ks
  prompt 0
  label ks
    kernel vmlinuz
    append ks=floppy initrd=initrd.img
</PRE>
</CODE></BLOCKQUOTE>
<P>Naar alle waarschijnlijkheid wil je je boot- en aanvullende diskettes
baseren op de meest recente diskimages die beschikbaar zijn in 
<EM>updates/i386</EM> op je lokale RedHat mirrorsite. Oudere images
kunnen fouten bevatten of bieden minder ondersteuning voor hardwaredrivers.
<H2><A NAME="s6">6. Het KickStart configbestand</A></H2>

<P>Het configbestand bestaat uit drie hoofdsecties:
<P>
<OL>
<LI>Systeem info, b.v. diskpartitionering en netwerkconfig</LI>
<LI>Te installeren RedHat packages</LI>
<LI>Post-installatie uit te voeren shellopdrachten</LI>
</OL>
<P>Er zijn nog een aantal andere mogelijkheden waar we het hier niet over
zullen hebben, maar die 
<B>wellicht</B> wel werken. Kijk voor meer informatie in het voorbeeld
KickStart config in <EM>misc/src/install/ks.samp</EM> en
<EM>doc/README.ks</EM> onder de top level <EM>i386</EM> RedHat
distributie directory op je CD-ROM of lokale RedHat mirror site.
<H2>6.1 Systeeminfo</H2>

<P>
<P>De beschikbare directives die ik heb gebruikt zijn:
<P>
<DL>
<DT><B>lang</B><DD><P>Taalconfiguratie, b.v. voor Engels
</DL>
<P>
<BLOCKQUOTE><CODE>
<PRE>
lang en
</PRE>
</CODE></BLOCKQUOTE>
<P>
<DL>
<DT><B>network</B><DD><P>Netwerkconfiguratie, b.v. gebruik van BOOTP/DHCP
</DL>
<P>
<BLOCKQUOTE><CODE>
<PRE>
network --bootp
</PRE>
</CODE></BLOCKQUOTE>
<P>
<DL>
<DT><B>nfs</B><DD><P>NFS server en directory van waaruit te installeren, b.v.
</DL>
<P>
<BLOCKQUOTE><CODE>
<PRE>
nfs --server chicken.swedish-chef.org /mnt/cdrom
</PRE>
</CODE></BLOCKQUOTE>
<P>om de NFS server <EM>chicken.swedish-chef.org</EM> te gebruiken en de
RedHat distributie vanuit de directory
<EM>/mnt/cdrom</EM> proberen te mounten.
<P>
<DL>
<DT><B>keyboard</B><DD><P>Selecteer type toetsenbord, b.v. voor UK toetsenborden
</DL>
<P>
<BLOCKQUOTE><CODE>
<PRE>
keyboard uk
</PRE>
</CODE></BLOCKQUOTE>
<P>
<DL>
<DT><B>zerombr</B><DD><P>Wis de Master Boot Record - verwijdert een eventueel
bestaande bootloader voor besturingssystemen op je disk
</DL>
<P>
<DL>
<DT><B>clearpart</B><DD><P>Wis bestaande partities - b.v. om alle bestaande
diskpartities voor de installatie te verwijderen.
</DL>
<P>
<BLOCKQUOTE><CODE>
<PRE>
clearpart --all
</PRE>
</CODE></BLOCKQUOTE>
<P>
<DL>
<DT><B>part</B><DD><P>Partitioneer de disk, b.v. voor het aanmaken van een
rootbestandssysteem van 500MB
</DL>
<P>
<BLOCKQUOTE><CODE>
<PRE>
part / --size 500
</PRE>
</CODE></BLOCKQUOTE>
<P>
<DL>
<DT><B>install</B><DD><P>Voor een nieuwe installatie van RedHat Linux.
</DL>
<P>
<DL>
<DT><B>mouse</B><DD><P>Stel de te gebruiken muis in, b.v. voor een PS/2 of compatibele 
"bus mouse"
</DL>
<P>
<BLOCKQUOTE><CODE>
<PRE>
mouse ps/2
</PRE>
</CODE></BLOCKQUOTE>
<P>
<DL>
<DT><B>timezone</B><DD><P>Stel de tijdszone in, b.v. voor de lokale tijd in de UK
</DL>
<P>
<BLOCKQUOTE><CODE>
<PRE>
timezone --utc Europe/London
</PRE>
</CODE></BLOCKQUOTE>
<P>
<DL>
<DT><B>rootpw</B><DD><P>Instelling van het initi&euml;le rootwachtwoord, afgeleid van
een eerder opgegeven versleuteld wachtwoord
</DL>
<P>
<BLOCKQUOTE><CODE>
<PRE>
rootpw --iscrypted XaacoeGPmf/A.
</PRE>
</CODE></BLOCKQUOTE>
<P>
<DL>
<DT><B>lilo</B><DD><P>Installeer de LILO bootloader, b.v. in de Master Boot Record
</DL>
<P>
<BLOCKQUOTE><CODE>
<PRE>
lilo --location mbr
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>
<DL>
<DT><B>/%packages</B><DD><P>Te installeren packages - zie hieronder.
</DL>
<P>
<DL>
<DT><B>%post</B><DD><P>Post-installatie shellopdrachten - zie hieronder.
</DL>
<P>De directory waar KickStart zoekt naar de RedHat distributie moet een
subdirectory <EM>RedHat</EM> bevatten, die de RedHat distributiestructuur
voor het platform in kwestie bevat. In het voorbeeld hiervoor, zouden we
bijvoorbeeld de volgende bestanden en directory's te zien moeten krijgen:
<P>
<BLOCKQUOTE><CODE>
<PRE>
/mnt/cdrom/RedHat
/mnt/cdrom/RedHat/base
/mnt/cdrom/RedHat/contents
/mnt/cdrom/RedHat/i386
/mnt/cdrom/RedHat/instimage
/mnt/cdrom/RedHat/RPMS
/mnt/cdrom/RPM-PGP-KEY
</PRE>
</CODE></BLOCKQUOTE>
<P>Als je vanaf een CD-ROM installeert in plaats van vanaf het netwerk,
dan ziet de inhoud er ongeveer zo uit:
<P>
<BLOCKQUOTE><CODE>
<PRE>
RedHat
RedHat/base
RedHat/contents
RedHat/i386
RedHat/instimage
RedHat/RPMS
RPM-PGP-KEY
</PRE>
</CODE></BLOCKQUOTE>
<P>Als je de RedHat distributie hebt voor meerdere architecturen (b.v.
op een NFS server - zijn ze te groot om meer dan &eacute;&eacute;n
versie van een architectuur op een enkele CD-ROM te passen), zal je
bemerken dat iedere distributie dezelfde bestanden en directory's
onder een subdirectory heeft, b.v.
<P>
<BLOCKQUOTE><CODE>
<PRE>
alpha/RPM-PGP-KEY
i386/RPM-PGP-KEY
sparc/RPM-PGP-KEY
</PRE>
</CODE></BLOCKQUOTE>
<P>Er zou een bestand <CODE>architecture</CODE>/Redhat/<CODE>architecture</CODE>
moeten zijn, b.v. <EM>i386/Redhat/i386</EM>.
<P>Met Perl is het heel eenvoudig als je je eigen versleutelde wachtwoorden
wilt aanmaken, b.v.
<P>
<BLOCKQUOTE><CODE>
<PRE>
% perl -e 'print crypt("schmurrdegurr", "Xa") . "\n";'p
</PRE>
</CODE></BLOCKQUOTE>
<P>Andere opties (of niet ter sprake gebrachte opties) die ik niet heb geprobeerd:
<P>
<P>
<DL>
<DT><B>cdrom</B><DD><P>Installeer vanaf CD-ROM in plaats van vanaf het netwerk.
</DL>
<P>
<DL>
<DT><B>device</B><DD><P>Expliciete declaratie van details, b.v.
</DL>
<P>
<BLOCKQUOTE><CODE>
<PRE>
device ethernet 3c509 --opts "io=0x330, irq=7"
</PRE>
</CODE></BLOCKQUOTE>
<P>Alternatieve waarden van <CODE>device</CODE> zijn onder andere <CODE>scsi</CODE> voor
SCSI controllers en <CODE>cdrom</CODE> voor eigen CD-ROM stations.
<P>
<DL>
<DT><B>upgrade</B><DD><P>Upgrade een bestaande installatie in plaats van het uitvoeren
van een nieuwe installatie.
</DL>
<P>
<DL>
<DT><B>xconfig</B><DD><P>Configureer de X Window server, grafische kaart en monitor.
</DL>
<P>b.v.
<P>
<BLOCKQUOTE><CODE>
<PRE>
xconfig --server "Mach64" --monitor "tatung cm14uhe"
</PRE>
</CODE></BLOCKQUOTE>
<P>Ik ben niet zo diep op die laatste ingegaan omdat ik niet van plan
ben X op de console te draaien of op &eacute;&eacute;n van mijn
met KickStart geconfigureerde computers.
Er is me verteld dat de uitvoering van <CODE>xconfig</CODE> binnen KickStart
zelf wat zwak is, maar dezelfde functionaliteit is ook vanaf de opdrachtregel
via <CODE>Xconfigurator</CODE> beschikbaar - dus wellicht dat je dit het
beste over kunt laten aan het post-installatie script.
<P>Wanneer we alle stukjes en beetjes bijelkaar plaatsen ziet het
KickStart config bestand er ongeveer zo uit:
<P>
<BLOCKQUOTE><CODE>
<PRE>
lang en
network --static --ip 198.168.254.253 --netmask 255.255.255.0
  --gateway 198.168.254.1 --nameserver 198.168.254.2
nfs --server chicken.swedish-chef.org /mnt/cdrom
keyboard uk
zerombr yes
clearpart --all
part / --size 500
part swap --size 120
install
mouse ps/2
timezone --utc Europe/London
rootpw --iscrypted XaacoeGPmf/A.
lilo --location mbr
</PRE>
</CODE></BLOCKQUOTE>
<P>Een deel van de RedHat documentatie refereert naar een aanroep van de
<CODE>network</CODE> directive welke in de praktijk niet echt werkt:
<CODE>network --option</CODE>. De juiste aanroep is
<CODE>network</CODE> gevolgd door <CODE>--static</CODE>, <CODE>--bootp</CODE>
of <CODE>--dhcp</CODE>.  De BOOTP en DHCP opties zijn verschillend -
- in de mate dat ze zelfs van andere code gebruik maken.
<P>Je kunt de <CODE>--grow</CODE> parameter toevoegen aan een <CODE>part</CODE>
directive om aan te geven dat het OK is dat de partitie verder toeneemt
dan de grootte die je opgeeft. Dit heeft waarschijnlijk slechts zin
als &eacute;&eacute;n partitie met <CODE>--grow</CODE> is gemarkeerd.
<H2>6.2 Te installeren packages</H2>

<P>Het begin van de sectie packages van het KickStart configuratiebestand
wordt aangegeven door de aanwezigheid van een <CODE>%packages</CODE> directive
op een aparte regel. Dit wordt gevolgd door &eacute;&eacute;n of beiden
typen packages specifiers - individuele packages kunnen worden ge&iuml;nstalleerd
door de naam van de RPM ervan op te geven (exclusief de informatie betreffende
de versie en het platform), en groepen packages kunnen worden ge&iuml;nstalleerd
door de naam van de groep waartoe ze behoren op te geven.
<P>Hier is een voorbeeld <CODE>packages</CODE> sectie voor een KickStart
configbestand:
<P>
<BLOCKQUOTE><CODE>
<PRE>
%packages
@ Base
netkit-base
bind-utils
ncftp
rdate
tcp_wrappers
traceroute
cmu-snmp
</PRE>
</CODE></BLOCKQUOTE>
<P>Wat zijn deze groepen?  Er zijn een aantal groepen standaard gedefinieerd
in een bestand genaamd <EM>base/comps</EM> onder de top level directory
van de RedHat distributie. Dit zijn degenen die tijdens dit schrijven
van toepassing waren:
<P>
<UL>
<LI> Base</LI>
<LI> Printer Support</LI>
<LI> X Window System</LI>
<LI> Mail/WWW/News Tools</LI>
<LI> DOS/Windows Connectivity</LI>
<LI> File Managers</LI>
<LI> Graphics Manipulation</LI>
<LI> X Games</LI>
<LI> Console Games</LI>
<LI> X multimedia support</LI>
<LI> Console Multimedia</LI>
<LI> Print Server</LI>
<LI> Networked Workstation</LI>
<LI> Dialup Workstation</LI>
<LI> News Server</LI>
<LI> NFS Server</LI>
<LI> SMB (Samba) Connectivity</LI>
<LI> IPX/Netware(tm) Connectivity</LI>
<LI> Anonymous FTP/Gopher Server</LI>
<LI> Web Server</LI>
<LI> DNS Name Server</LI>
<LI> Postgres (SQL) Server</LI>
<LI> Network Management Workstation</LI>
<LI> TeX Document Formatting</LI>
<LI> Emacs</LI>
<LI> Emacs with X windows</LI>
<LI> C Development</LI>
<LI> Development Libraries</LI>
<LI> C++ Development</LI>
<LI> X Development</LI>
<LI> Extra Documentation</LI>
</UL>
<P>Het zal je opvallen dat ze met de diverse configuraties corresponderen
waar je gedurende een handmatige installatie om wordt gevraagd.
Een aantal packages in een gegeven packagegroep komen ook in andere
groepen voor. Je kunt meerdere groepen packages installeren zonder dat
dit problemen veroorzaakt. Iedere groepsingang in de 
<EM>comps</EM> opsomming ziet er ongeveer zo uit:
<P>
<BLOCKQUOTE><CODE>
<PRE>
0 Extra Documentation
sag
lpg
howto
faq
man-pages
end
</PRE>
</CODE></BLOCKQUOTE>
<P>Het schijnt dat groepen met een <EM>1</EM> naast de naam (de eerste
regel hierboven) standaard voor de installatie worden geselecteerd.
Je kunt het Linux installatieproces zelfs verder aanpassen door je eigen
groepen aan te maken of bestaande groepen te herdefini&euml;ren
door dit bestand te wijzigen.
<H2>6.3 Post-installatie shellopdrachten</H2>

<P>Dit is waarschijnlijk de beste faciliteit, en iets waarvan geen direct
equivalent beschikbaar is in het handmatige installatieproces.
Wat we hier kunnen doen is een reeks opdrachten specificeren op niveau van de shell
die zouden kunnen worden uitgevoerd nadat de hoofdinstallatie (diskpartitionering,
installatie van de packages, enzovoort) compleet is.
<P>Het begin van deze sectie wordt aangeduid door de <CODE>%post</CODE>
directive in het KickStart configbestand. In de opdrachten die
daarop volgen kun je voordeel trekken van alle utility's die op je
nieuw gebouwde Linux systeem zijn ge&iuml;nstalleerd, b.v.
<P>
<BLOCKQUOTE><CODE>
<PRE>
%post
ln -s /etc/rc.d/init.d /etc/init.d
ln -s /etc/rc.d/rc.local /etc/rc.local
ln -s /usr/bin/md5sum /usr/bin/md5
ln -s /usr/bin/perl /usr/local/bin/perl
chmod ug-s /bin/linuxconf
mkdir /var/tmp/tmp
perl -spi -e 's!image=/boot/vmlinuz-.*!image=/boot/vmlinuz!' /etc/lilo.conf
rm /etc/rc.d/rc*.d/*sendmail
</PRE>
</CODE></BLOCKQUOTE>
<P>Je kunt ook gebruik maken van I/O omleiding en "here" documenten:
<P>
<BLOCKQUOTE><CODE>
<PRE>
cat &lt;&lt;EOF >>/etc/passwd
squid:*:102:3500:Squid Proxy:/usr/squid:/bin/bash
EOF

cat &lt;&lt;EOF >>/etc/group
cache:x:3500:
EOF
</PRE>
</CODE></BLOCKQUOTE>
<P>Pas de runtime opstartscripts aan:
<P>
<BLOCKQUOTE><CODE>
<PRE>
cat &lt;&lt;EOF >>/etc/rc.local
echo 8192 > /proc/sys/kernel/file-max
echo 32768 > /proc/sys/kernel/inode-max 

[ -x /usr/sbin/sshd ] &amp;&amp; /usr/sbin/sshd
[ -x /usr/sbin/cfd ] &amp;&amp; /usr/sbin/cfd

EOF
</PRE>
</CODE></BLOCKQUOTE>
<P>Stel de <EM>crontab</EM> regels in:
<P>
<BLOCKQUOTE><CODE>
<PRE>
cat &lt;&lt;EOF >/tmp/crontab.root
# Keep the time up to date
0,15,30,45 * * * * /usr/sbin/ntpdate -s eggtimer 2>&amp;1 >/dev/null
# Recycle Exim log files
1 0 * * * /usr/exim/bin/exicyclog
# Flush the Exim queue
0,15,30,45 * * * * /usr/exim/bin/exim -q
EOF

crontab /tmp/crontab.root
rm /tmp/crontab.root
</PRE>
</CODE></BLOCKQUOTE>
<P>En installeer zelfs andere RPM's die je zelf hebt samengesteld:
<P>
<BLOCKQUOTE><CODE>
<PRE>
rpm -i ftp://chicken.swedish-chef.org/rpms/squid.rpm
rpm -i ftp://chicken.swedish-chef.org/rpms/ssh.rpm
rpm -i ftp://chicken.swedish-chef.org/rpms/exim.rpm
rpm -i ftp://chicken.swedish-chef.org/rpms/cfengine.rpm
rpm -i ftp://chicken.swedish-chef.org/rpms/linux.rpm

ssh-keygen -b 1024 -f /etc/ssh_host_key -N ""
depmod -a
</PRE>
</CODE></BLOCKQUOTE>
<P>Je kunt hetzelfde effect bereiken door eigen RPM's aan te maken met
de opdrachten die je uit wilt voeren - zie hieronder voor meer informatie.
Geef ze een zorgvuldig gekozen naam. Je kunt ze als eerste laten installeren
(b.v. naam laten beginnen met 'aaa') of als laatste (b.v. naam laten 
beginnen met 'zzz').
<P>Een minder moeizame manier om root crontab records aan te maken is
ze als bestanden in &eacute;&eacute;n of meer van de directory's
<EM>/etc/cron.hourly</EM>, <EM>/etc/cron.daily</EM>,
<EM>/etc/cron.weekly</EM> en <EM>/etc/cron.monthly</EM> aan te maken.
<P>Meer informatie over het samenstellen van je eigen RPM's is beschikbaar
in Appendix B.
<H2><A NAME="s7">7. De installatie zelf</A></H2>

<P>Boot zoals gewoonlijk vanaf je RedHat bootdiskette de computer waarop
RedHat zal worden ge&iuml;nstalleerd, maar in plaats van het indrukken
van de <CODE>RETURN</CODE> achter de <CODE>SYSLINUX</CODE> prompt tik je
<CODE>linux ks</CODE> in.
<P>Als je geluk hebt, is dit alles wat je in hoeft te tikken!
<P>Als je de RedHat bootdiskette zoals hierboven uiteengezet hebt aangepast,
hoef je zelfs dit niet te doen :-)
<P>Aangezien we slechs de normale stappen van een RedHat installatie
aan het automatiseren zijn, zullen de normale dialogen verschijnen
als/wanneer KickStart niet meer weet wat het vervolgens moet doen.
In het meest waarschijnlijke geval zal je netwerkinterface niet
onmiddellijk automatisch worden gedetecteerd en zal je worden
gevraagd naar het IRQ en I/O-adres. KickStart heeft meestal hulp
nodig bij ISA-kaarten, en detecteert PCI-kaarten automatisch.
<P>Je kunt zoals gewoonlijk door het wisselen van virtuele consoles in
de gaten houden wat KickStart aan het doen is:
<P>
<UL>
<LI> Alt-F1 - installatie dialoog</LI>
<LI> Alt-F2 - shellprompt</LI>
<LI> Alt-F3 - installatielog (meldingen van het installatieprogramma)</LI>
<LI> Alt-F4 - systeemlog (meldingen van de kernel, enz.)</LI>
<LI> Alt-F5 - andere meldingen</LI>
</UL>
<H2><A NAME="s8">8. Mounten van de boot/aanvullende disks</A></H2>

<P>De RedHat bootdisk <EM>boot.img</EM> is in het MS-DOS formaat en maakt
gebruik van het <CODE>SYSLINUX</CODE> programma om te booten. De aanvullende disk
<EM>supp.img</EM> is een Linux <CODE>ext2</CODE> bestandssysteem. Je kunt
deze bestanden beiden aan je bestandssysteem mounten en ze hacken
als je in je Linux-kernel ondersteuning hebt voor het loopback
bestandssysteem:
<P>
<BLOCKQUOTE><CODE>
<PRE>
# mkdir -p /mnt/boot /mnt/supp
# mount -o loop -t msdos boot.img /mnt/boot
# mount -o loop supp.img /mnt/supp
</PRE>
</CODE></BLOCKQUOTE>
<P>Nu zou je de bestanden op de boot- en aanvullende disk onder respectievelijk
de <EM>/mnt/boot</EM> en <EM>/mnt/supp</EM> moeten kunnen zien.
H&egrave;!  Mogelijk kunnen oudere versies van <CODE>mount</CODE> de optie
<CODE>-o loop</CODE> niet hanteren. In deze gevallen moet je expliciet gebruik
maken van <CODE>losetup</CODE> om voor ieder bestand het loopback device te
configureren, b.v.
<P>
<BLOCKQUOTE><CODE>
<PRE>
# losetup /dev/loop0 boot.img
# mount -t msdos /dev/loop0 /mnt/boot
</PRE>
</CODE></BLOCKQUOTE>
<P>Wellicht dat je expliciet de optie <CODE>-t ext2</CODE> op moet geven bij
het mounten van een <CODE>ext2</CODE> bestandssysteem zoals hetgeen op de
aanvullende disk. Maar het ziet ernaar uit dat mensen met moderne
Linux distributies zich hier geen zorgen over hoeven maken.
<P>Als je het niet te moeilijk wilt maken, dan kun je dit altijd omzeilen,
en echte diskettes manipuleren in plaats van deze diskette-images.
<P>
<H2><A NAME="s9">9. Aanpassen van het RedHat installatieprogramma</A></H2>

<P>Als je wat met de installatieprocedure zelf wilt aanrommelen, de
broncode is te vinden op de RedHat CD-ROM of je lokale RedHat mirrorsite.
Het bevindt zich in de <EM>misc/src/install</EM> onder de toplevel directory
van de <EM>i386</EM> distributie.
<P>Als je de RedHat bootdisk bestudeert, zul je zien dat er naast de
Linux kernel <EM>vmlinuz</EM>, een groot bestand
<EM>initrd.img</EM> is:
<P>
<BLOCKQUOTE><CODE>
<PRE>
- -rwxr-xr-x   1 root     root          559 May 11 15:48 boot.msg
- -rwxr-xr-x   1 root     root          668 May 11 15:48 expert.msg
- -rwxr-xr-x   1 root     root          986 May 11 15:48 general.msg
- -rwxr-xr-x   1 root     root       968842 May 11 15:48 initrd.img
- -rwxr-xr-x   1 root     root         1120 May 11 15:48 kickit.msg
- -r-xr-xr-x   1 root     root         5352 May 11 15:48 ldlinux.sys
- -rwxr-xr-x   1 root     root          875 May 11 15:48 param.msg
- -rwxr-xr-x   1 root     root         1239 May 11 15:48 rescue.msg
- -rwxr-xr-x   1 root     root          402 May 11 15:48 syslinux.cfg
- -rwxr-xr-x   1 root     root       444602 May 11 15:48 vmlinuz
</PRE>
</CODE></BLOCKQUOTE>
<P>Je raadde het al, dit is een ander <CODE>ext2</CODE> bestandssysteem dat als
een bestand is opgeslagen --- maar met een handigheidje.  
Het is in feite ook gecomprimeerd.  Je kunt
het decomprimeren en het resultaat ervan mounten, b.v.
<P>
<BLOCKQUOTE><CODE>
<PRE>
# gzip -dc /mnt/boot/initrd.img >/tmp/initrd.ext2
# mkdir /mnt/initrd
# mount -o loop /tmp/initrd.ext2 /mnt/initrd
</PRE>
</CODE></BLOCKQUOTE>
<P>Waarschijnlijk het belangrijkste onderdeel van dit bestandssysteem is
de verzameling laadbare kernelmodules die in de bootdisk is opgenomen.
Als je een nieuwe driverversie hierin op wilt nemen, dan moet je of
<EM>vmlinuz</EM> door een nieuwe kernel vervangen, welke statisch is
gelinkt, of het in de verzameling modules vervangen.
Bovendien moet je wellicht andere modules verwijderen om plaats te maken.
<P>Het bestand <EM>modules/modules.cgz</EM> bestaat uit de verzameling modules.
Vraag je je af wat dat zou kunnen zijn?  In feite is het een
gecomprimeerd <CODE>cpio</CODE> archief, geloof het of niet! 
En je dacht dat niemand <CODE>cpio</CODE> nog gebruikte...  
Zelfs RPM maakt intern nog gebruik van <CODE>cpio</CODE>
Zo kun je er wat mee rommelen:
<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
# gzip -dc /mnt/initrd/modules/modules.cgz >/tmp/modules.cpio
# cpio -itv &lt;modules.cpio >modules.listing
# mkdir modules
# cpio -idumv &lt;../modules.cpio
</PRE>
</CODE></BLOCKQUOTE>
<P>Ik denk dat er thans onder Linux geen manier is (tenminste in
hoofdstroom distributies) om transparant gecomprimeerde bestandssystemen
te benaderen. Laat het me weten als je meer weet!
<P>Denk aan het volgende als je wijzigingen aanbrengt:
<P>
<OL>
<LI> Maak voor het opnieuw aanmaken van het archief gebruik van <CODE>cpio</CODE>.
Hoe je dit doet wordt als oefening aan de lezer overgelaten...</LI>
<LI> Gebruik <CODE>gzip</CODE> om het resulterende archief te comprimeren.</LI>
<LI> Kopieer het naar <EM>/mnt/initrd</EM>, of waar je je ongecomprimeerde
<EM>initrd.img</EM> archief dan ook plaatst.</LI>
<LI> Unmount <EM>/mnt/initrd</EM> (of hoe je het ook noemde).</LI>
<LI> Comprimeer het nieuwe <EM>initrd.img</EM> wederom met <CODE>gzip</CODE>.</LI>
<LI> Kopieer het resulterende archief naar de bootdisk-image - in ons
voorbeeld <EM>/mnt/boot/initrd.img</EM>.</LI>
<LI> Unmount de bootdisk-image, b.v. <EM>/mnt/boot</EM>.  </LI>
</OL>
<P>Tenslotte kun je met deze aangepaste bootdisksetup nieuwe bootdiskettes
aanmaken, b.v.
<P>
<BLOCKQUOTE><CODE>
<PRE>
# cat boot.img >/dev/fd0
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="s10">10. FAQ's/Lijst met wensen</A></H2>

<P>
<P><B>V:</B> Na de KickStart installatie boot mijn computer niet.
De BIOS geef een melding als <CODE>Missing operating system</CODE>.
<P><B>A:</B> Het lijkt erop dat de partitie met het rootbestandssysteem
niet opstartbaar is. Gebruik <CODE>fdisk</CODE> om naar de opstartbare status
over te schakelen.
<P><B>V:</B> Na de disketteboot, krijg ik de melding:
<CODE>Error opening files for kickstart copy: File exists</CODE>.
<P><B>A:</B> Gebruik een recentere versie van de <EM>boot.img</EM> en
<EM>supp.img</EM> - kijk in de directory <EM>updates</EM> van je
lokale RedHat mirror site.  Een aantal oudere versies hiervan voor
RedHat 5.1 bevatte een fout.
<P><B>V:</B> Kun je ook alle uitstaande patches (bijgewerkte RPM's) 
automatisch toepassen? Hoe?
<P><B>A1:</B> Kopieer de RPM's die je wilt installeren naar de RPMS directory van waaruit
de installatie plaats gaat vinden, zie dat je van de oudere RPM's afkomt,
en werk het bestand <EM>RedHat/base/hdlist</EM> bij met de nieuwe RPM details.
Zie Appendix C voor een script van Eric Doutreleau dat
dit voor je doet. Als je het zelf doet, denk er dan aan daarna
<EM>genhdlist</EM> uit te voeren!
<P><B>A2:</B> Probeer dit Perl-script: 
<A HREF="http://wwwcache.ja.net/dev/patchup/">patchup</A>.  Het vergelijkt de RPM's
die op je systeem zijn ge&iuml;nstalleerd met die in een 
voorgestelde directory en rapporteert over degenen waarvan wordt
verondersteld dat ze moeten worden bijgewerkt. Ze kunnen zelfs
worden ge&iuml;nstalleerd als je dat het script toevertrouwd.
<P><B>A3:</B> 
<A HREF="http://rufus.w3.org/linux/rpm2html/">rpm2hml</A>
heeft een krachtiger (12MB C code vs. een Perl pagina!) versie van A2.
<P><B>V:</B> Een enkel config bestand op de installatieserver voor alle
clients, misschien als een uitwijkmogelijkheid na het uitproberen van
<EM>IPADDR-kickstart</EM> ?
<P><B>A1:</B> Gebruik de BOOTP/DHCP 'boot file' parameter <EM>bf</EM> om de
bestandsnaam in te stellen.
<P><B>A2:</B> Voeg een record <CODE>bf=/kickstart/ks.cfg</CODE> toe aan de
relevante ingang in <EM>/etc/bootptab</EM>.
<P><B>V:</B> Meer flexibiliteit wanneer er iets mis gaat - b.v. 
vraag naar de alternatieve lokaties als de distributie niet op de
CD-ROM is te vinden.
<P><B>A:</B> ?
<P><B>V:</B> Expliet uitsluiten van packages - b.v. alles behalve
<EM>sendmail</EM>.
<P><B>A:</B> Zet het <B>BASE</B> package opnieuw op zonder sendmail.
<P><B>V:</B> Kies welke services automatisch worden gestart bij de
systeemstart door de runlevel scripts onder <EM>/etc/rc.d/</EM>.
<P><B>A:</B> Het <EM>chkconfig</EM> utility laat je configureren welke
services automatisch tijdens het booten worden uitgevoerd. Je kunt het
volgende in je post-installatie scriptsectie uit laten voeren, b.v.
voor het uitvoeren van <EM>ypbind</EM> in run
levels 3, 4 en 5:
<P>
<BLOCKQUOTE><CODE>
<PRE>
chkconfig --level 345 ypbind on
</PRE>
</CODE></BLOCKQUOTE>
<P>en het zal de ypbind level op de 345 level starten.
<P><B>V:</B>Laat uitvoer op een andere virtuele console verschijnen bij de
uitvoering van shellopdrachten in de <CODE>%post</CODE> sectie,
in plaats van het hoofdscherm te overschrijven.
<EM>Zou kunnen worden gedaan in de sectie shellopdrachten met
<CODE>open</CODE>?</EM>.
<P><B>A:</B> Geen probleem - doe bijvoorbeeld dit:
<P>
<BLOCKQUOTE><CODE>
<PRE>
  exec >/dev/tty5
</PRE>
</CODE></BLOCKQUOTE>
<P><B>V:</B>Controleert de aanmaakcode voor het bestandssysteem op 
slechte blokken?
<P><B>A:</B> Als je naar de virtuele console overschakelt waarop de uitvoer
van de aanmaak van het bestandssysteem wordt weergegeven, zie je geen
enkele vermelding van de uit te voeren 'read-only' test.
Het lijkt erop dat het antwoord 'nee' is.
<P><B>V:</B>Kan ik het zo regelen dat een aantal machines anders worden
geconfigureerd dan anderen?
<P><B>A:</B> Je zou de host afhankelijke gegevens in de script sectie
van de KickStart configuratie kunnen plaatsen - b.v. alleen een gegeven
RPM op een gegeven machine installeren. Het zou handig zijn als er
een voorwaardelijke installatiefaciliteit in de packages sectie van het
configuratiebestand was, b.v. overschakelen bij een andere architectuur,
of bij een hostnaam/domein naam/IP-adres.
<P><B>V:</B>Zijn er wijzigingen tussen RedHat 5.1 en 5.2 ?
<P><B>A1:</B> Veel wijzigingen in het installatieprogramma, maar voornamelijk
correcties op programmeerfouten en cosmetische verbeteringen.
Geen impact op KickStart zover als ik je kan zeggen - van een
<EM>diff -rcs</EM> van de twee <EM>misc/src/install</EM>
directory's.
<P><B>A2:</B> RH5.2 heeft nu blijkbaar de automatische IP toekenning/DHCP
patches voor <CODE>bootpd</CODE> opgenomen, maar ze hebben de documentatie achterwege
gelaten waarin wordt aangegeven hoe je het gebruikt.
<P><B>V:</B> (Hoe) kun je een specifieke partitie of partities wissen?
b.v. <EM>/home</EM> behouden maar <EM>/</EM> legen.
<P><B>A:</B> Dit kan (nog) niet!
<P><B>V:</B>Kun je het zo regelen dat je partities op meerdere drives
worden aangemaakt? b.v. <EM>/</EM> op <CODE>sda</CODE> en <EM>/home</EM>
op <CODE>sdb</CODE>.
<P><B>A:</B> Ik denk van niet - het ziet ernaar uit dat je alleen toegang
krijgt tot de eerste drive vanuit het partitionerings hulpmiddel.
<P><B>V:</B>Is het mogelijk bestaande partities op te laten nemen in
de mounttabel, of is het alleen mogelijk de aanmaak van nieuwe partities
te specificeren die dan zullen worden opgenomen?
<P><B>A:</B> ?
<P><B>V:</B> Waar is het bestand dat wordt aangemaakt bij de uitvoering van
<CODE>mkkickstart</CODE>?
<P><B>A:</B> Het maakt geen bestand aan - het dumpt de KickStart 
configuratie naar <CODE>stdout</CODE>.
<P><B>V:</B> In de virtuele console 4 (Alt-F4) krijg ik <CODE>Unable to load NLS
charset cp437(nls_cp437)</CODE>. Wat betekent dit?  Moet ik me zorgen maken?
<P><B>A:</B> Het lijkt erop dat je aan het proberen bent een CD-ROM
gebrand met het Joliet (Unicode uitbreidingen op ISO 9660) bestandssysteem
te mounten. In theorie zijn de bestandsnamen op de CD-ROM wellicht bewerkt
en komen ze niet correct over onder Linux. In praktijk schijnt het geen
problemen te veroorzaken - zou een onechte afhankelijkheid kunnen zijn?
<P><B>V:</B>Waarom wordt het X Window Systeem ge&iuml;nstalleerd? Ik plaatste
het niet in mijn lijst met packages.
<P><B>A:</B> De <CODE>XFree86-VGA16</CODE> RPM is een 'basiscomponent', en
wordt als zodanig altijd ge&iuml;nstalleerd - tenzij je de definitie
van de basisklasse wijzigt.
<P><B>V:</B> Kan ik in mijn post-installatie script de packages
gebruiken die inmiddels zijn ge&iuml;nstalleerd om geweldige dingen
mee uit te halen die niet mogelijk zijn met de beperkte tools op de
diskettes?
<P><B>A:</B> Ja - b.v. als je ervoor kiest Perl te installeren
wanneer je de KickStart config samenstelt, is bijna alles mogelijk in
ongeveer vijf regels :-)
<H2><A NAME="s11">11. Krediet</A></H2>

<P>Met dank aan Eric Doutreleau voor de info betreft <EM>chkconfig</EM>, de
hack voor het configuratiebestand <CODE>SYSLINUX</CODE>, en het Perlscript voor het bijwerken
van de RPM's op de distributieserver. Met dank aan Robert Kaminsky voor
het uitgebreide onderzoek. Met dank aan Piete Brooks, Flavia Regina
Munhoz, Tom Toffoli, Bob Robbins, Charlie Brady en Ragen Herrington,
voor hun opmerkingen en vragen.
<H2><A NAME="s12">12. Appendix A - Configureren van BOOTP/DHCP en NFS</A></H2>

<P>Als je je afvraagt wat in hemelsnaam deze BOOTP en DHCP zooi is, is meer
informatie beschikbaar op de 
<A HREF="http://www.dhcp.org/">DHCP WWW site</A>. NFS wordt in de NFS-HOWTO apart gedocumenteerd
en er is ook een DHCP mini-HOWTO. Ik heb getracht voldoende details aan
te leveren zodat je ermee kunt beginnen, maar heb de onderwerpen niet al
te diepgaand behandeld - laat het me weten als je denkt dat dit
een beetje te veel van het goede is.
<P>In de BOOTP/DHCP + NFS configuratie die we gaan bespreken, zou het
KickStart configuratiebestand via NFS te mounten moeten zijn door de
machine van waaraf wordt ge&iuml;nstalleerd
<EM>/kickstart/IPADDR-kickstart</EM> op de BOOTP/DHCP server,
waar <EM>IPADDR</EM> het IP-adres is van de nieuwe machine, b.v.
<EM>/kickstart/198.168.254.254-kickstart</EM> voor de machine
<EM>198.168.254.254</EM>.
<P>Je zou deze lokatie moeten kunnen overschrijven door de
<CODE>bf</CODE> parameter (boot file) in je BOOTP/DHCP response te retourneren.
Wellicht dat het zelfs mogelijk is deze via NFS geheel vanaf een andere
machine te mounten.
<P>Maak het bestand <EM>/etc/exports</EM> aan met een volgende vergelijkbare
inhoud om een aantal directory's voor NFS vanaf een bestaande Linux-box te
exporteren:
<P>
<BLOCKQUOTE><CODE>
<PRE>
/kickstart *.swedish-chef.org(ro,no_root_squash)
/mnt/cdrom *.swedish-chef.org(ro,no_root_squash)
</PRE>
</CODE></BLOCKQUOTE>
<P>Als je het IP-adres dat je met DNS gaat gebruiken niet hebt geregistreerd
dan kan het zijn dat wordt aangegeven dat de NFS-server en/of de RPC
portmapper het aflegt. Je kunt dit waarschijnlijk voorkomen door de
IP-adres/netmask paren in de configuratiebestanden te plaatsen, b.v.
<P>
<BLOCKQUOTE><CODE>
<PRE>
/kickstart 198.168.254.0/255.255.255.0(ro,no_root_squash)
</PRE>
</CODE></BLOCKQUOTE>
<P>en in <EM>/etc/hosts.allow</EM>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
ALL: 194.82.103.0/255.255.255.0: ALLOW
</PRE>
</CODE></BLOCKQUOTE>
<P>Dit komt doordat de meeste Linux-distributies gebruik maken van
TCP-wrappers voor een aantal of alle aan NFS gerelateerde daemons voor
het toegangsbeheer. De syntax van <EM>/etc/exports</EM> kan op andere
Unix-varianten anders zijn - de NFS-servers gebundeld met Linux-distributies
bieden gewoonlijke een veel breder bereik aan opties dan die met andere
Unix-versies worden geleverd.
<P>Als je in je KickStart configuratiebestand een rootwachtwoord opneemt,
of via NFS, directory's met gevoelige informatie exporteert, zal je
ervoor moeten zorgen dat je deze informatie aan zo weinig mogelijk
mensen blootstelt. Dit kun je bewerkstelligen door de NFS exportpermissies
zo verfijnd mogelijk in te stellen, b.v. door een bepaalde host of
een bepaald te exporteren subnet te specificeren in plaats van een geheel
domein. Het is allemaal mooi en simpel als je een speciaal IP-adres
voor KickStart installaties vrijhoudt, behalve als je het later moet
wijzigen - of de machine opnieuw moet configureren om het IP-adres
via BOOTP/DHCP te krijgen.
<P>De meeste NFS-servers vereisen dat je <CODE>mountd</CODE> en <CODE>nfsd</CODE>
(onder een aantal Unix-versies worden deze opdrachten voorafgegaan door
<CODE>rpc.</CODE>) te kennen geeft dat het bestand <EM>/etc/exports</EM> is gewijzigd -
gewoonlijk doe je dit door een <CODE>SIGHUP</CODE> te verzenden. Er is
vaak een programma of script genaamd <CODE>exportfs</CODE> die dit voor
je doet, b.v.
<P>
<BLOCKQUOTE><CODE>
<PRE>
# exportfs -a
</PRE>
</CODE></BLOCKQUOTE>
<P>Wellicht dat de directory's niet automatisch worden ge&euml;xporteerd
wanneer NFS na het booten van de machine niet werkend en draaiend was.
Probeer te rebooten, of start als root de volgende programma's op:
<P>
<BLOCKQUOTE><CODE>
<PRE>
# portmap
# rpc.nfsd
# rpc.mountd
</PRE>
</CODE></BLOCKQUOTE>
<P>Zoals opgemerkt, wordt op een aantal systemen het voorvoegsel <CODE>rpc.</CODE>
niet gebruikt. Onder de meeste moderne Unix-distributies zijn deze programma's
te vinden in de directory's <EM>/usr/sbin</EM> of <EM>/usr/libexec</EM>. 
Wellicht dat deze zich nog niet in je pad bevinden, b.v. als je <CODE>su</CODE> 
gebruikte om <EM>root</EM> te worden. Het programma <CODE>portmap</CODE> 
wordt soms ook <CODE>rpcbind</CODE> genoemd, b.v. onder Solaris, is voor een
aantal versies van <CODE>nfsd</CODE> vereist dat met een opdrachtregelopdracht
het aantal uit te voeren kopie&euml;n van de server wordt opgegeven, en
het kan zijn dat je bemerkt dat je ook een andere daemon met de naam
<CODE>biod</CODE> moet draaien. Het bovenstaande zou voldoende moeten zijn
op (bijna?) alle Linux systemen.
<P>Als je gebruikt maakt van de CMU BOOTP server en dynamische adresseringsextensies
waarnaar eerder werd gerefereerd, dan zou een
voorbeeld <EM>/etc/bootptab</EM> record
(<EM>/etc/bootptab</EM> is de normale lokatie van het BOOTP/DHCP
configuratiebestand) er ongeveer zo uit zien:
<P>
<BLOCKQUOTE><CODE>
<PRE>
  .dynamic-1:ip=198.168.254.128:T254=0x30:T250="ds=198.168.254.2:
  dn=swedish-chef.org:sm=255.255.255.0:gw=198.168.254.1:
  dl=0xFFFFFFFF":
</PRE>
</CODE></BLOCKQUOTE>
<P>
<P>Hiermee wordt aangegeven IP-adressen dynamisch toe te kennen bij het
aantreffen van nieuwe machines, te beginnen bij
<EM>198.168.254.128</EM> en verdergaand voor de volgende 48
(de hexidecimale waarde is <EM>30</EM>) adressen. Iedere client zal
de waarde <EM>T250</EM> teruggeven. In dit geval wordt hiermee ingesteld:
<P>
<UL>
<LI> de DNS server <CODE>ds</CODE> op <EM>198.168.254.2</EM></LI>
<LI> de domeinnaam <CODE>dn</CODE> op <EM>swedish-chef.org</EM></LI>
<LI> de subnetmask <CODE>sm</CODE> op <EM>255.255.255.0</EM></LI>
<LI> de standaardgateway <CODE>gw</CODE> op <EM>198.168.254.1</EM></LI>
<LI> de lease lengte <CODE>dl</CODE> (hoelang het adres geldig is)
op "forever"</LI>
</UL>
<P>Er schijnen een aantal andere verseis van deze server in omloop te zijn
die de dynamische adressering niet ondersteunen. Hiervoor zou je een
opsomming moeten geven van de hardware (typisch de Ethernet MAC) adressen
van iedere te-installeren machine in <EM>/etc/bootptab</EM>, en de regels
zouden er dan ongeveer zo uit zien:
<P>
<BLOCKQUOTE><CODE>
<PRE>
bork.swedish-chef.org:ip=198.168.254.128:ha=0000E8188E56:
  ds=198.168.254.2:dn=swedish-chef.org:sm=255.255.255.0:
  gw=198.168.254.1:dl=0xFFFFFFFF":
</PRE>
</CODE></BLOCKQUOTE>
<P>De parameter <CODE>ha</CODE> correspondeert met het hardware-adres
van de computer waarop wordt ge&iuml;nstalleerd.
<H2><A NAME="s13">13. Appendix B - Je eigen RPM's aanmaken</A></H2>

<P>Het RPM pakketformaat is reeds zeer goed gedocumenteerd, in het bijzonder
in het boek <EM>Maximum RPM</EM> van Ed Bailey, wat je kunt downloaden vanaf
de 
<A HREF="http://www.rpm.org/">RPM WWW site</A> - tevens beschikbaar
via alle goede boekwinkels!  Dit zijn slechts een paar aanwijzingen voor
mensen die haast hebben.
<P>RPM packages worden samengesteld vanuit een <EM>spec</EM> bestand. 
Dit bestaat (op een vergelijkbare wijze als het KickStart configbestand)
uit voorgeschreven stappen
die moeten worden genomen om het package samen te stellen. Er wordt 
vanuit gegaan dat je het vanaf de bron op moet bouwen, mogelijk voor
meerdere platformen, en waarbij wellicht patches voor het compileren
moeten worden toegepast. Eenmaal samengesteld en ge&iuml;nstalleerd
zal een binaire RPM worden aangemaakt uit de bestanden en directory's
die je opgeeft als zijnde geassocieerd met het package. Het is belangrijk
er notitie van te nemen dat RPM er geen idee van heeft welke bestanden
en directory's aan een gegeven package zijn gerelateerd - je moet dit
opgeven.
<P>Hier is een voorbeeldspecificatie voor een aangepaste RPM van de
<A HREF="http://squid.nlanr.net/">Squid WWW cache server</A>:
<P>
<BLOCKQUOTE><CODE>
<PRE>
Summary: Squid Web Cache server
Name: squid
Version: 1.NOVM.22
Release: 1
Copyright: GPL/Harvest
Group: Networking/Daemons
Source: squid-1.NOVM.22-src.tar.gz
Patch: retry-1.NOVM.20.patch
%description
Dit is slechts een eerste probeersel om de Squid Web Cache in te pakken
voor een eenvoudige installatie op onze RedHat Linux servers

%prep
%setup
%build
configure --prefix=/usr/squid
perl -spi -e 's!#( -DALLOW_HOSTNAME_UNDERSCORES)!$1!' src/Makefile
make

%install
make install

%files
/usr/squid
</PRE>
</CODE></BLOCKQUOTE>
<P>Zo bouw je deze RPM:
<P>
<BLOCKQUOTE><CODE>
<PRE>
% mkdir -p SOURCES BUILD SRPMS RPMS/i386
% cp ~/squid-1.NOVM.22-src.tar.gz SOURCES
% cp ~/retry-1.NOVM.20.patch SOURCES
% rpm -ba squid-1.NOVM.22+retry-1.spec
</PRE>
</CODE></BLOCKQUOTE>
<P>Hiermee zal automatisch een subdirectory onder de <EM>BUILD</EM>
directory worden aangemaakt, waarin de broncode zal worden uitgepakt
en dan de patch zal worden toegepast
(voor het patchen zijn een aantal opties beschikbaar - kijk in het
boek voor details). Nu zal RPM automatisch het package bouwen door
<CODE>configure</CODE> en vervolgens <CODE>make</CODE> uit te voeren, het met
<CODE>make install</CODE> installeren, en een momentopname te nemen van de
bestanden onder <EM>/usr/squid</EM>. Het is dat laatste wat de binaire
RPM van de Squid software zal vormen.
<P>We kunnen willekeurige shellopdrachten bij het uitpak-, bouw- en
installatieproces invoegen, zoals b.v. de aanroep naar <CODE>perl</CODE>
waarmee &eacute;&eacute;n van Squid's parameters tijdens het compileren
wordt verfijnd.
<P>De uiteindelijke binaire RPM zal onder de <EM>RPMS</EM> directory in
de voor het platform specifieke subdirectory <EM>i386</EM> worden achtergelaten.
In dit geval zal het <EM>squid-1.NOVM.22-1.i386.rpm</EM> worden genoemd.
De bestandsnaam wordt aangemaakt door de waarden van de volgende parameters
uit het spec bestand aaneen te schakelen:
<CODE>Name</CODE>, <CODE>Version</CODE> en
<CODE>Release</CODE> - plus het hardwareplatform in kwestie, in dit geval
<EM>i386</EM>.  Probeer dit in gedachten te houden bij het aanmaken van je
eigen RPM's, om te vermijden ze al te lange of moeilijke namen te geven!
<P>Het is het ook waard in gedachten te houden dat je RPM's kunt bouwen zonder
dat je het gehele softwarepackage opnieuw moet samenstellen, b.v.
<P>
<BLOCKQUOTE><CODE>
<PRE>
Summary: Linux 2.0.36 kernel + filehandle patch + serial console patch
Name: linux
Version: 2.0.36+filehandle+serial_console
Release: 1
Copyright: GPL
Group: Base/Kernel
Source: linux-2.0.36+filehandle+serial_console.tar.gz
%description
Dit is slechts een eerste poging in de Linux kernel met patches samen
te stellen voor installatie op onze RedHat Linux servers.

%prep
echo

%setup
echo

%build
echo

%install
echo

%post
/sbin/lilo

%files
/lib/modules/2.0.36
/boot/vmlinuz
</PRE>
</CODE></BLOCKQUOTE>
<P>In dit geval maken we eenvoudigweg een RPM gebaseerd op het
<EM>/boot/vmlinuz</EM> bestand en de inhoud van de directory
<EM>/lib/modules/2.0.36</EM>, en voeren <EM>/sbin/lilo</EM> uit nadat
het package op een doelcomputer is ge&iuml;nstalleerd. Laat het me weten
als je een veel nettere manier weet om het spec bestand te schrijven.
<H2><A NAME="s14">14. Appendix C - Opnemen van je eigen RPM's in de distributie</A></H2>

<P>
<P>Hier is Eric's script voor het opnemen van bijgewerkte RPM's in de
RedHat distributie:
<P>
<BLOCKQUOTE><CODE>
<PRE>
#!/usr/bin/perl
#
$redhatdir="/cdrom/i386";
$rpmdir="/cdrom/i386/RedHat/RPMS/";
$updatedir="/cdrom/updates/";
@OTHERDIR=($updatedir);
foreach $dir (@OTHERDIR)
        {
        print "update voor $dir\n";
        system(" find $dir -name \"*.rpm\" -exec cp {} $rpmdir \\; ");
        }
chdir($contribdir) || die "peux pas aller dans $contribdir $!\n";
system("chmod -R 755 $redhatdir");
chdir($rpmdir) || die "problem to go in $rpmdir $!\n";
#
# verwijder het oude bestand
#
opendir(DIR,'.');
@package=grep(/\.rpm$/,readdir(DIR));
foreach $file (@package)
        {
        $file =~ /(.*)\-([\d+|\.]+\w*)\-(\d+)\.[i386|noarch].*/;
        $nom=$1;
        $version=$2;
        $buildvers=$3;
        if ($NOM{$nom})
                {
                $version2=$VERSION{$nom};
                $buildver2=$BUILDVERS{$nom};
                $file2=$FILE{$nom};
                $nom2=$NOM{$nom};
                if ( $version2 gt $version )
                        {
                        print "$file2 is nieuwer dan $file\n";
                        unlink($file);
                        }
                else 
                        {
                        if ( $version2 lt $version )
                                {
                                print "$file is nieuwer dan $file2\n";
                                unlink($file2);
                                $VERSION{$nom}=$version;
                                $BUILDVERS{$nom}=$buildvers;
                                $FILE{$nom}=$file;
                                $NOM{$nom}=$nom;
                                }
                        else
                                {
                                if ( $buildver2 > $buildvers )
                                                {
                                           print "$file2 : $buildver2 est mieux que $file : $buildvers\n";
                                           unlink($file);
                                                }
                                else
                                                {
                                        print "$file2 : $buildver2 is ouder dan $file : $buildvers\n";
                                            unlink($file2);
                                            $VERSION{$nom}=$version;
                                            $BUILDVERS{$nom}=$buildvers;
                                            $FILE{$nom}=$file;
                                            $NOM{$nom}=$nom;
                                                }
                                }
                        }
                }
        else
                {
                $VERSION{$nom}=$version;
                $BUILDVERS{$nom}=$buildvers;
                $FILE{$nom}=$file;
                $NOM{$nom}=$nom;
                }
        }

# hier doen we het zware werk 
#
system("$redhatdir/misc/src/install/genhdlist $redhatdir");
</PRE>
</CODE></BLOCKQUOTE>
</BODY>
</HTML>
