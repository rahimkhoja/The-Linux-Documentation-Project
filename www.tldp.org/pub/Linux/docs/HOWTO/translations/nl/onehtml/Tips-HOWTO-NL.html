<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>De Linux Tips HOWTO</TITLE>


</HEAD>
<BODY>
<H1>De Linux Tips HOWTO</H1>

<H2>Paul Anderson, <CODE>paul@geeky1.ebtech.net</CODE>,<BR>
Vertaald door: Ellen Bokhorst, <CODE>bokkie@nl.linux.org</CODE></H2>v3.6, juni 1998
<P><HR>
<EM>Deze HOWTO bevat die moeilijk te vinden aanwijzingen en fijnafstemmingen
die Linux er wat fraaier op maken.</EM>
<HR>
<H2><A NAME="s1">1. Introductie</A></H2>

<P>Welkom bij de <B>Linux Tips HOWTO</B>, een lijst met handige truuks en
optimalisaties die Linux er leuker op maken. Alles wat hier nu in staat, zijn
tips die ik uit mijn hoofd ken, en tips vanuit mijn oude Tips-HOWTO
(Waarom zou je er fatsoenlijke tips uithalen, nietwaar?). 
Dus stuur al je favoriete tips naar me op, zodat ik ze in de volgende
Tips-HOWTO kan plaatsen.
<P>Paul Anderson <EM>Maintainer--Linux TIPS HOWTO</EM>
<P><CODE>panderso@ebtech.net</CODE>
<H2><A NAME="s2">2. Kleine Tips</A></H2>

<H2>2.1 Handige Syslog Truuk <I>Paul Anderson, Tips-HOWTO maintainer</I></H2>

<P>Wijzig je /etc/syslog.conf, en plaats daarin de volgende regel:
<BLOCKQUOTE><CODE>
<PRE>
# Dump alles naar tty8
*.*                                     /dev/tty8
</PRE>
</CODE></BLOCKQUOTE>

Een voorbehoud: <I>DENK ERAAN TABS TE GEBRUIKEN!</I>  syslog houdt niet van spaties...
<H2>2.2 Script om die gecomprimeerde HOWTO's te bekijken. <I>Didier Juges,</I> <CODE>dj@destin.nfds.net</CODE></H2>

<P>
<P>Voor de ene aan de andere newbie is hier een klein script die het zoeken naar
en het bekijken van howto documenten vereenvoudigt.
Mijn howto's staan in /usr/doc/faq/howto/ en zijn met gzip gecomprimeerd.
De bestandsnamen zijn XXX-HOWTO.gz, met XXX als het onderwerp.
Ik maakte het volgende script aan met de naam "howto" in de directory
/usr/local/sbin:
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#!/bin/sh
if [ "$1" = "" ]; then
    ls /usr/doc/faq/howto | less
else
    gunzip -c /usr/doc/faq/howto/$1-HOWTO.gz | less
fi
</PRE>
<HR>
</CODE></BLOCKQUOTE>

Wanneer aangeroepen zonder argument, toont het een directory met de
beschikbare howto's. Wanneer vervolgens ingevoerd met het eerste deel
van de bestandsnaam (voor het koppelteken) als een argument, toont het
dan het gedecomprimeerde bestand (waarbij het origineel intact blijft).
<P>Om bijvoorbeeld de Serial-HOWTO.gz te bekijken, typ je:
<P>$ howto Serial
<H2>2.3 Is er voldoende vrije ruimte??? <I>Hans Zoebelein,</I> <CODE>zocki@goldfish.cube.net</CODE></H2>

<P>Dit is een klein script waarmee van tijd tot tijd wordt gecontroleerd
of er voldoende vrije ruimte beschikbaar is op alles wat mount laat zien
(disks, cdrom, diskette...)
<P>Als de ruimte opraakt, wordt iedere X seconden op het scherm een
melding weergegeven en 1 mailbericht per gevuld device afgevuurd.
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#!/bin/sh

#
# $Id: Tips-HOWTO-NL.sgml,v 1.3 2003/11/22 14:36:34 bokkie Exp $
#

#
# Sinds ik tijdens het compileren mysterieuze foutmeldingen kreeg toen
# tmp bestanden mijn disks opvulden, schreef ik dit om een waarschuwing te
# krijgen voordat de disks vol zijn.
#
# Als hiermee werd voorkomen dat je servers explodeerde
# stuur dan een lovende email naar zocki@goldfish.cube.net.
# Als je site hierdoor afbrandt, dan sorry, maar ik heb je
# gewaarschuwd: geen klachten.
# Vergeef me alsjeblieft als je echt weet hoe met sed om te gaan :)
#

#
# Alle gekheid op een stokje: Plaats `check_hdspace &amp;' in rc.local.
# Controleer iedere $SLEEPTIME sec. op vrije ruimte op devices.
# Je zou zelfs je diskettes of tape drives erop kunnen controleren. :)
# Als de vrije ruimte onder de $MINFREE (kb) komt, zal er een waarschuwing
# op het scherm weerkaatsen en voor elke device waarop een tekort aan
# ruimte is geconstateerd een mail worden gestuurd aan $MAIL_TO_ME.
# Als er weer meer vrije ruimte is dan de limiet, gaat het ook weer gepaard
# met een mailactie.

# TEDOEN: Verschillende $MINFREE voor elk device.
# Bevrijd /*tmp dirs veilig van oude rommel als er geen vrije ruimte meer is.


DEVICES='/dev/sda2 /dev/sda8 /dev/sda9'         # device; hier plaats je disks
MINFREE=20480                                   # kb; hieronder een waarschuwing
SLEEPTIME=10                                    # sec; pauze tussen controles
MAIL_TO_ME='root@localhost'                     # dwaas; aan wie de waarschuwingsmail


# ------- geen wijzigingen nodig onder deze regel (hopelijk :) -------

MINMB=0
ISFREE=0
MAILED=""
let MINMB=$MINFREE/1024         # ja, we zijn strict :)

while [ 1 ]; do
        DF="`/bin/df`"
                for DEVICE in $DEVICES ; do
                ISFREE=`echo $DF | sed s#.\*$DEVICE" "\*[0-9]\*""\*[0-9]\*" "\*## | sed s#" ".\*##`
                
                if [ $ISFREE -le $MINFREE ] ; then
                        let ISMB=$ISFREE/1024
                        echo  "WAARSCHUWING: Slechts $ISMB vrij op $DEVICE." >&amp;2
                        #echo "meer code/tekst hier plaatsen" >&amp;2
                        echo -e "\a\a\a\a"
                        
                        if [ -z  "`echo $MAILED | grep -w $DEVICE`" ] ; then
                                echo "WAARSCHUWING: Slechts $ISMB vrij op $DEVICE.      (Trigger is ingesteld op $MINMB mb)" \
                                | mail -s "WAARSCHUWING: Slechts $ISMB vrij op $DEVICE!" $MAIL_TO_ME
                                MAILEDH="$MAILED $DEVICE"
                                MAILED=$MAILEDH
                                # plaats verdere acties, zoals opschonen van
                                # */tmp dirs hier...
                        fi
                        elif [ -n  "`echo $MAILED | grep -w $DEVICE`" ] ; then
                                # Verwijder mailed markering als er weer voldoende
                                # diskruimte is. Zodat we klaar staan voor nieuwe
                                # mailactie.
                                MAILEDH="`echo $MAILED  | sed s#$DEVICE##`"
                                MAILED=$MAILEDH
                        fi
                        
                done
                sleep $SLEEPTIME

done
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<H2>2.4 Util om je logbestanden op te schonen. <I>Paul Anderson, Tips-HOWTO Maintainer</I>></H2>

<P>Ben je net als ik, dan heb je een lijst met 430 subscribers, plus 100+ berichten
per dag die via UUCP binnenkomen. Wat moet een hacker met zulke grote logs?
Installeer chklogs, dat is wat je kunt doen.
Chklogs is geschreven door Emilio Grimaldo, <CODE>grimaldo@panama.iaehv.nl</CODE>,
en de huidige versie 1.8 is beschikbaar vanaf
ftp.iaehv.nl:/pub/users/grimaldo/chklogs-1.8.tar.gz.
Het is tamelijk eenvoudig te installeren (je zult natuurlijk de info
in de doc subdirectory erop nazien). Zodra je het hebt ge&iuml;nstalleerd,
voeg je als volgt een crontab record in:
<BLOCKQUOTE><CODE>
<PRE>
# Voer dagelijks chklogs uit om 9:00PM.
00 21 * * *       /usr/local/sbin/chklogs -m
</PRE>
</CODE></BLOCKQUOTE>
<H2>2.5 Handig script om core bestanden op te schonen<I>Otto Hammersmith,</I><CODE>ohammers@cu-online.com</CODE></H2>

<P>Maak een bestand aan met de naam rmcores (de auteur noemt het handle-cores) 
met daarin het volgende:
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#!/bin/sh
USAGE="$0 &lt;directory> &lt;message-file>"

if [ $# != 2 ] ; then
        echo $USAGE
        exit
fi

 echo Aan het verwijderen...
find $1 -name core -atime 7 -print -type f -exec rm {} \;

echo e-mailen
for name in `find $1 -name core -exec ls -l {} \; | cut -c16-24`
do
        echo $name
        cat $2 | mail $name
done
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>En laat het middels een cron job zeer vaak uitvoeren.
<H2>2.6 Directory's van het ene naar het andere bestandssysteem verplaatsen <I>Alan Cox,</I><CODE>A.Cox@swansea.ac.uk</CODE></H2>

<P>Snelle manier om een gehele structuur met bestanden van de ene naar de andere
disk te verplaatsen
<BLOCKQUOTE><CODE>
<PRE>
(cd /source/directory &amp;&amp; tar cf - . ) | (cd /dest/directory &amp;&amp; tar xvfp -)
</PRE>
</CODE></BLOCKQUOTE>

<I>[ Wijziging van cd /source/directory; tar....enz.  
ter voorkoming van een ramp waarmee de directory mogelijk wordt verwijderd.
Met dank aan Jim Dennis, jim@starshine.org, dat hij me dit liet weten.
-Maint. ]</I>
<H2>2.7 Uitzoeken wat de grootste directory's zijn. <I>Mick Ghazey,</I><CODE>mick@lowdown.com</CODE></H2>

<P>Je ooit afgevraagd welke directory's het grootst zijn op je computer?  
Zo kom je daar achter.
<BLOCKQUOTE><CODE>
<PRE>
du -S | sort -n
</PRE>
</CODE></BLOCKQUOTE>
<H2>2.8 De Linux Gazette</H2>

<P>Eer komt John Fisk toe, oprichter van de Linux Gazette. Dit is een uitstekend
e-zine en het is <B>GRATIS!!!</B>  Wat valt er meer te wensen?
Bekijk het op:
<BLOCKQUOTE><CODE>
<PRE>
http://www.linuxgazette.com
</PRE>
</CODE></BLOCKQUOTE>

BTW, Het schijnt dat (1) LG nu per maand uitkomt, en (2) 
John Fisk het niet langer onderhoudt, de lui bij SSC doen dit.
<H2>2.9 Verwijzer naar patch voor GNU Make 3.70 om het functioneren vanVPATH te wijzigen.<I>Ted Stern,</I> <CODE>stern@amath.washington.edu</CODE></H2>

<P>Ik weet niet of veel mensen dit probleem hebben, maar er is een "faciliteit"
van GNU make versie 3.70 die ik niet prettig vind. Het gaat erom dat VPATH
zich raar gedraagt als je het een absolute padnaam opgeeft. Er is een
uiterst degelijke patch waarmee dit wordt gecorrigeerd, die je kunt krijgen
van Paul D. Smith <CODE>&lt;psmith@wellfleet.com></CODE>.  Hij post de documentatie
en patch ook na elke revisie van GNU make in de nieuwsgroep
&quot;gnu.utils.bug&quot; Over het algemeen pas ik deze patch toe en 
hercompileer gmake op elk systeem waarop ik toegang heb.
<H2>2.10 Hoe stop ik mijn systeem dat het fsck uitvoert bij elke reboot? <I>Dale Lutz,</I> <CODE>dal@wimsey.com</CODE></H2>

<P>V:  Hoe stop ik e2fsck dat het mijn disk elke keer bij het booten controleert.
<P>A:  Wanneer je de kernel opnieuw bouwt, wordt het bestandssysteem als
`dirty' gemarkeerd en dus zal je disk bij elke boot worden gecontroleerd.
Je kunt dit corrigeren door het opstarten van:
<P>rdev -R /zImage 1
<P>Dit corrigeert de kernel zodat het er niet langer van overtuigd is dat
het bestandssysteem `dirty' is.
<P><EM>Noot: Voeg als je lilo gebruikt </EM><CODE>read-only</CODE> toe <EM>aan je linux
setup in je lilo config bestand (gewoonlijk /etc/lilo.conf) </EM>
<H2>2.11 Hoe fsck's te voorkomen door een "device busy" tijdens het booten. <I>Jon Tombs,</I> <CODE>jon@gtex02.us.es</CODE></H2>

<P>Als je vaak device busy fouten krijgt bij een shutdown die veroorzaken
dat op het bestandssysteem bij een reboot een fsck moet worden toegepast,
dan is hier een eenvoudige correctie:
<P>Voeg aan <CODE>/etc/rc.d/init.d/halt</CODE> of <CODE>/etc/rc.d/rc.0</CODE>
de regel
<BLOCKQUOTE><CODE>
<PRE>
mount -o remount,ro /mount.dir
</PRE>
</CODE></BLOCKQUOTE>

toe voor alle gemounte bestandssystemen, behalve voor /, voor de aanroep
naar umount -a. Dit betekent dat als het een shutdown om de een of andere reden 
niet lukt alle processen te killen en de disks te unmounten, ze bij een reboot
toch clean zullen zijn. Het bespaart mij bij een reboot een heleboel tijd.
<H2>2.12 Hoe de grootste bestanden op je harddisk te vinden.<I>Simon Amor,</I> <CODE>simon@foobar.co.uk</CODE></H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
ls -l | sort +4n
</PRE>
</CODE></BLOCKQUOTE>
<P>Of voor degenen voor wie de ruimte er werkelijk op aankomt duurt dit wel
even, maar het werkt geweldig:
<P>
<BLOCKQUOTE><CODE>
<PRE>
cd /
ls -lR | sort +4n
</PRE>
</CODE></BLOCKQUOTE>
<H2>2.13 Hoe druk ik pagina's af met een marge voor perforatiegaten. <I>Mike Dickey,</I> <CODE>mdickey@thorplus.lib.purdue.edu</CODE></H2>

<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
        #!/bin/sh
        # /usr/local/bin/print
        # een eenvoudige opgemaakte afdruk, om het iemand mogelijk te maken
        # 3 gaten in de uitvoer te ponsen en het samen te binden

        cat $1 | pr -t -o 5 -w 85 | lpr
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<H2>2.14 Een manier om bestandsstructuren te doorzoeken op een bepaaldereguliere expressie.<I>Raul Deluth Miller,</I> <CODE>rockwell@nova.umd.edu</CODE></H2>

<P>Ik noem dit script 'forall'.  Gebruik het als volgt:
<BLOCKQUOTE><CODE>
<PRE>
forall /usr/include grep -i ioctl
forall /usr/man grep ioctl
</PRE>
</CODE></BLOCKQUOTE>

Hier is forall:
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#!/bin/sh
if [ 1 = `expr 2 \> $#` ]
then
        echo Gebruik: $0 dir cmd [optargs]
        exit 1
fi
dir=$1
shift
find $dir -type f -print | xargs "$@"
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<H2>2.15 Een script voor opschonen nadat programma's autosave en backup bestanden hebben aangemaakt <I>Barry Tolnas,</I> <CODE>tolnas@nestor.engr.utk.edu</CODE></H2>

<P>Hier is een simpel tweeregelig script waarmee directory's worden afgedaald
om emacs auto-save (#) en backup (~) bestanden, .o bestanden en
TeX .log bestanden te verwijderen. Het comprimeert tevens .tex bestanden
en README bestanden. Ik noem het op mijn systeem 'squeeze'.
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#!/bin/sh
#SQUEEZE verwijdert onnodige bestanden en comprimeert .tex en README bestanden
#Door Barry tolnas, tolnas@sun1.engr.utk.edu
#
echo squeezing $PWD
find  $PWD \( -name \*~ -or -name \*.o -or -name \*.log -or -name \*\#\) -exec
rm -f {} \;
find $PWD \( -name \*.tex -or -name \*README\* -or -name \*readme\* \) -exec gzip -9 {} \;
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<H2>2.16 Hoe kom ik erachter welke processen het meeste geheugen in beslag nemen. <I>Simon Amor,</I> <CODE>simon@foobar.co.uk</CODE></H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
ps -aux | sort +4n
</PRE>
</CODE></BLOCKQUOTE>

-OF-
<BLOCKQUOTE><CODE>
<PRE>
ps -aux | sort +5n
</PRE>
</CODE></BLOCKQUOTE>
<H2>2.17 Vi optuigen voor het programmeren in C, <I>Paul Anderson,</I><CODE>Tips-HOWTO Maintainer</CODE></H2>

<P>Ik programmeer in mijn vrije tijd nogal wat in C en ik heb er de tijd voor
genomen vi op te tuigen zodanig dat het C vriendelijk is. Hier is mijn .exrc:
<BLOCKQUOTE><CODE>
<HR>
<PRE>
set autoindent
set shiftwidth=4
set backspace=2
set ruler
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>Wat doet het?  autoindent zorgt dat vi automatisch elke regel volgend op de
eerste inspringt, shiftwidth stelt de afstand van ^T in op 4 spaties, backspace
stelt de backspace modus in, en ruler zorgt dat het regelnummer wordt
weergegeven. Denk eraan, om naar een specifiek regelnummer te gaan, stel 20, 
gebruik je:
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
vi +20 myfile.c
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<H2>2.18 Gebruik ctags om het programmeren te vereenvoudigen</H2>

<P>De meeste hackers hebben ctags reeds op hun computers, maar gebruiken het niet.
Het kan erg handig zijn voor het wijzigen van specifieke functies. Stel dat je
een functie hebt in &eacute;&eacute;n van de vele bronbestanden in een
directory voor een programma dat je aan het schrijven bent, en je wilt deze
functie vanwege updates wijzigen. We zullen deze functie foo() noemen.
Je weet niet waar het zich in het bronbestand bevindt. Hier komt ctags
om de hoek kijken. Wanneer het wordt uitgevoerd, produceert ctags een bestand
met de naam tags in de huidige dir, wat uit een opsomming bestaat met alle
functies, in welke bestanden deze zich bevinden en waar in het bestand.
Het bestand tags ziet er ongeveer zo uit:
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>

ActiveIconManager       iconmgr.c       /^void ActiveIconManager(active)$/
AddDefaultBindings      add_window.c    /^AddDefaultBindings ()$/
AddEndResize    resize.c        /^AddEndResize(tmp_win)$/
AddFuncButton   menus.c /^Bool AddFuncButton (num, cont, mods, func, menu, item)$/
AddFuncKey      menus.c /^Bool AddFuncKey (name, cont, mods, func, menu, win_name, action)$/
AddIconManager  iconmgr.c       /^WList *AddIconManager(tmp_win)$/
AddIconRegion   icons.c /^AddIconRegion(geom, grav1, grav2, stepx, stepy)$/
AddStartResize  resize.c        /^AddStartResize(tmp_win, x, y, w, h)$/
AddToClientsList        workmgr.c       /^void AddToClientsList (workspace, client)$/
AddToList       list.c  /^AddToList(list_head, name, ptr)$/
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>Om bijvoorbeeld AddEndResize() met vim te wijzigen, geef je op:
<P>
<BLOCKQUOTE><CODE>
<PRE>
vim -t AddEndResize
</PRE>
</CODE></BLOCKQUOTE>

Hierdoor verschijnt het van toepassing zijnde bestand in de editor, met de
cursor aan het begin van de functie.
<H2>2.19 Waarom hangt sendmail 5 minuten bij het opstarten onder RedHat? <I>Paul Anderson,</I> <CODE>paul@geeky1.ebtech.net</CODE></H2>

<P>Dit is een tamelijk algemeen probleem. Ik weet niet of RedHat deze bug al
in hun distributie heeft gecorrigeerd, maar je kunt het zelf repareren.
Als je in het bestand /etc/hosts kijkt, zul je zien dat het er ongeveer zo uitziet:
<BLOCKQUOTE><CODE>
<PRE>
127.0.0.1               localhost       jebox
</PRE>
</CODE></BLOCKQUOTE>
<P>Wanneer sendmail start, zoekt het je hostnaam op (in dit voorbeeld, jebox).
Het bemerkt dan dat het IP van jebox 127.0.0.1 is. Sendmail heeft hier
problemen mee, dus voert het de zoekopdracht nogmaals uit. Het gaat hier een
tijdje mee verder totdat het uiteindelijk opgeeft en stopt. Het corrigeren
van het probleem is zeer eenvoudig. Wijzig het bestand /etc/hosts zodat het
er ongeveer zo uit komt te zien:
<BLOCKQUOTE><CODE>
<PRE>
127.0.0.1               localhost
10.56.142.1             jebox
</PRE>
</CODE></BLOCKQUOTE>
<H2>2.20 Hoe configureer ik RedHat voor gebruik van color-ls? <I>Paul Anderson,</I> <CODE>paul@geeky1.ebtech.net</CODE></H2>

<P>De distributie van RedHat wordt geleverd met color-ls.
Waarom ze het echter standaard niet voor kleurengebruik configureren, is
me een raadsel. Zo kun je het corrigeren.
<P>Typ als eerste: eval `DIRCOLORS`
<P>Vervolgens, alias ls='ls --color=auto'
<P>En plaats de 'alias.....' in /etc/bashrc
<H2>2.21 Hoe kom ik erachter welke library in /usr/lib een bepaalde functie bevat?  <I>Pawel Veselow,</I> <CODE>vps@unicorn.niimm.spb.su</CODE></H2>

<P>Wat als je aan het compileren bent en je hebt een library gemist die
moet worden gelinkt? Alle verslagen van gcc bestaan uit functienamen... Hier
is een simpele opdracht dat zal vinden waarnaar je op zoek bent:
<BLOCKQUOTE><CODE>
<PRE>
for i in *; do echo $i:;nm $i|grep tgetnum 2>/dev/null;done
</PRE>
</CODE></BLOCKQUOTE>
<P>tgetnum is hier de naam van de functie waar je naar op zoek bent.
<H2>2.22 Ik compileerde een klein testprogramma in C, maar toen ik het uit probeerde te voeren, kreeg ik geen uitvoer!</H2>

<P>Je hebt het programma waarschijnlijk in een binary met de naam test
gecompileerd, nietwaar? Linux heeft een programma met de naam test, 
die test of een bepaalde conditie waar is, het produceert nooit enige
uitvoer op het scherm. Probeer in plaats van gewoon test, het intikken
van: ./test
<H2><A NAME="s3">3. Gedetailleerde Tips</A></H2>

<H2>3.1 Delen van swappartities tussen Linux en Windows. <I>Tony Acero,</I> <CODE>ace3@midway.uchicago.edu</CODE></H2>

<P>
<OL>
<LI> Formatteer de partitie als een dospartitie, en cre&euml;er er het
Windows swapbestand op, maar draai windows nog niet. (Je wilt het swapbestand
op het moment nog leeghouden, zodat het goed comprimeert).</LI>
<LI> Boot linux en bewaar de partitie in een bestand.  
Als de partitie bijvoorbeeld /dev/hda8 is:
<BLOCKQUOTE><CODE>
<PRE>
dd if=/dev/hda8 of=/etc/dosswap
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI> Comprimeer het dosswap bestand; aangezien het praktisch allen
nullen zijn, zal het zeer goed comprimeren
<BLOCKQUOTE><CODE>
<PRE>
gzip -9 /etc/dosswap
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI> Voeg het volgende toe aan het /etc/rc bestand
om de swapspace onder Linux voor te bereiden en te installeren:

<EM>XXXXX is het aantal blokken in de swappartitie</EM>
<BLOCKQUOTE><CODE>
<PRE>
mkswap /dev/hda8 XXXXX
swapon -av   
</PRE>
</CODE></BLOCKQUOTE>

Zorg dat je een regel toevoegt in het /etc/fstab bestand voor de swappartitie</LI>
<LI> Als het package init/reboot /etc/brc of /sbin/brc ondersteunt, voeg
je het volgende toe aan /etc/brc, doe dit anders met de hand, wanneer je
in dos|os/2 boot en je de swappartitie weer wilt omzetten naar de dos/windows
versie:</LI>
</OL>
<P>
<BLOCKQUOTE><CODE>
<PRE>
swapoff -av
zcat /etc/dosswap.gz | dd of=/dev/hda8 bs=1k count=100
</PRE>
</CODE></BLOCKQUOTE>

# Merk op dat hiermee slechts de eerste 100 blokken naar de partitie worden
# teruggeschreven.
# Ik heb door ervaring gemerkt dat dit voldoende is
<P>&gt;  Wat zijn hier de voors en tegens van?
<P>Voors: je bespaart een substanti&euml;le hoeveelheid schijfruimte
<P>Tegens: Als stap 5 niet automatisch gaat, dan moet je eraan denken dit
met de hand te doen, en het vertraagt het rebootproces met een nanoseconde :-)
<H2>3.2 Wanhopige Undelete. <I>Michael Hamilton,</I> <CODE>michael@actrix.gen.nz</CODE></H2>

<P>Hier is een truuk die ik al een paar keer heb moeten gebruiken
<P>
<P>Als je per ongeluk een tekstbestand verwijdert, zoals bijvoorbeeld
wat email, of het resultaat van een programmeersessie op de late avond,
hoeft alles niet verloren te zijn. Als het bestand het ooit naar disk
haalde, d.w.z. dat het daar meer dan 30 seconden was, dan kan het zijn dat
de inhoud nog steeds op de diskpartitie voorkomt.
<P>Je kunt de opdracht grep gebruiken om de ruwe diskpartitie te doorzoeken
op de inhoud van het bestand.
<P>Ik verwijderde bijvoorbeeld onlangs per ongeluk een deel van m'n email.
Dus staakte ik onmiddellijk mijn activiteiten die deze partitie konden
wijzigen: in dit geval zag ik gewoon af van het opslaan van mijn
bestanden of het uitvoeren van compilaties, enz. Onder andere omstandigheden
heb ik me de moeilijkheid op de hals gehaald door het systeem in single
user modus te brengen en het bestandssysteem te unmounten.
<P>Ik paste toen de opdracht egrep toe op de diskpartitie:
in mijn geval bevond het emailbericht zich in /usr/local/home/michael/,
dus aan de uitvoer van df, kon ik zien dat dit op /dev/hdb5 was.
<BLOCKQUOTE><CODE>
<PRE>
  sputnik3:~ % df
    Filesystem         1024-blocks  Used Available Capacity Mounted on
    /dev/hda3              18621    9759     7901     55%   /
    /dev/hdb3             308852  258443    34458     88%   /usr
    /dev/hdb5             466896  407062    35720     92%   /usr/local

    sputnik3:~ % su
    Password:
    [michael@sputnik3 michael]# egrep -50 'ftp.+COL' /dev/hdb5 > /tmp/x
 
</PRE>
</CODE></BLOCKQUOTE>

Nu ben ik extreem voorzichtig wanneer ik met diskpartities aan de gang
ga, dus ik pauzeerde om er zeker van te zijn dat ik de syntax van de
opdracht begreep VOORDAT ik de return indrukte. In dit geval bevatte
de email het woord 'ftp' gevolgd door wat tekst gevolgd door het woord
`COL'. Het bericht bestond uit ongeveer 20 regels, dus gebruikte ik -50
om alle regels rondom de woorden te krijgen. Voorheen gebruikte ik altijd
-3000 om er zeker van te zijn dat ik alle regels kreeg van een of andere
broncode. Ik stuurde de uitvoer van egrep door naar een andere diskpartitie.
Hiermee voorkwam ik dat er over het bericht heengeschreven zou worden
waar ik naar aan het zoeken was.
<P>Vervolgens gebruikte ik strings om me te helpen de uitvoer te inspecteren.
<BLOCKQUOTE><CODE>
<PRE>
   strings /tmp/x | less
 
</PRE>
</CODE></BLOCKQUOTE>

Zeker weten dat de email zich daarin bevond.
<P>Deze methode is niet betrouwbaar; alle of een deel van de schijfruimte
kan reeds zijn hergebruikt.
<P>Deze truuk is waarschijnlijk alleen bruikbaar op single user systemen.
Op multi-user systemen met nogal wat diskactiviteit, kan de ruimte die je
hebt vrijgemaakt reeds weer zijn gebruikt. En de meesten van ons kunnen
niet zomaar de box vandaan trekken bij onze gebruikers wanneer we ooit
een bestand moeten herstellen.
<P>Op mijn systeem thuis is deze truuk me in de afgelopen paar jaar
bij ongeveer drie gelegenheden van pas gekomen - gewoonlijk wanneer ik
per ongeluk wat van het werk van die dag verwijderde.
Als waar ik aan werk het overleeft tot een punt waarvan ik het gevoel heb
dat ik een belangrijke voortgang hebt geboekt, wordt er op een diskette een backup van
gemaakt, dus ik heb deze truuk nog niet zo vaak nodig gehad.
<H2>3.3 Hoe gebruik te maken van de immutable vlag.<I>Jim Dennis,</I> <CODE>jadestar@rahul.net</CODE></H2>

<P>Gebruik de Immutable Flag
<P>Neem direct na de installatie en configuratie van je systeem
de /bin, /sbin, /usr/bin, /usr/sbin en /usr/lib door (plus
nog een paar van de andere gebruikelijke verdachte bestanden
en maak royaal gebruik van de opdracht 'chattr +i '.  Voeg dat ook
toe aan de kernelbestanden in root.  Nu 'mkdir /etc/.dist/'
kopieer alles vanuit /etc/ naar beneden (Ik doe dit in twee stappen
met /tmp/etcdist.tar ter voorkoming van recursie) in die directory.
(Optioneel kun je gewoon  /etc/.dist.tar.gz aanmaken) -- en
dat als immutable markeren.
<P>De reden voor dit alles is het beperken van de schade die je
als root kunt aanrichten. Je zal geen bestanden overschrijven
door een misplaatst omleidingsteken, en je zal het systeem niet
onbruikbaar achterlaten door een verdwaalde spatie in een
'rm -fr' opdracht (je kunt nog steeds heel wat schade aan je
gegevens aanrichten -- maar je libs en bins zullen veiliger zijn.
<P>Dit maakt ook een diversiteit aan beveiligings- en denial of
service uitbuitingen &oacute;f onmogelijk &oacute;f moeilijker (aangezien veel
daarvan erop vertrouwen een bestand te kunnen overschrijven
via de acties van een of ander SUID programma die *niet voorziet
in een willekeurige shellopdracht*).
<P>Het enige ongerief hierbij onstaat bij het bouwen en uitvoeren
van een 'make install' op diverse soorten systeembinary's.
Aan de andere kant voorkomt het ook dat een 'make install' 
de bestanden overschrijft. Wanneer je vergeet de Makefile
in te lezen en chattr -i toe te passen op de bestanden die
op het punt staan te worden overschreven (en de directory's
waaraan je bestanden toe wilt voegen) -- mislukt de make.
Je past er dan gewoon de chattr opdracht op toe en start
het opnieuw op. Je kunt die gelegenheid ook gebruiken om
je oude bin's, libs of wat dan ook naar een .old/ directory
te verplaatsen of ze hernoemen of er tar op toepassen of 
wat dan ook.
<H2>3.4 Een suggestie waar nieuwe software te plaatsen.<I>Jim Dennis,</I> <CODE>jadestar@rahul.net</CODE></H2>

<P>Alle nieuwe software begint onder /usr/local! of /usr/local/`hostname`
<P>Als je distributie /usr/local leeg laat, cre&euml;er dan een
/usr/local/src, /usr/local/bin enz en gebruik dat.
Plaatst de distributie zaken in de /usr/local structuur dan wil
je wellicht een 'mkdir /usr/local/`hostname`' uit laten voeren
en er de groep 'wheel' +w aan toekennen (ik maak het ook SUID en
SGID om ervan verzekerd te zijn dat elk lid van de wheel groep
daaronder alleen iets met eigen bestanden kan doen, en dat alle
aangemaakte bestanden zullen toebehoren aan de 'wheel' groep.
<P>Disciplineer jezelf nu om *ALTIJD! ALTIJD! ALTIJD!* nieuwe
packages onder /usr/local/src/.from/$WAAR_IK_HET_VANDAAN_HAALDE/
plaatst (voor de .tar of wat voor bestanden dan ook) en bouw ze onder
/usr/local/src (of .../$HOSTNAME/src). Zorg dat ze onder de
lokale hi&euml;rarchie worden ge&iuml;nstalleerd.
Plaats een symlink vanuit de lokale hi&euml;rarchie naar elk
element dat ergens anders naartoe gaat als het *beslist moet"
worden ge&iuml;nstalleerd in /bin, /usr/bin of elders.
<P>De reden hiervoor -- ook als is het wat meer werk -- is dat
het helpt isoleren waarvan een backup moeten worden gemaakt
en wat moet worden terruggezet van een backup of opnieuw
ge&iuml;nstalleerd in geval van een volledige herinstallatie
vanaf de distributiemedia (tegenwoordig gewoonlijk van een CD). 
Door gebruik te maken van een /usr/local/.from directory houd
je ook een informele log bij van waar je bronnen vandaan komen.
-- wat helpt wanneer je op zoek bent naar nieuwe updates -- en 
van groot belang kan zijn bij het monitoren van de 
security announcement lists.
<P>Een van mijn systemen thuis werd samengesteld voordat ik deze
maatregelen zelf toepaste. 
Ik heb nog maar erg weinig met de configuratie van mijn thuissysteem
gedaan en ik ben de *enige* persoon die het ooit gebruikt.
<P>Als contrast zijn de systemen die ik op het werk heb ingesteld
(toen mij hier de rol van systeembeheerder werd toevertrouwd)
allen op deze manier ingesteld --- beheerd door veel
contractanten en andere MIS mensen, zijn er een groot aantal
upgrades en installatie van packages op ge&iuml;nstalleerd.
Niettemin heb ik een zeer goede indruk welke elementen precies
werden geplaatst *na* de initi&euml;le installatie en configuratie.
<H2>3.5 Alle bestanden in een directory naar kleine letters omzetten. <I>Justin Dossey,</I> <CODE>dossey@ou.edu</CODE></H2>

<P>
<P>Ik nam notitie van een paar overmatig moeilijke of onnodige procedures
aanbevolen in de 2c tips sectie van Issue 12. Aangezien er meer
van zijn, stuur ik het je op:
<BLOCKQUOTE><CODE>
<HR>
<PRE>
#!/bin/sh
         # lowerit
         # zet alle bestandsnamen in de huidige directory om naar kleine letters
         # werkt alleen met gewone bestanden--wijzigt geen directorynamen
         # zal vragen om verificatie voor een bestaand bestand te overschrijven
         for x in `ls`
           do
           if [ ! -f $x ]; then
             continue
             fi
           lc=`echo $x  | tr '[A-Z]' '[a-z]'`
           if [ $lc != $x ]; then
             mv -i $x $lc
           fi
           done
</PRE>
<HR>
</CODE></BLOCKQUOTE>

Wauw. Dat is een lang script. Ik zou daarvoor geen script schrijven, ik
zou in plaats daarvan deze opdracht gebruiken:
<BLOCKQUOTE><CODE>
<PRE>
for i in * ; do [ -f $i ] &amp;&amp; mv -i $i `echo $i | tr '[A-Z]' '[a-z]'`;
done;
</PRE>
</CODE></BLOCKQUOTE>

op de opdrachtregel.
<P>Degene die het aanleverde zei dat de wijze waarop hij het script schreef
hij dit voor de leesbaarheid deed (zie hieronder).
<P>Op naar de volgende tip, deze over het toevoegen en verwijderen van 
gebruikers. Het gaat Geoff goed af tot aan de laatste stap.
Reboot? Tjonge, ik hoop niet dat hij reboot elke keer als hij een gebruiker
verwijdert. Het enige dat je hoeft te doen, is het uitvoeren van de eerste
twee stappen.  Welk type processen zou die gebruiker hebben lopen?
Een irc bot?  Het killen van de processen met een simpel
<BLOCKQUOTE><CODE>
<PRE>
kill -9 `ps -aux |grep ^&lt;username> |tr -s " " |cut -d " " -f2`
</PRE>
</CODE></BLOCKQUOTE>

Voorbeeld, gebruikersnaam is foo
<BLOCKQUOTE><CODE>
<PRE>
kill -9 `ps -aux |grep ^foo |tr -s " " |cut -d " " -f2`
</PRE>
</CODE></BLOCKQUOTE>

Laten we daarmee te hebben afgerekend, verdergaan met het vergeten
root-wachtwoord.
<P>De oplossing gegeven in de Gazette is de meest universele, maar niet de
eenvoudigste.  Met zowel LILO als loadlin, kan met het opgeven van de
bootparameter &quot;single&quot; direct in de standaardshell zonder
login of password prompt worden geboot. Vanaf daar, kan met elk wachtwoord
wijzigen of verwijderen voor het typen van
&quot;init 3&quot; om in multiuser modus te starten.
Aantal reboots: 1
De andere manier
Aantal reboots: 2
<P>
<P>Justin Dossey
<H2>3.6 Hoe Sendmail upgraden<I>Paul Anderson,</I> <CODE>paul@geeky1.ebtech.net</CODE></H2>

<P>We beginnen vanuit de ruwe, zuivere broncode. Zorg eerst dat je aan de sendmail
broncode komt.
Ik heb versie 8.9.0, wat zoals je op zal vallen, het nieuwste van het
nieuwste is. Ik haalde het vanaf 
ftp.sendmail.org:/pub/sendmail/sendmail.8.9.0.tar.gz
<P>Het is ongeveer 1Meg, en in overweging nemend dat ik 8.7.6 draai, 
denk ik dat het de moeite waard is. Als dit werkt, zul je dit ongetwijfeld te
horen krijgen, anders kan ik de nieuwe HOWTO versies er niet uitkrijgen
zonder e-mail:)
<P>Pak het uit, nu je de broncode hebt.  Er zal in de huidige
directory een dir met de naam <CODE>sendmail-8.9.0</CODE> worden aangemaakt.  Ga
naar die directory en lees de bestanden README en RELEASE_NOTES 
(en verbaas je over de updates die zijn gedaan).
Ga nu met cd naar src. Hier zal je meeste werk worden uitgevoerd.
<P><EM>Een beknopte notitie: Sendmail is een klein, krachtig en goed geschreven
programma. De sendmail binary zelf compileert in minder dan 5 minuten
op mijn 5x86 133 met 32Megs RAM!  De gehele compilatie en
installatie nam (zonder config) minder dan 15 minuten in beslag!</EM>
<P>Normaal gesproken gebruik ik BIND niet op mijn systeem, dus ik trof de
regels
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
# ifndef NAMED_BIND
#  define NAMED_BIND    1       /* gebruik Berkeley Internet Domain Server */
# endif
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>aan en wijzigde de 1 in een 0, ala:
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
# ifndef NAMED_BIND
#  define NAMED_BIND    0       /* gebruik Berkeley Internet Domain Server */
# endif
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>Onder Debian 1.3.1, is db.h standaard ge&iuml;nstalleerd in /usr/include/db, 
in plaats van in /usr/include, waar sendmail het hoopt te vinden. 
Ga naar de src, mailstats, makemap, praliases, rmail en smrsh directory's 
en voer de volgende opdracht uit:
<P>
<BLOCKQUOTE><CODE>
<PRE>
 ./Build -I/usr/include/db
</PRE>
</CODE></BLOCKQUOTE>
<P>Zodra je dat hebt gedaan, cd .. en typ make install. Dat is het!  Sendmail
versie 8.9.0 zou nu moeten zijn ge&iuml;nstalleerd!  
Dit uiteraard in de veronderstelling dat je reeds een originele configuratie
hebt. Om alles op mijn systeem soepel te laten werken, moest ik het volgende
aan het begin van /etc/sendmail.cf toevoegen, aangezien ik vrije mailinglists
host voor mensen die majordomo gebruiken:
<P>
<BLOCKQUOTE><CODE>
<HR>
<PRE>
O DontBlameSendmail=forwardfileinunsafedirpath, forwardfileinunsafedirpathsafe
</PRE>
<HR>
</CODE></BLOCKQUOTE>
<P>Sendmail 8.9.0 is tegenwoordig nogal eigenzinnig als het gaat om directory-
en bestandspermissies, en het zal meldingen geven over dirs en bestanden
in aliases of .forward bestanden die voor de groep of wereld schrijfbaar
zijn. Ondanks dat het niet verstandig is deze eigenzinnigheid te deactiveren,
draai ik het als enige persoon op de console en ik vond dat het ok was dit
kleine beveiligingsgat toe te staan.
YMMV.
<H2>3.7 Een aantal tips voor nieuwe systeembeheerders.<I>Jim Dennis,</I> <CODE>jadestar@rahul.net</CODE></H2>

<P>Cre&euml;er en onderhoud een /README.`hostname` en/of een
/etc/README.`hostname`
<EM>[Of mogelijk /usr/local/etc/README.`hostname` -Maint. ]</EM>
<P>Maak vanaf *de eerste dag* dat je een systeem beheert,
notities in een online logbestand. Je zou een 
&quot;vi /README.$(hostname)&quot; een regel in root's 
&nbsp;/bash_logout aan kunnen maken.
Een andere manier om dit te doen is het schrijven van een su of
sudo script die iets dergelijks doet als in:
<BLOCKQUOTE><CODE>
<PRE>
                function exit \
                        { unset exit; exit; \
                          cat ~/tmp/session.$(date +%y%m%d) \
                          >> /README.$(hostname) &amp;&amp; \
                          vi /README.$(hostname)
                          }
                script -a ~/tmp/session.$(date +%y%m%d)
                /bin/su.org -
</PRE>
</CODE></BLOCKQUOTE>
<P>(gebruik de opdracht typescript om een sessielog
te cre&euml;ren en maak een functie aan voor het automatisch
toevoegen en bijwerken van de log).
<P>Ik geef toe dat ik  het automatiseren van dit beleid niet heb
ge&iuml;mplementeerd. Ik vertrouwde tot dusverre op 
zelfdiscipline.
Ik heb echter met het idee gespeeld (zelfs tot aan het punt
vooraf intypen van de scripts en shellfuncties zoals je ze
hier ziet). Een ding dat me weerhoudt is de 'script' opdracht zelf.
Ik denk dat ik een paar opdrachtregelparameters aan de broncode
toe moet voegen (voor een pause/stop van het scriptopname vanaf
de opdrachtregel) voordat ik ze aanlever voor gebruik.
<P>Mijn laatste suggestie (voor deze ronde):
<P>Het pad van root zou moeten bestaan uit 'PATH=&nbsp;/bin'
<P>Dat is alles. Niets meer in het pad van root. Alles wat root
doet wordt geleverd door een symlink vanuit &nbsp;/bin of door een
alias of shellfunctie of is een script of binary in &nbsp;/bin, of
wordt uitgetikt met een expliciet pad.
<P>Dit maakt iedereen draaiend als root zich bewust (soms pijnlijk
bewust) van hoe hij/zij binaire bestanden vertrouwt. De verstandige
beheerder van een multi-user host zal periodiek zijn &nbsp;/bin en
&nbsp;/.*history bestanden doorzoeken op bepaalde patronen en 
loopholes.
<P>De echt gemotiveerde beheerder zal reeksen ontdekken die kunnen
worden geautomatiseerd, plaatsen waar veiligheidscontroles kunnen
worden ingevoegd, en taken waarvoor &quot;root&quot; privileges
tijdelijk zouden moeten worden vermeden
(opstarten van editors, MTA's en andere grote interactieve
programma's met uitgebreide scriptmogelijkheden die in
transparante of gegevensbestanden, *zouden* kunnen worden ingesloten
zoals de befaamde vi ./.exrc en emacs ./.emacs en de zelfs
meer verraderlijke $EXINIT en ingesloten header/footer
macro's). Vanzelfspreken kunnen dergelijke opdrachten worden
uitgevoerd met iets als:
<BLOCKQUOTE><CODE>
<PRE>
                cp $data $some_users_home/tmp
                su -c $origcommand $whatever_switches
                cp $some_users_home/tmp $data
</PRE>
</CODE></BLOCKQUOTE>

(...waar de details afhangen van de opdracht).
<P>De meeste van deze voorzorgsmaatregelen zijn voor de home- of voor een
&quot;single&quot; user werkstation wat overdreven, maar vormen
een erg goed beleid voor de beheerder van een multi-user systeem ---
in het bijzonder wordt een publiek toegankelijk systeem (zoals die
van netcom).
<H2>3.8 Hoe xdm's chooser te configureren voor hostselectie<I>Arrigo Triulzi,</I> <CODE>a.triulzi@ic.ac.uk</CODE></H2>

<P>
<OL>
<LI> Wijzig het bestand waarmee xdm wordt opgestart,
naar alle waarschijnlijkheid is dit /etc/rc/rc.6 of /etc/rc.local),
zodanig dat in de xdm opstartsectie de volgende regels komen
te staan:

<BLOCKQUOTE><CODE>
<PRE>
        
/usr/bin/X11/xdm
exec /usr/bin/X11/X -indirect hostname
</PRE>
</CODE></BLOCKQUOTE>
</LI>
<LI> Wijzig /usr/lib/X11/xdm/Xservers en haal het commentaarteken weg
voor de regel die de server start op de lokale machine (d.w.z. de regel
beginnend met 0:)</LI>
<LI> Reboot de machine</LI>
</OL>
<P>Ik voeg dit toe omdat het me ongeveer een week kostte om alle problemen
de kop in te drukken toen ik het wanhopig
probeerde in te stellen voor mijn eigen subnet.
<P>Voorbehoud: met oude SLS (1.1.1) kun je om een of andere reden een -nodaemon
weglaten na de xdm regel -- dit werkt <B>NIET</B> met latere uitgaven.
</BODY>
</HTML>
