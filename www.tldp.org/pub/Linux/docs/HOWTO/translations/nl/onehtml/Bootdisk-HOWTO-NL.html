<HTML
><HEAD
><TITLE
>De Linux Bootdisk HOWTO</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"></HEAD
><BODY
CLASS="ARTICLE"
BACKGROUND="../IMAGES/back.gif"
LINK="#000099"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
></A
>De Linux Bootdisk HOWTO</H1
><H3
CLASS="AUTHOR"
><A
NAME="AEN5"
>Tom Fawcett</A
></H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:fawcett+BH@croftj.net"
>fawcett+BH@croftj.net</A
>&#62;</TT
><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
></DIV
><H3
CLASS="AUTHOR"
><A
NAME="AEN11"
>Vertaald door: Ellen Bokhorst</A
></H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
>	&nbsp;<TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:bokkie@nl.linux.org"
>bokkie@nl.linux.org</A
>&#62;</TT
><br>
	&nbsp;</P
></DIV
></DIV
><P
CLASS="COPYRIGHT"
>Copyright &copy; 1995,1996,1997,1998,1999,2000 Tom Fawcett en Graham Chapman.</P
><P
CLASS="PUBDATE"
>v4.0, april 2000<BR></P
><DIV
><DIV
CLASS="ABSTRACT"
><A
NAME="AEN24"
></A
><P
></P
><P
>In dit document wordt beschreven hoe je eigen boot/root diskettes
      voor Linux te ontwerpen. Deze disks kunnen als rescue-disks worden
      gebruikt of om nieuwe systeemcomponenten te testen.
      Je zou redelijk bekend moeten zijn met systeembeheertaken voor je
      een poging gaat wagen je eigen bootdisk te bouwen.
      Zie <A
HREF="#PREMADE"
>Appendix A.1</A
> als je slechts een rescue-disk voor
      noodgevallen wilt.
      </P
><P
></P
></DIV
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Inhoudsopgave</B
></DT
><DT
><A
HREF="#AEN27"
>Voorwoord</A
></DT
><DT
><A
HREF="#AEN72"
>Introductie</A
></DT
><DT
><A
HREF="#AEN92"
>Bootdisks en het bootproces</A
></DT
><DT
><A
HREF="#BUILDROOT"
>Bouwen van een rootbestandssysteem</A
></DT
><DT
><A
HREF="#AEN701"
>Uitkiezen van een kernel</A
></DT
><DT
><A
HREF="#AEN716"
>Het bijelkaar plaatsen: aanmaken van de diskette(s)</A
></DT
><DT
><A
HREF="#TROUBLESHOOTING"
>Probleemoplossing</A
></DT
><DT
><A
HREF="#AEN958"
>Diverse onderwerpen</A
></DT
><DT
><A
HREF="#PROS"
>Hoe de pro's het doen</A
></DT
><DT
><A
HREF="#AEN1097"
>Lijst met veel gestelde vragen (FAQ)</A
></DT
><DT
>A. <A
HREF="#AEN1281"
>Bronnen en verwijzingen</A
></DT
><DT
>B. <A
HREF="#AEN1390"
>LILO boot foutcodes</A
></DT
><DT
>C. <A
HREF="#LISTINGS"
>Voorbeeldlisting van een rootbestandssysteem</A
></DT
><DT
>D. <A
HREF="#UTILITYLIST"
>Voorbeeldlisting van een utilitydisk</A
></DT
></DL
></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN27"
></A
>Voorwoord</H2
><DIV
CLASS="IMPORTANT"
><P
></P
><TABLE
CLASS="IMPORTANT"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/IMAGES/important.gif"
HSPACE="5"
ALT="Belangrijk"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Het kan zijn dat dit document verouderd is. Als de datum op de 
      titelpagina ouder is dan 6 maanden, kijk dan alsjeblieft op de
      <A
HREF="http://www.croftj.net/~fawcett/Bootdisk-HOWTO/index.html"
TARGET="_top"
>      Bootdisk-HOWTO homepage</A
> of er een recentere versie is.
      </P
></TD
></TR
></TABLE
></DIV
><P
>Alhoewel dit document in tekstvorm leesbaar zou moeten zijn,
    ziet het er in Postscript, PDF of HTML, vanwege 
    de gebruikte typografische conventies veel beter uit.
    </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN33"
></A
>Versie notities</H3
><P
>Graham Chapman schreef de oorspronkelijke Bootdisk-HOWTO en hij
      ondersteunde het tot aan versie 3.1. Tom Fawcett begon als mede-auteur
      zo rond de tijd dat kernel v2 werd ge&iuml;ntroduceerd. Hij is de 
      huidige beheerder van het document.
      </P
><P
>Deze informatie is bedoeld voor Linux op het
      <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Intel</I
></SPAN
> platform. Veel van deze informatie kan
      ook toepasbaar zijn voor Linux op andere processors, maar we hebben
      hiermee geen ervaring uit de eerste hand. Neem alsjeblieft contact met
      ons op als je ervaring hebt met bootdisks voor andere platformen.
     </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN41"
></A
>Nog te doen</H3
><P
>      Enige vrijwilligers?

      <P
></P
><OL
TYPE="1"
><LI
><P
>            Beschrijf (of link naar een ander document dat beschrijft) hoe 
            andere op opstartbare disk lijkende dingen, zoals CDROM's,
            ZIP-disks en LS110-disks te maken.
            </P
></LI
><LI
><P
> Beschrijf hoe om te gaan met de zeer grote
            <TT
CLASS="FILENAME"
>libc.so</TT
> shared library's. De opties zijn
            voornamelijk om oudere, kleinere library's te krijgen of 
            bestaande library's kleiner te krijgen.
            </P
></LI
><LI
><P
> Heranalyseer distributie-bootdisks en werk de sectie
            "Hoe de Pro's het doen" bij.
            </P
></LI
><LI
><P
> Verwijder de sectie die beschrijft hoe bestaande
            distributie-bootdisks bij te werken. Dit geeft gewoonlijk meer
            problemen dan het waard is.
            </P
></LI
><LI
><P
>            Herschrijf/stroomlijn de sectie Probleemoplossing.
            </P
></LI
></OL
>
     </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN56"
></A
>Feedback en krediet</H3
><P
>Ik verwelkom alle feedback, goed of slecht, over de inhoud van
      dit document. Ik/we heb(ben) mijn/onze best gedaan er zeker van 
      te zijn dat
      de instructies en de informatie in dit document accuraat en betrouwbaar
      zijn. Laat het me alsjeblieft weten als je fouten vindt of als er iets 
      ontbreekt. <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Geef alsjeblieft het versienummer van het document
      op waarnaar je refereert</I
></SPAN
> als je schrijft.
      </P
><P
> We bedanken de vele mensen die ons assisteerde met correcties en
      suggesties. Hun bijdragen hebben het veel beter gemaakt dan we het
      ooit alleen voor elkaar zouden kunnen hebben krijgen.
      </P
><P
> Stuur opmerkingen, correcties, en vragen naar de auteur via
      het bovenstaande e-mailadres. Het maakt me niet uit je proberen antwoord
      te geven op vragen, maar als je een specifieke vraag hebt over waarom je
      bootdisk niet werkt,
      <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>lees dan alsjeblieft eerst de <A
HREF="#TROUBLESHOOTING"
>paragraaf <I
>Probleemoplossing</I
></A
>
      </I
></SPAN
>.
      </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN64"
></A
>Distributiebeleid</H3
><P
> Copyright &copy; 1995,1996,1997,1998,1999,2000 door Tom Fawcett
      en Graham Chapman. Dit document mag onder de voorwaarden uiteengezet in
      de <A
HREF="http://linuxdoc.org/copyright.html"
TARGET="_top"
>Linux Documentation
      Project Licentie</A
> worden gedistribueerd. Neem alsjeblieft contact
      op met de auteurs als het je niet lukt aan de licentie te komen.
      </P
><P
>Dit is vrije documentatie. Het wordt gedistribueerd in de hoop
      dat het van nut zal zijn, maar <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>zonder enige garantie
      </I
></SPAN
>; zelfs zonder de impliciete garantie van
      <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>verkoopbaarheid</I
></SPAN
> of <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>geschiktheid voor 
      een bepaald doel</I
></SPAN
>.
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN72"
></A
>Introductie</H2
><P
>Linux bootdisks zijn in een aantal situaties van nut, zoals bij het testen
van een nieuwe kernel, het herstellen van een diskstoring (alles van een
verloren bootsector tot een crash van de diskkoppen), het herstellen van een
gedeactiveerd systeem, of het veilig bijwerken van kritieke systeembestanden,
(zoals <TT
CLASS="FILENAME"
>libc.so</TT
>).</P
><P
>Er bestaan diverse manieren om aan bootdisks te komen:

<P
></P
><UL
><LI
><P
>Gebruik er &eacute;&eacute;n van een distributie, zoals Slackware. Hiervan
zal je op z'n minst kunnen booten.
          </P
></LI
><LI
><P
>Gebruik een rescue-package om disks in te stellen die zijn ontworpen om te
worden gebruikt als rescue-disks.
          </P
></LI
><LI
><P
>Leer wat nodig is voor ieder type disk en bouw dan je eigen disks.</P
></LI
></UL
>

Een aantal mensen kiest voor de laatste optie om het zelf te kunnen doen.
Dit zodat, als er iets niet goed gaat, ze het zelf op kunnen lossen.
Plus dat het een geweldige manier is om te leren hoe een Linux-systeem werkt.</P
><P
>In dit document wordt uitgegaan van een basiskennis van 
Linuxsysteembeheer concepten. Je zou bijvoorbeeld bekend moeten zijn met
directory's, bestandssystemen en diskettes. Je zou moeten weten hoe
<B
CLASS="COMMAND"
>mount</B
> en <B
CLASS="COMMAND"
>df</B
> te gebruiken. 
Je zou moeten weten waar de bestanden
<TT
CLASS="FILENAME"
>/etc/passwd</TT
> en <TT
CLASS="FILENAME"
>fstab</TT
> voor zijn
er hoe ze er uitzien. Je zou moeten weten dat de meeste opdrachten in deze
HOWTO als root zouden moeten worden uitgevoerd.</P
><P
>Het vanaf het begin samenstellen van je eigen bootdisk kan gecompliceerd
zijn. Als je de Linux FAQ en daaraan gerelateerde documenten, zoals de
Linux Installation Guide niet hebt gelezen, doe je er beter aan niet
te proberen bootdiskettes te bouwen.
Als je slechts een bootdisk voor noodgevallen nodig hebt, is het 
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>veel</I
></SPAN
> eenvoudiger een voorgefabriceerd exemplaar te
downloaden. Zie <A
HREF="#PREMADE"
>Appendix A.1</A
>, waar je deze kunt vinden.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN92"
></A
>Bootdisks en het bootproces</H2
><P
>Een bootdisk is eigenlijk een miniatuur, zelfbevattend Linux-systeem op een
diskette. Het moet veel dezelfde functies verrichten die door een volledig
Linux-systeem worden verricht. Voordat men zijn eigen bootdisk gaat bouwen,
zou men de basis van het Linux bootproces moeten begrijpen. We presenteren je
hier de basis, wat voldoende is voor het begrijpen van de rest van het document.
Veel details en alternatieve opties zijn achterwege gelaten.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN97"
></A
>Het bootproces</H3
><P
> 

Alle PC-systemen starten het bootproces door code in ROM (in het bijzonder
de <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>BIOS</I
></SPAN
>) uit te voeren om de sector vanaf sector 0, 
cylinder 0 van de bootdisk te laden. De bootdisk is gewoonlijk de diskette in
het eerste diskettestation (toegekend als <TT
CLASS="FILENAME"
>A:</TT
> in DOS en 
<TT
CLASS="FILENAME"
>/dev/fd0</TT
> onder Linux). De BIOS probeert dan deze sector
uit te voeren. Op de meeste opstartbare disks, bevat sector 0, cylinder 0
zowel:

<P
></P
><UL
><LI
><P
>code van een bootloader zoals LILO, die de kernel lokaliseert, het laadt en
het uitvoert om de boot zuiver te starten als&#13;</P
></LI
><LI
><P
>de start van een besturingssysteem zoals Linux.&#13;</P
></LI
></UL
>&#13;</P
><P
>Als een Linux-kernel raw naar diskette is gekopieerd, zal de eerste sector
de eerste sector van de Linux-kernel zelf zijn. Deze eerste sector zal het
bootproces vervolgen door de rest van de kernel vanaf het bootdevice te laden.</P
><P
>Zodra de kernel volledig is geladen, neemt het een basisinitialisatie van
devices door. Het probeert vervolgens een <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>root
bestandssysteem</I
></SPAN
> vanaf een device te laden en mounten. 
Een rootbestandssysteem is gewoon een bestandssysteem dat is gemount als
``<TT
CLASS="FILENAME"
>/</TT
>''. De kernel moet worden verteld waar naar het
rootbestandssysteem te zoeken; als het daar geen laadbaar image kan vinden,
stopt het.</P
><P
>In een aantal bootsituaties - vaak wanneer van diskette wordt
geboot - wordt het rootbestandssysteem in
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ramdisk</I
></SPAN
> geladen, dit is RAM die door het systeem 
als een disk wordt benaderd. Er zijn twee redenen waarom het systeem naar
ramdisk laadt. Ten eerste is RAM verscheidene malen sneller dan een diskette,
dus de werking van het systeem is snel; en ten tweede kan de kernel
een <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>gecomprimeerd bestandssysteem</I
></SPAN
> vanaf de diskette
laden en het in de ramdisk decomprimeren, waardoor het mogelijk is meer
bestanden op de diskette te persen.</P
><P
>Als het rootbestandssysteem &eacute;&eacute;nmaal is geladen en gemount,
zie je een melding als:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        VFS: Mounted root (ext2 filesystem) readonly.</PRE
></TD
></TR
></TABLE
></P
><P
>Hier vindt het systeem het programma <TT
CLASS="FILENAME"
>init</TT
>
op het rootbestandssysteem (in <TT
CLASS="FILENAME"
>/bin</TT
> of
<TT
CLASS="FILENAME"
>/sbin</TT
>) en voert het uit. <TT
CLASS="FILENAME"
>init</TT
>
leest zijn configuratiebestand <TT
CLASS="FILENAME"
>/etc/inittab</TT
> in, zoekt
naar een regel aangeduid met <TT
CLASS="LITERAL"
>sysinit</TT
>, en voert het in
die regel genoemde script uit. Het <TT
CLASS="LITERAL"
>sysinit</TT
> script is
gewoonlijk iets als <TT
CLASS="FILENAME"
>/etc/rc</TT
> of
<TT
CLASS="FILENAME"
>/etc/init.d/boot</TT
>.
Dit script bestaat uit een set shell-opdrachten waarmee basissysteemservices
worden ingesteld, zoals:</P
><P
></P
><UL
><LI
><P
>Het op alle disks uitvoeren van <B
CLASS="COMMAND"
>fsck</B
>,</P
></LI
><LI
><P
>Het laden van de benodigde kernelmodules,</P
></LI
><LI
><P
>Het starten van swappen,</P
></LI
><LI
><P
>Het initialiseren van het netwerk,</P
></LI
><LI
><P
>Het mounten van de disks vermeld in <TT
CLASS="FILENAME"
>fstab</TT
>.</P
></LI
></UL
><P
>Dit script roept vaak diverse andere scripts aan voor de modulaire
initialisatie. In bijvoorbeeld de structuur van SysVinit, bevat de
directory <TT
CLASS="FILENAME"
>/etc/rc.d/</TT
> een complexe structuur aan
subdirectory's waarvan de bestanden specificeren hoe de meeste
systeemservices te activeren of af te sluiten.
Op een bootdisk is het sysinit-script echter vaak heel simpel.</P
><P
>&#13;Wanneer het sysinit-script klaar is, geeft het de controle terug aan
<B
CLASS="COMMAND"
>init</B
>, die dan overgaat op het <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>standaard
runlevel</I
></SPAN
>, met het sleutelwoord <TT
CLASS="LITERAL"
>initdefault</TT
>
gespecificeerd in <TT
CLASS="FILENAME"
>inittab</TT
>. In de regel met het
runlevel wordt gewoonlijk een programma als <B
CLASS="COMMAND"
>getty</B
>
gespecificeerd, welke verantwoordelijk is voor het afhandelen van 
communicaties op de console en tty's. Het is het <B
CLASS="COMMAND"
> getty</B
>
programma welke de bekende ``<TT
CLASS="PROMPT"
>login:</TT
>'' prompt afdrukt.
Het <B
CLASS="COMMAND"
>getty</B
> programma roept op zijn beurt het programma
<B
CLASS="COMMAND"
>login</B
> aan om de loginvalidatie af te handelen en
gebruikerssessies in te stellen.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN173"
></A
>Disktypes</H3
><P
>Na het basisbootproces te hebben ge&iuml;nspecteerd, kunnen we nu diverse
daarbij betrokken soorten disks defini&euml;ren.
We classificeren disks in vier typen. Bij de bespreking in dit gehele
document maken we, tenzij anders aangegeven, gebruik van de term
``disk'' om naar diskettes te refereren, alhoewel het meeste net zo goed
ook voor harddisks zou kunnen gelden.</P
><P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>boot</DT
><DD
><P
>Een disk met een kernel die kan worden geboot. De disk kan worden gebruikt
om de kernel te booten, die dan een rootbestandssysteem op een andere
disk kan laden. De kernel op een bootdisk moet gewoonlijk worden aangegeven
waar het zijn rootbestandssysteem kan vinden.</P
><P
>Vaak laadt een bootdisk een rootbestandssysteem van een andere diskette, maar
het is bij een bootdisk mogelijk het zo in te stellen dat het 't in plaats
daarvan een rootbestandssysteem van een harddisk laadt.
Dit wordt in het algemeen gedaan bij het testen van een nieuwe kernel (in 
feite zal ``<B
CLASS="COMMAND"
>make zdisk</B
>'' een dergelijke bootdisk
automatisch vanuit de kernel sourcecode aanmaken).</P
></DD
><DT
>root</DT
><DD
><P
>Een disk met een bestandssysteem met bestanden die nodig zijn om een
Linux-systeem te draaien. Een dergelijke disk hoeft niet noodzakelijkerwijs
een kernel of een bootloader te bevatten.&#13;</P
><P
>Een rootdisk kan onafhankelijk van enig andere disk worden gebruikt, zodra
de kernel is geboot. Gewoonlijk wordt de rootdisk automatisch naar een
ramdisk gekopieerd. Dit maakt dat de rootdisk veel sneller te benaderen is,
en het maakt het diskettestation vrij voor een utility-disk.</P
></DD
><DT
>boot/root</DT
><DD
><P
>Een disk met zowel de kernel als een rootbestandssysteem. Met andere
woorden, het bevat alles wat nodig is om te booten en een Linux-systeem
zonder harddisk te draaien. Het voordeel van dit type disk is dat het compact
is - alles wat nodig is op een enkele disk. De van alles geleidelijk
toenemende grootte betekent echter dat het, zelfs met compressie, in
toenemende mate moeilijker wordt alles op een enkele diskette te plaatsen.</P
></DD
><DT
>utility</DT
><DD
><P
>Een disk met een bestandssysteem, maar het is niet bedoeld te worden
gemount als een rootbestandssysteem. Het is een aanvullende gegevensdisk.
Je zou dit type disk kunnen gebruiken om aanvullende utility's mee te
vervoeren voor als je te veel hebt voor op je rootdisk.&#13;</P
></DD
></DL
></DIV
></P
><P
>In het algemeen bedoelen we wanneer we het hebben over ``het bouwen van een
bootdisk'', het aanmaken van zowel de boot (kernel) als de root (bestanden).
Ze mogen zowel samen (een enkele boot-/rootdisk) als apart (boot + rootdisks)
voorkomen. De meest flexibele benadering voor rescue-disks is waarschijnlijk
het gebruik van boot- en rootdiskettes, en &eacute;&eacute;n of meer
utility-diskettes voor datgene wat te veel is voor op deze disks.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="BUILDROOT"
></A
>Bouwen van een rootbestandssysteem</H2
><P
>Het aanmaken van het rootbestandssysteem bestaat uit het selecteren van de
bestanden die nodig zijn om het systeem te draaien. In deze sectie wordt
beschreven hoe een <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>gecomprimeerd rootbestandssysteem</I
></SPAN
>
te bouwen. Een minder gebruikelijke optie bestaat uit het bouwen van een
ongecomprimeerd bestandssysteem op een diskette dat direct als root
wordt gemount; dit alternatief wordt beschreven in de
<A
HREF="#NONRAMDISKROOT"
>paragraaf <I
>Niet-ramdisk rootbestandssystemen</I
></A
>.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN209"
></A
>Overzicht</H3
><P
>Op een rootbestandssysteem moet al datgene voorkomen wat nodig is om een
volledig Linux-systeem te ondersteunen. Hiervoor moeten op de disk de
minimum-vereisten voor een Linux-systeem worden opgenomen:</P
><P
>&#13;<P
></P
><UL
><LI
><P
>De basis bestandssysteemstructuuur,</P
></LI
><LI
><P
>&#13;Minimum set directory's: <TT
CLASS="FILENAME"
>/dev</TT
>,
<TT
CLASS="FILENAME"
>/proc</TT
>, 
<TT
CLASS="FILENAME"
>/bin</TT
>, 
<TT
CLASS="FILENAME"
>/etc</TT
>, 
<TT
CLASS="FILENAME"
>/lib</TT
>, 
<TT
CLASS="FILENAME"
>/usr</TT
>, 
<TT
CLASS="FILENAME"
>/tmp</TT
>,</P
></LI
><LI
><P
>Basisset utility's: <TT
CLASS="FILENAME"
>sh</TT
>, <TT
CLASS="FILENAME"
>ls</TT
>, <TT
CLASS="FILENAME"
>cp</TT
>,
<TT
CLASS="FILENAME"
>mv</TT
>, enz.,</P
></LI
><LI
><P
>Minimumset config bestanden: <TT
CLASS="FILENAME"
>rc, inittab, fstab</TT
>, enz.,</P
></LI
><LI
><P
>Devices: <TT
CLASS="FILENAME"
>/dev/hd*, /dev/tty*, /dev/fd0</TT
>, enz.,</P
></LI
><LI
><P
>Runtime library om in basisfuncties die door de utility's worden gebruikt te
voorzien.</P
></LI
></UL
>&#13;</P
><P
>Uiteraard is ieder systeem pas dan van nut als je er iets onder kunt draaien,
en een rootdiskette komt meestal alleen van pas als je iets kunt doen als:</P
><P
>&#13;<P
></P
><UL
><LI
><P
>&#13;Het controleren van een bestandssysteem op een andere disk, om bijvoorbeeld
je rootbestandssysteem op een harddisk te controleren, moet je Linux van een
andere disk kunnen booten, zoals je dat kan met een rootdiskettesysteem.
Vervolgens kun je 
<B
CLASS="COMMAND"
>fsck</B
> dan uitvoeren op je oorspronkelijke rootdisk terwijl
het niet is gemount.&#13;</P
></LI
><LI
><P
>Het herstellen van je gehele of gedeeltelijke oorspronkelijke
rootdisk vanaf een backup door gebruik te maken van archief- en compressie-
utility's zoals <TT
CLASS="FILENAME"
>cpio</TT
>, <TT
CLASS="FILENAME"
>tar</TT
>,
<TT
CLASS="FILENAME"
>gzip</TT
> en <TT
CLASS="FILENAME"
>ftape</TT
>.&#13;</P
></LI
></UL
>&#13;</P
><P
>&#13;We zullen beschrijven hoe een <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>gecomprimeerd</I
></SPAN
>
bestandssysteem op een ramdisk te bouwen. Het wordt zo genoemd omdat
het op disk is gecomprimeerd en bij het booten op een ramdisk wordt
gedecomprimeerd.
Met een gecomprimeerd bestandssysteem kunnen er veel bestanden
(bij benadering zes megabyte) op een standaard 1440K diskette.
Omdat het bestandssysteem veel groter is dan een diskette, kan het niet
op de diskette worden gebouwd. We moeten het elders bouwen, het
comprimeren, en dan naar diskette kopi&euml;ren.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CREATINGROOTFS"
></A
>Aanmaken van het bestandssysteem</H3
><P
>Om een dergelijk rootbestandssysteem te bouwen, heb je een reserve device
nodig welke groot genoeg is alle bestanden voor compressie te bevatten.
Je hebt een device nodig dat capabel is om ongeveer vier megabyte te bevatten.
Je hebt verscheidene keuzes:</P
><P
>&#13;<P
></P
><UL
><LI
><P
>Gebruik een <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ramdisk</I
></SPAN
> (<SPAN
CLASS="SYMBOL"
>DEVICE</SPAN
> =
<TT
CLASS="FILENAME"
>/dev/ram0</TT
>). In dit geval wordt geheugen gebruikt om
een diskette te simuleren. De ramdisk moet groot genoeg zijn voor een
bestandssysteem van passende grootte. Controleer je configuratiebestand
(<TT
CLASS="FILENAME"
>/etc/lilo.conf</TT
>) op een regel als <TT
CLASS="LITERAL"
>RAMDISK =
nnn</TT
> waarmee het maximum RAM dat in beslag kan worden genomen
door een ramdisk als je gebruik maakt van LILO. De standaardwaarde is
wat voldoende zou moeten zijn. Het is beter niet te proberen een dergelijke
ramdisk te gebruiken op een computer met minder dan 8MB RAM.

Controleer voor de zekerheid of je een device hebt als <TT
CLASS="FILENAME"
>/dev/ram0,
/dev/ram</TT
> of <TT
CLASS="FILENAME"
>/dev/ramdisk</TT
>. Als dit niet zo
is, maak <TT
CLASS="FILENAME"
>/dev/ram0</TT
> dan aan met
<B
CLASS="COMMAND"
>mknod</B
> (major nummer 1, minor 0).&#13;</P
></LI
><LI
><P
>Als je een ongebruikte harddiskpartitie hebt die groot genoeg is (verscheidene
megabytes) dan is dit acceptabel.&#13;</P
></LI
><LI
><P
>Gebruik een <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>loopback device</I
></SPAN
>, waarmee het mogelijk is
een diskbestand als een device te laten fungeren. Door gebruik te maken van
een loopback-device kun je op je harddisk een bestand van drie megabyte
aanmaken en er het bestandssysteem op bouwen. </P
><P
>Typ <B
CLASS="COMMAND"
>man losetup</B
> voor instructies over het gebruik van
loopback devices. Als je <B
CLASS="COMMAND"
>losetup</B
> niet hebt, kun je
het samen met compatibele versies van <B
CLASS="COMMAND"
>mount</B
> en
<B
CLASS="COMMAND"
>unmount</B
> verkrijgen vanuit het package
<TT
CLASS="FILENAME"
>util-linux</TT
> in de directory
<A
HREF="ftp://ftp.win.tue.nl/pub/linux/utils/util-linux/"
TARGET="_top"
><TT
CLASS="FILENAME"
>ftp://ftp.win.tue.nl/pub/linux/utils/util-linux/</TT
></A
>.</P
><P
>Als je op je systeem geen loop-device (<TT
CLASS="FILENAME"
>/dev/loop0</TT
>
<TT
CLASS="FILENAME"
>/dev/loop1</TT
>, enz.) hebt, zal je het aan moeten maken
met ``<B
CLASS="COMMAND"
>mknod /dev/loop0 b 7 0</B
>''. Zodra je deze
speciale <B
CLASS="COMMAND"
>mount</B
> en <B
CLASS="COMMAND"
>umount</B
> binary's hebt
ge&iuml;nstalleerd, maak je op een hardisk met voldoende capaciteit een
tijdelijk bestand aan (bv, <TT
CLASS="FILENAME"
>/tmp/fsfile</TT
>). Je kunt
een opdracht gebruiken als:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
>	dd if=/dev/zero of=/tmp/fsfile bs=1k count=<TT
CLASS="VARNAME"
>nnn</TT
></PRE
></TD
></TR
></TABLE
>
om een <TT
CLASS="VARNAME"
>nnn</TT
>-blockbestand aan te maken.</P
><P
>Gebruik hieronder dit bestand in plaats van <SPAN
CLASS="SYMBOL"
>DEVICE</SPAN
>.
Wanneer je een mount-opdracht aanroept, moet je de optie
<TT
CLASS="OPTION"
>-o loop</TT
> aan mount meegeven om aan te geven dat mount
een loopback-device gebruikt.

Bijvoorbeeld:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        mount -o loop -t ext2 /tmp/fsfile /mnt</PRE
></TD
></TR
></TABLE
>
zal <TT
CLASS="FILENAME"
>/tmp/fsfile</TT
> via een loopback device op het
mount point <TT
CLASS="FILENAME"
>/mnt</TT
> mounten. Een <B
CLASS="COMMAND"
>df</B
> 
zal dit bevestigen.</P
></LI
></UL
>&#13;</P
><P
>Nadat je voor &eacute;&eacute;n van deze opties hebt gekozen, prepareer je
het <SPAN
CLASS="SYMBOL"
>DEVICE</SPAN
> met:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        dd if=/dev/zero of=<SPAN
CLASS="SYMBOL"
>DEVICE</SPAN
> bs=1k count=4096</PRE
></TD
></TR
></TABLE
></P
><P
>Deze opdracht vult het device op met nullen.</P
><DIV
CLASS="IMPORTANT"
><P
></P
><TABLE
CLASS="IMPORTANT"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/IMAGES/important.gif"
HSPACE="5"
ALT="Belangrijk"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Het device met nullen opvullen is van groot belang omdat het bestandssysteem
later zal worden gecomprimeerd, dus alle ongebruikte delen zouden met
nullen moeten worden opgevuld om een maximum compressie te bereiken.
Houd dit feit in gedachten wanneer je bestanden vanaf je rootbestandssysteem
verwijdert. Het bestandssysteem zal de blokken correct vrijgeven,
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>maar het vult ze niet weer met nullen op</I
></SPAN
>. 
Als je veel verwijdert en kopieert, kan je gecomprimeerde bestandssysteem
uiteindelijk veel groter worden dan nodig is.</P
></TD
></TR
></TABLE
></DIV
><P
>&#13;

Maak vervolgens het bestandssysteem aan. De Linux-kernel herkent voor rootdisks
twee typen bestandssystemen die automatisch naar ramdisk worden gekopieerd.
Dit zijn minix en ext2, waarvan ext2 de voorkeur heeft. Als je ext2 gebruikt,
vind je het wellicht handig de optie
<TT
CLASS="LITERAL"
>-i</TT
> mee te geven om meer inodes dan de standaardwaarde
op te geven; <TT
CLASS="LITERAL"
>-i 2000</TT
> wordt aanbevolen zodat je geen
inodes te kort komt.
Als alternatief kun je op inodes besparen door veel van de onnodige
<TT
CLASS="FILENAME"
>/dev</TT
> bestanden te verwijderen.
<B
CLASS="COMMAND"
>mke2fs</B
> zal op een 1.44Mb diskette standaard 360 inodes
aanmaken. Ik merkte dat 120 inodes op mijn huidige rescue rootdiskette
ruim voldoende is, maar als je alle devices in de directory
<TT
CLASS="FILENAME"
>/dev</TT
> opneemt, dan zal het de 360 makkelijk overschrijden.
Het gebruik van een gecomprimeerd rootbestandssysteem maakt een groter
bestandssysteem mogelijk, en vandaar standaard meer inodes, maar mogelijk moet
je toch het aantal bestanden nog verminderen of het aantal inodes verhogen.</P
><P
>Dus de opdracht die je gaat gebruiken, ziet er ongeveer zo uit:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        mke2fs -m 0 -i 2000 <SPAN
CLASS="SYMBOL"
>DEVICE</SPAN
></PRE
></TD
></TR
></TABLE
></P
><P
>(Als je van een loopback-device gebruik maakt, moet <SPAN
CLASS="SYMBOL"
>DEVICE</SPAN
>
worden vervangen door het diskbestand).</P
><P
>De opdracht <B
CLASS="COMMAND"
>mke2fs</B
> zal automatisch de beschikbare
ruimte detecteren en zichzelf dienovereenkomstig configureren. De parameter
``<TT
CLASS="LITERAL"
>-m&nbsp;0</TT
>'' voorkomt dat er ruimte voor root wordt
gereserveerd, en daardoor blijft er meer bruikbare ruimte op de disk over.</P
><P
>Mount dan het device:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        mount -t ext2 <SPAN
CLASS="SYMBOL"
>DEVICE</SPAN
> /mnt</PRE
></TD
></TR
></TABLE
> 
(Je moet een mountpoint <TT
CLASS="FILENAME"
>/mnt</TT
> aanmaken als het nog niet
voorkomt). In de hiernavolgende secties zal ervan worden uitgegaan dat
alle namen van doeldirectory's zich relatief ten opzichte van
<TT
CLASS="FILENAME"
>/mnt</TT
> bevinden.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN333"
></A
>Het bestandssysteem vullen</H3
><P
>Hier is een redelijke minimumset directory's voor je rootbestandssysteem
<A
NAME="AEN336"
HREF="#FTN.AEN336"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
>:

<P
></P
><UL
><LI
><P
><TT
CLASS="FILENAME"
>/dev</TT
> -- Devices, vereist voor I/O</P
></LI
><LI
><P
><TT
CLASS="FILENAME"
>/proc</TT
> -- Directory stub vereist voor het
proc-bestandssysteem</P
></LI
><LI
><P
><TT
CLASS="FILENAME"
>/etc</TT
> -- Systeemconfiguratiebestanden</P
></LI
><LI
><P
><TT
CLASS="FILENAME"
>/sbin</TT
> -- Kritieke systeembinary's</P
></LI
><LI
><P
><TT
CLASS="FILENAME"
>/bin</TT
> -- Essenti&euml;le binary's die worden
aangemerkt als onderdeel van het systeem</P
></LI
><LI
><P
><TT
CLASS="FILENAME"
>/lib</TT
> -- Shared library's om te voorzien in run-time
support</P
></LI
><LI
><P
><TT
CLASS="FILENAME"
>/mnt</TT
> -- Een mountpoint voor het beheer van
andere disks</P
></LI
><LI
><P
><TT
CLASS="FILENAME"
>/usr</TT
> -- Extra utility's en applicaties</P
></LI
></UL
></P
><P
>&#13;Drie van deze directory's zullen op het rootbestandssysteem leeg zijn, dus
ze hoeven alleen met <B
CLASS="COMMAND"
>mkdir</B
> te worden aangemaakt. De
directory <TT
CLASS="FILENAME"
>/proc</TT
> is eigenlijk een stub waaronder het
proc-bestandssysteem wordt geplaatst. De directory's <TT
CLASS="FILENAME"
>/mnt</TT
>
en <TT
CLASS="FILENAME"
>/usr</TT
> zijn slechts mountpoints voor gebruik nadat het
boot/root systeem draait. Vandaar nogmaals, hoeven deze directory's alleen
te worden aangemaakt.</P
><P
>De overblijvende vier directory's worden in de volgende secties beschreven.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN370"
></A
>/dev</H4
><P
>Een <TT
CLASS="FILENAME"
>/dev</TT
> directory met voor alle devices een
speciaal bestand om door het systeem te worden gebruikt is voor ieder
Linux-systeem verplicht. De directory zelf is een normale directory en deze kan
met <TT
CLASS="LITERAL"
>mkdir</TT
> op de gebruikelijke wijze worden aangemaakt.
De speciale bestanden voor de devices moeten echter op een speciale manier,
met de opdracht <B
CLASS="COMMAND"
>mknod</B
> worden aangemaakt.</P
><P
> Er is echter een kortere weg. Kopieer de inhoud van je
bestaande <TT
CLASS="FILENAME"
>/dev</TT
> directory, en verwijder die bestanden
die je niet wilt. Het enige waar je op moet letten is dat je de speciale
bestanden voor de devices kopieert met de optie
<TT
CLASS="LITERAL"
>-R</TT
>. Hiermee zal de directory worden gekopieerd zonder
dat er zal worden geprobeerd de inhoud van de bestanden te kopi&euml;ren.
Zorg ervoor dat je de <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>hoofdletter <TT
CLASS="OPTION"
>R</TT
></I
></SPAN
>
gebruikt. De opdracht is:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        cp -dpR /dev /mnt</PRE
></TD
></TR
></TABLE
>
ervan uitgaande dat de diskette is gemount op <TT
CLASS="FILENAME"
>/mnt</TT
>. De
<TT
CLASS="LITERAL"
>dp</TT
> switches zorgen ervoor dat symbolische links als
links worden gekopieerd in plaats van dat het doelbestand wordt gebruikt en
dat de oorspronkelijke bestandskenmerken blijven behouden, dus dat de
informatie over de eigenaren blijft behouden.</P
><P
>Als je het op een moeilijke manier wilt doen, gebruik je
<TT
CLASS="LITERAL"
>ls -l</TT
> om de major en minor device-nummers voor de
gewenste devices weer te geven, en maak je ze aan op de diskette
met <TT
CLASS="LITERAL"
>mknod</TT
>.</P
><P
>Alhoewel de devices zijn gekopieerd, loont het de moeite na te kijken dat
alle door jou benodigde devices op de rescue-diskette zijn geplaatst.
<TT
CLASS="LITERAL"
>ftape</TT
> maakt bijvoorbeeld gebruik van tape devices, 
dus zal je alle tape devices moeten kopi&euml;ren als je van plan bent
je floppy tapedrive vanaf de bootdisk te benaderen.</P
><P
>Voor ieder speciaal apparaatbestand is een inode vereist, en inodes kunnen
zo nu en dan een schaarse bron vormen, vooral op diskette bestandssystemen.
Het heeft daarom zin alle niet benodigde speciale bestanden voor de devices
uit de directory <TT
CLASS="FILENAME"
>/dev</TT
> van de diskette te verwijderen.
Als je bijvoorbeeld geen SCSI-disks hebt, kun je alle apparaatbestanden te
beginnen met <TT
CLASS="LITERAL"
>sd</TT
> gerust verwijderen. Op vergelijkbare
wijze kunnen alle apparaatbestanden beginnend met <TT
CLASS="LITERAL"
>cua</TT
>
worden verwijderd, als je niet van plan bent je seri&euml;le poort te gaan
gebruiken.</P
><DIV
CLASS="IMPORTANT"
><P
></P
><TABLE
CLASS="IMPORTANT"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/IMAGES/important.gif"
HSPACE="5"
ALT="Belangrijk"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
> Zorg er in ieder geval voor dat je de volgende bestanden
in deze directory opneemt:
<TT
CLASS="FILENAME"
>console</TT
>, <TT
CLASS="FILENAME"
>kmem</TT
>,
<TT
CLASS="FILENAME"
>mem</TT
>, <TT
CLASS="FILENAME"
>null</TT
>,
<TT
CLASS="FILENAME"
>ram0</TT
> en <TT
CLASS="FILENAME"
>tty1</TT
>.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN403"
></A
>/etc</H4
><P
>In deze directory staan belangrijke configuratiebestanden. Op de meeste
systemen kunnen deze in drie groepen worden onderverdeeld:
<P
></P
><OL
TYPE="1"
><LI
><P
>Ten alle tijden vereist, <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>b.v.</I
></SPAN
> <TT
CLASS="FILENAME"
>rc</TT
>,
<TT
CLASS="FILENAME"
>fstab</TT
>, <TT
CLASS="FILENAME"
>passwd</TT
>.</P
></LI
><LI
><P
>Mogelijk nodig, maar niemand is daar al te zeker van.</P
></LI
><LI
><P
>Rommel die erin is geslopen.</P
></LI
></OL
>
Niet essenti&euml;le bestanden kunnen gewoonlijk worden ge&iuml;dentificeerd
met de opdracht:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        ls -ltru</PRE
></TD
></TR
></TABLE
>
Hiermee worden bestanden in omgekeerde volgorde op de laatst benaderde datum
weergegeven, dus als eventuele bestanden niet zijn benaderd, kunnen ze op een
rootdiskette achterwege worden gelaten.</P
><P
>Op mijn rootdiskettes heb ik het aantal configuratiebstanden onder de 15 weten
te houden. Dit reduceert mijn werk tot 3 sets bestanden:
<P
></P
><OL
TYPE="1"
><LI
><P
>Degenen die ik voor een boot/root-systeem moet configureren:
<P
></P
><OL
TYPE="a"
><LI
><P
><TT
CLASS="FILENAME"
>rc.d/*</TT
> -- systeem opstartscripts en scripts benodigd
bij het wijzigen van het runlevel.</P
></LI
><LI
><P
><TT
CLASS="FILENAME"
>fstab</TT
> -- lijst met te mounten bestandssystemen</P
></LI
><LI
><P
><TT
CLASS="FILENAME"
>inittab</TT
> -- parameters voor het
<B
CLASS="COMMAND"
>init</B
>-proces, het eerste proces dat bij de systeemstart
wordt gestart.</P
></LI
></OL
></P
></LI
><LI
><P
>Degenen die ik voor een boot/root-systeem op zou kunnen knappen:
<P
></P
><OL
TYPE="a"
><LI
><P
><TT
CLASS="FILENAME"
>passwd</TT
> -- lijst met gebruikers, homedirectory's, enz.</P
></LI
><LI
><P
><TT
CLASS="FILENAME"
>group</TT
> -- gebruikersgroepen.&#13;</P
></LI
><LI
><P
><TT
CLASS="FILENAME"
>shadow</TT
> -- wachtwoorden van gebruikers. 
Wellicht dat je deze niet hebt.&#13;</P
></LI
><LI
><P
><TT
CLASS="FILENAME"
>termcap</TT
> -- de terminal capaciteiten database.</P
></LI
></OL
></P
><P
>Als beveiliging van belang is, dan zouden <TT
CLASS="FILENAME"
>passwd</TT
> en
<TT
CLASS="FILENAME"
>shadow</TT
> moeten worden geoptimaliseerd om het
kopi&euml;ren van gebruikerswachtwoorden van het systeem te voorkomen
zodat ongewenste logins worden verworpen wanneer je vanaf een diskette
boot.</P
><P
>&#13;
Zorg ervoor dat in <TT
CLASS="FILENAME"
>passwd</TT
> om z'n minst
<TT
CLASS="LITERAL"
>root</TT
> voorkomt. Als je van plan bent andere gebruikers in
te laten loggen, zorg er dan voor dat de directory's en shells aanwezig zijn.</P
><P
><TT
CLASS="FILENAME"
>termcap</TT
>, de terminal database is meestal 
verscheidene kilobytes groot. De versie die je op je boot-/rootdiskette
gebruikt, zou zo moeten worden geoptimaliseerd, dat het slechts de te
gebruiken termainal(s) bevat, wat gewoonlijk slechts het 
<TT
CLASS="LITERAL"
>linux</TT
> of <TT
CLASS="LITERAL"
>linux-console</TT
> veld is.</P
></LI
><LI
><P
>De rest. Ze zijn op het moment actief dus laat ik ze met rust.</P
></LI
></OL
></P
><P
>Daarbuiten hoefde ik slechts twee bestanden te configureren en de inhoud
daarvan is verbazingwekkend weinig.

<P
></P
><UL
><LI
><P
>In <TT
CLASS="FILENAME"
>rc</TT
> zou moeten staan:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        #!/bin/sh       
        /bin/mount -av
        /bin/hostname Kangaroo</PRE
></TD
></TR
></TABLE
>

Zorg ervoor dat de directory's juist zijn. Het is niet echt nodig
<B
CLASS="COMMAND"
>hostname</B
> uit te voeren - het ziet er gewoon fraaier
uit als je het wel doet.&#13;</P
></LI
><LI
><P
>In <TT
CLASS="FILENAME"
>fstab</TT
> zou op z'n minst moeten staan:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        /dev/ram0       /               ext2    defaults
        /dev/fd0        /               ext2    defaults
        /proc           /proc           proc    defaults</PRE
></TD
></TR
></TABLE
>

Je kunt de velden vanuit je bestaande <TT
CLASS="FILENAME"
>fstab</TT
> kopi&euml;ren,
maar je zou de harddisk-partities niet automatisch moeten mounten; gebruik
in plaats daarvan de optie <TT
CLASS="LITERAL"
>noauto</TT
>. Je harddisk kan
beschadigd of onbereikbaar zijn als de bootdisk wordt gebruikt.</P
></LI
></UL
></P
><P
>Je moet je <TT
CLASS="FILENAME"
>inittab</TT
> zodanig wijzigen dat de regel
<TT
CLASS="LITERAL"
>sysinit</TT
> <TT
CLASS="FILENAME"
>rc</TT
>, of welk bootscript dan
ook zal worden gebruikt, wordt uitgevoerd. Als je er tevens zeker van wilt
zijn dat gebruikers niet in kunnen loggen via seri&euml;le poorten, plaats
dan een commentaarteken voor alle velden met <TT
CLASS="FILENAME"
>getty</TT
>
waarin een <TT
CLASS="FILENAME"
>ttys</TT
> of <TT
CLASS="FILENAME"
>ttyS</TT
> device aan
het einde van de regel is opgenomen. Laat de <TT
CLASS="FILENAME"
>tty</TT
> poorten
staan, zodat je op de console in kunt loggen.</P
><P
>Een minimaal <TT
CLASS="FILENAME"
>inittab</TT
> bestand ziet er als volgt uit:

<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        id:2:initdefault:
        si::sysinit:/etc/rc
        1:2345:respawn:/sbin/getty 9600 tty1
        2:23:respawn:/sbin/getty 9600 tty2</PRE
></TD
></TR
></TABLE
> 

Het <TT
CLASS="FILENAME"
>inittab</TT
> bestand definieert wat het systeem in diverse
toestanden uit zal voeren, waaronder bij het opstarten, het overgaan naar
multi-user mode, enz. Controleer de bestanden vermeld in
<TT
CLASS="FILENAME"
>inittab</TT
> zorgvuldig; als
<TT
CLASS="LITERAL"
>init</TT
> het vermelde programma niet kan vinden, zal de
bootdisk blijven hangen, en krijg je mogelijk zelfs geen foutmelding.</P
><P
>Een aantal programma's kan niet naar elders worden verplaatst, omdat andere
programma's hun lokaties hebben ingeprogrammeerd. Op mijn systeem bijvoorbeeld
is in <TT
CLASS="FILENAME"
>/etc/shutdown</TT
> <TT
CLASS="FILENAME"
>/etc/reboot</TT
> 
ingeprogrammeerd. Als ik <TT
CLASS="FILENAME"
>reboot</TT
> naar
<TT
CLASS="FILENAME"
>/bin/reboot</TT
> verplaats, en dan de opdracht
<TT
CLASS="LITERAL"
>shutdown</TT
> aanroep, zal de uitvoering ervan mislukken omdat
het 't bestand <TT
CLASS="LITERAL"
>reboot</TT
> niet kan vinden.</P
><P
>Kopieer voor de rest alle tekstbestanden plus alle uitvoerbare bestanden
in de directory <TT
CLASS="FILENAME"
>/etc</TT
> waarvan je niet zeker bent of je
ze niet nodig hebt. Raadpleeg als een leidraad de voorbeeldlisting in
<A
HREF="#LISTINGS"
>Aanhangsel C</A
>. Waarschijnlijk is het voldoende alleen die
bestanden te kopi&euml;ren, maar systemen verschillen nogal, dus je kunt
er niet zeker van zijn dat dezelfde set bestanden op je systeem equivalent
is aan de bestanden in de lijst. De enige zekere methode is te beginnen bij
<TT
CLASS="LITERAL"
>inittab</TT
> en alles uit te werken wat nodig is.</P
><P
>Op de meeste systemen wordt nu gebruik gemaakt van een
<TT
CLASS="FILENAME"
>/etc/rc.d/</TT
> directory waarin alle shell-scripts voor
de verschillende runlevels staan. Het minimum is een enkel
<TT
CLASS="FILENAME"
>rc</TT
> script, maar het kan eenvoudiger door gewoon 
het bestand <TT
CLASS="FILENAME"
>inittab</TT
> en de directory
<TT
CLASS="FILENAME"
>/etc/rc.d</TT
> vanaf je bestaande systeem te kopi&euml;ren
en de shell-scripts in de directory <TT
CLASS="FILENAME"
>rc.d</TT
> te ontdoen 
van verwerkingen die niet relevant zijn voor een systeemomgeving voor op
diskette.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN533"
></A
>/bin en /sbin</H4
><P
>&#13;De directory <TT
CLASS="FILENAME"
>/bin</TT
> is een prima plaats voor extra
utility's die je nodig hebt voor de uitvoering van basisbewerkingen,
utility's zoals <B
CLASS="COMMAND"
>ls</B
>, <B
CLASS="COMMAND"
>mv</B
>,
<B
CLASS="COMMAND"
>cat</B
> en <B
CLASS="COMMAND"
>dd</B
>. Zie 
<A
HREF="#LISTINGS"
>Aanhangsel C</A
> voor een voorbeeldlijst met bestanden die in
de directory's <B
CLASS="COMMAND"
>bin</B
> en <TT
CLASS="FILENAME"
>/sbin</TT
> 
worden geplaatst. Hierin zijn geen utility's opgenomen die nodig zijn om
gegevens vanaf een backup terug te zetten, zoals <B
CLASS="COMMAND"
>cpio</B
>,
<B
CLASS="COMMAND"
>tar</B
> en <B
CLASS="COMMAND"
>gzip</B
>. Dat komt doordat ik die
op een aparte utility-diskette plaats, om ruimte te besparen op de
boot-/rootdiskette. Zodra de boot-/rootdiskette is geboot, wordt het naar
de ramdisk gekopieerd waarbij het diskettestaion vrijkomt om een andere
diskette, de utility-diskette te kunnen mounten. Ik mount deze gewoonlijk
als <TT
CLASS="FILENAME"
>/usr</TT
>.</P
><P
> De aanmaak van een utility-diskette wordt hierna beschreven in de
<A
HREF="#UTILITYDISK"
>paragraaf <I
>Bouwen van een utility-disk</I
></A
>. Waarschijnlijk is het wenselijk een kopie van
dezelfde versie backuputitily's, die worden gebruikt om de backups te
schrijven, te beheren, zodat je geen tijd verspilt bij het proberen te
installeren van versies die je backuptapes niet in kunnen lezen.</P
><DIV
CLASS="IMPORTANT"
><P
></P
><TABLE
CLASS="IMPORTANT"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/IMAGES/important.gif"
HSPACE="5"
ALT="Belangrijk"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Verzeker je ervan dat je de volgende programma's opneemt:
<TT
CLASS="FILENAME"
>init</TT
>, <TT
CLASS="FILENAME"
>getty</TT
> of equivalent,
<TT
CLASS="FILENAME"
>login</TT
>, <TT
CLASS="FILENAME"
>mount</TT
>, een 
shell die capabel is voor het uitvoeren van je rc-scripts, een link 
vanuit <TT
CLASS="FILENAME"
>sh</TT
> naar je shell.</P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN571"
></A
>/lib</H4
><P
>In <TT
CLASS="FILENAME"
>/lib</TT
> plaats je de benodigde shared library's en
loaders. Als de benodigde library's niet in de directory
<TT
CLASS="FILENAME"
>/lib</TT
> worden gevonden dan zal het systeem niet kunnen
booten. Als je geluk hebt, zie je wellicht een foutmelding over wat er
aan de hand is.</P
><P
>&#13;Bijna ieder programma heeft op z'n minst de library <TT
CLASS="FILENAME"
>libc</TT
>,
<TT
CLASS="FILENAME"
>libc.so.</TT
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>N</I
></SPAN
> nodig; de
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>N</I
></SPAN
> staat voor het huidige versienummer. Controleer je
<TT
CLASS="FILENAME"
>/lib</TT
> directory. Het bestand
<TT
CLASS="FILENAME"
>libc.so.N</TT
> is gewoonlijk een symlink naar een bestandsnaam
met een volledig versienummer:</P
><P
>&#13;<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>% ls -l /lib/libc*
-rwxr-xr-x   1 root     root      4016683 Apr 16 18:48 libc-2.1.1.so*
lrwxrwxrwx   1 root     root           13 Apr 10 12:25 libc.so.6 -&#62; libc-2.1.1.so*</PRE
></TD
></TR
></TABLE
>&#13;</P
><P
>In dit geval gebruik je <TT
CLASS="FILENAME"
>libc-2.1.1.so</TT
>. Om achter
de andere library's te komen, neem je alle binaire bestanden door die je
van plan bent op de diskette te plaatsen en controleer je daarvan de
afhankelijkheden met <B
CLASS="COMMAND"
>ldd</B
>. Bijvoorbeeld:

<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        % ldd /sbin/mke2fs
        libext2fs.so.2 =&#62; /lib/libext2fs.so.2 (0x40014000)
        libcom_err.so.2 =&#62; /lib/libcom_err.so.2 (0x40026000)
        libuuid.so.1 =&#62; /lib/libuuid.so.1 (0x40028000)
        libc.so.6 =&#62; /lib/libc.so.6 (0x4002c000)
        /lib/ld-linux.so.2 =&#62; /lib/ld-linux.so.2 (0x40000000)</PRE
></TD
></TR
></TABLE
>
Ieder bestand rechts is vereist. Het bestand mag een symbolische link zijn.</P
><P
> Een aantal library's is <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>nogal groot</I
></SPAN
> en ze
zullen niet zo gemakkelijk op je rootbestandssysteem passen.
De hiervoor genoemde <TT
CLASS="FILENAME"
>libc.so</TT
> bijvoorbeeld is ongeveer
4 meg. Waarschijnlijk zal je library's moeten strippen wanneer je ze naar
je rootbestandssysteem kopieert.
Zie <A
HREF="#SLIMFAST"
>paragraaf <I
>Terugbrengen van de grootte van het rootbestandssysteem</I
></A
> voor instructies.</P
><P
>In <TT
CLASS="FILENAME"
>/lib</TT
> moet je tevens een loader voor de library's
opnemen. De loader zal &oacute;f <TT
CLASS="FILENAME"
>ld.so</TT
> (voor
A.OUT library's, die niet langer algemeen zijn) &oacute;f 
<TT
CLASS="FILENAME"
>ld-linux.so</TT
> (voor ELF library's) zijn. Nieuwere versies van
<B
CLASS="COMMAND"
>ldd</B
> vertellen je exact welke loader nodig is, zoals
in het voorbeeld hiervoor, maar oudere versies mogelijk niet.
Als je niet zeker weet welke je nodig hebt, pas dan de opdracht
<B
CLASS="COMMAND"
>file</B
> toe op de library. Bijvoorbeeld:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>% file /lib/libc.so.4.7.2 /lib/libc.so.5.4.33 /lib/libc-2.1.1.so
/lib/libc.so.4.7.2: Linux/i386 demand-paged executable (QMAGIC), stripped
/lib/libc.so.5.4.33: ELF 32-bit LSB shared object, Intel 80386, version 1, stripped
/lib/libc-2.1.1.so: ELF 32-bit LSB shared object, Intel 80386, version 1, not stripped</PRE
></TD
></TR
></TABLE
>
De <TT
CLASS="LITERAL"
>QMAGIC</TT
> geeft aan dat <TT
CLASS="LITERAL"
>4.7.2</TT
> voor
A.OUT library's is, en <TT
CLASS="LITERAL"
>ELF</TT
> geeft aan dat
<TT
CLASS="LITERAL"
>5.4.33</TT
> en <TT
CLASS="LITERAL"
>2.1.1</TT
> voor ELF zijn.
&#13;</P
><P
>Kopieer de specifieke loader(s) die je nodig hebt naar het rootbestandssysteem
dat je aan het bouwen bent.

Library's en loaders zouden <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>zorgvuldig</I
></SPAN
> moeten worden
gecontroleerd met de opgenomen library's.
Als de kernel een benodigde library niet kan laden, kan het zijn dat de
kernel zonder foutmelding blijft hangen.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PAMANDNSS"
></A
>Voorziening voor PAM en NSS</H3
><P
>Mogelijk zijn er voor je systeem dynamisch laadbare library's nodig die niet
zichtbaar zijn voor <TT
CLASS="FILENAME"
>ldd</TT
>. Als je hierin niet voorziet,
kan het zijn dat je problemen krijgt bij het inloggen of het gebruiken van
je bootdisk.</P
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN622"
></A
>PAM (Pluggable Authentication Modules)</H4
><P
>Als er op je systeem gebruik wordt gemaakt van PAM 
(Pluggable Authentication Modules), moet je er voorzieningen voor treffen
op je bootdisk. Kort gezegd is PAM een geraffineerde modulaire methode voor
de authenticatie van gebruikers en het beheren van de toegang tot de
services voor gebruikers. Een eenvoudige manier om vast te stellen of je
systeem gebruik maakt van PAM is <TT
CLASS="FILENAME"
>ldd</TT
> op het uitvoerbare
bestand <TT
CLASS="FILENAME"
>login</TT
> toe te passen; als in de uitvoer
<TT
CLASS="FILENAME"
>libpam.so</TT
> voorkomt, heb je PAM nodig.</P
><P
>Gelukkig heb je bij bootdisks gewoonlijk niets met beveiliging van
doen aangezien iedereen die fysiek toegang heeft tot een computer, gewoonlijk
alles kan doen wat hij/zij wil. Daarom kun je PAM effectief deactiveren door
het aanmaken van een eenvoudig <TT
CLASS="FILENAME"
>/etc/pam.conf</TT
> bestand
in je rootbestandssysteem dat er ongeveer zo uitziet:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>OTHER   auth       optional     /lib/security/pam_permit.so
OTHER   account    optional     /lib/security/pam_permit.so
OTHER   password   optional     /lib/security/pam_permit.so
OTHER   session    optional     /lib/security/pam_permit.so</PRE
></TD
></TR
></TABLE
>

Kopieer ook het bestand <TT
CLASS="FILENAME"
>/lib/security/pam_permit.so</TT
>
naar je rootbestandssysteem. Deze library is slechts ongeveer 8K dus heeft het
een minimale overhead tot gevolg.</P
><P
>Deze configuratie staat iedereen toegang tot de bestanden en services
op je computer toe. Als beveiliging op je bootdisk je om &eacute;&eacute;n
of andere reden lief is, zal je de gehele of gedeeltelijke PAM setup van je
harddisk naar je rootbestandssysteem moeten kopi&euml;ren.
Lees de PAM documentatie zorgvuldig door, en kopieer alle benodigde
library's in <TT
CLASS="FILENAME"
>/lib/security</TT
> naar je rootbestandssysteem.</P
><P
>Je moet tevens <TT
CLASS="FILENAME"
>/lib/libpam.so</TT
> op je bootdisk plaatsen.
Maar dit wist je al aangezien je ldd op
<TT
CLASS="FILENAME"
>/bin/login</TT
> toepaste, waarmee deze afhankelijkheid werd
getoond.</P
></DIV
><DIV
CLASS="SECT3"
><HR><H4
CLASS="SECT3"
><A
NAME="AEN637"
></A
>NSS (Name Service Switch)</H4
><P
>Als je glibc (ala libc6) gebruikt, zal je voorzieningen moeten treffen voor
name services anders zal je niet in kunnen loggen. Het bestand
<TT
CLASS="FILENAME"
>/etc/nsswitch.conf</TT
> bestuurt database lookups voor
diverse services. Als je van plan bent services vanaf het netwerk te
benaderen (bv, DNS of NIS lookups) dan moet je een eenvoudig
<TT
CLASS="FILENAME"
>nsswitch.conf</TT
> bestand prepareren dat er ongeveer zo
uitziet:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>     passwd:     files 
     shadow:     files 
     group:      files 
     hosts:      files
     services:   files
     networks:   files
     protocols:  files
     rpc:        files
     ethers:     files
     netmasks:   files     
     bootparams: files
     automount:  files 
     aliases:    files
     netgroup:   files
     publickey:  files</PRE
></TD
></TR
></TABLE
>

Hiermee wordt aangegeven dat iedere service alleen door lokale bestanden
wordt geleverd. Je zal ook 
<TT
CLASS="FILENAME"
>/lib/libnss_files.so.</TT
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>X</I
></SPAN
>
op moeten nemen; <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>X</I
></SPAN
> is 1 voor glibc 2.0 en 2 voor
glibc 2.1. Deze library zal dynamisch worden geladen om de file lookups
af te handelen.</P
><P
>Als je van plan bent het netwerk vanaf je bootdisk te benaderen, wil je
misschien een nauwgezetter bestand <TT
CLASS="FILENAME"
>nsswitch.conf</TT
>
aanmaken. Zie de <TT
CLASS="FILENAME"
>nsswitch</TT
> manpage voor details.
Je moet een bestand <TT
CLASS="FILENAME"
>/lib/libnss_</TT
>
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>service</I
></SPAN
><TT
CLASS="FILENAME"
>.so.1</TT
> opgeven voor iedere
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>service</I
></SPAN
> die je specificeert.</P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN653"
></A
>Modules</H3
><P
> Als je een modulaire kernel hebt, overweeg dan welke modules je
na het booten vanaf je bootdisk wilt laden. Wellicht dat je
<B
CLASS="COMMAND"
>ftape</B
> en <B
CLASS="COMMAND"
>zftape</B
> modules op wilt
nemen als je backuptapes op floppytape zijn, modules voor SCSI-devices als
je ze hebt, en mogelijk modules voor PPP of SLIP ondersteuning als je
het net in noodgeval wilt benaderen.</P
><P
>Deze modules kunnen in <TT
CLASS="FILENAME"
>/lib/modules</TT
> worden geplaatst.
Je zou ook <B
CLASS="COMMAND"
>insmod</B
>, <B
CLASS="COMMAND"
>rmmod</B
> en
<B
CLASS="COMMAND"
>lsmod</B
> op moeten nemen. En afhankelijk van of je
modules automatisch wilt laden, ook <B
CLASS="COMMAND"
>modprobe</B
>,
<B
CLASS="COMMAND"
>depmod</B
> en <B
CLASS="COMMAND"
>swapout</B
>. Als je 
<B
CLASS="COMMAND"
>kerneld</B
> gebruikt, neem het dan samen met
<TT
CLASS="FILENAME"
>/etc/conf.modules</TT
> op.</P
><P
>Het belangrijkste voordeel bij het gebruik van modules is echter dat je
niet kritieke modules naar een utility-disk kunt verplaatsen en ze kunt
laden wanneer ze nodig zijn. Dus gebruik je minder ruimte op je rootdisk.
Als je met veel verschillende devices te maken hebt, heeft deze benadering
de voorkeur in vergelijking met het bouwen van &eacute;&eacute;n zeer grote
kernel met veel ingebouwde drivers.</P
><DIV
CLASS="IMPORTANT"
><P
></P
><TABLE
CLASS="IMPORTANT"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/IMAGES/important.gif"
HSPACE="5"
ALT="Belangrijk"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Om een gecomprimeerd ext2 bestandssysteem te kunnen booten, moet je ramdisk
en ext2 ondersteuning hebben ingebouwd.
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Ze kunnen niet als modules worden toegevoegd.</I
></SPAN
></P
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN674"
></A
>Een paar laatste details</H3
><P
>Een aantal systeemprogramma's, zoals <B
CLASS="COMMAND"
>login</B
>, produceert
foutmeldingen als het bestand <TT
CLASS="FILENAME"
>/var/run/utmp</TT
> en de
directory <TT
CLASS="FILENAME"
>/var/log</TT
> niet voorkomen. Dus:</P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        mkdir -p /mnt/var/&lcub;log,run&lcub;
        touch /mnt/var/run/utmp</PRE
></TD
></TR
></TABLE
><P
>Nadat je tenslotte alle benodigde library's hebt ingesteld, pas je
<B
CLASS="COMMAND"
>ldconfig</B
> toe op
<TT
CLASS="FILENAME"
>/etc/ld.so.cache</TT
> op het rootbestandssysteem opnieuw
aan te maken. De cache vertelt de loader waar het de library's vindt.
Roep de volgende opdrachten aan voor het opnieuw maken van 
<TT
CLASS="FILENAME"
>ld.so.cache</TT
>:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        chdir /mnt; chroot /mnt /sbin/ldconfig</PRE
></TD
></TR
></TABLE
>




De <B
CLASS="COMMAND"
>chroot</B
> is noodzakelijk omdat
<B
CLASS="COMMAND"
>ldconfig</B
> de cache voor het rootbestandssysteem altijd
opnieuw aanmaakt.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="WRAPPINGITUP"
></A
>Het samenstellen</H3
><P
>Zodra je klaar bent met het construeren van het rootbestandssysteem, unmount
je het, kopieer je het naar een bestand en comprimeer je het:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        umount /mnt
        dd if=<SPAN
CLASS="SYMBOL"
>DEVICE</SPAN
> bs=1k | gzip -v9 &#62; rootfs.gz</PRE
></TD
></TR
></TABLE
>

Wanneer dit klaar is, heb je een bestand genaamd
<TT
CLASS="FILENAME"
>rootfs.gz</TT
>. Dit is je gecomprimeerde rootbestandssysteem.
Controleer de grootte ervan om er zeker van te zijn dat het op een diskette
zal passen; als dit niet zo is, zal je terug moeten gaan en wat bestanden
moeten verwijderen. In de <A
HREF="#SLIMFAST"
>paragraaf <I
>Terugbrengen van de grootte van het rootbestandssysteem</I
></A
> staat diverse aanbevelingen 
voor het terugdringen van de omvang van het rootbestandssysteem.</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN701"
></A
>Uitkiezen van een kernel</H2
><P
>Je hebt nu een compleet gecomprimeerd rootbestandssysteem.
De volgende stap bestaat uit het samenstellen of uitkiezen van een kernel.
In de meeste gevallen is het mogelijk je huidige kernel te kopi&euml;ren en
daarmee vanaf diskette te booten. Er kunnen echter situaties zijn dat je
een aparte kernel wenst te bouwen.</P
><P
>&Eacute;&eacute;n reden is de omvang. Als je een enkele boot-/rootdiskette
aan het bouwen ben, zal de kernel &eacute;&eacute;n van de grootste bestanden
op de diskette zijn, dus zal je de grootte van de kernel zoveel mogelijk
willen beperken. Bouw het met een minimumset aan faciliteiten die nodig is
om het gewenste systeem te ondersteunen. Dit betekent alles achterwege 
laten wat je niet nodig hebt. Netwerkondersteuning is prima achterwege
te laten, als ook de ondersteuning voor eventuele diskettestations en andere
drivers voor apparaten die je niet nodig hebt als je je boot-/rootsysteem 
draait. Zoals eerder uiteengezet, <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>moet</I
></SPAN
> de ondersteuning 
voor de ramdisk en ext2 in je kernel zijn ingebouwd.</P
><P
> Je zal uit moeten werken wat erin terug te plaatsen als je een minimum
set faciliteiten hebt uitgewerkt om in een kernel op te nemen. Waarschijnlijk
het meest algemene gebruik voor een boot-/rootdiskette zou zijn een systeem
voor het bestuderen en herstellen van een beschadigd rootbestandssysteem,
en hiervoor
heb je wellicht kernelondersteuning nodig. Als bijvoorbeeld je backups allen
op tape worden bewaard door gebruik te maken van Ftape om je tapedrive te
benaderen, dan zal het niet mogelijk zijn vanaf je backuptapes een
herstelprocedure uit te voeren als je je huidige rootdrive en drives met
Ftape kwijtraakt. Je zal Linux opnieuw moeten installeren, en 
<B
CLASS="COMMAND"
>ftape</B
> moeten downloaden en installeren om vervolgens je
backups opnieuw in proberen te lezen.</P
><P
>Waar het hierom gaat is dat welke I/O ondersteuning je ook aan je kernel hebt
toegevoegd voor de ondersteuning van backups, dit ook in je boot/root kernel
moet worden toegevoegd.</P
><P
>De procedure voor het werkelijk bouwen van de kernel is beschreven in de
documentatie die met de kernel wordt geleverd. Het is tamelijk eenvoudig te
volgen, dus begin door het kijken in <TT
CLASS="FILENAME"
>/usr/src/linux</TT
>.
Als je bij het bouwen van een kernel problemen ondervindt, zou je eigenlijk
niet moeten proberen boot/root systemen te bouwen. Denk eraan de kernel met
``<B
CLASS="COMMAND"
>make zImage</B
>'' te comprimeren.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN716"
></A
>Het bijelkaar plaatsen: aanmaken van de diskette(s)</H2
><P
>Je hebt nu een kernel en een gecomprimeerd rootbestandssysteem.
Controleer de grootte als je een boot-/rootdisk aan het maken bent om er
zeker van te zijn dat ze beiden op &eacute;&eacute;n disk passen.
Controleer het rootbestandssysteem als je er zeker van wilt zijn dat het op
een enkele diskette past als je een uit twee disks bestaande boot+root set
aan het maken bent.</P
><P
>Je zou een beslissing moeten nemen of je LILO wilt gebruiken om de
bootdiskkernel te booten. Het alternatief is de kernel direct naar de diskette
te kopi&euml;ren en zonder LILO te booten.
Het voordeel van het gebruik van LILO is dat het je de mogelijkheid biedt een
aantal parameters aan de kernel op te geven die mogelijk nodig zijn om je
hardware te initialiseren. (Controleer het bestand 
<TT
CLASS="FILENAME"
>/etc/lilo.conf</TT
> op je systeem. Als het bestaat en er een
regel als ``<TT
CLASS="LITERAL"
>append=...</TT
>''in voorkomt, heb je het
waarschijnlijk nodig). Het nadeel van het gebruik van LILO is dat het bouwen
van de bootdisk wat gecompliceerder is en wat meer ruimte in beslag neemt. Je 
zal een klein apart bestandssysteem in moeten stellen, wat we het 
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>kernelbestandssysteem</I
></SPAN
> zullen noemen, waarnaar we de kernel
en een paar andere bestanden die LILO nodig heeft, zullen transporteren.</P
><P
>Lees verder als je LILO gaat gebruiken en als je de kernel direct gaat
transporteren dan ga je verder met de <A
HREF="#TRANSFERRINGWITHOUTLILO"
>paragraaf <I
>Transporteren van de kernel zonder LILO</I
></A
>.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="TRANSFERRINGWITHLILO"
></A
>Transporteren van de kernel met LILO</H3
><P
>Het eerste wat je moet doen is een klein configuratiebestand voor LILO aanmaken.
Het zal er ongeveer zo uit moeten komen te zien:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        boot      =/dev/fd0
        install   =/boot/boot.b
        map       =/boot/map
        read-write
        backup    =/dev/null
        compact
        image     = KERNEL
        label     = Bootdisk
        root      =/dev/fd0</PRE
></TD
></TR
></TABLE
>
Zie de gebruikersdocumentatie van LILO voor een uitleg van deze parameters.
Je zal waarschijnlijk ook de regel
<TT
CLASS="LITERAL"
>append=...</TT
> aan dit bestand toe moeten voegen, kijk hiervoor
in het bestand <TT
CLASS="FILENAME"
>/etc/lilo.conf</TT
> op je harddisk.</P
><P
>Bewaar dit bestand als <TT
CLASS="FILENAME"
>bdlilo.conf</TT
>.</P
><P
>Je zal nu een klein bestandssysteem aan moeten maken, wat we een 
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>kernelbestandssysteem</I
></SPAN
> zullen noemen, om het te
onderscheiden van het rootbestandssysteem.</P
><P
>Zoek als eerste uit hoe groot het bestandssysteem zal moeten zijn. Neem de
omvang van je kernel in blokken (de grootte weergegeven door
``<B
CLASS="COMMAND"
>ls -l KERNEL</B
>'' gedeeld door 1024 en afgerond naar
boven) en tel hier 50 bij op. Vijftig blokken is bij benadering de ruimte
die nodig is voor inodes plus nog wat andere bestanden.
Je kunt dit aantal exact berekenen of gewoon 50 gebruiken. Als je een uit
twee disks bestaande set gebruikt, kun je de ruimte net zo goed ruim nemen
aangezien de kernel toch alleen voor de kernel wordt gebruikt.
Noem dit aantal <TT
CLASS="LITERAL"
>KERNEL_BLOCKS</TT
>.</P
><P
>Plaats een diskette in de drive (ter vereenvoudiging gaan we uit van
<TT
CLASS="FILENAME"
>/dev/fd0</TT
>) en maak hier een ext2 kernelbestandssysteem
op aan:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        mke2fs -i 8192 -m 0 /dev/fd0 KERNEL_BLOCKS</PRE
></TD
></TR
></TABLE
>



De ``<TT
CLASS="LITERAL"
>-i 8192</TT
>'' geeft aan de we &eacute;&eacute;n inode
per 8192 bytes willen. Mount vervolgens het bestandssysteem, verwijder de
directory <TT
CLASS="FILENAME"
>lost+found</TT
> en maak de directory's
<TT
CLASS="FILENAME"
>dev</TT
> en <TT
CLASS="FILENAME"
>boot</TT
> voor LILO aan:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        mount /dev/fd0 /mnt
        rm -rf /mnt/lost+found
        mkdir /mnt/&lcub;boot,dev&rcub;</PRE
></TD
></TR
></TABLE
></P
><P
>Maak dan de devices <TT
CLASS="FILENAME"
>/dev/null</TT
> en
<TT
CLASS="FILENAME"
>/dev/fd0</TT
>. Je kunt in plaats van het opzoeken van
de devicenummers, ze vanaf je harddisk kopi&euml;ren door gebruik te maken
van <TT
CLASS="LITERAL"
>-R</TT
>:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        cp -R /dev/{null,fd0} /mnt/dev</PRE
></TD
></TR
></TABLE
> 
LILO heeft een kopie van de bootloader <TT
CLASS="FILENAME"
>boot.b</TT
> nodig, 
die je van je harddisk kan halen. Het wordt gewoonlijk in de directory
<TT
CLASS="FILENAME"
>/boot</TT
> bewaard.
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        cp /boot/boot.b /mnt/boot</PRE
></TD
></TR
></TABLE
>
Kopieer tenslotte het configuratiebestand van LILO samen met de kernel die
je in de laatste sectie aanmaakte. Beiden kunnen in de rootdirectory worden
geplaatst:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        cp bdlilo.conf KERNEL /mnt</PRE
></TD
></TR
></TABLE
>
Alle benodigdheden voor LILO bevinden zich nu op het kernelbestandssysteem, dus
je bent er klaar voor het uit te voeren.
LILO's <TT
CLASS="LITERAL"
>-r</TT
> vlag wordt gebruikt voor het installeren van
de bootloader op een andere root:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        lilo -v -C bdlilo.conf -r /mnt</PRE
></TD
></TR
></TABLE
>

LILO zou zonder fouten moeten draaien, waarna het kernelbestandssysteem
er ongeveer zo uit zou moeten zien:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>total 361
  1 -rw-r--r--   1 root     root          176 Jan 10 07:22 bdlilo.conf
  1 drwxr-xr-x   2 root     root         1024 Jan 10 07:23 boot/
  1 drwxr-xr-x   2 root     root         1024 Jan 10 07:22 dev/
358 -rw-r--r--   1 root     root       362707 Jan 10 07:23 vmlinuz
boot:
total 8
  4 -rw-r--r--   1 root     root         3708 Jan 10 07:22 boot.b
  4 -rw-------   1 root     root         3584 Jan 10 07:23 map
dev:
total 0
  0 brw-r-----   1 root     root       2,   0 Jan 10 07:22 fd0
  0 crw-r--r--   1 root     root       1,   3 Jan 10 07:22 null           </PRE
></TD
></TR
></TABLE
></P
><P
>Maak je geen zorgen als de bestandsgroottes bij jou iets anders uitpakken.</P
><P
>Laat de diskette nu in het diskettestation en ga naar de <A
HREF="#SETTINGRAMDISKWORD"
>paragraaf <I
>Instellen van het ramdisk word</I
></A
>.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="TRANSFERRINGWITHOUTLILO"
></A
>Transporteren van de kernel zonder LILO</H3
><P
>Transporteer de kernel met de opdracht <B
CLASS="COMMAND"
>dd</B
> als je
LILO <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>niet</I
></SPAN
> gebruikt:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        % dd if=KERNEL of=/dev/fd0 bs=1k
        353+1 records in
        353+1 records out</PRE
></TD
></TR
></TABLE
>

In dit voorbeeld schreef <B
CLASS="COMMAND"
>dd</B
> 353 complete + 1
gedeeltelijk record weg, dus de kernel neemt de eerste 354 blokken van de
diskette in beslag. Noem dit aantal <TT
CLASS="LITERAL"
>KERNEL_BLOCKS</TT
>
en onthoud het voor gebruik in de volgende sectie.</P
><P
>Stel het rootdevice zo in dat het de diskette zelf is, en stel de root dan
in dat het read/write zal worden geladen:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        rdev /dev/fd0 /dev/fd0
        rdev -R /dev/fd0 0</PRE
></TD
></TR
></TABLE
>



Let erop dat je de hoofdletter <TT
CLASS="LITERAL"
>-R</TT
> gebruikt in de
tweede <B
CLASS="COMMAND"
>rdev</B
> opdracht.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SETTINGRAMDISKWORD"
></A
>Instellen van het ramdisk word</H3
><P
> 
Binnenin de kernelimage bevindt zich het <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ramdisk word</I
></SPAN
> 
waarin wordt aangegeven waar het rootbestandssysteem is te vinden, plus
nog wat andere opties. Het word kan worden benaderd en ingesteld via de
<B
CLASS="COMMAND"
>rdev</B
> opdracht, en de inhoud ervan wordt als volgt
ge&iuml;nterpreteerd:
  <DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN794"
></A
><P
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
WIDTH="96"
ALIGN="RIGHT"
VALIGN="TOP"
>Bit veld</TH
><TH
WIDTH="100%"
ALIGN="LEFT"
VALIGN="TOP"
>Beschrijving</TH
></TR
></THEAD
><TBODY
><TR
><TD
WIDTH="96"
ALIGN="RIGHT"
VALIGN="TOP"
>0-10</TD
><TD
WIDTH="100%"
ALIGN="LEFT"
VALIGN="TOP"
>Offset van start ramdisk, in 1024 byte blokken</TD
></TR
><TR
><TD
WIDTH="96"
ALIGN="RIGHT"
VALIGN="TOP"
>11-13</TD
><TD
WIDTH="100%"
ALIGN="LEFT"
VALIGN="TOP"
>ongebruikt</TD
></TR
><TR
><TD
WIDTH="96"
ALIGN="RIGHT"
VALIGN="TOP"
>14</TD
><TD
WIDTH="100%"
ALIGN="LEFT"
VALIGN="TOP"
>Vlag die aangeeft dat ramdisk wordt geladen</TD
></TR
><TR
><TD
WIDTH="96"
ALIGN="RIGHT"
VALIGN="TOP"
>15</TD
><TD
WIDTH="100%"
ALIGN="LEFT"
VALIGN="TOP"
>Vlag die aangeeft een melding te geven alvorens rootfs te laden</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></P
><P
>Als bit 15 is ingesteld, zal tijdens de systeemstart worden aangegeven een
nieuwe diskette in het diskettestation te plaatsen. Dit is nodig voor een uit
twee disks bestaande bootset.</P
><P
>Er zijn twee situaties, afhankelijk van of je een enkele boot-/rootdiskette
aan het bouwen bent, of een dubbele ``boot+root'' disketteset.</P
><P
></P
><OL
TYPE="1"
><LI
><P
>Als je een enkele disk aan het bouwen bent, zal het gecomprimeerde
rootbestandssysteem direct achter de kernel worden geplaatst, dus zal de
offset het eerste vrije blok zijn (wat hetzelfde zou moeten zijn als
<TT
CLASS="LITERAL"
>KERNEL_BLOCKS</TT
>). Bit 14 zal op 1 zijn gezet, en
bit 15 op nul.

Stel bijvoorbeeld dat je een enkele disk aan het bouwen bent en dat het
rootbestandssysteem begint op blok 253 (decimaal). De waarde van het
ramdisk word zou 253 (decimaal) moeten zijn met bit 14 op 1 gezet en bit
15 op 0. Voor het berekenen van de waarde kun je de decimale waarden 
eenvoudigweg bijelkaar optellen. 253 + (2^14) = 253 + 16384 = 16637.
Als je het niet geheel begrijpt waar dit nummer vandaan komt, tik het
dan in op een wetenschappelijke rekenmachine en converteer het naar
binair.</P
></LI
><LI
><P
>Als je een diskset bestaande uit twee disks aan het bouwen bent, zal het
rootbestandssysteem beginnen op blok nul van de tweede disk, dus zal de
offset nul zijn. Bit 14 zal op 1 zijn gezet en bit 15 op 1. De decimale
waarde zal in dit geval 2^14 + 2^15 = 49152 zijn.</P
></LI
></OL
><P
>Stel na het zorgvuldig te hebben berekend van de waarde voor het ramdisk
word het in met <B
CLASS="COMMAND"
>rdev -r</B
>. Wees er zeker van de
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>decimale</I
></SPAN
> waarde te gebruiken. 
Het argument aan <B
CLASS="COMMAND"
>rdev</B
> zou hier het
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>gemounte kernel path</I
></SPAN
>,b.v. <TT
CLASS="FILENAME"
>/mnt/vmlinuz</TT
> moeten zijn als je LILO gebruikte; als je in plaats daarvan de kernel met
<B
CLASS="COMMAND"
>dd</B
>  kopieerde, gebruik je de naam van het diskettedevice
(<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>b.v.,</I
></SPAN
> <TT
CLASS="FILENAME"
>/dev/fd0</TT
>).
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        rdev -r KERNEL_OR_FLOPPY_DRIVE  VALUE</PRE
></TD
></TR
></TABLE
></P
><P
>Bij gebruik van LILO unmount je nu de diskette.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AEN838"
></A
>Transporteren van het rootbestandssysteem</H3
><P
>De laatste stap bestaat uit het transporteren van het rootbestandssysteem.</P
><P
>&#13;<P
></P
><UL
><LI
><P
>Als het rootbestandssysteem op <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>dezelfde</I
></SPAN
> disk zal
worden geplaatst als de kernel, dan transporteer je het met behulp van
<B
CLASS="COMMAND"
>dd</B
> met de optie <TT
CLASS="OPTION"
>seek</TT
>, waarmee wordt
opgegeven hoeveel blokken over te slaan:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        dd if=rootfs.gz of=/dev/fd0 bs=1k seek=<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>KERNEL_BLOCKS</I
></SPAN
></PRE
></TD
></TR
></TABLE
></P
></LI
><LI
><P
>Als het rootbestandssysteem op een <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>tweede</I
></SPAN
> disk zal
worden geplaatst, verwijder je de eerste diskette, doe je de tweede diskette
in het diskettestation, en transporteert dan het rootbestandssysteem naar deze
diskette:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        dd if=rootfs.gz of=/dev/fd0 bs=1k</PRE
></TD
></TR
></TABLE
></P
></LI
></UL
>&#13;</P
><P
>Gefeliciteerd, je bent klaar!  </P
><DIV
CLASS="IMPORTANT"
><P
></P
><TABLE
CLASS="IMPORTANT"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/IMAGES/important.gif"
HSPACE="5"
ALT="Belangrijk"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Test een bootdisk altijd voordat je het opzij legt voor
een noodgeval. Lees verder als het niet lukt ervan te booten.</P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="TROUBLESHOOTING"
></A
>Probleemoplossing</H2
><P
>Bij het bouwen van bootdisks, zal het systeem bij de eerste pogingen
waarschijnlijk niet booten. De algemene benadering bij het bouwen van een
rootdisk is componenten vanuit je bestaande systeem te assembleren, en het
op een diskette gebaseerd systeem te krijgen tot op het punt waar het
berichten op de console weergeeft. Zodra het &eacute;&eacute;nmaal met
je begint te communiceren, is het halve leed geleden omdat je dan kunt zien
waar het problemen mee heeft en kun je individuele problemen herstellen net
zolang tot het systeem soepel werkt. Als het systeem zonder verklaring hangt,
kan het uitzoeken van de oorzaak moeilijk zijn. Om een systeem geboot te
krijgen tot die fase waarin het met je zal communiceren, is het vereist dat
verscheidene componenten aanwezig zijn en dat deze correct zijn 
geconfigureerd. De aanbevolen procedure voor het onderzoeken van het probleem
waar het systeem niet met je zal communiceren is als volgt:</P
><P
>&#13;<P
></P
><UL
><LI
><P
>Mogelijk zie je een melding als:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
>Kernel panic: VFS: Unable to mount root fs on XX:YY</PRE
></TD
></TR
></TABLE
>
Dit is een algemeen probleem en het kan slechts door een paar dingen worden
veroorzaakt. Vergelijk allereerst het device <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>XX:YY</I
></SPAN
>
Met de lijst devicecodes; is het 't correcte rootdevice?
Als dit niet zo is, heb je vermoedelijk <B
CLASS="COMMAND"
>rdev -R</B
> niet
uitgevoerd, of paste je het toe op het verkeerde image. Als de devicecode
correct is, controleer dan nauwkeurig de devicedrivers die in je
kernel zijn gecompileerd. Overtuig jezelf ervan dat er ingebouwde ondersteuning
voor een diskette, ramdisk en het ext2 bestandssysteem in de kernel voorkomt.&#13;</P
></LI
><LI
><P
>Als je foutmeldingen ziet als:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
>end_request: I/O error, dev 01:00 (ramdisk), sector NNN</PRE
></TD
></TR
></TABLE
>
Dit is een I/O error die door de ramdiskdriver wordt gerapporteerd, 
waarschijnlijk omdat de kernel voorbij het einde van het device probeert
te schrijven. Je ramdisk is te klein om je rootbestandssysteem te bevatten.
Controleer de initialisatiemeldingen van je bootdiskkernel op een regel
als:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        Ramdisk driver initialized : 16 ramdisks of 4096K size</PRE
></TD
></TR
></TABLE
>
Vergelijk deze grootte met de <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ongecomprimeerde</I
></SPAN
> grootte
van het rootbestandsssysteem. Maak de ramdisk groter als hij niet groot genoeg
is.</P
></LI
><LI
><P
>Controleer of de rootdisk echt die directory's bevat waarvan je denkt dat
ze erop voorkomen. Het is heel eenvoudig op het onjuiste niveau iets te
kopi&euml;ren, waardoor je op je rootdisk uiteindelijk uitkomt met iets als
<TT
CLASS="FILENAME"
>/rootdisk/bin</TT
> in plaats van
<TT
CLASS="FILENAME"
>/bin</TT
>.&#13;</P
></LI
><LI
><P
>Controleer of er een <TT
CLASS="FILENAME"
>/lib/libc.so</TT
> voorkomt
met dezelfde link die in je <TT
CLASS="FILENAME"
>/lib</TT
> directory 
op je harddisk staat.&#13;</P
></LI
><LI
><P
>Controleer of alle symbolische links in je <TT
CLASS="FILENAME"
>/dev</TT
>
directory van je bestaande systeem ook voorkomen op je rootbestandssysteem
op de diskette, waar die links naar devices verwijzen die je op je rootdiskette
hebt opgenomen. In het bijzonder zijn in veel gevallen de
<TT
CLASS="FILENAME"
>/dev/console</TT
> links essentieel.</P
></LI
><LI
><P
>Controleer of je de bestanden <TT
CLASS="FILENAME"
>/dev/tty1, /dev/null, /dev/zero,
/dev/mem, /dev/ram</TT
> en <TT
CLASS="FILENAME"
>/dev/kmem</TT
> niet bent
vergeten.&#13;</P
></LI
><LI
><P
>Controleer je kernelconfiguratie -- ondersteuning voor alle bronnen die nodig
zijn tot op het punt van inloggen mogen geen modules zijn, maar zijn ingebouwd.
Dus <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ondersteuning voor een ramdisk en ext2 moeten zijn ingebouwd</I
></SPAN
>.&#13;</P
></LI
><LI
><P
>Controleer of je kernel rootdevice en ramdisk instellingen correct zijn.</P
></LI
></UL
>&#13;</P
><P
>Nu we deze algemene aspecten &eacute;&eacute;nmaal hebben gehad, zijn hier
nog een aantal specifieke bestanden te controleren:

<P
></P
><OL
TYPE="1"
><LI
><P
>Zorg ervoor dat <B
CLASS="COMMAND"
>init</B
> is opgenomen als
<TT
CLASS="FILENAME"
>/sbin/init</TT
> of <TT
CLASS="FILENAME"
>/bin/init</TT
>.
Wees er zeker van dat het uitvoerbaar is.</P
></LI
><LI
><P
>Voer <B
CLASS="COMMAND"
>ldd init</B
> uit om te controleren op de library's van
init. Gewoonlijk is dit slechts
<TT
CLASS="FILENAME"
>libc.so</TT
>, maar controleer het toch maar. Zorg ervoor
dat je de benodigde library's en loaders hebt ingesloten.</P
></LI
><LI
><P
>Verzeker je jezelf ervan dat je de juiste loader voor je library's hebt
-- <TT
CLASS="FILENAME"
>ld.so</TT
> voor a.out of <TT
CLASS="FILENAME"
>ld-linux.so</TT
>
voor ELF.&#13;</P
></LI
><LI
><P
>Controleer <TT
CLASS="FILENAME"
>/etc/inittab</TT
> op het bestandssysteem van je
bootdisk op aanroepen naar <B
CLASS="COMMAND"
>getty</B
> (of een op
<B
CLASS="COMMAND"
>getty</B
>-lijkend programma, zoals
<B
CLASS="COMMAND"
>agetty</B
>, <B
CLASS="COMMAND"
>mgetty</B
> of
<B
CLASS="COMMAND"
>getty_ps</B
>). Controleer deze tweemaal
met <TT
CLASS="FILENAME"
>inittab</TT
> op je harddisk.
Controleer de manpages van het te gebruiken programma om er zeker van te
zijn dat deze zin hebben. <TT
CLASS="FILENAME"
>inittab</TT
> is mogelijk het
lastigste onderdeel omdat de syntax en inhoud ervan afhangen van het in
gebruik zijnde init programma en de aard van het systeem. De enige manier
om het aan te pakken is de manpages van <B
CLASS="COMMAND"
>init</B
> en
<TT
CLASS="FILENAME"
>inittab</TT
> lezen en exact
uit te werken wat je bestaande systeem doet wanneer het boot.
Controleer voor de zekerheid of <TT
CLASS="FILENAME"
>/etc/inittab</TT
> een
systeeminitialisatie-entry heeft. Hierin zou een opdracht moeten staan voor
het uitvoeren van het systeem initialisatiescript, dat voor moet komen.&#13;</P
></LI
><LI
><P
> Pas net als bij <B
CLASS="COMMAND"
>getty</B
> <B
CLASS="COMMAND"
>ldd</B
> toe
op <B
CLASS="COMMAND"
>getty</B
> om te zien wat het nodig heeft, en zorg ervoor
dat de benodigde library bestanden en loaders in je rootbestandssysteem
zijn opgenomen.&#13;</P
></LI
><LI
><P
>Wees er zeker van dat je een shell-programma hebt ingesloten 
(b.v., <B
CLASS="COMMAND"
>bash</B
> of <B
CLASS="COMMAND"
>ash</B
>) welke al je
rc-scripts kan uitvoeren.&#13;</P
></LI
><LI
><P
>Als je een <TT
CLASS="FILENAME"
>/etc/ld.so.cache</TT
> bestand op je rescue-disk
hebt, maak het dan opnieuw aan.</P
></LI
></OL
>&#13;</P
><P
>Als <B
CLASS="COMMAND"
>init</B
> start, maar je een melding krijgt als:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        Id xxx respawning too fast: disabled for 5 minutes  </PRE
></TD
></TR
></TABLE
>
is dat afkomstig van <B
CLASS="COMMAND"
>init</B
>, waarmee gewoonlijk wordt
aangegeven dat <B
CLASS="COMMAND"
>getty</B
> of <B
CLASS="COMMAND"
>login</B
> afsluit
zodra het opstart.
Controleer de uitvoerbare bestanden <B
CLASS="COMMAND"
>getty</B
> en
<B
CLASS="COMMAND"
>login</B
> en de library's waar ze afhankelijk van zijn.
Zorg dat de aanroepen in <TT
CLASS="FILENAME"
>/etc/inittab</TT
> juist zijn.
Als je vreemde meldingen van <B
CLASS="COMMAND"
>getty</B
> krijgt, kan dit
betekenen dat de aanroepende vorm in
<TT
CLASS="FILENAME"
>/etc/inittab</TT
> niet goed is.</P
><P
>Als je een loginprompt krijgt en je een geldige loginnaam invoert, maar
het systeem vraagt je onmiddellijk daarna om nog een andere loginnaam,
kan het probleem te maken hebben met PAM of NSS.
Zie <A
HREF="#PAMANDNSS"
>paragraaf <I
>Voorziening voor PAM en NSS</I
></A
>. Het probleem kan ook zijn dat je
shadow passwords gebruikt en 
<TT
CLASS="FILENAME"
>/etc/shadow</TT
> niet naar je bootdisk kopieerde.</P
><P
>Als je &eacute;&eacute;n of ander uitvoerbaar bestand, zoals
<B
CLASS="COMMAND"
>df</B
> probeert uit te voeren, wat zich op je rescue-disk
bevindt, maar het levert je een bericht op als:
<TT
CLASS="LITERAL"
>df: not found</TT
>, controleer dan op twee
zaken: (1) Verzeker je ervan dat de directory met het binaire bestand zich
in je PATH bevindt, en (2) zorg ervoor dat de library's (en loaders) die
het programma nodig heeft er zijn.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN958"
></A
>Diverse onderwerpen</H2
><DIV
CLASS="SECT2"
><H3
CLASS="SECT2"
><A
NAME="SLIMFAST"
></A
>Terugbrengen van de grootte van het rootbestandssysteem</H3
><P
>Soms is een rootbestandssysteem zelfs na compressie te groot voor op
een diskette. Hier zijn een aantal manieren om de grootte van het
bestandssysteem terug te brengen:

<P
></P
><OL
TYPE="1"
><LI
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Verhoog de dichtheid van de diskette</I
></SPAN
>.  
Standaard worden diskette op 1440K geformatteerd, maar er zijn hogere
dichtheidsformaten beschikbaar. <TT
CLASS="FILENAME"
>fdformat</TT
> kan disks
met de volgende omvang formatteren:
1600, 1680, 1722, 1743, 1760, 1840, en 1920. De meeste 1440K diskettestations
ondersteunen 1722K, en dit is wat ik altijd voor bootdisks gebruik.
Zie de manpage van <B
CLASS="COMMAND"
>fdformat</B
> en
<TT
CLASS="FILENAME"
>/usr/src/linux/Documentation/devices.txt</TT
>.</P
></LI
><LI
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Vervang je shell</I
></SPAN
>. Een aantal
populaire shells voor Linux, zoals <B
CLASS="COMMAND"
>bash</B
> en
<B
CLASS="COMMAND"
>tcsh</B
>, is nogal groot en deze shells vereisen veel library's.
Er zijn lichtgewicht alternatieven, zoals <B
CLASS="COMMAND"
>ash</B
>,
<B
CLASS="COMMAND"
>lsh</B
>, <B
CLASS="COMMAND"
>kiss</B
> en
<B
CLASS="COMMAND"
>smash</B
>, die heel wat kleiner zijn en waarvoor minder
(of geen) library's nodig zijn. De meeste vervangende shells zijn beschikbaar
vanaf <A
HREF="http://metalab.unc.edu/pub/Linux/system/shells/"
TARGET="_top"
><TT
CLASS="FILENAME"
>http://metalab.unc.edu/pub/Linux/system/shells/</TT
></A
>. Zorg er in ieder geval voor dat de shell die je kiest
de opdrachten in alle <TT
CLASS="FILENAME"
>rc</TT
> bestanden op je bootdisk uit
kan voeren. </P
></LI
><LI
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Strip library's en binary's</I
></SPAN
>. Veel
library's en binary's worden met debugging informatie gedistribueerd. 
Als dit zo is krijg je als uitvoer ``<TT
CLASS="LITERAL"
>not stripped</TT
>'' als
je op deze bestanden de opdracht <B
CLASS="COMMAND"
>file</B
> toepast.
 Bij het kopi&euml;ren van
binary's naar je rootbestandssysteem, is het een goede gewoonte gebruik te
maken van:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="SCREEN"
>      objcopy --strip-all FROM TO</PRE
></TD
></TR
></TABLE
>





<DIV
CLASS="IMPORTANT"
><P
></P
><TABLE
CLASS="IMPORTANT"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/IMAGES/important.gif"
HSPACE="5"
ALT="Belangrijk"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Gebruik bij het kopi&euml;ren van library's <TT
CLASS="OPTION"
>strip-debug</TT
>
in plaats van <TT
CLASS="OPTION"
>strip-all</TT
>.</P
></TD
></TR
></TABLE
></DIV
></P
></LI
><LI
><P
>Als je bij het aanmaken van het rootbestandssysteem veel bestanden
verplaatste of verwijderde, maak het dan opnieuw aan. Zie de NOOT HIERVOOR
over het belang van het ontbreken van `dirty blocks' in het bestandssysteem.</P
></LI
><LI
><P
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Verplaats niet kritieke bestanden naar een utilitydisk</I
></SPAN
>.

Als een aantal van je binary's na het booten of inloggen niet onmiddellijk
nodig is, kun je ze naar een utilitydisk verplaatsen.
Zie de <A
HREF="#UTILITYDISK"
>paragraaf <I
>Bouwen van een utility-disk</I
></A
> voor details.
Je kunt ook in overweging nemen modules naar een utilitydisk te
verplaatsen.
&#13;</P
></LI
></OL
></P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="NONRAMDISKROOT"
></A
>Niet-ramdisk rootbestandssystemen</H3
><P
>In <A
HREF="#BUILDROOT"
>paragraaf <I
>Bouwen van een rootbestandssysteem</I
></A
> werden instructies gegeven voor het
bouwen van een gecomprimeerd rootbestandssysteem die bij het booten van
het systeem naar ramdisk wordt geladen. Deze methode heeft veel voordelen
en wordt daarom vaak gebruikt. Op een aantal systemen kun je je dit echter
niet permitteren vanwege de benodigde RAM, en moet het rootbestandssysteem
direct vanaf de diskette worden gemount.</P
><P
>Dergelijke bestandssystemen zijn in wezen eenvoudiger aan te maken dan
gecomprimeerde rootbestandssystemen, omdat ze op een diskette kunnen worden
gebouwd in plaats van op &eacute;&eacute;n of ander ander device, en ze
niet hoeven te worden gedecomprimeerd. We zullen deze procedure in zoverre
ze verschilt van de instructies hiervoor uiteenzetten. Houd in gedachten dat
als je hiervoor kiest je <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>veel minder ruimte</I
></SPAN
> beschikbaar
zal hebben.</P
><P
>&#13;<P
></P
><OL
TYPE="1"
><LI
><P
>Bereken hoeveel ruimte je beschikbaar zal hebben voor rootbestanden.

Als je een enkele boot-/rootdisk aan het bouwen bent, moeten alle blokken
voor de kernel plus alle blokken voor het rootbestandssysteem op 
&eacute;&eacute;n disk passen.&#13;</P
></LI
><LI
><P
>Maak met behulp van <B
CLASS="COMMAND"
>mke2fs</B
> een rootbestandssysteem op
een diskette van de van toepassing zijnde grootte aan.&#13;</P
></LI
><LI
><P
>Stel het bestandssysteem samen zoals eerder werd beschreven.&#13;</P
></LI
><LI
><P
>Unmount het bestandssysteem en transporteer het naar een diskbestand als
je klaar bent, maar <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>comprimeer het niet</I
></SPAN
>.&#13;</P
></LI
><LI
><P
>Transporteer, zoals eerder beschreven, de kernel naar een diskette.
<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Stel bit 14 in op nul</I
></SPAN
> bij het berekenen van het
ramdisk word om aan te geven dat het rootbestandssysteem niet naar ramdisk
moet worden geladen. Voer zoals eerder beschreven de opdracht
<B
CLASS="COMMAND"
>rdev</B
> uit.

&#13;</P
></LI
><LI
><P
>Transporteer het rootbestandssysteem als voorheen.&#13;</P
></LI
></OL
>&#13;</P
><P
> Er zijn verscheidene kortere wegen te bewandelen. Als je een uit twee
disks bestaande set aan het bouwen bent, kun je het complete
rootbestandssysteem direct op de tweede disk bouwen en is het niet nodig
het tijdelijk naar een harddiskbestand te transporteren.
Ook kun je een <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>enkel</I
></SPAN
> bestandssysteem met de kernel,
LILO bestanden en rootbestanden op de gehele
disk bouwen als je een enkele boot-/rootdisk aan het bouwen bent en LILO
gebruikt en als laatste stap gewoon LILO opstarten.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="UTILITYDISK"
></A
>Bouwen van een utility-disk</H3
><P
>Het bouwen van een utility-disk is relatief gezien eenvoudig -- maak
op een geformatteerde disk een bestandssysteem aan en kopieer er de bestanden
naar. Mount het handmatig nadat het systeem is geboot bij gebruik met een 
bootdisk.</P
><P
>In de instructies hiervoor gaven we al aan dat de utility-disk als
<TT
CLASS="FILENAME"
>/usr</TT
> zou kunnen worden gemount. In deze situatie zouden
de binary's in de <TT
CLASS="FILENAME"
>/bin</TT
> directory op je utility-disk kunnen
worden geplaatst, zodat het in je path plaatsen van
<TT
CLASS="FILENAME"
>/usr/bin</TT
> ervoor zorgt dat ze kunnen worden benadert. 
Extra library's benodigd voor de binary's worden geplaatst in 
<TT
CLASS="FILENAME"
>/lib</TT
> op de utility-disk.</P
><P
>Er zijn bij het ontwerpen van een utility-disk een aantal aandachtspunten:</P
><P
>&#13;<P
></P
><OL
TYPE="1"
><LI
><P
>Plaats kritieke systeembinary's of library's niet op de utility-disk omdat
het pas nadat het systeem is geboot te mounten zal zijn.&#13;</P
></LI
><LI
><P
>Je kunt een diskette en floppy tapedrive niet gelijktijdig benaderen.
Dit betekent dat als je een floppy tapedrive hebt, je het niet zal kunnen
benaderen als je utility-disk is gemount.&#13;</P
></LI
><LI
><P
>Toegang tot de bestanden op de utility-disk verloopt traag.&#13;</P
></LI
></OL
>&#13;</P
><P
>In de <A
HREF="#UTILITYLIST"
>Aanhangsel D</A
> wordt een voorbeeld gegeven van
bestanden op een utility-disk. Hier zijn een aantal idee&euml;n betreft
bestanden die je wellicht nuttig zal vinden: programma's voor het
bestuderen en manipuleren van disks (<B
CLASS="COMMAND"
>format, fdisk</B
>) 
en bestandssystemen (<B
CLASS="COMMAND"
>mke2fs, fsck, debugfs, isofs.o</B
>),
een lichtgewicht teksteditor (<B
CLASS="COMMAND"
>elvis, jove</B
>), comprimeer-
en archiefutility's (<B
CLASS="COMMAND"
>gzip, bzip, tar, cpio, afio</B
>), tape
utility's (<B
CLASS="COMMAND"
>mt, ftmt, tob, taper</B
>), communicatie utility's
(<B
CLASS="COMMAND"
>ppp.o, slip.o, minicom</B
>) en utility's voor devices
(<B
CLASS="COMMAND"
>setserial, mknod</B
>).</P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PROS"
></A
>Hoe de pro's het doen</H2
><P
>Misschien dat het je is opgevallen dat de bootdisks van belangrijke
distributies, zoals Slackware, RedHat of Debian geraffineerder lijken dan
wat in dit document is beschreven. Professionele distributie bootdisks zijn op 
dezelfde principes gebaseerd als hierin is uiteengezet, maar investeren in
diverse truuks omdat hun bootdisks aanvullende vereisten hebben.
Ten eerste moeten ze kunnen werken met een brede vari&euml;teit aan hardware,
dus moet er een interactie met de gebruiker plaats kunnen vinden en 
moet het mogelijk zijn diverse devicedrivers te laden.
Ten tweede moeten ze zodanig zijn geprepareerd dat ze met vele verschillende
installatie-opties werken, met diverse graden van automatisering.
Als laatste worden in de bootdisks van distributies gewoonlijk installatie
en rescue mogelijkheden gecombineerd.</P
><P
>Op een aantal bootdisks wordt gebruik gemaakt van een mogelijkheid 
genaamd <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>initrd</I
></SPAN
>
(<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>initi&euml;le ramdisk</I
></SPAN
>). Deze mogelijkheid werd zo
rond 2.0.x ge&iuml;ntroduceerd en deze maakt het mogelijk een kernel in
twee fasen te booten. Wanneer de kernel in de eerste fase boot, laadt het
een initi&euml;le ramdisk image vanaf de disk.
Deze initi&euml;le ramdisk is een rootbestandssysteem met een programma
dat voor het echte root-fs wordt geladen. Dit programma inspecteert
gewoonlijk de omgeving en/of vraagt de gebruiker diverse bootopties,
zoals het device waarvan de echte rootdisk te laden, te selecteren.
Het laadt extra modules die niet in de kernel zijn gebouwd. Wanneer dit
initi&euml;le programma stopt, laadt de kernel het echte root-image in en
wordt het booten normaal gecontinueerd. Zie voor verdere informatie 
over <B
CLASS="COMMAND"
>initrd</B
> het lokale bestand <A
HREF="file:/usr/src/linux/Documentation/initrd.txt"
TARGET="_top"
><TT
CLASS="FILENAME"
>/usr/src/linux/Documentation/initrd.txt</TT
></A
>
en <A
HREF="ftp://elserv.ffm.fgan.de/pub/linux/loadlin-1.6/initrd-example.tgz"
TARGET="_top"
><TT
CLASS="FILENAME"
>ftp://elserv.ffm.fgan.de/pub/linux/loadlin-1.6/initrd-example.tgz</TT
></A
></P
><P
>Hieronder volgen samenvattingen van hoe de installatiedisks van
iedere distributie schijnen te werken, gebaseerd op het inspecteren van
de bestreffende bestandssysteem en/of sourcecode. We kunnen niet
garanderen dat deze informatie volledig accuraat is, of dat ze sinds
de vermelde versies niet is gewijzigd.</P
><P
>Slackware (v.3.1) gebruikt een recht-door-zee LILO-boot vergelijkbaar met
wat is beschreven in <A
HREF="#TRANSFERRINGWITHLILO"
>paragraaf <I
>Transporteren van de kernel met LILO</I
></A
>.
De Slackware bootdisk drukt een opstartmelding af
(&ldquo;<TT
CLASS="LITERAL"
>Welcome to the Slackware Linux bootkernel disk!</TT
>
&rdquo;) door gebruik te maken van LILO's <TT
CLASS="LITERAL"
>message</TT
> parameter.
Hiermee wordt de gebruiker ge&iuml;nstrueerd zonodig een bootparameterregel
in te voeren. Na het booten wordt een rootbestandssysteem geladen vanaf een
tweede disk. De gebruiker roept een <B
CLASS="COMMAND"
>setup</B
> script aan waarmee
de installatie wordt gestart. Slackware voorziet in vele verschillende
kernels in plaats dat het gebruik maakt van een modulaire kernel en
het hangt van de gebruiker af die kernel te selecteren die overeenkomt met
zijn of haar hardwarebenodigdheden.</P
><P
> Ook RedHat (v.4.0) maakt gebruik van een LILO boot. Het laadt een
gecomprimeerde ramdisk vanaf de eerste disk, waarbij een aangepast
<B
CLASS="COMMAND"
>init</B
> programma wordt uitgevoerd. Dit programma ondervraagt
naar drivers en laadt dan zonodig de extra bestanden vanaf een supplemental
disk.</P
><P
> Debian (v.1.3) is waarschijnlijk het meest geraffineerd van de
installatie disksets. Het maakt gebruik van de SYSLINUX loader om diverse
laadopties te regelen, vervolgens gebruikt het een
<TT
CLASS="LITERAL"
>initrd</TT
> image om de gebruiker door de installatie te
leiden. Het blijkt van zowel een aangepaste
<B
CLASS="COMMAND"
>init</B
> als een aangepaste shell gebruik te maken.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1097"
></A
>Lijst met veel gestelde vragen (FAQ)</H2
><DIV
CLASS="QANDASET"
><DL
><DT
>Vraag: <A
HREF="#AEN1101"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Ik boot vanaf mijn boot-/rootdisks en er gebeurt niets. Wat kan ik doen?</I
></SPAN
></A
></DT
><DT
>Vraag: <A
HREF="#AEN1108"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Hoe werkt de Slackware/Debian/RedHat bootdisk?</I
></SPAN
></A
></DT
><DT
>Vraag: <A
HREF="#AEN1115"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Hoe kan ik een bootdisk met een XYZ-driver aanmaken?</I
></SPAN
></A
></DT
><DT
>Vraag: <A
HREF="#AEN1132"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Hoe werk ik mijn rootdiskette bij met nieuwe bestanden?</I
></SPAN
></A
></DT
><DT
>Vraag: <A
HREF="#AEN1147"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Hoe verwijder ik LILO zodat ik DOS weer kan gebruiken om te booten?</I
></SPAN
></A
></DT
><DT
>Vraag: <A
HREF="#AEN1163"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Hoe kan ik booten als ik mijn kernel- <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>en</I
></SPAN
>
mijn bootdisk niet meer heb?</I
></SPAN
></A
></DT
><DT
>Vraag: <A
HREF="#AEN1186"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Hoe kan ik extra kopie&euml;n van boot-/rootdiskettes maken?</I
></SPAN
></A
></DT
><DT
>Vraag: <A
HREF="#AEN1209"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Hoe kan ik zonder het iedere keer weer typen van &ldquo;ahaxxxx=nn,nn,nn&rdquo; booten?</I
></SPAN
></A
></DT
><DT
>Vraag: <A
HREF="#AEN1242"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Tijdens de systeemstart, krijg ik de foutmelding &ldquo;<TT
CLASS="LITERAL"
>A:
cannot execute B</TT
>&rdquo;. Waarom?</I
></SPAN
></A
></DT
><DT
>Vraag: <A
HREF="#AEN1269"
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Mijn kernel heeft ondersteuning voor een ramdisk van 0K. Waarom?</I
></SPAN
></A
></DT
></DL
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN1101"
></A
><B
>Vraag: </B
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Ik boot vanaf mijn boot-/rootdisks en er gebeurt niets. Wat kan ik doen?</I
></SPAN
></P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
>Antwoord: </B
>Zie <A
HREF="#TROUBLESHOOTING"
>paragraaf <I
>Probleemoplossing</I
></A
>.</P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN1108"
></A
><B
>Vraag: </B
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Hoe werkt de Slackware/Debian/RedHat bootdisk?</I
></SPAN
></P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
>Antwoord: </B
>Zie <A
HREF="#PROS"
>paragraaf <I
>Hoe de pro's het doen</I
></A
>.</P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN1115"
></A
><B
>Vraag: </B
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Hoe kan ik een bootdisk met een XYZ-driver aanmaken?</I
></SPAN
></P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
>Antwoord: </B
>De eenvoudigste manier is door aan een Slackware kernel vanaf je dichtsbijzijnde mirrorsite te komen. Slackware kernels zijn algemene kernels die voor
zoveel mogelijk devices drivers op proberen te nemen, dus als je een SCSI- of
IDE-controller hebt, bestaat de kans dat er een driver voor in de Slackware
kernel is opgenomen.</P
><P
>Ga naar de directory <TT
CLASS="FILENAME"
>a1</TT
> en selecteer, afhankelijk van
het type controller dat je hebt, een IDE- of SCSI-kernel. Controleer het
bestand xxxxkern.cfg voor de geselecteerde kernel om te bezien welke drivers
in die kernel zijn opgenomen. Als het gewenste device in de lijst voorkomt,
dan zou je met de corresponderende kernel je computer moeten kunnen booten.
Download het bestand xxxxkern.tgz en kopieer het naar je bootdiskette
zoals werd beschreven in de sectie over het maken van bootdisks.</P
><P
>Vervolgens moet je met behulp van de opdracht
<B
CLASS="COMMAND"
>rdev zImage</B
> het rootdevice in de kernel controleren.
Als deze niet hetzelfde is als het gewenste rootdevice, gebruik je
<B
CLASS="COMMAND"
>rdev</B
> om het te wijzigen. De kernel die ik bijvoorbeeld
probeerde was ingesteld op <TT
CLASS="FILENAME"
>/dev/sda2</TT
>, maar mijn root
SCSI-partitie bevindt zich op <TT
CLASS="FILENAME"
>/dev/sda8</TT
>. 
Om het op een rootdiskette te gebruiken, zou je de opdracht
<B
CLASS="COMMAND"
>rdev zImage /dev/fd0</B
> uit moeten voeren.</P
><P
>Als je bovendien wilt weten hoe je een Slackware rootdisk in wilt stellen,
dan raad ik je aan hiervoor de Linux Install Guide te lezen of aan de
Slackware distributie te komen want dat valt buiten het kader van deze HOWTO.
Zie in deze HOWTO de sectie getiteld ``Referenties''.</P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN1132"
></A
><B
>Vraag: </B
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Hoe werk ik mijn rootdiskette bij met nieuwe bestanden?</I
></SPAN
></P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
>Antwoord: </B
>


De gemakkelijkste manier is het bestandssysteem vanaf de rootdisk terug naar
het eerder gebruikte <SPAN
CLASS="SYMBOL"
>DEVICE</SPAN
> te kopi&euml;ren (zie
<A
HREF="#CREATINGROOTFS"
>paragraaf <I
>Aanmaken van het bestandssysteem</I
></A
>). Mount vervolgens het bestandssysteem en
maak de wijzigingen. Je zal moeten onthouden waar je rootbestandssysteem
begon en hoeveel blokken het in beslag nam:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        dd if=/dev/fd0 bs=1k skip=ROOTBEGIN count=BLOCKS | gunzip &#62; <SPAN
CLASS="SYMBOL"
>DEVICE</SPAN
>
        mount -t ext2 <SPAN
CLASS="SYMBOL"
>DEVICE</SPAN
> /mnt</PRE
></TD
></TR
></TABLE
>
Na het maken van de wijzigingen ga je als voorheen verder (in <A
HREF="#WRAPPINGITUP"
>paragraaf <I
>Het samenstellen</I
></A
>) en transporteer je het rootbestandssysteem weer
terug naar de disk.
Als je de beginpositie van het nieuwe rootbestandssysteem niet wijzigt,
hoef je de kernel niet opnieuw te transporteren of het ramdisk word opnieuw
te berekenen.</P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN1147"
></A
><B
>Vraag: </B
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Hoe verwijder ik LILO zodat ik DOS weer kan gebruiken om te booten?</I
></SPAN
></P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
>Antwoord: </B
>Dit is niet echt een Bootdisk onderwerp, maar het wordt vaak gevraagd.
Onder Linux doe je het volgende:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        /sbin/lilo -u</PRE
></TD
></TR
></TABLE
></P
><P
>Je kunt ook gebruik maken van de opdracht <B
CLASS="COMMAND"
>dd</B
>
waarbij je de door LILO opgeslagen backup naar de bootsector kopieert.
Raadpleeg hiervoor de LILO documentatie als je het op deze manier wilt doen.</P
><P
>Onder DOS en Windows kun je de volgende DOS-opdracht gebruiken:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        FDISK /MBR</PRE
></TD
></TR
></TABLE
>
MBR staat voor Master Boot Record. Met deze opdracht vervang je de bootsector
door een zuivere DOS MBR, zonder dat dit effect heeft op de partitietabel.
Een aantal puristen is het hier niet mee eens, maar zelfs de auteur van
LILO, Werner Almesberger, raadt dit aan.
Het is makkelijk en het werkt.</P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN1163"
></A
><B
>Vraag: </B
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Hoe kan ik booten als ik mijn kernel- <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>en</I
></SPAN
>
mijn bootdisk niet meer heb?</I
></SPAN
></P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
>Antwoord: </B
>Als je geen bootdisk meer bij de hand hebt, is de eenvoudigste methode
vermoedelijk voor te zorgen dat je aan een Slackware kernel voor je type
diskcontroller (IDE of SCSI) komt zoals hiervoor werd beschreven in
``Hoe maak ik een bootdisk met een XXX driver?''. Je kunt je computer
dan met behulp van deze kernel booten en vervolgens de opgelopen schade 
repareren.</P
><P
>Het kan zijn dat het rootdevice in deze kernel niet op het gewenste
disktype en partitie is ingesteld. De algemene kernel van Slackware 
bijvoorbeeld heeft het rootdevice op <TT
CLASS="FILENAME"
>/dev/sda2</TT
> ingesteld,
terwijl mijn Linux rootpartitie op <TT
CLASS="FILENAME"
>/dev/sda8</TT
> voorkomt.
In dit geval zal het rootdevice in de kernel moeten worden gewijzigd.</P
><P
>Je kunt het root-device en de instellingen voor de ramdisk in de kernel
nog steeds wijzigen zelfs al heb je alleen een kernel en een ander
besturingssysteem zoals DOS.</P
><P
> <B
CLASS="COMMAND"
>rdev</B
> wijzigt de instellingen van de kernel
door de waarden op vaste offsets in het kernelbestand aan te passen, dus
je kunt hetzelfde doen als je een hex-editor tot je beschikking hebt.
-- je kunt hierbij bijvoorbeeld gebruik maken van de Norton Utilities Disk
Editor onder DOS. Je moet dan op de volgende offsets te waarden in de
kernel controleren en zonodig wijzigen:




<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>HEX     DEC  DESCRIPTION
0x01F8  504  Low byte van RAMDISK word
0x01F9  505  High byte van RAMDISK word
0x01FC  508  Root minor device nummer - zie hieronder
0X01FD  509  Root major device nummer - zie hieronder</PRE
></TD
></TR
></TABLE
></P
><P
>De interpretatie van het ramdisk word werd hiervoor beschreven in <A
HREF="#SETTINGRAMDISKWORD"
>paragraaf <I
>Instellen van het ramdisk word</I
></A
>.</P
><P
>De major en minor devicenummers moeten worden ingesteld op het device waarop
je het rootbestandssysteem wilt instellen. Een aantal nuttige waarden om
te selecteren zijn:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>DEVICE          MAJOR MINOR
/dev/fd0            2     0   1e diskettestation
/dev/hda1           3     1   partitie 1 op 1e IDE-drive
/dev/sda1           8     1   partitie 1 op 1e SCSI-drive
/dev/sda8           8     8   partitie 8 op 1e SCSI-drive</PRE
></TD
></TR
></TABLE
>
Zodra je deze waarden hebt ingesteld, kun je het bestand naar een diskette
wegschrijven met behulp van de Norton Utilities Disk Editor of een programma
genaamd <B
CLASS="COMMAND"
>rawrite.exe</B
>. Dit programma wordt met alle
distributies meegeleverd. Het is een DOS-programma waarmee een bestand ``raw''
naar de disk wordt weggeschreven, te beginnen bij de bootsector, in plaats
dat het bestand naar het bestandssysteem wordt weggeschreven.
Als je Norton Utilities hiervoor gebruikt, moet je het bestand naar een
fysieke disk beginnend bij de start van de disk wegschrijven.</P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN1186"
></A
><B
>Vraag: </B
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Hoe kan ik extra kopie&euml;n van boot-/rootdiskettes maken?</I
></SPAN
></P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
>Antwoord: </B
>Omdat magnetische media mettertijd verslechtert, zou je verscheidene
kopie&euml;n van je rescuedisk moeten bewaren, voor het geval het
origineel onleesbaar wordt.</P
><P
> 
De eenvoudigste wijze om kopie&euml;n van een diskette te maken,
waaronder opstartbare en utility-diskettes, is gebruik te maken van de
opdracht <B
CLASS="COMMAND"
>dd</B
> om de inhoud van de oorspronkelijke
diskette naar een bestand op je harddisk te kopi&euml;ren en dan dezelfde 
opdracht te gebruiken om het bestand terug naar een nieuwe diskette te
kopi&euml;ren. Het is niet nodig de diskettes te mounten en je zou dit
ook niet moeten doen, omdat <B
CLASS="COMMAND"
>dd</B
> gebruik maakt van de
raw device interface.</P
><P
>Typ voor het kopi&euml;ren van het origineel de opdracht:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        dd if=<SPAN
CLASS="SYMBOL"
>DEVICENAME</SPAN
> of=<SPAN
CLASS="SYMBOL"
>FILENAME</SPAN
></PRE
></TD
></TR
></TABLE
>

waar <SPAN
CLASS="SYMBOL"
>DEVICENAME</SPAN
> de naam van het device voor de diskette is en
<SPAN
CLASS="SYMBOL"
>FILENAME</SPAN
> de naam is van het uitvoerbestand (harddisk).
Als je de parameter <TT
CLASS="LITERAL"
>count</TT
> achterwege laat, maakt dat je
met <B
CLASS="COMMAND"
>dd</B
> de hele diskette kopieert
(voor een high-density diskette zijn dit 2880 blokken).</P
><P
>Voor het kopi&euml;ren van het resulterende bestand naar een nieuwe diskette,
doe je de nieuwe diskette in het diskettestation en geef je de opdracht 
omgekeerd:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        dd if=<SPAN
CLASS="SYMBOL"
>FILENAME</SPAN
> of=<SPAN
CLASS="SYMBOL"
>DEVICENAME</SPAN
></PRE
></TD
></TR
></TABLE
></P
><P
>In de uitleg hierboven wordt ervan uitgegaan dat je slechts &eacute;&eacute;n
diskettestation hebt. Als je er twee van hetzelfde type hebt, kun je de
diskettes kopi&euml;ren met een opdracht als:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        dd if=/dev/fd0 of=/dev/fd1</PRE
></TD
></TR
></TABLE
></P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN1209"
></A
><B
>Vraag: </B
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Hoe kan ik zonder het iedere keer weer typen van &ldquo;ahaxxxx=nn,nn,nn&rdquo; booten?</I
></SPAN
></P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
>Antwoord: </B
>


Als een diskdevice niet automatisch kan worden gedetecteerd moeten er aan
de kernel met een opdracht device parameterstrings worden opgegeven, zoals:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        aha152x=0x340,11,3,1</PRE
></TD
></TR
></TABLE
>

Deze parameterstring kan met behulp van LILO op verscheidene manieren
worden aangeleverd:
<P
></P
><UL
><LI
><P
>Door het iedere keer dat het systeem wordt geboot via LILO op de opdrachtregel
in te voeren. Dit is echter nogal vervelend.</P
></LI
><LI
><P
>Met behulp van LILO's <TT
CLASS="LITERAL"
>lock</TT
> keyword om ervoor te zorgen
dat de opdrachtregel als de standaard opdrachtregel wordt opgeslagen, zodat
LILO iedere keer dat het boot dezelfde opties gebruikt.</P
></LI
><LI
><P
>Met behulp van de opdracht <TT
CLASS="LITERAL"
>append=</TT
> in het 
configuratiebestand van LILO. De parameterstring moeten worden omsloten
door aanhalingstekens.</P
></LI
></UL
></P
><P
>Een voorbeeld van een opdrachtregel met de hiervoor 
genoemde parameterstring die zou worden gebruikt, zou zijn:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        zImage  aha152x=0x340,11,3,1 root=/dev/sda1 lock</PRE
></TD
></TR
></TABLE
></P
><P
>Hiermee zou de parameterstring voor het device worden doorgegeven en
zou de kernel ook worden gevraagd het rootdevice op
<TT
CLASS="FILENAME"
>/dev/sda1</TT
> in te stellen en de gehele opdrachtregel
te bewaren en het voor alle toekomstige boots opnieuw te gebruiken.</P
><P
>Een voorbeeld van een APPEND opdracht is:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        APPEND = &ldquo;aha152x=0x340,11,3,1&rdquo;</PRE
></TD
></TR
></TABLE
></P
><P
>De parameterstring moet op de opdrachtregel <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>niet</I
></SPAN
>
door aanhalingstekens worden omsloten, maar <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>wel</I
></SPAN
> in de
opdracht <TT
CLASS="LITERAL"
>APPEND</TT
>.</P
><P
>In de kernel moet de driver waarop de parameterstring betrekking heeft,
zijn ingebouwd. Als dit niet zo is, dan is er niets wat er naar de
parameterstring luistert, en zal je de kernel opnieuw moeten bouwen zodat
het benodigde device erin is opgenomen.
Ga naar <TT
CLASS="FILENAME"
>/usr/src/linux</TT
> en lees de README, de
Linux FAQ en Installatie HOWTO voor het opnieuw bouwen van de kernel.
Als alternatief kun je een algemene kernel voor het type disk ophalen en
die installeren.</P
><P
>We raden je aan de LILO documentatie goed door te lezen voordat je met
de LILO installatie gaat experimenteren. Onvoorzichtig gebruik van de
<TT
CLASS="LITERAL"
>BOOT</TT
> opdracht kan partities beschadigen.</P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN1242"
></A
><B
>Vraag: </B
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Tijdens de systeemstart, krijg ik de foutmelding &ldquo;<TT
CLASS="LITERAL"
>A:
cannot execute B</TT
>&rdquo;. Waarom?</I
></SPAN
></P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
>Antwoord: </B
>
In een aantal situaties worden programmanamen in diverse utility's
ingeprogrammeerd (hardcoded). Dit is niet altijd het geval, maar
het geeft wel een verklaring waarom een uitvoerbaar bestand blijkbaar niet
op je systeem kan worden gevonden zelfs al kun je zien dat het er is.
Of een gegeven programma de naam van een andere programma heeft ingeprogrammeerd
kun je achterhalen met behulp van de opdracht
<B
CLASS="COMMAND"
>strings</B
> en door via een pipe de uitvoer door
<B
CLASS="COMMAND"
>grep</B
> te laten gaan.</P
><P
>Bekende voorbeelden van hardcoding zijn:

<P
></P
><UL
><LI
><P
>In een aantal versies van <B
CLASS="COMMAND"
>shutdown</B
> is 
<TT
CLASS="FILENAME"
>/etc/reboot</TT
> hardcoded, dus moet <B
CLASS="COMMAND"
>reboot</B
>
in de directory <TT
CLASS="FILENAME"
>/etc</TT
> worden geplaatst.</P
></LI
><LI
><P
><B
CLASS="COMMAND"
>init</B
> heeft op z'n minst voor &eacute;&eacute;n persoon
voor problemen gezorgd waarbij de kernel <B
CLASS="COMMAND"
>init</B
> niet kon
vinden.</P
></LI
></UL
></P
><P
>Verplaats de programma's &oacute;f naar de juiste directory, &oacute;f
wijzig de configuratiebestanden
(b.v. <TT
CLASS="FILENAME"
>inittab</TT
>) zodanig dat naar de juiste directory
wordt verwezen. Plaats bij twijfel de programma's in dezelfde directory als
waar ze op je harddisk staan, en gebruik dezelfde <TT
CLASS="FILENAME"
>inittab</TT
>
en <TT
CLASS="FILENAME"
>/etc/rc.d</TT
> bestanden zoals die op je harddisk.</P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN1269"
></A
><B
>Vraag: </B
><SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Mijn kernel heeft ondersteuning voor een ramdisk van 0K. Waarom?</I
></SPAN
></P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
>Antwoord: </B
>In die gevallen zal bij het booten een kernelmelding als de volgende worden
weergegeven:

<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        Ramdisk driver initialized : 16 ramdisks of 0K size</PRE
></TD
></TR
></TABLE
></P
><P
>Dit komt waarschijnlijk doordat de grootte door kernelparameters tijdens
de systeemstart op 0 is ingesteld. Dit zou vermoedelijk kunnen zijn veroorzaakt
door een over het hoofd geziene parameter in het configuratiebestand van LILO:
<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>    ramdisk= 0</PRE
></TD
></TR
></TABLE
></P
><P
>Dit stond in een aantal oudere distributies in voorbeeldconfiguratiebestanden
van LILO, en het werd hier geplaatst om eventuele voorgaande kernelinstellingen
te overschrijven. Als er een dergelijke regel in voorkomt, verwijder je het.</P
><P
>Als je een ramdisk ter grootte van 0 probeert te gebruiken, kan de werking
onvoorspelbaar zijn en in kernelpanics resulteren.</P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
CLASS="APPENDIX"
><A
NAME="AEN1281"
></A
>A. Bronnen en verwijzingen</H1
><P
>Zorg bij het ophalen van een package altijd dat je de laatste versie ophaalt,
tenzij je goede redenen hebt om dit niet te doen.</P
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PREMADE"
></A
>Voorgefabriceerde Bootdisks</H2
><P
>Dit zijn bronnen voor distributie-bootdisks. <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Gebruik alsjeblieft 
&eacute;&eacute;n van de mirror-sites om de load op deze machines te beperken.</I
></SPAN
>

<P
></P
><UL
><LI
><P
> <A
HREF="http://metalab.unc.edu/pub/Linux/distributions/slackware/bootdsks.144/"
TARGET="_top"
>Slackware bootdisks</A
>,
<A
HREF="http://metalab.unc.edu/pub/Linux/distributions/slackware/rootdsks/"
TARGET="_top"
>rootdisks</A
> 

en <A
HREF="http://www.slackware.com/getslack/"
TARGET="_top"
>Slackware mirror sites</A
></P
></LI
><LI
><P
> <A
HREF="http://metalab.unc.edu/pub/Linux/distributions/redhat/current/i386/images/"
TARGET="_top"
>RedHat bootdisks</A
> en <A
HREF="http://www.redhat.com/mirrors.html"
TARGET="_top"
>Red Hat mirror sites</A
>&#13;</P
></LI
><LI
><P
> <A
HREF="ftp://ftp.debian.org/pub/debian/dists/stable/main/disks-i386/current/"
TARGET="_top"
>Debian bootdisks</A
> en <A
HREF="ftp://ftp.debian.org/pub/debian/README.mirrors.html"
TARGET="_top"
>Debian mirror sites</A
>&#13;</P
></LI
></UL
>&#13;</P
><P
>&#13;In aanvulling op de distributie-bootdisks zijn de volgende rescue-diskimages
beschikbaar. Tenzij anders aangegeven, zijn ze te vinden in de directory
<A
HREF="http://metalab.unc.edu/pub/Linux/system/recovery/!INDEX.html"
TARGET="_top"
><TT
CLASS="FILENAME"
>http://metalab.unc.edu/pub/Linux/system/recovery/!INDEX.html</TT
></A
></P
><P
>&#13;<P
></P
><UL
><LI
><P
><TT
CLASS="LITERAL"
>tomsrtbt</TT
>, door Tom Oehser, is een enkele boot-/rootdisk
gebaseerd op kernel 2.0, met een grote set mogelijkheden en ondersteunings
programma's. Het
biedt ondersteuning voor IDE, SCSI, tape, netwerkadaptors, PCMCIA en meer.
Ongeveer 100 utility-programma's en tools zijn opgenomen voor het herstellen
van disks. In het package zijn ook scripts opgenomen voor het deassembleren
en herconstrueren van de images zodat zonodig nieuw materiaal kan worden
toegevoegd.</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>rescue02</TT
>, door John Comyns, is een rescue-disk gebaseerd
op kernel 1.3.84 met ondersteuning voor IDE, 
Adaptec 1542 en NCR53C7,8xx. Het maakt gebruik van ELF
binary's, maar heeft genoeg opdrachten zodat het op ieder systeem gebruikt
kan worden. Er zijn voor alle andere SCSI-kaarten modules die na het booten
kunnen worden geladen. Het werkt waarschijnlijk niet met systemen met 4 mb
aan ram aangezien het gebruik maakt van een ramdisk van 3 mb.</P
></LI
><LI
><P
><TT
CLASS="LITERAL"
>resque_disk-2.0.22</TT
>, door Sergei Viznyuk, is een
boot-/rootdisk gebaseerd op kernel 2.0.22 met ingebouwde ondersteuning voor
IDE, veel verschillende SCSI-controllers, en ELF/AOUT. Tevens zijn veel modules
en nuttige utility's voor het herstellen van een harddisk opgenomen. </P
></LI
><LI
><P
><A
HREF="http://metalab.unc.edu/pub/Linux/system/recovery/images"
TARGET="_top"
><TT
CLASS="LITERAL"
>cramdisk</TT
> images</A
>, gebaseerd op de 2.0.23 kernel,
beschikbaar voor 4 meg en 8 meg machines. Hierin is ondersteuning voor de
math emulatie en netwerken (PPP en dial-in script, NE2000, 3C509) opgenomen
of ondersteuning voor de parallelle poort ZIP-drive.
Deze disk-images zullen op een 386'r met 4MB RAM booten.
MSDOS ondersteuning is opgenomen dus je kunt vanaf het net naar een
DOS-partitie downloaden.</P
></LI
></UL
>&#13;</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1320"
></A
>Rescue packages</H2
><P
>Op metalab.unc.edu zijn verscheidene packages voor het aanmaken van
rescue-disks beschikbaar. Met deze packages specificeer je een set bestanden
die moeten worden opgenomen en de software automatiseert
(in verschillende mate) de aanmaak van een bootdisk.
Zie <A
HREF="http://metalab.unc.edu/pub/Linux/system/recovery/!INDEX.html"
TARGET="_top"
><TT
CLASS="FILENAME"
>http://metalab.unc.edu/pub/Linux/system/recovery/!INDEX.html</TT
></A
>
voor meer informatie. <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>Controleer de bestandsdata zorgvuldig</I
></SPAN
>. Een aantal packages is verscheidene jaren niet bijgewerkt en
zal de aanmaak van een gecomprimeerd rootbestandssysteem die in de ramdisk
wordt geladen niet ondersteunen. 
Zover we weten, is <A
HREF="http://www.croftj.net/~fawcett/yard/index.html"
TARGET="_top"
>Yard</A
> het enige
package dat dit wel doet.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1327"
></A
>LILO -- de Linux loader</H2
><P
>Geschreven door Werner Almesberger. Uitstekende bootloader, en de
documentatie bevat informatie over de inhoud van de bootsector en de
beginfasen van het bootproces.</P
><P
>Ftp vanaf <A
HREF="ftp://tsx-11.mit.edu/pub/linux/packages/lilo/"
TARGET="_top"
>ftp://tsx-11.mit.edu/pub/linux/packages/lilo/</A
>. Het is ook
beschikbaar op Metalab en mirrors.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1332"
></A
>Linux FAQ en HOWTO's</H2
><P
>Deze zijn vanaf veel bronnen beschikbaar. Kijk in de usenet nieuwsgroepen
<TT
CLASS="LITERAL"
>news.answers</TT
> en <TT
CLASS="LITERAL"
>comp.os.linux.announce</TT
>.</P
><P
> 

De FAQ is beschikbaar vanaf <A
HREF="http://linuxdoc.org/FAQ/Linux-FAQ.html"
TARGET="_top"
>http://linuxdoc.org/FAQ/Linux-FAQ.html</A
>
en de HOWTO's van 
<A
HREF="http://linuxdoc.org/HOWTO/HOWTO-INDEX.html"
TARGET="_top"
>http://linuxdoc.org/HOWTO/HOWTO-INDEX.html</A
>. De meeste documentatie voor
Linux is te vinden op de homepage van het
<A
HREF="http://linuxdoc.org/"
TARGET="_top"
>Linux Documentatie Project</A
>.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1341"
></A
>Ramdisk gebruik</H2
><P
>Een uitstekende beschrijving van de werking van de ramdisk code is te
vinden in de documentatie die met de Linux-kernel wordt meegeleverd.
Zie <TT
CLASS="FILENAME"
>/usr/src/linux/Documentation/ramdisk.txt</TT
>. Het is
geschreven door Paul Gortmaker en bevat een sectie over het aanmaken van een
gecomprimeerde ramdisk.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="AEN1347"
></A
>Het Linux bootproces</H2
><P
>Hier zijn wat verwijzingen voor meer info over het Linux bootproces:

<P
></P
><UL
><LI
><P
>In de <A
HREF="http://linuxdoc.org/LDP/sag/c1596.html"
TARGET="_top"
><I
CLASS="CITETITLE"
>Linux
System Administrators' Guide</I
></A
> staat een sectie over het
booten.</P
></LI
><LI
><P
>In het <A
HREF="http://metalab.unc.edu/pub/Linux/system/boot/lilo/lilo-t-21.ps.gz"
TARGET="_top"
>LILO ``Technische overzicht''</A
> staat de definitieve technische,
low-level beschrijving van het bootproces, tot aan waar de kernel is gestart.</P
></LI
><LI
><P
>De broncode is de definitieve leidraad. Hieronder staan een
aantal kernelbestanden gerelateerd aan het bootproces. Als je de broncode
van de Linux-kernel hebt, kun je deze op je computer vinden onder
<TT
CLASS="FILENAME"
>/usr/src/linux</TT
>; als alternatief heeft 
Shigio Yamaguchi (shigio@tamacom.com) voor het lezen van de kernelbronbestanden
een zeer fraaie <A
HREF="http://www.tamacom.com/tour/linux/index.html"
TARGET="_top"
>hypertext kernel browser</A
>. Dit zijn een aantal relevante te bekijken bestanden:
                                                                   
<P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="FILENAME"
>arch/i386/boot/bootsect.S</TT
> en
<TT
CLASS="FILENAME"
>setup.S</TT
></DT
><DD
><P
>Hierin staat assembleercode voor de bootsector zelf.</P
></DD
><DT
><TT
CLASS="FILENAME"
>arch/i386/boot/compressed/misc.c</TT
></DT
><DD
><P
>Hierin staat code voor het decomprimeren van de kernel.</P
></DD
><DT
><TT
CLASS="FILENAME"
>arch/i386/kernel/</TT
></DT
><DD
><P
>Directory met kernel-initialisatiecode.
<TT
CLASS="FILENAME"
>setup.c</TT
> definieert het ramdisk word.</P
></DD
><DT
><TT
CLASS="FILENAME"
>drivers/block/rd.c</TT
></DT
><DD
><P
>Bevat de ramdisk driver. De procedures
<B
CLASS="COMMAND"
>rd_load</B
> en <B
CLASS="COMMAND"
>rd_load_image</B
> laden blokken vanaf een device naar
ramdisk. De procedure
<B
CLASS="COMMAND"
>identify_ramdisk_image</B
> stelt vast welk
type bestandssysteem is gevonden en of het is gecomprimeerd.</P
></DD
></DL
></DIV
>&#13;</P
></LI
></UL
>&#13;</P
></DIV
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
CLASS="APPENDIX"
><A
NAME="AEN1390"
></A
>B. LILO boot foutcodes</H1
><P
>Vragen over deze foutmeldingen worden zovaak in Usenet gesteld dat we ze
hier als een publieke service hebben opgenomen. Deze samenvatting is
onttrokken uit Werner Almsberger's <A
HREF="http://metalab.unc.edu/pub/Linux/system/boot/lilo/lilo-u-21.ps.gz"
TARGET="_top"
>LILO User Documentation</A
>.</P
><P
>Wanneer LILO zichzelf laadt, geeft het 't woord
<TT
CLASS="LITERAL"
>LILO</TT
> weer. Iedere letter wordt voor of na het
uitvoeren van een bepaalde actie afgedrukt. Als LILO op een bepaald
punt faalt, worden de letters tot zover afgedrukt dat ze kunnen worden
gebruikt om het probleem te identificeren.</P
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN1399"
></A
><P
></P
><TABLE
BORDER="1"
CLASS="CALSTABLE"
><THEAD
><TR
><TH
WIDTH="96"
ALIGN="LEFT"
VALIGN="TOP"
>Uitvoer</TH
><TH
WIDTH="100%"
ALIGN="LEFT"
VALIGN="TOP"
>Probleem</TH
></TR
></THEAD
><TBODY
><TR
><TD
WIDTH="96"
ALIGN="LEFT"
VALIGN="TOP"
>(niets)</TD
><TD
WIDTH="100%"
ALIGN="LEFT"
VALIGN="TOP"
>            Geen enkel onderdeel van LILO werd geladen. LILO is 
            &oacute;f niet ge&iuml;nstalleerd &oacute;f de partitie
            waarop de bootsector voorkomt, is niet actief.
            </TD
></TR
><TR
><TD
WIDTH="96"
ALIGN="LEFT"
VALIGN="TOP"
>L</TD
><TD
WIDTH="100%"
ALIGN="LEFT"
VALIGN="TOP"
>            De eerste fase bootloader werd geladen, maar het kan de
            tweede fase bootloader niet laden. De uit twee cijfers bestaande
            foutcode geeft het type probleem aan. (Zie ook de sectie
            ``Disk foutcodes''.)  Dit geeft meestal aan dat er een media
           storing is &oacute;f een onjuiste geometrie (b.v. verkeerde
           diskparameters).
            </TD
></TR
><TR
><TD
WIDTH="96"
ALIGN="LEFT"
VALIGN="TOP"
>LI</TD
><TD
WIDTH="100%"
ALIGN="LEFT"
VALIGN="TOP"
>            De eerste fase bootloader kon de tweede fase bootloader laden,
            maar lukte het niet het uit te voeren.
            Dit kan &oacute;f worden veroorzaakt door een onjuiste
            geometrie &oacute;f door het verplaatsen van 
            <TT
CLASS="FILENAME"
>/boot/boot.b</TT
> zonder dat de map-installer
            werd uitgevoerd.
            </TD
></TR
><TR
><TD
WIDTH="96"
ALIGN="LEFT"
VALIGN="TOP"
>LIL</TD
><TD
WIDTH="100%"
ALIGN="LEFT"
VALIGN="TOP"
>            De tweede fase bootloader is gestart, maar het kan de
            descriptor tabel vanuit het map-bestand niet laden.
            Dit wordt meestal veroorzaakt door een storing aan media of
            door een onjuiste geometrie.
            </TD
></TR
><TR
><TD
WIDTH="96"
ALIGN="LEFT"
VALIGN="TOP"
>LIL?</TD
><TD
WIDTH="100%"
ALIGN="LEFT"
VALIGN="TOP"
>            De tweede fase bootloader is op een onjuist adres geladen.
            Dit wordt meestal door een subtiel onjuiste geometrie veroorzaakt
            &oacute;f doordat de <TT
CLASS="FILENAME"
>/boot/boot.b</TT
> werd 
            verplaatst zonder dat de map-installer werd uitgevoerd.
            </TD
></TR
><TR
><TD
WIDTH="96"
ALIGN="LEFT"
VALIGN="TOP"
>LIL-</TD
><TD
WIDTH="100%"
ALIGN="LEFT"
VALIGN="TOP"
>            De descriptor tabel is beschadigd. Dit kan &oacute;f worden
            veroorzaakt door een onjuiste geometrie of door het verplaatsen
            van /boot/map zonder de map-installer uit te voeren.
            </TD
></TR
><TR
><TD
WIDTH="96"
ALIGN="LEFT"
VALIGN="TOP"
>LILO</TD
><TD
WIDTH="100%"
ALIGN="LEFT"
VALIGN="TOP"
>            Alle onderdelen van LILO zijn succesvol ge&iuml;nstalleerd.
            </TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
><P
>Als de BIOS een fout signaleert wanneer LILO een bootimage probeert te laden,
wordt de bijbehorende foutcode weergegeven. Deze codes vari&euml;ren van
<TT
CLASS="LITERAL"
>0x00</TT
> tot en met <TT
CLASS="LITERAL"
>0xbb</TT
>. Zie de LILO
Gebruikersgids voor een uitleg van deze foutcodes.</P
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
CLASS="APPENDIX"
><A
NAME="LISTINGS"
></A
>C. Voorbeeldlisting van een rootbestandssysteem</H1
><P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>/:
drwx--x--x   2 root     root         1024 Nov  1 15:39 bin
drwx--x--x   2 root     root         4096 Nov  1 15:39 dev
drwx--x--x   3 root     root         1024 Nov  1 15:39 etc
drwx--x--x   4 root     root         1024 Nov  1 15:39 lib
drwx--x--x   5 root     root         1024 Nov  1 15:39 mnt
drwx--x--x   2 root     root         1024 Nov  1 15:39 proc
drwx--x--x   2 root     root         1024 Nov  1 15:39 root
drwx--x--x   2 root     root         1024 Nov  1 15:39 sbin
drwx--x--x   2 root     root         1024 Nov  1 15:39 tmp
drwx--x--x   7 root     root         1024 Nov  1 15:39 usr
drwx--x--x   5 root     root         1024 Nov  1 15:39 var

/bin:
-rwx--x--x   1 root     root        62660 Nov  1 15:39 ash
-rwx--x--x   1 root     root         9032 Nov  1 15:39 cat
-rwx--x--x   1 root     root        10276 Nov  1 15:39 chmod
-rwx--x--x   1 root     root         9592 Nov  1 15:39 chown
-rwx--x--x   1 root     root        23124 Nov  1 15:39 cp
-rwx--x--x   1 root     root        23028 Nov  1 15:39 date
-rwx--x--x   1 root     root        14052 Nov  1 15:39 dd
-rwx--x--x   1 root     root        14144 Nov  1 15:39 df
-rwx--x--x   1 root     root        69444 Nov  1 15:39 egrep
-rwx--x--x   1 root     root          395 Nov  1 15:39 false
-rwx--x--x   1 root     root        69444 Nov  1 15:39 fgrep
-rwx--x--x   1 root     root        69444 Nov  1 15:39 grep
-rwx--x--x   3 root     root        45436 Nov  1 15:39 gunzip
-rwx--x--x   3 root     root        45436 Nov  1 15:39 gzip
-rwx--x--x   1 root     root         8008 Nov  1 15:39 hostname
-rwx--x--x   1 root     root        12736 Nov  1 15:39 ln
-rws--x--x   1 root     root        15284 Nov  1 15:39 login
-rwx--x--x   1 root     root        29308 Nov  1 15:39 ls
-rwx--x--x   1 root     root         8268 Nov  1 15:39 mkdir
-rwx--x--x   1 root     root         8920 Nov  1 15:39 mknod
-rwx--x--x   1 root     root        24836 Nov  1 15:39 more
-rws--x--x   1 root     root        37640 Nov  1 15:39 mount
-rwx--x--x   1 root     root        12240 Nov  1 15:39 mt
-rwx--x--x   1 root     root        12932 Nov  1 15:39 mv
-r-x--x--x   1 root     root        12324 Nov  1 15:39 ps
-rwx--x--x   1 root     root         5388 Nov  1 15:39 pwd
-rwx--x--x   1 root     root        10092 Nov  1 15:39 rm
lrwxrwxrwx   1 root     root            3 Nov  1 15:39 sh -&#62; ash
-rwx--x--x   1 root     root        25296 Nov  1 15:39 stty
-rws--x--x   1 root     root        12648 Nov  1 15:39 su
-rwx--x--x   1 root     root         4444 Nov  1 15:39 sync
-rwx--x--x   1 root     root       110668 Nov  1 15:39 tar
-rwx--x--x   1 root     root        19712 Nov  1 15:39 touch
-rwx--x--x   1 root     root          395 Nov  1 15:39 true
-rws--x--x   1 root     root        19084 Nov  1 15:39 umount
-rwx--x--x   1 root     root         5368 Nov  1 15:39 uname
-rwx--x--x   3 root     root        45436 Nov  1 15:39 zcat

/dev:
lrwxrwxrwx   1 root     root            6 Nov  1 15:39 cdrom -&#62; cdu31a
brw-rw-r--   1 root     root      15,   0 May  5  1998 cdu31a
crw-------   1 root     root       4,   0 Nov  1 15:29 console
crw-rw-rw-   1 root     uucp       5,  64 Sep  9 19:46 cua0
crw-rw-rw-   1 root     uucp       5,  65 May  5  1998 cua1
crw-rw-rw-   1 root     uucp       5,  66 May  5  1998 cua2
crw-rw-rw-   1 root     uucp       5,  67 May  5  1998 cua3
brw-rw----   1 root     floppy     2,   0 Aug  8 13:54 fd0
brw-rw----   1 root     floppy     2,  36 Aug  8 13:54 fd0CompaQ
brw-rw----   1 root     floppy     2,  84 Aug  8 13:55 fd0D1040
brw-rw----   1 root     floppy     2,  88 Aug  8 13:55 fd0D1120
brw-rw----   1 root     floppy     2,  12 Aug  8 13:54 fd0D360
brw-rw----   1 root     floppy     2,  16 Aug  8 13:54 fd0D720
brw-rw----   1 root     floppy     2, 120 Aug  8 13:55 fd0D800
brw-rw----   1 root     floppy     2,  32 Aug  8 13:54 fd0E2880
brw-rw----   1 root     floppy     2, 104 Aug  8 13:55 fd0E3200
brw-rw----   1 root     floppy     2, 108 Aug  8 13:55 fd0E3520
brw-rw----   1 root     floppy     2, 112 Aug  8 13:55 fd0E3840
brw-rw----   1 root     floppy     2,  28 Aug  8 13:54 fd0H1440
brw-rw----   1 root     floppy     2, 124 Aug  8 13:55 fd0H1600
brw-rw----   1 root     floppy     2,  44 Aug  8 13:55 fd0H1680
brw-rw----   1 root     floppy     2,  60 Aug  8 13:55 fd0H1722
brw-rw----   1 root     floppy     2,  76 Aug  8 13:55 fd0H1743
brw-rw----   1 root     floppy     2,  96 Aug  8 13:55 fd0H1760
brw-rw----   1 root     floppy     2, 116 Aug  8 13:55 fd0H1840
brw-rw----   1 root     floppy     2, 100 Aug  8 13:55 fd0H1920
lrwxrwxrwx   1 root     root            7 Nov  1 15:39 fd0H360 -&#62; fd0D360
lrwxrwxrwx   1 root     root            7 Nov  1 15:39 fd0H720 -&#62; fd0D720
brw-rw----   1 root     floppy     2,  52 Aug  8 13:55 fd0H820
brw-rw----   1 root     floppy     2,  68 Aug  8 13:55 fd0H830
brw-rw----   1 root     floppy     2,   4 Aug  8 13:54 fd0d360
brw-rw----   1 root     floppy     2,   8 Aug  8 13:54 fd0h1200
brw-rw----   1 root     floppy     2,  40 Aug  8 13:54 fd0h1440
brw-rw----   1 root     floppy     2,  56 Aug  8 13:55 fd0h1476
brw-rw----   1 root     floppy     2,  72 Aug  8 13:55 fd0h1494
brw-rw----   1 root     floppy     2,  92 Aug  8 13:55 fd0h1600
brw-rw----   1 root     floppy     2,  20 Aug  8 13:54 fd0h360
brw-rw----   1 root     floppy     2,  48 Aug  8 13:55 fd0h410
brw-rw----   1 root     floppy     2,  64 Aug  8 13:55 fd0h420
brw-rw----   1 root     floppy     2,  24 Aug  8 13:54 fd0h720
brw-rw----   1 root     floppy     2,  80 Aug  8 13:55 fd0h880
brw-rw----   1 root     disk       3,   0 May  5  1998 hda
brw-rw----   1 root     disk       3,   1 May  5  1998 hda1
brw-rw----   1 root     disk       3,   2 May  5  1998 hda2
brw-rw----   1 root     disk       3,   3 May  5  1998 hda3
brw-rw----   1 root     disk       3,   4 May  5  1998 hda4
brw-rw----   1 root     disk       3,   5 May  5  1998 hda5
brw-rw----   1 root     disk       3,   6 May  5  1998 hda6
brw-rw----   1 root     disk       3,  64 May  5  1998 hdb
brw-rw----   1 root     disk       3,  65 May  5  1998 hdb1
brw-rw----   1 root     disk       3,  66 May  5  1998 hdb2
brw-rw----   1 root     disk       3,  67 May  5  1998 hdb3
brw-rw----   1 root     disk       3,  68 May  5  1998 hdb4
brw-rw----   1 root     disk       3,  69 May  5  1998 hdb5
brw-rw----   1 root     disk       3,  70 May  5  1998 hdb6
crw-r-----   1 root     kmem       1,   2 May  5  1998 kmem
crw-r-----   1 root     kmem       1,   1 May  5  1998 mem
lrwxrwxrwx   1 root     root           12 Nov  1 15:39 modem -&#62; ttyS1
lrwxrwxrwx   1 root     root           12 Nov  1 15:39 mouse -&#62; psaux
crw-rw-rw-   1 root     root       1,   3 May  5  1998 null
crwxrwxrwx   1 root     root      10,   1 Oct  5 20:22 psaux
brw-r-----   1 root     disk       1,   1 May  5  1998 ram
brw-rw----   1 root     disk       1,   0 May  5  1998 ram0
brw-rw----   1 root     disk       1,   1 May  5  1998 ram1
brw-rw----   1 root     disk       1,   2 May  5  1998 ram2
brw-rw----   1 root     disk       1,   3 May  5  1998 ram3
brw-rw----   1 root     disk       1,   4 May  5  1998 ram4
brw-rw----   1 root     disk       1,   5 May  5  1998 ram5
brw-rw----   1 root     disk       1,   6 May  5  1998 ram6
brw-rw----   1 root     disk       1,   7 May  5  1998 ram7
brw-rw----   1 root     disk       1,   8 May  5  1998 ram8
brw-rw----   1 root     disk       1,   9 May  5  1998 ram9
lrwxrwxrwx   1 root     root            4 Nov  1 15:39 ramdisk -&#62; ram0
<SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>***  Ik heb slechts die devices voor de IDE-partities opgenomen, waar
***  ik gebruik van maak. Als je gebruik maakt van SCSI, gebruik dan
***  in plaats daarvan de /dev/sdXX devices.</B
></SPAN
>
crw-------   1 root     root       4,   0 May  5  1998 tty0
crw-w-----   1 root     tty        4,   1 Nov  1 15:39 tty1
crw-------   1 root     root       4,   2 Nov  1 15:29 tty2
crw-------   1 root     root       4,   3 Nov  1 15:29 tty3
crw-------   1 root     root       4,   4 Nov  1 15:29 tty4
crw-------   1 root     root       4,   5 Nov  1 15:29 tty5
crw-------   1 root     root       4,   6 Nov  1 15:29 tty6
crw-------   1 root     root       4,   7 May  5  1998 tty7
crw-------   1 root     tty        4,   8 May  5  1998 tty8
crw-------   1 root     tty        4,   9 May  8 12:57 tty9
crw-rw-rw-   1 root     root       4,  65 Nov  1 12:17 ttyS1
crw-rw-rw-   1 root     root       1,   5 May  5  1998 zero

/etc:
-rw-------   1 root     root          164 Nov  1 15:39 conf.modules
-rw-------   1 root     root          668 Nov  1 15:39 fstab
-rw-------   1 root     root           71 Nov  1 15:39 gettydefs
-rw-------   1 root     root          389 Nov  1 15:39 group
-rw-------   1 root     root          413 Nov  1 15:39 inittab
-rw-------   1 root     root           65 Nov  1 15:39 issue
-rw-r--r--   1 root     root          746 Nov  1 15:39 ld.so.cache
-rw-------   1 root     root           32 Nov  1 15:39 motd
-rw-------   1 root     root          949 Nov  1 15:39 nsswitch.conf
drwx--x--x   2 root     root         1024 Nov  1 15:39 pam.d
-rw-------   1 root     root          139 Nov  1 15:39 passwd
-rw-------   1 root     root          516 Nov  1 15:39 profile
-rwx--x--x   1 root     root          387 Nov  1 15:39 rc
-rw-------   1 root     root           55 Nov  1 15:39 shells
-rw-------   1 root     root          774 Nov  1 15:39 termcap
-rw-------   1 root     root           78 Nov  1 15:39 ttytype
lrwxrwxrwx   1 root     root           15 Nov  1 15:39 utmp -&#62; ../var/run/utmp
lrwxrwxrwx   1 root     root           15 Nov  1 15:39 wtmp -&#62; ../var/log/wtmp

/etc/pam.d:
-rw-------   1 root     root          356 Nov  1 15:39 other

/lib:
-rwxr-xr-x   1 root     root        45415 Nov  1 15:39 ld-2.0.7.so
lrwxrwxrwx   1 root     root           11 Nov  1 15:39 ld-linux.so.2 -&#62; ld-2.0.7.so
-rwxr-xr-x   1 root     root       731548 Nov  1 15:39 libc-2.0.7.so
lrwxrwxrwx   1 root     root           13 Nov  1 15:39 libc.so.6 -&#62; libc-2.0.7.so
lrwxrwxrwx   1 root     root           17 Nov  1 15:39 libcom_err.so.2 -&#62; libcom_err.so.2.0
-rwxr-xr-x   1 root     root         6209 Nov  1 15:39 libcom_err.so.2.0
-rwxr-xr-x   1 root     root       153881 Nov  1 15:39 libcrypt-2.0.7.so
lrwxrwxrwx   1 root     root           17 Nov  1 15:39 libcrypt.so.1 -&#62; libcrypt-2.0.7.so
-rwxr-xr-x   1 root     root        12962 Nov  1 15:39 libdl-2.0.7.so
lrwxrwxrwx   1 root     root           14 Nov  1 15:39 libdl.so.2 -&#62; libdl-2.0.7.so
lrwxrwxrwx   1 root     root           16 Nov  1 15:39 libext2fs.so.2 -&#62; libext2fs.so.2.4
-rwxr-xr-x   1 root     root        81382 Nov  1 15:39 libext2fs.so.2.4
-rwxr-xr-x   1 root     root        25222 Nov  1 15:39 libnsl-2.0.7.so
lrwxrwxrwx   1 root     root           15 Nov  1 15:39 libnsl.so.1 -&#62; libnsl-2.0.7.so
-rwx--x--x   1 root     root       178336 Nov  1 15:39 libnss_files-2.0.7.so
lrwxrwxrwx   1 root     root           21 Nov  1 15:39 libnss_files.so.1 -&#62; libnss_files-2.0.7.so
lrwxrwxrwx   1 root     root           14 Nov  1 15:39 libpam.so.0 -&#62; libpam.so.0.64
-rwxr-xr-x   1 root     root        26906 Nov  1 15:39 libpam.so.0.64
lrwxrwxrwx   1 root     root           19 Nov  1 15:39 libpam_misc.so.0 -&#62; libpam_misc.so.0.64
-rwxr-xr-x   1 root     root         7086 Nov  1 15:39 libpam_misc.so.0.64
-r-xr-xr-x   1 root     root        35615 Nov  1 15:39 libproc.so.1.2.6
lrwxrwxrwx   1 root     root           15 Nov  1 15:39 libpwdb.so.0 -&#62; libpwdb.so.0.54
-rw-r-r---   1 root     root       121899 Nov  1 15:39 libpwdb.so.0.54
lrwxrwxrwx   1 root     root           19 Nov  1 15:39 libtermcap.so.2 -&#62; libtermcap.so.2.0.8
-rwxr-xr-x   1 root     root        12041 Nov  1 15:39 libtermcap.so.2.0.8
-rwxr-xr-x   1 root     root        12874 Nov  1 15:39 libutil-2.0.7.so
lrwxrwxrwx   1 root     root           16 Nov  1 15:39 libutil.so.1 -&#62; libutil-2.0.7.so
lrwxrwxrwx   1 root     root           14 Nov  1 15:39 libuuid.so.1 -&#62; libuuid.so.1.1
-rwxr-xr-x   1 root     root         8039 Nov  1 15:39 libuuid.so.1.1
drwx--x--x   3 root     root         1024 Nov  1 15:39 modules
drwx--x--x   2 root     root         1024 Nov  1 15:39 security

/lib/modules:
drwx--x--x   4 root     root         1024 Nov  1 15:39 2.0.35

/lib/modules/2.0.35:
drwx--x--x   2 root     root         1024 Nov  1 15:39 block
drwx--x--x   2 root     root         1024 Nov  1 15:39 cdrom

/lib/modules/2.0.35/block:
drwx------   1 root     root         7156 Nov  1 15:39 loop.o

/lib/modules/2.0.35/cdrom:
drwx------   1 root     root        24108 Nov  1 15:39 cdu31a.o

/lib/security:
-rwx--x--x   1 root     root         8771 Nov  1 15:39 pam_permit.so

<SPAN
CLASS="bold"
><B
CLASS="EMPHASIS"
>***  Directory stubs voor het mounten</B
></SPAN
>
/mnt:
drwx--x--x   2 root     root         1024 Nov  1 15:39 cdrom
drwx--x--x   2 root     root         1024 Nov  1 15:39 floppy

/proc:

/root:
-rw-------   1 root     root          176 Nov  1 15:39 .bashrc
-rw-------   1 root     root          182 Nov  1 15:39 .cshrc
-rwx--x--x   1 root     root          455 Nov  1 15:39 .profile
-rw-------   1 root     root         4014 Nov  1 15:39 .tcshrc

/sbin:
-rwx--x--x   1 root     root        23976 Nov  1 15:39 depmod
-rwx--x--x   2 root     root       274600 Nov  1 15:39 e2fsck
-rwx--x--x   1 root     root        41268 Nov  1 15:39 fdisk
-rwx--x--x   1 root     root         9396 Nov  1 15:39 fsck
-rwx--x--x   2 root     root       274600 Nov  1 15:39 fsck.ext2
-rwx--x--x   1 root     root        29556 Nov  1 15:39 getty
-rwx--x--x   1 root     root         6620 Nov  1 15:39 halt
-rwx--x--x   1 root     root        23116 Nov  1 15:39 init
-rwx--x--x   1 root     root        25612 Nov  1 15:39 insmod
-rwx--x--x   1 root     root        10368 Nov  1 15:39 kerneld
-rwx--x--x   1 root     root       110400 Nov  1 15:39 ldconfig
-rwx--x--x   1 root     root         6108 Nov  1 15:39 lsmod
-rwx--x--x   2 root     root        17400 Nov  1 15:39 mke2fs
-rwx--x--x   1 root     root         4072 Nov  1 15:39 mkfs
-rwx--x--x   2 root     root        17400 Nov  1 15:39 mkfs.ext2
-rwx--x--x   1 root     root         5664 Nov  1 15:39 mkswap
-rwx--x--x   1 root     root        22032 Nov  1 15:39 modprobe
lrwxrwxrwx   1 root     root            4 Nov  1 15:39 reboot -&#62; halt
-rwx--x--x   1 root     root         7492 Nov  1 15:39 rmmod
-rwx--x--x   1 root     root        12932 Nov  1 15:39 shutdown
lrwxrwxrwx   1 root     root            6 Nov  1 15:39 swapoff -&#62; swapon
-rwx--x--x   1 root     root         5124 Nov  1 15:39 swapon
lrwxrwxrwx   1 root     root            4 Nov  1 15:39 telinit -&#62; init
-rwx--x--x   1 root     root         6944 Nov  1 15:39 update

/tmp:

/usr:
drwx--x--x   2 root     root         1024 Nov  1 15:39 bin
drwx--x--x   2 root     root         1024 Nov  1 15:39 lib
drwx--x--x   3 root     root         1024 Nov  1 15:39 man
drwx--x--x   2 root     root         1024 Nov  1 15:39 sbin
drwx--x--x   3 root     root         1024 Nov  1 15:39 share
lrwxrwxrwx   1 root     root           10 Nov  1 15:39 tmp -&#62; ../var/tmp

/usr/bin:
-rwx--x--x   1 root     root        37164 Nov  1 15:39 afio
-rwx--x--x   1 root     root         5044 Nov  1 15:39 chroot
-rwx--x--x   1 root     root        10656 Nov  1 15:39 cut
-rwx--x--x   1 root     root        63652 Nov  1 15:39 diff
-rwx--x--x   1 root     root        12972 Nov  1 15:39 du
-rwx--x--x   1 root     root        56552 Nov  1 15:39 find
-r-x--x--x   1 root     root         6280 Nov  1 15:39 free
-rwx--x--x   1 root     root         7680 Nov  1 15:39 head
-rwx--x--x   1 root     root         8504 Nov  1 15:39 id
-r-sr-xr-x   1 root     bin          4200 Nov  1 15:39 passwd
-rwx--x--x   1 root     root        14856 Nov  1 15:39 tail
-rwx--x--x   1 root     root        19008 Nov  1 15:39 tr
-rwx--x--x   1 root     root         7160 Nov  1 15:39 wc
-rwx--x--x   1 root     root         4412 Nov  1 15:39 whoami

/usr/lib:
lrwxrwxrwx   1 root     root           17 Nov  1 15:39 libncurses.so.4 -&#62; libncurses.so.4.2
-rw-r-r---   1 root     root       260474 Nov  1 15:39 libncurses.so.4.2

/usr/sbin:
-r-x--x--x   1 root     root        13684 Nov  1 15:39 fuser
-rwx--x--x   1 root     root         3876 Nov  1 15:39 mklost+found

/usr/share:
drwx--x--x   4 root     root         1024 Nov  1 15:39 terminfo

/usr/share/terminfo:
drwx--x--x   2 root     root         1024 Nov  1 15:39 l
drwx--x--x   2 root     root         1024 Nov  1 15:39 v

/usr/share/terminfo/l:
-rw-------   1 root     root         1552 Nov  1 15:39 linux
-rw-------   1 root     root         1516 Nov  1 15:39 linux-m
-rw-------   1 root     root         1583 Nov  1 15:39 linux-nic

/usr/share/terminfo/v:
-rw-------   2 root     root         1143 Nov  1 15:39 vt100
-rw-------   2 root     root         1143 Nov  1 15:39 vt100-am

/var:
drwx--x--x   2 root     root         1024 Nov  1 15:39 log
drwx--x--x   2 root     root         1024 Nov  1 15:39 run
drwx--x--x   2 root     root         1024 Nov  1 15:39 tmp

/var/log:
-rw-------   1 root     root            0 Nov  1 15:39 wtmp

/var/run:
-rw-------   1 root     root            0 Nov  1 15:39 utmp

/var/tmp:</PRE
></TD
></TR
></TABLE
></P
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
CLASS="APPENDIX"
><A
NAME="UTILITYLIST"
></A
>D. Voorbeeldlisting van een utilitydisk</H1
><P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>total 579
-rwxr-xr-x   1 root     root        42333 Jul 28 19:05 cpio
-rwxr-xr-x   1 root     root        32844 Aug 28 19:50 debugfs
-rwxr-xr-x   1 root     root       103560 Jul 29 21:31 elvis
-rwxr-xr-x   1 root     root        29536 Jul 28 19:04 fdisk
-rw-r-r---   1 root     root       128254 Jul 28 19:03 ftape.o
-rwxr-xr-x   1 root     root        17564 Jul 25 03:21 ftmt
-rwxr-xr-x   1 root     root        64161 Jul 29 20:47 grep
-rwxr-xr-x   1 root     root        45309 Jul 29 20:48 gzip
-rwxr-xr-x   1 root     root        23560 Jul 28 19:04 insmod
-rwxr-xr-x   1 root     root          118 Jul 28 19:04 lsmod
lrwxrwxrwx   1 root     root            5 Jul 28 19:04 mt -&#62; mt-st
-rwxr-xr-x   1 root     root         9573 Jul 28 19:03 mt-st
lrwxrwxrwx   1 root     root            6 Jul 28 19:05 rmmod -&#62; insmod
-rwxr-xr-x   1 root     root       104085 Jul 28 19:05 tar
lrwxrwxrwx   1 root     root            5 Jul 29 21:35 vi -&#62; elvis</PRE
></TD
></TR
></TABLE
></P
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Noten</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN336"
HREF="#AEN336"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>De directorystructuur die hier wordt gepresenteerd is alleen voor
het gebruik van een rootdiskette.
Echte Linux-systemen hebben een complexere en meer gedisciplineerde set
gedragslijnen, genaamd de
<A
HREF="http://www.pathname.com/fhs/2.0/fhs-toc.html"
TARGET="_top"
>Filesystem
Hierarchy Standard</A
>, voor het vaststellen waar welke bestanden in 
staan).</P
></TD
></TR
></TABLE
></BODY
></HTML
>