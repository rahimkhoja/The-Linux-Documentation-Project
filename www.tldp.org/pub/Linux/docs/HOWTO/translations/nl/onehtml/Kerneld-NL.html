<HTML
><HEAD
><TITLE
>Linux kerneld mini-HOWTO</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"></HEAD
><BODY
CLASS="ARTICLE"
BACKGROUND="../IMAGES/back.gif"
LINK="#000099"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
></A
>Linux kerneld mini-HOWTO</H1
><DIV
CLASS="AUTHORGROUP"
><A
NAME="AEN4"
></A
><H3
CLASS="AUTHOR"
><A
NAME="AEN5"
>Henrik Storner</A
></H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
><TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:kerneld-howto@linuxdoc.org"
>kerneld-howto@linuxdoc.org</A
>&#62;</TT
></P
></DIV
></DIV
><H3
CLASS="AUTHOR"
><A
NAME="AEN11"
>Vertaald door: Ellen Bokhorst</A
></H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
><TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:bokkie@nl.linux.org"
>bokkie@nl.linux.org</A
>&#62;</TT
></P
></DIV
></DIV
></DIV
><P
CLASS="COPYRIGHT"
>Copyright &copy; 2000 Linux Documentation
      Project</P
><DIV
CLASS="REVHISTORY"
><TABLE
WIDTH="100%"
BORDER="0"
><TR
><TH
ALIGN="LEFT"
VALIGN="TOP"
COLSPAN="3"
><B
>Revision History</B
></TH
></TR
><TR
><TD
ALIGN="LEFT"
>Revision v2.0</TD
><TD
ALIGN="LEFT"
>22 mei 2000</TD
><TD
ALIGN="LEFT"
></TD
></TR
><TR
><TD
ALIGN="LEFT"
COLSPAN="3"
>conversie van HTML naar DocBook SGML.</TD
></TR
></TABLE
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#AEN32"
>Over de kerneld mini-HOWTO</A
></DT
><DT
><A
HREF="#INTRODUCTION"
>Wat is kerneld?</A
></DT
><DT
><A
HREF="#SETUP"
>Hoe stel ik het in?</A
></DT
><DT
><A
HREF="#CONFIGURATION"
>Hoe weet kerneld welke module te laden?</A
></DT
><DT
><A
HREF="#SPECIAL-DEVS"
>Devices waarvoor speciale configuratie nodig is</A
></DT
><DT
><A
HREF="#SPYING"
>Kerneld bespioneren</A
></DT
><DT
><A
HREF="#GOODIES"
>Speciale kerneld gebruiken</A
></DT
><DT
><A
HREF="#COMMONPROBLEMS"
>Algemene problemen en dingen die je je wellicht afvraagt</A
></DT
></DL
></DIV
><DIV
CLASS="SECT1"
><H2
CLASS="SECT1"
><A
NAME="AEN32"
></A
>Over de kerneld mini-HOWTO</H2
><P
>In dit document wordt uitgelegd hoe de automatische kernel
      module loader <SPAN
CLASS="QUOTE"
>"kerneld"</SPAN
> te
      installeren en gebruiken. De laatst uitgegeven versie van
      dit document is te vinden bij <A
HREF="http://www.linuxdoc.org"
TARGET="_top"
>het Linux Documentatie Project</A
>
      </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CREDITS"
></A
>Krediet</H3
><P
>Dit document is gebaseerd op een oorspronkelijke
      HTML versie 1.7 gedateerd 19 juli 1997 door Henrik Storner
      <TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:storner@osiris.ping.dk"
>storner@osiris.ping.dk</A
>&#62;</TT
> en het werd gereviseerd
      en omgezet volgens de DocBook DTD door Gary Lawrence Murphy
      <TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:garym@teledyn.com"
>garym@teledyn.com</A
>&#62;</TT
> 20 mei 2000.</P
><P
>De volgende mensen hebben op een of andere wijze een
      bijdrage aan deze mini-HOWTO geleverd:
      </P
><P
></P
><UL
><LI
><P
>Bjorn Ekwall bj0rn@blox.se</P
></LI
><LI
><P
>Ben Galliart bgallia@luc.edu</P
></LI
><LI
><P
>Cedric Tefft cedric@earthling.net</P
></LI
><LI
><P
>Brian Miller bmiller@netspace.net.au</P
></LI
><LI
><P
>James C. Tsiao
        jtsiao@madoka.jpl.nasa.gov</P
></LI
></UL
><P
>Stuur alsjeblieft een e-mail naar
      <TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:kerneld-howto@linuxdoc.org"
>kerneld-howto@linuxdoc.org</A
>&#62;</TT
> als je fouten aantreft
      in dit document. Je opmerkingen, aanmoedigingen, en suggesties
      zijn welkom en worden gewaardeerd, en zijn van hulp bij het
      garanderen dat deze handleiding actueel en accuraat blijft.
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="INTRODUCTION"
></A
>Wat is kerneld?</H2
><P
>De kerneld feature werd ge&iuml;ntroduceerd tijdens
      de 1.3 ontwikkelaarskernels door Bjorn Ekwall. Je kunt er
      kernelmodules, zoals devicedrivers, netwerkdrivers en
      bestandssystemen automatisch mee laden wanneer ze nodig zijn,
      in plaats van dat je dit handmatig moet doen met
      <B
CLASS="COMMAND"
>modprobe</B
> of <B
CLASS="COMMAND"
>insmod</B
>. </P
><P
>En voor de wat amusantere aspecten, alhoewel deze (nog?)
      niet zijn ge&iuml;ntegreerd in de standaardkernel:</P
><P
></P
><UL
><LI
><P
>Het kan zo worden ingesteld dat het een
	gebruikersprogramma uitvoert in plaats van de standaard
	schermbeveiliging, dus dat het je elk programma als 
	screen-saver laat gebruiken.
        </P
></LI
><LI
><P
>Vergelijkbaar met de screen-blanker ondersteuning,
	kun je ook de standaard console beep in iets totaal anders
	wijzigen.
        </P
></LI
></UL
><P
>kerneld bestaat uit twee componenten: </P
><P
></P
><UL
><LI
><P
>Ondersteuning in de Linux kernel voor het
	versturen van verzoeken naar een daemon vragend om een
	een module voor een bepaalde taak.
        </P
></LI
><LI
><P
>Een user-space daemon die uit kan zoeken
	welke modules moeten worden geladen om aan het verzoek van
	de kernel te voldoen.
         </P
></LI
></UL
><P
>Beide componenten moeten werken wil de kerneld ondersteuning
      functioneren; het is niet genoeg dat slechts de een of de ander
      is ingesteld.
        </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="WHY"
></A
>Waarom zou ik het willen gebruiken?</H3
><P
>Er zijn een aantal goede redenen waarom je kerneld
      zou willen gebruiken. De redenen die ik hier benoem, zijn mijn
      redenen, anderen hebben weer andere redenen.</P
><P
></P
><UL
><LI
><P
>Als je kernels hebt gebouwd voor verscheidene
	systemen met slechts kleine verschillen, zoals een ander
	soort netwerkkaart, bijvoorbeeld, dan kun je een enkele
	kernel bouwen met een aantal modules in plaats van
	individuele kernels voor elk systeem.
        </P
></LI
><LI
><P
>Modules zijn voor ontwikkelaars eenvoudiger
	te testen. Je hoeft het systeem niet opnieuw op te starten
	om de driver te laden of uit het geheugen te laten verwijderen;
        dit geldt voor alle modules, niet alleen voor via kerneld
	geladen modules.
        </P
></LI
><LI
><P
>Het scheelt je in geheugen voor de kernel,
	waardoor er meer geheugen overblijft voor applicaties.
        Geheugen dat door de kernel wordt gebruikt, wordt
        <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>nooit</I
></SPAN
> naar disk geswapt, dus als je
	voor 100Kb aan ongebruikte drivers in je kernel hebt
	gecompileerd, dan is dat simpelweg een verspilling van RAM.
        </P
></LI
><LI
><P
>Een aantal dingen die ik gebruik zoals 
	bijvoorbeeld de ftape floppy-tape driver of iBCS, zijn
	alleen beschikbaar als modules, maar ik wil me niet
	druk hoeven maken om het laden of weer uit het geheugen
	verwijderen van deze modules wanneer ik ze nodig heb.
        </P
></LI
><LI
><P
>Mensen die Linux distributies samenstellen
	hoeven geen 284 verschillende bootimages te bouwen: Elke
	gebruiker laadt de modules die hij nodig heeft voor zijn
	hardware. De meeste moderne Linux distributies zullen je
	hardware detecteren en zullen alleen die modules laden die
	werkelijk nodig zijn.
        </P
></LI
></UL
><P
>Natuurlijk zijn er ook redenen waarom je ze niet wilt
      gebruiken. Als je het gebruik van slechts &eacute;&eacute;n
      kernel image bestand waar alle drivers zijn ingebouwd prefereert,
      dan lees je het verkeerde document.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="WHERE"
></A
>Waar haal ik de benodigde onderdelen vandaan?
    ?</H3
><P
>De ondersteuning in de Linux kernel werd bij Linux 1.3.57
      ge&iuml;ntroduceerd. Als je een eerdere kernelversie hebt, dan
      zul je moeten upgraden als je de kerneld ondersteuning wilt. De
      huidige Linux kernelsources zijn te vinden op de meeste Linux
      FTP archiefsites waaronder:</P
><P
></P
><UL
><LI
><P
><A
HREF="ftp://ftp.kernel.org/pub/linux/kernel/"
TARGET="_top"
>Kernel.Org
          archief</A
></P
></LI
><LI
><P
><A
HREF="ftp://metalab.unc.edu/pub/Linux/kernel/"
TARGET="_top"
>Metalab Linux
          archief</A
></P
></LI
><LI
><P
><A
HREF="ftp://tsx-11.mit.edu/pub/linux/sources/system/"
TARGET="_top"
>TSX-11
          op MIT</A
></P
></LI
></UL
><P
>De user-space daemon is opgenomen in het
      <SPAN
CLASS="PRODUCTNAME"
>modules</SPAN
> package. Deze zijn normaal
      gesproken vanaf dezelfde plaats beschikbaar als de kernelsources.
      </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/IMAGES//note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Als je het module laden wilt proberen met de laatste
      <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>ontwikkelaars</I
></SPAN
> kernels, dan moet je het
      nieuwere <SPAN
CLASS="PRODUCTNAME"
>modutils</SPAN
> package gebruiken
      en niet de <SPAN
CLASS="PRODUCTNAME"
>modules</SPAN
>. Bekijk altijd
      het <TT
CLASS="FILENAME"
>Documentation/Changes</TT
> bestand in de kernel
      sources voor het minimum vereiste versienummer voor je kernelimage.
      Zie ook  over de problemen
      die zich voordeden met modules en 2.1 kernels.
      </P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SETUP"
></A
>Hoe stel ik het in?</H2
><P
>Zorg eerst dat je aan de benodigde onderdelen komt:
      een geschikte kernel en het laatste
      <SPAN
CLASS="PRODUCTNAME"
>modules</SPAN
> package.  Dan moet je
      de module utility's volgens de instructies in het package
      installeren. Tamelijk simpel: Pak gewoon de broncode uit en
      start <B
CLASS="COMMAND"
>make install</B
>. Hiermee worden de
      volgende programma's in <TT
CLASS="FILENAME"
>/sbin</TT
> ge&iuml;nstalleerd:
      <B
CLASS="COMMAND"
>genksysm</B
>, <B
CLASS="COMMAND"
>insmod</B
>,
      <B
CLASS="COMMAND"
>lsmod</B
>, <B
CLASS="COMMAND"
>modprobe</B
>,
      <B
CLASS="COMMAND"
>depmod</B
> en <B
CLASS="COMMAND"
>kerneld</B
>. Ik raad
      je aan wat regels toe te voegen aan je opstartscripts om de 
      benodigde setup uit te voeren op het moment dat je Linux boot.
      Voeg de volgende regels toe aan het bestand
      <TT
CLASS="FILENAME"
>/etc/rc.d/rc.S</TT
> (als je Slackware draait) of
      aan <TT
CLASS="FILENAME"
>/etc/rc.d/rc.sysinit</TT
> als je
      SysVinit, d.w.z. Debian, Corel, RedHat, Mandrake of Caldera
      draait:
      </P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        # Start kerneld - dit moet zeer vroeg gebeuren in het bootproces,
	# zeker VOORDAT je fsck op bestandssystemen uitvoert
        # waarvoor wellicht automatisch diskdrivers moeten worden geladen
        if [ -x /sbin/kerneld ]
        then
                /sbin/kerneld
        fi

        # Hier komen de standaard fsck opdrachten
        # En de mount opdracht om het root fs read-write te mounten

        # Update kernel-module dependencies file
        # Je root-fs MOET nu read-write zijn gemount
        if [ -x /sbin/depmod ]
        then
                /sbin/depmod -a
        fi</PRE
></TD
></TR
></TABLE
><P
>Deze opdrachten kunnen reeds voorkomen in het SysV init
      script. Het eerste deel start kerneld zelf. Het tweede deel
      roept <B
CLASS="COMMAND"
>depmod -a</B
> tijdens de systeemstart
      aan om een lijst met alle beschikbare modules samen te stellen
      en het analyseert de onderlinge afhankelijkheden. De
      depmod map vertelt kerneld dan of voor een module een andere
      module moet zijn geladen voordat het zichzelf laadt.
      </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/IMAGES//note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Recente versies van kerneld hebben een optie om te worden
      gelinkt met de GNU gdbm library, <SPAN
CLASS="PRODUCTNAME"
>libgdbm</SPAN
>. 
      Als je dit activeert bij het bouwen van de module utility's, dan
      <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>zal kerneld niet starten als libgdm niet beschikbaar is
      </I
></SPAN
> wat het geval kan zijn als 
      <TT
CLASS="FILENAME"
>/usr</TT
> zich op een aparte partitie bevindt
      en het starten van kerneld plaatsvindt voordat <TT
CLASS="FILENAME"
>/usr</TT
> 
      is gemount. De aanbevolen oplossing is om 
      <TT
CLASS="FILENAME"
>/usr/lib/libgdbm</TT
> te verplaatsen naar
      <TT
CLASS="FILENAME"
>/lib</TT
>, of om kerneld statisch te linken.
      </P
></TD
></TR
></TABLE
></DIV
><P
>Pak vervolgens de kernelsources uit, configureer en bouw
      naar wens een kernel. Als je dit nog nooit eerder hebt gedaan,
      dan moet je beslist het README bestand lezen in de hoofdirectory
      van de Linux sources. Wanneer je <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>make xconfig</I
></SPAN
>
      uitvoert om de kernel te configureren, let dan op de volgende
      vragen:</P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  Enable loadable module support (CONFIG_MODULES) [Y/n/?] Y</PRE
></TD
></TR
></TABLE
><P
>Je moet de laadbare module ondersteuning selecteren, anders
      zullen er geen te laden modules zijn voor kerneld! Geef gewoon
      Y als antwoord.
      </P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  Kernel daemon support (CONFIG_KERNELD) [Y/n/?] Y</PRE
></TD
></TR
></TABLE
><P
>Dit is natuurlijk ook nodig. Dan is er heel veel wat als module
      kan worden gebouwd, je zult vragen te zien krijgen als:
      </P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  Normal floppy disk support (CONFIG_BLK_DEV_FD) [M/n/y/?] </PRE
></TD
></TR
></TABLE
><P
>waar je kunt antwoorden met een <SPAN
CLASS="KEYSYM"
>M</SPAN
> voor
      <SPAN
CLASS="QUOTE"
>"Module"</SPAN
>. Gewoonlijk hoeven alleen de drivers die
      nodig zijn op je systeem om op te starten in de kernel te worden gebouwd;
      de rest kan worden gebouwd als modules.
      </P
><DIV
CLASS="CAUTION"
><P
></P
><TABLE
CLASS="CAUTION"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/IMAGES//caution.gif"
HSPACE="5"
ALT="Caution"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Essenti&euml;le drivers</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Essenti&euml;le drivers
        die noodzakelijk zijn om je systeem te booten moeten in de core
	kernel worden gecompileerd en kunnen niet als modules worden geladen.
        Kenmerkend zijn hier de harddisk-driver en de driver voor het root
	filesysteem. Als je een dual-boot machine hebt en het rekent op
	bestanden die te vinden zijn op de andere partitie, dan moet je
	in de core kernel ook ondersteuning compileren voor dat bestandssysteem.
        </P
></TD
></TR
></TABLE
></DIV
><P
>Wanneer je <B
CLASS="COMMAND"
>make config</B
> hebt doorlopen, 
      compileer en installeer je de nieuwe kernel en de modules met
      <B
CLASS="COMMAND"
>make dep clean bzlilo modules modules_install</B
>.</P
><P
>Oef. </P
><DIV
CLASS="TIP"
><P
></P
><TABLE
CLASS="TIP"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/IMAGES//tip.gif"
HSPACE="5"
ALT="Tip"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Compileren van een kernel-image</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>De opdracht
        <B
CLASS="COMMAND"
>make zImage</B
> zal stoppen zonder een kernel
	te installeren en de nieuwe kernel-image achterlaten in het
	bestand <TT
CLASS="FILENAME"
>arch/i386/boot/zImage</TT
>. Om dit image
	te gaan gebruiken, zul je het naar waar je je boot-image hebt,
	moeten kopi&euml;ren en het handmatig met LILO moeten installeren.
        </P
><P
>Zie voor meer informatie over het configureren, bouwen
	en installeren van je eigen kernel de Kernel-HOWTO, welke
        regelmatig wordt gepost naar 
	<TT
CLASS="FILENAME"
>comp.os.linux.answers</TT
>, en beschikbaar is
        vanaf <A
HREF="http://www.linuxdoc.org"
TARGET="_top"
>het Linux
        Documentatie Project</A
> en mirrors.</P
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="TESTING"
></A
>Kerneld uitproberen</H3
><P
>Start je systeem nu opnieuw op met de nieuwe kernel. Wanneer het
      systeem weer opkomt, kun je <B
CLASS="COMMAND"
>ps ax</B
> uitvoeren, 
      en als het goed is, zie je dan een regel voor kerneld: </P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>    PID TTY STAT  TIME COMMAND
     59  ?  S     0:01 /sbin/kerneld</PRE
></TD
></TR
></TABLE
><P
>Een van de fraaie dingen met kerneld is dat zodra je
      de kernel en de daemon hebt ge&iuml;nstalleerd, er weinig
      instellingen nodig zijn. Probeer om te beginnen &eacute;&eacute;n
      van de drivers die je als een module compileerde; het is eerder
      waarschijnlijk dan niet dat het zonder verdere configuratie zal
      werken. Als ik de floppy driver als een module compileerde, dan
      zou ik een DOS diskette in het diskettestation kunnen doen en
      typen:
      </P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  osiris:~ $ mdir a:
   Volume in drive A has no label
   Volume Serial Number is 2E2B-1102
   Directory for A:/

  binuti~1 gz       1942 02-14-1996  11:35a binutils-2.6.0.6-2.6.0.7.diff.gz
  libc-5~1 gz      24747 02-14-1996  11:35a libc-5.3.4-5.3.5.diff.gz
          2 file(s)        26689 bytes</PRE
></TD
></TR
></TABLE
><P
>De floppy driver werkt! Het wordt automatisch door kerneld
      geladen wanneer ik de floppy disk probeer te gebruiken.
      </P
><P
>Om te bekijken of de floppy module inderdaad is geladen, kun
      je <B
CLASS="COMMAND"
>/sbin/lsmod</B
> uitvoeren om een opsomming van
      alle thans geladen modules te zien te krijgen:
      </P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  osiris:~ $ /sbin/lsmod 
  Module:        #pages:  Used by:
  floppy            11    0 (autoclean)</PRE
></TD
></TR
></TABLE
><P
>De <SPAN
CLASS="QUOTE"
>"(autoclean)"</SPAN
> betekent dat de module
      automatisch door kerneld zal worden verwijderd als het meer
      dan een minuut niet wordt gebruikt. Dus de 11 pagina's geheugen
      (= 44kB, &eacute;&eacute;n pagina is 4 kB) zullen alleen worden
      gebruikt wanneer ik het diskettestation benader. Gebruik ik de
      diskette meer dan een minuut niet, dan wordt het geheugen
      vrijgegeven. Heel fraai, als je weinig geheugen hebt voor je
      applicaties!
      </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="CONFIGURATION"
></A
>Hoe weet kerneld welke module te laden?</H2
><P
>Alhoewel kerneld met ingebouwde kennis wordt geleverd over
      de meest gebruikelijke typen modules, zijn er situaties waar
      kerneld niet weet hoe een verzoek van de kernel af te handelen.
      Dit is het geval bij bv CD-ROM drivers of netwerkdrivers, waarbij
      er meer dan &eacute;&eacute;n mogelijke module kan worden geladen.
      </P
><P
>Het verzoek dat de daemon kerneld krijgt van de kernel is
      voor &eacute;&eacute;n van de volgende items:</P
><P
></P
><UL
><LI
><P
>een block-device driver </P
></LI
><LI
><P
>een character-device driver </P
></LI
><LI
><P
>een binair formaat </P
></LI
><LI
><P
>een lijndiscipline </P
></LI
><LI
><P
>een bestandssysteem </P
></LI
><LI
><P
>een netwerkdevice </P
></LI
><LI
><P
>een netwerkservice (b.v. rarp) </P
></LI
><LI
><P
>een protocol (b.v. IPX)
        </P
></LI
></UL
><P
>Kerneld stelt vast welke module moet worden geladen door
      het configuratiebestand <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
>
      <A
NAME="AEN198"
HREF="#FTN.AEN198"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
> te scannen. 
      In dit bestand bevinden zich twee soorten regels: Directorypaden
      waar de module bestanden zijn te vinden, en aan de module toegekende
      aliassen die moet worden geladen voor een gegeven service.
      Als dit bestand nog niet bestaat, dan kun je het aanmaken door het
      uitvoeren van:
      </P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  /sbin/modprobe -c | grep -v '^path' /etc/conf.modules</PRE
></TD
></TR
></TABLE
><P
>Als je nog een andere path directive toe wilt voegen aan
      de standaard directorypaden, dan moet je tevens alle standaard
      directorypaden opnemen, aangezien een path directive in
      <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
> alle paden die modprobe
      standaard kent zullen worden <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>vervangen</I
></SPAN
> door het
      toegevoegde pad.
      </P
><P
>Normaal gesproken zul je zelf geen directorypaden willen
      toevoegen, aangezien de ingebouwde set zou moeten voorzien in
      alle normale setups.
      </P
><P
>Als je aan de andere kant een alias of option directive
      toe wilt voegen, dan zullen je nieuwe regels in
      <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
> worden toegevoegd
      aan die modprobe reeds kent. Als je een alias of
      optie <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>herdefinieert</I
></SPAN
> dan zullen je
      nieuwe regels in <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
>
      de ingebouwde regels overschrijven.</P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="BLOCKDEV"
></A
>Block devices</H3
><P
>Als je <B
CLASS="COMMAND"
>/sbin/modprobe -c</B
> uitvoert, dan
      zul je een overzicht krijgen met de modules die kerneld kent,
      en met welke verzoeken zij corresponderen. Het verzoek bijvoorbeeld
      dat er op neerkomt dat de floppy driver wordt geladen is voor het
      block-device met major nummer 2:</P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  osiris:~ $ /sbin/modprobe -c | grep floppy
  alias block-major-2 floppy</PRE
></TD
></TR
></TABLE
><P
>Waarom <TT
CLASS="FILENAME"
>block-major-2</TT
>? Omdat de
     floppy devices <TT
CLASS="FILENAME"
>/dev/fd*</TT
> gebruik maken
     van major device 2 en het block devices zijn:
     </P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  osiris:~ $ ls -l /dev/fd0 /dev/fd1
  brw-rw-rw-   1 root     root       2,   0 Mar  3  1995 /dev/fd0
  brw-r--r--   1 root     root       2,   1 Mar  3  1995 /dev/fd1</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CHARDEV"
></A
>Character devices</H3
><P
>Met Character devices wordt op vergelijkbare wijze
	omgegaan. B.v. de ftape floppy tape driver neemt de plaats in van
        major-device 27: </P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  osiris:~ $ ls -lL /dev/ftape 
  crw-rw----   1 root     disk      27,   0 Jul 18  1994 /dev/ftape</PRE
></TD
></TR
></TABLE
><P
>Kerneld is standaard echter niet op de hoogte van de
	ftape driver, het wordt niet weergegeven in de uitvoer van
        <B
CLASS="COMMAND"
>/sbin/modprobe -c</B
>. Voor het instellen van
	kerneld dat het de ftape driver laadt, moet ik een regel
	toevoegen aan het configuratiebestand 
	<TT
CLASS="FILENAME"
>/etc/conf.modules</TT
>:
        </P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  alias char-major-27 ftape</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="ETH0"
></A
>Netwerkdevices</H3
><P
>Je kunt ook de naam van het device gebruiken in plaats
	van de <TT
CLASS="LITERAL"
>char-major-xxx</TT
> of
        <TT
CLASS="LITERAL"
>block-major-yyy</TT
> setup. Dit is vooral handig
	bij netwerkdrivers. Een driver voor een ne2000 netwerkkaart
	bijvoorbeeld, fungerend als <TT
CLASS="FILENAME"
>eth0</TT
> zou
	worden geladen met</P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  alias eth0 ne</PRE
></TD
></TR
></TABLE
><P
>Als je een aantal opties aan de driver door moet geven,
	bijvoorbeeld om de module te laten weten welk IRQ de netwerkkaart
	gebruikt, dan moet je een <SPAN
CLASS="QUOTE"
>"options"</SPAN
> regel 
	toevoegen: </P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  options ne irq=5</PRE
></TD
></TR
></TABLE
><P
>Dit zorgt ervoor dat kerneld de NE2000 driver laadt met de
	opdracht
        </P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  /sbin/modprobe ne irq=5</PRE
></TD
></TR
></TABLE
><P
>Natuurlijk zijn de werkelijke beschikbare opties specifiek
	voor de module die je laadt.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="BINFMT"
></A
>Binaire formaten</H3
><P
>Binaire formaten worden op vergelijkbare wijze afgehandeld.
	Wanneer je een programma probeert uit te voeren waarvan de kernel
	niet weet hoe het te laden, dan krijgt kerneld een verzoek voor
        <TT
CLASS="LITERAL"
>binfmt-</TT
><TT
CLASS="VARNAME"
>xxx</TT
>, waar
        <TT
CLASS="VARNAME"
>xxx</TT
> een nummer is dat is bepaald uit de eerste
	paar bytes van het uitvoerbare bestand.
        Dus de configuratie van kerneld
	om de binfmt_aout module voor ZMAGIC (a.out) uitvoerbare
	bestanden te laden is:
        </P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  alias binfmt-267 binfmt_aout</PRE
></TD
></TR
></TABLE
><P
>Het magic nummer voor ZMAGIC bestanden is 267 en als je in
        <TT
CLASS="FILENAME"
>/etc/magic</TT
> kijkt, dan zie je het nummer
        0413; houdt in gedachten dat <TT
CLASS="FILENAME"
>/etc/magic</TT
> 
	gebruik maakt van octale getallen terwijl kerneld gebruik maakt
	van decimale getallen en 413 in het octale stelsel gelijk is aan
	267 in het decimale stelsel. Er zijn feitelijk drie iets andere
	varianten op a.out uitvoerbare bestanden
        (NMAGIC, QMAGIC en ZMAGIC), dus voor volledige support van de
        binfmt_aout module hebben we nodig
        </P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  alias binfmt-264 binfmt_aout  # pure executable (NMAGIC)
  alias binfmt-267 binfmt_aout  # demand-paged executable (ZMAGIC)
  alias binfmt-204 binfmt_aout  # demand-paged executable (QMAGIC)</PRE
></TD
></TR
></TABLE
><P
>a.out, Java en iBCS binaire formaten worden automatisch
	zonder enige configuratie door kerneld herkend.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="LDISC"
></A
>Lijndisciplines (slip, cslip en ppp)</H3
><P
>Om lijndisciplines wordt verzocht met
        <TT
CLASS="LITERAL"
>tty-ldisc-</TT
><TT
CLASS="VARNAME"
>x</TT
>, waarbij
        <TT
CLASS="VARNAME"
>x</TT
> gewoonlijk 1 is (voor SLIP) of 3
	(voor PPP). Beiden worden automatisch herkend door kerneld.
        </P
><P
>Nu we het toch over ppp hebben, als je wilt dat kerneld de
	bsd_comp data compressie module voor ppp laadt, dan moet je de
	volgende twee regels aan
        <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
> toevoegen:</P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  alias tty-ldisc-3 bsd_comp
  alias ppp0 bsd_comp</PRE
></TD
></TR
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="NET-PF"
></A
>Netwerk protocol family's (IPX,
      AppleTalk, AX.25)</H3
><P
>Tevens kunnen een aantal netwerkprotocollen worden geladen.
        De kernel vraagt kerneld om een protocol familie (b.v. IPX)
        met een verzoek om
        <TT
CLASS="LITERAL"
>net-pf-</TT
><TT
CLASS="VARNAME"
>X</TT
> waarbij
        <TT
CLASS="VARNAME"
>X</TT
> een nummer is die de gewenste familie
	aangeeft. B.v. <TT
CLASS="LITERAL"
>net-pf-3</TT
> is AX.25,
        <TT
CLASS="LITERAL"
>net-pf-4</TT
> is IPX en
        <TT
CLASS="LITERAL"
>net-pf-5</TT
> is AppleTalk; Deze nummers worden
	vastgesteld door de AF_AX25, AF_IPX enz. definities in het
	linux bronbestand <TT
CLASS="FILENAME"
>include/linux/socket.h</TT
>.
        Dus voor het automatisch laden van de IPX module, heb je
	in <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
> een regel nodig als:
        </P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  alias net-pf-4 ipx</PRE
></TD
></TR
></TABLE
><P
>Zie <A
HREF="#COMMONPROBLEMS"
>Common Problems</A
> voor informatie
        over hoe je een aantal ergerlijke meldingen tijdens het booten
	kunt voorkomen die zijn
        gerelateerd aan ongedefini&euml;erde protocol family's.</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="FS"
></A
>Bestandssystemen</H3
><P
>kerneld verzoeken om bestandssystemen bestaan simpelweg
	uit de naam van het type bestandssysteem. Een veelvoorkomend
	gebruik hiervan is het laden van de module isofs voor CD-ROM
	bestandssystemen, d.w.z. bestandssystemen van het type
        iso9660: </P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  alias iso9660 isofs</PRE
></TD
></TR
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SPECIAL-DEVS"
></A
>Devices waarvoor speciale configuratie nodig is</H2
><P
>Voor een aantal devices is extra configuratie nodig naast de
     normale aliasing van een device naar een module.
     </P
><P
></P
><UL
><LI
><P
>Character devices op major nummer 10: <A
HREF="#MISCDEVS"
>De diverse devices</A
></P
></LI
><LI
><P
><A
HREF="#SCSIDEVS"
>SCSI devices</A
>
        </P
></LI
><LI
><P
><A
HREF="#PRE-POST"
>Devices waarvoor
	speciale initialisatie nodig is </A
></P
></LI
></UL
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MISCDEVS"
></A
>char-major-10 : Muizen, watchdogs en randomness</H3
><P
>Hardware devices worden gewoonlijk ge&iuml;dentificeerd
	via hun major device nummers, b.v. ftape is
        <TT
CLASS="LITERAL"
>char-major-27</TT
>. Als je echter de bestanden
	in <TT
CLASS="FILENAME"
>/dev</TT
> bekijkt met char major 10,
        dan zul je zien dat dit een boel verschillende devices zijn,
        waaronder </P
><P
></P
><UL
><LI
><P
>Diverse soorten muizen (busmuizen, PS/2
          muizen)</P
></LI
><LI
><P
>Watchdog devices </P
></LI
><LI
><P
>De kernel <TT
CLASS="FILENAME"
>random</TT
>
          device </P
></LI
><LI
><P
>APM (Advanced Power Management) interface
          </P
></LI
></UL
><P
>Deze devices worden door verschillende modules bestuurd,
	niet slechts door &eacute;&eacute;n, en daarom wordt voor deze
	<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>misc. devices</I
></SPAN
> in de kerneld configuratie
	gebruik gemaakt van het major nummer <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>en</I
></SPAN
>
	het minor nummer:</P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        alias char-major-10-1 psaux     # Voor PS/2 mouse
        alias char-major-10-130 wdt     # Voor WDT watchdog</PRE
></TD
></TR
></TABLE
><P
>Je hebt kernelversie 1.3.82 of nieuwer nodig om hiervan
	gebruik te kunnen maken; eerdere versies geven het minor nummer
	niet door aan kerneld, waardoor het voor kerneld onmogelijk is
	om uit te zoeken welk misc. device het moet laden.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SCSIDEVS"
></A
>Het laden van SCSI drivers: De
      <TT
CLASS="LITERAL"
>scsi_hostadapter</TT
> entry</H3
><P
>Drivers voor SCSI devices bestaan uit een driver voor de
        SCSI host adapter (b.v. een Adaptec 1542), en een driver voor het
        type SCSI device dat je gebruikt, b.v. een harddisk, een CD-ROM of een
        tape-drive. Deze kunnen allen worden geladen als modules. Als je
	echter bijvoorbeeld de CD-ROM drive wilt benaderen die is 
	gekoppeld aan de Adaptec kaart, dan weten de kernel en kerneld
	alleen dat ze de <TT
CLASS="FILENAME"
>sr_mod</TT
> module moeten
	laden om SCSI CD-ROM's te ondersteunen; niet bekend is op welke
	SCSI-controller de CD-ROM is aangesloten en daarom niet
	welke module moet worden geladen voor ondersteuning van de
	SCSI-controller.
        </P
><P
>Om hier iets aan te doen, kun je een regel toevoegen aan
        <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
>
	voor de SCSI drivermodule waarbij aan kerneld wordt opgegeven
	welke van de vele mogelijke SCSI controllermodules het moet laden:
        </P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        alias scd0 sr_mod               # sr_mod voor SCSI CD-ROM's ...
        alias scsi_hostadapter aha1542  # ... Adaptec driver nodig</PRE
></TD
></TR
></TABLE
><P
>Dit werkt alleen bij kernelversie 1.3.82 of later. </P
><P
>Dit werkt als je slechts &eacute;&eacute;n SCSI-controller
	hebt. Als je er meer dan &eacute;&eacute;n hebt, dan wordt het
	iets moeilijker.
        </P
><P
>Over het algemeen kun je kerneld geen driver laten laden
	voor een SCSI-hostadapter, als er reeds een driver voor een andere
	hostadapter is ge&iuml;nstalleerd. Je moet of beide drivers in je
	kernel inbouwen (niet als modules) of de modules handmatig laden.
        </P
><DIV
CLASS="TIP"
><P
></P
><TABLE
CLASS="TIP"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/IMAGES//tip.gif"
HSPACE="5"
ALT="Tip"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Er <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>is</I
></SPAN
> een manier om
	kerneld meerdere SCSI-drivers te laten laden.
        James Tsiao kwam met het volgende idee:</P
><A
NAME="AEN326"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
> Je kunt kerneld makkelijk de tweede scsi driver laten
	    laden door met de hand de afhankelijkheid in te stellen in 
	    modules.dep. Hiervoor is de volgende regel nodig:
            </P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>      /lib/modules/2.0.30/scsi/st.o: /lib/modules/2.0.30/scsi/aha1542.o</PRE
></TD
></TR
></TABLE
><P
>Om kerneld <TT
CLASS="FILENAME"
>aha1542.o</TT
> te laten laden 
	    voordat het <TT
CLASS="FILENAME"
>st.o</TT
> laadt.  
	    Op mijn machine thuis is het vrijwel exact zo ingesteld als
	    de setup hierboven, en het werkt prima bij al mijn
            tweede scsi devices, waaronder tape, cd-rom, en
            generic scsi devices.  De keerzijde is dat
            <B
CLASS="COMMAND"
>depmod -a</B
> deze afhankelijkheden niet
	    automatisch kan detecteren, dus de gebruiker moet ze met
	    de hand toevoegen en geen
            <B
CLASS="COMMAND"
>depmod -a</B
> tijdens de systeemstart uitvoeren.
	    Maar als het eenmaal is ingesteld, zal kerneld 
            <TT
CLASS="FILENAME"
>aha1542.o</TT
> prima automatisch laden.
            </P
></BLOCKQUOTE
></TD
></TR
></TABLE
></DIV
><P
>Wees je ervan bewust dat deze techniek alleen werkt als je
	verschillende soorten SCSI-devices op de twee controllers hebt,
        zoals bijvoorbeeld harddisks op de ene controller en
	cd-rom drives, tapes of generic SCSI-devices op een ander.
        </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PRE-POST"
></A
>Wanneer het laden van een module niet genoeg is: De
        <TT
CLASS="LITERAL"
>post-install</TT
> entry</H3
><P
>Soms is het slechts laden van de module niet genoeg om
	iets werkend te krijgen. Als je bijvoorbeeld je geluidskaart
	als een module hebt gecompileerd, is het vaak handig om een bepaald
	volumeniveau in te stellen. Het probleem is echter dat de instelling
	de volgende keer dat de module wordt geladen verdwijnt.
        Hier is een aardige truuk van Ben
        Galliart (<TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:bgallia@luc.edu"
>bgallia@luc.edu</A
>&#62;</TT
>): </P
><A
NAME="AEN341"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>De uiteindelijke oplossing vereiste de installatie van het
	  <A
HREF="ftp://sunsite.unc.edu/pub/Linux/apps/sound/mixers/"
TARGET="_top"
>          <SPAN
CLASS="PRODUCTNAME"
>setmix</SPAN
> package</A
> om daarna
	  de volgende regel toe te voegen aan 
          <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
>: </P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>post-install sound /usr/local/bin/setmix -f /etc/volume.conf</PRE
></TD
></TR
></TABLE
></BLOCKQUOTE
><P
>Nadat de sound module is geladen, voert kerneld de
	opdracht uit die wordt aangegeven in de
        <TT
CLASS="LITERAL"
>post-install sound</TT
> entry. Dus de sound
	module wordt geconfigureerd met de opdracht
        <B
CLASS="COMMAND"
>/usr/local/bin/setmix -f
        /etc/volume.conf</B
>.</P
><P
>Dit kan ook voor andere modules handig zijn, 
        de <TT
CLASS="FILENAME"
>lp</TT
> module bijvoorbeeld kan worden
	geconfigureerd met het programma
        <TT
CLASS="FILENAME"
>tunelp</TT
> door de toevoeging:
        </P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>        post-install lp tunelp options</PRE
></TD
></TR
></TABLE
><P
>Je hebt kerneld versie 1.3.69f of later nodig wil kerneld
	deze opties herkennen.
        </P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="100%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="/IMAGES//note.gif"
HSPACE="5"
ALT="Note"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>In een eerdere versie van deze mini-HOWTO werd een pre-remove
	  optie genoemd dat kon worden gebruikt om een opdracht op te
	  starten voordat kerneld een module zou verwijderen. Dit heeft
	  echter nooit gewerkt en het gebruik ervan wordt daarom ontmoedigd.
          Naar alle waarschijnlijkheid zal deze optie in een toekomstige
	  kerneld release verdwijnen. Het gehele onderwerp over
	  module instellingen ondergaat op het moment een aantal wijzigingen 
          en wellicht dat het er anders uitziet op je systeem wanneer je
	  dit leest.
          </P
></TD
></TR
></TABLE
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SPYING"
></A
>Kerneld bespioneren</H2
><P
>Mocht je alles al hebben geprobeerd en kun je er niet
      achter komen wat de kernel vraagt kerneld te doen, dan is er
      een manier om de verzoeken die kerneld ontvangt te bekijken,
      om er zo achter te komen wat in
      <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
> moet komen te staan:
      Het <B
CLASS="COMMAND"
>kdstat</B
> utility. </P
><P
>Dit handige kleine programmaatje wordt geleverd met het
      modules-package, maar is standaard niet gecompileerd of 
      ge&iuml;nstalleerd. Om het samen te stellen ga je naar de
      directory met kerneld bronnen en typ je
      <B
CLASS="COMMAND"
>make kdstat</B
>. Om dan kerneld informatie te laten 
      weergeven wat het aan het doen is, voer je 
      <B
CLASS="COMMAND"
>kdstat debug</B
> uit. Kerneld zal beginnen met het
      spuwen van wat meldingen op de console over wat het aan het doen is.
      Als je dan de opdracht probeert en uitvoert die je wilt gebruiken,
      dan zul je de kerneld verzoeken te zien krijgen; deze kunnen worden
      geplaatst in <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
> en
      aliased naar de module die nodig is om de job te klaren. </P
><P
>Start <B
CLASS="COMMAND"
>/sbin/kdstat</B
> om het debuggen uit te
      zetten.</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="GOODIES"
></A
>Speciale kerneld gebruiken</H2
><P
>Ik wist dat je zou vragen naar het hoe voor het instellen van de
      screen-saver module!</P
><P
>In de <TT
CLASS="FILENAME"
>kerneld/GOODIES</TT
> directory in het
      modules package staan een paar kernelpatches voor screen-saver
      en console-beep ondersteuning in kerneld; deze maken nog geen
      onderdeel uit van de offici&euml;le kernel, dus je zult de
      kernel-patches moeten installeren en de kernel opnieuw moeten
      compileren.
      </P
><P
>Voor het installeren van een patch, gebruik je de opdracht patch:
      </P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>  cd /usr/src/linux
  patch -s -p1 /usr/src/modules-*/kerneld/GOODIES/blanker_patch</PRE
></TD
></TR
></TABLE
><P
>Stel de kernel dan opnieuw samen en installeer deze. </P
><P
>Wanneer de schermbeveiliging wordt geactiveerd, zal kerneld de
      opdracht <TT
CLASS="FILENAME"
>/sbin/screenblanker</TT
> uitvoeren; dit bestand
      kan alles zijn wat je maar wilt, zoals bijvoorbeeld een shellscript
      die je favoriete schermbeveiliging uitvoert.
      </P
><P
>Wanneer de kernel het scherm weer in normale toestand terug
      wil brengen, stuurt het een
      <SPAN
CLASS="TOKEN"
>SIGQUIT</SPAN
> signaal naar het proces dat
      <TT
CLASS="FILENAME"
>/sbin/screenblanker</TT
> draait. Je shellscript
      of schermbeveiliger zou dit af moeten vangen.
      Denk eraan het scherm in de oorspronkelijke tekstmodus terug
      te brengen!</P
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="COMMONPROBLEMS"
></A
>Algemene problemen en dingen die je je wellicht afvraagt</H2
><DIV
CLASS="QANDASET"
><DL
><DT
>1. <A
HREF="#AEN385"
>Waarom krijg ik <SPAN
CLASS="ERRORNAME"
>Cannot locate module for
            net-pf-</SPAN
><TT
CLASS="VARNAME"
>X</TT
> meldingen wanneer ik
            <B
CLASS="COMMAND"
>/sbin/ifconfig</B
> uitvoer?</A
></DT
><DT
>2. <A
HREF="#AEN402"
>Na het starten van kerneld, wordt mijn systeem zo langzaam
	    als een slak wanneer ik mijn ppp-verbinding activeer
            </A
></DT
><DT
>3. <A
HREF="#AEN414"
>kerneld laadt mijn SCSI-driver niet!</A
></DT
><DT
>4. <A
HREF="#AEN422"
>modprobe klaagt over een ongedefinieerde
             <SPAN
CLASS="ERRORNAME"
>gcc2_compiled</SPAN
></A
></DT
><DT
>5. <A
HREF="#AEN428"
>Mijn geluidsdriver blijft zijn instellingen voor het volume
	    enz vergeten
            </A
></DT
><DT
>6. <A
HREF="#AEN436"
>DOSEMU heeft een aantal modules nodig; hoe kan ik
	    kerneld zover krijgen dat het deze laadt?
            </A
></DT
><DT
>7. <A
HREF="#AEN441"
>Waarom krijg ik <SPAN
CLASS="ERRORNAME"
>Ouch, kerneld timed out,
            message failed</SPAN
> meldingen ?</A
></DT
><DT
>8. <A
HREF="#AEN453"
>Mount wacht niet op kerneld totdat het de module
	    voor het bestandssysteem heeft geladen
            </A
></DT
><DT
>9. <A
HREF="#AEN459"
>kerneld kan de <TT
CLASS="LITERAL"
>ncpfs</TT
> module
	    niet laden</A
></DT
><DT
>10. <A
HREF="#AEN468"
>kerneld kan de <TT
CLASS="FILENAME"
>smbfs</TT
>
            module niet laden</A
></DT
><DT
>11. <A
HREF="#AEN476"
>Ik heb alles als modules gecompileerd, en nu boot
	    mijn system niet of kerneld kan de module voor het root
	    bestandssysteem niet laden!
            </A
></DT
><DT
>12. <A
HREF="#AEN492"
>kerneld laadt niet tijdens het booten; het geeft foutmeldingen
	    over libgdbm</A
></DT
><DT
>13. <A
HREF="#AEN502"
>Ik krijg Cannot load module <TT
CLASS="VARNAME"
>xxx</TT
> maar
	    ik heb mijn kernel net opnieuw geconfigureerd zonder
            <TT
CLASS="VARNAME"
>xxx</TT
> ondersteuning!</A
></DT
><DT
>14. <A
HREF="#AEN511"
>Ik heb mijn kernel en modules opnieuw gecompileerd en
	    krijg bij het booten steeds meldingen over unresolved symbols 
            </A
></DT
><DT
>15. <A
HREF="#AEN520"
>Ik installeerde Linux 2.1/2.3 en nu kan
	  ik geen <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>enkele</I
></SPAN
> module meer laden!
          </A
></DT
><DT
>16. <A
HREF="#AEN536"
>Hoe zit het met dial-on-demand netwerkverbinding?</A
></DT
></DL
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN385"
></A
><B
>1. </B
>Waarom krijg ik <SPAN
CLASS="ERRORNAME"
>Cannot locate module for
            net-pf-</SPAN
><TT
CLASS="VARNAME"
>X</TT
> meldingen wanneer ik
            <B
CLASS="COMMAND"
>/sbin/ifconfig</B
> uitvoer?</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>Zo om en nabij kernelversie 1.3.80 werd de netwerkcode
	    gewijzigd dat het 't laden van protocol families 
            als modules mogelijk maakte (b.v. IPX, AX.25 en AppleTalk).
	    Dit zorgde voor de aanvulling van een nieuw kerneld verzoek:
            <TT
CLASS="LITERAL"
>net-pf-</TT
><TT
CLASS="VARNAME"
>X</TT
>, waarbij
            <TT
CLASS="VARNAME"
>X</TT
> een nummer is die het protocol aanduidt
            (zie <TT
CLASS="FILENAME"
>/usr/src/linux/include/linux/socket.h</TT
>
            voor de betekenis van de diverse nummers). Helaas vangt
            <B
CLASS="COMMAND"
>ifconfig</B
> deze meldingen per ongeluk af,
	    zodat bij een heleboel mensen een paar meldingen worden gelogd
	    wanneer het systeem boot en het draait
            <B
CLASS="COMMAND"
>ifconfig</B
> om het loopback device in te stellen.
            De meldingen zijn onschuldig, en je kunt ze deactiveren door
	    het toevoegen van de regels:</P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>        alias net-pf-3 off      # Vergeet AX.25
        alias net-pf-4 off      # Vergeet IPX
        alias net-pf-5 off      # Vergeet AppleTalk</PRE
></TD
></TR
></TABLE
><P
>aan <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
>. Je voegt
	    natuurlijk geen regel toe om IPX te deactiveren als je IPX
	    wel als een module gebruikt.
            </P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN402"
></A
><B
>2. </B
>Na het starten van kerneld, wordt mijn systeem zo langzaam
	    als een slak wanneer ik mijn ppp-verbinding activeer
            </P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>Er zijn hier diverse meldingen van. Het lijkt op een
	    ongelukkige interactie tussen kerneld en het
            <SPAN
CLASS="PRODUCTNAME"
>tkPPP</SPAN
> script dat op een aantal
	    systemen wordt gebruikt om de PPP verbinding op te zetten
	    en te monitoren. Het script voert blijkbaar loops uit 
	    terwijl het <B
CLASS="COMMAND"
>ifconfig</B
> draait.
            Dit activeert kerneld, te zoeken naar de
            <TT
CLASS="LITERAL"
>net-pf-</TT
><TT
CLASS="VARNAME"
>X</TT
> modules
            (zie hiervoor), de systeembelasting hoog houdend en mogelijk
            veel Cannot locat module for
            <TT
CLASS="LITERAL"
>net-pf-</TT
><TT
CLASS="VARNAME"
>X</TT
> meldingen
	    in de systeemlog veroorzakend. Er is geen bekende oplossing voor,
	    anders dan geen gebruik te maken van
            <SPAN
CLASS="PRODUCTNAME"
>tkPPP</SPAN
>, of het zodanig te wijzigen
	    dat het een andere manier om de verbinding te monitoren gebruikt.
            </P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN414"
></A
><B
>3. </B
>kerneld laadt mijn SCSI-driver niet!</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>Voeg een regel toe voor de SCSI-hostadapter aan het bestand
            <TT
CLASS="FILENAME"
>/etc/conf.modules</TT
>. Zie de beschrijving van
	    de <A
HREF="#SCSIDEVS"
><TT
CLASS="LITERAL"
>scsi_hostadapter</TT
>
	    </A
> hiervoor.</P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN422"
></A
><B
>4. </B
>modprobe klaagt over een ongedefinieerde
             <SPAN
CLASS="ERRORNAME"
>gcc2_compiled</SPAN
></P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>Dit is een bug in de module utility's, die alleen
	    in binutils 2.6.0.9 en later aan het licht komt en het is
	    ook gedocumenteerd in de release note van de binutils.
            Dus lees dat of haal een upgrade op voor de module-utilities 
	    die deze bug corrigeert.
            </P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN428"
></A
><B
>5. </B
>Mijn geluidsdriver blijft zijn instellingen voor het volume
	    enz vergeten
            </P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>De instellingen voor een module worden opgeslagen 
	    in de module zelf wanneer het wordt geladen. Dus wanneer kerneld
	    automatisch een module uit het geheugen verwijdert, zijn alle
	    instellingen die je hebt ingesteld vergeten en de volgende
	    keer dat de module weer wordt geladen keert het terug naar de
	    standaardinstellingen.
            </P
><P
>Je kunt kerneld aangeven een module te configureren door
	    een programma uit te voeren nadat de module automatisch is
	    geladen. Zie <A
HREF="#PRE-POST"
>Pre/Post Install</A
> on the
            <TT
CLASS="LITERAL"
>post-install</TT
> entry. </P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN436"
></A
><B
>6. </B
>DOSEMU heeft een aantal modules nodig; hoe kan ik
	    kerneld zover krijgen dat het deze laadt?
            </P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>Dat kan niet. Geen van de dosemu versies, offici&euml;le
	    of ontwikkelaarsversies ondersteunt het laden van de dosemu
	    modules via kerneld. Met kernel 2.0.26 echter, heb je de 
	    speciale dosemumodules niet meer nodig; upgrade gewoon naar
	    dosemu 0.66.1 of een nieuwere versie.
            </P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN441"
></A
><B
>7. </B
>Waarom krijg ik <SPAN
CLASS="ERRORNAME"
>Ouch, kerneld timed out,
            message failed</SPAN
> meldingen ?</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>Wanneer de kernel een verzoek aan kerneld verstuurt,
	    verwacht het hiervan binnen een seconde een bevestiging 
	    terug te ontvangen. Als kerneld deze bevestiging niet
	    zendt, wordt deze melding gelogt. Het verzoek wordt opnieuw
	    gestuurd en zou tenslotte door moeten komen. </P
><P
>Dit gebeurt gewoonlijk op systemen met een zeer hoge
	    belasting. Aangezien kerneld een gebruikersproces is, 
            wordt het net als elk ander proces op het systeem gepland.
            Ten tijden van hoge belasting, wordt het wellicht niet op
	    tijd uitgevoerd om de bevestiging terug te sturen voordat
	    de kernel onderbreekt.
            </P
><P
>Probeer het opnieuw opstarten van kerneld als 
	    dit bij een lage belasting gebeurt. Kill het kerneld proces,
	    en start het weer op met de opdracht
            <B
CLASS="COMMAND"
>/usr/sbin/kerneld</B
>. Als het probleem blijft
	    aanhouden dan zou je een bug report moeten mailen naar
            <TT
CLASS="EMAIL"
>&#60;<A
HREF="mailto:linux-kernel@vger.rutgers.edu"
>linux-kernel@vger.rutgers.edu</A
>&#62;</TT
>, maar
            verzeker je er <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>alsjeblieft</I
></SPAN
> van dat
	    de door je in gebruik zijnde versies van de kernel, kerneld 
	    en module utility's up-to-date zijn voor je het als probleem
	    post. Controleer de benodigdheden in
            <TT
CLASS="FILENAME"
>linux/Documentation/Changes</TT
></P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN453"
></A
><B
>8. </B
>Mount wacht niet op kerneld totdat het de module
	    voor het bestandssysteem heeft geladen
            </P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>Er zijn een aantal meldingen waardoor de opdracht mount(8)
	    niet wacht op kerneld totdat het de module voor het
	    bestandssysteem heeft geladen.
            <B
CLASS="COMMAND"
>lsmod</B
> toont wel dat kerneld
	    de module laadt, en als je de opdracht mount onmiddellijk
	    herhaalt, lukt het wel. Dit schijnt een bug te zijn in de
            module-utilities versie 1.3.69f waardoor een aantal
	    Debian gebruikers wordt getroffen.
            Het kan worden gecorrigeerd door een latere
	    versie van de module utility's op te halen.
            </P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN459"
></A
><B
>9. </B
>kerneld kan de <TT
CLASS="LITERAL"
>ncpfs</TT
> module
	    niet laden</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>Je moet de ncpfs utility's compileren met
            <SPAN
CLASS="TOKEN"
>-DHAVE_KERNELD</SPAN
>. Zie de
            <SPAN
CLASS="PRODUCTNAME"
>ncpfs</SPAN
>
            <TT
CLASS="FILENAME"
>Makefile</TT
>. </P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN468"
></A
><B
>10. </B
>kerneld kan de <TT
CLASS="FILENAME"
>smbfs</TT
>
            module niet laden</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>Je hebt een oudere versie van de
            <SPAN
CLASS="PRODUCTNAME"
>smbmount</SPAN
> utility's in gebruik. Haal de
	    laatste versie op (0.10 of later) vanaf
            <A
HREF="ftp://tsx-11.mit.edu/pub/linux/filesystems/smbfs/"
TARGET="_top"
>het
            SMBFS archief op TSX-11</A
></P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN476"
></A
><B
>11. </B
>Ik heb alles als modules gecompileerd, en nu boot
	    mijn system niet of kerneld kan de module voor het root
	    bestandssysteem niet laden!
            </P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>Je kunt niet 
            <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>alles</I
></SPAN
> modularizeren: In de kernel moeten
	    zich voldoende drivers bevinden om je root bestandssysteem
	    te kunnen mounten, en de nodige programma's om
            kerneld te starten.<A
NAME="AEN481"
HREF="#FTN.AEN481"
><SPAN
CLASS="footnote"
>[2]</SPAN
></A
>. Wat je niet kunt modularizeren: </P
><P
></P
><UL
><LI
><P
>de driver voor de harddisk waar je root
	      bestandssysteem op voorkomt
            </P
></LI
><LI
><P
>de driver voor het root bestandssysteem zelf
              </P
></LI
><LI
><P
>de binary format loader voor init,
              kerneld en andere programma's </P
></LI
></UL
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN492"
></A
><B
>12. </B
>kerneld laadt niet tijdens het booten; het geeft foutmeldingen
	    over libgdbm</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>Nieuwere versies van kerneld hebben de GNU dmb library,
            <TT
CLASS="FILENAME"
>libgdbm.so</TT
> nodig om te kunnen draaien. De
	    meeste installaties hebben dit bestand in
            <TT
CLASS="FILENAME"
>/usr/lib</TT
>, maar waarschijnlijk start je
            kerneld voordat het <TT
CLASS="FILENAME"
>/usr</TT
> bestandssysteem
            is gemount. Een symptoom hiervan is dat kerneld tijdens het
	    starten van het systeem niet (vanuit je rc-scripts) zal starten,
	    maar prima draait als je het met de hand start nadat het systeem
	    is geboot. De oplossing is de kerneld opstart te verplaatsen
	    nadat <TT
CLASS="FILENAME"
>/usr</TT
> is gemount of door de gdbm
	    library naar je root bestandssysteem te verplaatsen, b.v. naar
            <TT
CLASS="FILENAME"
>/lib</TT
>.</P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN502"
></A
><B
>13. </B
>Ik krijg Cannot load module <TT
CLASS="VARNAME"
>xxx</TT
> maar
	    ik heb mijn kernel net opnieuw geconfigureerd zonder
            <TT
CLASS="VARNAME"
>xxx</TT
> ondersteuning!</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>De Slackware installatie (mogelijk anderen) bouwt een
             standaard <TT
CLASS="FILENAME"
>/etc/rc.d/rc.modules</TT
> die
	    een expliciete modprobe uitvoert op een vari&euml;teit aan
	    modules. Exact welke modules worden geladen met modprobe
            is afhankelijk van de oorspronkelijke
	    configuratie van de kernel. Je hebt je kernel waarschijnlijk
	    opnieuw geconfigureerd om er &eacute;&eacute;n of meer
	    modules uit te laten die in rc.modules met modprobe
	    worden getracht te laden, vandaar de foutmelding(en).
            Werk het rc.modules bestand bij door voor modules die je
	    niet langer gebruikt een commentaarteken te plaatsen of
	    verwijder <TT
CLASS="FILENAME"
>rc.modules</TT
> in zijn geheel en laat
	    kerneld de modules laden wanneer ze nodig zijn.
            </P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN511"
></A
><B
>14. </B
>Ik heb mijn kernel en modules opnieuw gecompileerd en
	    krijg bij het booten steeds meldingen over unresolved symbols 
            </P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>Je hebt waarschijnlijk je kernel opnieuw
	    geconfigureerd en gecompileerd en daar wat modules uitgelaten.
            Je hebt een aantal modules die je niet langer gebruikt
            in de <TT
CLASS="FILENAME"
>/lib/modules</TT
> directory. De
	    eenvoudigste manier om dit te corrigeren is het verwijderen
	    van de <TT
CLASS="FILENAME"
>/lib/modules/</TT
><TT
CLASS="VARNAME"
>x.y.z</TT
>
            directory en de opdracht <B
CLASS="COMMAND"
>make modules_install</B
>
	    vanuit de kernel broncode directory nogmaals op te starten.
            Dit probleem komt alleen voor wanneer je de kernel opnieuw
	    configureert zonder van versie te wijzigen. Wanneer je deze
	    foutmelding te zien krijgt wanneer je een nieuwe kernelversie
	    hebt ge&iuml;nstalleerd, dan gaat het om een ander probleem.
            </P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN520"
></A
><B
>15. </B
>Ik installeerde Linux 2.1/2.3 en nu kan
	  ik geen <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>enkele</I
></SPAN
> module meer laden!
          </P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>Oneven genummerde Linux versies zijn ontwikkelaarskernels.
	    Als zodanig kan ervan worden verwacht dat er van tijd tot tijd
	    iets breekt. Een van de dingen die veelbetekenend is
	    gewijzigd is de wijze waarop modules worden afgehandeld,
	    en waar de kernel en modules in het geheugen worden geladen.
            </P
><P
>Samengevat: als je modules wilt gebruiken in combinatie
	    met een ontwikkelaarskernel, dan moet je
            </P
><P
></P
><UL
><LI
><P
>het bestand
              <TT
CLASS="FILENAME"
>Documentation/Changes</TT
> lezen en hierin
	      opzoeken welke packages moeten worden bijgewerkt op je systeem
              </P
></LI
><LI
><P
>het laatste modutils package gebruiken,
	      beschikbaar vanaf <A
HREF="ftp://ftp.redhat.com/pub/alphabits/"
TARGET="_top"
>AlphaBits op
              Red Hat</A
> of de mirror site op <A
HREF="ftp://tsx-11.mit.edu/pub/linux/packages/alphabits/"
TARGET="_top"
>TSX-11</A
></P
></LI
></UL
><P
>Ik raad op z'n minst het gebruik van kernel 2.1.29 aan,
	    als je modules wilt gebruiken met een 2.1. kernel.</P
></DIV
></DIV
><DIV
CLASS="QANDAENTRY"
><DIV
CLASS="QUESTION"
><P
><A
NAME="AEN536"
></A
><B
>16. </B
>Hoe zit het met dial-on-demand netwerkverbinding?</P
></DIV
><DIV
CLASS="ANSWER"
><P
><B
> </B
>kerneld bood oorspronkelijk enige ondersteuning voor
	    het tot stand brengen van dialup netwerkverbindingen op
	    verzoek; pakketjes naar een netwerk proberen te versturen
	    zonder dat er een verbinding was zorgde ervoor dat
	    kerneld het <TT
CLASS="FILENAME"
>/sbin/request_route</TT
> script 
	    opstartte om een PPP of SLIP-verbinding op te zetten.</P
><P
>Achteraf leek dit niet zo'n goed idee. Alan Cox
	    van Linux networking fame schreef naar de linux-kernel
	    mailinglist</P
><A
NAME="AEN542"
></A
><BLOCKQUOTE
CLASS="BLOCKQUOTE"
><P
>De request-route materie is verouderd, gebrekkig en
              onnodig [...]  Het is bovendien verwijderd uit
	      de 2.1.x structuren.
              </P
></BLOCKQUOTE
><P
>In plaats van het gebruik van het request-route script
	    in combinatie met kerneld, kan ik je van harte het <A
HREF="http://www.dna.lth.se/~erics/diald.html"
TARGET="_top"
>diald
            package</A
> van Eric Schenk aanbevelen om je demand dialing
	    beheren.</P
></DIV
></DIV
></DIV
></DIV
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN198"
HREF="#AEN198"
><SPAN
CLASS="footnote"
>[1]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>Een aantal distributies noemen dit bestand
      <TT
CLASS="FILENAME"
>modules.conf</TT
></P
></TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN481"
HREF="#AEN481"
><SPAN
CLASS="footnote"
>[2]</SPAN
></A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>In werkelijkheid is dit niet waar. Late
            1.3.x en alle 2.x kernels ondersteunen het gebruik van een
	    initi&euml;le ramdisk die door LILO of LOADLIN wordt geladen;
	    het is mogelijk in een zeer vroeg stadium van het bootproces
	    modules vanaf deze disk te laden. Hoe je dit doet is beschreven
	    in het bestand <TT
CLASS="FILENAME"
>linux/Documentation/initrd.txt</TT
>
	    dat wordt meegeleverd met de kernel bronbestanden. </P
></TD
></TR
></TABLE
></BODY
></HTML
>