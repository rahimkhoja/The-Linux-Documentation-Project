<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>De Linux Kernel HOWTO</TITLE>


</HEAD>
<BODY>
<H1>De Linux Kernel HOWTO</H1>

<H2>Brian Ward, <CODE>bri@cs.uchicago.edu</CODE>,<BR>
Vertaald door: Ellen Bokhorst, <CODE>bokkie@nl.linux.org</CODE></H2>v2.6, 18 mei 2001
<P><HR>
<EM>Dit is een gedetailleerde gids voor het configureren, compileren en upgraden van de kernel, en het oplossen van problemen voor op ix86 gebaseerde systemen.</EM>
<HR>
<H2><A NAME="s1">1. Introductie</A></H2>

<P>Zou je dit document moeten lezen? Wel als je &eacute;&eacute;n van de volgende
symptomen herkent:
<P>
<UL>
<LI> ``Ai! Dit wizzo-46.5.6 package zegt dat het kernel
release 2.8.193 nodig heeft en ik heb nog steeds slechts release 1.0.9!''</LI>
<LI> Er is een devicedriver in &eacute;&eacute;n van de nieuwere kernels
die je gewoon moet hebben</LI>
<LI> Je hebt werkelijk geen idee hoe je een kernel compileert</LI>
<LI> ``Is datgene wat er in de README staat, <I>echt</I> het hele verhaal?''</LI>
<LI> Je kwam, je probeerde het, het werkte niet</LI>
<LI> Je hebt iets nodig om aan mensen te geven die erop blijven hameren
dat je hun kernels voor ze installeert</LI>
</UL>
<H2>1.1  Lees dit eerst! (Ik meen het)</H2>

<P>Bij een aantal van de voorbeelden in dit document wordt ervan uitgegaan dat je
GNU <CODE>tar</CODE>, <CODE>find</CODE>, en <CODE>xargs</CODE> hebt. 
Dit zijn standaards; dit zou geen problemen mogen veroorzaken.
Er wordt ook vanuit gegaan dat je bekend bent met de structuur van het
bestandssysteem op je systeem;
als dit niet zo is, is het van groot belang dat je een geschreven kopie
van de uitvoer van het commando
<CODE>mount</CODE> tijdens de normale systeembewerking bij de hand houdt
(of een listing van <CODE>/etc/fstab</CODE>, als je het kunt lezen).
Deze informatie is belangrijk, en wijzigt niet, tenzij je je disk opnieuw
partitioneert, een nieuwe disk toevoegt, je systeem opnieuw installeert of
iets dergelijks.
<P>De laatste ``productie'' kernelversie op moment van dit schrijven was
2.2.9, wat betekent dat de verwijzingen en voorbeelden corresponderen met
die release.
Zelfs al probeer ik dit document zo versie-onafhankelijk mogelijk te maken,
de kernel is voortdurend onder ontwikkeling, dus als je een nieuwere release
krijgt, zullen er onontkoombaar wat verschillen zijn.
Nogmaals, dit zou geen belangrijke problemen moeten geven, maar het kan
wat verwarring geven.
<P>Er zijn twee versies van de linux kernel source, ``productie'' en
``development.'' Productie releases zijn de even-minor-genummerde releases;
1.2.x was productie, 2.0.x is productie, als ook 2.2.x. Deze kernels
worden aangemerkt als de meest stabiele kernels, foutvrije versies die
ten tijde van de release beschikbaar zijn.
De development kernels (2.1.x, 2.3.x, enz) zijn bedoeld als kernels om te
testen, voor mensen die bereid zijn om ze uit te testen en het kunnen
kernels zijn die veel fouten bevatten. Je bent gewaarschuwd.
<H2>1.2 Een woord over stijl</H2>

<P><CODE>Tekst die er zo uitziet</CODE> is iets dat op het scherm verschijnt,
een bestandsnaam, of iets dat direct kan worden ingetikt, zoals een 
commando, of opties voor een commando (als je een plain-tekstbestand bekijkt,
ziet het er niet veel anders uit).
Commando's en andere invoer worden vaak tussen aanhalingstekens geplaatst
(met ` '), wat het volgende klassieke leesteken-probleem veroorzaakt:
als een dergelijk item aan het einde van een zin tussen aanhalingstekens
verschijnt, typen mensen vaak een `.' met het commando, omdat de Amerikaanse
aanhalingsstijl aangeeft dat de punt binnen de aanhalingstekens hoort. 
Zelfs met gezond verstand (en helaas wordt hier verondersteld dat degene
met ``gezond verstand'' gewend is aan de zogenoemde Amerikaanse stijl
van aanhalen), zou iemand moeten zeggen het eerst van het leesteken te ontdoen,
toch denken veel mensen daar gewoon niet aan, dus ik zal het
in dergelijke gevallen buiten de aanhalingstekens plaatsen.
Met andere woorden, als er wordt aangegeven dat je 
``<CODE>make config</CODE>'' zou moeten typen,
zal ik `<CODE>make config</CODE>' schrijven en niet `<CODE>make config</CODE>.'
<H2><A NAME="s2">2. Snelle stappen - Kernelcompilatie</A></H2>

<P>Deze sectie is geschreven door
<A HREF="mailto:alavoor@yahoo.com">Al Dev (alavoor@yahoo.com)</A><P>De laatste versie van deze sectie is te vinden op 
<A HREF="http://www.aldev.8m.com">http://www.aldev.8m.com</A> en klik op
"Quick Steps to recompile linux kernel". Mirror sites zijn te vinden op -
<A HREF="http://aldev.webjump.com">http://aldev.webjump.com</A>,
<A HREF="http://www.angelfire.com/country/aldev0">angelfire</A>,
<A HREF="http://www.geocities.com/alavoor/index.html">geocities</A>,
<A HREF="http://aldev0.virtualave.net">virtualave</A>,
<A HREF="http://aldev0.50megs.com">50megs</A>,
<A HREF="http://members.theglobe.com/aldev1/index.html">theglobe</A>,
<A HREF="http://members.nbci.com/alavoor">NBCi</A>,
<A HREF="http://aldev.terrashare.com">Terrashare</A>,
<A HREF="http://members.fortunecity.com/aldev">Fortunecity</A>,
<A HREF="http://aldev.freewebsites.com">Freewebsites</A>,
<A HREF="http://members.tripod.lycos.com/aldev">Tripod</A>,
<A HREF="http://members.spree.com/technology/aldev">Spree</A>,
<A HREF="http://www.escalix.com/freepage/aldev">Escalix</A>,
<A HREF="http://www.httpcity.com/aldev/index.html">Httpcity</A>,
<A HREF="http://aldev.freeservers.com">Freeservers</A>.
<P>Deze sites bieden <B>heel veel linux fraais</B> en tips.
<P>Een kopie van de bovenstaande website is hier gereproduceerd -
<P>Het opnieuw compileren van de kernel is nodig om de kernel zo klein mogelijk
te maken, wat zal resulteren in een SNELLER besturingssysteem. Het moet
ook gebeuren als je ondersteuning wilt voor enige nieuwe devices.
<B>Noot: </B> Hieronder duidt 'bash#' op de bash-prompt, je typt de
opdrachten die na de 'bash#' prompt staan. De hieronderstaande
opdrachten zijn onder RedHat Linux getest, maar ze zouden tevens met
minimale wijzigingen onder andere distributies moeten werken.
<P>
<OL>
<LI> Noot: 
Er kunnen meerdere kernelimages op je systeem voorkomen. Door de hieronder
staande stappen op te volgen, overschrijf je of beschadig je geen 
bestaande kernel. Deze stappen zijn <B>zeer veilig</B> en je huidige
kernel blijft intact en zal niet worden aangeroerd.</LI>
<LI> Log bij al deze stappen in als 'root'.
Mount de Redhat linux cdrom en installeer de linux kernelsource rpm
<HR>
<PRE>
bash$ su - root
bash# cd /mnt/cdrom/RedHat/RPMS 
bash# rpm -i    kernel-headers*.rpm 
bash# rpm -i    kernel-source*.rpm 
bash# rpm -i dev86*.rpm   
bash# rpm -i bin86*.rpm   
</PRE>
<HR>

(De bin86*.rpm en 'as86' is alleen nodig voor <B>OUDERE Linux</B> systemen
zoals redhat 5.x. Neem de Intel assembler 'as86' opdracht uit
dev86*.rpm op de cdrom of vanaf
<A HREF="http://rpmfind.net/linux/RPM/mandrake/7.1/Mandrake/RPMS/bin86-0.4-12mdk.i586.html">http://rpmfind.net/linux/RPM/mandrake/7.1/Mandrake/RPMS/bin86-0.4-12mdk.i586.html</A>
, 
<A HREF="http://rpmfind.net/linux/RPM/kondara/jirai/i586/bin86-0.4-8k.i586.html">http://rpmfind.net/linux/RPM/kondara/jirai/i586/bin86-0.4-8k.i586.html</A>
).</LI>
<LI> Start X-window op met 'startx'. 
<HR>
<PRE>
bash# man startx
bash# startx
bash# cd /usr/src/linux 
bash# make xconfig 
</PRE>
<HR>

De <B>"make xconfig"</B> komt met een gebruikersvriendelijke GUI interface!
Maak <B>GEEN</B> gebruik van 'make config' want dit is een opdrachtregel
optie (gebruik dit <B>ALLEEN</B> als je X-window niet kunt uitvoeren).
Een beter alternatief op de opdracht 'make config' is 
<B>'make menuconfig'</B> waarmee je een gebruikersvriendelijke
op tekst gebaseerde ncurses interface krijgt. Een aantal mensen geven de
voorkeur aan 'make menuconfig' boven 'make xconfig'. Mijn persoonlijke
voorkeur - wanneer ik X-window niet uit kan voeren, gebruik ik 'make
menuconfig'.
Je kunt het configuratiebestand laden van
<I>/usr/src/linux/.config</I> (punt config file. Let op de punt voor
config).</LI>
<LI> Binnen 'make xconfig' moet je het volgende doen om problemen
te voorkomen -
<UL>
<LI> Selecteer het juiste CPU type - Pentium 3, AMD K6, Cyrix, Pentium 4, 
Intel 386, DEC Alpha, PowerPC anders zal de kernel niet booten!!</LI>
<LI> Kies voor SMP - of een enkele CPU of meerdere CPU's</LI>
<LI> Filesystems - Selecteer Windows95 Vfat, MSDOS, NTFS als onderdeel
van de kernel en niet als laadbare modules.</LI>
<LI> Activeer de ondersteuning voor laadbare kernelmodules!
Met deze optie kun je device drivers op een draaiend linux systeem 
dynamisch laden en uit het geheugen verwijderen.
Zie de volgende manpages
<HR>
<PRE>
bash# man lsmod
bash# man insmod
bash# man rmmod
bash# man depmod
bash# man modprobe
</PRE>
<HR>
</LI>
</UL>
</LI>
<LI>Save en Exit "make xconfig". 
Alle opties die je hebt geselecteerd zullen nu worden opgeslagen in het
configuratiebestand
<I>/usr/src/linux/.config</I> (punt config file).
En voer nu uit:
<HR>
<PRE>
bash# make dep
bash# make clean
</PRE>
<HR>
</LI>
<LI> 
Lees het volgende bestand 
(om kennis op te doen over het bouwen van een kernel. Tip: gebruik de
kleureneditor
<A HREF="http://metalab.unc.edu/LDP/HOWTO/Vim-HOWTO.html">gvim</A>
voor een betere leesbaarheid.
<HR>
<PRE>
bash# gvim -R   /usr/src/linux/arch/i386/config.in 
bash# man less 
bash# less   /usr/src/linux/arch/i386/config.in 
Typ 'h' voor hulp en druk voor het navigeren op i, j, k, l, h of 
de pijltjestoets, page up/down toetsen.
</PRE>
<HR>
</LI>
<LI> Geef nu de opdracht make:
<HR>
<PRE>
        bash# cd /usr/src/linux
        bash# man nohup
        bash# nohup make bzImage &amp;  
        bash# tail -f nohup.out     (.... to monitor the progress) 
Hiermee zal de kernel worden neergezet in 
/usr/src/linux/arch/i386/boot/bzImage 
        bash# man tail 
</PRE>
<HR>
</LI>
<LI> Na een succesvolle bzImage, kopieer je de kernelimage naar de
/boot directory. Je moet de nieuwe kernelimage naar de /boot directory
kopi&euml;ren, anders zal de nieuwe kernel <B>NIET</B> booten.
En lees dan de manual page over lilo
(zie ook 
<A HREF="http://www.linuxdoc.org/HOWTO/LILO-crash-rescue-HOWTO.html">http://www.linuxdoc.org/HOWTO/LILO-crash-rescue-HOWTO.html</A>)
en zie het voorbeeldbestand 
<A HREF="#liloconf">lilo.conf</A>.
Geef altijd een datumextensie aan de bestandsnaam, omdat het je vertelt
wanneer je de kernel bouwde. Dit wordt hieronder aangegeven:
<HR>
<PRE>
bash# cp /usr/src/linux/arch/i386/boot/bzImage     /boot/bzImage.myker.26mar2001
bash# man lilo
bash# man lilo.conf
Wijzig het bestand /etc/lilo.conf en plaats daar de volgende regels in:
        image=/boot/bzImage.myker.26mar2001 
        label=myker
        root=/dev/hda1 
        read-only 
Je kunt de devicenaam voro 'root=' controleren met de opdracht:
        bash# df   / 
 
</PRE>
<HR>
</LI>
<LI> Start nu
<HR>
<PRE>
 bash# lilo 
 bash# lilo -q 
 
</PRE>
<HR>

Je moet lilo iedere keer dat je een nieuwe bzImage aanmaakt, opnieuw opstarten,
zelfs als zou het record 'myker' reeds
bestaan. </LI>
<LI> Start de machine opnieuw op en achter lilo druk je de tab toets in
en typt 'myker'. Als het boot dan heb je goed werk verricht! 
Selecteer anders achter de lilo je oude kernel, boot en begin helemaal
opnieuw. Je oude kernel
<B>is nog steeds INTACT en VEILIG gesteld</B> 
in stel <I>/boot/vmlinuz-2.0.34-0.6</I></LI>
<LI> Laadbare modules:
Zoek naar de insmod opdracht die zeer frequent wordt gebruikt voor het
laden van de modules.
<HR>
<PRE>
 bash# man insmod
 bash# insmod 
 bash# rpm -i /mnt/cdrom/Redhat/RPMS/modutils*.rpm
 
</PRE>
<HR>

 
De stap hieronder is wellicht niet nodig, maar slechts nodig voor
<B>NOODGEVALLEN</B> wanneer je /lib/modules bestanden zijn beschadigd.
Wanneer je reeds een /lib/modules directory hebt en in het geval je de
bestanden wilt vervangen, gebruik dan de --force om het package te
vervangen en selecteer de van toepassing zijnde cpu architectuur.
 
Voor nieuwe versies van linux redhat linux 6.0 en latere versies zijn de
kernelmodules opgenomen in kernel-2.2*.rpm. Installeer de laadbare modules
en de kernel met
<HR>
<PRE>
Hiermee krijg je een reeds ge&iuml;nstalleerd package te zien.
 bash# rpm -qa | grep -i kernel
        
 bash# rpm -U --force  /mnt/cdrom/Redhat/RPMS/kernel-2.2.14-5.0.i686.rpm
 (or)
 bash# rpm -U --force  /mnt/cdrom/Redhat/RPMS/kernel-2.2.14-5.0.i586.rpm
 (or)
 bash# rpm -U --force  /mnt/cdrom/Redhat/RPMS/kernel-2.2.14-5.0.i386.rpm
 
</PRE>
<HR>

 
Dit geldt alleen voor oude versies van redhat linux 5.2 en eerdere versies.
Boot de nieuwe kernel en installeer de laadbare modules vanaf de
RedHat Linux "contrib" cdrom 
<HR>
<PRE>
bash# rpm -i /mnt/cdrom/contrib/kernel-modules*.rpm 
....(Voor oude linux systemen waarop insmod niet is voorge&iuml;nstalleerd)
 
</PRE>
<HR>
</LI>
<LI>Deze stap is <B>ALLEEN</B> nodig als je een nieuwe versie van
de kernelsource hebt gedownload.
Laadbare modules zijn te vinden in /lib/modules. 
<HR>
<PRE>
bash# cd /usr/src/linux
bash# make modules
bash# make modules_install
</PRE>
<HR>
</LI>
<LI>Als je nieuwe kernel 'myker' boot en correct functioneert, dan kun
je de bootdisk aanmaken. Doe een lege diskette in het diskettestation en:
<HR>
<PRE>
bash# cd /usr/src/linux
bash# make bzdisk
Zie tevens mkbootdisk -
bash# rpm -i mkbootdisk*.rpm
bash# man mkbootdisk
</PRE>
<HR>
</LI>
</OL>
<H2>2.1 Oplossen van veelvoorkomende fouten</H2>

<P>De volgende fouten worden zeer frequent door nieuwe gebruikers gemaakt:
<P>Als je nieuwe kernel niet boot en je krijgt:
<HR>
<PRE>
 Warning: unable to open an initial console
 Kernel panic: no init found. Try passing init= option to kernel
</PRE>
<HR>

Het probleem is hier dat je de "root=" parameter <B>NIET</B> juist opgaf
in /etc/lilo.conf. In mijn geval maakte ik gebruik van root=/dev/hda1
met daarop de root partitie "/". Je moet naar het juiste rootdevice verwijzen
in lilo.conf. Dit kan bv iets als /dev/hdb2 of /dev/hda7 zijn.
<P>De kernel zoekt naar de init opdracht welke is te vinden in /sbin/init.
En de directory /sbin komt voor op de rootpartitie.
Zie voor details:
<HR>
<PRE>
 bash# man init
 
</PRE>
<HR>
<H2><A NAME="liloconf"></A> 2.2 Voorbeeld lilo.conf </H2>

<P>Hieronder wordt een voorbeeldbestand van /etc/lilo.conf gegeven. 
Volg de naamconventies zoals ker2217 (voor kernel 2.2.17), ker2214 
(voor kernel 2.2.14).
Er kunnen meerdere kernelimages op hetzelfde /boot systeem voorkomen.
Op mijn machine heb ik iets als:
<HR>
<PRE>
 boot=/dev/hda
 map=/boot/map
 install=/boot/boot.b
 prompt
 timeout=50
 default=firewall
 
 image=/boot/vmlinuz-2.2.14-5.0
        label=ker2214
        read-only
        root=/dev/hda9
 
 image=/boot/vmlinuz-2.2.17-14
        label=ker2217
        read-only
        root=/dev/hda9
 
 #image=/usr/src/linux/arch/i386/boot/bzImage 
 #      label=myker 
 #      root=/dev/hda7
 #      read-only 
 
 image=/boot/bzImage.myker.11feb2001
        label=myker11feb 
        root=/dev/hda9
        read-only 
 
 image=/boot/bzImage.myker.01jan2001
        label=myker01jan 
        root=/dev/hda9
        read-only 
 
 image=/boot/bzImage.myker-firewall.16mar2001
        label=firewall 
        root=/dev/hda9
        read-only 
 
</PRE>
<HR>
<H2><A NAME="s3">3. Belangrijke vragen en de antwoorden daarop</A></H2>

<H2>3.1 Wat doet de kernel, eigenlijk?</H2>

<P>De Unix kernel gedraagt zich als een bemiddelaar voor je programma's en
je hardware. Als eerste doet het (of regelt het) voor alle draaiende 
programma's het geheugenbeheer (processen), en zorgt het ervoor dat ze allen een
eerlijk (of oneerlijk, als je dat wenst) deel van de processor cycli
krijgen. Bovendien voorziet het in een tamelijk fraaie overdraagbare 
interface voor programma's om met je hardware te communiceren.
<P>De werking van de kernel beslaat beslist meer dan dat, maar dit zijn
de belangrijkste basisfuncties.
<H2>3.2 Waarom zou ik mijn kernel willen upgraden?</H2>

<P>Nieuwere kernels bieden over het algemeen de mogelijkheid om te kunnen
communiceren met meer soorten hardware
(dat wil zeggen dat ze meer devicedrivers hebben), het kan zijn dat ze een
beter procesbeheer hebben, ze kunnen sneller draaien dan de oudere versie, ze
zouden stabieler kunnen zijn dan de oudere versies, en
ze herstellen domme fouten in de oudere versies.
De meeste mensen upgraden kernels omdat ze de devicedrivers en de 
bug fixes willen.
<H2>3.3 Welke soort hardware ondersteunen de nieuwere kernels?</H2>

<P>Zie de Hardware-HOWTO. Als alternatief kun je het bestand
`<CODE>config.in</CODE>' in de linux source bekijken, of er gewoon achterkomen
als je `<CODE>make config</CODE>' uitprobeert.
Hierdoor wordt alle door de standaard kerneldistributie ondersteunde hardware
getoond, maar niet alles dat door linux wordt ondersteund;
veel algemene devicedrivers (zoals de PCMCIA drivers en een aantal tape 
drivers) bestaan uit laadbare modules die apart worden beheerd en 
gedistribueerd.
<H2>3.4 Welke versie van gcc en libc heb ik nodig?</H2>

<P>Linus beveelt in het bestand <CODE>README</CODE>, dat bij de linux source 
is inbegrepen, een gcc-versie aan.
Als je deze versie niet hebt, zou de documentatie van de aanbevolen versie
van gcc aan moeten geven of je je libc moet upgraden.
Dit is geen moeilijke procedure, maar het is belangrijk de instructies op
te volgen.
<H2>3.5 Wat is een laadbare module?</H2>

<P>Dit zijn delen van de kernelcode die niet direct in de kernel zijn
gelinkt (ingevoegd). Ze worden apart gecompileerd, en je kunt ze
op bijna ieder moment in de draaiende kernel invoegen en verwijderen.
Vanwege de flexibiliteit ervan, is dit nu de te verkiezen manier
om bepaalde kernelfaciliteiten te coderen. Veel van de populaire devicedrivers,
zoals de PCMCIA drivers en de QIC-80/40 tapedriver, zijn laadbare modules.
<H2>3.6 Hoeveel diskruimte heb ik nodig?</H2>

<P>
<P>Dat is afhankelijk van je afzonderlijke systeemconfiguratie. 
Ten eerste is de gecomprimeerde linux-source van versie 2.2.9 
bijna 14 megabytes groot. Veel sites houden dit zelfs na het uitpakken.
Ongecomprimeerd en gebouwd met een gemiddelde configuratie, neemt het nog
eens 67 MB in beslag.
<H2>3.7 Hoeveel tijd neemt het in beslag?</H2>

<P>Met nieuwere computers, neemt de compilatie aanmerkelijk minder tijd in beslag
dan met oudere computers; een AMD K6-2/300 met een snelle harddisk kan 
een 2.2.x kernel in ongeveer vier minuten compileren. 
Als je van plan bent om te gaan compileren, wees dan bij oude Pentiums, 
486'rs, en 386'rs voorbereid dat je zult moeten
wachten, mogelijk wel uren, dagen..
<P>Als je je daar zorgen over maakt, en je hebt een snellere computer in
de buurt om op te compileren, kun je op de snelle computers bouwen
(ervan uitgaande dat je het de juiste parameters meegeeft, dat je
ulilities up-to-date zijn, enzovoort), en vervolgens de kernel-image
naar de langzamere computer transporteren.
<H2><A NAME="s4">4. Hoe de kernel feitelijk te configureren</A></H2>

<H2>4.1 Verkrijgen van de source</H2>

<P>
<P>Je kunt de source via anonieme ftp verkrijgen vanaf <CODE>ftp.kernel.org</CODE> in
<CODE>/pub/linux/kernel/vx.y</CODE>, waar <CODE>x.y</CODE> voor de versie staat 
(bv 2.2), en zoals eerder genoemd, die met een oneven nummer eindigen,
zijn development releases en kunnen onstabiel zijn.
Ze zijn vaak gelabeld als <CODE>linux-x.y.z.tar.gz</CODE>, waarbij <CODE>x.y.z </CODE>
voor het versienummer staat. Op de sites staan vaak ook bestanden met het
toevoegsel <CODE>.bz2</CODE>, deze zijn met bzip2 gecomprimeerd 
(ze zullen kleiner zijn en nemen bij het transporteren minder tijd in beslag).
<P>Je kunt het beste <CODE>ftp.xx.kernel.org</CODE> gebruiken, waar <CODE>xx</CODE> 
je landcode voorstelt;
voorbeelden zijn <CODE>ftp.at.kernel.org</CODE> voor Australi&euml;,
en <CODE>ftp.us.kernel.org</CODE> voor de United States.
<H2>4.2 Het uitpakken van de source</H2>

<P>Log in als, of <CODE>su</CODE> naar, `<CODE>root</CODE>', en <CODE>cd</CODE> naar
<CODE>/usr/src</CODE>.
Als je de kernelsource installeerde toen je linux voor het eerst installeerde
(zoals de meeste doen), zal er reeds een directory met de naam
`<CODE>linux</CODE>' voorkomen, die de gehele oude sourcetree bevat.
Als je de diskruimte hebt en het veilig wilt spelen, bewaar die directory
dan. Het is een goed idee om er achter te komen welke versie nu
op je systeem draait en de directory overeenkomstig te hernoemen.
Het commando `<CODE>uname -r</CODE>' drukt de huidige kernelversie af.
Daarom zou je (met `<CODE>mv</CODE>') `<CODE>linux</CODE>' in `<CODE>linux-1.0.9</CODE>'
kunnen hernoemen, als `<CODE>uname -r</CODE> `<CODE>1.0.9</CODE>' aangeeft.
Als je je daar niet zo om bekommert, verwijder dan gewoon de volledige
directory. Zorg er in ieder geval voor dat er geen `<CODE>linux</CODE>' directory
in <CODE>/usr/src</CODE> voorkomt, voordat je de volledige sourcecode uitpakt.
<P>Pak nu in <CODE>/usr/src</CODE> de source uit met
`<CODE>tar zxpvf linux-x.y.z.tar.gz</CODE>'
(als je slechts een <CODE>.tar</CODE> bestand zonder <CODE>.gz</CODE> aan het einde
hebt, werkt `<CODE>tar xpvf linux-x.y.z.tar</CODE>').
De inhoud van de source zal voorbij vliegen. Als 't klaar is, dan zal er
een nieuwe `<CODE>linux</CODE>' directory in <CODE>/usr/src</CODE> voorkomen. 
<CODE>cd</CODE> naar
<CODE>linux</CODE> en lees het bestand <CODE>README</CODE> door.
Er zal een sectie in staan met het label `<CODE>INSTALLING the kernel</CODE>'.
Voer de van toepassing zijnde instructies uit, symbolische links die op
hun plaats zouden moeten staan, verwijdering van oude <CODE>.o</CODE> bestanden,
enz.
<P>Als je een <CODE>.bz2</CODE> bestand en het bzip2 programma hebt (lees erover op
<CODE>http://www.muraroa.demon.co.uk/</CODE>), doe dan het volgende:
<P>
<PRE>
     bz2cat linux-x.y.z.tar.bz2 | tar xvf -
</PRE>
<H2>4.3 Configureren van de kernel</H2>

<P>Opmerking: Een deel hiervan is een herhaling/opheldering van een
vergelijkbare sectie in het <CODE>README</CODE> bestand van Linux.
<P>Het commando `<CODE>make config</CODE>' als je je in <CODE>/usr/src/linux</CODE> 
bevindt, start een configuratiescript, welke je vele vragen stelt.
Het vereist bash, dus verifieer dat bash zich in
<CODE>/bin/bash</CODE>, <CODE>/bin/sh</CODE>, of <CODE>$BASH</CODE> bevindt.
<P>Er zijn echter wat plezieriger alternatieven voor `<CODE>make
config</CODE>' en het kan heel goed zijn dat je ze makkelijker en comfortabeler
in het gebruik vindt.
`<CODE>make menuconfig</CODE>' is waarschijnlijk de meest gebruikte. Wat je ook
kiest, het is het beste als je bekend raakt met de interface, omdat het heel
goed mogelijk is dat je eerder terug zult keren, dan je zult denken.
Voor degene die ``X draaien,'' kun je `<CODE>make xconfig</CODE>' proberen,
als je Tk hebt ge&iuml;nstalleerd `<CODE>make menuconfig</CODE>' is voor degene
die (n)curses hebben en de voorkeur zouden geven aan een op tekst gebaseerd
menu.  Deze interfaces hebben een nogal
duidelijk voordeel: Als je het verprutst en tijdens de configuratie 
een verkeerde keuze maakt, is het heel eenvoudig om terug te gaan en het
te corrigeren.
<P>De configuratie-opties zullen met `<CODE>make menuconfig</CODE>' en
<CODE>make xconfig</CODE>' in hierarchi&euml;n verschijnen.
<P>Je bent er klaar voor om de vragen te gaan beantwoorden, 
gewoonlijk met `<CODE>y</CODE>' (yes) of
`<CODE>n</CODE>' (no). Device drivers hebben typisch een `<CODE>m</CODE>' optie.
Dit betekent ``module,'' wat inhoudt dat het systeem ze niet direct in de
kernel zal compileren, maar als een laadbare module.
Een komischer manier om het te beschrijven is als ``misschien.'' Een aantal
van de vanzelfsprekende en niet-kritieke opties is hier niet beschreven; 
zie de sectie ``Andere configuratie-opties'' voor beknopte beschrijvingen 
van een paar andere opties.
Met `<CODE>make menuconfig</CODE>', verwissel je met de spatiebalk van selectie.
<P>In 2.0.x en later, is er een `?' optie, die voorziet in een korte
beschrijving van de configuratieparameter.
Die informatie is waarschijnlijk het meest up-to-date. 
Hier is een opsomming van een aantal van de belangrijke faciliteiten,
in welke hierarchie ze staan, en met een korte beschrijving.
<H3>Kernel math emulatie (Processor type and facilities)</H3>

<P>Als je geen math processor hebt (je hebt een minimale 386 of
486SX), moet je hier met `<CODE>y</CODE>' antwoorden. 
Als je een coprocessor hebt en je zegt dan toch
`<CODE>y</CODE>', maak je er dan niet te veel zorgen om, de coprocessor wordt
nog steeds gebruikt en de emulatie wordt genegeerd. 
Voor iedere moderne computer, zal het antwoord `no' zijn, maar maak je
geen zorgen als je hier per ongeluk `yes' hebt geantwoord;
als het niet nodig is, wordt het niet gebruikt.
<H3>Enhanced (MFM/RLL) disk en IDE disk/cdrom support (Block Devices)</H3>

<P>
<P>Je zult de ondersteuning waarschijnlijk nodig hebben; het betekent dat de 
kernel standaard PC harddisks, die de meeste mensen hebben, zal ondersteunen.
Bij deze driver zijn SCSI-drivers niet inbegrepen; die komen later 
in de configuratie aan de orde.
<P>Er zal dan worden gevraagd naar de ``old disk-only'' en ``new IDE'' drivers.
Je zult er hier &eacute;&eacute;n van willen kiezen; het belangrijkste 
verschil is dat de oude driver alleen twee disks op een enkele interface 
ondersteunt, en de nieuwe een tweede interface en IDE/ATAPI cdromdrives
ondersteunt. De nieuwe driver is 4k groter dan de oude en 
is, naar men mag aannemen, ook ``verbeterd,'' wat betekent dat het afgezien van
een verschillend aantal bevattende fouten, het je diskperformance kan
verbeteren, vooral als je nieuwere (EIDE-type) hardware hebt.
<H3>Netwerkondersteuning (General Setup)</H3>

<P>In principe, zou je hier slechts `<CODE>y</CODE>' antwoorden, als je 
computer zich in een netwerk bevindt, zoals het internet, of je gebruik
wilt maken van SLIP, PPP, term, enz. om in te bellen voor toegang tot het
internet. Je zou hier echter `<CODE>y</CODE>' moeten antwoorden, 
want veel packages (zoals het X-windowsysteem)
vereisen netwerkondersteuning, ook al is je computer niet op een echt
netwerk aangesloten. Later zal je worden gevraagd of je ondersteuning
wilt voor een TCP/IP netwerk; antwoord hier nogmaals
`<CODE>y</CODE>', als je er niet helemaal zeker van bent.
<H3>System V IPC (General Setup)</H3>

<P>&Eacute;&eacute;n van de beste definities van IPC (Interprocess Communication) 
staat in de verklarende woordenlijst van het Perl boek. 
Het is niet verwonderlijk dat een aantal Perl programmeurs het gebruikt
om processen met elkaar te laten communiceren, evenals vele andere
packages (in 't bijzonder DOOM), dus het is geen goed idee om hier 
<CODE>n</CODE> op te antwoorden, tenzij je precies weet wat je aan het doen bent.
<H3>Processor familie (Processor type en faciliteiten)</H3>

<P>(in oudere kernels: Gebruik de -m486 flag voor 486-specifieke optimalisaties)
<P>Volgens traditie werden hierdoor bepaalde optimalisaties voor een bepaalde
processor meegecompileerd; de kernels draaide prima op andere chips, maar
de kernel was misschien wat groter. 
In nieuwere kernels geldt dit echter niet meer, dus je zou op moeten geven
voor welke processor je de kernel aan het compileren bent.
Een ``386'' kernel werkt met alle computers.
<H3>SCSI-support</H3>

<P>Als je SCSI-devices hebt, antwoord je `<CODE>y</CODE>'. Er zal je worden gevraagd
naar meer informatie, zoals ondersteuning voor CD-ROM, disks, en wat voor soort
SCSI-adapter je hebt. Zie de SCSI-HOWTO voor uitgebreidere details.
<H3>Network device support</H3>

<P>Als je een netwerkkaart hebt, of je zou SLIP, PPP of een parallelle
poortadapter wilen gebruiken om verbinding te maken met het Internet,
antwoord je `<CODE>y</CODE>'. Het configuratiescript zal je vragen naar de soort
kaart die je hebt, en welk protocol moet worden gebruikt.
<H3>Filesystems</H3>

<P>
<P>Het configureerscript vraagt je vervolgens of je ondersteuning voor
de volgende bestandssystemen wilt:
<P>Standard (minix) - Nieuwere distributies maken geen minix bestandssystemen
aan, en veel mensen gebruiken het niet, maar het kan nog steeds een goed
idee zijn om deze te configureren.
Een aantal ``rescue disk'' programma's maakt er gebruik van, en steeds
meer diskettes kunnen een minix bestandssysteem hebben,
aangezien het minix bestandssysteem minder moeizaam op een diskette
is te gebruiken.
<P>Second extended - Dit is het standaard Linux bestandssysteem. Het is bijna
zeker dat je er hier &eacute;&eacute;n van hebt, en 
`<CODE>y</CODE>' moet antwoorden.
<P>msdos - Als je je MS-DOS harddisk partities wilt gebruiken, of MS-DOS
geformatteerde diskettes wilt gebruiken, antwoord je `<CODE>y</CODE>'.
<P>Er zijn diverse andere externe soorten besturingssystemen beschikbaar.
<P>/proc - (idee van Bell Labs, denk ik). Men maakt geen proc bestandssysteem
op een disk;
dit is een bestandssysteeminterface naar de kernel en de processen.
Veel programma's die processen weergeven (zoals `<CODE>ps</CODE>') maken er
gebruik van. Probeer eens een keer
`<CODE>cat /proc/meminfo</CODE>' of `<CODE>cat /proc/devices</CODE>'.
Een aantal shells (rc, in het bijzonder) gebruikt voor I/O 
<CODE>/proc/self/fd</CODE> (op andere systemen bekend als <CODE>/dev/fd</CODE>).
Je zou hier bijna zeker `<CODE>y</CODE>' moeten antwoorden;
veel belangrijke linux tools zijn ervan afhankelijk.
<P>NFS - Als je computer op een netwerk is aangesloten, en je wilt
bestandssystemen gebruiken die voorkomen op andere systemen met NFS,
antwoord dan `<CODE>y</CODE>'.
<P>ISO9660 - Wordt op de meeste CD-ROM's aangetroffen. Als je een CD-ROM 
drive hebt en je wilt het onder Linux gebruiken, geef je als
antwoord `<CODE>y</CODE>'.
<H3>Maar ik weet niet welke bestandssystemen ik nodig heb!</H3>

<P>
<P>Ok, typ `<CODE>mount</CODE>'. De uitvoer zal er ongeveer zo uitzien:
<P>
<BLOCKQUOTE><CODE>
<PRE>
    blah# mount
    /dev/hda1 on / type ext2 (defaults)
    /dev/hda3 on /usr type ext2 (defaults)
    none on /proc type proc (defaults)
    /dev/fd0 on /mnt type msdos (defaults)
</PRE>
</CODE></BLOCKQUOTE>
<P>Bekijk iedere regel; het woord naast `<CODE>type</CODE>' is het type 
bestandssysteem.
In dit voorbeeld zijn mijn <CODE>/</CODE> en <CODE>/usr</CODE> bestandssystemen
second extended, Ik gebruik <CODE>/proc</CODE>, en er is een diskette gemount
door gebruik te maken van het msdos-bestandssysteem.
<P>Je kunt `<CODE>cat /proc/filesystems</CODE>' proberen, als je <CODE>/proc</CODE>
thans is geactiveerd; je huidige kernel's bestandssystemen zullen worden
weergegeven.
<P>De configuratie van zeldzaam gebruikte, niet kritieke bestandssystemen
kunnen een bloat kernel veroorzaken; zie de sectie over modules voor een 
manier om dit te voorkomen en de sectie
``Valkuilen'' over waarom een bloat kernel niet wenselijk is.
<H3>Character devices</H3>

<P>
<P>Hier activeer je de drivers voor je printer (dat wil zeggen, parallelle
printer), busmouse, PS/2 mouse (veel notebooks gebruiken het PS/2 
mouse protocol voor hun ingebouwde trackballs), een aantal tapedrives, 
en andere ``character'' devices. Antwoord `<CODE>y</CODE>' als dit van
toepassing is.
<P>Opmerking: <CODE>gpm</CODE> is een programma waarmee
het gebruik van de muis buiten het X-windowsysteem voor knippen en plakken
tussen virtuele consoles is toegestaan.
Het is echt heel aardig als je een seri&euml;le muis hebt, omdat
het goed naast X kan voortbestaan, maar je hebt voor andere muizen
speciale foefjes nodig.
<H3>Sound</H3>

<P>
<P>Als je een groot verlangen voelt om <CODE>geklap en geblaf</CODE> te horen, 
antwoord dan `<CODE>y</CODE>',
en je kunt het configuratieprogramma alles over je geluidskaart laten weten.
(Een opmerking over de configuratie van een geluidskaart: 
als je wordt gevraagd of je de volledige versie van de driver wilt
installeren, kun je hier
`<CODE>n</CODE>' antwoorden en wat kernelgeheugen besparen door alleen
de faciliteiten eruit te pikken die je nodig acht).
<P>Als de geluidsondersteuning je menens is, bekijk dan eens de 
vrij verkrijgbare drivers bij <CODE>http://www.linux.org.uk/OSS/</CODE> en 
het commerci&euml;le Open Sound System bij <CODE>http://www.opensound.com/</CODE>.
<H3>Andere configuratie-opties</H3>

<P>Niet alle configuratie-opties worden hier opgesomd, omdat ze te vaak
wijzigen of tamelijk vanzelfsprekend zijn (bijvoorbeeld, 3Com 3C509 
ondersteuning voor het compileren van de devicedriver voor deze 
speciale ethernetkaart).
Er bestaat een tamelijk uitgebreide lijst met opties (plus een manier om
ze in het <CODE>Configure</CODE> script te plaatsen) met inzet gestart en
beheerd door Axel Boldt (<CODE>boldt@math.ucsb.edu</CODE>) en het is de online-
help. Het is sinds versie 2.0 ook beschikbaar als &eacute;&eacute;n 
groot bestand als de
<CODE>Documentation/Configure.help</CODE> in je Linux kernel source tree.
<H3>Kernel hacking</H3>

<P>
<P>>Vanuit het README bestand van Linus:
<P>de ``kernel hacking'' configuratie details resulteren meestal in
een grotere of langzamere kernel (of beiden), en kan de kernel zelfs
minder stabiel maken door een aantal routines te configureren die actief
probeert slechte code aan de oppervlakte te laten komen om kernelproblemen
op te sporen (kmalloc()). Dus je zou waarschijnlijk `n' moeten 
antwoorden op de vragen voor een ``production'' kernel.
<H2>4.4 Wat nu? (De Makefile)</H2>

<P>
<P>Nadat je de configuratie hebt be&euml;indigd, krijg je een bericht dat je
kernel is geconfigureerd en de melding  
``check the top-level <CODE>Makefile</CODE> for additional configuration,'' 
enz.
<P>Dus bekijk <CODE>Makefile</CODE>. Je zult het waarschijnlijk niet hoeven
wijzigen, maar het kan nooit kwaad het te bekijken. 
Je kunt de opties ervan ook wijzigen met het
commando `<CODE>rdev</CODE>' zodra de nieuwe kernel op z'n plaats staat.
Als het je ontgaat als je het bestand bekijkt, maak je er dan geen zorgen om.
<H2><A NAME="s5">5. Compileren van de kernel</A></H2>

<H2>5.1 Opschonen en afhankelijkheden</H2>

<P>
<P>Als het configuratiescript eindigt, geeft het ook aan een `<CODE>make dep</CODE>'
en (mogelijk) `<CODE>clean</CODE>' uit te voeren.
Dus, doe de `<CODE>make dep</CODE>'. Dit verzekert je dat alle
afhankelijkheden, zoals de include bestanden, op hun plaats staan. 
Het duurt niet lang, tenzij je computer om te beginnen nogal langzaam is.
Je zou voor oudere versies van de kernel een `<CODE>make clean</CODE> 
moeten doen, als je klaar bent.
Hiermee worden alle object-bestanden en wat andere zaken verwijderd die door
een oude versie achter worden gelaten. Vergeet deze stap in ieder geval
<I>niet</I> voordat je een poging gaat ondernemen om een kernel te
hercompileren.
<H2>5.2 Compileertijd</H2>

<P>
<P>Na een <CODE>make dep</CODE> en een <CODE>make clean</CODE>, kun je nu een
`<CODE>make bzImage</CODE>' of `<CODE>make bzdisk</CODE>' opstarten 
(dit is het onderdeel dat lang duurt).
`<CODE>make bzImage</CODE>' zal de kernel compileren, en (onder andere)
een bestand in <CODE>arch/i386/boot</CODE> met de naam `<CODE>bzImage</CODE>'
achterlaten. Dit is de nieuw gecomprimeerde kernel.
`<CODE>make bzdisk</CODE>' doet hetzelfde, maar het plaatst ook het nieuwe
<CODE>bzImage</CODE> op een diskette, die je hopelijk in drive
``A:'' deed. `<CODE>bzdisk</CODE>' is nogal handig voor het testen van nieuwe
kernels; als het totaal mislukt (of het gewoon niet goed werkt), 
verwijder dan gewoon de diskette en boot met je oude kernel.
Als je per ongeluk je kernel verwijdert (of iets net zo vreselijks),
kan het ook een handige manier zijn om te booten. Je kunt het ook 
gebruiken om nieuwe systemen te installeren als je de inhoud van de ene naar
de andere disk dumpt.
(``dit alles en meer! hoeveel zou je NU willen betalen?'').
<P>Alle pas halverwege redelijk recente kernels zijn gecomprimeerd, hieruit
volgt de `<CODE>bz</CODE>' aan het begin van de naam. Een gecomprimeerde 
kernel decomprimeert zichzelf als het wordt uitgevoerd.
<P>In oudere kernels had je de optie niet om een <CODE>bzImage</CODE> te bouwen; het
was gewoon een <CODE>zImage</CODE>. Die optie is op het moment nog steeds
beschikbaar, het is echter, gegeven de grootte van de nieuwere kernels, min
of meer verplicht om een <CODE>bzImage</CODE> te bouwen, omdat de oudere
methoden niet met een al te grote kernel om kunnen gaan.
<H2>5.3 Andere ``make'' 's</H2>

<P>Met `<CODE>make mrproper</CODE>' zal een grootser opgezette `<CODE>schoonmaak</CODE>
worden uitgevoerd.
Soms is het nodig; je wilt het misschien bij iedere patch doen. Met `<CODE>make
mrproper</CODE>' zal ook je configuratiebestand worden verwijderd, 
dus misschien wil je een backup maken van
(<CODE>.config</CODE>), als je het als waardevol beschouwd.
<P>Met `<CODE>make oldconfig</CODE>' zal worden geprobeerd de kernel vanuit een
oud configuratiebestand te configureren;
het zal het `<CODE>make config</CODE>' proces voor je doorlopen.
Als je nooit eerder een kernel hebt gecompileerd of je hebt geen
oud configuratiebestand, dan zou je dit waarschijnlijk niet moeten doen,
aangezien je zeer waarschijnlijk je standaardconfiguratie zal willen
veranderen.
<P>Zie de sectie over modules voor een beschrijving van `<CODE>make modules</CODE>'.
<H2>5.4 Installeren van de kernel</H2>

<P>Nu dat je een kernel hebt die lijkt te werken zoals je het wilt, is het tijd
om het te installeren.
De meeste mensen gebruiken hiervoor LILO (Linux Loader).
`<CODE>make bzlilo</CODE>' zal de kernel installeren, draai LILO,
en je bent er helemaal klaar voor om te booten, MAAR ALLEEN als lilo 
op de volgende manier op je systeem is geconfigureerd:
kernel is <CODE>/vmlinuz</CODE>, lilo is in <CODE>/sbin</CODE>, en je lilo config
(<CODE>/etc/lilo.conf</CODE>) stemt daar mee overeen.
<P>Anders moet je LILO op directe wijze gebruiken. Het is een tamelijk makkelijk
package om te installeren en om mee te werken, maar het heeft de
neiging om mensen met z'n configuratiebestand in de war te brengen.
Zoek naar het configuratiebestand (<CODE>/etc/lilo/config</CODE> voor oudere
versies of <CODE>/etc/lilo.conf</CODE> voor nieuwe versies), en bekijk de
huidige setup. Het configuratiebestand ziet er ongeveer zo uit:
<P>
<PRE>
    image = /vmlinuz
        label = Linux
        root = /dev/hda1
        ...
</PRE>
<P>De `<CODE>image =</CODE>' is op de huidige ge&iuml;nstalleerde kernel ingesteld.
De meeste mensen gebruiken <CODE>/vmlinuz</CODE>. `<CODE>label</CODE>'
wordt door lilo gebruikt om vast te stellen welke kernel of welk
besturingssysteem moet worden geboot, en
`<CODE>root</CODE>' is de <CODE>/</CODE> van dat bepaalde besturingssysteem.
Maak een backup van je oude kernel en kopieer het
<CODE>bzImage</CODE> dat je net op z'n plaats hebt gezet
(je zou hier `<CODE>cp bzImage /vmlinuz</CODE>' opgeven als je
`<CODE>/vmlinuz</CODE>' gebruikt). Start lilo dan weer op,
op nieuwere systemen kun je gewoon
`<CODE>lilo</CODE>' opstarten, maar op oudere, kan het zijn dat je
<CODE>/etc/lilo/install</CODE> of zelfs 
<CODE>/etc/lilo/lilo -C /etc/lilo/config</CODE> op moet geven.
<P>Als je meer zou willen weten over de configuratie van LILO, of je hebt
LILO niet, haal dan de nieuwste versie vanaf je favoriete ftp-site en
volg de instructies op.
<P>Om &eacute;&eacute;n van je oude kernels vanaf de harddisk te booten
(een andere manier om jezelf te redden voor 't geval je de nieuwe kernel
hebt verprutst), kopieer je de regels hieronder (en voeg ze in): 
`<CODE>image = xxx</CODE>' in het configuratiebestand van LILO onderaan
het bestand, waarbij je 
`<CODE>image = xxx</CODE>' wijzigt in
`<CODE>image = yyy</CODE>';hierbij staat `<CODE>yyy</CODE>' voor de volledige padnaam
van het bestand, waarin je je backup van de kernel bewaarde.
<P>Wijzig dan de regel `<CODE>label = zzz</CODE>' in
`<CODE>label = linux-backup</CODE>' en herstart <CODE>lilo</CODE>. 
Misschien moet je nog een regel in het configuratiebestand plaatsen
zoals `<CODE>delay=x</CODE>', waar x staat voor het aantal tienden seconden,
dat LILO voor het booten moet wachten, zodat je het kunt onderbreken.
(bijvoorbeeld met de shift-toets), en het label in kunt tikken 
van de backup boot-image (voor 't geval er onplezierige dingen gebeuren).
<H2><A NAME="s6">6. Patchen van de kernel</A></H2>

<H2>6.1 Toepassen van een patch</H2>

<P>
<P>Periodieke upgrades van de kernel worden als patches gedistribueerd.
Als je bijvoorbeeld versie 1.1.45 hebt, en je merkt dat er een 
`<CODE>patch46.gz</CODE>' voor is, betekent het dat je naar versie 
1.1.46 kunt upgraden door toepassing van de patch. 
Misschien wil je eerst een backup van de sourcetree maken
(`<CODE>make clean</CODE>' en vervolgens
`<CODE>cd /usr/src; tar zcvf old-tree.tar.gz linux</CODE>'
zal een gecomprimeerd tar-archief voor je maken).
<P>Dus, verdergaand met het voorbeeld van hierboven, laten we ervan uitgaan
dat je `<CODE>patch46.gz</CODE>' in <CODE>/usr/src</CODE> hebt. <CODE>cd</CODE> naar
<CODE>/usr/src</CODE>  en doe een `<CODE>zcat patch46.gz | patch -p0</CODE>'
(of `<CODE>patch -p0 &lt; patch46</CODE>'
als de patch niet is gecomprimeerd). Je zult van alles voorbij zien
vliegen (of fladderen als je systeem zo langzaam is) om je te laten
weten dat het aan het proberen is om brokken toe te passen en of het
daarin slaagt of niet.  Meestal gaan deze acties te snel voorbij om
ze te kunnen lezen, en ben je er niet helemaal zeker van of het wel of
niet werkte, dus misschien wil je de
<CODE>-s</CODE> flag aan <CODE>patch</CODE> opgeven, welke <CODE>patch</CODE> aangeeft
alleen de foutmeldingen te rapporteren (je krijgt niet zoveel als bij het
``h&eacute;, mijn computer doet eindelijk eens wat voor de verandering!''
gevoel, maar het kan zijn dat je hier de voorkeur aan geeft ..). 
Om die onderdelen te bekijken die misschien niet zo soepel zijn verlopen,
cd je naar <CODE>/usr/src/linux</CODE> en
zoek je naar bestanden met een <CODE>.rej</CODE> extensie. 
Een aantal versies van <CODE>patch</CODE>
(oudere versies welke kunnen zijn gecompileerd met een inferieur
bestandssysteem) laat de verwerpingen met een <CODE>#</CODE> extensie achter.
Je kunt `<CODE>find</CODE>' gebruiken om ze voor je op te sporen;
<PRE>
    find .  -name '*.rej' -print
</PRE>

drukt alle bestanden in de huidige directory of elke subdirectory met de
<CODE>.rej</CODE> extensie naar standaarduitvoer af.
<P>Als alles goed ging, doe je een `<CODE>make clean</CODE>', `<CODE>config</CODE>',
en `<CODE>dep</CODE>' zoals in sectie 3 en 4 werd beschreven.
<P>Er zijn heel wat opties voor het <CODE>patch</CODE> commando. Zoals hierboven
genoemd, zal <CODE>patch -s</CODE> alle berichten behalve de foutmeldingen
onderdrukken. Als je je kernelsource op een andere plaats dan
<CODE>/usr/src/linux</CODE> bewaart, zal er met <CODE>patch -p1</CODE>
(in die directory) een zuivere patch worden uitgevoerd. 
Andere <CODE>patch</CODE> opties zijn goed gedocumenteerd in de manual page.
<H2>6.2 Als er iets fout gaat</H2>

<P>
<P>(Opmerking: deze sectie refereert voornamelijk naar nogal oude kernels)
<P>Het meest voorkomende probleem dat zich voordeed was wanneer een patch 
een bestand met de naam `<CODE>config.in</CODE>' wijzigde en het er niet helemaal
goed uitzag, omdat je de opties wijzigde om aan je computer aan te passen.
Dit is verholpen, maar het kan zijn dat je het met een oudere release
nog aan zult treffen.  
Bekijk het bestand <CODE>config.in.rej</CODE> om het te herstellen, en zie
wat er van de originele patch over is gebleven.
Kenmerkend is dat de wijzigingen aan het begin van de regel
met een `<CODE>+</CODE>' en een `<CODE>-</CODE>' worden gemarkeerd.
Kijk naar de regels die erdoor worden omsloten, en denk eraan terug of ze
met `<CODE>y</CODE>' of `<CODE>n</CODE>' werden ingesteld. Wijzig nu
je <CODE>config.in</CODE>, en verander daar waar van toepassing de
`<CODE>y</CODE>' in een `<CODE>n</CODE>' en de `<CODE>n</CODE>' in een `<CODE>y</CODE>'
Tik in
<PRE>
    patch -p0 &lt; config.in.rej
</PRE>

en als het rapporteert dat het
succesvol was (zonder gebreken), dan kun je verdergaan met de 
configuratie en compilatie.
Het bestand <CODE>config.in.rej</CODE> blijft behouden, maar je kunt het
verwijderen.
<P>Als je verdere problemen tegenkomt, kan het zijn dat je een patch in de
verkeerde volgorde hebt ge&iuml;nstalleerd.
Als patch de melding `<CODE>previously applied patch detected: Assume
-R?</CODE>' geeft, ben je waarschijnlijk aan het proberen om een patch
toe te passen welke lager is dan het huidige versienummer;
als je `<CODE>y</CODE>' antwoordt, zal het proberen je source te degraderen,
en zal hier waarschijnlijk niet in slagen; dus je zult een volledige nieuwe
versie van de source tree nodig hebben
(wat in eerste instantie niet eens zo'n slecht idee zou zijn geweest).
<P>Om een patch achteraf te verwijderen, gebruik je
`<CODE>patch -R</CODE>' op de originele patch
(het toepassen ongedaan maken).
<P>Als patches echt verkeerd blijken te zijn, kun je het beste
opnieuw beginnen met een nog onaangetaste source tree (bijvoorbeeld 
vanuit &eacute;&eacute;n van de <CODE>linux-x.y.z.tar.gz</CODE> bestanden).
<H2>6.3 De .orig bestanden zien kwijt te raken</H2>

<P>
<P>Na slechts een paar patches, zullen de <CODE>.orig</CODE> bestanden zich beginnen
op te stapelen. Een 1.1.51 tree die ik bijvoorbeeld ooit had, was voor het
laatst bij 1.1.48 opgeschoond.
Het verwijderen van de .orig bestanden bespaarde me meer dan een halve meg.
<PRE>
    find .  -name '*.orig' -exec rm -f {} ';'
</PRE>

zal dit voor je regelen. Versies van <CODE>patch</CODE> die
<CODE>#</CODE> gebruiken voor verwerpingen, maken gebruik van een tilde 
in plaats van <CODE>.orig</CODE>.
<P>Er zijn betere manieren om af te geraken van de <CODE>.orig</CODE> bestanden,
die afhankelijk zijn van GNU <CODE>xargs</CODE>:
<PRE>
    find .  -name '*.orig' | xargs rm
</PRE>

of de ``heel veilige maar een beetje uitgebreidere'' methode:
<PRE>
    find . -name '*.orig' -print0 | xargs --null rm --
</PRE>
<H2>6.4 Andere patches </H2>

<P>
<P>Er zijn andere patches (Ik zal ze ``nietstandaard'' noemen) dan die
Linus distribueert. Als je deze toepast, kan het zijn dat de patches
van Linux niet correct werken en dan zul je ze alsnog moeten verwijderen,
de source of de patch moeten herstellen, een nieuwe sourcetree moeten
installeren, of een combinatie van het bovenstaande. Dit kan erg
frustrerend worden, dus als je de source niet wilt wijzigen (met de
kans op een zeer slechte uitkomst), verwijder dan de niet-standaard
patches voordat je die van Linux toepast, of installeer gewoon een
nieuwe tree. Vervolgens kun je zien of de niet-standaard patches nog
steeds werken. Als dat niet zo is, zit je vast aan een oude
kernel, het spelen met de patch of de source om het aan het werk te
krijgen, of zul je moeten wachten (of bedelen) tot er een nieuwe versie
van de patch uitkomt.
<P>Hoe algemeen zijn de patches die zich niet in de standaarddistributie
bevinden? Je zult waarschijnlijk van ze horen. Ik was gewend de noblink
patch voor mijn virtuele consoles te gebruiken, omdat ik een hekel heb
aan knipperende cursors. (Deze patch wordt (of tenminste werd) vaak
bijgewerkt voor nieuwe kernelreleases). Van de meeste nieuwe devicedrivers,
die als laadbare modules worden ontwikkeld, is de frequentie van 
"niet-standaard" patches echter aanmerkelijk aan het afnemen.
<H2><A NAME="s7">7. Aanvullende packages</A></H2>

<P>Je linuxkernel heeft vele faciliteiten die niet in de kernelsource zelf
zijn uitgelegd; deze faciliteiten worden kenmerkend door externe
packages gebruikt. Een aantal van de meest gebruikelijke faciliteiten
wordt hier opgesomd.
<H2>7.1 kbd</H2>

<P>De linux console heeft waarschijnlijk meer faciliteiten dan het toekomt.
Hiertussen bevindt zich de mogelijkheid om van lettertypen te verwisselen,
je toetsenbord opnieuw in te delen, tussen video-modes te schakelen
(in nieuwere kernels), enz. Het kbd package bestaat uit programma's
die de gebruiker in staat stellen om dit allemaal te doen, plus nog
vele lettertypen en toetsenbordindelingen voor bijna ieder toetsenbord, 
en het is vanaf dezelfde sites beschikbaar waar de kernelsource te
vinden is.
<H2>7.2 util-linux</H2>

<P>Rik Faith (<CODE>faith@cs.unc.edu</CODE>) heeft een grote verzameling
linux utility's bijeen gebracht, door een eigenaardig toeval, met de naam
util-linux. Deze
worden nu door Andries Brouwer (<CODE>util-linux@math.uio.no</CODE>) beheerd.
Beschikbaar via anonieme ftp vanaf sunsite.unc.edu in 
<CODE>/pub/Linux/system/misc</CODE>, het
bevat programma's zoals <CODE>setterm</CODE>, <CODE>rdev</CODE>, en
<CODE>ctrlaltdel</CODE>, die relevant zijn voor de kernel. Zoals Rik zegt, 
<I>installeer het niet zonder erbij na te denken ;</I> 
je hoeft niet alles dat zich in het package bevindt, te installeren, en
het zou heel goed ernstige problemen kunnen veroorzaken als je dit
wel doet.
<H2>7.3 hdparm</H2>

<P>Zoals met vele packages, was dit ooit een kernelpatch en ondersteunde
programma's. De patches haalde het tot in de offici&euml;le kernel, en
de programma's voor het optimaliseren en spelen met je harddisk worden
afzonderlijk gedistribueerd.
<H2>7.4 gpm</H2>

<P>gpm staat voor `general purpose mouse.' Dit programma staat je toe om tussen
virtuele consoles tekst te knippen en te plakken en wat andere dingen te
doen met een grote diversiteit aan muistypes.
<H2><A NAME="s8">8. Een aantal valkuilen</A></H2>

<H2>8.1 make clean </H2>

<P>Als je nieuwe kernel echt vreemde dingen doet na een routine kernel-upgrade,
bestaat de kans dan je vergat 
<CODE>make clean</CODE> uit te voeren voordat je de nieuwe kernel compileerde.
De symptomen kunnen van alles zijn, van je systeem dat ineens crasht,
vreemde I/O problemen, te lage performance. Wees er zeker van dat je
ook een <CODE>make dep</CODE> doet.
<H2>8.2 Zeer grote of langzame kernels</H2>

<P>Als je kernel een boel geheugen opslurpt, te groot is, en/of het compileren
eeuwig duurt, ook al heb je een nieuwe Quadbazillium-III/4400 die eraan werkt,
dan heb je waarschijnlijk erg veel onnodig spul (device drivers, 
bestandssystemen, enz) geconfigureerd. Als je het niet gebruikt, configureer
het dan niet, want het neemt geheugen in beslag.
Het meest opvallende van kernel bload is het extreme in en uitswappen van 
geheugen naar de disk; als je disk een heleboel lawaai maakt en het niet
&eacute;&eacute;n van die oude Fujitsu Eagles is, die klinken alsof er een
straalvliegtuig landt als je je computer uitzet, kijk dan nog eens naar je 
kernelconfiguratie.
<P>Je kunt erachter komen hoeveel geheugen je kernel gebruikt door de
totale hoeveelheid geheugen in je machine af te trekken van de hoeveeelheid
van ``total mem'' in <CODE>/proc/meminfo</CODE>  of de uitvoer van het
commando `<CODE>free</CODE>'.
<H2>8.3 De parallelle poort werkt niet/mijn printer werkt niet</H2>

<P>Configuratie-opties voor PC's zijn: Selecteer als eerste, onder de categorie
`General Setup', `Parallel port support' en `PC-style hardware'. Selecteer 
dan onder `Character devices', `Parallel printer support'.
<P>En dan zijn er nog de namen. Linux 2.2 noemt de printerdevices anders dan
in voorgaande releases.
Het komt hierop neer dat, als je onder je oude kernel een <CODE>lp1</CODE> 
had, het onder je nieuwe kernel waarschijnlijk een <CODE>lp0</CODE> is.
Gebruik `<CODE>dmesg</CODE>' of doorzoek de logs in <CODE>/var/log</CODE> om erachter
te komen.
<H2>8.4 Kernel compileert niet </H2>

<P>
<P>Als het niet compileert, dan is het waarschijnlijk dat er een patch 
mislukte, of je source is op &eacute;n&eacute;n of andere manier verknoeid.
Het kan ook zijn dat je niet de juiste versie van gcc hebt, of deze kan
ook verknoeid zijn (de include bestanden kunnen bijvoorbeeld fout zijn).
Zorg ervoor dat de symbolische links, die Linux in de
<CODE>README</CODE> beschrijft, juist zijn ingesteld. 
In het algemeen geldt, dat als een standaardkernel niet compileert, er
iets ernstig mis is met het systeem, en opnieuw installeren van bepaalde
tools is waarschijnlijk noodzakelijk.
<P>In een aantal gevallen kan gcc door hardwareproblemen crashen. 
De foutmelding zal iets zijn als ``xxx exited with signal 15'' en het zal
er gewoonlijk zeer mysterieus uitzien. Ik zou dit waarschijnlijk niet
ter sprake hebben gebracht, behalve dat het me een keer overkwam
- Ik had wat slecht cache geheugen, en de compiler kon nu en dan
willekeurig weigeren. Probeer als eerste gcc opnieuw te
installeren als je problemen ervaart.
Je zou alleen achterdochtig moeten zijn, als je kernel goed compileert
met externe cache uitgezet, een verminderde hoeveelheid RAM, enz.
<P>Het schijnt mensen te storen wanneer er wordt gesuggereerd, dat er problemen
met hun hardware zijn. Ik verzin dit niet. Er is een FAQ voor -- het is te
vinden bij <CODE>http://www.bitwizard.nl/sig11/</CODE>.
<H2>8.5 De nieuwe kernelversie lijkt niet te booten</H2>

<P>
<P>Je hebt LILO niet gedraaid of het is niet juist geconfigureerd. 
&Eacute;&eacute;n ding dat me eens ``overkwam'', was een probleem in het
configuratiebestand; het gaf aan `<CODE>boot = /dev/hda1</CODE>'
in plaats van `<CODE>boot = /dev/hda</CODE>' (Dit kan in het begin echt 
hinderlijk zijn, maar zodra je een werkend configuratiebestand hebt, zou
je het niet meer hoeven te wijzigen).
<H2>8.6  Je vergat LILO te draaien, of je systeem boot helemaal niet</H2>

<P>
<P>Oeps! Het beste wat je hier kunt doen is met een diskette of CDROM te 
booten en een andere opstartbare diskette aan te maken
(zoals `<CODE>make zdisk</CODE>' zou doen).
Je zult moeten weten waar je root (<CODE>/</CODE>) bestandssysteem zich bevindt 
en van welk type het is
(b.v. second extended, minix). In het voorbeeld hieronder zul je ook moeten
weten op welk bestandssysteem je
<CODE>/usr/src/linux</CODE> source-tree zich bevindt, het type, 
en waar het normaal gesproken wordt gemount.
<P>In het volgende voorbeeld, is <CODE>/</CODE> <CODE>/dev/hda1</CODE>, en het
bestandssysteem met <CODE>/usr/src/linux</CODE>
is <CODE>/dev/hda3</CODE>, normaal gesproken gemount onder <CODE>/usr</CODE>. 
Het zijn allebei second extended bestandssystemen. De werkende kernel image in
<CODE>/usr/src/linux/arch/i386/boot</CODE> wordt <CODE>bzImage</CODE> genoemd.
<P>De bedoeling is, dat als er een functionerend
<CODE>bzImage</CODE> is, het mogelijk is om dat voor de nieuwe diskette te
gebruiken. Een ander alternatief, welke wel of niet beter kan werken,
(dit hangt af van de speciale methode waarin je je systeem hebt verknoeid) 
wordt na het voorbeeld besproken.
<P>Boot om te beginnen vanaf een boot/root diskset of rescuedisk, 
en mount het bestandssysteem waarin zich de werkende kernel-image
bevindt:
<P>
<P>
<PRE>
    mkdir /mnt
    mount -t ext2 /dev/hda3 /mnt
</PRE>
<P>Als <CODE>mkdir</CODE> je de melding geeft dat de directory al bestaat, negeer
het dan gewoon.
<CODE>cd</CODE> nu naar de plaats waar de werkende kernel-image stond. Merk
op dat 
<PRE>
/mnt + /usr/src/linux/arch/i386/boot - /usr = /mnt/src/linux/arch/i386/boot
</PRE>
<P>Plaats een geformatteerde disk in drive ``A:'' (niet je boot- of rootdisk!),
dump de image naar de disk, en configureer het voor je root bestandssysteem:
<P>
<PRE>
    cd /mnt/src/linux/arch/i386/boot
    dd if=bzImage of=/dev/fd0
    rdev /dev/fd0 /dev/hda1
</PRE>
<P><CODE>cd</CODE> naar <CODE>/</CODE> en unmount het normale <CODE>/usr</CODE>
bestandssysteem:
<PRE>
    cd /
    umount /mnt
</PRE>
<P>Je zou je systeem nu zoals gewoonlijk vanaf deze diskette op moeten kunnen
starten. Vergeet na het opstarten, lilo niet te draaien 
(of wat je ook verkeerd deed)!
<P>Zoals hierboven genoemd, is er nog een ander alternatief. Als je
een werkende kernel-image in <CODE>/</CODE> hebt, (bijvoorbeeld
<CODE>/vmlinuz</CODE>), kun je dat voor een bootdisk gebruiken.
Uitgaande van alle bovenstaande condities, en dat mijn kernel-image 
<CODE>/vmlinuz</CODE> is, maak je gewoon deze wijzigingen aan, in het
voorbeeld hierboven:
verander
<CODE>/dev/hda3</CODE> in <CODE>/dev/hda1</CODE> (het <CODE>/</CODE> bestandssysteem),
<CODE>/mnt/src/linux</CODE> in
<CODE>/mnt</CODE>, en <CODE>if=bzImage</CODE> in <CODE>if=vmlinuz</CODE>. De
opmerking die uitleg geeft hoe <CODE>/mnt/src/linux</CODE> kan worden afgeleid,
kan worden genegeerd.
<P>LILO met grote drives gebruiken, (meer dan 1024 cylinders) 
kan problemen veroorzaken.
Zie de LILO mini-HOWTO of documentatie hierover voor hulp.
<H2>8.7 Het geeft de melding `warning: bdflush not running'</H2>

<P>
<P>Dit kan een ernstig probleem zijn. Beginnend met kernelrelease
na 1.0 (rond 20 Apr 1994), werd een programma met de naam
`<CODE>update</CODE>' bijgewerkt, welke periodiek de buffers van het 
bestandssysteem opschoont. 
Haal de sources van `<CODE>bdflush</CODE>' op
(je zou het moeten kunnen vinden daar waar je je kernelsource vandaan hebt
gehaald), en installeer het (je wilt je systeem waarschijnlijk
onder de oude kernel draaien als je hiermee bezig bent). Het
installeert zichzelf als `<CODE>update</CODE>' en na een reboot, zou de nieuwe
kernel er niet langer problemen mee moeten hebben.
<H2>8.8 Ik krijg mijn IDE/ATAPI CD-ROM drive niet aan de praat</H2>

<P>Vreemd genoeg krijgen een heleboel mensen hun ATAPI drives niet werkend,
waarschijnlijk omdat er een aantal dingen verkeerd kan gaan.
<P>Als je CD-ROM drive het enige apparaat op een bepaalde IDE interface is,
moet het als ``master'' of ``slave'' zijn gejumperd.
Dit is vermoedelijk de meest voorkomende fout.
<P>Creative Labs heeft nu IDE-interfaces op hun geluidskaarten
gezet. Dit leidt echter tot het interessante probleem dat terwijl een
aantal mensen slechts &eacute;&eacute;n interface heeft
, hebben velen twee
IDE-interfaces op hun moederborden ingebouwd (meestal op IRQ15), dus 
het is een algemene gewoonte om van de
soundblaster interface een derde IDE poort te maken (IRQ11, is me verteld).
<P>Dit veroorzaakt problemen met linux gezien versies 1.2.x geen derde
IDE-interface ondersteunen
(er is ondersteuning te beginnen ergens in 1.3.x series
maar dat is development, denk daaraan, en het doet geen auto-probe). 
Om dit te omzeilen, heb je een paar keuzes.
<P>Als je al een tweede IDE-poort hebt, bestaat de kans dat je het niet
gebruikt, of er zich nog geen twee devices op bevinden.
Haal de ATAPI-drive van de geluidskaart af en bevestig het aan de tweede
interface. Je kunt de interface van de geluidskaart vervolgens de-activeren,
wat je hoe dan ook een IRQ bespaart.
<P>Als je geen tweede interface hebt, jumper de interface van de geluidskaart
(niet het geluidsdeel van de geluidskaart) dan als IRQ15, de tweede interface. 
Het zou moeten werken.
<H2>8.9 Het geeft rare meldingen over `obsolete routing requests'</H2>

<P>
<P>Haal nieuwe versies op van het <CODE>route</CODE> programma en enige andere
programma's die er zijn voor route manipulatie.
<CODE>/usr/include/linux/route.h</CODE>  (dat eigenlijk een bestand in
<CODE>/usr/src/linux</CODE> is), is gewijzigd.
<H2>8.10 Firewall werkt niet in 1.2.0</H2>

<P>Upgrade naar tenminste versie 1.2.1.
<H2>8.11 ``Not a compressed kernel Image file''</H2>

<P>Gebruik het bestand <CODE>vmlinux</CODE> die je in <CODE>/usr/src/linux</CODE>
hebt aangemaakt, niet als je boot-image; het juiste bestand is
<CODE>[..]/arch/i386/boot/bzImage</CODE>.
<H2>8.12 Problemen met console terminal na het upgraden tot 1.3.x</H2>

<P>Wijzig het woord <CODE>dumb</CODE> in <CODE>linux</CODE> in de console termcap
entry in <CODE>/etc/termcap</CODE>. Het kan ook zijn dat je een terminfo
entry moet maken.
<H2>8.13 Het lijkt erop dat ik dingen na de kernel-upgrade niet kan compileren</H2>

<P>De linux kernelsource bevat een aantal include bestanden (die met
een <CODE>.h</CODE> eindigen), waarnaar wordt verwezen door de standaard
include bestanden in <CODE>/usr/include</CODE>. 
Er wordt als volgt naar verwezen (waar
<CODE>xyzzy.h</CODE> iets in <CODE>/usr/include/linux</CODE> zou zijn):
<PRE>
    #include &lt;linux/xyzzy.h>
</PRE>
<P>Normaal gesproken, is er een link met de naam <CODE>linux</CODE> in 
<CODE>/usr/include</CODE> naar de directory
<CODE>include/linux</CODE> van je kernelsource
(<CODE>/usr/src/linux/include/linux</CODE> op het systeem). Als deze link
niet voorkomt, of naar de verkeerde plaats verwijst, zal het meeste helemaal
niet worden gecompileerd.
Als je besloot de kernelsource te verwijderen, omdat het te veel
ruimte op de disk in beslag nam, zal dit uiteraard een probleem zijn.
Een andere manier waarop het fout kan gaan is door bestandspermissies;
als je <CODE>root</CODE> een umask heeft, die andere gebruikers niet toestaat,
standaard de bestanden te zien, en je pakte de kernelsource uit met de
<CODE>p</CODE> (preserve filemodes)
optie, dan zullen die gebruikers ook niet in staat zijn om de C compiler
te gebruiken. Alhoewel je het
<CODE>chmod</CODE> commando zou kunnen gebruiken om dit te herstellen, 
is het waarschijnlijk makkelijker om de include bestanden opnieuw uit te
pakken. Je kunt dit op dezelfde manier doen zoals
je in het begin met de hele source deed, alleen met een aanvullend argument:
<P>
<PRE>
    blah# tar zxvpf linux.x.y.z.tar.gz linux/include
</PRE>

Opmerking: ``<CODE>make config</CODE>'' zal de <CODE>/usr/src/linux</CODE>
opnieuw aanmaken als het er niet is.
<H2>8.14 Verhogen van limieten</H2>

<P>De volgende paar <I>voorbeeld</I>commando's kunnen handig zijn voor
degenen die zich afvragen hoe ze bepaalde software-limieten kunnen
verhogen die door de kernel worden opgelegd:
<PRE>
echo 4096 > /proc/sys/kernel/file-max
echo 12288 > /proc/sys/kernel/inode-max
echo 300 400 500 > /proc/sys/vm/freepages
</PRE>
<H2><A NAME="s9">9. Opmerking voor upgrade naar versie 2.0.x, 2.2.x</A></H2>

<P>Kernel versies 2.0.x en 2.2.x introduceerde heel wat wijzigingen voor de
kernel-installatie.
Het bestand <CODE>Documentation/Changes</CODE> in de 2.0.x source
tree bevat informatie waarmee je bekend zou moeten zijn als je naar 
&eacute;&eacute;n van deze versies gaat upgraden.
Je zult zeer waarschijnlijk verscheidene packages moeten upgraden, zoals
gcc, libc, en SysVInit, en misschien een aantal systeembestanden moeten
wijzigen, dus wees hier op voorbereid. Echter, geen paniek.
<H2><A NAME="s10">10. Modules</A></H2>

<P>Laadbare kernelmodules kunnen geheugen besparen en de configuratie
vergemakkelijken. De strekking van modules
is gegroeid dat het bestandssystemen, ethernetkaartdrivers, tapedrivers, 
printer drivers, en meer bevat.
<H2>10.1 Installeren van de module-utility's</H2>

<P>De module utility's zijn beschikbaar vanwaar je je kernelsource vandaan
hebt gehaald als <CODE>modutils-x.y.z.tar.gz</CODE>; kies het hoogste
patchlevel <CODE>x.y.z</CODE> dat gelijk is of lager dan dat van je huidige
kernel. Pak het uit met `<CODE>tar zxvf modutils-x.y.z.tar.gz</CODE>',
<CODE>cd</CODE> naar de directory, het maakt (<CODE>modutils-x.y.z</CODE>) aan,
bekijk de <CODE>README</CODE>, en voer de installatie-instructies ervan uit
(die meestal erg eenvoudig zijn, zoals <CODE>make install</CODE>). Je
zou nu de programma's <CODE>insmod</CODE>, <CODE>rmmod</CODE>, <CODE>ksyms</CODE>,
<CODE>lsmod</CODE>, <CODE>genksyms</CODE>, <CODE>modprobe</CODE>, en <CODE>depmod</CODE> in
<CODE>/sbin</CODE> moeten hebben.
Test de utility's met de ``hw'' voorbeelddriver in <CODE>insmod</CODE>, als je
dat wilt; bekijk het bestand
<CODE>INSTALL</CODE> in die subdirectory voor details.
<P><CODE>insmod</CODE> voegt een module in, in de draaiende kernel. Modules
hebben meestal een <CODE>.o</CODE> extensie; de voorbeelddriver die hierboven
werd genoemd, heeft de naam 
<CODE>drv_hello.o</CODE>, dus om dit in te voegen, zou men intikken
`<CODE>insmod drv_hello.o</CODE>'. Om te modules te zien die de kernel op
dit moment gebruikt, gebruik je <CODE>lsmod</CODE>. 
De uitvoer ziet er ongeveer zo uit:
<PRE>
    blah# lsmod
    Module:        #pages:  Used by:
    drv_hello          1
</PRE>
<P>`<CODE>drv_hello</CODE>' is de naam van de module, het gebruikt &eacute;&eacute;n
pagina (4k) van het geheugen, en er zijn op dit moment geen 
andere kernelmodules afhankelijk van.
Om deze module te verwijderen, gebruik je `<CODE>rmmod drv_hello</CODE>'. 
Merk op dat <CODE>rmmod</CODE> de 
<I>naam van een module</I> verlangt, geen bestandsnaam; je krijgt dit van de
uitvoer van <CODE>lsmod</CODE>. De strekking van de andere utility's voor de
modules staan in hun manual pages gedocumenteerd.
<H2>10.2 Met de kernel gedistribueerde modules</H2>

<P>Sinds versie 2.0.30, is bijna alles als een laadbare module beschikbaar.
Zorg er eerst voor dat je ze niet in de reguliere kernel configureert, om
ze te gebruiken; dat wil zeggen, beantwoord 't niet met
<CODE>y</CODE> tijdens `<CODE>make config</CODE>'.
Compileer een nieuwe kernel en reboot ermee. <CODE>cd</CODE> dan nogmaals naar
<CODE>/usr/src/linux</CODE>, en doe een `<CODE>make modules</CODE>'. Hiermee
worden alle modules gecompileerd die je niet in de kernelconfiguratie hebt
gespecificeerd, en links ernaar in <CODE>/usr/src/linux/modules</CODE> geplaatst.
Je kunt ze direct vanuit die directory gebruiken of `<CODE>make
modules_install</CODE>' uitvoeren, waarmee ze in
<CODE>/lib/modules/x.y.z</CODE> worden ge&iuml;nstalleerd, hierbij
staat <CODE>x.y.z</CODE> voor de kernelrelease.
<P>Dit kan vooral handig zijn met bestandssystemen. Het kan zijn dat je het
minix of msdos bestandssysteem niet vaak gebruikt.
Als ik bijvoorbeeld een msdos (huiver) diskette trof, zou ik
<CODE>insmod /usr/src/linux/modules/msdos.o</CODE>, en dan
<CODE>rmmod msdos</CODE> als ik klaar ben. Deze procedure bespaart
gedurende de normale bewerking ongeveer 50k RAM in de kernel. 
Een kleine aantekening voor het minix bestandssysteem:
je zou het <I>altijd</I> direct in de kernel moeten configureren, voor
gebruik in ``rescue'' disks.
<H2><A NAME="s11">11. Tips en trucs</A></H2>

<H2>11.1 Doorsturen van uitvoer van de make of patch commando's </H2>

<P>
<P>Als je logs van wat die `<CODE>make</CODE>' of `<CODE>patch</CODE>'
commando's deden, zou willen hebben, kun je de uitvoer naar een bestand 
doorsturen. Zoek als eerste uit onder welke shell je draait:
`<CODE>grep root /etc/passwd</CODE>' en zoek naar iets als
`<CODE>/bin/csh</CODE>'.
<P>Als je sh of bash gebruikt, zal
<PRE>
    (commando) 2>&amp;1 | tee (uitvoerbestand)
</PRE>

een kopie van de uitvoer van <CODE>(commando)</CODE> in het bestand
`<CODE>(uitvoerbestand)</CODE>' plaatsen.
<P>Gebruik voor csh of tcsh,
<PRE>
    (command) |&amp; tee (uitvoerbestand)
</PRE>
<P>Voor rc (Opmerking: je gebruikt rc waarschijnlijk niet) is het
<PRE>
    (command) >[2=1] | tee (uitvoerbestand)
</PRE>
<H2>11.2 Voorwaardelijke kernel-installatie</H2>

<P>Naast het gebruiken van diskettes, zijn er nog verscheidene methoden om een
nieuwe kernel uit te testen zonder de oude kernel aan te roeren. In
tegenstelling tot andere Unix-soorten, heeft LILO de mogelijkheid om een
kernel vanaf iedere plaats op de disk te booten. (als je een grote disk
(500 MB of meer) hebt, lees dan alsjeblieft de LILO-documentatie door over
hoe dit problemen kan veroorzaken).
Dus, als je iets vergelijkbaars als het volgende aan het einde van je
LILO configuratiebestand toevoegt,
<PRE>
    image = /usr/src/linux/arch/i386/boot/bzImage
        label = new_kernel
</PRE>

kun je ervoor kiezen een nieuwe gecompileerde kernel te draaien zonder dat
je je oude <CODE>/vmlinuz</CODE> aanroert (na het draaien van 
<CODE>lilo</CODE>, natuurlijk). De makkelijkste manier om LILO te vertellen dat
het een nieuwe kernel moet booten is om de linker shift-toets tijdens het
opstarten in te drukken,
(als je <CODE>LILO</CODE> op het scherm ziet staan, en niets anders)
waardoor je een prompt krijgt.
Op dit punt kun je `<CODE>nieuwe_kernel</CODE>' opgeven om de nieuwe kernel te
booten.
<P>Als je verscheidene verschillende kernel source-trees tegelijkertijd
op je systeem wilt behouden (dit kan <I>heel veel</I> diskruimte innemen;
wees voorzichtig), is de meest gebruikelijke
manier om ze <CODE>/usr/src/linux-x.y.z</CODE> te noemen, waar
<CODE>x.y.z</CODE> voor de kernelversie staat. Je kunt een sourcetree
dan met een symbolische link ``selecteren''; 
bijvoorbeeld, `<CODE>ln -sf linux-1.2.2
/usr/src/linux</CODE>' zou de 1.2.2 tree de huidige maken. 
Zorg ervoor dat het laatste 
argument van <CODE>ln</CODE> geen echte directory is (oude symbolische links 
zijn prima), voordat je op deze manier een symbolische link maakt; 
het resultaat zal je namelijk anders niet hetgene geven wat je ervan zou 
verwachten.
<H2>11.3 Kernel updates </H2>

<P>Russell Nelson (<CODE>nelson@crynwr.com</CODE>) vat de wijzigingen in
nieuwe kernelreleases samen.
Ze zijn beknopt, en je zou er misschien voor een upgrade naar willen kijken.
Ze zijn beschikbaar via anonieme ftp vanaf
<CODE>ftp.emlist.com</CODE> in <CODE>pub/kchanges</CODE> of via de URL
<PRE>
    http://www.crynwr.com/kchanges
</PRE>
<H2><A NAME="s12">12. Andere relevante HOWTO's die nuttig kunnen zijn</A></H2>

<P>
<UL>
<LI> Sound-HOWTO: geluidskaarten en utility's</LI>
<LI> SCSI-HOWTO: alles over SCSI-controllers en -devices</LI>
<LI> NET-2-HOWTO: netwerk</LI>
<LI> PPP-HOWTO: PPP-netwerken in het bijzonder</LI>
<LI> PCMCIA-HOWTO: over de drivers voor je notebook</LI>
<LI> ELF-HOWTO: ELF: wat het is, het converteren..</LI>
<LI> Hardware-HOWTO: overzicht van ondersteunde hardware</LI>
<LI> Module mini-HOWTO: meer over kernelmodules</LI>
<LI> Kerneld mini-HOWTO: over kerneld</LI>
<LI> BogoMips mini-HOWTO: voor 't geval je 't je af mocht vragen</LI>
</UL>
<H2><A NAME="s13">13. Diversen</A></H2>

<H2>13.1 Auteur</H2>

<P>
<P>De auteur en beheerder van de Linux Kernel-HOWTO is Brian Ward
(<CODE>bri@cs.uchicago.edu</CODE>). Stuur me alsjeblieft je opmerkingen,
aanvullingen, correcties
(Correcties zijn voor mij in het bijzonder het belangrijkst).
<P>Je kunt een kijkje nemen op mijn `home page' op &eacute;&eacute;n 
van deze URL's:
<PRE>
    http://www.math.psu.edu/bri/
    http://blah.math.tu-graz.ac.at/~bri/
</PRE>
<P>Ook al probeer ik zo attent mogelijk te zijn met mail, denk er alsjeblieft
aan dat ik er iedere dag <I>heel veel</I> van krijg, dus het kan even
duren voor ik je antwoord.
Vooral als je me mailt met een vraag, probeer dan alsjeblieft extra je
best te doen in je bericht duidelijk en gedetailleerd te zijn.
Als je me schrijft over niet werkende hardware (of iets dergelijks)
moet ik weten wat je hardwareconfiguratie is.
Als je een fout rapporteert, zeg dan niet slechts
``Ik heb dit geprobeerd, maar het gaf een foutmelding;'' 
Ik moet weten wat de foutmelding was.
Ik zou ook willen weten welke versie van de kernel, gcc, en libc je gebruikt.
Als je me slechts vertelt dat je &eacute;&eacute;n of andere versie van
een bepaalde distributie gebruikt, zal me dat niet veel zeggen.
Het maakt me niet uit als je eenvoudige vragen stelt; denk eraan, als je
niets vraagt, kun je ook nooit een antwoord krijgen!
Ik zou graag iedereen willen bedanken die me feedback heeft gegeven.
<P>Als je vraag niets met de kernel te maken heeft, of in een taal staat die
ik niet begrijp, kan het zijn dat ik niet antwoord.
<P>
<P>Als je me een mail hebt gestuurd en binnen redelijke tijd (drie weken of
meer) geen antwoord hebt gekregen, dan bestaat de kans dat ik je bericht
per ongeluk heb verwijderd of iets van die strekking (sorry). Probeer het
alsjeblieft opnieuw.
<P>Ik krijg erg veel mail over zaken die eigenlijk te maken hebben met
hardware of hardwareproblemen.
Dat is prima, maar probeer er alsjeblieft aan te denken dat ik niet
bekend ben met alle in de wereld te krijgen hardware. 
Ik gebruik AMD processors, Adaptec en Sybios SCSI-controllers, en 
IBM SCSI-disks.
<P>Versie -0.1 werd geschreven op 3 oktober 1994. Dit document is beschikbaar in
SGML, PostScript, TeX, roff, en plain-text formaten.
<H2>13.2 Te doen</H2>

<P>De ``Tips en trucs'' sectie is wat klein. Ik hoop het uit te kunnen
breiden door suggesties van anderen. Zo ook ``Aanvullende packages.''
Meer debugging/crash herstel info nodig.
<H2>13.3 Contributies</H2>

<P>Een klein deel van Linus' README (kernelhacking opties) is inbegrepen.
(Bedankt, Linus!)
<P><CODE>uc@brian.lunetix.de</CODE> (Ulrich Callmeier): patch -s en xargs.
<P><CODE>quinlan@yggdrasil.com</CODE> (Daniel Quinlan): correcties en aanvullingen
in vele secties. 
<P><CODE>nat@nat@nataa.fr.eu.org</CODE> (Nat Makarevitch): mrproper, tar -p, vele
andere zaken
<P><CODE>boldt@math.ucsb.edu</CODE> (Axel Boldt): verzamelde beschrijvingen
van kernelconfiguratie-opties op het net; voorzag me vervolgens in een lijst
<P><CODE>lembark@wrkhors.psyber.com</CODE> (Steve Lembark): multiple boot
suggestie
<P><CODE>kbriggs@earwax.pd.uwa.edu.au</CODE> (Keith Briggs): een aantal correcties
en suggesties
<P><CODE>rmcguire@freenet.columbus.oh.us</CODE> (Ryan McGuire): makeables
aanvullingen
<P><CODE>dumas@excalibur.ibp.fr</CODE> (Eric Dumas): Franse vertaling
<P><CODE>simazaki@ab11.yamanashi.ac.jp</CODE> (Yasutada Shimazaki):
Japanse vertaling
<P><CODE>jjamor@lml.ls.fi.upm.es</CODE> (Juan Jose Amor Iglesias):
Spaanse vertaling
<P><CODE>mva@sbbs.se</CODE> (Martin Wahlen): Zweedse vertaling
<P><CODE>jzp1218@stud.u-szeged.hu</CODE> (Zoltan Vamosi): Hongaarse vertaling
<P><CODE>bart@mat.uni.torun.pl</CODE> (Bartosz Maruszewski): Poolse vertaling
<P><CODE>donahue@tiber.nist.gov</CODE> (Michael J Donahue): typos, winnaar van de
``sliced bread competition''
<P><CODE>rms@gnu.ai.mit.edu</CODE> (Richard Stallman):
``vrije'' documentatie concept/distributie notitie
<P><CODE>dak@Pool.Informatik.RWTH-Aachen.DE</CODE> (David Kastrup): iets over NFS
<P><CODE>esr@snark.thyrsus.com</CODE> (Eric Raymond): diverse juweeltjes
<P>De mensen die me mail zonden met vragen en problemen waren ook 
zeer behulpzaam.
<H2>13.4 Copyright-melding, Licentie en al dat soort zaken</H2>

<P>Copyright &copy; Brian Ward, 1994-1999.
<P>Het is toegestaan kopie&euml;n van deze handleiding te distribueren, op
voorwaarde dat de copyright-melding en deze permissie-melding op alle
kopie&euml;n behouden blijft.
<P>Het is toegestaan gewijzigde versies van deze handleiding te kopie&euml;ren
en te distribueren onder de condities voor letterlijk kopie&euml;ren,
op voorwaarde dat het afgeleide werk onder de voorwaarden van 
een permissie-melding identiek is aan deze vermelding.
Vertalingen vallen onder de categorie ``gewijzigde versies.''
<P>Garantie: Geen.
<P>Aanbevelingen:
Commerci&euml;le herdistributie is toegestaan en wordt aangemoedigd; het wordt
echter sterk aangeraden dat de herdistributeur contact opneemt met de auteur
voor de herdistributie, in het belang van zaken up-to-date te houden 
(je zou me een kopie van hetgeen je aan het maken bent toe kunnen sturen
terwijl je er mee bezig bent). Vertalers
worden ook geadviseerd om contact op te nemen met de auteur voor het vertalen.
De afgedrukte versie ziet er mooier uit. Recycle.
<H2><A NAME="s14">14. Andere formaten van dit document</A></H2>

<P>Deze sectie is geschreven door
<A HREF="mailto:alavoor@yahoo.com">Al Dev</A>
(op de site 
<A HREF="http://www.aldev.8m.com">http://www.aldev.8m.com</A> 
mirrors bij 
<A HREF="http://aldev.webjump.com">http://aldev.webjump.com</A>,
<A HREF="http://www.angelfire.com/country/aldev0">angelfire</A>,
<A HREF="http://www.geocities.com/alavoor/index.html">geocities</A>,
<A HREF="http://aldev0.virtualave.net">virtualave</A>,
<A HREF="http://aldev0.50megs.com">50megs</A>,
<A HREF="http://members.theglobe.com/aldev1/index.html">theglobe</A>,
<A HREF="http://members.nbci.com/alavoor">NBCi</A>,
<A HREF="http://aldev.terrashare.com">Terrashare</A>,
<A HREF="http://members.fortunecity.com/aldev">Fortunecity</A>,
<A HREF="http://aldev.freewebsites.com">Freewebsites</A>,
<A HREF="http://members.tripod.lycos.com/aldev">Tripod</A>,
<A HREF="http://members.spree.com/technology/aldev">Spree</A>,
<A HREF="http://www.escalix.com/freepage/aldev">Escalix</A>,
<A HREF="http://www.httpcity.com/aldev/index.html">Httpcity</A>,
<A HREF="http://aldev.freeservers.com">Freeservers</A>
)
<P>
<P>Dit document is in 12 verschillende formaten geschreven, te weten - DVI, 
Postscript, Latex, Adobe Acrobat PDF, LyX, GNU-info, HTML, 
RTF(Rich Text Format), Plain-text, Unix man pages, een enkel HTML bestand en
SGML.
<UL>
<LI>Je kunt dit HOWTO document als een enkele tarball ophalen in HTML, DVI,
Postscript of SGML formaten vanaf -
<A HREF="ftp://sunsite.unc.edu/pub/Linux/docs/HOWTO/other-formats/">ftp://sunsite.unc.edu/pub/Linux/docs/HOWTO/other-formats/</A>
en 
<A HREF="http://www.linuxdoc.org/docs.html#howto">http://www.linuxdoc.org/docs.html#howto</A></LI>
<LI>Het gewone tekstformaat is te vinden in:
<A HREF="ftp://sunsite.unc.edu/pub/Linux/docs/HOWTO">ftp://sunsite.unc.edu/pub/Linux/docs/HOWTO</A>
en 
<A HREF="http://www.linuxdoc.org/docs.html#howto">http://www.linuxdoc.org/docs.html#howto</A></LI>
<LI>Het enkele HTML bestandsformaat is te vinden in:
<A HREF="http://www.linuxdoc.org/docs.html#howto">http://www.linuxdoc.org/docs.html#howto</A></LI>
<LI>Vertalingen naar andere talen zoals Frans, Duits, Spaans, Chinees,
Japanees zijn te vinden in
<A HREF="ftp://sunsite.unc.edu/pub/Linux/docs/HOWTO">ftp://sunsite.unc.edu/pub/Linux/docs/HOWTO</A>
en 
<A HREF="http://www.linuxdoc.org/docs.html#howto">http://www.linuxdoc.org/docs.html#howto</A>
Elke hulp om naar andere talen te vertalen is welkom.</LI>
</UL>

Het document is geschreven met een tool genaamd "SGML-Tools" wat kan worden
opgehaald vanaf
<A HREF="http://www.sgmltools.org">http://www.sgmltools.org</A>
Voor het compileren van de source gebruik je de volgende opdrachten
<UL>
<LI>sgml2html Kernel-HOWTO.sgml     (voor het genereren van het html bestand)</LI>
<LI>sgml2rtf  Kernel-HOWTO.sgml     (voor het genereren van het RTF bestand)</LI>
<LI>sgml2latex Kernel-HOWTO.sgml    (voor het genereren van het latex bestand)</LI>
</UL>
<P>LaTeX documenten kunnen naar PDF bestand worden geconverteerd door eenvoudigweg
Postscript uitvoer te produceren met behulp van
<B>sgml2latex</B> ( en dvips) en de uitvoer door als volgt de Acrobat
<B>distill</B> (
<A HREF="http://www.adobe.com">http://www.adobe.com</A>) opdracht uit te voeren:
<HR>
<PRE>
bash$ man sgml2latex
bash$ sgml2latex filename.sgml
bash$ man dvips
bash$ dvips -o filename.ps filename.dvi
bash$ distill filename.ps
bash$ man ghostscript
bash$ man ps2pdf
bash$ ps2pdf input.ps output.pdf
bash$ acroread output.pdf &amp;
</PRE>
<HR>

Of je kunt gebruik maken van de Ghostscript opdracht <B>ps2pdf</B>.
ps2pdf is een work-alike voor bijna alle functionaliteit van
Adobe's Acrobat Distiller product: het converteert PostScript bestanden
naar Portable Document Format (PDF) bestanden.
<B>ps2pdf</B> is ge&iuml;mplementeerd als een zeer klein opdrachtscript
(batch file) dat Ghostscript aanroept, waarbij het een speciaal
"output device" genaamd <B>pdfwrite</B> selecteert. 
Voor gebruik van ps2pdf moest het pdfwrite device zijn opgenomen in de
makefile wanneer Ghostscript werd gecompileerd;
zie de documentatie over het bouwen van Ghostscript voor details.
<P>Dit howto document is te vinden op:
<UL>
<LI> 
<A HREF="http://sunsite.unc.edu/LDP/HOWTO/Kernel-HOWTO.html">http://sunsite.unc.edu/LDP/HOWTO/Kernel-HOWTO.html</A></LI>
</UL>
<P>Dit document is ook te vinden op de volgende mirrorsites:
<UL>
<LI> 
<A HREF="http://www.caldera.com/LDP/HOWTO/Kernel-HOWTO.html">http://www.caldera.com/LDP/HOWTO/Kernel-HOWTO.html</A></LI>
<LI> 
<A HREF="http://www.WGS.com/LDP/HOWTO/Kernel-HOWTO.html">http://www.WGS.com/LDP/HOWTO/Kernel-HOWTO.html</A></LI>
<LI> 
<A HREF="http://www.cc.gatech.edu/linux/LDP/HOWTO/Kernel-HOWTO.html">http://www.cc.gatech.edu/linux/LDP/HOWTO/Kernel-HOWTO.html</A></LI>
<LI> 
<A HREF="http://www.redhat.com/linux-info/ldp/HOWTO/Kernel-HOWTO.html">http://www.redhat.com/linux-info/ldp/HOWTO/Kernel-HOWTO.html</A></LI>
<LI> Andere mirrorsites in je buurt (netwerk-adres-wijsheid) zijn te
vinden op
<A HREF="http://sunsite.unc.edu/LDP/hmirrors.html">http://sunsite.unc.edu/LDP/hmirrors.html</A>
selecteer een site en ga naar de directory /LDP/HOWTO/Kernel-HOWTO.html</LI>
</UL>
<P>
<P>Om het document te bekijken in dvi formaat, gebruik je het programma xdvi.
Het programma xdvi is onder RedHat Linux te vinden in het 
tetex-xdvi*.rpm package welke kan worden gelokaliseerd via het menu
ControlPanel | Applications | Publishing | TeX .
Geef de volgende opdracht om het dvi document te lezen
<BLOCKQUOTE><CODE>
<PRE>
        xdvi -geometry 80x90 howto.dvi
        man xdvi
</PRE>
</CODE></BLOCKQUOTE>

En vergroot/verklein het venster met de muis.
Gebruik om te navigeren de Pijltjestoetsen, Page Up, Page Down toetsen,
tevens kun je gebruik maken van de lettertoetsen
'f', 'd', 'u', 'c', 'l', 'r', 'p', 'n' voor respectievelijk
naar boven, naar beneden, centreren, volgende pagina, vorige pagina, enz. 
Druk de 'x' toets in om het expert menu uit te zetten.
<P>Met het programma 'gv' (ghostview) of 'ghostscript' kun je het postscript
bestand lezen. Onder RedHat is het ghostscript programma te vinden in het 
ghostscript*rpm package en het programma gv in het gv*rpm package wat
te vinden is via het menu ControlPanel | Applications | Graphics.
Het programma gv is veel gebruikersvriendelijker dan ghostscript.
Ghostscript en gv zijn ook beschikbaar voor andere platformen, zoals
OS/2, Windows 95 en NT. Je kunt dit document zelfs onder deze platformen
bekijken.
<P>
<UL>
<LI>Ghostscript voor Windows 95, OS/2, en voor alle andere besturingssystemen
is op te halen vanaf 
<A HREF="http://www.cs.wisc.edu/~ghost">http://www.cs.wisc.edu/~ghost</A></LI>
</UL>
<P>Geef de opdracht
<BLOCKQUOTE><CODE>
<PRE>
                gv howto.ps
                ghostscript howto.ps
</PRE>
</CODE></BLOCKQUOTE>

om het postscript document te kunnen lezen.
<P>Met Netscape Navigator, Microsoft Internet explorer, Redhat Baron Web browser
of een van de andere 10 webbrowsers kun je het document in HTML formaat lezen.
<P>De uitvoer van LyX, de latex uitvoer, kun je lezen met LyX, een X-Window 
frontend naar latex.
</BODY>
</HTML>
