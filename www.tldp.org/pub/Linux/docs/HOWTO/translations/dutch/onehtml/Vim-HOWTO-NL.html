<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>Vim Color Editor HOW-TO (Vi Improved met syntax color highlighting) </TITLE>


</HEAD>
<BODY>
<H1>Vim Color Editor HOW-TO (Vi Improved met syntax color highlighting) </H1>

<H2>Al Dev (Alavoor Vasudevan) 
<A HREF="mailto:alavoor@yahoo.com">alavoor@yahoo.com</A><BR>
Vertaald door: Ellen Bokhorst 
<A HREF="mailto:bokkie@nl.linux.org">bokkie@nl.linux.org</A></H2>v5.0, 04 maart 2000
<P><HR>
<EM>Dit document is een leidraad voor het snel instellen van de Vim-kleuren
editor onder Linux- of Unix-systemen. De informatie hierin zal de
productiviteit van een programmeur verhogen aangezien de Vim-editor
ondersteuning biedt voor syntax color highlighting en bold fonts die de
"leesbaarheid" van programmeercode verbetert. De productiviteit van
programmeurs wordt met 2 tot 3 keer verbeterd door gebruik te maken van
een kleureneditor zoals Vim. De informatie in dit document geldt voor alle
besturingssystemen waaronder Vim werkt, dat zijn - Windows 95/NT en alle
soorten Unix zoals Linux, Solaris, HPUX, AIX, SCO, Sinix, BSD, SCO, enz..</EM>
<HR>
<H2><A NAME="s1">1. Introductie</A></H2>

<P>Vim editor staat voor 'Vi IMproved'. Vi is de populairste en krachtigste
editor in de Unix-wereld. De <B>Vi</B> is een afkorting voor
"<I><B>Vi</B></I>sueel" editor. Vroeger was de eerste editor
op deze planeet een regeleditor genaamd 'ed' (en 'ex'). De 
<I><B>Vi</B></I>suele editor zoals Vi was een reusachtige verbetering
in vergelijking met regeleditors als 'ed' (of 'ex'). De editors 'ed' en
'ex' zijn nog steeds beschikbaar onder Linux, zie 'man ed' en 'man ex'.
<P>Een goede editor zal de productiviteit van de
programmeur verbeteren. Vim biedt ondersteuning voor color syntax 
highlighting van programma-code en tevens benadrukking door gebruik te
maken van verschillende fonts als normaal, vet of cursief. 
Een kleureneditor als Vim zal de <B>productiviteit</B> bij het programmeren
met een factor 2 tot 3 verhogen!! Programmeurs kunnen de code veel sneller
lezen aangezien de syntax van de code in kleur en opgelicht wordt weergegeven.
<H2>1.1 Installatie van Vim onder Redhat Linux</H2>

<P>Installeer de volgende RPM-packages om Vim onder Redhat Linux te installeren -
<HR>
<PRE>
        rpm -i vim*.rpm

OF gebruik dit -
        rpm -i vim-enhanced*.rpm
        rpm -i vim-X11*.rpm
        rpm -i vim-common*.rpm
        rpm -i vim-minimal*.rpm
</PRE>
<HR>

Je kan een lijst te zien krijgen van de bestanden die het rpm-package van
vim installeert met - 
<HR>
<PRE>
 
        rpm -qa | grep ^vim | awk '{print "rpm -ql " $1 }' | /bin/sh | less
</PRE>
<HR>

en hier doorheen bladeren met j,k, CTRL+f, CTRL+D, CTRL+B, CTRL+U of door 
gebruik te maken van de pijltjestoetsen, page up/down toetsen.
Zie 'man less'.
<H2>1.2 Installatie van Vim onder GNU Debian Linux</H2>

<P>Voor de installatie van Vim onder Debian Linux (GNU Linux) log je in als
root en wanneer je bent verbonden met het internet type je:
<HR>
<PRE>
apt-get install vim vim-rt
</PRE>
<HR>
<P>Hiermee zal de laatste versie van vim worden gedownload, ge&iuml;nstalleerd
en geconfigureerd en zal het 't .deb bestand dat werd gedowload, worden
verwijderd. Het eerst opgesomde package is vim, de standaard editor, 
gecompileerd met X11-ondersteuning, vim-rt is de vim runtime, het bevat
alle syntax- en helpbestanden.
<H2>1.3 Vim onder diverse Unix-en installeren</H2>

<P>Download voor andere varianten van unix, zoals Solaris, HPUX, AIX, Sinix,
SCO het broncode bestand
<P>
<HR>
<PRE>
 
        zcat vim.tar.gz | tar -xvf -
        cd vim-5.5/src
        ./configure --enable-gui=motif
        make
        make install
</PRE>
<HR>
<H2>1.4 Vim installeren onder Microsoft Windows 95/NT</H2>

<P>Voor Windows 95/NT moet je <B>TWEE</B> zip-bestanden downloaden.
<UL>
<LI> Runtime ondersteuningsbestand <B>vim*rt.zip</B></LI>
<LI> Vim opdrachtenbestand <B>vim*56.zip</B>. Hier is de Vim-versie 5.6</LI>
</UL>

Haald deze twee zipbestanden op vanaf -
<UL>
<LI> De homepage van vim: 
<A HREF="http://www.vim.org">http://www.vim.org</A></LI>
<LI> Een mirror site in US: 
<A HREF="http://www.us.vim.org">http://www.us.vim.org</A></LI>
</UL>

Pak de zip-bestanden uit met behulp van Winzip 
<A HREF="http://www.winzip.com">http://www.winzip.com</A>. Beide zip-bestanden (vim*rt.zip en vim*56.zip) moeten in dezelfde directory,
bv in <B>c:\vim</B> worden uitgepakt.
<P>Stel de omgeving VIM in in autoexec.bat en plaats daarin deze regel -
<HR>
<PRE>
set VIM=c:\vim\vim56
</PRE>
<HR>

Vim zou daarnaar moeten verwijzen daar waar je de vim56 directory installeerde.
Je kunt je PATH ook zo instellen dat het pad naar gvim.exe erin voorkomt.
<P>Mogelijk moet je uitloggen en weer inloggen om je omgeving in te stellen.
Typ achter de MS-DOS prompt -
<HR>
<PRE>
set vim
</PRE>
<HR>

En je zou moeten zien: VIM=c:\vim\vim56
<P>Maakt een snelkoppeling aan op je desktop door te klikken en slepen
vanuit c:\vim\vim56\gvim.exe. Kopieer het bestand gvimrc_example naar
$VIM\_gvimrc. In mijn geval is dit c:\vim\vim56\_gvimrc.
<H2><A NAME="s2">2. Stel de init-bestanden van gvim in</A></H2>

<P>Je MOET het bestand gvimrc naar je homedirectory kopi&euml;ren om
de syntax color highlighting te activeren. 
Hierdoor zal ook het "Syntax" Menu met de gvim-opdracht worden geplaatst.
Je kunt op het Syntax-Menu klikken en de van toepassing zijnde talen
selecteren, zoals C++, Perl, Java, SQL, ESQL enz..
<HR>
<PRE>
cd $HOME
cp /usr/doc/vim-common-5.3/gvimrc_example  ~/.gvimrc
</PRE>
<HR>

Commentaarregels beginnen in .gvimrc met dubbele aanhalingstekens (").
Je kunt gvim aanpassen door het wijzigen van het bestand $HOME/.gvimrc 
en daar de volgende regels in plaatsen - 
<HR>
<PRE>
"Deze regel is commentaar .... &eacute;&eacute;n die met dubbele aanhalingstekens begint
" Het beste is het bold-font, probeer ze allemaal en kies er &eacute;&eacute;n uit....
set guifont=9x15bold
"set guifont=8x13bold
"set guifont=7x14bold
"set guifont=7x13bold
"
"Beslist aan te raden de tabtoetsen op 4 in te stellen.
set tabstop=4
set shiftwidth=4
"Het tegengestelde is 'set wrapscan' bij het zoeken naar strings....
set nowrapscan
"
"Het tegengestelde is noignorecase
set ignorecase
</PRE>
<HR>

Het word je <B>ten zeerste</B> aanbevolen de tabstop en shiftwidth op
4 in te stellen.
<P>De tabstop is het aantal spaties dat door TAB zal worden geplaatst als je
met gvim aan het werken bent. De shiftwidth is het aantal spaties waarmee
de regels zullen worden verschoven bij gebruik van de ">>" of "&lt;&lt;" opdrachten
van vi. Raadpleeg de tutorials van Vi 
<A HREF="#Vim Tutorial">Vim Tutorial</A>
 voor meer details.
<P>Zie de opdracht <B>xlsfonts</B> voor een lijst met beschikbare fonts
onder Linux/Unix. Typ
<HR>
<PRE>
        bash$ xlsfonts | less
        bash$ xlsfonts | grep -i bold | grep x
        bash$ man xlsfonts
</PRE>
<HR>
<H2>2.1 Voorbeeld gvimrc bestand</H2>

<P>Je kunt de instellingen, zoals kleuren, bold/normale fonts in het $HOME/.gvimrc
bestand wijzigen.
Het wordt <B>ten zeerste</B> aanbevolen dat je de achtergrondkleur
op <CODE>lichtgeel</CODE> of <CODE>wit</CODE> met een <CODE>zwarte</CODE> voorgrond
instelt. Ergonomen zeggen dat de beste achtergrondkleur
<CODE>lichtgeel</CODE> of <CODE>wit</CODE> met een zwarte voorgrond is. Wijzig
daarom als volgt de variabele 'guibg':
<HR>
<PRE>
        highlight Normal guibg=lightyellow
</PRE>
<HR>
<P>Het voorbeeld gvimrc vanuit /usr/doc/vim-common-5.3/gvimrc_example luidt
als volgt (vertaalde versie):
<HR>
<PRE>
" Vim
" Een voorbeeld gvimrc bestand.
" De opdrachten hierin worden uitgevoerd wanneer de GUI wordt opgestart.
"
" Kopieer het voor gebruik naar
"     voor Unix en OS/2:  ~/.gvimrc
"            voor Amiga:  s:.gvimrc
"  voor MS-DOS en Win32:  $VIM\_gvimrc

" Zorg dat externe opdrachten via een pipe in plaats van een pseudo-tty werken
"set noguipty

" stel het te gebruiken X11-font in. Zie onder unix/linux 'man xlsfonts'.
" set guifont=-misc-fixed-medium-r-normal--14-130-75-75-c-70-iso8859-1
set guifont=8x13bold
"set guifont=9x15bold
"set guifont=7x14bold
"set guifont=7x13bold
"
"Beslist aan te raden de tabtoetsen op 4 in te stellen.
set tabstop=4
set shiftwidth=4
"Het tegengestelde is 'set wrapscan' bij het zoeken naar strings....
set nowrapscan
"
"Het tegengestelde is noignorecase
set ignorecase

" Stel de opdrachtregel in op 2 regels
set ch=2

" shift-insert werkt net als in Xterm
map &lt;S-Insert> &lt;MiddleMouse>
map! &lt;S-Insert> &lt;MiddleMouse>

" Doe dit alleen voor Vim versie 5.0 en later.
if version >= 500

  " Ik vind 't prettig als strings in C commentaar wordt opgelicht
  let c_comment_strings=1

  " Schakel syntax highlighting in.
  syntax on

" Schakel zoekpatroon highlighting in.
set hlsearch

" Voor Win32 versie, "K" zoekt het sleutelwoord in een helpbestand
"if has("win32")
"  let winhelpfile='windows.hlp'
"  map K :execute "!start winhlp32 -k &lt;cword> " . winhelpfile &lt;CR>
"endif

" Verberg de muisaanwijzer tijdens het typen
set mousehide

" Stel fraaie kleuren in
" achtergrond voor normale tekst is lichtgrijs
" Tekst onder de laatste regel is donkergrijs
" Cursor is groen
" Constanten worden niet onderstreept maar hebben een iets lichtere achtergrond
  highlight Normal guibg=grey90
  highlight Cursor guibg=Green guifg=NONE
  highlight NonText guibg=grey80
  highlight Constant gui=NONE guibg=grey95
  highlight Special gui=NONE guibg=grey95

endif
</PRE>
<HR>

Zie ook het voorbeelbestand vimrc in /usr/doc/vim-common-5.3/vimrc_example dat
voor onder de console wordt gebruikt 
<H2>2.2 Xdefaults parameters</H2>

<P>Je kunt een aantal eigenschappen van Vim in het bestand Xdefaults plaatsen.
<P><B> WAARSCHUWING!! WAARSCHUWING: </B>Plaats hierin niet de
<B>Vim*geometry</B>; het zal het menu van gvim opbreken, gebruik hier
voor in de plaats <B>Vim.geometry</B>. 
<P>Wijzig het bestand $HOME/.Xdefaults en plaats hierin de volgende regels:
<HR>
<PRE>
! GVim great Colors.
Vim*useSchemes:         all
Vim*sgiMode:            true
Vim*useEnhancedFSB:     true
Vim.foreground:         Black
!Vim.background:        lightyellow2
Vim*background:         white
! Gebruik GEEN Vim*geometry, dit zal de menu's opbreken, gebruik in plaats
! daarvan Vim.geometry. Een asteriks tussen Vim en geometry is niet toegestaan.
! Vim.geometry: widthxheight
Vim.geometry:           88x40
!Vim*font:              -misc-fixed-medium-r-normal--20-200-75-75-c-100-iso8859-15-*5
Vim*menuBackground: yellow
Vim*menuForeground: black
</PRE>
<HR>

Dit heeft effect na het intikken van -
<HR>
<PRE>
        xrdb -merge $HOME/.Xdefaults
        man xrdb
</PRE>
<HR>
<P>Je kunt ook het bestand ~/.gvimrc wijzigen om de achtergrondkleuren te veranderen.
<HR>
<PRE>
        gvim $HOME/.gvimrc
De beste achtergrondkleur is lichtgeel of wit.
highlight Normal guibg=lightyellow
</PRE>
<HR>
<H2><A NAME="s3">3. Kleuren Syntax init bestanden</A></H2>

<P>In plaats van gebruik te maken van het "Syntax" menu kun je 
het syntax-bestand ook handmatig bewerken.
Wijzig het bestand met gvim   
en achter de : (dubbele punt) opdracht geef je de 'so' opdracht. Bijvoorbeeld -
<HR>
<PRE>
        gvim foo.pc
        :so $VIM/syntax/esqlc.vim
</PRE>
<HR>

De syntax source-bestanden staan in /usr/share/vim/syntax/*.vim. 
Vim ondersteunt meer dan 120 verschillende syntax-bestanden voor verschillende
talen zoals C++, PERL, VHDL, Javascript,... enzovoort!!
<P>Ieder syntaxbestand ondersteunt een standaardnaam voor de bestandsextensie,
het syntaxbestand voor Javascript bijvoorbeeld, ondersteunt de extensie *.js.
Mocht het je gebeuren dat je een andere extensie gebruikt die een conflict
veroorzaakt met een ander standaard syntaxbestand zoals bij het plaatsen
van Javascript in een *.html bestand, dan MOET je de opdracht
:so $VIM/syntax/javascript.vim gebruiken. De beste methode is een softlink
aan te maken zoals
<HR>
<PRE>
ln -s $VIM/syntax/javascript.vim js
gvim foo.html (... dit bestand bevat javascript functies en HTML)
:so js
</PRE>
<HR>
<H2><A NAME="s4">4. VIM Gebruik</A></H2>

<P>Je kunt Vim in twee modi gebruiken - &eacute;&eacute;n met GUI en
de andere zonder GUI. Om de GUI te gebruiken geef je de volgende opdracht -
<HR>
<PRE>
        gvim foo.cpp
</PRE>
<HR>

Om de niet-gui modus te gebruiken tik je in -
<HR>
<PRE>
        vim foo.cpp
OF plain vanilla modus
        vi foo.cpp
</PRE>
<HR>

Het is ten zeerste aan te raden dat je altijd gebruik maakt van gvim
in plaats van vim, aangezien de GUI mode met kleuren je productiviteit
beslist zal verbeteren.
<P>De GUI mode voorziet in het volgende -
<UL>
<LI> Je kunt de tekst met de muis markeren om te knippen, kopi&euml;ren,
en plakken.</LI>
<LI> Je kunt de Menubalk met de File, Edit, Window, Tools, Syntax en
Help knoppen items gebruiken.</LI>
<LI> In de nabije toekomst van gvim zal een tweede menubalk de lijst
met de te wijzigen bestanden tonen, en kun je tussen bestanden schakelen
door op de bestandsnamen te klikken, tot dan kun je gebruik maken van de
vi-opdrachten -:e#, :e#1, :e#3, :#4, ...enzovoort om de bestanden te
selecteren.</LI>
</UL>
<H2><A NAME="s5">5. Vi bondgenoten</A></H2>

<P>In het algemeen wordt Vim in samenwerking met andere krachtige tools zoals
<B>ctags</B> en <B>gdb</B> gebruikt. De <B>ctags</B> is voor zeer
snelle navigatie door miljoenen regels "C/C++" code en <B>gdb</B>
voor het debuggen van de "C/C++" code. Een beknopte introductie van deze
twee onmisbare opdrachten zal in dit hoofdstuk worden gegeven.
<P>De <B>ctags</B> is de krachtigste beschikbare opdracht voor het coderen
in C, C++, Java, Perl, Korn/Bourne shell scripts of Fortran. Ontwikkelaars
gebruiken <B>ctags</B> zeer uitgebreid om "naar en vanuit" duizende functies
C/C++ programma's te navigeren. Zie onder Unix 'man ctags'. Het is 
<B>zeer belangrijk</B> dat je MOET leren hoe deze ctags te gebruiken om
programma's in C of C++, Java, enz.. te ontwikkelen. Navigatie is de 
belangrijkste taak tijdens het ontwikkelen in C of C++ code. Met behulp van
ctags kun je de code zeer snel lezen door te springen van de aanroepende
regel naar de functie en dieper in geneste functie-aanroepen gaan en naar
het begin teruggaan. Je kunt zeer snel heen en weer van functie naar
functie gaan.
<P>Zonder NAVIGATIE zal je waarschijnlijk verloren zijn! <B>ctags</B> is als
de magnetische KOMPAS naald voor de programmeurs.
<P>Gebruik van <B>ctags</B> : 
<HR>
<PRE>
        ctags *.cpp
        gvim -t foo_function
        gvim -t main
</PRE>
<HR>

Hiermee zal het C++ programmabestand met daarin de functie foo_funtion()
worden gewijzigd en zal de cursor automatisch op de eerste regel van de
funtie foo_funtion() worden geplaatst.
De tweede opdracht brengt je naar de regel met de main() functie
definitie.
<P>Binnen de Vim editor, kun je naar een functie springen door het intikken van
een : (dubbele punt) tag
&lt; functie naam &gt; als hieronder -
<HR>
<PRE>
        :tag voorbeeld_functie
</PRE>
<HR>

Hiermee zal de cursor op de eerste regel van voorbeeld_functie() worden
geplaatst.
<P>Als je binnen de functie naar een regel met de naam van de functie wilt
springen, plaats je de cursor direct voor de naam van de functie en druk
je op <B>CTRL+]</B> (druk tegelijkertijd op de control-toets en linker
blokhaak), hierdoor zal je automatisch direct rechts van de regel 
terechtkomen waar de functie begint!!
<HR>
<PRE>
                // voorbeeldcode
                switch(id_number) {
                        Case 1:
                                if ( foo_function( 22, "abcef") == 3 )
                                    ^
                                    |
                                    |
                                    |
                  Plaats de cursor hier (direct voor foo_function) en druk op CTRL+]
                  Hierdoor zal je naar de functie met de naam "foo_function" gaan. 
                  Druk op CTRL+t om naar deze regel terug te keren.
</PRE>
<HR>

Druk op <B>CTRL+t</B> (Control-toets en letter 't' samen) om terug te gaan
naar de aanroepende regel.
Je blijft de <B>CTRL+t</B> indrukken om terug te gaan en naar de
eerste regel te gaan vanwaar je de navigatie begon.
Dat wil zeggen dat je de
<B>CTRL+]</B> in kan blijven drukken en dan de <B>CTRL+t</B> om terug
te gaan. Je kunt dit zovaak herhalen als je wilt voor volledige navigatie
door de C of C++ functies.
<H2>5.1 Ctags voor ESQL</H2>

<P>Aangezien ctags de Embedded SQL/C (ESQL) taal niet direct ondersteunt, kan
het volgende script worden gebruikt om tags voor esql aan te maken.
ESQL/C zijn database SQL opdrachten embedded binnen de "C" programma's.
Oracle's ESQL/C wordt Pro*C genoemd en Sybase, Informix heeft ESQL/C en
PostgreSQL heeft het produkt "ecpg".
<P>Bewaar dit bestand als "sqltags.sh" en pas een a+rx tags_gen.sh toe.
<HR>
<PRE>
#!/bin/sh

# Programma om ctags voor ESQL, C++ en C bestanden aan te maken
ESQL_EXTN=pc
tag_file1=tags_file.1
tag_file2=tags_file.2

which_tag=ctags

rm -f $tag_file1 $tag_file2 tags

aa=`ls *.$ESQL_EXTN`
#echo $aa
for ii in $aa 
do
        #echo $ii
        jj=`echo $ii | cut -d'.' -f1`
        #echo $jj

        if [ ! -f $jj.cpp ]; then
                echo " "
                echo " "
                echo "***********************************************"
                echo "ESQL *.cpp bestanden bestaan niet.. "
                echo "Je moet de *.cpp vanuit het *.pc bestand genereren"
                echo "met behulp van de Oracle Pro*C pre-compiler of Sybase"
                echo "of Informix esql/c pre-compiler."
                echo "En vervolgens deze opdracht weer opnieuw uitvoeren"
                echo "***********************************************"
                echo " "
                exit
        fi

        rm -f tags
        $which_tag $jj.cpp
        kk=s/$jj\.cpp/$jj\.pc/g

        #echo $kk > sed.tmp
        #sed -f sed.tmp tags >> $tag_file1

        #sed -e's/sample\.cpp/sample\.pc/g' tags >> $tag_file1
        sed -e $kk tags >> $tag_file1
done

# Handel nu alle C++/C bestanden af - sluit de ESQL *.cpp bestanden uit
rm -f tags $tag_file2
bb=`ls *.cpp *.c`
aa=`ls *.$ESQL_EXTN`
for mm in $bb 
do
        ee=`echo $mm | cut -d'.' -f1`
        file_type="NOT_ESQL"
        # Sluit de ESQL *.cpp en *.c bestanden uit
        for nn in $aa 
        do
                dd=`echo $nn | cut -d'.' -f1`
                if [ "$dd" = "$ee" ]; then
                        file_type="ESQL"
                        break
                fi
        done

        if [ "$file_type" = "ESQL" ]; then
                continue
        fi

        rm -f tags
        $which_tag $mm
        cat tags >> $tag_file2
done

mv -f $tag_file2 tags
cat  $tag_file1 >> tags
rm -f $tag_file1

# Moet tags bestand sorteren wil het juist werken ....
sort tags > $tag_file1
mv $tag_file1 tags
</PRE>
<HR>
<H2>5.2 Ctags voor Javascript programma's, Korn, Bourne shells</H2>

<P>Het hieronder gegeven shell-script kan worden gebruikt om tags voor een
zeer grote vari&euml;teit aan programma's geschreven in 
variety of programs written in JavasScript, PHP/FI scripts, Korn shell,
C shell, Bourne shell en vele anderen te genereren. Dit is een zeer algemene
module.
<P>Bewaar dit bestand als tags_gen.sh en pas een chmod a+rx tags_gen.sh toe.
<HR>
<PRE>
#!/bin/sh

tmp_tag=tags_file
tmp_tag2=tags_file2

echo " "
echo " "
echo " "
echo " "
echo " "
echo "Genereer tags voor ...."
while :
do
        echo "    Voer de bestandsextensie in waarvoor je tags wilt genereren."
        echo -n "  Bestandsextensie zou iets moeten zijn als sh, js, ksh, enz... : "
        read ans

        if [ "$ans" == "" ]; then
                echo " "
                echo "Onjuiste invoer. Probeer opnieuw!"
        else
                break
        fi
done

\rm -f $tmp_tag

aa=`ls *.$ans`

for ii in $aa
do
        jj=`echo $ii | cut -d'.' -f1`
        #echo $jj
        cp $ii $jj.c
        ctags $jj.c
        echo "s/$jj.c/$ii/g" > $tmp_tag2
        sed -f $tmp_tag2 tags >> $tmp_tag
        \rm -f tags $jj.c
done

sort $tmp_tag > tags

\rm -f $tmp_tag $tmp_tag2
</PRE>
<HR>
<H2>5.3 Debugger gdb</H2>

<P>Je zou samen met Vi uitgebreid gebruik moeten maken van gdb.
Debuggen is het belangrijkste aspect van programmeren
aangezien de belangrijkste kosten van een softwareproject in het debuggen
en testen gaan zitten.
<P>Gebruik de too 'gdb' voor het debuggen van C++/C programma's. Zie
<B>'man gdb'</B>.
Je moet je programma's met de optie -g3 compileren als
<BLOCKQUOTE><CODE>
<PRE>
        gcc -g3 foo.c foo_another.c sample.c
</PRE>
</CODE></BLOCKQUOTE>
<P>Voor het eenvoudig instellen van aliassen -
<BLOCKQUOTE><CODE>
<PRE>
  Stel een alias in in je ~/.bash_profile
        alias gdb='gdb -directory=/home/src -directory=/usr/myname/src '
  Give -
        gdb foo.cpp
        gdb> dir /hom2/another_src
        Dit zal aan het bestandszoekpad worden toegevoegd
        gdb> break 'some_class::func&lt;TAB>&lt;TAB>
  Hiermee zal de functienaam worden aangevuld om je tijd te sparen bij het typen... en zal uitvoer produceren als -
        gdb> break 'some_class::function_foo_some_where(int aa, float bb)'
</PRE>
</CODE></BLOCKQUOTE>
<P>Het tweemaal indrukken van de TAB-toets is de voltooi&iuml;ng van de
opdrachtregel, wat je heel veel tijd zal besparen bij het typen.
Dit is &eacute;&eacute;n van de belangrijkste technieken bij het gebruik van
gdb.
<P>Voor online hulp -
<BLOCKQUOTE><CODE>
<PRE>
        gdb> help
  Geeft online hulp
        gdb> help breakpoints
  Geeft meer details over breakpoints.
</PRE>
</CODE></BLOCKQUOTE>
<P>Het instellen van breakpoints en het debuggen
<BLOCKQUOTE><CODE>
<PRE>
        unixprompt> gdb exe_filename 
        gdb> b main
Hiermee zal een breakpoint in de main() functie worden geplaatst
        gdb> b 123
Hiermee zal een breakpoint in regel 123 van het huidige bestand worden geplaatst.
        gdb> help breakpoints
Geeft meer details over breakpoints.
</PRE>
</CODE></BLOCKQUOTE>
<P>Voor het analyseren van de core dumps 
<BLOCKQUOTE><CODE>
<PRE>
        unixprompt> gdb exe_filename  core
        gdb> bt
  Geeft backtrace van functies en regelnummers waar het programma in gebreke bleef
        gdb> help backtrace
  Geeft meer details over backtrace.
</PRE>
</CODE></BLOCKQUOTE>
<P>Je kunt ook de GUI-versie van gdb, genaamd xxgdb gebruiken.
<P>Memory leak tools - 
<UL>
<LI> Freeware Electric Fence on linux cd, </LI>
<LI> Commercial tools Purify 
<A HREF="http://www.rational.com">http://www.rational.com</A> </LI>
<LI> Insure++ 
<A HREF="http://www.insure.com">http://www.insure.com</A></LI>
</UL>
<H2><A NAME="s6">6. Online VIM help</A></H2>

<P>Zie de online man pages. Typ achter de unix shell-prompt <B>man vim</B> en 
<B>man gvim</B>.
<P>Of in de gvim sessie tik je :help in voor de helppagina. Zie ook de
<A HREF="#Vim Tutorial">Vim Tutorial</A>
Vim Tutiorial.
<P>
<BLOCKQUOTE><CODE>
<PRE>
                        VIM - hoofd helpbestand

     Manoeuvreren:  Gebruik de cursortoetsen, of "h" om naar links te gaan,
                    "j" om naar beneden te gaan, "k" om naar boven te gaan,
                    "l" om naar rechts te gaan.
                    ":1" ga naar 1e regel van pagina
                    ":n" ga naar de n-de regel van pagina
                    "&lt;SHIFT>g" ga naar de onderkant van pagina
                    ":/eenwoord/ zoek naar "eenwoord" in doc

Sluit dit venster:  Gebruik ":q&lt;Enter>".

Ga naar onderwerp:  Positioneer de cursor op een tag tussen |&lt;tag>| en druk op
                    CTRL-].

      Met de muis:  ":set mouse=a" om de muis te activeren (in xterm of GUI).
                    Dubbelklik met de linkermuisknop op een tag tussen |&lt;tag>|.

         ga terug:  Typ CTRL-T of CTRL-O.

  Specifieke hulp:  Het is mogelijk direct naar een bepaald hulponderwerp
                    te gaan, door een argument aan de ":help" opdracht
                    |:help| op te geven.
                    Het is mogelijk de context verder te specificeren:
                          WAT                   ERVOOR     VOORBEELD    ~
                    Normale modus opdrachten    (niets)    :help x
                    Visual modus opdrachten       v_       :help v_u
                    Insert modus opdrachten       i_       :help i_&lt;Esc>
                    command-line opdrachten       :        :help :quit
                    command-line editing          c_       :help c_&lt;Del>
                    Vim opdrachtargumenten        -        :help -r
                    opties                        '        :help 'textwidth'

lijst met documentatie-bestanden:

|howto.txt|     hoe het meest algemene te doen
|intro.txt|     introductie Vim
|index.txt|     alfabetische index voor iedere mode
|autocmd.txt|   automatisch uitvoeren van opdrachten bij een actie
|change.txt|    verwijderen en vervangen van tekst
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="s7">7. Vim Home page en Vim links</A></H2>

<P>De homepage van vim is te vinden bij 
<A HREF="http://www.vim.org">http://www.vim.org</A> 
en de mirror-site in de US 
<A HREF="http://www.us.vim.org">http://www.us.vim.org</A> 
<P>Vim FAQ is bij 
<A HREF="http://www.grafnetix.com/~laurent/vim/faq.html">http://www.grafnetix.com/~laurent/vim/faq.html</A>
en bij 
<A HREF="http://www.vim.org/faq">http://www.vim.org/faq</A><P>Eli's Vim Page op 
<A HREF="http://www.netusa.net/~eli/src/vim.html">http://www.netusa.net/~eli/src/vim.html</A><P>De Vi Lovers Home Page 
<A HREF="http://www.cs.vu.nl/~tmgil/vi.html">http://www.cs.vu.nl/~tmgil/vi.html</A><P>Vim Reference Guide op 
<A HREF="http://scisun.sci.ccny.cuny.edu/~olrcc/vim/">http://scisun.sci.ccny.cuny.edu/~olrcc/vim/</A><P>Vim mailing list op 
<A HREF="http://www.findmail.com/listsaver/vimannounce.html">http://www.findmail.com/listsaver/vimannounce.html</A>
en 
<A HREF="http://www.vim.org/mail.html">http://www.vim.org/mail.html</A><P>Mailing list archieven worden bewaard op: 
<UL>
<LI> 
<A HREF="http://www.egroups.com/group/vim">http://www.egroups.com/group/vim</A></LI>
<LI> 
<A HREF="http://www.egroups.com/group/vimdev">http://www.egroups.com/group/vimdev</A></LI>
<LI> 
<A HREF="http://www.egroups.com/group/vimannounce">http://www.egroups.com/group/vimannounce</A></LI>
</UL>
<P>Vim macro's 
<A HREF="http://www.grafnetix.com/~laurent/vim/macros.html">http://www.grafnetix.com/~laurent/vim/macros.html</A><H2><A NAME="Vim Tutorial"></A> <A NAME="s8">8. Vim Tutorial </A></H2>

<H2><A NAME="vimhandson"></A> 8.1 Vim Hands-on Tutorial </H2>

<P>Kijk voor de tutorial op een Linux-systeem in /usr/doc/vim-common-5.*/tutor, 
ga onder andere unix-systemen naar de directory waarin vim is ge&iuml;nstalleerd
en zoek naar de doc directory.
<HR>
<PRE>
        bash$ cd /usr/doc/vim-common*/tutor
        bash$ less README.txt
        bash$ cp tutor $HOME
        bash$ cd $HOME
        bash$ less tutor
</PRE>
<HR>
<H2><A NAME="vimurls"></A> 8.2 Vi Tutorials op het Internet</H2>

<P>
<UL>
<LI> Purdue University 
<A HREF="http://ecn.www.ecn.purdue.edu/ECN/Documents/VI/">http://ecn.www.ecn.purdue.edu/ECN/Documents/VI/</A></LI>
<LI> 
Quick Vi tutorial 
<A HREF="http://linuxwww.db.erau.edu/LUG/node165.html">http://linuxwww.db.erau.edu/LUG/node165.html</A></LI>
<LI> Advanced Vi tutorial 
<A HREF="http://www.yggdrasil.com/bible/bible-src/user-alpha-4/guide/node171.html">http://www.yggdrasil.com/bible/bible-src/user-alpha-4/guide/node171.html</A></LI>
<LI> Tutorials 
<A HREF="http://www.cfm.brown.edu/Unixhelp/vi_.html">http://www.cfm.brown.edu/Unixhelp/vi_.html</A></LI>
<LI> 
Tutorials 
<A HREF="http://www.linuxbox.com/~taylor/4ltrwrd/section3_4.html">http://www.linuxbox.com/~taylor/4ltrwrd/section3_4.html</A></LI>
<LI> Unix world online vi tutorial 
<A HREF="http://www.networkcomputing.com/unixworld/unixhome.html">http://www.networkcomputing.com/unixworld/unixhome.html</A></LI>
<LI> 
Univ of Hawaii tutorial 
<A HREF="http://www.eng.hawaii.edu/Tutor/vi.html">http://www.eng.hawaii.edu/Tutor/vi.html</A></LI>
<LI> InfoBound  
<A HREF="http://www.infobound.com/vi.html">http://www.infobound.com/vi.html</A></LI>
<LI> Cornell Univ 
<A HREF="http://www.tc.cornell.edu/Edu/Tutor/Basics/vi/">http://www.tc.cornell.edu/Edu/Tutor/Basics/vi/</A></LI>
<LI> Vi Lovers home page: 
<A HREF="http://www.cs.vu.nl/~tmgil/vi.html">http://www.cs.vu.nl/~tmgil/vi.html</A></LI>
<LI> Zal na Sept 2000, verplaatst worden naar 
<A HREF="http://www.thomer.com/thomer/vi/vi.html">http://www.thomer.com/thomer/vi/vi.html</A></LI>
<LI> Beginner's Guide to vi 
<A HREF="http://www.cs.umr.edu/unixinfo/general/packages/viguide.html">http://www.cs.umr.edu/unixinfo/general/packages/viguide.html</A></LI>
<LI> vi Help file 
<A HREF="http://www.vmunix.com/~gabor/vi.html">http://www.vmunix.com/~gabor/vi.html</A></LI>
<LI> vim FAQ 
<A HREF="http://www.math.fu-berlin.de/~guckes/vim/faq/">http://www.math.fu-berlin.de/~guckes/vim/faq/</A>
Er bestaan vele Vi Tutorials op het internet. 
Tik bij Yahoo (Lycos, excite of Hotbot) 
"Vi Tutorial" in het zoekveld en de zoekmachine zal vele verwijzingen 
retourneren.</LI>
</UL>
<H2><A NAME="vimtut"></A> <A NAME="s9">9. Vi Tutorial </A></H2>

<P>In deze tutorial beschrijven we een aantal "gevorderde" <B>vi</B> 
concepten en opdrachten, zodat je de kracht van <B>vi</B> 
kunt leren waarderen en dus beslissen hoe je je kennis van 
<B>vi</B> opdrachten kunt uitbreiden. 
Bijna alle <B>vi</B> referenties sommen de beschikbare opdrachten op,
maar veel gaan er niet op in hoe de opdrachten 
met elkaar in verband staan; dit onderwerp is het hoofddoel van deze tutorial.
<H2>9.1 Cursor verplaatsingsopdrachten</H2>

<P>De <B>vi</B> cursorverplaatsingsopdrachten maken het mogelijk de
cursor met een minimum aantal toetsaanslagen effici&euml;nt in het bestand
en/of op het scherm te positioneren.
Er zijn heel veel cursorverplaatsingsopdrachten - probeer ze niet allemaal
tegelijkertijd te onthouden!
Later zullen we zien dat veel van de kracht van <B>vi</B> 
komt door het mixen van cursorverplaatsingsopdrachten met andere opdrachten
om tekst te verwijderen, wijzigen, yanken (kopi&euml;ren), en filteren.
<P>Wijzig alsjeblieft een groot tekstbestand (zoals bijvoorbeeld <B>wknight</B>)
zodat je met iedere opdracht kunt experimenteren op 't moment dat 't wordt
beschreven. Houd in gedachten dat deze opdrachten alleen in de Commando-modus
werken, niet in de Insert Modus; als je "opdrachten" in je tekst krijgt, druk
dan op de ESC-toets om naar de Commando-modus terug te keren.
<P>
<UL>
<LI> <B>cursortoetsen</B> : Zoals we hebben gezien, kunnen we met
de cursorpijlen een enkel teken naar links, beneden, boven en rechts
opschuiven. Verplaatsing voorbij de bovenkant, de
onderkant, rechts van het einde van een regel, of links van het begin van
een regel van het bestand is niet toegestaan (geen regelomslag).</LI>
<LI> <B>hjkl</B> : Toen <B>vi</B> werd geschreven (rond 1978), hadden
veel terminals op UNIX-systemen geen cursortoetsen!
<B>h, j, k,</B> en <B>l</B> werden gekozen als opdrachten
om respectievelijk naar links, beneden, boven, en naar rechts te gaan.
Probeer ze uit! De meeste <B>vi</B> fanaten geven de voorkeur aan deze
cursortoetsen omdat
<UL>
<LI><B>(a)</B> ze op alle toetsenborden op dezelfde plaats voorkomen, en</LI>
<LI><B>(b)</B> ze prettig onder de vingers passen, in tegenstelling tot
de meeste cursortoetsen, die in een box of "T" of 
&eacute;&eacute;n of andere niet lineaire vorm zijn gearrangeerd.</LI>
</UL>


Waarom h, j, k, en l? In de ASCII character set, staat CTRL-H voor de
backspace (verplaatsing naar links), CTRL-J voor linefeed (verplaatsing naar
beneden), en, k en l bevinden zich direct naast h en j, dus zoals je kunt
zien zijn ze makkelijk te onthouden.</LI>
<LI> <B>0</B> : ("nul", niet "oh") Ga naar het begin van de huidige
regel. (gebruik de cursortoetsen of <B>h j k l</B> om naar een
ingesprongen tekstregel met een paar "e" tekens erin te gaan, om dit en
de volgende paar opdrachten uit te proberen.
Als je geen ingesprongen regel in je bestand kunt vinden, maak er dan 
&eacute;&eacute;n aan door een paar spaties aan het begin van een regel
in te voegen).</LI>
<LI> <B> ^ </B> : Ga naar het eerste niet-blanco teken van de huidige
regel. (Voor een ingesprongen regel, hebben 0 en ^ een verschillende 
betekenis).</LI>
<LI> <B> $ </B> : Ga naar het laatste teken van de huidige regel.</LI>
<LI> <B> tC </B> : Ga naar (vlak ervoor) het volgende teken c in
de huidige regel. (Druk op 0, en tik dan `te' in.
Hiermee zal naar de eerste `e' in de huidige regel worden gegaan).</LI>
<LI> <B> fC </B> : Zoek naar (plaatst cursor onder teken) volgende 
teken `c' in de huidige regel. (Tik `fe' in, en de cursor zal de volgende
`e' vinden - dat wil zeggen, verplaatst worden naar - de volgende `e' in de 
huidige regel).</LI>
<LI> <B> TC </B> : Ga naar (direct erachter) het vorige teken c
in de huidige regel (Druk op $, dan Te).</LI>
<LI> <B> FC </B> : Zoek (plaatst cursor onder teken) het vorige teken c
in de huidige regel. (Druk op Fe.)</LI>
<LI> <B> n| </B> : Ga naar kolom n in de huidige regel. 
(Probeer 20 |. De cijfers 2 en 0 zullen, als je ze intikt, niet worden 
getoond, maar als je de | intikt, zal de cursor naar kolom 20 gaan).

Probeer wat met t f T F | te experimenteren. Als je iets niet goed doet, zal
<B>vi</B> een beep genereren.</LI>
<LI> <B> w </B> : Voorwaarts naar het begin van het volgende "kleine"
woord (een "klein" woord bestaat uit een onafgebroken reeks alfanumerieke
tekens of leestekens, maar niet gemengd alfanumeriek en leestekens). Probeer
een aantal keren de w - merk op wat er gebeurt bij een leesteken.</LI>
<LI> <B> W </B> : Voorwaarts naar het begin van het volgende "grote"
woord (gemengd alfanumeriek en leestekens). Probeer een aantal dozijn maal
de W.</LI>
<LI> <B> b </B> : Terugwaarts naar het begin van een "klein" woord.</LI>
<LI> <B> B </B> : Terugwaarts naar het begin van een "groot" woord.</LI>
<LI> <B> e </B> : Voorwaarts naar het einde van een "klein" woord.</LI>
<LI> <B> E </B> : Voorwaarts naar het einde van een "groot" woord.</LI>
<LI> <B> + Return </B> : Ga naar het eerste niet-blanco teken op de
volgende regel. (+ en de Return toets hebben hetzelfde effect).</LI>
<LI> <B> - </B> : Ga naar het eerste niet-blanco teken op de vorige regel.</LI>
<LI> <B> ) </B> : Ga naar het einde van de zin. (Een zin eindigt of met
een lege regel of met een punt of een uitroepteken gevolgd door twee
spaties of op het einde van een regel.
Een punt of uitroepteken gevolgd door een spatie betekent niet het einde
van een zin; dit gedrag is juist, overeenkomstig traditionele regels van hoe
zinnen in getypte documenten zouden moeten verschijnen, maar lijkt vaak
onjuist voor degenen die nooit typeles hebben gehad).</LI>
<LI> <B> ( </B> : Ga naar het begin van de zin.</LI>
<LI> <B> } </B> : Ga naar het einde van de paragraaf. 
(Paragrafen worden gescheiden door lege regels, volgens de definitie van
<B>vi</B>).</LI>
<LI> <B> { </B> : Ga naar het begin van de paragraaf.</LI>
<LI> <B> H </B> : Ga naar de home-positie (bovenste regel) op het scherm.</LI>
<LI> <B> M </B> : Ga naar de middelste regel op het scherm.</LI>
<LI> <B> L </B> : Ga naar de laatste regel op het scherm.</LI>
<LI> <B> nG </B> : Ga naar regel n. Als n niet wordt opgegeven, ga
dan naar de laatste regel in het bestand.
(Probeer bijvoorbeeld 15G om naar regel 15 te gaan. De CTRL-G opdracht toont
de naam van het bestand, wat statusinformatie en het huidige regelnummer.
Om naar het begin van het bestand te gaan: 1G)</LI>
<LI> <B> CTRL-d </B> : Scroll een half scherm omlaag (zie noot).</LI>
<LI> <B> CTRL-u </B> : Scroll een half scherm omhoog (zie noot).</LI>
<LI> <B> CTRL-f </B> : Ga een scherm verder (zie noot).</LI>
<LI> <B> CTRL-b </B> : Ga een scherm terug (zie noot).</LI>
<LI> <B> Noot </B> : Deze vier scrolling/paging opdrachten kunnen niet met
de verwijder-, wijzigings-, kopieer- of filteropdrachten worden gebruikt.</LI>
<LI> <B> /reg_exp </B> : Ga naar het volgende voorkomen van de
reguliere expressie reg_exp.
Als je de / intikt, wordt de cursor naar de linkeronderkant van het scherm
geplaatst en wacht totdat je de reguliere expressie typt.
Druk op de Return toets om de invoer te bevestigen; <B>vi</B> zoekt dan
in voorwaartse richting naar het volgende voorkomen van de reguliere
expressie. 
Bijvoorbeeld, tik in /de gevolgd door een druk op de Return. Hiermee wordt
naar het volgende voorkomen van `de' gegaan, misschien onderdeel uitmakend
van een wat langer woord (ander, weder, enz.). Als je de / intikt,
gevolgd door de Return, zoekt <B>vi</B> naar de laatst opgegeven reguliere
expressie waarnaar werd gezocht.</LI>
<LI> <B> n </B> : Heeft hetzelfde effect als het indrukken van de /
en de Return; d.w.z., zoekt naar het volgende voorkomen van de laatste 
reguliere expressie waarnaar je zocht.</LI>
<LI> <B> ?reg_exp </B> : Zoek voorwaarts, in plaats van terugwaarts. Als
er geen reg_exp werd opgegeven, zoekt het naar de laatste reguliere expressie
die werd ingevoerd. Het zoeken met / en ? "na" de onderkant en "voor" de 
bovenkant van het bestand is toegestaan.</LI>
<LI> <B> N </B> : Hetzelfde als het indrukken van ? en dan op Return.</LI>
</UL>
<H2>9.2 Herhalingen</H2>

<P>Veel van de verplaatsingsopdrachten die hiervoor werden besproken kunnen
worden voorafgegaan door een getal waarmee wordt aangegeven hoeveel maal
de erna volgende opdracht moet worden herhaald; de verplaatsing wordt
gewoon het gegeven aantal malen herhaald:
<UL>
<LI> <B> 3w </B> : Ga drie woorden vooruit</LI>
<LI> <B> 5k </B> : Ga vier tekens naar boven</LI>
<LI> <B> 3fa </B> : Zoek de derde opeenvolgende a in de huidige regel</LI>
<LI> <B> 6+ </B> : Ga zes regels naar beneden</LI>
</UL>

Voor een aantal opdrachten hebben de herhalingen een speciale betekenis:
<UL>
<LI> <B> 4H </B> : Ga naar regel 4 op het scherm (home plus 3)</LI>
<LI> <B> 8L </B> : Ga naar de achtste regel vanaf de onderkant van het
scherm.</LI>
<LI> <B> 3$ </B> : Ga naar het einde van de derde regel van onder</LI>
</UL>

Bij een aantal opdrachten (b.v., ^) wordt de herhaling genegeerd; 
bij anderen (b.v., / en ? ) is het niet toegestaan
<H2>9.3 Verwijderen van Tekst</H2>

<P>We hebben gezien dat <B>dd</B> de huidige regel verwijdert. Dit kan met
een herhaling worden gebruikt: 3dd verwijdert drie regels, de huidige
regel en de 2 daarop volgende regels. 
<P>De d opdracht kan als een "voorvoegsel" worden gebruikt met de meeste
verplaatsingsopdrachten hierboven om bijna willekeurige stukken tekst te
verwijderen. De verplaatsingsopdrachten worden "target specifiers" genoemd,
als ze in combinatie met d worden gebruikt. Aan d kan een herhaling worden
opgegeven. (Als je hiermee gaat experimenteren, denk er dan aan na iedere
opdracht de u in te tikken om de verwijdering ongedaan te maken).
<P>
<UL>
<LI> <B> dw </B> : Verwijder "klein" woord voorwaarts</LI>
<LI> <B> d3w </B> : Verwijder drie "kleine" woorden voorwaarts</LI>
<LI> <B> 3dw </B> : Drie keer, verwijder "klein" woord voorwaarts</LI>
<LI> <B> 3d3w </B> : Drie keer, verwijder drie "kleine" woorden voorwaarts
(dat wil zeggen, verwijder negen "kleine" woorden voorwaarts)</LI>
<LI> <B> d+ </B> : Verwijder huidige en daaropvolgende regel</LI>
<LI> <B> d/de </B>: Verwijder vanaf het huidige teken tot aan, maar niet
inclusief het volgende voorkomen van het patroon 'de'</LI>
<LI> <B> d$ </B> : Verwijder tot aan het einde van de regel</LI>
<LI> <B> d0 </B> : Verwijder tot aan het begin van de regel</LI>
<LI> <B> d30G </B> : Verwijder vanaf de huidige regel tot en met
regel 30</LI>
<LI> <B> dG </B> : Verwijder vanaf de huidige regel tot en met
de laatste regel</LI>
<LI> <B> d1G </B> : Verwijder vanaf de huidige regel tot en met
regel 1</LI>
</UL>

Gebruik x om enkele tekens te verwijderen. aan x kan een herhaling worden
opgegeven:
<UL>
<LI> <B> 15x </B> : Verwijder het huidige en de 14 daaropvolgende
14 tekens</LI>
</UL>

x is in feite gewoon een afkorting van d1; dat wil zeggen, verwijder 
&eacute;&eacute;n teken rechts.
<H2>9.4 Wijzigen van Tekst</H2>

<P>De c opdracht is vergelijkbaar met d, behalve dat het <B>vi</B> naar Insert
mode laat schakelen, waarbij het mogelijk wordt de oorspronkelijke (ongewenste)
tekst in iets anders te veranderen.
<P>Plaats bijvoorbeeld de cursor aan het begin van een woord (druk op w om
naar het begin van het volgende woord te gaan). Druk dan op cw om dat woord
te wijzigen. Op het scherm zal het laatste teken in het woord dat wordt
gewijzigd, worden vervangen door een <B>$</B>-symbool om de grens van
de wijziging aan te geven; typ een nieuw woord in (je zult het oorspronkelijke
woord op het scherm overschrijven) en druk de ESC-toets in als je klaar bent.
Wat je invoert mag langer of korter zijn dan het woord dat wordt gewijzigd.
<P>Plaats de cursor aan het begin van een regel bestaande uit op z'n minst
drie woorden, en probeer c3w om drie woorden te wijzigen.
Probeer c$ om tot het einde van de huidige regel te wijzigen.
In alle gevallen wordt de grens aangegeven met $ daar waar de wijziging
alleen effect heeft op de huidige regel.
<P>Als een wijziging op meer dan alleen de huidige regel effect heeft,
verwijdert <B>vi</B> de oorspronkelijke tekst van het scherm en schakelt
over naar Insert-mode. Probeer bijvoorbeeld eens met c3+ de huidige
en 3 volgende regels te wijzigen;
<B>vi</B> verwijdert de vier oorspronkelijke regels van het scherm en
schakelt over naar Insert-mode op een nieuwe blanco regel.
Druk zoals gewoonlijk op de ESC-toets wanneer je klaar bent met het invoeren
van je nieuwe tekst.
<P>Een aantal andere wijzigingsopdrachten:
<UL>
<LI> <B> cc </B> : Wijzig huidige regel</LI>
<LI> <B> 5cc </B> : Wijzig vijf regels (huidige en de volgende vier)</LI>
<LI> <B> c/de </B> : Wijzig vanaf huidige teken tot aan, maar niet
inclusief het volgende voorkomen van het volgende patroon dat voldoet aan
'de'</LI>
<LI> <B> c$ </B> : Wijzig tot aan het einde van de regel</LI>
<LI> <B> c30G </B> : Wijzig vanaf de huidige regel tot en met Regel 30</LI>
<LI> <B> cG </B> : Wijzig vanaf de huidige regel tot en met de laatste
regel</LI>
<LI> <B> c1G </B> : Wijzig vanaf de huidige regel tot en met Regel 1</LI>
</UL>
<H2>9.5 Yanken (kopi&euml;ren) van Tekst</H2>

<P>De y opdracht kopieert een kopie van tekst naar een buffer; de gekopieerde
tekst kan dan met p of P elders in het bestand worden geplaatst (of geplakt).
<P>De eenvoudigste vorm van yank is yy om de huidige regel te kopi&euml;ren;
probeer na een yy een kopie van de gekopieerde regel na de cursor te
plaatsen. Na een yy, kun je zoveel kopie&euml;n van de gekopieerde regel
maken als je wilt door naar boven en naar beneden in het bestand te gaan
en op p te drukken.
<P>Probeer voor het kopi&euml;ren van meerdere regels bijvoorbeeld 5yy
(kopieer de huidige en de volgende vier regels).
p plaatst een kopie van de gekopieerde regels na de cursor; de reeks 5yyp
"werkt" maar het is waarschijnlijk niet wat je wilt. De P opdracht is
vergelijkbaar met p, maar het plaatst een kopie van de gekopieerde tekst
voor de cursor; probeer de reeks 5yyP.
<P>Andere kopieer-opdrachten:
<UL>
<LI> <B> y3w </B> : Kopieer drie woorden</LI>
<LI> <B> y$ </B> :  Kopieer tot aan het einde van de huidige regel</LI>
<LI> <B> y1G </B> : Kopieer vanaf de huidige regel tot en met Regel 1</LI>
</UL>
<H2>9.6 Filteren van tekst</H2>

<P>De filteropdracht <B>!</B>, verwacht de naam van een UNIX-opdracht
(wat een filter zou moeten zijn), en geeft de geselecteerde regels dan door
aan het filter, waarbij de geselecteerde regels in de <B>vi</B>-buffer
dan worden vervangen door de uitvoer van het filteropdracht.
<B>vi</B>'s vermogen om bijna willekeurige stukken tekst via iedere 
UNIX-filter door te geven voegt, zonder "extra kosten" aan <B>vi</B> een
ongelofelijke flexibliteit toe.
<P>Ter illustratie zal een aantal voorbeelden van hulp zijn. Maak in het
bestand een regel met slechts het woord 'who' en absoluut geen andere tekst.
Plaats de cursor op deze regel, en druk op <B>!!</B>.
Deze opdracht is analoog aan dd, cc, of yy, maar in plaats van het verwijderen,
wijzigen of kopi&euml;ren van de huidige regel, filtert het de huidige regel.
Als je de tweede ! indrukt, gaat de cursor naar de linkerhoek aan de onderkant
van het scherm en wordt een enkele ! getoond, daarbij wachtend totdat je de
naam van een filter opgeeft. Typ als filternaam sh en druk op de Return-toets.
<B>sh</B> (de Bourne shell) is een filter!
Het leest van standaarinvoer, verwerkt zijn invoer (dat wil zeggen, voert
opdrachten uit) en stuurt de uitvoer (de uitvoer van die opdrachten) naar
standaarduitvoer. Het filteren van de regel met who via sh zorgt ervoor dat de
regel met who wordt vervangen door een lijst met de huidige gebruikers op het
systeem - direct in je bestand!
<P>Probeer dit proces te herhalen met <B>date</B>. Dat wil zeggen, maak een
regel met niets anders dan het woord <B>date</B>, plaats de cursor dan op
deze regel, druk op <B>!!sh</B> en de Return-toets. De regel met
<B>date</B> wordt vervangen door de uitvoer van de <B>date</B> opdracht.
<P>Plaats de cursor op de eerste regel van de uitvoer van who. Tel het aantal
regels. Stel bijvoorbeeld dat het aantal zes is. Selecteer dan deze zes
regels om via sort te laten filteren; druk op 
<B>6!!sort</B> en vervolgens de Return-toets. De zes regels zullen aan sort
worden doorgegeven, en de zes oorspronkelijke regels worden door de uitvoer
van sort vervangen.
<P>De filteropdracht kan alleen op gehele regels worden toegepast, niet op
tekens of woorden. 
<P>Nog wat andere filter-opdrachten (hier betekent, &lt; CR &gt; een druk op de
Return-toets):
<UL>
<LI> <B>!/de &lt; CR &gt; sort &lt; CR &gt;</B> : Sorteer vanaf de huidige
regel tot en met de volgende regel met daarin het woord `de'.</LI>
<LI><B> !1Ggrep de &lt; CR &gt;</B> : Vervang vanaf de huidige regel tot
en met Regel 1 door slechts die regels met daarin het woord `de'.</LI>
<LI><B> !Gawk '{print $1}' &lt; CR &gt; </B>: Vanaf de huidige regel tot
aan het einde van het bestand, het vervangen van iedere regel door slechts
het eerste woord.</LI>
</UL>
<H2>9.7 Markeren van Regels en Tekens</H2>

<P>Je kunt regels en tekens markeren om te worden gebruikt als doel voor
verplaatsing, verwijdering, wijziging, ze te kopi&euml;ren, of filteren met
behulp van de opdracht mc, waar c staat voor een kleine letter.
<P>Plaats de cursor bijvoorbeeld in het midden van een woord en druk op ma.
Hiermee wordt het teken onder de cursor met a gemarkeerd.
<P>Verplaats de cursor nu naar elders, weg van het gemarkeerde teken en naar
een andere regel (gebruik de cursorpijlen, CTRL-u of iets dergelijks).
Om naar de gemarkeerde regel terug te keren, tik je 'a in.
(dat wil zeggen, een enkel aanhalingsteken en dan een a).
Hierdoor wordt de cursor naar het eerste niet-blanco teken in de regel 
gemarkeerd met a verplaatst.
<P>Ga weer weg van deze regel. Druk op `a (dat wil zeggen, een aanhalingsteken
achterwaarts en dan een a) om naar het gemarkeerde teken terug te keren.
Hierdoor wordt de cursor naar het teken gemarkeerd met a verplaatst.
<P>Markeringen worden meestal gebruikt in combinatie met verwijderingen,
wijzigingen, kopieer- of filteropdrachten.
Verplaats de cursor bijvoorbeeld naar een andere regel dan die met de
markering a en druk dan op d'a (d, een enkel aanhalingsteken en een a).
Hiermee wordt de huidige regel tot en met de regel gemarkeerd met a verwijderd.
<P>Plaats de cursor in het midden van een ander woord en druk op mb om de
markering b in te stellen. Verplaats de cursor nu, weg van dat woord (maar
slechts een paar regels, zodat je makkelijk kunt zien wat we aan het doen zijn),
en druk dan op d`b (d, aanhalingsteken achterwaarts, b).
Hierdoor wordt het huidige teken tot en met het teken gemarkeerd met b
verwijderd.
<P>Een ander voorbeeld is om de uitvoer van who te sorteren, markeer de eerste
regel (ma), verplaats de cursor dan naar de laatste regel en druk op
!'asort en dan de Return-toets.
<P>Als je naar een markering springt en besluit terug te gaan naar waar je vandaan
sprong, kun je '' intikken (ga terug naar regel ..) of `` (ga terug naar het
teken ..).
<H2>9.8 Benoemen van Buffers</H2>

<P>Als je tekst verwijdert, wijzigt of kopieert, wordt de oorspronkelijke tekst
(tot de volgende verwijdering, wijziging of kopieeropdracht) in een 
onbenoemde buffer opgeslagen van waaruit het kan worden opgehaald met
p of P. Door gebruik te maken van de onbenoemde buffer, kan alleen de meest
recente verwijderde, gewijzigde of gekopieerde tekst worden hersteld.
<P>Als je meerdere delen van je tekst wilt verwijderen, wijzigen of kopi&euml;ren
en je wilt ze allemaal onthouden (tot aan een maximum van 26), kun je 
voor de wijzigings- of kopieeropdracht aan een buffer een naam toekennen.
De naam van een buffer heeft de vorm "c (dubbel aanhalingsteken, kleine letter
c).
<P>Tik bijvoorbeeld "ayy in om de huidige regel naar buffer a te kopi&euml;ren.
Verplaats je vervolgens naar een andere regel en druk op "byy om die regel naar
buffer b te kopi&euml;ren. Verplaats de cursor nu naar elders in het bestand en
tik in "ap en "bp om kopie&euml;n van de tekst te plaatsen die in de buffers
a en b zijn geplaatst.
<P>Nog wat andere benoemde bufferopdrachten:
<UL>
<LI> <B> "a6yy </B> : Kopieer zes regels (de huidige en de volgende
vijf) naar buffer a</LI>
<LI> <B> "bd1G </B> : Verwijder vanaf de huidige regel tot en met Regel 1,
waarbij de verwijderde regel in buffer b wordt opgeslagen</LI>
<LI> <B> "cy'c </B> : Kopieer vanaf de huidige regel gemarkeerd als c
naar buffer c (markeringen en buffers zijn verschillend, en kunnen dezelfde
naam hebben zonder dat <B>vi</B> daarvan in de war raakt).</LI>
</UL>
<H2>9.9 Substituties</H2>

<P>Gebruik de :s opdracht om een stuk tekst door een ander stuk tekst in regels
door je hele bestand te vervangen.
Wat substitueer voorbeelden:
<UL>
<LI> <B> :1,$s/de/DE/g </B>Vervang van regel 1 tot aan de laatste
regel (regel $), het woord `de' door `DE'
doe dit globaal in iedere regel waar `de' voorkomt</LI>
<LI> <B> :'a,.s/.*/ha ha/ </B> Vervang in de regel gemarkeerd met `a'
tot aan de huidige regel (regel .) alles op de regel door de tekst `ha ha'</LI>
</UL>
<H2>9.10 Diverse "Commando's beginnend met een dubbele punt"</H2>

<P>Alle volgende opdrachten beginnen met een dubbele punt; als je de dubbele
punt intikt, gaat de cursor naar de linkeronderkant van het scherm en wordt
er een prompt, bestaande uit een dubbele punt, weergegeven, die wacht totdat
je gereed bent met het invoeren van je opdracht.
<P>Een aantal belangrijke voorbeelden:
<UL>
<LI><B>:w </B> Schrijf de inhoud van de buffer naar het bestand zonder
<B>vi</B> te verlaten</LI>
<LI><B>:w abc </B>Schrijf de inhoud van de buffer naar het bestand 
`abc' (waarbij `abc' wordt aangemaakt als het niet bestaat of de huidige
inhoud overschrijft als het wel bestaat) zonder <B>vi</B> te verlaten</LI>
<LI><B>:1,10w  abc  </B>Schrijf de regels 1 tot en met 10 naar het
bestand `abc'</LI>
<LI><B>:'a,$w abc  </B>Schrijf vanaf de regel gemarkeerd als a tot aan
de laatste regel naar het bestand `abc'</LI>
<LI><B>:e abc </B>Wijzig bestand `abc', in plaats van het huidige
bestand. <B>vi</B> drukt een foutmelding af als er aan het huidige bestand
wijzigingen zijn aangebracht die nog niet met :w zijn opgeslagen</LI>
<LI><B>:e! abc </B>Wijzig het bestand `abc', waarbij eventuele wijzigingen
die zijn aangebracht aan het huidige bestand worden verworpen</LI>
<LI><B>:e #  </B>Wijzig het vorige gewijzigde bestand (opeenvolgende
:e# opdrachten schakelen tussen twee bestanden)</LI>
<LI><B>:f abc  </B>Wijzig de bestandsnaam voor de huidige <B>vi</B>
buffer in abc</LI>
<LI><B>:q </B>Be&euml;indig, tenzij niet opgeslagen wijzigingen zijn
gemaakt</LI>
<LI><B>:q! </B>Be&euml;indig, waarbij eventuele wijzingingen die zijn
aangebracht, worden verworpen</LI>
<LI><B>:r abc </B>Lees het bestand `abc' in de huidige <B>vi</B> buffer,
na de regel waarop de cursor staat (probeer :r croc om een kopie van het
croc bestand in te lezen)</LI>
<LI><B>:!cmd </B>Voer de opdracht cmd uit (who, sort, ls, enz.)</LI>
</UL>
<H2>9.11 Opties Instellen</H2>

<P>Diverse opties hebben effect op de "feel" van <B>vi</B>. 
Je kunt alle diverse opties die kunnen worden ingesteld tonen met de
opdracht :set all. Je kunt set ook gebruiken om opties te wijzigen.
<P>Als je bijvoorbeeld regelnummers wilt zien voor de regel in het bestand
wat je aan het wijzigen bent, gebruik je de opdracht :set number.
Voor het uitzetten van de regelnummering, gebruik je de opdracht
:set nonumber. De meeste opties kunnen worden afgekort. :set nu zet de
regelnummering aan en :set nonu zet de regelnummering uit.
<P>Met een :set nomagic, wordt de speciale betekenis van de reguliere expressie
tekens (punt, asterisk, blokhaak, enz.) uitgeschakeld. Gebruik :set magic
om de speciale betekenissen weer te herstellen.
<P>Een aantal opties verwacht een waarde. :set tabstop=4 bijvoorbeeld 
zorgt ervoor dat tabs als vier spatie-tekens worden weergegeven in plaats
van de gebruikelijke acht.
<P>Als je bemerkt dat je bepaalde opties altijd op een bepaalde manier instelt, kun
je de set opdrachten die je wilt in een bestand met de naam .exrc plaatsen,
of je kunt de omgevingsvariabele EXINIT instellen om de gewenste opties in
te stellen.
<P>Als je login-shell bijvoorbeeld de Bourne-shell is, zou deze regel in je
.profile bestand geplaatst kunnen worden:
<HR>
<PRE>
        EXINIT='set nomagic nu tabstop=4'; export EXINIT
</PRE>
<HR>

Als je login-shell een C-shell is, zou deze regel in je .login bestand
geplaatst kunnen worden:
<HR>
<PRE>
        setenv EXINIT 'set nomagic nu tabstop=4'
</PRE>
<HR>
<H2>9.12 Key Mappings</H2>

<P>Als je bemerkt dat je keer op keer een serie eenvoudige opdrachten aanroept,
kun je met de opdracht :map de serie opdrachten aan een ongebruikte
opdrachttoets toekennen. Als in de toekenning controle-tekens zoals de
Return-toets (CTRL-M in ASCII) of de ESC (CTRL-[ in ASCII), moeten worden
opgenomen, laat dergelijke tekens dan voorafgaan door een CTRL-v om hun
speciale betekenis te onderdrukken.
<P>In bijvoorbeeld de hierna volgende opdracht wordt aan de opdracht
CTRL-A toegekend dat de cursor 55 regels verder wordt geplaatst, dan weer
terug wordt gegaan naar de regel met de minste tekens, waarbij die blanco
regel wordt gewijzigd in een formfeed (CTRL-L) gevolgd door drie blanco
regels. Dat wil zeggen dat iedere CTRL-A de volgende pagina zal pagineren,
zonder dat paragrafen op meerdere pagina's worden gesplitst.
<P>Noot: In deze opdracht wordt ieder controle-teken getoond als ^C, C is hierbij
een hoofdletter. CTRL-M wordt bijvoorbeeld getoond als ^M.
Wanneer je deze opdracht invoert, zul je ook de CTRL-v tekens zoals getoond,
niet zien: iedere CTRL-v onderdrukt louter de gebruikelijke speciale betekenis
van het volgende controle-teken, dus als je de reeks ^V^M intikt, zul je
op het scherm slechts ^M zien. In deze opdracht, is ^M de Return-toets en
^[ is de ESC-toets.
<HR>
<PRE>
        :map ^A  55+?^$^V^Mcc^V^L^V^M^V^M^V^M^V^[
</PRE>
<HR>
<H2>9.13 Wijzigen van Meerdere Bestanden</H2>

<P>Je kunt met <B>vi</B> meerdere bestanden wijzigen, door als argumenten op
de opdrachtregel, meerdere bestandsnamen op te geven:
<HR>
<PRE>
        vi croc fatherw  wknight
</PRE>
<HR>

Twee opdrachten beginnend met een dubbele punt worden gebruikt om je
tussen de meerdere bestanden te verplaatsen:
<UL>
<LI><B> :n  </B>Ga naar het volgende bestand in de argumentenlijst 
(je moet je wijzigingen opslaan met
:w anders zal <B>vi</B> een foutmelding weergeven)</LI>
<LI><B> :rew </B>Ga terug en ga weer verder met het eerste bestand
in de lijst met argumenten</LI>
</UL>

De :n en :rew opdrachten zijn wat onhandig, maar er zijn een aantal
belangrijke voordelen: de inhoud van benoemde buffers
("a, "b, "c, etc.) worden door de bestanden heen onthouden, dus je kunt
:n en :rew met p en P gebruiken om tekst heen en weer tussen bestanden 
te kopi&euml;ren. Ook wordt de meest recente zoekstring voor de / en ?
opdrachten door de bestanden heen onthouden, dus je kunt nogal makkelijk 
herhalende zoekopdrachten in meerdere bestanden gebruiken.
<P>Probeer bijvoorbeeld het volgende experiment:
Ga eerst uit <B>vi</B>, start <B>vi</B> dan op met croc en wknight 
als argumenten:
<HR>
<PRE>
        $ vi croc wknight
</PRE>
<HR>

Zoek in croc naar `de'
<P><B>  /de &lt; CR &gt; </B>
<P>Kopieer deze regel naar buffer a:
<P><B>  "ayy </B>
<P>Ga nu naar het volgende bestand (je hebt geen wijzigingen aangebracht aan
croc, dus dit werkt):
<P><B>  :n &lt; CR &gt; </B>
<P>Zoek naar de volgende regel met `de', zonder het opnieuw intikken van de
zoekstring:
<P><B>  n </B>
<P>Plaats een kopie van buffer a na de huidige regel in wknight:
<P><B>  "ap </B>
<P>Ga twee regels naar beneden, en kopieer de huidige regel naar buffer b:
<P><B>  jj"byy </B>
<P>Sla de wijzigingen in wknight op
<P><B>  :w &lt; CR &gt; </B>
<P>Ga nu terug naar croc
<P><B>  :rew &lt; CR &gt; </B>
<P>Zoek nogmaals, en plaats een kopie van buffer b na de gevonden regel:
<P><B>  n"bp </B>
<P>Sla de wijzigingen op en be&euml;indig <B>vi</B>
<P><B>  ZZ </B>
<H2>9.14 Laatste Opmerkingen</H2>

<P>Deze tutorial was bedoeld om wat van de mogelijkheden van 
<B>vi</B> te introduceren waar je in het systeemhandboek van <B>vi</B> 
misschien overheen zou kijken of die wellicht niet in het handboek worden
vermeld (op de verschillende systemen zijn de handboeken van zeer 
verschillende kwaliteit).
<P>Je zult na het lezen van deze tutorial geen <B>vi</B>-expert zijn, maar je
kunt de mogelijkheden van <B>vi</B> dan wel juist inschatten. 
Slechts tijd en moeite kunnen een <B>vi</B>-expert van je
maken. Maar de effici&euml;ntie en alomvattenheid betalen dit op de lange
termijn terug.
<P>Mogelijk heb je besloten dat je <B>vi</B> haat. Het zij zo! 
Maar wees je er bewust van dat <B>vi</B> de standaard UNIX teksteditor
blijft - de enige editor waar je op kunt rekenen dat het op ieder UNIX-systeem
beschikbaar is - dus zelfs als je de voorkeur geeft om dagelijks iets anders
te gebruiken, wordt je geadviseerd om bekend te zijn met het absolute
minimum aan het <B>vi</B>-materiaal dat in deze tutorial is behandeld.
<H2><A NAME="vimref"></A> <A NAME="s10">10. Vim Referentiekaart</A></H2>

<H2>10.1 Vi status</H2>

<P>Vi heeft 3 modi:
<OL>
<LI> <B><I>opdrachtenmodus</I></B> - Normale en initi&euml;le status;
anderen keren hier naar terug (gebruik <B>ESC</B> om een gedeeltelijk
getypte opdracht af te breken)</LI>
<LI> <B><I>invoer modus</I></B> - ingegaan door specieke opdrachten
<B>a i A I o O c C s S R </B> en be&euml;indigd door <B>ESC</B> of
abnormaal door een interrupt</LI>
<LI> <B><I>regel modus</I></B> - d.w.z. het wachten op invoer
na een <B>: </B>, <B>/ </B>, <B>? </B> of een <B>! </B> 
opdracht (be&euml;indigd met <B>CR</B>, af te breken met <B>CTRL-c</B>).
<B>CTRL</B> is de control-toets: <B>CTRL-c</B> betekent "control c"</LI>
</OL>
<H2>10.2 Shell Commando's</H2>

<P>
<OL>
<LI> <B>TERM=</B> <I>code</I> Plaatst een code-naam voor je terminal
in de variabele <B>TERM</B></LI>
<LI> <B>export TERM</B> Draagt de waarde van <B>TERM</B> over (de 
terminal code) naar ieder UNIX-systeemprogramma dat terminal afhankelijk is.</LI>
<LI> <B>tput init</B> Initialiseert de terminal zodat het juist zal
functioneren met diverse UNIX-systeemprogramma's.</LI>
<LI> <B>vi </B> <I>filename</I> Geeft toegang tot de schermeditor
<B>vi</B> zodat je een specifiek bestand kunt wijzigen.</LI>
<LI> <B>vi </B> <I>file1 file2 file3</I> Laadt drie bestanden in de
<B>vi</B> buffer om te worden gewijzigd. Die bestanden zijn 
<I>file1, file2,</I> en <I>file3</I>.</LI>
<LI> <B>view </B> <I>file</I> Roep de vi-editor aan met het bestand
<I>file</I> in read-only modus</LI>
<LI> <B>vi -R </B> <I>file</I> Roep de vi-editor aan met het bestand
<I>file</I> in read-only mode</LI>
<LI> <B>vi -r </B> <I>file</I> Herstel het bestand <I>file</I> en
recente wijzigingen na een systeemcrash</LI>
<LI> <B>vi -r </B> <I>file</I> Herstel het bestand <I>file</I> en 
recente wijzigingen na een systeemcrash</LI>
</OL>
<H2>10.3 Opties Instellen</H2>

<P>
<OL>
<LI> <B>:set</B> <I>optie</I> Activeer <I>optie</I></LI>
<LI> <B>:set</B> <I>optie=waarde</I> Wijs <I>waarde</I> toe aan
<I>optie</I></LI>
<LI> <B>:set no</B> <I>optie</I> Deactiveer <I>optie</I></LI>
<LI> <B>:set </B> Toon door gebruiker ingestelde opties</LI>
<LI> <B>:set all</B> Toon lijst met alle huidige opties, zowel
standaard als die zijn ingesteld door de gebruiker</LI>
<LI> <B>:set </B> <I>optie</I>? Toon waarden van <I>optie</I></LI>
</OL>
<H2>10.4 Gebruikte Notaties</H2>

<P>Notaties:
<OL>
<LI> <B>CTRL-c</B> <B>CTRL</B> is de control-toets: <B>CTRL-c</B> betekent "control c"</LI>
<LI> <B>CR</B> is een Carriage return (ENTER toets)</LI>
</OL>
<H2>10.5 Onderbreken, annuleren</H2>

<P>
<UL>
<LI> <B>ESC</B> be&euml;indig invoeg-modus of onvolledige opdracht</LI>
<LI> <B>CTRL-?</B> <B>CTRL</B> is de control-toets: 
<B>CTRL-?</B> betekent "control ?" verwijder of rubout interrupts</LI>
<LI> <B>CTRL-l</B> reprint/ververs scherm als CTRL-? het door de war gooit</LI>
</UL>
<H2>10.6 Bestandsmanipulatie</H2>

<P>
<UL>
<LI> <B>ZZ</B> Bewaar bestand en be&euml;indig vi</LI>
<LI> <B>:wq</B> Bewaar het bestand en be&euml;indig vi</LI>
<LI> <B>:w</B> Sla het huidige bestand op</LI>
<LI> <B>:w!</B> Forceer schrijven naar het huidige bestand, als het
bestand alleen lezen is</LI>
<LI> <B>:w<I>name</I></B> Schrijf naar bestand <I>name</I></LI>
<LI> <B>:q</B> Be&euml;indig vi</LI>
<LI> <B>:q!</B> Forceer be&euml;indiging vi (verwerp wijzigingen)</LI>
<LI> <B>:e name</B> Wijzig bestands<I>naam</I></LI>
<LI> <B>:e!</B> opnieuw wijzigen, verwerp veranderingen</LI>
<LI> <B>:e + name</B> wijzig bestand <I>name</I>, beginnend aan het eind</LI>
<LI> <B>:e + n</B> begin met wijzigen op regel<I>n</I></LI>
<LI> <B>:e #</B> wijzig andere bestand</LI>
<LI> <B>:n</B> wijzig volgende bestand in <I>arglist</I></LI>
<LI> <B>:args</B> geef lijst met bestanden in huidige bestandenlijst</LI>
<LI> <B>:rew</B> wijzig eerste bestand in bestandenlijst</LI>
<LI> <B>:n args</B> specificeer nieuwe arglist</LI>
<LI> <B>:f </B> toon huidige bestand en regel</LI>
<LI> <B>CTRL-G</B> synoniem voor :f , toon huidige bestand en regel</LI>
<LI> <B>:ta tag </B> naar tag file entry <I>tag</I></LI>
<LI> <B>CTRL-] </B> :ta, volgende woord is tag</LI>
</UL>
<H2>10.7 Verplaatsen</H2>

<P>
<UL>
<LI> <B>Cursorpijlen</B> Verplaats de cursor</LI>
<LI> <B>CTRL-d</B> Scroll halve pagina omlaag</LI>
<LI> <B>CTRL-u</B> Scroll halve pagina omhoog</LI>
<LI> <B>CTRL-f</B> Scroll een volledige pagina omlaag</LI>
<LI> <B>CTRL-b</B> Scroll een volledige pagina omhoog</LI>
<LI> <B>:0</B> Ga naar begin van het bestand</LI>
<LI> <B>:n</B> Ga naar regelnummer n</LI>
<LI> <B>:$</B> Ga naar einde bestand </LI>
<LI> <B>0</B> Ga naar begin van de regel</LI>
<LI> <B>^</B> Ga naar eerste niet-blanco teken</LI>
<LI> <B>$</B> Ga naar einde regel</LI>
<LI> <B>CR</B> Ga naar het begin van de volgende regel</LI>
<LI> <B>-</B> Ga naar het begin van de vorige regel</LI>
<LI> <B>%</B> Zoek naar overeenkomende blokhaak</LI>
<LI> <B>G </B> ga naar regel (standaard de laatste regel)</LI>
<LI> <B>]] </B> volgende sectie/functie</LI>
<LI> <B>[[ </B> vorige sectie/functie</LI>
</UL>
<H2>10.8 Regel positionering</H2>

<P>
<UL>
<LI> <B>H </B> Linksbovenaan venster</LI>
<LI> <B>L </B> Laatste regel van venster</LI>
<LI> <B>M </B> Middelste regel van venster</LI>
<LI> <B>+ </B> Volgende regel, naar eerst niet-blanco</LI>
<LI> <B>- </B> Vorige regel, naar eerste niet-blanco</LI>
<LI> <B>CR </B> return, zelfde als +</LI>
<LI> <B>j </B> volgende regel, zelfde kolom</LI>
<LI> <B>k </B> vorige regel, zelfde kolom</LI>
</UL>
<H2>10.9 Positioneren van de cursor</H2>

<P>
<UL>
<LI> <B>0 </B> begin van de regel</LI>
<LI> <B>$ </B> einde van de regel</LI>
<LI> <B>h </B> vooruit </LI>
<LI> <B>l </B> terug </LI>
<LI> <B>SPACE </B> zelfde als l </LI>
<LI> <B>fx </B> zoek x voorwaarts</LI>
<LI> <B>Fx </B> zoek x terugwaarts</LI>
<LI> <B>; </B> herhaal laatste f F</LI>
<LI> <B>, </B> inverse van ;</LI>
<LI> <B>| </B> naar aangegeven kolom</LI>
<LI> <B>% </B> zoek overeenkomende { of }</LI>
</UL>
<H2>10.10 Woorden, zinnen, paragrafen</H2>

<P>
<UL>
<LI> <B>w </B> Woord vooruit</LI>
<LI> <B>b </B> Woord achteruit</LI>
<LI> <B>e </B> Einde woord</LI>
<LI> <B>) </B> Naar volgende zin </LI>
<LI> <B>( </B> Zin terug </LI>
<LI> <B>} </B> Naar volgende paragraaf </LI>
<LI> <B>{ </B> Paragraaf terug </LI>
<LI> <B>W </B> Volgende woord</LI>
<LI> <B>B </B> W terug</LI>
<LI> <B>E </B> Naar einde van W</LI>
</UL>
<H2>10.11 Markeren en terugkeren</H2>

<P>
<UL>
<LI> <B>``</B> (druk tweemaal op de ` toets) Vorige context</LI>
<LI> <B>''</B> (druk tweemaal op de ` toets) 
Vorige context op eerste niet-blanco teken in regel</LI>
<LI> <B>mx</B> Markeer positie met letter x</LI>
<LI> <B>`x</B> (` en letter x) ga naar markering x</LI>
<LI> <B>'x</B> ga naar markering x op eerste niet-blanco teken in regel</LI>
</UL>
<H2>10.12 Correcties tijdens het invoegen</H2>

<P>
<UL>
<LI> <B>CTRL-h</B> Verwijder laatste teken</LI>
<LI> <B>CTRL-w</B> Verwijder laatste woord</LI>
<LI> <B>erase </B> Druk op de DELETE toets, zelfde als CTRL-h</LI>
<LI> <B>kill </B> Je kill-toets, verwijder invoer deze regel</LI>
<LI> <B>\ </B> Escapes CTRL-h, DELETE en kill</LI>
<LI> <B>ESC </B> Be&euml;indig het invoegen, terug naar opdrachtenmodus</LI>
<LI> <B>CTRL-? </B> Interrupt, be&euml;indig invoer</LI>
<LI> <B>CTRL-d </B> Terugtab over <I>autoindent</I></LI>
<LI> <B>CTRL-v </B> Quote niet-afdrukbaar teken</LI>
</UL>
<H2>10.13 Aanpassen van het scherm</H2>

<P>
<UL>
<LI> <B>CTRL-l</B> Maak het scherm schoon en bouw het opnieuw op</LI>
<LI> <B>CTRL-r</B> typ opnieuw, elimineer @lines</LI>
<LI> <B>z-CR</B> ververs scherm, huidige regel bovenkant van venster</LI>
<LI> <B>z-</B> ververs scherm, huidige regel onderkant van venster</LI>
<LI> <B>z.</B> ververs scherm, huidige regel in het midden van het venster</LI>
<LI> <B>/pat/z-</B> <I>pat</I> regel onderaan</LI>
<LI> <B>tn</B> Gebruik n regel venster</LI>
<LI> <B>CTRL-e</B> Scroll venster 1 regel naar beneden</LI>
<LI> <B>CTRL-y</B> Scroll venster 1 regel naar boven</LI>
</UL>
<H2>10.14 Verwijderen</H2>

<P>
<UL>
<LI> <B>x</B> Verwijder het teken onder de cursor</LI>
<LI> <B>X</B> Verwijder het teken voor de cursor</LI>
<LI> <B>D</B> Verwijder tot aan het einde van de regel</LI>
<LI> <B>d^</B> Verwijder terug tot aan het begin van de regel</LI>
<LI> <B>dd</B> Verwijder de huidige regel</LI>
<LI> <B>ndd</B> Verwijder <I>n</I> regel te beginnen met de huidige regel</LI>
<LI> <B>dnw</B> Verwijder <I>n</I> woorden te beginnen vanaf de cursor</LI>
</UL>
<H2>10.15 Invoegen, wijzigen</H2>

<P>
<UL>
<LI> <B>i</B> Ga naar invoermode en voeg in voor de cursor</LI>
<LI> <B>I</B> Ga naar invoermode en voeg in voor het eerste niet-blanco
teken</LI>
<LI> <B>a</B> Ga naar invoermode en voeg in na de cursor</LI>
<LI> <B>A</B> Ga naar invoermode en voeg in na het einde van de regel</LI>
<LI> <B>o</B> Voeg een nieuwe regel in na de regel onder de huidige
regel en ga naar invoermode</LI>
<LI> <B>O</B> Voeg een nieuwe regel in boven de huidige regel en
gan naar invoermode</LI>
<LI> <B>r</B> Vervang het teken onder de cursor (ga NIET naar invoermode)</LI>
<LI> <B>R</B> Ga naar invoermode en vervang tekens</LI>
<LI> <B>C</B> shift-c. Wijzig rest van regel</LI>
<LI> <B>D</B> shift-d. Verwijder rest van regel</LI>
<LI> <B>s</B> Vervang tekens</LI>
<LI> <B>S</B> Vervang regels</LI>
<LI> <B>J</B> Voeg regels samen</LI>
<LI> <B>J</B> Voeg regels samen</LI>
</UL>
<H2>10.16 Kopi&euml;ren en Plakken</H2>

<P>De "yank buffer" wordt met <I>IEDERE</I> delete opdracht gevuld, of expliciet
door <B>Y</B> en <B>yy</B>.
<UL>
<LI> <B>Y</B> Kopieer de huidige regel naar de yank buffer</LI>
<LI> <B><I>n</I>yy</B> Kopieer <I>n</I> regels te beginnen vanaf
de huidige regel naar de yank buffer</LI>
<LI> <B>p</B> "Plak" de inhoud van de yank buffer na de cursor
(of onder de huidige regel)</LI>
<LI> <B>P</B> "Plak" de yank buffer voor de cursor (of boven
de huidige regel)</LI>
<LI> <B>"<I>x</I>p </B> "Plak" vanuit buffer x</LI>
<LI> <B>"<I>x</I>y </B> Yank (kopieer) naar buffer x</LI>
<LI> <B>"<I>x</I>d </B> Verplaats naar buffer x</LI>
</UL>
<H2>10.17 Operators (gebruik dubbel om effect te hebben op regels)</H2>

<P>
<UL>
<LI> <B>d </B> delete (verwijder)</LI>
<LI> <B>c </B> change (wijzig)</LI>
<LI> <B>&lt; </B> linker verschuiving</LI>
<LI> <B>> </B> rechter verschuiving</LI>
<LI> <B>! </B> filter door opdracht</LI>
<LI> <B>= </B> inspringing voor LISP</LI>
<LI> <B>y </B> yank (kopieer) tekst naar buffer</LI>
</UL>
<H2>10.18 Zoeken en vervangen</H2>

<P>
<UL>
<LI> <B>/<I>text</I></B> Zoek voorwaarts naar <I>text</I></LI>
<LI> <B>?<I>text</I></B> Zoek terugwaarts naar <I>text</I></LI>
<LI> <B>n</B> Herhaal de laatste zoekactie in dezelfde richting</LI>
<LI> <B>N</B> Herhaal de laatste zoekactie in tegengestelde richting</LI>
<LI> <B>/</B> Herhaal de laatste zoekactie voorwaarts</LI>
<LI> <B>?</B> Herhaal de laatste zoekactie terugwaarts</LI>
<LI> <B>[ addr ] s/van/naar/ [ g ] </B> Zoek naar het
voorkomen van <I>van</I>
en vervang het in de huidige regel of in de range <B><I>addr</I></B>
(twee regelnummers gescheiden door een komma; 1,$ is het gehele bestand) 
door <B><I>naar</I></B>.
Vervang &eacute;&eacute;n voorkomen per regel, of alle voorkomendheden
als <B><I>g</I></B> is gespecificeerd.
Bijvoorbeeld, :3,20s/zoekwoord/anderwoord/g  zal "zoekwoord" vervangen
door "anderwoord" te beginnen bij regel 3 tot aan regel 20. 'g' voor globaal
betekent dat alle keren dat het "zoekwoord" voorkomt, het moet worden vervangen.</LI>
</UL>
<H2>10.19 Algemeen</H2>

<P>
<UL>
<LI> <B>:sh</B> Roept een shell aan (kan worden be&euml;indigd met CTRL-d)</LI>
<LI> <B>:!<I>opdracht</I></B> Roept een shell aan om de 
<I>opdracht</I> uit te voeren.</LI>
<LI> <B>:set number</B> Schakel regelnummering in</LI>
<LI> <B>:set nonumber</B> Schakel regelnummering uit</LI>
</UL>
<H2>10.20 Regeleditor-opdrachten</H2>

<P>
<UL>
<LI> <B>:</B> Vertelt <B>vi</B> dat de volgende opdrachten die je
uitvoert, regeleditor-opdrachten zullen zijn.</LI>
<LI> <B>:sh</B> Ga tijdelijk naar de shell om een aantal shell-opdrachten
uit te voeren zonder <B>vi</B> te verlaten.</LI>
<LI> <B>CTRL-d</B> Be&euml;indig de tijdelijke shell en keer terug naar
<B>vi</B> zodat je het huidige venster kunt wijzigen.</LI>
<LI> <B>:</B><I>n</I> Ga naar de <I>n</I>-de regel in de buffer.</LI>
<LI> <B>:</B><I>x,z</I><B>w</B> <I>filename</I> Schrijf regel vanaf
het nummer <I>x</I> tot aan het nummer <I>z</I> naar het nieuwe bestand
genaamd <I>filename</I>.</LI>
<LI> <B>:$</B> Verplaats de cursor naar het begin van de laatste
regel in de buffer.</LI>
<LI> <B>:.,$d</B> Verwijder alle regels vanaf de huidige regel tot aan
de laatste regel.</LI>
<LI> <B>:r</B> <I>filename</I> Voegt de inhoud van het bestand 
<I>filename</I> toe onder de huidige regel van de buffer.</LI>
<LI> <B>:s</B><I>/text/new_text/</I> Vervangt het eerste voorkomen van
<I>text</I> op de huidige regel door <I>new_text</I></LI>
<LI> <B>:s</B><I>/text/new_text/g</I> Vervangt ieder voorkomen van
<I>text</I> op de huidige regel door <I>new_text</I></LI>
<LI> <B>:g</B><I>/text/s//new_text/g</I> Wijzigt ieder voorkomen van
<I>text</I> in de buffer naar <I>new_text</I>.</LI>
</UL>
<H2>10.21  Andere opdrachten</H2>

<P>
<UL>
<LI> <B>u</B> Maak de laatste wijziging ongedaan</LI>
<LI> <B>U</B> Herstel de huidige regel</LI>
<LI> <B>~</B> Wijzig grote letter in kleine letter en vice versa</LI>
<LI> <B>J</B> Voeg de huidige regel samen met de volgende regel</LI>
<LI> <B>.</B> Herhaal laatste tekstwijzigingsopdracht</LI>
<LI> <B>CTRL-g</B> Toon bestandsnaam en regelnummer</LI>
</UL>
<H2><A NAME="s11">11. Gerelateerde URL's</A></H2>

<P>Aan VIM gerelateerde URL's zijn te vinden bij -
<UL>
<LI> C and C++ Beautifer 
<A HREF="http://www.metalab.unc.edu/LDP/HOWTO/C-C++Beautifier-HOWTO.html">http://www.metalab.unc.edu/LDP/HOWTO/C-C++Beautifier-HOWTO.html</A></LI>
<LI> Linux goodies 
<A HREF="http://www.aldev.8m.com">http://www.aldev.8m.com</A> or bij 
<A HREF="http://www.aldev.webjump.com">http://www.aldev.webjump.com</A></LI>
</UL>
<H2><A NAME="s12">12. Andere Formaten van dit Document</A></H2>

<P>Dit document is in 10 verschillende formaten gepubliceerd, te weten - 
DVI, Postscript, Latex, LyX, GNU-info, HTML, RTF(Rich Text Format), 
Plain-text, Unix man pages en SGML.
<UL>
<LI>Je kunt dit HOWTO-document als een enkel tar-archief ophalen in HTML, DVI, 
Postscript of SGML-formaat vanaf -
<A HREF="ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/other-formats/">ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/other-formats/</A>
of 
<A HREF="ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/other-formats/">ftp://metalab.unc.edu/pub/Linux/docs/HOWTO/other-formats/</A></LI>
<LI>Plain tekstformaat is in: 
<A HREF="ftp://metalab.unc.edu/pub/Linux/docs/HOWTO">ftp://metalab.unc.edu/pub/Linux/docs/HOWTO</A>
of 
<A HREF="ftp://metalab.unc.edu/pub/Linux/docs/HOWTO">ftp://metalab.unc.edu/pub/Linux/docs/HOWTO</A></LI>
<LI>Vertalingen naar 't Frans, Duits, Spaans, Chinees, Japans staan in
<A HREF="ftp://metalab.unc.edu/pub/Linux/docs/HOWTO">ftp://metalab.unc.edu/pub/Linux/docs/HOWTO</A>
of 
<A HREF="ftp://metalab.unc.edu/pub/Linux/docs/HOWTO">ftp://metalab.unc.edu/pub/Linux/docs/HOWTO</A>
Alle hulp bij het vertalen naar andere talen is welkom.</LI>
</UL>

Het document is geschreven door gebruik te maken van een tool genaamd
"SGML tool" welke kan worden opgehaald vanaf - 
<A HREF="http://www.xs4all.nl/~cg/sgmltools/">http://www.xs4all.nl/~cg/sgmltools/</A>
Bij het compileren van de source krijg je met de volgende opdrachten
<P>
<UL>
<LI>sgml2html vim-howto.sgml     (een html-bestand)</LI>
<LI>sgml2rtf  vim-howto.sgml     (een RTF-bestand)</LI>
<LI>sgml2latex vim-howto.sgml    (een latex-bestand)</LI>
</UL>
<P>Dit document is te vinden op -
<UL>
<LI> 
<A HREF="http://metalab.unc.edu/LDP/HOWTO/Vim-HOWTO.html">http://metalab.unc.edu/LDP/HOWTO/Vim-HOWTO.html</A></LI>
</UL>
<P>Je kunt dit document ook vinden op de volgende mirror-sites -
<UL>
<LI> 
<A HREF="http://www.caldera.com/LDP/HOWTO/Vim-HOWTO.html">http://www.caldera.com/LDP/HOWTO/Vim-HOWTO.html</A></LI>
<LI> 
<A HREF="http://www.WGS.com/LDP/HOWTO/Vim-HOWTO.html">http://www.WGS.com/LDP/HOWTO/Vim-HOWTO.html</A></LI>
<LI> 
<A HREF="http://www.cc.gatech.edu/linux/LDP/HOWTO/Vim-HOWTO.html">http://www.cc.gatech.edu/linux/LDP/HOWTO/Vim-HOWTO.html</A></LI>
<LI> 
<A HREF="http://www.redhat.com/linux-info/ldp/HOWTO/Vim-HOWTO.html">http://www.redhat.com/linux-info/ldp/HOWTO/Vim-HOWTO.html</A></LI>
<LI> Andere mirror-sites in de buurt (netwerk-adres-wijsheid) zijn te
vinden op 
<A HREF="http://metalab.unc.edu/LDP/hmirrors.html">http://metalab.unc.edu/LDP/hmirrors.html</A>
selecteer een site en ga naar de directory /LDP/HOWTO/Vim-HOWTO.html</LI>
</UL>
<P>
<P>Gebruik het xdvi-programma om dit document in het dvi-formaat te bekijken.
Het xdvi-programma is te vinden in het
tetex-xdvi*.rpm package in Redhat Linux wat kan worden gevonden via de
ControlPanel | Applications | Publishing | TeX menu buttons.
<BLOCKQUOTE><CODE>
<PRE>
        Geef de volgende opdracht om het dvi-document te lezen -
                xdvi -geometry 80x90 howto.dvi
        En pas de grootte van het scherm met de muis aan. 
        Zie de manpage over xdvi. 
        Gebruik de pijltjestoetsen, Page Up, Page Down keys, om door
        het document te manoeuvreren, je kunt ook de
        'f', 'd', 'u', 'c', 'l', 'r', 'p', 'n' letter
        toetsen gebruiken om naar boven, onder, het midden, de volgende
        pagina, vorige pagina, enz te gaan.
        Druk op 'x' om het expert-menu uit te schakelen.
</PRE>
</CODE></BLOCKQUOTE>

Je kunt het postscript-bestand lezen met behulp van het programma 'gv' 
(ghostview) of 'ghostscript'.
Het ghostscript programma is te vinden in het ghostscript*.rpm package en
het gv programma is te vinden in het gv*.rpm package in Redhat Linux
welke kan worden gelokaliseerd via de ControlPanel | Applications | Graphics 
menu buttons. Het gv programma is veel gebruikersvriendelijker dan ghostscript.
Ghostscript en gv zijn ook voor andere platformen beschikbaar zoals OS/2,
Windows 95 en NT.
<BLOCKQUOTE><CODE>
<PRE>
        Geef de volgende opdracht om het postscript document te lezen -
                gv howto.ps

        Met gebruik van ghostscript geef je op -
                ghostscript howto.ps
</PRE>
</CODE></BLOCKQUOTE>
<P>Je kunt het HTML-formaat document lezen met Netscape Navigator, Microsoft
Internet explorer, Redhat Baron Web browser of enige andere webbrowsers.
<P>Je kunt de latex, LyX uitvoer lezen met LyX een "X-Windows" front end naar
latex.
<H2><A NAME="s13">13. Copyright Notice</A></H2>

<P>Copyright policy is GNU/GPL as per LDP (Linux Documentation project).
LDP is a GNU/GPL project.
Additional restrictions are - you must retain the author's name, email address
and this copyright notice on all the copies. If you make any changes 
or additions to this document than you should 
intimate all the authors of this document.
</BODY>
</HTML>
