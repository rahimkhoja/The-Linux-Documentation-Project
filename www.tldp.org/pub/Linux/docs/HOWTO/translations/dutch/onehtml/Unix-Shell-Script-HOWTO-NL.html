<HTML
><HEAD
><TITLE
>	Unix shell scripting		</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"></HEAD
><BODY
CLASS="ARTICLE"
BACKGROUND="../IMAGES/back.gif"
LINK="#000099"
><DIV
CLASS="ARTICLE"
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
></A
><SPAN
CLASS="ACRONYM"
>Unix</SPAN
> shell scripting</H1
><H3
CLASS="AUTHOR"
><A
NAME="AEN5"
> Daniel					  C.						    von Asmuth					</A
></H3
><P
CLASS="COPYRIGHT"
>Copyright &copy; 	2000						 	D.C.von Asmuth					</P
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Inhoudsopgave</B
></DT
><DT
><A
HREF="#SHELL"
><SPAN
CLASS="ACRONYM"
>Unix</SPAN
> en de shell</A
></DT
><DT
><A
HREF="#PROGRAMMEREN"
>elementair shell programmeren</A
></DT
><DT
><A
HREF="#TOOLS"
>enkele <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> tools</A
></DT
></DL
></DIV
><BLOCKQUOTE
CLASS="ABSTRACT"
><DIV
CLASS="ABSTRACT"
><A
NAME="AEN13"
></A
><P
></P
><P
>	Dit is een uitgebreide inleiding over het gebruik van de 
	<SPAN
CLASS="ACRONYM"
>Unix</SPAN
> shell en bijbehorende hulpmiddelen 
	om scripts te schrijven. 
	Het veronderstelt enige kennis van de <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> 
	commandoregel, bijvoorbeeld de bash-prompt-howto. 
	Het bevat wat meer voorbeelden dan de offici&euml;le 
	handleidingen. 
  </P
><P
></P
></DIV
></BLOCKQUOTE
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="SHELL"
></A
><SPAN
CLASS="ACRONYM"
>Unix</SPAN
> en de shell</H2
><P
>	De shell is de <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> `commandostip', 
	die opdrachten van 
	de gebruikers inleest van het toetsenbord, ze uitvoert 
	en het resultaat op het scherm zet. 
	In de simpelste vorm bestaat een opdracht uit de naam 
	van een programma; de shell zal dat programma dan 
	opstarten, dat de beschikking over het toetsenbord en 
	beeldscherm krijgt, en laat een nieuwe prompt zien als 
	het programma be&euml;indigd is.
  </P
><P
>	Het <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> besturingssysteem wordt wel 
	eens voorgesteld als bestaande uit een harde kern oftewel 
	kernel, die de hardware aanstuurt en hardware aanstuurt 
	en dat de shell een schil erom heen is, die de kernel van de 
	gebruikers afschermt. Het is echter de taak van de kernel 
	om de hardware af te schermen, terwijl de shell dient om 
	toegang tot het systeem te geven. Gebruikersprogramma's 
	hoeven geen gebruik van de shell te maken; de 
	C-bibliotheek heeft bijvoorbeeld wel de functie van een 
	schil om de kernel. 
  </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="INLEIDING"
></A
>inleiding</H3
><P
>	Dit verhaal gaat ervan uit dat u enige ervaring met 
	<SPAN
CLASS="ACRONYM"
>Unix</SPAN
> hebt en dus met het typen van 
	commando's in de shell. 
	Het kan nooit kwaad om de uitgebreide informatie over een 
	besproken commando op te vragen met 
	<B
CLASS="COMMAND"
>man commando</B
> of (op <SPAN
CLASS="ACRONYM"
>GNU</SPAN
> 
	systemen) <B
CLASS="COMMAND"
>info commando</B
>. 
  </P
><P
>	Er zijn verschillende varianten op het <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> 
	besturingssysteem; alle besturingssystemen die de hier 
	besproken commando's bezitten worden hier voor het gemak 
	met <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> aangeduid, ook al zijn ze niet 
	gebaseerd op de originele code van <SPAN
CLASS="ABBREV"
>A T &amp; T</SPAN
>. 
	Op een <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> systeem zijn vaak verschillende 
	shells te vinden. 
	Het is ook mogelijk om een shell te draaien op Windows 
	<SPAN
CLASS="ACRONYM"
>NT</SPAN
>&trade;. 
	De voorbeelden bij dit verhaal zijn getest onder Linux en 
	zullen op andere systemen soms aanpassing behoeven. 
  </P
><P
>	De oorspronkelijke <TT
CLASS="FILENAME"
>/bin/sh</TT
> is de Bourne 
	shell, en de andere zijn daarvan afgeleid. 
	De nummer twee was de C-shell, die handige features had om 
	processen te besturen, maar minder handig om ermee te 
	programmeren, en dus niet verder aan de orde zal komen. 
	De nieuwere Korn shell lijkt weer meer op de Bourne shell, 
	met de features van de C-shell, plus een hele reeks eigen 
	uitbreidingen voor interaktief gebruik en programmeren. 
	De Bourne Again Shell van het <SPAN
CLASS="ACRONYM"
>GNU</SPAN
> projekt 
	heeft eveneens een wijde verbreiding gekregen.
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="TRYOUT"
></A
>Mijn eerste scriptje</H3
><P
>	Het bijzondere aan de shell is dat hij zowel een handige 
	commandoverwerker is voor interaktief gebruik als een 
	programmeertaal. 
	Verschillende delen van een <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> 
	besturingssysteem bestaan uit shell scripts, omdat deze 
	gemakkelijk door de gebruiker aan diens behoefte kunnen 
	worden aangepast, wat vooral systeembeheerders waarderen. 
	Shell scripts worden ook vaak gebruikt als een schil om een 
	complexe applicatie. 
  </P
><P
>	Het is een kleine moeite om een korte reeks veel gebruikte 
	commando's samen te voegen tot een scriptje: maak met 
        <B
CLASS="COMMAND"
>vi</B
> 
	(c.q. uw favoriete editor) een file <TT
CLASS="FILENAME"
>voorbeeld</TT
>
	aan met de volgende, vrij willekeurige,  inhoud:
    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN47"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>date
uname -a
who 								</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>

	Vervolgens typt u
    <B
CLASS="COMMAND"
>	chmod ugo+rx voorbeeld
    </B
>
	waarmee het tekstbestand tot programma wordt gepromoveerd, 
	dat met
    <B
CLASS="COMMAND"
>	./voorbeeld
    </B
>
	kan worden uitgevoerd. De kernel is zelf in staat te bepalen 
	of een uit te voeren file een script of binair programma bevat. 

  </P
><P
>	In het voorbeeld is de directory waar het programma zich 
	bevindt expliciet opgegeven. 
	Als die wordt weggelaten zal de shell de lijst van directory's 
	doorzoeken die in de speciale variabele <TT
CLASS="ENVAR"
>$PATH</TT
> 
	staat. 
	Het is enigszins riskant om de aktuele directory 
	(<TT
CLASS="FILENAME"
>.</TT
>) in het zoekpad op te nemen.</P
><P
>	Een standaard vergissing is om eigen programma's de naam 
	<TT
CLASS="FILENAME"
>test</TT
> te geven. 
	Helaas is <I
CLASS="FIRSTTERM"
>test</I
> een ingebouwd commando 
	van de shell. 
	De shell heeft niet zoveel ingebouwde commando's: 
	het meeste werk wordt door externe programma's gedaan. &#13;</P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="HALLO"
></A
>hallo</H3
><P
>	Als volgende voorbeeld de nederlandstalige versie van het 
	onvermijdelijke nutteloze programma <I
CLASS="FIRSTTERM"
>hello</I
>, 
	bekend van Kernighan &amp; Ritchie.

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN61"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#!/bin/sh 
# dit programma zegt vriendelijk goedendag 

echo Hallo, allemaal! ; exit 0					</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>

	Dit lijkt al iets meer op een programma. 
	In de eerste regel staat achter <B
CLASS="COMMAND"
>#!</B
>  
	aangegeven welk programma het script moet uitvoeren. 
	Normaliter is dat de shell waarmee u inlogt; 
	u kunt hiermee voorkomen dat een programma niet werkt 
	als het bijvoorbeeld vanaf de C-shell wordt gestart. 
	Aan de andere kant zal een script dat begint met 
	<B
CLASS="COMMAND"
>#!/bin/bash</B
> niet werken op een systeem 
	waar die shell in <TT
CLASS="FILENAME"
>/usr/local/bin</TT
> 
	staat of afwezig is. 
	Deze eigenschap is vooral handig voor scripts in andere 
	talen, bijv.:

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN66"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#!/usr/bin/perl
print "Hallo, allemaal!\n"					</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>

	De programmeertaal <SPAN
CLASS="ACRONYM"
>Perl</SPAN
> wordt hier niet 
	verder behandeld. 
	Voor de rest geeft een hekje aan dat de rest van de regel 
	kommentaar is. 
	Een lege commandoregel is toegestaan. 
	Behalve het einde van de regel kan ook een puntkomma 
	worden gebruikt om opdrachten te scheiden die na elkaar 
	worden uitgevoerd.
  </P
><P
>	De opdracht <I
CLASS="FIRSTTERM"
>echo</I
> is een ingebouwde 
	functie van de shell, net als trouwens exit. 
	<B
CLASS="COMMAND"
>Echo</B
> zorgt ervoor dat de resterende 
	woorden op het 
	<I
CLASS="FIRSTTERM"
>standaard uitvoerkanaal</I
> (bijv. het 
	scherm) worden afgedrukt. 
	Shell commando's, argumenten en vlaggen moeten atlijd  
	van elkaar worden gescheiden door spaties of andere 
	scheidingstekens. 
  </P
><P
>	De opdracht <I
CLASS="FIRSTTERM"
>exit</I
> be&euml;indigt het 
	script, ook als er nog opdrachten volgen; het gebruik ervan 
	is niet verplicht. 
	Net als de exit functie in een C programma wordt er een foutcode 
	geretourneerd, die 0 bedraagt als er geen fout is opgetreden. 
	Typ maar eens de volgende regels in achter de prompt.

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN75"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>true
echo $? 
false
echo $?								</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>

	De variabele <TT
CLASS="ENVAR"
>$?</TT
> krijgt de 
	<I
CLASS="FIRSTTERM"
>exit status</I
> van het laatst uitgevoerde 
	commando of script. 
	Na exit of het einde van een script gaat de shell verder met 
	het aanroepende script of vraagt de gebruiker om invoer. 
	<B
CLASS="COMMAND"
>True</B
> en <B
CLASS="COMMAND"
>false</B
> zijn 
	externe programma's die niets doen en alleen in shell 
	programma's nut hebben. 
	Het resultaat verschilt nogal van Boolean types in 
	andere programmeertalen. 
  </P
><P
>	Als u inlogt zal de shell eerst het script 
	<TT
CLASS="FILENAME"
>/etc/profile</TT
>
	uitvoeren, waarin zich algemene instellingen bevinden, 
	gevolgd door <TT
CLASS="FILENAME"
>.profile</TT
> in uw eigen 
	directory, waarin u uw persoonlijke instellingen kwijt kunt. 
	Bash en ksh kennen ook initialisatie files 
	<TT
CLASS="FILENAME"
>~/.bashrc</TT
> en <TT
CLASS="FILENAME"
>~/.kshrc</TT
> 
	die iedere keer uitgevoerd worden 
	als een interactieve shell start, bijvoorbeeld bij 
	het openen van een xterm. 
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="HERHALING"
></A
>een herhalingsoefening</H3
><P
>	De rest van dit hoofdstuk wordt besteed aan <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> 
	en de shell, zonder dat er verder programmeren bij komt kijken. 
	De behandeling zal erg oppervlakkig blijven; in 
	<A
HREF="#TOOLS"
>paragraaf <I
>enkele <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> tools</I
></A
> komen we er uitgebreid op terug. 
  </P
><P
>	Het centrale concept in <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> is de 
	<I
CLASS="FIRSTTERM"
>file</I
> oftewel het bestand. 
	Files worden voortdurend gebruikt waar informatie voor 
	min of meer lange tijd moet worden bewaard. 
	Een file is een reeks bytes, die meestal op een schijf 
	wordt bewaard. 
	De belangrijkste operaties zijn het lezen of schrijven 
	van een aantal bytes. 
	Daarbij wordt de <I
CLASS="FIRSTTERM"
>file pointer</I
> 
	of bladwijzer om het aantal 
	gelezen of geschreven bytes verplaatst. 
	Verder is het mogelijk om de file pointer naar een 
	opgegeven punt te verplaatsen en de lengte van het 
	bestand in te krimpen tot bijvoorbeeld nul bytes.
  </P
><P
>	De inhoud van een bestand ligt niet vast. 
	<SPAN
CLASS="ACRONYM"
>Unix</SPAN
> maakt vaak gebruik van tekstbestanden. 
	Een byte staat dan voor een letterteken (karakter) van  
	het <SPAN
CLASS="ACRONYM"
>ASCII</SPAN
> alfabet. 
	Het teken &lt;LF&gt; oftewel 0xa oftwel ^J oftewel \n 
	geeft het einde van een regel aan. 
	Er is geen teken nodig om het einde van een bestand te markeren,
        maar ^D kan worden gebruikt om invoer van de terminal te
	be&euml;indigen.   
  </P
><P
>	Veel tools gaan ervan uit dat een bestand tekst bevat. 
	Bijvoorbeeld zal
	<B
CLASS="COMMAND"
>cat voorbeeld</B
>
	de inhoud van het bestand over het scherm laten lopen. 
	Als het bestand echter geen tekst bevat, dan kan de 
	terminal de kluts kwijt raken van de stuurcodes; 
	doe dus geen
	<B
CLASS="COMMAND"
>/bin/cat /bin/cat</B
>.
	Met <B
CLASS="COMMAND"
>cat -v</B
> loopt u geen gevaar.
  </P
><P
>	In sommige Unices kunt u de schade repareren met 
	het commando <B
CLASS="COMMAND"
>reset</B
>. 
	De oude methode is de terminal uit en weer aan te zetten. 
	De schade is te voorkomen. 
	Het kommando <B
CLASS="COMMAND"
>file hallo</B
>
	zou iets moeten geven als
	<TT
CLASS="COMPUTEROUTPUT"
>hallo: Bourne shell script text</TT
>.
  </P
><P
>	Als file een frase met het woord `executable' erin retourneert, 
	hebben we te maken met een binair programma. 
	Een binair programma kun je alleen uitvoeren: dat werkt wel 
	een stuk sneller dan een ingewikkeld shell script. 
	File kan zich ondanks zijn `magic' uiteraard vergissen. 
  </P
><P
>	Verder zijn er speciale files, waarmee bijvoorbeeld apparaten 
	kunnen worden afgelezen of beschreven alsof het files waren; 
	een tape wordt bijvoorbeeld bediend als een hele lange 
	pseudo-file, waarvan de grootte aan een vast maximum is 
	gebonden. 
	Deze worden vaak in de <TT
CLASS="FILENAME"
>/dev</TT
> directory 
	gevonden. 
  </P
><P
>	Tekst die naar <TT
CLASS="FILENAME"
>/dev/tty</TT
> wordt geschreven, 
	wordt wel zichtbaar gemaakt, maar niet opgeslagen. 
	Een poging om <TT
CLASS="FILENAME"
>/dev/tty</TT
> uit te lezen 
	retourneert niet de geschreven tekst, maar van het toetsenbord 
	ingevoerde tekens. 
	<SPAN
CLASS="ACRONYM"
>Unix</SPAN
> zal u laten wachten totdat er een regel 
	is ingevoerd, c.q. op de return-toets is gedrukt. 
  </P
><P
>	Om een tekstbestand uit te printen zou je 
	<B
CLASS="COMMAND"
>cat hallo &gt;/dev/lp0</B
>
	of iets dergelijks kunnen doen, maar <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> 
	staat dat enkel aan de user <I
CLASS="FIRSTTERM"
>root</I
> toe.  
	De juiste manier om een bestand te printen is via het printer 
	spoolprogramma met <B
CLASS="COMMAND"
>lpr hallo</B
>
  </P
><P
>	Een ander bestand dat in scripts gebruikt kan worden is 
	<TT
CLASS="FILENAME"
>/dev/null</TT
>, ook wel de bittenbak genoemd, 
	omdat alle data die er naartoe worden geschreven direkt 
	worden weggegooid in tegenstelling tot de vuilnisbak van 
	de Macintosh&trade;. 
	Lezen uit <TT
CLASS="FILENAME"
>/dev/null</TT
> is toegestaan, maar 
	er zal niets uit komen. 
  </P
><P
>	De <I
CLASS="FIRSTTERM"
>directory's</I
> kunnen worden beschouwd 
	als een speciaal soort bestand, dat alleen met 
	speciale opdrachten als <B
CLASS="COMMAND"
>ls</B
>, 
	<B
CLASS="COMMAND"
>cp</B
>, <B
CLASS="COMMAND"
>mv</B
>, 
	<B
CLASS="COMMAND"
>rm</B
> en <B
CLASS="COMMAND"
>ln</B
> kan worden 
	gemanipuleerd. 
	Directory's bevatten weinig anders als de namen van files 
	en directory's. 
	Daarom is voor een opdracht als 
	<B
CLASS="COMMAND"
>rm -f ./voorbeeld</B
>
	schrijfpermissie op de aktuele directory vereist, maar geen 
	permissie op het bestand. 
	In scripts gebruiken we vaak de <TT
CLASS="OPTION"
>-f</TT
> optie,
	zodat <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> niet nog eens vraagt of we het wel 
	zeker weten.
  </P
><P
> 
	Een file kan meerdere namen of <I
CLASS="FIRSTTERM"
>links</I
> 
	hebben; met het commando <B
CLASS="COMMAND"
>ln</B
> wordt een 
	nieuwe link naar een bestaand bestand gelegd. 
	<B
CLASS="COMMAND"
>ln /bin/ls /bin/dir</B
>
	maakt een nieuw commando, <B
CLASS="COMMAND"
>dir</B
> geheten, 
	dat hetzelfde doet als <B
CLASS="COMMAND"
>ls</B
>. 
	Met <B
CLASS="COMMAND"
>rm</B
> wordt het aantal links met 
	&eacute;&eacute;n verminderd. 
	Pas wanneer dat tot nul is gedaald en het bestand niet 
	in gebruik is, zal <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> het bestand 
	daadwerkelijk verwijderen. 
  </P
><P
>	Het is niet mogelijk naar een link te maken naar een directory 
	of een bestand op een andere schijf. 
	Deze beperking wordt opgeheven door de 
	<I
CLASS="FIRSTTERM"
>symbolic link</I
> of snelkoppeling, 
	die je maakt met <B
CLASS="COMMAND"
>ln -s</B
>. 
	Een snelkoppeling loopt het gevaar dat het bestand waar hij 
	naar verwijst niet bestaat of dat een circulaire keten van 
	links ontstaat. 
	Vergelijk de uitvoer van <B
CLASS="COMMAND"
>ls -lL</B
> eens
	met <B
CLASS="COMMAND"
>ls -l</B
>. 
    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN144"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>-rwxr-xr-x 1 daniel users 769 Mai 29 example
-rwxr-xr-x 1 daniel users 769 Mai 29 voorbeeld

lrwxrwxrwx 2 daniel users   3 Jun 6 example -&#62; wie
lrwxrwxrwx 2 daniel users   3 Jun 6 voorbeeld -&#62; wie		</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PROCESSEN"
></A
>processen en hun in- en uitvoer</H3
><P
>	We zagen al dat een programma in <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> 
	wordt opgeslagen in een bestand. 
	Een <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> <I
CLASS="FIRSTTERM"
>proces</I
> 
	is een lopend programma, met zijn data en de context waarin 
	het draait zoals de huidige directory. 
	Moderne besturingssystemen kunnen een proces verdelen in 
	zgn. <I
CLASS="FIRSTTERM"
>threads;</I
> 
	en programma kan daarmee meerdere taken tegelijk uitvoeren, 
	die hun data delen, wat al snel in een chaos kan ontaarden.
  </P
><P
>	De shell zal, met uitzondering van ingebouwde opdrachten, 
	commando's uitvoeren door er aparte processen voor te starten. 
	Shell scripts worden doorgaans in afzonderlijke processen 
	(subshells) uitgevoerd. 
	Ondanks dat <SPAN
CLASS="ACRONYM"
>Unix</SPAN
>' 
	<I
CLASS="FIRSTTERM"
>multi-tasking</I
> effici&euml;nter 
	werkt dan huis-, tuin- en keuken besturingssystemen, maakt 
	het voortdurende maken en opruimen van processen shell 
	scripts een stuk langzamer dan andere programmeertalen. 
  </P
><P
>	Als een extern programma is opgestart zal de shell gewoon 
	wachten totdat hij een seintje ontvangt van de kernel dat het 
	kindproces is gestorven c.q. be&euml;indigd.
  </P
><P
>	Door een `ampersand' achter een commando te zetten als in
	<B
CLASS="COMMAND"
>voorbeeld&#38;</B
>, zal het `in de achtergrond' 
	worden verwerkt, en de shell onmiddellijk om de volgende 
	opdracht vragen.
  </P
><P
>	Een voorbeeld van een ingebouwde opdracht is het commando 
	<B
CLASS="COMMAND"
>cd</B
>. 
	Beginners verbazen zich er soms over dat een 
	<B
CLASS="COMMAND"
>cd</B
> opdracht binnen een shell script 
	wel wordt uitgevoerd, maar het effekt ervan vergeten is 
	als het script be&euml;indigd is en terug keert naar de 
	interactieve shell. 
  </P
><P
>	Commando's in een script kunnen ook worden uitgevoerd met bijv.
	<B
CLASS="COMMAND"
>. ./voorbeeld</B
>.
	Hiermee worden de opdrachten in het bestand voorbeeld 
	binnen de lopende shell uitgevoerd en werkt <B
CLASS="COMMAND"
>cd</B
>
	bijvoorbeeld wel. 
	Een minder gebruikte mogelijkheid is om programma's (niet 
	alleen scripts) te starten met de opdracht <B
CLASS="COMMAND"
>exec</B
> 
	ervoor. 
	Er wordt dan geen apart proces gemaakt, maar het nieuwe 
	programma wordt in het lopende proces geladen en vervangt het,  
	zodat het oorspronkelijke programma na afloop niet verder kan 
	gaan. 
  </P
><P
>	Tot de context van een proces behoren ook de 
	standaard invoer-, uitvoer- en error-kanalen. 
	Voor een interactieve shell verwijst de standaard invoer naar
	het toetsenbord en de uitvoer en error kanalen naar het 
	beeldscherm. 
	Als u bent ingelogd via een modem of netwerk, dan verwijzen 
	deze kanalen naar uw scherm en toetsenbord in plaats 
	van dat van de computer waarop de shell draait.
  </P
><P
>	Met <B
CLASS="COMMAND"
>./voorbeeld &lt;data &gt;resultaat</B
>
	worden de kanalen omgeleid zodat de inhoud van het bestand 
	<TT
CLASS="FILENAME"
>data</TT
> zal worden gelezen en de uitvoer 
	in het bestand <TT
CLASS="FILENAME"
>resultaat</TT
> komt. 
	Eventuele foutmeldingen komen nog op het scherm. 
  </P
><P
>	De notatie 
	<B
CLASS="COMMAND"
>./voorbeeld &lt;data &gt;&thinsp;&gt;resultaat 2&#62;&#38;1 &#38;</B
>
  	zegt dat het script in de achtergrond moet draaien. 
	We zien toch geen resultaten. 
	Het dubbele `groter dan' teken geeft aan dat de uitvoer 
	achter de bestaande inhoud van <TT
CLASS="FILENAME"
>resultaat</TT
> 
	moet komen in plaats van het bestand eerst te wissen. 
  </P
><P
>	De aanduiding <B
CLASS="COMMAND"
>2&#62;&#38;1</B
> geeft aan dat het 
	standaard error-kanaal (de tweede 
	<I
CLASS="FIRSTTERM"
>file-descriptor)</I
> een kopie is van 
	nummer 1 (standaard uitvoer), dus foutmeldingen en resultaten 
	verschijnen door elkaar heen in het bestand 
	<TT
CLASS="FILENAME"
>resultaat</TT
>; 
	het standaard-invoerkanaal heeft file-descriptor nummer 0. 
	Kind processen erven file-descriptors (open bestanden); 
	de standaard kanalen zijn altijd open. 
	Als de standaard kanalen zijn omgeleid naar bestanden zijn 
	toetsenbord en beeldscherm toch te benaderen door om te leiden 
	naar het pseudo-bestand <TT
CLASS="FILENAME"
>/dev/tty</TT
>. 
  </P
><P
>	Een <I
CLASS="FIRSTTERM"
>here-document</I
> is een bijzonder 
	geval van omleiding waarin de te verwerken gegevens in het 
	script-bestand zelf staan. 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN181"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>fox=dog; dog=fox
cat &lt;&thinsp;&lt;woord
The quick brown $fox jumps over the lazy $dog. 
&hellip;
woord 								</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>

	De rest van het script tot aan woord wordt dan als invoer 
	gebruikt voor het commando (bijv. <B
CLASS="COMMAND"
>cat</B
>). 
	Het woord dat als markering dient moet letterlijk worden 
	herhaald op een aparte regel. 
	De shell zal wel eventuele substituties uitvoeren op de data. 
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="WILDCARDS"
></A
>een les over `ls': jokertekens</H3
><P
>	Het volgende commando is een eenvoudige vervanging voor 
	<I
CLASS="FIRSTTERM"
>ls</I
>.
    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN188"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
> 
echo * | tr  " " "\n" | column					</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Het illustreert hoe de shell <I
CLASS="FIRSTTERM"
>jokertekens</I
> 
	of wildcards behandelt. 
	Als er in een woord een jokerteken voorkomt, dan zal de 
	shell dat woord vervangen door alle bestandsnamen in 
	de huidige directory die overeenkomen met dat zoekpatroon. 
  </P
><P
>	De <TT
CLASS="LITERAL"
>*</TT
> staat voor iedere reeks van nul 
	of meer tekens, dus <B
CLASS="COMMAND"
>ls a*z</B
> geeft de 
	lijst van alle bestanden waarvan de naam begint met een 
	a en eindigt op z, zoals `alcatraz' (onder DOS/Windows 
	kunt u de * alleen aan het eind gebruiken). 
	Als er geen corresponderende bestanden zijn dan blijft 
	de asterisk staan, bijv.
	<B
CLASS="COMMAND"
>	echo Wie*dit*leest*is*gek		</B
>
  </P
><P
>	Het is mogelijk te voorkomen dat jokertekens worden 
	vervangen door ze tussen aanhalingstekens te zetten 
	of door er een backslash (<TT
CLASS="LITERAL"
>\</TT
>) voor 
	te zetten; 
	<B
CLASS="COMMAND"
>	ls \* 					</B
>
	komt van pas, want een bestand met de naam 
	<TT
CLASS="LITERAL"
>*</TT
> is niet uitgesloten. 
  </P
><P
>	Een <TT
CLASS="LITERAL"
>.</TT
> corrrespondeert met een 
	willekeurig teken, zodat de shell <TT
CLASS="LITERAL"
>p?n</TT
> 
	kan vervangen door <TT
CLASS="LITERAL"
>pan pen pin pon</TT
>. 
	Een reeks van tekens tussen rechte haken kan worden 
	vervangen door &eacute;&eacute;n van die tekens, bijv. 
	<B
CLASS="COMMAND"
>ls fig-[123456789].jpg</B
> door 
	<TT
CLASS="LITERAL"
>ls fig-1.jpg fig-2.jpg				</TT
> 
  </P
><P
>	Let erop dat <B
CLASS="COMMAND"
>ls *</B
> ook de inhoud van 
	subdirectory's weergeeft. 
	<B
CLASS="COMMAND"
>ls</B
> geeft alleen files in de huidige 
	directory en <B
CLASS="COMMAND"
>ls */</B
> geeft de 
	inhoud van alle subdirectory's. 
 </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PIJPLEIDINGEN"
></A
>pijpleidingen</H3
><P
>	Twee processen kunnen gemakkelijk via een 
	<I
CLASS="FIRSTTERM"
>pijp</I
> gekoppeld worden, zodat 
	data die uit de standaard uitvoer van het eerste proces 
	komen, door de standaard invoer van het tweede proces 
	worden verwerkt, bijv.:
	<B
CLASS="COMMAND"
>ps -ef | sort</B
>
  </P
><P
>	Het eerste commando geeft een lijst van alle processen 
	die momenteel draaien en het <B
CLASS="COMMAND"
>sort</B
> 
	commando sorteert ze (op de inlognaam van de gebruiker; 
	werkt helaas niet op alle <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> versies 
	gelijk). 
	Als in een pijp een commando wordt gebruikt dat een 
	filenaam als argument nodig heeft, dan kan meestal `-' 
	worden gebruikt om de standaard invoer aan te duiden; 
	veel commando's gebruiken automatisch de standaard invoer als 
	ze geen bestandsnaam meekrijgen. 
  </P
><P
>	Een programma dat data van het standaard invoerkanaal 
	leest en na een eenvoudige bewerking naar het standaard 
	uitvoerkanaal schrijft noemen we een <I
CLASS="FIRSTTERM"
>filter.</I
>
	Het eenvoudigste filter is <I
CLASS="FIRSTTERM"
>cat,</I
> 
	dat data onveranderd kopieert; <I
CLASS="FIRSTTERM"
>sort</I
> 
	is ingewikkelder. 
  </P
><P
>	Een ander filter is <I
CLASS="FIRSTTERM"
>dd;</I
>.
	Voor details zie <A
HREF="#SPLIT"
>paragraaf <I
>split en dd</I
></A
>; hier volgt een 
	voorbeeld hoe je een bestand kunt converteren 
	naar hoofdletters: 
	<B
CLASS="COMMAND"
>dd conv=ucase &lt;voorbeeld &gt;gesorteerd 
	2&gt;/dev/null</B
>
  </P
><P
> 
	Dd wordt onder <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> wel gebruikt om een floppy 
	disk te kopi&euml;ren met  
	<B
CLASS="COMMAND"
>dd if=/dev/fd0 of=image-file</B
>
	Vervolgens verwissel je de disks en kopi&euml;ert de 
	image file terug naar floppy. 
  </P
><P
>	Vergelijk het resultaat van  
	<B
CLASS="COMMAND"
>find /bin | sort</B
> 
	eens met <B
CLASS="COMMAND"
>ls -1 /bin/*</B
>
	en u ziet dat <B
CLASS="COMMAND"
>ls</B
> de gewoonte heeft de 
	uitvoer te sorteren. 
	Bij gebruik van een pijp wordt de uitvoer van het eerste 
	proces opgeslagen in een kleine hoeveelheid buffergeheugen. 
	Als dat vol is, wordt de producent stilgezet totdat de 
	consument deze data heeft verwerkt. 
  </P
><P
>	Om de uitvoer van een commando op het scherm te bekijken 
	en tegelijk een kopie in een bestand te bewaren gebruikt men 
	iets als
	<B
CLASS="COMMAND"
>./voorbeeld 2&#62;&#38;1 | tee resultaat</B
> 
  </P
><P
>	Als u beschikt over het tooltje 
	<A
HREF="http://199.103.168.8:4984/web1/hak/netcat.html"
TARGET="_top"
>	  <I
CLASS="FIRSTTERM"
>netcat</I
> 
	</A
>
	dan kunt u ook op eenvoudige wijze gegevens over 
	een netwerk versturen. 
	In plaats van <B
CLASS="COMMAND"
>prog1 | prog2</B
> start u op 
	machine <TT
CLASS="REPLACEABLE"
><I
>host</I
></TT
> 
	<B
CLASS="COMMAND"
>netcat -v -l -p 1234 | <TT
CLASS="REPLACEABLE"
><I
>prog2</I
></TT
></B
> 
	en op de andere machine doet u
	<B
CLASS="COMMAND"
><TT
CLASS="REPLACEABLE"
><I
>prog1</I
></TT
> | netcat host 1234</B
> 
	Hierin is <TT
CLASS="LITERAL"
>1234</TT
> de gebruikte 
	<SPAN
CLASS="ACRONYM"
>IP</SPAN
> poort: een min of meer willekeurig 
	nummer, mits de betreffende poort nog ongebruikt is, en 
	<TT
CLASS="VARNAME"
>prog1</TT
> en <TT
CLASS="VARNAME"
>prog2</TT
> zijn 
	willekeurige commando's. 
	Netcat fungeert hierin als een pijp tussen processen op 
	verschillende computers. 
  </P
><P
>	Alle <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> versies kennen de bovengenoemde 
	<I
CLASS="FIRSTTERM"
>anonieme pijp;</I
> 
	sommige kennen ook een pijp die als een speciale file in het 
	bestandssysteem voorkomt. 
	Een pijp kan worden aangemaakt met 
	<B
CLASS="COMMAND"
>mkfifo pijp</B
> of
	<B
CLASS="COMMAND"
>mknod pijp p</B
>
	Het <I
CLASS="FIRSTTERM"
>mknod</I
> commando wordt ook gebruikt 
	om speciale files van het <I
CLASS="FIRSTTERM"
>block</I
> of 
	<I
CLASS="FIRSTTERM"
>character</I
> type aan te maken. 
	Probeer maar eens welke output het <B
CLASS="COMMAND"
>file</B
> commando 
	op een speciale file geeft. 
  </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="PROGRAMMEREN"
></A
>elementair shell programmeren</H2
><P
>	
	In dit artikel wordt de shell geprogrammeerd met 
	behulp van script files. 
	Moderne shells bezitten bovendien de mogelijkheid 
	om korte macro's te defini&euml;ren met de 
	<I
CLASS="FIRSTTERM"
>alias</I
> opdracht
	bijv. <B
CLASS="COMMAND"
>alias l='ls -alg '</B
>
  </P
><P
>	Aliassen kunnen ingewikkelde commando's vervangen 
	door eenvoudiger te onthouden namen. 
	Ze worden vaak gedefinieerd in 
	<TT
CLASS="FILENAME"
>~/.profile</TT
>, een shell script 
	dat elke keer als iemand inlogt wordt uitgevoerd. 
	Met <I
CLASS="FIRSTTERM"
>unalias</I
> wordt de 
	definitie weer verwijderd. 
  </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="VARIABELEN"
></A
>variabelen</H3
><P
>	
	De werking van de shell is vrij ingewikkeld. 
	Er zijn verschillende manieren waarop de shell 
	reeksen tekens zal vervangen door andere. 
	Een daarvan is de expansie van aliassen: 
	het kommando <B
CLASS="COMMAND"
>l ~/*/a* </B
>
	kan worden uitgeschreven tot bijvoorbeeld
    <TT
CLASS="COMPUTEROUTPUT"
>	/bin/ls -alg /home/gast/agf/aardappel 
	/home/gast/agf/aardbei /home/gast/agf/appel 
	/home/gast/autos/audi
    </TT
>
  </P
><P
>	De alias kwamen we zojuist tegen; aan 'ls' is hier 
	het pad toegevoegd. 
	De tilde staat voor de <I
CLASS="FIRSTTERM"
>home directory</I
>, 
	waarop de gebruiker `gast' inlogt; de uitdrukking `a*' 
	wordt door de shell vervangen door een lijst van 
	filenamen die met een a beginnen. 
  </P
><P
>	Een <I
CLASS="FIRSTTERM"
>variabele</I
> is een naam, 
	die door de shell aan een reeks tekens wordt gekoppeld 
	met bijv. <B
CLASS="COMMAND"
>L='ls -alg '</B
>
  </P
><P
>	Het kommando <B
CLASS="COMMAND"
>set</B
> zonder argumenten 
	geeft een lijst van alle op dat moment gedefinieerde
	variabelen met hun waarden. 
	De shell heeft zelf een aantal ingebouwde variabelen 
	en andere variabelen worden bij het inloggen gedefinieerd, 
	zoals <TT
CLASS="ENVAR"
>$HOME</TT
>, de home directory van de gebruiker 
	en <TT
CLASS="ENVAR"
>$PWD</TT
>, de huidige directory. 
  </P
><P
>	We zijn ook al de variabele <TT
CLASS="ENVAR"
>$PATH</TT
> tegengekomen, 
	ook wel het zoekpad genoemd. 
	De waarde van <TT
CLASS="ENVAR"
>$PATH</TT
> is een lijst van directory's, 
	gescheiden door dubbele punten. 
	Als een commando dat geen slash (/) in de naam heeft, 
	niet is ingebouwd in de shell of als alias is 
	gedefinieerd, wordt gezocht of het commando overeenkomt 
	met de naam van een file in een van deze directory's. 
  </P
><P
>	Hetzelfde kunt u doen met het <B
CLASS="COMMAND"
>which</B
> commando, 
	dat echter niet op alle <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> systemen bestaat, 
	of waarvoor soms een alternatief <B
CLASS="COMMAND"
>whence</B
> voor 
	bestaat. 
	Voorbeeld: <B
CLASS="COMMAND"
>which find</B
>
  </P
><P
>	De shell zal een dollarteken gevolgd door de naam van een 
	variabele vervangen door de waarde van de betreffende variabele. 
	Nu kunnen we hetzelfde effekt als voorheen krijgen met
	<B
CLASS="COMMAND"
>$L</B
>.
  </P
><P
>	Hadden we echter L de waarde `l' gegeven, dan zou het resultaat 
	geweest zijn: 
	<TT
CLASS="COMPUTEROUTPUT"
>l: command not found			</TT
>
	Bash en ksh brengen ons in dit geval verder met
	<B
CLASS="COMMAND"
>eval $L</B
> 
	Hiermee wordt de uitdrukking `l' nog eens ge&euml;valueerd, 
	nadat de shell de waarde van L 
	heeft gesubstitueerd. 
	Een opdrachtregel als
	<B
CLASS="COMMAND"
>$apenkool</B
>
	zal niets doen en ook geen foutmelding opleveren als de 
	betreffende variabele niet gedefinieerd is. 
  </P
><P
>  	We krijgen de waarde van de variabele <TT
CLASS="ENVAR"
>L</TT
> terug 
	met <B
CLASS="COMMAND"
>echo $L</B
>. 
	Het dollarteken maakt eigenlijk geen deel uit van de naam. 
	Als we nu een script of ander programma aanroepen waarin de 
	waarde van variabele L gebruikt wordt, zal die echter 
	ongedefinieerd zijn, tenzij we eerst de opdracht
	<B
CLASS="COMMAND"
>export L</B
>
	geven om een lokale variabele te exporteren naar de 
	programma-omgeving. 
	Echo en export zijn ingebouwde functies van de shell. 
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AANHALING"
></A
>aanhaling</H3
><P
>	
	In de vorige paragraaf werd de waarde die aan L werd 
	toegewezen omgeven door enkele aanhalingstekens. 
	Deze zijn nodig om van de uitdrukking &eacute;&eacute;n 
	woord te maken, inclusief de spaties. 
	Dubbele aanhalingstekens hadden ook voldaan. 
	Het verschil is, dat binnen dubbele aanhalingstekens de 
	variabelen nog steeds worden vervangen door hun waarde, 
	en alleen tekst tussen enkele aanhalingstekens letterlijk 
	wordt overgenomen. 
  </P
><P
>	Tussen dubbele aanhalingstekens bestaat nog de mogelijkheid 
	om aan te geven dat een enkel teken exact moet worden 
	gekopi&euml;erd; 
	dit gebeurt door er een backslash voor te zetten als 
	<I
CLASS="FIRSTTERM"
>escape symbool</I
>. 
  </P
><P
>	De programmeertaal C definieert een aantal escape
	symbolen, die ook in de shell kunnen worden gebruikt.
    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="LITERAL"
>\a</TT
>	(alert)</DT
><DD
><P
>	&lt;BELL&gt; (laat een pieptoon horen)	</P
></DD
><DT
><TT
CLASS="LITERAL"
>\b</TT
>	(backspace)</DT
><DD
><P
>	&lt;BS&gt; verplaatst de cursor een stap 
			terug. (`x\bx' kan worden gebruikt om 
			een x vet af te drukken.)		</P
></DD
><DT
><TT
CLASS="LITERAL"
>\f</TT
>	(formfeed)</DT
><DD
><P
>	&lt;FF&gt; geeft een nieuwe pagina	</P
></DD
><DT
><TT
CLASS="LITERAL"
>\n</TT
>	(newline)</DT
><DD
><P
>	&lt;LF&gt; geeft een nieuwe regel	</P
></DD
><DT
><TT
CLASS="LITERAL"
>\r</TT
>	(carriage return)</DT
><DD
><P
>	&lt;CR&gt; verplaatst de cursor terug 
			naar het begin van de regel		</P
></DD
><DT
><TT
CLASS="LITERAL"
>\t</TT
>	(tabulator)</DT
><DD
><P
>	&lt;TAB&gt; verplaatst de cursor naar
			de volgende tab-stop			</P
></DD
><DT
><TT
CLASS="LITERAL"
>\t</TT
>	(vertical tab)</DT
><DD
><P
>	&lt;VT&gt; verplaatst de cursor een stap
			omlaag					</P
></DD
></DL
></DIV
>

	Verder kunnen <SPAN
CLASS="ACRONYM"
>ASCII</SPAN
> tekens worden 
	aangeduid in octale notatie, bijvoorbeeld \007 (ook \a) 
	voor het &lt;BELL&gt; teken. 
  </P
><P
>	Hierbij zij aangetekend dat de echo opdracht van de shell 
	van zichzelf een &lt;LF&gt; (regeleinde) toevoegt, tenzij 
	er <B
CLASS="COMMAND"
>echo -n</B
> is gebruikt; 
	gebruikers van bash moeten echo de <TT
CLASS="OPTION"
>-e</TT
> 
	vlag meegeven om de escapes te laten werken. 
	Het resultaat kan verschillen als er oktale codes boven 0200 
	worden gebruikt. 
  </P
><P
>	Een speciale functie van de shell is de 
	<I
CLASS="FIRSTTERM"
>commando substitutie</I
>, aangegeven door 
	achterwaartse aanhalingstekens, bijv.
	<B
CLASS="COMMAND"
>L=`l`</B
> 
	Hier wordt een aparte subshell gestart, waarin het commando 
	<B
CLASS="COMMAND"
>ls -alg</B
> wordt uitgevoerd; 
	het resultaat is weer te zien met
	<B
CLASS="COMMAND"
>echo "$L"</B
> 
  </P
><P
>	Probeer nu maar eens wat er gebeurt als de dubbele 
	aanhalingstekens worden weggelaten. 
	Een alternatieve notatie is om de te substitueren opdracht 
	tussen <TT
CLASS="LITERAL"
>$(</TT
> en <TT
CLASS="LITERAL"
>)</TT
> te zetten. 
	Daarmee kunnen gesubstitueerde processen bovendien genesteld 
	worden. 
	Let op het verschil tussen de notaties 
	<B
CLASS="COMMAND"
>$( lijst;van;commando's)</B
> en
	<B
CLASS="COMMAND"
>(lijst;van;commando's)</B
>: beide voeren de 
	opgegeven opdrachten uit in een aparte subshell, maar 
	waar de uitvoer van de tweede variant gewoon tussen de 
	standaard uitvoer verschijnt, wordt de uitvoer in het eerste 
	geval een deel van de opdrachtregel. 
  </P
><P
>	Om een variabele af te scheiden van de rest van de tekst kan 
	deze worden omgeven door dubbele aanhalingtekens of door 
	accolades, zodat de volgende uitdrukkingen alle de waarde van 
	de variabele <TT
CLASS="ENVAR"
>L</TT
> evalueren en er de letters `OVE' 
	achter plakken.
    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN355"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>echo "$L"OVE
echo ${L}OVE
echo "${L}OVE"							</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
	De beperkingen van de shell als programmeertaal worden 
	duidelijk als je bij de variabele <TT
CLASS="ENVAR"
>i</TT
>
	1 wilt optellen. 
	Rekenen is mogelijk met behulp van het hulpprogramma 
	<I
CLASS="FIRSTTERM"
>expr</I
>, bijv. 
	<B
CLASS="COMMAND"
>i=$(expr $i + 1)</B
>
	Let erop dat de shell spaties nodig heeft om de woorden 
	te onderscheiden. 
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PARAMETERS"
></A
>parameters</H3
><P
>	
	We hebben inmiddels enkele manieren gezien waarop de 
	shell ingevoerde tekens bewerkt, zoals de substitutie 
	van variabelen en verwijderen van aanhalingstekens. 
	Vervolgens wordt een commando in woorden opgeknipt, 
	waarbij witruimte de scheiding tussen de woorden aangeeft. 
	De variabele <TT
CLASS="ENVAR"
>IFS</TT
> bevat de tekens die 
	hierbij als scheidingsteken worden gebruikt, 
	standaard zijn dit &lt;SP&gt;, &lt;TAB&gt; en &lt;LF&gt;. 
	Let erop dat een uitdrukking tussen enkele of dubbele 
	aanhalingstekens altijd als een woord wordt gezien, 
	ook al bevat ze spaties. 
	Twee aanhalingstekens direkt achter elkaar tellen 
	als een woord met lengte nul (0). 
  </P
><P
>	In een shell script zijn de parameters (c.q. argumenten 
	en vlaggen) beschikbaar via de speciale variabelen 
	<TT
CLASS="ENVAR"
>$0</TT
> t/m <TT
CLASS="ENVAR"
>$9</TT
> (en zonodig ook 
	<TT
CLASS="ENVAR"
>${10}</TT
> en hoger). 
	<TT
CLASS="ENVAR"
>$0</TT
> is de naam van het programma zelf. 
	Daarmee is het mogelijk om bijvoorbeeld 
	<I
CLASS="FIRSTTERM"
>gunzip</I
> een link naar 
	<I
CLASS="FIRSTTERM"
>gzip</I
> te laten zijn en het programma 
	verschillend te laten werken afhankelijk van de naam 
	waarmee het is aangeroepen. 
  </P
><P
>	De shell kent nog een aantal speciale parameters; 
	we zijn <TT
CLASS="ENVAR"
>$?</TT
> al tegengekomen, dat telkens de 
	exit status van het laatste uitgevoerde commando krijgt. 
	<TT
CLASS="ENVAR"
>$$</TT
> bevat het <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> 
	proces nummer van de shell die uw script draait. 
	Dit kan ook handig zijn om unieke filenamen te maken voor 
	tijdelijke bestanden. 
  </P
><P
>	De parameters <TT
CLASS="ENVAR"
>$*</TT
> en <TT
CLASS="ENVAR"
>$@</TT
> leveren 
	de complete parameterlijst op, met uitzondering van 
	<TT
CLASS="ENVAR"
>$0</TT
>.  
	Tussen dubbele aanhalings tekens gezet zal 
	<TT
CLASS="ENVAR"
>"$*"</TT
> een woord opleveren dat overeenkomt 
	met <TT
CLASS="COMPUTEROUTPUT"
>"$1 $2 $3&hellip;"</TT
>, 
	terwijl <TT
CLASS="ENVAR"
>"$@"</TT
> een reeks woorden 
	<TT
CLASS="COMPUTEROUTPUT"
>"$1" "$2" "$3"&hellip;</TT
> geeft. 
	De variabele <TT
CLASS="ENVAR"
>$#</TT
> geeft het aantal argumenten. 
  </P
><P
>	Hieronder volgt een scriptje om met het gebruik van 
	parameters door de shell te experimenteren. 
	De <B
CLASS="COMMAND"
>shift</B
> opdracht gooit de eerste parameter 
	weg en schuift de rest een positie op, met uitzondering van 
	<TT
CLASS="ENVAR"
>$0</TT
>. 
	De regel met <B
CLASS="COMMAND"
>while</B
> wordt nader toegelicht 
	in <A
HREF="#HERHALINGEN"
>paragraaf <I
>herhalingen</I
></A
>. 
    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN389"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>#!/bin/sh

echo "Script $0 aangeroepen met $# parameters:"

while [ $# -gt 0 ]
do 
  echo -n "\"$1\" "
  shift
done
echo
exit 								</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Het verwerken van de parameterlijsten kan nog wat 
	ingewikkelder worden. 
	Zo kan met de notatie <TT
CLASS="ENVAR"
>${parameter:-woord}</TT
>
	een standaardwaarde (default) worden aangegeven voor een 
	weggelaten parameter of met <TT
CLASS="ENVAR"
>{$parameter:?woord}</TT
> 
	een foutmelding worden gegeven als de parameter verplicht is, 
	bijvoorbeeld
    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN394"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>cp ${1:?"De eerste parameter is verplicht"} \
   ${2:-"."}							</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
	Zoals gezegd wordt een opdracht be&euml;indigd door een 
	puntkomma of regeleinde. 
	Hier is een backslash gebruikt om aan te geven dat de 
	opdracht nog niet afgelopen is. 
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="IF"
></A
>als-dan</H3
><P
>	
	De meest elementaire programma-constructie laat 
	&eacute;&eacute;n of meer opdrachten al of niet uitvoeren, 
	afhankelijk van de uitkomst van een test, bijvoorbeeld:
    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN399"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><B
CLASS="COMMAND"
>if</B
> /usr/bin/test "A" = "a"
<B
CLASS="COMMAND"
>then</B
>
  echo "Gelijk"
<B
CLASS="COMMAND"
>else</B
> 
  echo "Verschillend"
<B
CLASS="COMMAND"
>fi</B
>						</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Eerst wordt de opdracht achter <B
CLASS="COMMAND"
>if</B
> 
	uitgevoerd. 
	Er wordt dan gekeken welke exit status die opdracht 
	oplevert. 
	De meeste programma's geven standaard 0 terug, en 1 of 
	een andere foutcode als er problemen zijn, 
	<B
CLASS="COMMAND"
>/bin/true</B
> of <B
CLASS="COMMAND"
>:</B
> is 
	altijd 0, en <B
CLASS="COMMAND"
>/bin/false</B
> altijd 1. 
	<B
CLASS="COMMAND"
>echo 1</B
> zal weliswaar 1 als output 
	geven, maar het resultaat is 0. 
  </P
><P
>	De opdracht(en) achter <B
CLASS="COMMAND"
>then</B
> worden enkel 
	uitgevoerd als de if-opdracht 0 oplevert, 
	anders wordt het deel achter <B
CLASS="COMMAND"
>else</B
> 
	uitgevoerd, maar het opnemen van een else-tak is niet 
	verplicht. 
	De if-constructie wordt pas uitgevoerd als het sleutelwoord 
	<B
CLASS="COMMAND"
>fi</B
> is gelezen. 
	In een interactieve shell krijg je een 
	<I
CLASS="FIRSTTERM"
>prompt string</I
> te zien om aan te geven 
	dat de shell op de volgende opdracht wacht. 
	Deze prompt wordt bepaald door de variabele <TT
CLASS="ENVAR"
>PS1</TT
>. 
	Als een opdracht niet afgesloten is, krijgt u de prompt 
	string <TT
CLASS="ENVAR"
>PS2</TT
> te zien. 
	De voorwaardelijke opdrachtregels worden hier ingesprongen 
	om de leesbaarheid te verbeteren. 
  </P
><P
>	De Bourne shell is een vrij beperkt programma. 
	Voor eenvoudige berekeningen kan het hulpprogramma 
	<B
CLASS="COMMAND"
>expr</B
> worden gebruikt en <B
CLASS="COMMAND"
>test</B
> 
	voor testen en vergelijken. 
	Moderne shells als ksh, bash of tcsh hebben deze faciliteiten 
	vaak ingebouwd. 
	In plaats van de notatie 
        <B
CLASS="COMMAND"
>test <TT
CLASS="REPLACEABLE"
><I
>expressie</I
></TT
></B
>
	gebruiken ze 
	<B
CLASS="COMMAND"
>[ <TT
CLASS="REPLACEABLE"
><I
>expressie</I
></TT
> ]</B
>. 
	De shell wil spaties zien tussen de verschillende onderdelen 
	van een expressie, terwijl in de opdracht variabele=waarde 
	juist geen spaties voor of na het =-teken mogen komen. 
        Voor uitgebreidere informatie zie <A
HREF="#EXPR"
>paragraaf <I
>expr</I
></A
> en
	<A
HREF="#TEST"
>paragraaf <I
>test</I
></A
>.
  </P
><P
>	Bovenstaand voorbeeld zal aangeven dat de strings 
	<TT
CLASS="LITERAL"
>"A"</TT
> en 
	<TT
CLASS="LITERAL"
>"a"</TT
> verschillend zijn.
	Hetzelfde geldt voor <B
CLASS="COMMAND"
>test "1" = "01"</B
> 
	terwijl <B
CLASS="COMMAND"
>test "1" -eq "01"</B
> 
	moet opleveren dat beide uitdrukkingen hetzelfde getal 
	voorstellen. 
	De opdracht <B
CLASS="COMMAND"
>test -e "$file"</B
> komt op 
	hetzelfde neer als 
	<B
CLASS="COMMAND"
>ls "$file" &gt;/dev/null 2&gt;&amp;1</B
>. 
	Zet variabelen tussen dubbele aanhalingstekens, anders 
	zal het fout gaan als de variabele niet bestaat of leeg is. 
  </P
><P
>	Er bestaan nog twee beknopte voorwaardelijke opdrachten:
    <B
CLASS="COMMAND"
>	<TT
CLASS="REPLACEABLE"
><I
>commando1</I
></TT
> &amp;&amp;
 	<TT
CLASS="REPLACEABLE"
><I
>commando2</I
></TT
>
    </B
> en
    <B
CLASS="COMMAND"
>	<TT
CLASS="REPLACEABLE"
><I
>commando1</I
></TT
> || 
	<TT
CLASS="REPLACEABLE"
><I
>commando2</I
></TT
>
    </B
>. 
	In beide gevallen wordt eerst 
	<B
CLASS="COMMAND"
><TT
CLASS="REPLACEABLE"
><I
>commando1</I
></TT
></B
> 
	uitgevoerd. 
	In het eerste geval wordt 
	<B
CLASS="COMMAND"
><TT
CLASS="REPLACEABLE"
><I
>commando2</I
></TT
></B
> 
	alleen uitgevoerd als het eerste exit status 
	<TT
CLASS="LITERAL"
>0</TT
> (nul) oplevert, 
	in het tweede geval als het resultaat van 
	<B
CLASS="COMMAND"
><TT
CLASS="REPLACEABLE"
><I
>commando1</I
></TT
></B
>
	ongelijk is aan nul. 
	Het resultaat is dus <TT
CLASS="LITERAL"
>true</TT
> als 
	<B
CLASS="COMMAND"
><TT
CLASS="REPLACEABLE"
><I
>commando1</I
></TT
></B
> 
	<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>en</I
></SPAN
> c.q. <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>of</I
></SPAN
> 
	<B
CLASS="COMMAND"
><TT
CLASS="REPLACEABLE"
><I
>commando2</I
></TT
></B
> 
	<TT
CLASS="LITERAL"
>true</TT
> opleveren. 
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CASE"
></A
>meerkeuze tests</H3
><P
>&#13;	Om de waarde van een uitdrukking in de standaard uitvoer 
	te krijgen wordt de <B
CLASS="COMMAND"
>echo</B
> opdracht gebruikt. 
	Om een waarde van de standaard invoer te lezen en toe 
	te kennen aan een of meer variabelen wordt 
	<B
CLASS="COMMAND"
> read <TT
CLASS="REPLACEABLE"
><I
>naam1 naam2</I
></TT
>&hellip; </B
>
	gebruikt. 
	De variabelen krijgen dan elk een woord van de invoer 
	als waarde. 
	Als er geen variabelen worden opgegeven, wordt er een regel 
	gelezen en in z'n geheel toegekend aan <TT
CLASS="ENVAR"
>REPLY</TT
>. 
  </P
><P
>	De if constructie kan met meerdere tests worden uitgebreid: 
    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN464"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><B
CLASS="COMMAND"
>if</B
> <TT
CLASS="REPLACEABLE"
><I
>test1</I
></TT
> 
<B
CLASS="COMMAND"
>then</B
>
  <TT
CLASS="REPLACEABLE"
><I
>commando1</I
></TT
> 
<B
CLASS="COMMAND"
>else</B
> 
  <B
CLASS="COMMAND"
>if</B
> <TT
CLASS="REPLACEABLE"
><I
>test2</I
></TT
>
  <B
CLASS="COMMAND"
>then</B
> 
     <TT
CLASS="REPLACEABLE"
><I
>commando2</I
></TT
>
  <B
CLASS="COMMAND"
>else</B
> 
  &hellip;
  <B
CLASS="COMMAND"
>fi</B
>
<B
CLASS="COMMAND"
>fi</B
>						</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>

	Dit kan ook korter worden genoteerd. 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN478"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>  
<B
CLASS="COMMAND"
>if</B
> <TT
CLASS="REPLACEABLE"
><I
>test1</I
></TT
> 
<B
CLASS="COMMAND"
>then</B
>
  <TT
CLASS="REPLACEABLE"
><I
>commando1</I
></TT
> 
<B
CLASS="COMMAND"
>elif</B
> <TT
CLASS="REPLACEABLE"
><I
>test2</I
></TT
>
<B
CLASS="COMMAND"
>then</B
> 
  <TT
CLASS="REPLACEABLE"
><I
>commando2</I
></TT
>
<B
CLASS="COMMAND"
>else</B
> 
  &hellip;
<B
CLASS="COMMAND"
>fi</B
>						</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Om de inhoud van een variabele met meerdere waarden 
	te vergelijken gebruiken we de <I
CLASS="FIRSTTERM"
>case</I
> 
	constructie, zoals in het volgende voorbeeld. 
    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN492"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>echo -n $vraag		# variabele moet gedefinieerd zijn
read antwoord
antwoord=$(expr substr "$antwoord" 1 1 | tr \
  "[a-z]" "[A-Z]")
<B
CLASS="COMMAND"
>case</B
> $antwoord <B
CLASS="COMMAND"
>in</B
>
[YJDOS] )
  exit 0 ;;
N )
  exit 1 ;;
* )
  echo "Ongeldig antwoord!" 1&#62;&#38;2
  exit 2 ;;
<B
CLASS="COMMAND"
>esac</B
>						</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>

	Hier wordt een vraag gesteld en een antwoord van de 
	gebruiker ingelezen, waarvan de eerste letter wordt 
	genomen en kleine letters in hoofdletters vertaald. 
	De case constructie vergelijkt <TT
CLASS="ENVAR"
>antwoord</TT
> 
	met een aantal patronen en voert de reeks bijbehorende 
	opdrachten uit, die wordt afgesloten met een dubbele puntkomma. 
  </P
><P
>	<TT
CLASS="USERINPUT"
><B
>Y</B
></TT
> (yes), <TT
CLASS="USERINPUT"
><B
>J</B
></TT
> (ja), 
	<TT
CLASS="USERINPUT"
><B
>D</B
></TT
> (da), <TT
CLASS="USERINPUT"
><B
>O</B
></TT
> (oui) of 
	<TT
CLASS="USERINPUT"
><B
>S</B
></TT
> (si) retourneren exit status 
	<TT
CLASS="LITERAL"
>0</TT
> (true), 
	<TT
CLASS="USERINPUT"
><B
>N</B
></TT
> (nein of njet) retourneren 
	<TT
CLASS="LITERAL"
>1</TT
> (false) en alle andere invoer komt overeen 
	met de asterisk en resulteert in 2 met bijbehorende foutmelding 
	op het standard error kanaal. 
  </P
><P
>	Een variant hierop is de <I
CLASS="FIRSTTERM"
>select</I
> constructie, 
	die niet in de originele Bourne shell voorkomt, waarmee eenvoudige 
	menu's kunnen worden gemaakt. 
    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN509"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>echo -n $vraag 
<B
CLASS="COMMAND"
>select</B
> woord <B
CLASS="COMMAND"
>in</B
> ja nee
<B
CLASS="COMMAND"
>do</B
> 
  <B
CLASS="COMMAND"
>if</B
> /usr/bin/test "$woord" != "" 
  <B
CLASS="COMMAND"
>then</B
> 
    break
  <B
CLASS="COMMAND"
>fi
done</B
>							</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
	Hier wordt de keuze van de gebruiker beperkt tot 
	<TT
CLASS="USERINPUT"
><B
>1</B
></TT
> (ja) of 
	<TT
CLASS="USERINPUT"
><B
>2</B
></TT
> (nee). 
	Let op dat <TT
CLASS="ENVAR"
>"$woord"</TT
> hier tussen aanhalingstekens 
	moet staan omdat de vergelijking anders niet goed gaat als 
	de waarde van de variabele een lege string is (gebruiker heeft 
	ongeldige invoer gepleegd). 
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="HERHALINGEN"
></A
>herhalingen</H3
><P
>	In het voorbeeld hierboven wordt de invoer zo lang 
	herhaald, totdat de gebruiker een geldige waarde heeft 
	ingevoerd. 
	Een meer algemene herhaling wordt geschreven als

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN523"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><B
CLASS="COMMAND"
>while</B
> <TT
CLASS="REPLACEABLE"
><I
>test</I
></TT
>
<B
CLASS="COMMAND"
>do</B
> 
  <TT
CLASS="REPLACEABLE"
><I
>opdracht1</I
></TT
> 
  &hellip;
  <TT
CLASS="REPLACEABLE"
><I
>opdrachtn</I
></TT
>
<B
CLASS="COMMAND"
>done</B
>						</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>

	Hierin wordt telkens de opdracht achter 
	<I
CLASS="FIRSTTERM"
>while</I
> herhaald en zo lang als het 
	resultaat <TT
CLASS="LITERAL"
>0</TT
> of true oplevert wordt 
	de reeks opdrachten tussen do en done herhaald, 
	wat dus ook nul keer het geval kan zijn en de test 
	(inderdaad is dat vaak het test commando) wordt altijd 
	een keer meer uitgevoerd dan de opdrachten. 
	Een voorbeeld van het gebruik van while 
	zagen we in <A
HREF="#PARAMETERS"
>paragraaf <I
>parameters</I
></A
>. 
  </P
><P
>	    
	De <I
CLASS="FIRSTTERM"
>until</I
> constructie lijkt hier 
	sterk op. 
	Hierin wordt de lijst van opdrachten herhaald 
	zolang als het resultaat ongelijk is aan 
	<TT
CLASS="LITERAL"
>0</TT
>. 
	De uitvoering van het script gaat dan verder 
	met de opdracht na `done'. 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN537"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><B
CLASS="COMMAND"
>until</B
> <TT
CLASS="REPLACEABLE"
><I
>test</I
></TT
>
<B
CLASS="COMMAND"
>do</B
> 
  <TT
CLASS="REPLACEABLE"
><I
>opdracht1</I
></TT
> 
  &hellip;
  <TT
CLASS="REPLACEABLE"
><I
>opdrachtn</I
></TT
>
<B
CLASS="COMMAND"
>done</B
>						</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	De <I
CLASS="FIRSTTERM"
>for</I
> constructie wordt ook 
	vaak gebruikt.

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN547"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><B
CLASS="COMMAND"
>for</B
> <TT
CLASS="REPLACEABLE"
><I
>variabele</I
></TT
> <B
CLASS="COMMAND"
>in</B
> <TT
CLASS="REPLACEABLE"
><I
>lijst</I
></TT
> 
<B
CLASS="COMMAND"
>do</B
> 
  <TT
CLASS="REPLACEABLE"
><I
>opdracht</I
></TT
>1 
  &hellip;
  <TT
CLASS="REPLACEABLE"
><I
>opdracht</I
></TT
>n
<B
CLASS="COMMAND"
>done</B
>						</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>

	Achter <B
CLASS="COMMAND"
>for</B
> staat de naam van een variabele 
	zonder dollarteken. 
	Bij elke doorgang krijgt de variabele de waarde van het 
	volgende woord in de lijst. 
	We geven enkele voorbeelden. 
    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN558"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><B
CLASS="COMMAND"
>for</B
> file <B
CLASS="COMMAND"
>in</B
> * 
<B
CLASS="COMMAND"
>do</B
> 
  <B
CLASS="COMMAND"
>if</B
> [ -f "$file" ] 
  <B
CLASS="COMMAND"
>then</B
> 
    wc "$file"
  <B
CLASS="COMMAND"
>fi
done</B
>							</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Hier wordt voor elke file in de huidige directory het 
	commando <B
CLASS="COMMAND"
>wc</B
> uitgevoerd, dat het 
	aantal regels, woorden en tekens in het bestand telt. 
	Gebruik van <B
CLASS="COMMAND"
>wc *</B
> is niet zo netjes 
	omdat dan ook directory's en speciale files worden meegenomen.  

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN569"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><B
CLASS="COMMAND"
>for</B
> i <B
CLASS="COMMAND"
>in</B
> 1 2 3 4 5 6 7 8 9 10
<B
CLASS="COMMAND"
>do</B
> 
  <B
CLASS="COMMAND"
>for</B
> j <B
CLASS="COMMAND"
>in</B
> 1 2 3 4 5 6 7 8 9 10
  <B
CLASS="COMMAND"
>do</B
> 
    echo -n $( expr $i '*' $j) " "
  <B
CLASS="COMMAND"
>done</B
>
  echo
<B
CLASS="COMMAND"
>done</B
>						</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Herhalingsopdrachten kunnen prima genest worden zoals in 
	bovenstaand voorbeeld, dat de tafels van vermenigvuldiging 
	afdrukt. 
	Let op de enkele aanhalingstekens rond het sterretje. 
	Er staat <TT
CLASS="OPTION"
>-n</TT
> achter echo om de tafels op 
	&eacute;&eacute;n regel te houden en er wordt een spatie 
	tussenruimte ingevoegd. 
  </P
><P
>	Als het woord <B
CLASS="COMMAND"
>in</B
> en de volgende lijst 
	afwezig zijn dan krijgt de variabele achtereenvolgens de 
	parameters toegewezen waarmee het script werd aangeroepen, 
	zodat we het programma van <A
HREF="#PARAMETERS"
>paragraaf <I
>parameters</I
></A
>
	kunnen herschrijven als
    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN584"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>echo "Programma $0 is aangeroepen met $# parameters"
<B
CLASS="COMMAND"
>for</B
> i
<B
CLASS="COMMAND"
>do</B
>
  echo $i
<B
CLASS="COMMAND"
>done</B
>						</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Een while lus kan oneindig doorlopen als voor de test 
	<B
CLASS="COMMAND"
>:</B
> of <B
CLASS="COMMAND"
>/bin/true</B
> 
	wordt ingevuld. 
	Een lus kan voortijdig worden verlaten met de 
	<B
CLASS="COMMAND"
>break</B
> opdracht; 
	met <B
CLASS="COMMAND"
>break 2</B
> wordt in geval van twee 
	geneste lussen de buitenste verlaten, enzovoorts. 
	De opdracht <B
CLASS="COMMAND"
>continue</B
> zorgt ervoor 
	dat de lijst opdrachten niet verder wordt afgewerkt en het 
	script verder gaat met de test. 
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SAMENSTELLINGEN"
></A
>samenstellingen</H3
><P
>	Tot de samengestelde commando's behoren if, case, select, 
	while, for, until en de functies, die verderop aan bod 
	komen. 
	Het simpelste samengestelde commando is 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN598"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>{
  <TT
CLASS="REPLACEABLE"
><I
>opdracht</I
></TT
>1 
  &hellip;
  <TT
CLASS="REPLACEABLE"
><I
>opdracht</I
></TT
>n 
}								</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Het <I
CLASS="FIRSTTERM"
> groep</I
> commando zal de 
	commando's in de groep na elkaar uitvoeren. 
	De exit status van de laatste opdracht is tevens het 
	resultaat van de groep. 
	Zo kan bijvoorbeeld een pijplijn als een opdracht worden 
	behandeld met 
	<B
CLASS="COMMAND"
>{ <TT
CLASS="REPLACEABLE"
><I
>opdracht</I
></TT
>1 | 
	  <TT
CLASS="REPLACEABLE"
><I
>opdracht</I
></TT
>2; }</B
>. 
  </P
><P
>	Als een lijst commando's in plaats van accolades tussen 
	ronde haken <B
CLASS="COMMAND"
>()</B
> wordt gezet, worden die binnen 
	een aparte <I
CLASS="FIRSTTERM"
>subshell</I
> uitgevoerd. 
	Dit geldt ook voor 
	<B
CLASS="COMMAND"
>$( <TT
CLASS="REPLACEABLE"
><I
>lijst</I
></TT
> )</B
>. 
	In het laatste geval wordt de uitvoer van de lijst als 
	deel van het script gebruikt. 
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="FUNCTIES"
></A
>functies</H3
><P
>	De definitie van een <I
CLASS="FIRSTTERM"
>functie</I
> 
	bestaat uit diens naam met een paar haken erachter, 
	doorgaans gevolgd door een lijst commando's. 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN616"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><B
CLASS="COMMAND"
><TT
CLASS="REPLACEABLE"
><I
>functie-naam()</I
></TT
></B
>
{
  <TT
CLASS="REPLACEABLE"
><I
>opdracht</I
></TT
>1 
  &hellip;
  <TT
CLASS="REPLACEABLE"
><I
>opdracht</I
></TT
>n 
}								</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Een functieaanroep bestaat uit de naam van de functie 
	gevolgd door de eventuele <I
CLASS="FIRSTTERM"
>argumenten</I
> 
	gescheiden door spaties. 
	De betreffende commando's worden dan &eacute;&eacute;n voor 
	&eacute;&eacute;n in de huidige shell uitgevoerd, waarna 
	het script verder gaat waar het gebleven was. 
	Binnen de functie zijn de argumenten beschikbaar als 
	<TT
CLASS="LITERAL"
>$1 &hellip;</TT
>
  </P
><P
> 
	De uitvoering van de functie stopt bij de afsluitende accolade 
	of na een return opdracht, die bij voorkeur de laatste opdracht 
	binnen de functie vormt. 
	Achter return kan eventueel een exit status volgen, die aan het 
	aanroepende script beschikbaar komt in <TT
CLASS="ENVAR"
>$?</TT
>. 
	De exit status is altijd een geheel getal. 
	Als een string als resultaat gewenst is, kan dat resultaat 
	bijvoorbeeld met echo worden uitgevoerd en de functie via 
	commando substitutie worden aangeroepen. 
	In plaats van 
	<B
CLASS="COMMAND"
>for i in 1 2 3 4 5 6 7 8 9 10 </B
> kan 
	<B
CLASS="COMMAND"
>for i in `range 1 10`</B
> worden geschreven 
	met de volgende functie:
  
    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN629"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><B
CLASS="COMMAND"
>range()</B
>
{ typeset i i

  i=$1
  while [ "$i" -le "$2" ]
  do
    echo $i
    i=`expr "$i" + 1`
  done
  unset i
}								</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Het kan handig zijn om functiedefinities in een apart bestand 
	<TT
CLASS="FILENAME"
>functies</TT
> te zetten en die met 
	<B
CLASS="COMMAND"
>./functies</B
> of 
	<B
CLASS="COMMAND"
>source functies</B
> in te lezen. 
	Bash zal een naam eerst proberen te koppelen aan een alias, 
	dan een functie en als laatste een bestand met dezelfde 
	naam gaan zoeken in zijn pad. 
  </P
><P
>	Binnen de functie zijn dezelfde variabelen als in de rest van 
	het script te gebruiken en gewijzigde waarden blijven ook na 
	afloop bestaan. 
	In de Korn en Bash shell kunnen ook 
	<I
CLASS="FIRSTTERM"
>lokale variabelen</I
> worden gedeclareerd
 	met de <B
CLASS="COMMAND"
>typeset</B
> opdracht, die alleen binnen de 
	functiecontekst bestaat. 
	In Bash kan hetzelfde ook met <B
CLASS="COMMAND"
>local</B
> worden 
	bereikt. 
	Een lokale variabele maskeert een eventuele globale variabele 
	met dezelfde naam. 
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="VOORBEELDEN"
></A
>enkele voorbeelden</H3
><P
>	Het volgende voorbeeldprogramma geeft de namen van de 
	ingelogde gebruikers. 
	Na een tweetal functiedefinities volgt het hoofdprogramma, 
	dat bestaat uit een pijp van vijf segmenten. 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN643"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><B
CLASS="COMMAND"
>word()</B
>
{ if [ "$#" -gt 1 ]
  then
    i=0; n=$1; shift
    for j in $@
    do
      if [ $i = $n ]
      then
        echo "$j"
        break
      else
        i=$(expr $i + 1)
      fi
    done
  fi
} 

<B
CLASS="COMMAND"
>item()</B
>
{ OFS=$IFS; IFS=":"
  NR=$1; shift

  word $NR "$@" 
  IFS=$OFS
}

<TT
CLASS="REPLACEABLE"
><I
># het hoofdprogramma </I
></TT
>
who \
| while read LINE1
  do 
    while read LINE2 
    do
      if [ "$(word 0 "$LINE1")" = 
           "$(item 0 "$LINE2")" ]
      then
        echo -e "$(item 0 "$LINE2")\011$(item 4
          "$LINE2")"
      fi
    done &lt;/etc/passwd
  done \
| sort \
| uniq -c							</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	De functie <TT
CLASS="FUNCTION"
>word</TT
> retourneert het 
	1<SUP
>e</SUP
> argument, dat wordt gebruikt 
	om een regel in woorden te splitsen; handiger dan daar 
	<I
CLASS="FIRSTTERM"
>awk</I
> voor te gebruiken. 
	De functie <TT
CLASS="FUNCTION"
>item</TT
> maakt handig 
	gebruik van de ingebouwde shell variabele <TT
CLASS="ENVAR"
>IFS</TT
> 
	om de dubbele punt in plaats van de spatie als scheidingsteken 
	te gebruiken. 
	Het hoofdprogramma doet niets anders dan uit de uitvoer van 
	<B
CLASS="COMMAND"
>who</B
> de username te knippen en die te 
	vergelijken met het corresponderende veld uit 
	<TT
CLASS="FILENAME"
>/etc/passwd</TT
>. 
	De uitvoer wordt dan gesorteerd en dubbele regels verwijderd. 
  </P
><P
>	Deze functies worden ook weer gebruikt in het volgende script 
	voor systemen die niet over een <B
CLASS="COMMAND"
>which</B
> commando 
	beschikken (zie <A
HREF="#VARIABELEN"
>paragraaf <I
>variabelen</I
></A
>). 
	Dit script houdt echter geen rekening met aliassen en 
	ingebouwde functies van de shell. 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN659"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><B
CLASS="COMMAND"
>which_p()</B
>
{ f=0
  while :
  do
    f=`expr $f + 1`
    dir=`item "$f" "$PATH"`
    if [ "$dir" = "" ]
    then
      break
    fi
    path=$dir/$1
    if [ -f "$path" ]
    then
      echo "$path"
      break
   fi
done
}

<TT
CLASS="REPLACEABLE"
><I
># het hoofdprogramma `which'</I
></TT
>
if [ `expr match "$1" '.*/.*` -gt 0 ]
then
  if [ -f "$1" ]
  then
    echo "$1"
  fi
else
  echo `which_p "$1"`
fi								</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Het volgende programma toont verschillen tussen twee 
	bestanden, maar het is een stuk beperkter dan het
	<I
CLASS="FIRSTTERM"
>diff</I
> commando. 
	Hier wordt zoals uitgelegd in <A
HREF="#PROCESSEN"
>paragraaf <I
>processen en hun in- en uitvoer</I
></A
>
	het standaard invoerkanaal omgeleid naar het bestand dat
	als eerste argument op de commandoregel is meegegeven
	en er het tweede bestand wordt gekoppeld aan het derde
	invoerkanaal. 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN666"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><B
CLASS="COMMAND"
>doit()</B
>
{ LINE=0
  while read EEN&#60;&#38;0
  do
    LINE=`expr $LINE + 1`
    read TWEE&#60;&#38;3
    if [ "$EEN" != "$TWEE" ]
    then
      echo "$LINE""c""$LINE"
      echo "&#60; $EEN"
      echo "---"
      echo "&#62; $TWEE"
    fi
  done
}

<TT
CLASS="REPLACEABLE"
><I
># hoofdprogramma					</I
></TT
>
if [ "$#" -ne 2 ]
  then
  echo "Usage: $0 file1 file2"
  exit 1
fi
if [ -r "$1" -a -r "$2" ]
then
  doit 0&#60;$1 3&#60;$2
  exit 0
else
  echo "Invoerbestand(en) onleesbaar"
  exit 1
fi 								</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="RECURSIE"
></A
>een voorbeeld van een recursieve functie</H3
><P
>	Een functie mag ook zichzelf aanroepen (recursie), 
	waarbij je moet voorkomen dat dat proces oneindig doorgaat. 
	In onderstaand voorbeeld voor bash en ksh vindt de recursie 
	alleen plaats als <TT
CLASS="ENVAR"
>$1</TT
> &gt; 0 en wordt het 
	argument verlaagd om te zorgen dat na een aantal stappen 
	<TT
CLASS="ENVAR"
>$1</TT
> gelijk wordt aan 0.

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN675"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><B
CLASS="COMMAND"
>Hanoi()</B
>
{ typeset i aantal

  if [ "$1" -gt "0" ]
  then
    aantal=$(expr $1 - 1)
    Hanoi "$aantal" "$2" "$4" "$3"
    echo "Verplaats een schijf van $2 naar $3"
    Hanoi "$aantal" "$4" "$3" "$2"
  fi
}
<TT
CLASS="REPLACEABLE"
><I
># Aanroepen met: </I
></TT
>
Hanoi 4 "A" "B" "C"						</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Voor wie het spel <I
CLASS="FIRSTTERM"
>de Torens van Hanoi</I
>
	nog niet kent: je hebt een toren van 4 (of 64, maar 
	dan duurt het spel erg lang) gouden schijven van verschillende 
	diameter, die je &eacute;&eacute;n voor &eacute;&eacute;n 
	van stapel A naar B moet verplaatsen, waarbij nooit een grotere
 	schijf bovenop een kleinere mag komen te liggen. 
	De optimale oplossing is om de bovenste drie schijven eerst 
	recursief van A naar C te verplaatsen, waarna de onderste 
	schijf van A naar B kan worden verplaatst en de rest weer 
	recursief van C naar B. 
  </P
><P
>	Om te bewijzen dat een recursief algorithme korrekt is, 
	is inductie nodig. 
	Het is triviaal in te zien dat het algorithme een stapel van 
	nul schijven van A naar B verplaatst door niets te doen. 
	Voor 
		n &gt; 0
	verplaats je eerst de bovenliggende 
		(n - 1) 
	schijven van A naar C en na het verschuiven van de 
	n<SUP
>e</SUP
>, weer van C naar B. 
	Als we mogen aannemen dat het verplaatsen van 
		(n - 1) 
	schijven korrekt wordt uitgevoerd, dan gaat werkt het op deze manier 
	ook voor een toren van 
		n
	schijven. 
  </P
><P
>	De inductieregel stelt, dat aangezien het algorithme het gewenste 
	effekt heeft voor 
		n = 0
	en dat voor elke 
		n &ges; 0
	geldt, dat als het goed gaat voor 
		n,
	ook een toren van 
		(n + 1)
	schijven korrekt wordt verwerkt. 
	Op dezelfde manier is te bewijzen dat als elke schijf groter 
	is dan de schijf erboven, het algorithme nooit een grotere 
	schijf bovenop een kleinere zal leggen: de toren van 
		(n - 1)
	schijven is altijd kleiner dan de onderste en de onderste schijf 
	komt nooit ergens bovenop te liggen. 
  </P
><P
>	Uit het algorithme volgt een recurrente betrekking voor het 
	aantal verplaatsingen:
  
    <DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN685"
></A
><P
></P
><TABLE
BORDER="0"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
> 
	    V(0) = 0
	  </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>	    V(n) = 2 &times; V(n-1) + 1
	  </TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Door een tabel te maken van de waarden voor verschillende n 
	zie je al snel dat dit overeenkomt met 
		V(n) = 2<SUP
>n</SUP
>-1, 
	wat vervolgens geverifi&euml;erd kan worden. 

    <DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN694"
></A
><P
></P
><TABLE
BORDER="0"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
> 
	    V(0) = 2<SUP
>0</SUP
>-1 = 0
	  </TD
></TR
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
>	    V(n) = 2 &times; (2<SUP
>n-1</SUP
>-1) + 1 = 2<SUP
>n</SUP
> - 1
	  </TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Bewijzen dat er geen snellere weg bestaat, is moeilijker. 
	Het kritieke pad is het verplaatsen van de onderste schijf van 
	A naar B. 
	Voor dat het zover is, moeten de schijven erboven eerst op 
	&eacute;&eacute;n of andere manier naar C worden verplaatst en 
	daarna weer naar B. 
	Een van de weinige alternatieven is om eerst van A naar C te 
	verplaatsen, en daarna van C naar B, maar dat maakt het enkel langer. 
	Welke keuze je ook maakt, het heeft geen invloed op het verplaatsen 
	van de resterende schijven. 
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SIGNALEN"
></A
>signalen</H3
><P
>	We hebben al gezien hoe we processen in de achtergrond 
	kunnen starten en kennis gemaakt met een manier om de 
	manier om twee processen te co&ouml;rdineren door middel 
	van een pijp: het eerste proces mag zolang in de pijp 
	schrijven totdat de kleine buffer vol is; dan zal 
	<SPAN
CLASS="ACRONYM"
>Unix</SPAN
> het stoppen totdat er weer 
	voldoende ruimte vrij is. 
	Het lezende proces wordt telkens als de pijp leeg is in 
	de wacht gezet. 
  </P
><P
>	De meeste vormen van interprocescommunicatie vergen een 
	hogere programmeertaal. 
	Voor de shell programmeur zijn de signalen het belangrijkst. 
	<SPAN
CLASS="ACRONYM"
>Unix</SPAN
> heeft twintig tot dertig 
	voorgedefinieerde <I
CLASS="FIRSTTERM"
>signalen</I
> 
	plus twee vrij definieerbare. 

	Met de opdracht 
	<B
CLASS="COMMAND"
>kill <TT
CLASS="REPLACEABLE"
><I
>signaal proces</I
></TT
></B
> 
	stuur je een signaal naar het opgegeven proces. 
	De nummers van de processen zijn met <B
CLASS="COMMAND"
>ps</B
> 
	te achterhalen. 
	Het nummer van het proces zelf is te vinden in de 
	variabele <TT
CLASS="ENVAR"
>$$</TT
> en in bash zit het ouderproces 
	in <TT
CLASS="ENVAR"
>$PPID</TT
>. 
	De nummers van de signalen verschillen enigszins per 
	<SPAN
CLASS="ACRONYM"
>Unix</SPAN
> versie; de signalen kunnen ook met 
	symbolische namen worden aangeduid; 
	voor bash beginnen die met de letters <TT
CLASS="LITERAL"
>SIG</TT
>, 
	maar in de korn shell moet dit voorvoegsel worden weggelaten. 
  </P
><P
>	Het effekt van een signaal is in de meeste gevallen dat het 
	opgegeven programma onmiddellijk wordt beeindigd. 
	Voor <TT
CLASS="LITERAL"
>SIGKILL</TT
> (9) is dit altijd het geval. 
	Het ligt voor de hand dat alleen 
	<I
CLASS="FOREIGNPHRASE"
>root</I
> het recht heeft om 
	andermans processen te doden. 
	Het besturingssysteem kan zelf besluiten een proces een 
	signaal te geven. 
	Als een programma stopt met 
	<TT
CLASS="COMPUTEROUTPUT"
>segmentation violation</TT
>, 
	<TT
CLASS="COMPUTEROUTPUT"
>bus error</TT
>, 
	<TT
CLASS="COMPUTEROUTPUT"
>floating point exception</TT
> of 
	<TT
CLASS="COMPUTEROUTPUT"
>illegal instruction</TT
> duidt 
	dat meestal op een programmeerfout; 
	shell scripts veroorzaken deze fouten zelden. 
  </P
><P
>	De gebruiker heeft een snellere manier om signalen naar 
	het proces op de voorgrond te sturen. 
	Deze kunnen vrij worden veranderd met het commando 
	<I
CLASS="FIRSTTERM"
>stty</I
>. 
	Met <B
CLASS="COMMAND"
>stty -a</B
> krijg je een lijst van de 
	ingestelde waarden, bijvoorbeeld 
	<B
CLASS="KEYCAP"
>Ctrl</B
>-<B
CLASS="KEYCAP"
>D</B
>
	voor <TT
CLASS="LITERAL"
>SIGHUP</TT
>, 
	<B
CLASS="KEYCAP"
>Ctrl</B
>-<B
CLASS="KEYCAP"
>C</B
>
	of <B
CLASS="KEYCAP"
>Del</B
> voor <TT
CLASS="LITERAL"
>SIGINT</TT
>, 
	<B
CLASS="KEYCAP"
>Ctrl</B
>-<B
CLASS="KEYCAP"
>\</B
>
	<TT
CLASS="LITERAL"
>SIGQUIT</TT
>. Met
	<B
CLASS="KEYCAP"
>Ctrl</B
>-<B
CLASS="KEYCAP"
>Z</B
>
	wordt een lopend programma tijdelijk onderbroken. 
	Onder bash kan een script zichzelf onderbreken met de 
	<B
CLASS="COMMAND"
>suspend</B
> opdracht. 
	De ingebouwde opdrachten met <B
CLASS="COMMAND"
>fg</B
> en 
	<B
CLASS="COMMAND"
>bg</B
> zetten een onderbroken job voort in de 
	voor- resp. achtergrond. 
	
  </P
><P
>	Met de opdracht 
	<B
CLASS="COMMAND"
>sleep <TT
CLASS="REPLACEABLE"
><I
>seconden</I
></TT
></B
>
	wordt een programma tijdelijk onderbroken en zal het na het 
	opgegeven aantal seconden met <TT
CLASS="LITERAL"
>SIGALRM</TT
> worden 
	gewekt. 
	De <I
CLASS="FIRSTTERM"
>wait</I
> opdracht onderbreekt een proces 
	zolang totdat het van <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> het signaal 
	<TT
CLASS="LITERAL"
>SIGCHLD</TT
> krijgt dat het opgegeven kind proces 
	of job in de achtergrond be&euml;indigd is. 
	<B
CLASS="COMMAND"
>Wait</B
> zonder argumenten wacht totdat alle 
	kinderen afgestorven zijn. 
	Als een proces in de voorgrond gestart is, wacht de ouder 
	zonder expliciet wait commando. 
  </P
><P
>	Een proces kan ervoor kiezen bepaalde signalen gewoon te negeren, 
	met uitzondering van <TT
CLASS="LITERAL"
>SIGKILL</TT
> en 
	<TT
CLASS="LITERAL"
>SIGSTOP</TT
>. 
	Het <TT
CLASS="LITERAL"
>SIGHUP</TT
> signaal dat aangeeft dat een 
	terminalgebruiker de (telefoon)verbinding heeft opgehangen wordt 
	genegeerd met <B
CLASS="COMMAND"
>nohup commando&#38;</B
>. 
	De standaard uitvoer en error kanalen worden dan omgeleid naar 
	het bestand <TT
CLASS="FILENAME"
>nohup.out</TT
>. 
  </P
><P
>	Signalen worden asynchroon verwerkt, onafhankelijk van waar 
	een proces mee bezig was en na afloop gaat het programma verder 
	waar het gebleven was, tenzij het be&euml;indigd is. 
  </P
><P
>	Met het commando 
	<B
CLASS="COMMAND"
>trap <TT
CLASS="REPLACEABLE"
><I
>commando signa(a)l(en)</I
></TT
></B
> 
	wordt aangegeven dat een bepaald commando moet worden uitgevoerd 
	als het volgende signaal c.q. &eacute;&eacute;n van de signalen wordt 
	ontvangen. 
	Dit zal vaak de naam van de functie zijn die het betreffende 
	signaal moet afhandelen. 
	Als een script voortijdig moet worden afgebroken zal zo'n functie 
	bijvoorbeeld tijdelijke bestanden verwijderen. 
  </P
><P
>	<B
CLASS="COMMAND"
>Trap</B
> heeft geen effekt op kind processen. 
	Als het commando <B
CLASS="COMMAND"
>-</B
> luidt of ontbreekt, 
	dan wordt de oorspronkelijke handelwijze hersteld. 
	Als het commando een lege string is, dan zal de lijst van 
	signalen door het script worden genegeerd. 
  </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H2
CLASS="SECT1"
><A
NAME="TOOLS"
></A
>enkele <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> tools</H2
><P
>	De <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> shell is van oudsher de enige 
	programmeertaal zonder ingebouwde optelling. 
	Optellen en een eindeloze reeks andere functies kunnen 
	echter gerealiseerd worden door externe programma's. 
	De verzameling van tools die standaard met 
	<SPAN
CLASS="ACRONYM"
>Unix</SPAN
> worden geleverd vormen een k
	rachtig en flexibel geheel. 
	Dit hoofdstuk behandelt er een paar die vooral 
	geschikt zijn voor gebruik in scripts; 
	het pretendeert niet volledig te zijn. 
  </P
><P
>	Een modale Unix commandoregel begint 
	met de naam van het programma, gevolgd door de opties, 
	die met een min-teken beginnen, met daarna de overige
	parameters, die vaak bestanden zijn. 
	Veelal mogen er ook meerdere bestanden voorkomen. 
	De opties mogen in willekeurige volgorde worden 
	gebruikt en opties van &eacute;&eacute;n letter gecombineerd van 
	<B
CLASS="COMMAND"
>prog -a -b <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
></B
> 
	tot bijv. 
	<B
CLASS="COMMAND"
>prog -ab <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
></B
>. 
	Verder kunnen argumenten aan opties worden gekoppeld met 
	iets als 
	<B
CLASS="COMMAND"
>prog -a <TT
CLASS="REPLACEABLE"
><I
>-variabele=waarde</I
></TT
> 
	-b &hellip;</B
> of
	<B
CLASS="COMMAND"
>prog -a <TT
CLASS="REPLACEABLE"
><I
>-variabele waarde</I
></TT
>
	-b &hellip;</B
>; 
	let op wanneer je wel of geen spaties moet gebruiken. 
  </P
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXPR"
></A
>expr</H3
><P
>	Wie een rekenmachine zoekt gebruikt meestal 
	<I
CLASS="FIRSTTERM"
>bc</I
> of <I
CLASS="FIRSTTERM"
>xcalc</I
>. 
	<I
CLASS="FIRSTTERM"
>Expr</I
> is speciaal voor shell scripts. 
	Elk argument is een getal of een operator, 
	en moet door spaties gescheiden worden;
	speciale tekens moeten door backslashes worden voorafgegaan. 
	Expr kent geen variabelen; daarvoor zijn shell variabelen. 
	Om een getal met drie te vermenigvuldigen gebruiken we iets als 
	<B
CLASS="COMMAND"
>i=`expr "3" \* "$i"`</B
>
  </P
><P
>	De rekenkundige operatoren <B
CLASS="COMMAND"
>+</B
> voor optellen, 
	<B
CLASS="COMMAND"
>-</B
> voor aftrekken, <B
CLASS="COMMAND"
>*</B
> 
	voor vermenigvuldigen, <B
CLASS="COMMAND"
>/</B
> voor delen en 
	<B
CLASS="COMMAND"
>%</B
> voor rest werken met gehele getallen. 
	De vergelijkingsoperatoren <B
CLASS="COMMAND"
>&gt;</B
>, 
	<B
CLASS="COMMAND"
>&lt;</B
>, <B
CLASS="COMMAND"
>&gt;=</B
>, 
	<B
CLASS="COMMAND"
>&lt;=</B
>, <B
CLASS="COMMAND"
>=</B
> (in 
	<SPAN
CLASS="ACRONYM"
>GNU</SPAN
> expr ook <B
CLASS="COMMAND"
>==</B
>)  
	en <B
CLASS="COMMAND"
>!=</B
> kunnen ook voor strings worden 
	gebruikt. 
	In tegenstelling tot de shell retourneren ze een 
	<TT
CLASS="LITERAL"
>1</TT
> als de vergelijking waar is en 
	anders <TT
CLASS="LITERAL"
>0</TT
>, evenals de operatoren 
	<B
CLASS="COMMAND"
>|</B
> (logische `of') en <B
CLASS="COMMAND"
>&#38;</B
> 
	(logische `en'). 
	In plaats van een nul mag de lege string worden gebruikt 
	en expressies kunnen tussen haakjes <B
CLASS="COMMAND"
>( )</B
> 
	gezet worden. 
	Let op dat in 
	<B
CLASS="COMMAND"
> if $(expr "$i" = "") 				</B
>
	de aanhalingstekens om de variabelenaam niet gemist kunnen worden. 
  </P
><P
>	De Korn shell en bash hebben ook een ingebouwde rekenfunctie: 
	de te berekenen uitdrukking wordt omgeven door 
	<B
CLASS="COMMAND"
>$((</B
> en <B
CLASS="COMMAND"
>))</B
>. 
	Hier worden geen aanhalingstekens gebruikt en de spaties 
	zijn niet vereist. 
	Er zijn extra operatoren: <B
CLASS="COMMAND"
>=</B
> staat 
	voor toewijzing, dus voor vergelijking wordt 
	<B
CLASS="COMMAND"
>==</B
> gebruikt. 
	Behalve in de decimale notatie kunnen getallen ook octaal 
	worden genoteerd door ze met <TT
CLASS="LITERAL"
>0</TT
> te beginnen 
	of hexadecimaal door er <TT
CLASS="LITERAL"
>0x</TT
> voor te zetten. 
	Het gebruik van de ingebouwde functie bespaart 
	<SPAN
CLASS="ACRONYM"
>Unix</SPAN
> de tijd voor het maken van het 
	`expr' proces. 
  </P
><P
>	Expr kent ook een patroonherkenning operator 
	<B
CLASS="COMMAND"
>:</B
> die een string vergelijkt met een 
	reguliere expressie (zie <A
HREF="#GREP"
>paragraaf <I
>grep en reguliere expressies</I
></A
>). 
	Deze operator levert het aantal tekens dat overeenkomt op. 
  </P
><P
>	Modernere versies van <B
CLASS="COMMAND"
>expr</B
> bezitten een 
	aantal string functies. 

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><B
CLASS="COMMAND"
> 
		match <TT
CLASS="REPLACEABLE"
><I
>string regexp</I
></TT
>	
	  </B
></DT
><DD
><P
> 
		een alternatieve notatie voor patroonherkenning  
	  </P
></DD
><DT
><B
CLASS="COMMAND"
> 
		substr <TT
CLASS="REPLACEABLE"
><I
>string begin lengte</I
></TT
>
	  </B
></DT
><DD
><P
> 
		retourneert een deel van de string van lengte 
		tekens vanaf positie <TT
CLASS="REPLACEABLE"
><I
>begin</I
></TT
>; 
		posities worden vanaf <TT
CLASS="LITERAL"
>1</TT
> geteld
	  </P
></DD
><DT
><B
CLASS="COMMAND"
> 
		index <TT
CLASS="REPLACEABLE"
><I
>string tekens</I
></TT
>
	  </B
></DT
><DD
><P
> 
		retourneert de eerste positie in de 
		<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
> waar 
		&eacute;&eacute;n van de reeks tekens voorkomt
	  </P
></DD
><DT
><B
CLASS="COMMAND"
> 
		length <TT
CLASS="REPLACEABLE"
><I
>string </I
></TT
>	
	  </B
></DT
><DD
><P
> 
		retourneert het aantal tekens in de string 
	  </P
></DD
></DL
></DIV
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="TEST"
></A
>test</H3
><P
>	Het <I
CLASS="FIRSTTERM"
>test</I
> commando, dat wordt 
	gebruikt in voorwaardelijke opdrachten, zijn we al 
	tegengekomen. 
	Let op dat test een ingebouwde functie van moderne 
	shells als bash of ksh is, die erg lijkt op 
	<TT
CLASS="FILENAME"
>/usr/bin/test</TT
>. 
	Die ingebouwde test functie kan ook worden genoteerd als 
	<B
CLASS="COMMAND"
>[ <TT
CLASS="REPLACEABLE"
><I
>expressie</I
></TT
> ]</B
>. 
	De eerste toepassing is om te testen of een bestand bestaat. 

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><B
CLASS="COMMAND"
> 
		-d <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>	
	  </B
></DT
><DD
><P
> 
		waar als de file een directory is
	  </P
></DD
><DT
><B
CLASS="COMMAND"
> 
		-f <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>	
	  </B
></DT
><DD
><P
> 
		waar als de file een normaal bestand is
	  </P
></DD
><DT
><B
CLASS="COMMAND"
> 
		-r <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>	
	  </B
></DT
><DD
><P
> 
		waar als je het recht hebt om de file te lezen
	  </P
></DD
><DT
><B
CLASS="COMMAND"
> 
		-w <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>	
	  </B
></DT
><DD
><P
> 
		waar als je het recht hebt om naar de file te schrijven
	  </P
></DD
><DT
><B
CLASS="COMMAND"
> 
		-s <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>	
	  </B
></DT
><DD
><P
> 
		waar als het bestand niet leeg is
	  </P
></DD
><DT
><B
CLASS="COMMAND"
>		-t <TT
CLASS="REPLACEABLE"
><I
>kanaal</I
></TT
>	
	  </B
></DT
><DD
><P
> 
		waar als het kanaal 
		<I
CLASS="FIRSTTERM"
>(file descriptor)</I
> 
		aan een terminal gekoppeld is. 
		<SPAN
CLASS="ACRONYM"
>Unix</SPAN
> koppelt elk bestand dat geopend 
		wordt aan een nummer. Om te lezen of te schrijven 
		verwijs je naar dat nummer. een bestand kan evt. dubbel 
		geopend zijn. 
		De shell zal bij het inloggen kanaal 0 openen voor invoer 
		van de terminal en 1 en 2 openen voor uitvoer naar de 
		terminal; 
		voor 
		<B
CLASS="COMMAND"
>commando <TT
CLASS="REPLACEABLE"
><I
>&lt;file</I
></TT
></B
>
		zal de shell het bestand openen met nummer 3 of hoger, 
		het commando uitvoeren en de file weer sluiten. 
	  </P
></DD
></DL
></DIV
>
  </P
><P
> 
	Hedendaagse Unices hebben wat meer opties. 
	De tweede groep tests vergelijkt strings. 

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><B
CLASS="COMMAND"
> 
	    <TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>1 = <TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>2	
	  </B
></DT
><DD
><P
> 
		waar als beide strings gelijk zijn
	  </P
></DD
><DT
><B
CLASS="COMMAND"
> 
	    <TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>1 != <TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>2	
	  </B
></DT
><DD
><P
> 
		waar als beide strings verschillen
	  </P
></DD
><DT
><B
CLASS="COMMAND"
> 
	    <TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>1	
	  </B
></DT
><DD
><P
> 
		waar als de string niet de lege string "" is
	  </P
></DD
><DT
><B
CLASS="COMMAND"
> 
	    -n <TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>1	
	  </B
></DT
><DD
><P
> 
		waar als de lengte van de string gen nul bedraagt
	  </P
></DD
></DL
></DIV
>
  </P
><P
>	Om in plaats van strings gehele getallen te vergelijken 
	worden de operaties <TT
CLASS="OPTION"
>-eq</TT
>, 
	<TT
CLASS="OPTION"
>-ne</TT
>, <TT
CLASS="OPTION"
>-gt</TT
>, <TT
CLASS="OPTION"
>-ge</TT
>,
	<TT
CLASS="OPTION"
>-lt</TT
>, <TT
CLASS="OPTION"
>-le</TT
> gebruikt. 
	Getallen worden als strings weergegeven. 
	Het verschil is dat <B
CLASS="COMMAND"
> test "02" -eq "2"</B
> 
	<TT
CLASS="LITERAL"
>0</TT
> (true) zal opleveren en 
	<B
CLASS="COMMAND"
>/usr/bin/test "02" = "2"</B
> 
	<TT
CLASS="LITERAL"
>1</TT
> (false). 
	Dit resultaat krijgt u te zien met <B
CLASS="COMMAND"
>echo $?</B
>. 
	<B
CLASS="COMMAND"
>/usr/bin/expr "02" = "2"</B
> zal op de 
	standaard uitvoer <TT
CLASS="LITERAL"
>1</TT
> (true) schrijven en de 
	exit status <TT
CLASS="LITERAL"
>0</TT
> (true) retourneren. 
  </P
><P
>	De vierde groep zijn de verbindingen. 
	<B
CLASS="COMMAND"
>! <TT
CLASS="REPLACEABLE"
><I
>expressie</I
></TT
></B
> 
	staat voor logische negatie,  
	<B
CLASS="COMMAND"
><TT
CLASS="REPLACEABLE"
><I
>expressie</I
></TT
>1 -a 
	<TT
CLASS="REPLACEABLE"
><I
>expressie</I
></TT
>2</B
> 
	vormt een logische <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>en</I
></SPAN
> en 
	<B
CLASS="COMMAND"
><TT
CLASS="REPLACEABLE"
><I
>expressie</I
></TT
>1 -o 
	<TT
CLASS="REPLACEABLE"
><I
>expressie</I
></TT
>2</B
> 
	een logische <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>of</I
></SPAN
>. 
	Verder kunnen subexpressies tussen <B
CLASS="COMMAND"
>( )</B
> 
	haakjes worden gezet. 
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="GREP"
></A
>grep en reguliere expressies</H3
><P
>	<I
CLASS="FIRSTTERM"
>Grep</I
> is een tool om in 
	tekstbestanden te zoeken; 
	met binaire bestanden kunnen veel van de hier besproken 
	tools problemen geven. 
	U kunt het <B
CLASS="COMMAND"
>strings</B
> commando gebruiken 
	om leesbare tekstfragmenten te vissen uit alle soorten 
	files. 
  </P
><P
>	Sinds het ontstaan van <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> zijn er 
	veel versies met verschillende kenmerken in omloop 
	en bovendien zijn er <I
CLASS="FIRSTTERM"
>egrep</I
>, 
	<I
CLASS="FIRSTTERM"
>fgrep</I
> en 
	<I
CLASS="FIRSTTERM"
>agrep</I
> bij gekomen. 
	Ten behoeve van de portabiliteit zijn 
	egrep of fgrep aan te bevelen. 
  </P
><P
>	Hieronder volgt de syntaxis van de fgrep opdracht. 
	De rechte haken geven aan dat een onderdeel optioneel 
	is en worden in een echte opdrachtregel niet opgeschreven, 
	evenmin als cursieve termen letterlijk worden genomen. 

    <P
><B
CLASS="COMMAND"
> fgrep						</B
>  [	<TT
CLASS="REPLACEABLE"
><I
>	optie					</I
></TT
>
      ...]  	<TT
CLASS="REPLACEABLE"
><I
>	string					</I
></TT
>
      ...  [	<TT
CLASS="REPLACEABLE"
><I
>	file					</I
></TT
>
      ...]</P
>
  </P
><P
>	Fgrep is het beperktste en tevens snelste lid van 
	de familie. 
	Als er een enkele string als argument wordt meegegeven 
	functioneert het als een filter dat van de regels in 
	de invoer degene doorlaat die de opgegeven string 
	bevatten. 
  </P
><P
>	Er kan op meerdere strings worden gezocht, die dan 
	worden gescheiden door een regeleinde. 
	De strings moeten dan tussen aanhalingstekens worden gezet 
	om een argument te vormen en alle regels die 
	&eacute;&eacute;n van de strings bevatten worden 
	afgedrukt. 
	Fgrep kent de volgende opties. 

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
> -v						</TT
></DT
><DD
><P
> 
		alle regels afdrukken, behalve degene die de 
		gezochte strings bevatten
	  </P
></DD
><DT
><TT
CLASS="OPTION"
> -c						</TT
></DT
><DD
><P
> 
		alleen het aantal regels afdrukken
	  </P
></DD
><DT
><TT
CLASS="OPTION"
> -l						</TT
></DT
><DD
><P
> 
		de namen van de files afdrukken, die de gezochte 
		strings bevatten
	  </P
></DD
><DT
><TT
CLASS="OPTION"
> -i						</TT
></DT
><DD
><P
> 
		geen onderscheid maken tussen hoofd- en kleine
		letters
	  </P
></DD
><DT
><TT
CLASS="OPTION"
> -w						</TT
></DT
><DD
><P
> 
		regels waarin de zoekstring een deel van een
		woord vormt tellen niet mee
	  </P
></DD
><DT
><TT
CLASS="OPTION"
> -x						</TT
></DT
><DD
><P
> 
		alleen regels die helemaal gelijk zijn aan de
		zoekstring tellen mee
	  </P
></DD
></DL
></DIV
>
  </P
><P
>  
	Er bestaan meer opties, maar die verschillen per systeem. 
	Als je wilt testen of een bepaalde string in een bepaalde 
	file voorkomt kun je de <TT
CLASS="OPTION"
>-s</TT
> (silent) 
	optie gebruiken (BSD), of <TT
CLASS="OPTION"
>-q</TT
> 
	(quiet, GNU) om de standaard uitvoer te onderdrukken. 
  </P
><P
>	Het volgende voorbeeld geeft een lijst van al je processen. 
	(de juiste opties van ps hangen af of je OS tot de System V 
	of BSD familie behoort) 
    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1012"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>ps -al | fgrep `fgrep $USER /etc/passwd | cut -f 3 -d ':'` 	</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	De binnenste <I
CLASS="FIRSTTERM"
>fgrep</I
> selekteert de 
	regel van de ingelogde gebruiker uit het wachtwoordbestand. 
	<I
CLASS="FIRSTTERM"
>Cut</I
> knipt daaruit het derde veld, 
	waarbij de dubbele punt als scheidingsteken wordt gebruikt. 
	De buitenste fgrep selecteert de regels met dit 
	<I
CLASS="FOREIGNPHRASE"
>User ID</I
> uit de uitvoer van 
	<I
CLASS="FIRSTTERM"
>ps</I
>. 
	Vergelijk met het voorbeeld uit <A
HREF="#VOORBEELDEN"
>paragraaf <I
>enkele voorbeelden</I
></A
>. 
  </P
><P
>	De functionaliteit van grep zelf verschilt nogal per systeem, 
	en daarom wordt hier het uitgebreidere 
	<I
CLASS="FIRSTTERM"
>egrep</I
> besproken. 
	De opties zijn hetzelfde, maar het zoekt naar 
	<I
CLASS="FIRSTTERM"
>reguliere expressies</I
> in plaats van alleen 
	letterlijke strings. 
	Reguliere expressies lijken op de wildcards 
	(jokertekens, zie <A
HREF="#WILDCARDS"
>paragraaf <I
>een les over `ls': jokertekens</I
></A
>) * en ? die de 
	shell gebruikt om naar bestandsnamen te zoeken, maar 
	de notatie verschilt sterk. 
	Denk eraan de zoekstring tussen enkele aanhalingstekens te 
	zetten om verhaspelen door de shell te voorkomen. 
	Het kan geen kwaad om zelf eens wat te proberen op een grote 
	woordenlijst. 
  </P
><P
>    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1025"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>egrep -i 'abc
def' /usr/share/dict/words					</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>

	Hiermee zoeken we naar alle woorden waarin de letters 
	<TT
CLASS="LITERAL"
>abc</TT
> en/of <TT
CLASS="LITERAL"
>def</TT
> direkt 
	achter elkaar staan. 
	De woordenlijst zou ook in bijv. 
	<TT
CLASS="FILENAME"
>/usr/dict/words</TT
> kunnen staan. 
  </P
><P
>	Reguliere expressies moeten voldoen aan de volgende regels.
  </P
><P
></P
><UL
><LI
STYLE="list-style-type: opencircle"
><P
>	Een enkel teken dat geen speciale functie heeft, komt 
	overeen met dat teken zelf
      </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>	Om te zoeken naar een teken dat een speciale functie 
	heeft, moet je er een <TT
CLASS="LITERAL"
>\</TT
> voorzetten, 
	bijv. <B
CLASS="COMMAND"
>egrep '\\'</B
>
      </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>	Een reeks tekens tussen vierkante haken wordt gebruikt 
	om te zoeken naar een enkel teken uit deze reeks, 
	zo correspondeert <TT
CLASS="LITERAL"
>[0123456789]</TT
> met 
	een enkel cijfer.  
      </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>	Tussen vierkante haken kan een reeks tekens worden 
	aangegeven met een koppelteken tussen het eerste en 
	laatste teken, bijv. <TT
CLASS="LITERAL"
>[0-9]</TT
>. 
      </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>	Een punt correspondeert met een willekeurig teken, 
	bijv. <TT
CLASS="LITERAL"
>.a.b.c..de</TT
> 
	met `barbecuede'.
      </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>	De reguliere expressie 
	<SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>1</SPAN
><SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>2</SPAN
> correspondeert met 
	<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>1<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>2
	als <SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>1</SPAN
> 
	correspondeert met <TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>1 en 
	<SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>2</SPAN
> correspondeert 
	met <TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>2, waarbij 
	<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>1 de langst mogelijke string 
	is waarvoor nog een correspondentie met 
	<SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>2</SPAN
> mogelijk is. 
      </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>	De reguliere expressie 
	<SPAN
CLASS="TOKEN"
>(<TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>)</SPAN
> correspondeert 
	met alle strings die corresponderen met 
	<SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
></SPAN
>. 
      </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>	De reguliere expressie 
	<SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>1|<TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>2</SPAN
> 
	correspondeert met alle strings die corresponderen met 
	<SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>1</SPAN
> 
	<SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>of</I
></SPAN
> 
	<SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>2</SPAN
>. 
	Iets handiger dan een regeleinde. 
      </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>	De reguliere expressie 
	<SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>1*</SPAN
> correspondeert 
	met alle strings die nul of meer keer corresponderen met 
	<SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>1</SPAN
>. 
	Zo komt <TT
CLASS="LITERAL"
>a.*b.*c.*d.*e</TT
> overeen met 
	o.a. `Abcoude' en blijkt bijv. 
	<B
CLASS="COMMAND"
>egrep `(bla)*(bla)'</B
> dezelfde output op 
	te leveren als <B
CLASS="COMMAND"
>fgrep bla</B
>. 
      </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>	De reguliere expressie 
	<SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>1+</SPAN
> is equivalent met 
	<SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>1(<TT
CLASS="REPLACEABLE"
><I
>exp1</I
></TT
>)*</SPAN
>. 
      </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>	De reguliere expressie 
	<SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>1?</SPAN
> is equivalent met 
	<SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>1|()</SPAN
>. 
      </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>	De reguliere expressie 
	<SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>1\{<TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
>1\}</SPAN
> 
	is equivalent met <SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>1</SPAN
> 
	<TT
CLASS="VARNAME"
><TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
>1</TT
> 
	keer achter elkaar. 
      </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>	De reguliere expressie 
	<SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>1\{<TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
>1,\}</SPAN
> 
	is equivalent met <SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>1</SPAN
> 
	<TT
CLASS="VARNAME"
><TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
>1</TT
> of meer 
	keer achter elkaar. 
      </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>	De reguliere expressie 
	<SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>1\{<TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
>1,<TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
>2\}</SPAN
> 
	is equivalent met <SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>1</SPAN
> 
	minstens <TT
CLASS="VARNAME"
><TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
>1</TT
> 
	en hoogstens <TT
CLASS="VARNAME"
><TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
>2</TT
> 
	keer achter elkaar.  
      </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>	De reguliere expressie 
	<SPAN
CLASS="TOKEN"
>^<TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>1</SPAN
> correspondeert 
	met alle regels waarin <SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>1</SPAN
> 
	aan het begin van de regel voorkomt. 
      </P
></LI
><LI
STYLE="list-style-type: opencircle"
><P
>	De reguliere expressie 
	<SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>1$</SPAN
> correspondeert 
	met alle regels waarin <SPAN
CLASS="TOKEN"
><TT
CLASS="REPLACEABLE"
><I
>exp</I
></TT
>1</SPAN
> 
	aan het eind van de regel voorkomt. 
      </P
></LI
></UL
><P
>	Een uitbreiding op de Reguliere Expressies, die oudere Unices 
	missen, zijn de <I
CLASS="FIRSTTERM"
>karakter klassen</I
> die 
	een uitbreiding vormen van de lijsten karakters. 
  </P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><SPAN
CLASS="TOKEN"
>	[[:alpha:]]          			</SPAN
></DT
><DD
><P
>	de letters van het alfabet		</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>	[[:upper:]]          			</SPAN
></DT
><DD
><P
>	de hoofdletters				</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>	[[:lower:]]          			</SPAN
></DT
><DD
><P
>	de kleine letters			</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>	[[:digit:]]          			</SPAN
></DT
><DD
><P
>	de cijfers				</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>	[[:xdigit:]]          			</SPAN
></DT
><DD
><P
>	de hexadecimale cijfers			</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>	[[:punct:]]          			</SPAN
></DT
><DD
><P
>	de leestekens				</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>	[[:graph:]]          			</SPAN
></DT
><DD
><P
>	de zichtbare tekens			</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>	[[:print:]]          			</SPAN
></DT
><DD
><P
>	de afdrukbare tekens (zichtbare tekens
			plus de spatie				</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>	[[:blank:]]          			</SPAN
></DT
><DD
><P
>	de spatie en het tabulatie-teken	</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>	[[:space:]]          			</SPAN
></DT
><DD
><P
>	alle witruimte 
			(<SPAN
CLASS="TOKEN"
>[[:blank:]]</SPAN
> plus 
			<SPAN
CLASS="TOKEN"
>vertical tab</SPAN
> en
			<SPAN
CLASS="TOKEN"
>form feed</SPAN
>		</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>	[[:cntrl:]]          			</SPAN
></DT
><DD
><P
>	de stuurtekens				</P
></DD
></DL
></DIV
><P
> 
	Welke tekens tot deze klassen behoren is afhankelijk 
	van uw <I
CLASS="FIRSTTERM"
>locale</I
>. 
	Als <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> uw moedertaal is, dan typt u 
	<B
CLASS="COMMAND"
>export LANG=C</B
> of 
	<B
CLASS="COMMAND"
>export LANG=POSIX</B
>. 
	De klasse <SPAN
CLASS="TOKEN"
>[:upper:]</SPAN
> bevat dan alleen de 
	<SPAN
CLASS="ACRONYM"
>ASCII</SPAN
> tekens A - Z, maar met 
	<B
CLASS="COMMAND"
> export LANG=nl_NL</B
> worden ook de 
	diakritische tekens als 
	&Auml;&Ucirc;&Eacute;&Ograve;&Ntilde;&Aring;&szlig;&Ccedil;&ijlig;&Rcaron;&Omacr;&OElig;&Idot;&inodot; 
	met <SPAN
CLASS="ACRONYM"
>ASCII</SPAN
> nummers boven 127 toe gerekend. 
	Ook de volgorde van de output van <B
CLASS="COMMAND"
>sort -d -f</B
> 
	is afhankelijk met de ingestelde locale. 
  </P
><P
>	De <I
CLASS="FIRSTTERM"
>equivalentie klassen</I
> zijn eveneens 
	afhankelijk van de locale en worden door 
	<SPAN
CLASS="ACRONYM"
>GNU</SPAN
> nog niet goed ondersteund. 
	De notatie <SPAN
CLASS="TOKEN"
>[[=<TT
CLASS="REPLACEABLE"
><I
>letter</I
></TT
>=]]</SPAN
> 
	duidt de verzameling van tekens aan die in het woordenboek 
	op de zelfde plaats komen, zoals hoofdletters en letters 
	met een accent. 
  </P
><P
>	De  <SPAN
CLASS="ACRONYM"
>GNU</SPAN
> versie heeft weer een uitgebreidere 
	set van regels, waaronder de mogelijkheid om terug te refereren 
	naar een eerdere RE tussen haakjes met een backslash gevolgd 
	door het nummer van die expressie, bijv. 
	<TT
CLASS="LITERAL"
>([a-z]) is een \1.*"</TT
> correspondeert met 
	regels als `a is een aapje, dat eet uit zijn poot', `b is een 
	bakker, die bakt voor ons brood'. 
  </P
><P
>	Nog uitgebreider dan egrep is 
	<A
HREF="http://www.tgries.de/agrep/"
TARGET="_top"
>	  <I
CLASS="FIRSTTERM"
>agrep</I
>,
	</A
>
	een algorithme van Sun Wu en Udi Manber.
	Hiermee kun je zoeken op strings die ongeveer gelijk zijn 
	aan het zoekpatroon. 
  </P
><P
>	De belangrijkste extra optie is het maximum toegestane aantal 
	fouten (letters die je moet wijzigen, toevoegen, vervangen om 
	ze met het zoekpatroon te laten overeenkomen). 
	Als eerste optie wordt dan <TT
CLASS="OPTION"
>-1, -2, ...</TT
> 
	aangegeven.
  </P
><P
>	Een andere extra optie is mogelijkheid te zoeken naar alle 
	strings die een uitbreiding van het zoekpatroon bevatten. 
	In plaats van <B
CLASS="COMMAND"
>egrep 'a.*b.*c.*d.*e'</B
> 
	schrijf je dan <B
CLASS="COMMAND"
>agrep -p 'abcde'</B
>.
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="FIND"
></A
>find en xargs</H3
><P
>	Een van de meest voorkomende taken van shell scripts is 
	het zoeken naar bepaalde bestanden en het bewerken ervan. 
	Script programmeurs gebruiken hiervoor liever 
	<I
CLASS="FIRSTTERM"
>find</I
> dan ls. 
	Find zoekt een directory en diens subdirectory's recursief 
	af en levert als uitvoer een reeks padnamen (namen van 
	bestanden plus directory's) die aan bepaalde criteria 
	voldoen. 
	De uitvoer wordt niet gesorteerd. 
  </P
><P
>	Om een commando uit te voeren op elk van de gevonden 
	bestanden zou je iets kunnen doen als 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1236"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>for bestand in `find ....`
do 
  <TT
CLASS="REPLACEABLE"
><I
>commando</I
></TT
> $bestand 
done 								</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>

	Dit heeft het nadeel dat de output van find potentieel 
	enorm lang kan zijn, terwijl shells maar een beperkte lengte 
	voor een commandoregel kunnen accepteren. 
	Deze maximale lengte kun je vinden met het commando 
    	<B
CLASS="COMMAND"
> find /usr/include -name limits.h -follow -exec grep 
	ARG_MAX \{\} \; 2&#62;&#62;/dev/null </B
>
  </P
><P
>	De oplossing is de <I
CLASS="FIRSTTERM"
>xargs</I
> opdracht, 
	die het commando naar wens herhaalt, bijvoorbeeld tien keer 
	met telkens honderd argumenten, als er duizend bestanden 
	zijn gevonden. 
	De syntaxis van deze opdrachten luidt:

    <P
><B
CLASS="COMMAND"
> find						</B
>  [	<TT
CLASS="REPLACEABLE"
><I
>	file					</I
></TT
>
      ...] [	<TT
CLASS="REPLACEABLE"
><I
>	expressie				</I
></TT
>
      ]   | \					 <BR><B
CLASS="COMMAND"
>		xargs					</B
>  [        <TT
CLASS="REPLACEABLE"
><I
>	optie					</I
></TT
>
      ...] [	<TT
CLASS="REPLACEABLE"
><I
>	commando				</I
></TT
>
      ] [	<TT
CLASS="REPLACEABLE"
><I
>	argument				</I
></TT
>
      ...]</P
>
  </P
><P
>	Het volgende voorbeeld zoekt alle core dumps in uw home 
	directory en subdirectory's. 
	<B
CLASS="COMMAND"
>	find ~ -name "core" -print | xargs file	</B
>
  </P
><P
>	De lijst van argumenten begint met een reeks directory's 
	die worden doorzocht, gevolgd door een optionele reeks 
	van tests en een of meer <I
CLASS="FIRSTTERM"
>akties</I
>. 
	De akties worden alleen uitgevoerd als alle opties 
	<TT
CLASS="LITERAL"
>true</TT
> opleveren; 
	er mag ook <TT
CLASS="OPTION"
>-a</TT
> tussen worden gezet. 
	Als meerdere opties worden verbonden door <TT
CLASS="OPTION"
>-o</TT
> 
	dan zal de combinatie waar (0) opleveren als 
	&eacute;&eacute;n ervan waar is. 
	Het resultaat van een optie kan worden omgekeerd door er een 
	<TT
CLASS="OPTION"
>!</TT
> voor te zetten en opties mogen tussen 
	<TT
CLASS="OPTION"
>( )</TT
> haakjes worden gegroepeerd. 
	De haakjes moeten door een backslash worden beschermd tegen 
	substitutie door de shell. 
  </P
><P
>	Find kent de volgende tests: 
    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>	 -name <TT
CLASS="REPLACEABLE"
><I
>"string"</I
></TT
></TT
></DT
><DD
><P
>	waar als de naam van de file overeenkomt; 
			de string mag wildcards bevatten mits er 
			haakjes omheen of backslashes voor staan 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>	 -perm <TT
CLASS="REPLACEABLE"
><I
>getal</I
></TT
>	</TT
></DT
><DD
><P
>	waar als de <I
CLASS="FIRSTTERM"
>permissie bits</I
> 
			overeenkomen met het oktale getal. 
			<B
CLASS="COMMAND"
>man chmod</B
> geeft meer 
			informatie over deze numerieke modes. 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>	 -type <TT
CLASS="REPLACEABLE"
><I
>t</I
></TT
>	</TT
></DT
><DD
><P
>	waar als het bestand van het type 
			<TT
CLASS="REPLACEABLE"
><I
>t</I
></TT
> is; 
			<TT
CLASS="LITERAL"
>f</TT
> staat voor een 
			gewone file, <TT
CLASS="LITERAL"
>d</TT
> voor 
			een directory, <TT
CLASS="LITERAL"
>b</TT
> voor 
			een block special file en 
			<TT
CLASS="LITERAL"
>c</TT
> voor character special 
			file. 
			Nieuwere systemen kennen ook 
			<TT
CLASS="LITERAL"
>p</TT
> voor named pipes, 
			<TT
CLASS="LITERAL"
>s</TT
> voor sockets en 
			<TT
CLASS="LITERAL"
>l</TT
> voor 
			<I
CLASS="FIRSTTERM"
>symbolic links</I
> 
			(snelkoppelingen).
	</P
></DD
><DT
><TT
CLASS="OPTION"
>	 -links <TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>	</TT
></DT
><DD
><P
>	waar als het bestand 
			<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
> links bezit.
	</P
></DD
><DT
><TT
CLASS="OPTION"
>	 -user <TT
CLASS="REPLACEABLE"
><I
>naam</I
></TT
>	</TT
></DT
><DD
><P
>	waar als het bestand eigendom is van 
			gebruiker <TT
CLASS="REPLACEABLE"
><I
>naam</I
></TT
>; 
			dat mag een login naam of nummer zijn.  
	</P
></DD
><DT
><TT
CLASS="OPTION"
>	 -group <TT
CLASS="REPLACEABLE"
><I
>naam</I
></TT
>	</TT
></DT
><DD
><P
>	waar als het bestand eigendom is van 
			groep <TT
CLASS="REPLACEABLE"
><I
>naam</I
></TT
>; 
			dat mag een groep naam of nummer zijn.
	</P
></DD
><DT
><TT
CLASS="OPTION"
>	 -size <TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>	</TT
></DT
><DD
><P
>	waar als de grootte van het bestand 
			<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
> 
			<I
CLASS="FIRSTTERM"
>disk blocks</I
> bedraagt. 
			Een disk block is 512 bytes groot, niet te 
			verwarren met de blokken van 1024 bytes van 
			<B
CLASS="COMMAND"
>df</B
>. 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>	 -inum <TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>	</TT
></DT
><DD
><P
>	waar als het bestand <I
CLASS="FIRSTTERM"
>inode
			nummer</I
> <TT
CLASS="REPLACEABLE"
><I
>n
			</I
></TT
> heeft.
	</P
></DD
><DT
><TT
CLASS="OPTION"
>	 -atime <TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>	</TT
></DT
><DD
><P
>	waar als het bestand gedurende de laatste 
			<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
> dagen is
			gebruikt. 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>	 -mtime <TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>	</TT
></DT
><DD
><P
>	waar als het bestand gedurende de laatste
			<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
> dagen is 
			gewijzigd.
	</P
></DD
><DT
><TT
CLASS="OPTION"
>	 -newer <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>	</TT
></DT
><DD
><P
>	waar als het bestand recenter is gewijzigd
			dan de opgegeven <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>
	</P
></DD
></DL
></DIV
>
  </P
><P
>	In de voorafgaande opties kan gehalve <TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
> 
	om een aantal aan te duiden ook de notatie 
	+<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
> worden gebruikt voor aantallen 
	groter dan <TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
> of
	-<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
> om aantallen kleiner dan 
	<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
> aan te duiden. 
  </P
><P
>	Het volgende voorbeeld zoekt naar andermans files in uw home 
	directory.  
	<B
CLASS="COMMAND"
>find ~ \! -user $USER -type f -print | xargs ls -l </B
>
  </P
><P
>	Find kent de volgende akties:
    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>	 -print					</TT
></DT
><DD
><P
>	drukt de naam van het huidige bestand af 
			op de uitvoer. 
			In de <SPAN
CLASS="ACRONYM"
>GNU</SPAN
> versie kan 
			deze aktie worden weggelaten. 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>	 -exec <TT
CLASS="REPLACEABLE"
><I
>commando</I
></TT
></TT
></DT
><DD
><P
>	waar als de exit status van het 
			<TT
CLASS="REPLACEABLE"
><I
>commando</I
></TT
> 
			gelijk is aan nul.  
			Het commando moet worden be&euml;indigd 
			met een puntkomma. 
			Als het commando <TT
CLASS="OPTION"
>{}</TT
> bevat, 
			dan zal dat worden vervangen door de huidige 
			filenaam. 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>	 -ok <TT
CLASS="REPLACEABLE"
><I
>commando</I
></TT
></TT
></DT
><DD
><P
>	waar als de exit status van het 
			<TT
CLASS="REPLACEABLE"
><I
>commando</I
></TT
> gelijk is 
			aan nul. 
			Find vraagt dan eerst om bevestiging en voert 
			het commando alleen uit als er 
			<TT
CLASS="USERINPUT"
><B
>y</B
></TT
> wordt ingevoerd. 
	</P
></DD
></DL
></DIV
>

	De <SPAN
CLASS="ACRONYM"
>GNU</SPAN
> versie heeft nog veel meer opties, 
	onder andere: 

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>	 -follow				</TT
></DT
><DD
><P
>	volg symbolische links
	</P
></DD
><DT
><TT
CLASS="OPTION"
>	 -mount					</TT
></DT
><DD
><P
>	sla gemounte filesystemen over
	</P
></DD
><DT
><TT
CLASS="OPTION"
>	 -maxdepth <TT
CLASS="REPLACEABLE"
><I
>nivo</I
></TT
></TT
></DT
><DD
><P
>	daal de directoryboom slechts tot het 
			opgegeven aantal <TT
CLASS="REPLACEABLE"
><I
>nivo's</I
></TT
>
			af.
	</P
></DD
></DL
></DIV
>
  </P
><P
>	Hieronder een iets andere manier om <I
CLASS="FIRSTTERM"
>core</I
> 
	files te zoeken. 
	Let op de backslashes.
	<B
CLASS="COMMAND"
>find ~ -name core -exec file \{\}\; -print | grep core</B
>
	Een handige manier om de inhoud van directory 
	<TT
CLASS="REPLACEABLE"
><I
>origineel</I
></TT
> met alle subdirectory's 
	te kopi&euml;ren naar directory <TT
CLASS="REPLACEABLE"
><I
>bestemming</I
></TT
> 
	gebruikt de <I
CLASS="FIRSTTERM"
>pass-through</I
> optie van 
	<I
CLASS="FIRSTTERM"
>cpio</I
>: 
	<B
CLASS="COMMAND"
>find <TT
CLASS="REPLACEABLE"
><I
>origineel</I
></TT
> -print | 
	cpio -pdm <TT
CLASS="REPLACEABLE"
><I
>bestemming</I
></TT
></B
>. 
	<SPAN
CLASS="ACRONYM"
>SCO</SPAN
> <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> heeft hiervoor 
	een <I
CLASS="FIRSTTERM"
>copy</I
> commando. 
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="DU"
></A
>directory's doorlopen met du</H3
><P
>	De <I
CLASS="FIRSTTERM"
>du</I
> utility geeft een overzicht 
	van de hoeveelheid schijfruimte die een bepaalde 
	directory samen met de onderliggende subdirectory's in beslag 
	neemt. 
	Behalve als een uitgebreide versie van <I
CLASS="FIRSTTERM"
>df</I
> 
	kun je het ook beschouwen als een snelle variant op find, 
	die alleen directory's weergeeft. 
	De syntaxis luidt: 

    <P
><B
CLASS="COMMAND"
> 	du					</B
>  [-a					] [-k					] [-s					] [-x					] [        <TT
CLASS="REPLACEABLE"
><I
>	directory				</I
></TT
>
      ...]</P
>
  </P
><P
>	Als er geen directory's opgegeven zijn, bekijkt du de 
	huidige directory. 
	De opties zijn als volgt: 
    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-a</TT
> (all)</DT
><DD
><P
>	geef de grootte van alle files, niet
			alleen directory's
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-k</TT
> (kilobyte)</DT
><DD
><P
>	rapporteer de schijfruimte in kilobytes; 
			de standaardeenheid kan 512 bytes of 
			1024 bytes zijn. 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-s</TT
> (summary)</DT
><DD
><P
>	geef slechts &eacute;&eacute;n regel
			per directory
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-x</TT
> (exclude)</DT
><DD
><P
>	sla directory's op gemounte schijven over
	</P
></DD
></DL
></DIV
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SED"
></A
>sed, editen vanuit een script</H3
><P
>	Met behulp van egrep kun je informatie zoeken in een 
	tekstbestand. 
	Om regels te wijzigen is er de <I
CLASS="FIRSTTERM"
>stream editor 
	sed,</I
> een broertje van de <I
CLASS="FIRSTTERM"
>ed</I
> 
	editor, die weer een voorloper van <I
CLASS="FIRSTTERM"
>vi</I
> 
	is, die speciaal gemaakt is voor gebruik in scripts. 
	Sed kopi&euml;ert telkens een volgende regel van de invoer 
	naar de <I
CLASS="FIRSTTERM"
>patroonbuffer</I
>, 
	voert de opdrachten in zijn edit script &eacute;&eacute;n 
	voor &eacute;&eacute;n uit en kopi&euml;ert de buffer 
	naar de uitvoer. 
	De syntaxis luidt:

    <P
><B
CLASS="COMMAND"
> 	sed					</B
>  [-n					] [-e <TT
CLASS="REPLACEABLE"
><I
>script</I
></TT
>	] [-f <TT
CLASS="REPLACEABLE"
><I
>sfile</I
></TT
>	] [        <TT
CLASS="REPLACEABLE"
><I
>	file				</I
></TT
>
      ...]</P
>
  </P
><P
>	Als de filenaam of -namen ontbreken dan zal sed de 
	standaard invoer verwerken. 
	Het edit script kan op de commandoregel achter de 
	<TT
CLASS="OPTION"
>-e</TT
> vlag tussen aanhalingstekens worden 
	meegegeven of worden gelezen uit de file die met de 
	<TT
CLASS="OPTION"
>-f</TT
> vlag wordt aangeduid. 
	Als de <TT
CLASS="OPTION"
>-n</TT
> vlag wordt gebruikt, dan 
	wordt er alleen uitvoer gegeneerd door de print opdracht. 
  </P
><P
>	Onderstaand scriptje print de regels uit het wachtwoordbestand 
	die de letters <TT
CLASS="LITERAL"
>rot</TT
> of <TT
CLASS="LITERAL"
>root</TT
> 
	bevatten, net als egrep. 
	Zonder de <TT
CLASS="OPTION"
>-n</TT
> vlag zouden deze dubbel worden geprint. 
	<B
CLASS="COMMAND"
>sed -n -e '/ro\+t/p' /etc/passwd 		</B
>
  </P
><P
>	Sed scripts zien er nog cryptischer uit dan shell scripts; 
	ze bestaan in het algemeen uit regels van de vorm 

  <P
>[	<TT
CLASS="REPLACEABLE"
><I
>adres</I
></TT
>1 
       [, <TT
CLASS="REPLACEABLE"
><I
>adres</I
></TT
>2	]
    ] [!						] [	argument						...]</P
>
  </P
><P
>	Een scriptregel zonder adres wordt toegepast op elke 
	regel in de invoer, met &eacute;&eacute;n adres wordt de 
	functie toegepast op elke regel die met 
	<TT
CLASS="REPLACEABLE"
><I
>adres</I
></TT
>1 overeenkomt, en met 
	twee adressen op de regels vanaf de eerste die overeenkomt 
	met <TT
CLASS="REPLACEABLE"
><I
>adres</I
></TT
>1 tot de volgende die 
	overeenkomt met <TT
CLASS="REPLACEABLE"
><I
>adres</I
></TT
>2. 
	Als dat niet geworden wordt, tot aan het eind van de file. 
	Als achter het adres een uitroepteken staat wordt de functie 
	toegepast op alle regels die niet geselecteerd zijn. 
  </P
><P
>	Een adres kan een decimaal regelnummer zijn, cat vanaf 1 
	geteld wordt, <TT
CLASS="LITERAL"
>$</TT
> voor de laatste 
	regel of een reguliere expressie tussen schuine strepen. 
	De <SPAN
CLASS="ACRONYM"
>GNU</SPAN
> versie staat toe de reguliere 
	expressie te begrenzen met een ander teken dan de slash. 
	Het volgende voorbeeld retourneert de regels tussen 
	'root' en `bin' uit hter wachtwoordbestand.
	<B
CLASS="COMMAND"
>sed -e '\#root#,\#bin#!d' /etc/passwd 		</B
>
  </P
><P
>	Sed kent onder andere de volgende functies:
   <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>p</TT
> (print)</DT
><DD
><P
>	kopi&euml;er de inhoud van de 
			patroonbuffer naar de uitvoer; zonder de 
			<TT
CLASS="OPTION"
>-n</TT
> optie kan dat 
			resulteren in dubbel afgedrukte regels. 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>n</TT
> (next)</DT
><DD
><P
>	drukt de inhoud van de patroonbuffer af 
			op de uitvoer en leest de volgende 
			regel van de invoer in de patroonbuffer. 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>d</TT
> (delete)</DT
><DD
><P
>	maak de patroonbuffer leeg en ga verder 
			met de volgende regel. 
	  </P
></DD
><DT
><P
> 			a \  <BR>  	
			<TT
CLASS="REPLACEABLE"
><I
>tekst</I
></TT
>	 </P
></DT
><DD
><P
>	plaats een regel tekst in de uitvoer 
			voordat de volgende regel wordt gelezen.
	</P
></DD
><DT
><P
> 			c \  <BR>  	
			<TT
CLASS="REPLACEABLE"
><I
>tekst</I
></TT
>	 </P
></DT
><DD
><P
>	Maak de patroonbuffer leeg, schrijf de 
			tekst naar de uitvoer en lees de volgende 
			regel in. 
	</P
></DD
><DT
><P
> 			i \  <BR>  	
			<TT
CLASS="REPLACEABLE"
><I
>tekst</I
></TT
>	 </P
></DT
><DD
><P
>	plaats een regel tekst in de uitvoer. 
			Append en insert hebben hooguit 
			&eacute;&eacute;n adres. 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>q</TT
> (quit)</DT
><DD
><P
>	be&euml;indig het programma zonder de 
			rest van de invoer te lezen. 
			Quit gebruikt hooguit &eacute;&eacute;n adres. 
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>=</TT
> (regelnummer)</DT
><DD
><P
>	schrijf het regelnummer naar de uitvoer op een 
			aparte regel.  
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>w <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
></TT
></DT
><DD
><P
>	voeg de inhoud van de patroonbuffer toe 
			aan het opgegeven bestand. 
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>r <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
></TT
></DT
><DD
><P
>	lees de inhoud van het opgegeven bestand 
			en schrijf die naar de uitvoer alvorens 
			de volgende invoerregel te lezen. 
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>h</TT
> (hold)</DT
><DD
><P
>	vervang de inhoud van de 
			<I
CLASS="FIRSTTERM"
>houdbuffer</I
> door 
			die van de patroonbuffer. 
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>g</TT
> (get)</DT
><DD
><P
>	vervang de patroonbuffer door de inhoud 
			van de houdbuffer.
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>x</TT
> (exchange)</DT
><DD
><P
>	verwissel de inhoud van de patroonbuffer 
			en de houdbuffer. 
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>y/<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>1/<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>2/</TT
> (yield)</DT
><DD
><P
>	vervang tekens uit <TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>1 
			door overeenkomstige tekens van 
			<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>2; 
			beide strings moeten even lang zijn.
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>N</TT
> (next)</DT
><DD
><P
>	voeg de volgende regel toe aan de patroonbuffer 
			met een regeleinde (<TT
CLASS="LITERAL"
>\n</TT
>) 
			ertussen. 
			Normaliter bevat de buffer geen 
			<TT
CLASS="LITERAL"
>\n</TT
>. 
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>D</TT
> (delete)</DT
><DD
><P
>	Verwijder de eerste regel van de patroonbuffer 
			en ga verder met de volgende invoerregel. 
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>G</TT
> (get)</DT
><DD
><P
>	plaats een regel text in de uitvoer voordat 
			de volgende regel wordt gelezen.
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>P</TT
> (print)</DT
><DD
><P
>	kopi&euml;er de eerste regel van de 
			patroonbuffer naar de standaard uitvoer.  
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>H</TT
> (hold)</DT
><DD
><P
>	voeg de inhoug van de patroonbuffer toe 
			aan de houdbuffer.
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>#	<TT
CLASS="REPLACEABLE"
><I
>commentaar</I
></TT
></TT
></DT
><DD
><P
>	Na een hekje wordt de rest van de regel 
			genegeerd, net als een lege regel 
	  </P
></DD
><DT
><P
> 			{ <TT
CLASS="REPLACEABLE"
><I
>functie</I
></TT
>1	 <BR>  	
			<TT
CLASS="REPLACEABLE"
><I
>functie</I
></TT
>2	... <BR>  			}					 </P
></DT
><DD
><P
>	In plaats van een functie wordt de hele 
			groep uitgevoerd. 
			Functies op &eacute;&eacute;n regel 
			mogen ook door puntkomma's worden afgesloten. 
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>s/<TT
CLASS="REPLACEABLE"
><I
>regul. expressie</I
></TT
>/<TT
CLASS="REPLACEABLE"
><I
>vervanging</I
></TT
>/[<TT
CLASS="REPLACEABLE"
><I
>flags</I
></TT
>]</TT
> (substitute)</DT
><DD
><P
>	zoek tekst en vervang die. 
			Als voor het adres reeds een zoekexpressie is 
			gebruikt, kan achter de <TT
CLASS="LITERAL"
>s</TT
> 
			een lege expressie staan. 
			De flags kunnen een <TT
CLASS="LITERAL"
>g</TT
> 
			omvatten als er meerdere substituties in een regel 
			kunnen voorkomen, een <TT
CLASS="LITERAL"
>p</TT
> om de 
			patroonbuffer te printen als er een vervanging 
			is gemaakt en 
			<TT
CLASS="LITERAL"
>w <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
></TT
> 
			om de inhoud van de patroonbuffer naar de file te 
			schrijven als er iets is vervangen. 
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>:<TT
CLASS="REPLACEABLE"
><I
>naam</I
></TT
></TT
> (label)</DT
><DD
><P
>	doet niets, maar markeert een positie om 
			naar toe te springen. 
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>b [<TT
CLASS="REPLACEABLE"
><I
>naam</I
></TT
>]</TT
> (branch)</DT
><DD
><P
>	ga verder met de volgende functie achter 
			het label <TT
CLASS="REPLACEABLE"
><I
>naam</I
></TT
>. 
			Als de naam is weggelaten, spring naar het 
			eind van het script en ga verder met de 
			volgende invoerregel. 
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>t [<TT
CLASS="REPLACEABLE"
><I
>naam</I
></TT
>]</TT
> (test)</DT
><DD
><P
>	ga verder met de volgende functie achter 
			het label <TT
CLASS="REPLACEABLE"
><I
>naam</I
></TT
> 
			als er sinds het inlezen van de invoerregel 
			of sinds de vorige test opdracht een succesvolle 
			substitutie heeft plaatsgevonden. 
			Als de naam ontbreekt wordt er naar het eind 
			van het script gesprongen. 
	  </P
></DD
></DL
></DIV
>
  </P
><P
>	Het volgende voorbeeld zet regelnummers voor de invoer; 
	<SPAN
CLASS="ACRONYM"
>BSD</SPAN
> en <SPAN
CLASS="ACRONYM"
>gnu</SPAN
> systemen 
	bereiken hetzelfde met <B
CLASS="COMMAND"
>cat -n</B
>.  
	Omdat de regelnummers op aparte regels komen, wordt een 
	tweede sed commando gebruikt om ze samen te voegen en de 
	regeleinden te vervangen door spaties. 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1669"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>sed -n -e '=; p' | sed -n -e 'N; s/\n/ /p' 			</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	De volgende variant illustreert hoe met tweetal adressen 
	meerdere regelbereiken worden gevonden. 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1672"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>ls /bin | sed -n -e '/name/,/t/{=;p;}' | \
  sed -n -e 'N; s/\n/ /p'					</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Het volgende voorbeeld zet een spatie achter ieder teken en 
	een lege regel achter iedere regel en vervangt alle kleine 
	letters door hoofdletters. 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1675"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>sed -e 's/\(.\)/\1 /g 
y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/
G'								</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Voor meer informatie en voorbeelden, zie 
	<A
HREF="http://seders.icheme.org/"
TARGET="_top"
> the seders' grab-bag.</A
> 
	Hierna volgt een wat uitgebreider shell script dat gebruik 
	maakt van sed om commentaar in C<SUP
>++</SUP
> 
	stijl te veranderen in standaard C code. 
	Het maakt gebruik van ledige substituties om te testen of 
	een bepaald patroon in de invoerregel voorkomt. 
	De functie <I
CLASS="FIRSTTERM"
>extension</I
> behoeft wellicht 
	verbetering voor namen als <TT
CLASS="FILENAME"
>app-1.0.0.tar.gz</TT
>. 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN1682"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><B
CLASS="COMMAND"
>subst()</B
>
{ sed -e '
         //\*/s/$//
         t loop
         b cont

:loop
         /\*//s/$//
         t cont
         n
         b loop
:cont
         /\/\//s/$//
         t found
         b
:found
         /\".*\/\/.*\"/s/$//
         t
         /\*\/\/\*/s/$//
         t
         /\/\*.*\/\/.*\*\//s/$//
         t
         /\/\//s/$/ \*\//
         /\/\/.*\/\*.*\*\//s/\*\///
         /\/\//s//\/\*/
         t
         ' $1
}

<B
CLASS="COMMAND"
>stringlen()</B
>
{ if [ "$1" = "" ]
  then
    echo "0"
  else
    expr length "$1"
  fi
}

<B
CLASS="COMMAND"
>substring()</B
>
{ if [ "$1" = "" ]
  then
    echo ""
  else
    expr substr "$1" "$2" "$3"
  fi
}

<B
CLASS="COMMAND"
>lastindex()</B
>
{ name="$1"
  DotPos1=0
  DotPos2=`expr index "$name" "$2"`
  while [ "$DotPos2" -gt "0" ]
  do
    DotPos1=`expr $DotPos1 + $DotPos2`
    DotPos2=`expr $DotPos2 + 1`
    name=`substring "$name" $DotPos2 999`
    DotPos2=`expr index "$name" "$2"`
  done
  echo $DotPos1
}

<B
CLASS="COMMAND"
>extension()</B
>
{ DotPos=`lastindex "$1" "."`
  if [ "$DotPos" -gt "0" ]
  then
   substring "$1" `expr $DotPos + 1` `stringlen "$1"`
  else
    echo ""
  fi
}

<TT
CLASS="REPLACEABLE"
><I
># main loop - find files to be modified </I
></TT
>
find . -print \
| while read i
  do
    if [ -f "$i" ] &#38;&#38; [ -r "$i" ]
    then
      if [ -w "$i" ]
      then
        if [ "`extension $i`" = "c" ] || \
           [ "`extension $i`" = "h" ]
        then
          if grep '//' $i &gt;&thinsp;&gt;/dev/null
          then
            echo "File $i is modified."
            mv "$i" "$i"~
            subst "$i"~ &gt;$i
          fi
        fi
      else
        echo "File $i is not writable!"
      fi
    fi
  done								</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AWK"
></A
>tabellen verwerken met awk</H3
><P
>	De scripttaal <I
CLASS="FIRSTTERM"
>awk</I
> (klinkt als 
	<TT
CLASS="LITERAL"
>`look awk`</TT
>) is genoemd naar haar 
	makers, Aho, Weinberger en Kernighan van A, T &#38; T. 
	Awk is uitgebreider dan sed en vooral geschikt voor het 
	verwerken van tabellen. 
	Veel Unix commando's als ls, ps, en who produceren tabellen, 
	platte tekstfiles bestaaande uit kolommen met een vaste breedte. 
	De syntaxis luidt:
 
   <P
><B
CLASS="COMMAND"
> awk						</B
>  [		<TT
CLASS="REPLACEABLE"
><I
>optie</I
></TT
>
      ...] [		-f <TT
CLASS="REPLACEABLE"
><I
>sfile</I
></TT
>	
      ]   
		<TT
CLASS="REPLACEABLE"
><I
>'script'</I
></TT
>	
        [		<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>
      ...]</P
>
  </P
><P
> 
	De belangrijkste optie is 
	<TT
CLASS="OPTION"
>-F<TT
CLASS="REPLACEABLE"
><I
>t</I
></TT
></TT
>, waarmee 
	het teken <TT
CLASS="REPLACEABLE"
><I
>t</I
></TT
> als 
	<I
CLASS="FIRSTTERM"
>field separator</I
> wordt ingesteld. 
	Het script zelf kan weer als een groot argument op de 
	commandoregel worden meegegeven of in een aparte file 
	met <TT
CLASS="OPTION"
>-f</TT
>, en als er geen verdere filenamen 
	zijn meegegeven, dan zal awk de standaard invoer verwerken. 
	Awk scripts hebben over het algemeen de vorm 

    <TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>[<B
CLASS="COMMAND"
>BEGIN</B
> {<TT
CLASS="REPLACEABLE"
><I
>actie</I
></TT
>}]
[<TT
CLASS="REPLACEABLE"
><I
>patroon</I
></TT
>] [{<TT
CLASS="REPLACEABLE"
><I
>actie</I
></TT
>}] 
&hellip;
[<B
CLASS="COMMAND"
>END</B
>     {<TT
CLASS="REPLACEABLE"
><I
>actie</I
></TT
>}] </PRE
></TD
></TR
></TABLE
>
  </P
><P
>	Net als bij sed zal elke invoerregel &eacute;&eacute;n voor 
	&eacute;&eacute;n met de patronen worden vergeleken en 
	voor elk patroon dat overeenkomt zal de bijbehorende actie 
	worden uitgevoerd. 
	Als er geen patroon is opgegeven wordt de actie altijd 
	uitgevoerd en als er geen actie staat, dan wordt de 
	invoerregel afgedrukt. 
	De eventuele actie achter begin wordt voor het inlezen 
	van de eerste regel uitgevoerd en de actie achter end na 
	het eind van de laatste regel. 
	Het eerste voorbeeld verwijdert lege regels uit de invoer: 
	<B
CLASS="COMMAND"
>awk '$0'					</B
> 
  </P
><P
>	Hierin staat <TT
CLASS="LITERAL"
>$0</TT
> voor de invoerregel. 
	De invoerregel wordt door awk gesplitst in velden, 
	gescheiden door witruimte of een ander scheidingsteken, 
	genaamd <TT
CLASS="LITERAL"
>$1</TT
>, <TT
CLASS="LITERAL"
>$2</TT
>, &hellip;. 
	<TT
CLASS="LITERAL"
>NF</TT
> is het aantal velden en 
	<TT
CLASS="LITERAL"
>NR</TT
> het aantal records c.q regelnummer. 
	Het toevoegen van regelnummers aan de input gaat met awk 
	eenvoudiger dan met sed: 
	<B
CLASS="COMMAND"
>awk '{print NR " " $0}'			</B
> 
  </P
><P
>	De patronen kunnen boolese combinaties van reguliere 
	expressies en&thinsp;/&thinsp;of relationele expressies 
	zijn. 
	De boolese combinatoren zijn <B
CLASS="COMMAND"
>!</B
> (niet), 
	<B
CLASS="COMMAND"
>&#38;&#38;</B
> (en), <B
CLASS="COMMAND"
>||</B
> (of) 
	en de <B
CLASS="COMMAND"
>( )</B
> haakjes; de reguliere expressies 
	zijn eerder besproken; 
	de relationele combinatoren zijn <B
CLASS="COMMAND"
>&lt;</B
> 
	(kleiner), <B
CLASS="COMMAND"
>&gt;</B
> (groter), 
	<B
CLASS="COMMAND"
>&lt;=</B
> (kleiner of gelijk), 
	<B
CLASS="COMMAND"
>&gt;=</B
> (groter of gelijk), 
	<B
CLASS="COMMAND"
>==</B
> (gelijk), <B
CLASS="COMMAND"
>!=</B
> 
	(ongelijk), <B
CLASS="COMMAND"
>~</B
> (komt overeen met 
	reguliere expressie) en <B
CLASS="COMMAND"
>!~</B
> (komt niet 
	overeen met RE). 
  </P
><P
>	Expressies kunnen verder bestaan uit variabelen, numerieke 
	constanten (gehele getallen of drijvende komma) en string 
	constanten (tussen dubbele aanhalingstekens) en de 
	rekenkundige operatoren <B
CLASS="COMMAND"
>+</B
> (optellen), 
	<B
CLASS="COMMAND"
>-</B
> (aftrekken), <B
CLASS="COMMAND"
>*</B
> 
	(vermenigvuldigen), <B
CLASS="COMMAND"
>/</B
> (delen), 
	<B
CLASS="COMMAND"
>%</B
> (rest), <B
CLASS="COMMAND"
>^</B
> of 
	<B
CLASS="COMMAND"
>**</B
> (machtsverheffen), 
	<B
CLASS="COMMAND"
>++</B
> (1 optellen) en <B
CLASS="COMMAND"
>--</B
> 
	(1 aftrekken) als in de programmeertaal C en de string 
	operator <B
CLASS="COMMAND"
>' '</B
> (samenvoeging). 
  </P
><P
>	Behalve enkelvoudige patronen kunnen net als bij sed reeksen 
	regels worden opgegeven met een tweetal patronen. 
	De volgende regel selecteert de regels 10 t&thinsp;/&thinsp;m 
	20 van een bestand. 
	<B
CLASS="COMMAND"
>awk 'FNR==10, FNR==20' /etc/hosts		</B
> 
  </P
><P
>	Een awk script kan ook variabelen aanmaken; 
	declareren is niet nodig. 
	Een variabele kan zowel als string als getal worden 
	gebruikt en wordt automatisch ge&iuml;nitialiseerd met 
	waarden <TT
CLASS="LITERAL"
>0</TT
> en <TT
CLASS="LITERAL"
>""</TT
>. 
	De operatoren bepalen het type van het resultaat: 
	zo levert <TT
CLASS="LITERAL"
>("3x" + 1)</TT
> 4 op maar 
	<TT
CLASS="LITERAL"
>("x3" + 1)</TT
> 1. 
	Behalve een constante tussen schuine strepen kan ook 
	een variabele als reguliere expressie worden gebruikt. 
	De eenvoudigste acties zijn 
	<TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>variabele</I
></TT
> = 
	<TT
CLASS="REPLACEABLE"
><I
>expressie</I
></TT
></TT
> en 
	<TT
CLASS="LITERAL"
>print <TT
CLASS="REPLACEABLE"
><I
>expressie</I
></TT
></TT
>. 
	Het is ook mogelijk om de <I
CLASS="FIRSTTERM"
>veldvariabelen</I
> 
	$1, $2,&hellip; een andere waarde toe te kennen. 
  </P
><P
>	Moderne awk varianten kennen associatieve arrays. 
	Arrays hoeven niet gedeclareerd te worden: 
	het is voldoende een element van een array een waarde te geven 
	met <TT
CLASS="LITERAL"
><TT
CLASS="REPLACEABLE"
><I
>naam</I
></TT
>[ 
	<TT
CLASS="REPLACEABLE"
><I
>index</I
></TT
>] = 
	<TT
CLASS="REPLACEABLE"
><I
>waarde</I
></TT
></TT
>. 
	Voor de index kunnen gehele getallen of willekeurige strings 
	worden gebruikt, zelfs meerdere getallen zijn toegestaan om 
	pseudo-multidimensionale arrays te maken. 
	De waarden van de index hoeven niet opeenvolgend te zijn. 
  </P
><P
>	Awk kent een aantal rekenkundige functies. 

    <DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN1770"
></A
><P
></P
><TABLE
BORDER="0"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>sin(<TT
CLASS="REPLACEABLE"
><I
>x</I
></TT
>)</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      berekent de sinus van x, met x in radialen
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>cos(<TT
CLASS="REPLACEABLE"
><I
>x</I
></TT
>)</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      berekent de cosinus van x
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>exp(<TT
CLASS="REPLACEABLE"
><I
>x</I
></TT
>)</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      berekent de e-macht van x
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>int(<TT
CLASS="REPLACEABLE"
><I
>x</I
></TT
>)</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      berekent de entier van x 
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>log(<TT
CLASS="REPLACEABLE"
><I
>x</I
></TT
>)</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      berekent de natuurlijke logarithme van x
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>sqrt(<TT
CLASS="REPLACEABLE"
><I
>x</I
></TT
>)</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      berekent de wortel van x
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>rand</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      berekent een toevalsgetal tussen 0 en 1
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>srand(<TT
CLASS="REPLACEABLE"
><I
>x</I
></TT
>)</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      maakt x tot generator van een reeks toevalsgetallen
	    </TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Awk kent verschillende string functies. 

    <DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN1831"
></A
><P
></P
><TABLE
BORDER="0"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>gsub(<TT
CLASS="REPLACEABLE"
><I
>r,s,t</I
></TT
>)</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>		vervangt in de string <TT
CLASS="REPLACEABLE"
><I
>t</I
></TT
> 
		overal de substring <TT
CLASS="REPLACEABLE"
><I
>r</I
></TT
> 
		door <TT
CLASS="REPLACEABLE"
><I
>s</I
></TT
> en retourneert
		het aantal malen dat de substitutie is uitgevoerd
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>index(<TT
CLASS="REPLACEABLE"
><I
>s,t</I
></TT
>)</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>		retourneert de positie van substring 
		<TT
CLASS="REPLACEABLE"
><I
>t</I
></TT
>in <TT
CLASS="REPLACEABLE"
><I
>s</I
></TT
> 
		of 0 is die niet is gevonden
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>length(<TT
CLASS="REPLACEABLE"
><I
>s</I
></TT
>)</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>			retourneert de lengte van de string
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>substr(<TT
CLASS="REPLACEABLE"
><I
>s,p,n)</I
></TT
></P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>		retourneert de substring van <TT
CLASS="REPLACEABLE"
><I
>s</I
></TT
>, 
		vanaf positie <TT
CLASS="REPLACEABLE"
><I
>p</I
></TT
> van 
		<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
> tekens lang
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>tolower(<TT
CLASS="REPLACEABLE"
><I
>s</I
></TT
>)</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>		retourneert <TT
CLASS="REPLACEABLE"
><I
>s</I
></TT
> met alle 
		hoofdletters vervangen door kleine 
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>toupper(<TT
CLASS="REPLACEABLE"
><I
>s</I
></TT
>)</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>		retourneert <TT
CLASS="REPLACEABLE"
><I
>s</I
></TT
> met alle 
		kleine letters vervangen door hoofdletters 		
	    </TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Awk lijkt een beetje op C. 
	Acties c.q. statements worden gegroepeerd door accolades en 
	afgesloten door een puntkomma of nieuwe regel. 
	Een lang statement kan worden voortgezet door de regel met een 
	backslash te be&euml;indigen. 
	Na een <TT
CLASS="LITERAL"
>#</TT
> hekje wordt de rest van de regel 
	als commentaar beschouwd. 
	Het <I
CLASS="FIRSTTERM"
>if-statement</I
> heeft de volgende syntaxis. 
 
     <TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
><B
CLASS="COMMAND"
>if</B
>( <TT
CLASS="REPLACEABLE"
><I
>expressie</I
></TT
> ) <TT
CLASS="REPLACEABLE"
><I
>statement</I
></TT
>1 [<B
CLASS="COMMAND"
>else</B
> <TT
CLASS="REPLACEABLE"
><I
>statement</I
></TT
>2] </PRE
></TD
></TR
></TABLE
>
  </P
><P
>	Als de expressie ongelijk is aan 0 c.q. "", dan wordt het 
	eerste statement uitgevoerd en anders het optionele tweede. 
	Voor herhaling bestaan er twee varianten van 
	<I
CLASS="FIRSTTERM"
>while</I
> en de 
	<I
CLASS="FIRSTTERM"
>for-lus</I
>.
 
    <TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>  
<B
CLASS="COMMAND"
>while(</B
> <TT
CLASS="REPLACEABLE"
><I
>expressie</I
></TT
>) <TT
CLASS="REPLACEABLE"
><I
>statement</I
></TT
>
<B
CLASS="COMMAND"
>do</B
> <TT
CLASS="REPLACEABLE"
><I
>statement</I
></TT
> <B
CLASS="COMMAND"
>while</B
> (<TT
CLASS="REPLACEABLE"
><I
>expressie</I
></TT
>) 
<B
CLASS="COMMAND"
>for</B
>( <TT
CLASS="REPLACEABLE"
><I
>expressie</I
></TT
>1; <TT
CLASS="REPLACEABLE"
><I
>expressie</I
></TT
>2; <TT
CLASS="REPLACEABLE"
><I
>expressie</I
></TT
>3) <TT
CLASS="REPLACEABLE"
><I
>statement</I
></TT
> </PRE
></TD
></TR
></TABLE
>
  </P
><P
> 
	De eerste expressie achter for initialiseert de lus, de 
	tweede test of de lus be&euml;indigd moet worden en de derde 
	wordt na elke doorgang uitgevoerd. 
	Om tot tien te tellen gebruik je
	<B
CLASS="COMMAND"
>awk 'BEGIN {} {} END {for( i = 1;i &#60;= 10;i++) print i}'</B
>
  </P
><P
>	De volgende vorm van de for-lus loopt alle elementen van 
	een array af:
 
    <TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
><B
CLASS="COMMAND"
>for</B
> (<TT
CLASS="REPLACEABLE"
><I
>variabele</I
></TT
> <B
CLASS="COMMAND"
>in</B
> <TT
CLASS="REPLACEABLE"
><I
>array</I
></TT
>) <TT
CLASS="REPLACEABLE"
><I
>statement</I
></TT
> </PRE
></TD
></TR
></TABLE
>
  </P
><P
> 
	Met <B
CLASS="COMMAND"
>break</B
> kan een lus voort&ijlig;dig worden 
	verlaten; 
	met <B
CLASS="COMMAND"
>continue</B
> wordt de rest van de inhoud 
	van de lus overgeslagen en met <B
CLASS="COMMAND"
>exit</B
> 
	wordt de rest van de invoer overgeslagen en gaat awk verder 
	met de eventuele actie achter <B
CLASS="COMMAND"
>end</B
>; 
	in de end-sectie kan weer een <B
CLASS="COMMAND"
>exit</B
> 
	opdracht volgen met een exit status. 
  </P
><P
>	In moderne versies van awk kunnen in een script eigen 
	functies gedefinieerd worden met

    <TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
><B
CLASS="COMMAND"
>function</B
> <TT
CLASS="REPLACEABLE"
><I
>naam</I
></TT
>( <TT
CLASS="REPLACEABLE"
><I
>parameter</I
></TT
>1,&thinsp;&hellip; ) { <TT
CLASS="REPLACEABLE"
><I
>statements</I
></TT
> } </PRE
></TD
></TR
></TABLE
>
  </P
><P
>	Functies moeten worden gedeclareerd voordat ze kunnen 
	worden gebruikt. 
	Met de <B
CLASS="COMMAND"
>return</B
> opdracht kunnen ze 
	een waarde teruggeven. 
	Als in een functie de waarde van een parameter gewijzigd 
	wordt, dan zal dit geen effekt hebben op de waarde van 
	een variabele die als argument is meegeven, behalve voor 
	arrays. 
  </P
><P
>	Het is mogelijk om met <I
CLASS="FIRSTTERM"
>print</I
> naar 
	een willekeurige file te schrijven met de notatie

    <TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
> 
<B
CLASS="COMMAND"
>print</B
> <TT
CLASS="REPLACEABLE"
><I
>waarde</I
></TT
> &gt;"<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>" </PRE
></TD
></TR
></TABLE
>

	Zonder de aanhalingstekens is file een variabele die de 
	naam van het bestand bevat. 
	Om de uitvoer achter de bestaande inhoud van het bestand 
	te plakken wordt het volgende gebruikt:

    <TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
><B
CLASS="COMMAND"
>print</B
> <TT
CLASS="REPLACEABLE"
><I
>waarde</I
></TT
> &gt;&thinsp;&gt;"<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>" </PRE
></TD
></TR
></TABLE
>

	Het is ook mogelijk om binnen een awk script een extern 
	commando te starten dat de uitvoer van print leest 
	met de notatie 

    <TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
><B
CLASS="COMMAND"
>print</B
> <TT
CLASS="REPLACEABLE"
><I
>waarde</I
></TT
> | "<TT
CLASS="REPLACEABLE"
><I
>commando</I
></TT
>" </PRE
></TD
></TR
></TABLE
>

	Om de output van een extern commando in te lezen kun je iets 
	als <B
CLASS="COMMAND"
>system( "<TT
CLASS="REPLACEABLE"
><I
>commando</I
></TT
>" | 
	getline)</B
> gebruiken. 
  </P
><P
>	Om nette tabellen te maken wordt het <I
CLASS="FIRSTTERM"
>printf</I
> 
	statement gebruikt met de volgende syntaxis:

    <TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
><B
CLASS="COMMAND"
>printf</B
> "<TT
CLASS="REPLACEABLE"
><I
>formaat</I
></TT
>", <TT
CLASS="REPLACEABLE"
><I
>expressie</I
></TT
>1,&thinsp;&hellip; </PRE
></TD
></TR
></TABLE
>
  </P
><P
>	De formaat string wordt gewoon afgedrukt, afgezien van 
	formaat specificaties, die worden vervangen door 
	&eacute;&eacute;n van de volgende expressies. 
	Anders dan voor print moet de formaat string worden afgesloten 
	met een regeleinde (<TT
CLASS="LITERAL"
>\n</TT
>). 
	Een formaat specificatie geeft aan in welk formaat de 
	bijbehorende expressie moet worden afgedrukt en heeft de vorm 

    <TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SYNOPSIS"
>%[-][0][<TT
CLASS="REPLACEABLE"
><I
>breedte</I
></TT
>[.<TT
CLASS="REPLACEABLE"
><I
>precisie</I
></TT
>]]<TT
CLASS="REPLACEABLE"
><I
>type</I
></TT
> </PRE
></TD
></TR
></TABLE
>
  </P
><P
>	De expressie wordt afgedrukt in <TT
CLASS="REPLACEABLE"
><I
>breedte</I
></TT
> 
	kolommen, mits het daarin past, en eventueel aangevuld met 
	spaties, maar als de breedte met 0 begint, worden er 
	voorloopnullen gebruikt. Een eventueel min-teken geeft aan 
	dat de waarde links moet worden aangelijnd. 
	Voor getallen geeft de <TT
CLASS="REPLACEABLE"
><I
>precisie</I
></TT
> 
	het aantal cijfers achter de komma c.q. decimale punt weer; 
	voor strings is dat de lengte waarop de string wordt afgekapt, 
	waarna het resultaat wordt aangevuld tot de opgegeven breedte. 
	Het afkappen van relevante informatie kan een bug in een script 
	vormen. 
	De volgende formaattypen zijn mogelijk. 

    <DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN1967"
></A
><P
></P
><TABLE
BORDER="0"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>%%</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      een enkel procentteken
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>%c</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      een enkel letterteken
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>%c</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      een enkel letterteken
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>%s</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      een string
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>%d</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      een geheel getal; breuken worden niet afgerond
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>%o</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      een positief geheel getal in octale stelsel
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>%x</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      een positief geheel getal in hexadecimale stelsel
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>%f</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      een decimale breuk
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>%e</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      een getal in drijvende-komma notatie
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>%g</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      de best leesbare notatie voor het getal
	    </TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Zo zullen de volgende opdrachten

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN2033"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>{ printf "%10.3s\n", 3.1415692}
{ printf "%10.3f\n", 3.1415692} 				</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
	als output geven:
    <TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>       3.1
     3.142							</PRE
></TD
></TR
></TABLE
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXPECT"
></A
>expect en andere scripttalen</H3
><P
>	De behandeling van awk is hier vrij kort gehouden 
	ondanks de vrij complexe materie. 
	De clou is dat een van de belangrijkste redenen om awk 
	binnen een shell script te gebruiken, de printf functie, 
	ook in de korn en bourne again shells is ingebouwd. 
	Ook de andere scripttalen als Perl, TCL, PHP3 en Python, 
	zijn te uitgebreid om hier te behandelen. 
	Perl lijkt enigszins op awk, met nog meer mogelijkheden. 
	Tk maakt in combinatie met TCL of Perl GUI scripts mogelijk. 
  </P
><P
>	C programmeurs gebruiken make files, die aangeven welke 
	source files met welke opties moeten worden gecompileerd 
	om binaries en libraries te maken. 
	Make files bevatten weer shell commando's. 
	De m4 macroprocessor is een geval apart, dat te vergelijken 
	is met de C preprocessor, en handig is voor assembly 
	programmeurs. 
	Een m4 file kan willekeurige tekst bevatten plus 
	macrodefinities en macro's. M4 vervangt dan de macro's 
	door hun definitie. 
  </P
><P
>	Postscript&trade; van Adobe wordt een 
	paginabeschrijvingstaal genoemd. 
	Postscript programma's worden geschreven door 
	opmaakprogramma's en uitgevoerd door printers, 
	resulterend in een of meer pagina's gedrukt tekst. 
	Elementen die op elke pagina terugkomen worden eenmalig 
	als een functie gedefinieerd. Verder heeft het wat
	van Forth weg. 
	Het voordeel is dat de taal onafhankelijk van het type printer is. 
  </P
><P
>	Om een script te schrijven dat interactie, zowel in- als 
	uitvoer, pleegt met een ander programma, kun je gebruik 
	maken van 
	<A
HREF="http://expect.nist.gov"
TARGET="_top"
><I
CLASS="FIRSTTERM"
>Expect</I
>,</A
> 
	dat weer gebruik maakt van John Ousterhout's Tool Command 
	Language. 
	De syntaxis luidt 

  <P
><B
CLASS="COMMAND"
>		expect					</B
>  [	-di					] [	-c <TT
CLASS="REPLACEABLE"
><I
>script</I
></TT
>	] [	-f <TT
CLASS="REPLACEABLE"
><I
>sfile</I
></TT
>	]  				... </P
>
  </P
><P
>	De <TT
CLASS="OPTION"
>-d</TT
> optie geeft een hoop diagnostische 
	uitvoer. 
	Met de <TT
CLASS="OPTION"
>-i</TT
> optie gedraagt expect zich als 
	een interactieve shell. 
	Achter <TT
CLASS="OPTION"
>-c</TT
> kan in een heel script (tussen 
	aanhalingstekens) worden opgegeven en met <TT
CLASS="OPTION"
>-f</TT
> 
	kan de naam van de file met het script worden meegegeven. 
	Hieronder volgt een voorbeeld waarin expect wordt gebruikt 
	om een bestand te downloaden via ftp, wat met de shell niet 
	zou lukken. 
  </P
><P
>    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN2058"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>						<B
CLASS="COMMAND"
>#!/usr/bin/expect -f						</B
>

<TT
CLASS="REPLACEABLE"
><I
># zoals aangegeven in paragraaf 1.3 wordt hierboven
# expect gestart en de rest zijn expect commando's		</I
></TT
>

spawn ftp localhost
								<TT
CLASS="REPLACEABLE"
><I
># Met spawn wordt een extern programma gestart 			</I
></TT
>

expect -re "Connected.*\n"
expect -re "220.*\n"
expect -re "Name.*:.?"
								<TT
CLASS="REPLACEABLE"
><I
># Het expect commando laat expect wachten totdat het
# het externe programma de opgegeven strings uitprint
# of er een time-out of end-of-file optreedt. 
# Na de -re optie volgt een reguliere expressie. 
# \n staat voor een nieuwe regel en \r voor return. 		</I
></TT
>

send "anonymous\r"
expect "anonymous\r\n"

								<TT
CLASS="REPLACEABLE"
><I
># Het send commando stuurt de user naam naar het ftp
# proces. Dat zal de invoer terug echoen.			</I
></TT
>

expect  {
          -re 331.*\nPassword: {
                                 expect_user -re.*\n
                               }
         }

								<TT
CLASS="REPLACEABLE"
><I
># We wachten op de password-prompt van de ftp server
# en dan vraagt het script de gebruiker om zelf 
# het wachtwoord in te vullen. 					</I
></TT
>

send "$expect_out(0,string)\r"
expect "\r\n"

								<TT
CLASS="REPLACEABLE"
><I
># We sturen de invoer van de gebruiker naar de ftp
# server. Die zal het wachtwoord niet laten zien. 		</I
></TT
>

expect  {
        -re (230.*\n)+.*\n.*\n  {}
        -re (530.*.n)+.*\n      exit
        }
}

								<TT
CLASS="REPLACEABLE"
><I
># Nu zijn er twee mogelijk heden: 230. User anonymous
# logged in, of 530. Login incorrect; in het eerste
# geval doen we niets en in het tweede geval stoppen
# we de expect sessie. 						</I
></TT
>

expect -re "ftp&#62;.?"
send "cd pub\r"
expect "cd pub\r\n"
expect -re "(250.*\n)*250.*successful.*\n"

								<TT
CLASS="REPLACEABLE"
><I
># We wachten op de ftp prompt en sturen "cd pub" 
								</I
></TT
>
expect -re "ftp&#62;.?"
send "ls\r"
expect "ls\r\n"
expect -re "200.*\n150.*\ntotal(.*\n)+226.*\n"

								<TT
CLASS="REPLACEABLE"
><I
># We sturen "ls" en krijgen een aantal regels terug, 
# en na de prompt sturen we "get README" 			</I
></TT
>

expect -re "ftp&#62;.?"
send "get README\r"
expect "get README\r\n"
expect {
 -re local.*\n200.*\n150.*\n226.*\n.*received.*\n {}
 -re local.*\n200.*\n550.*\n                       exit

}								</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>

	De rest van dit hoofdstuk wordt besteed aan een korte 
	beschrijving van enkele handige 
	<SPAN
CLASS="ACRONYM"
>Unix</SPAN
> commando's. 
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="AT"
></A
>at en batch</H3
><P
>	De <I
CLASS="FIRSTTERM"
>at</I
> faciliteit zorgt ervoor dat 
	opdrachten op een later tijdstip worden uitgevoerd. 
	De syntaxis luidt: 

  <P
><B
CLASS="COMMAND"
>		at					</B
>  [	-m					] [	-l					] [	-f <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>	] [	-q <TT
CLASS="REPLACEABLE"
><I
>letter</I
></TT
>	] [	-r <TT
CLASS="REPLACEABLE"
><I
>job</I
></TT
>	]     <TT
CLASS="REPLACEABLE"
><I
>tijdstip</I
></TT
>	 </P
>
  </P
><P
>	De <TT
CLASS="OPTION"
>-f</TT
> optie wordt gevolgd door de naam 
	van het uit te voeren script; 
	als deze optie ontbreekt, dan worden commando's van de 
	standaard invoer gelezen. 
	De uitvoer van het script wordt de gebruiker toegemaild, 
	dus die hoeft op het moment van uitvoering niet ingelogd 
	te zijn. 
	Op de meeste systemen hebben ook gewone gebruikers 
	toestemming om at te gebruiken. 
  </P
><P
>	De <TT
CLASS="OPTION"
>-m</TT
> optie zorgt ervoor dat er ook 
	mail wordt verzonden als de opdracht geen uitvoer 
	produceerde. 
	Er wordt voor gezord dat de commando's dezelfde 
	omgevingsvariabelen meekrijgen als op het moment dat 
	at werd aangeroepen. 
  </P
><P
>	Het <I
CLASS="FIRSTTERM"
>batch</I
> commando doet hetzelfde 
	als at, behalve dat commando's pas worden uitgevoerd 
	wanneer de belasting van het systeem voldoende laag is. 
	Die belasting krijg je te zien met 
	<B
CLASS="COMMAND"
>uptime</B
>. 
	De <TT
CLASS="OPTION"
>-q</TT
> vlag geeft aan in welke queue 
	(wachtrij) de job terecht komt. 
	De queue bepaalt de prioriteit waarmee een taak wordt 
	uitgevoerd: 
	<TT
CLASS="LITERAL"
>a</TT
> is de default at queue, 
	<TT
CLASS="LITERAL"
>b</TT
> de default batch queue. 
  </P
><P
>	De tijd kan worden opgegeven als 
	<TT
CLASS="REPLACEABLE"
><I
>uumm</I
></TT
> of <TT
CLASS="REPLACEABLE"
><I
>uu:mm</I
></TT
>, 
	desgewenst met <TT
CLASS="LITERAL"
>am</TT
> of <TT
CLASS="LITERAL"
>pm</TT
> 
	erachter. 
	De liefhebber mag ook <TT
CLASS="LITERAL"
>now</TT
>, 
	<TT
CLASS="LITERAL"
>midnight</TT
>, <TT
CLASS="LITERAL"
>noon</TT
> of 
	<TT
CLASS="LITERAL"
>teatime</TT
> gebruiken. 
	Daarachter komt de eventuele datum, die bijvoorbeeld 
	<TT
CLASS="LITERAL"
>today</TT
> of <TT
CLASS="LITERAL"
>tomorrow</TT
> 
	mag luiden. 
	Als het tijdstip al voorbij is, wordt aangenomen dat het 
	morgen moet zijn en als de dag al geweest is, dan zal de 
	gebruiker wel volgend jaar bedoelen. Enkele voorbeelden: 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN2108"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>at 0815am Jan 24, 2002 
at 8:15am Jan 24 
at now + 1 day 
at 5 pm Friday next week  					</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>   
	Met de <TT
CLASS="OPTION"
>-l</TT
> optie krijg je een lijst van 
	de geplande taken te zien. 
	Met de <TT
CLASS="OPTION"
>-r</TT
> optie kun je een taak 
	verwijderen. 
	Alleen <TT
CLASS="LITERAL"
>root</TT
> mag andermans taken annuleren. 
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CRON"
></A
>cron</H3
><P
>	<I
CLASS="FIRSTTERM"
>Cron</I
> is een <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> 
	daemon, een systeemprogramma dat op de achtergrond loopt, 
	die op gezette tijden opgegeven programma's start, 
	terwijl at voor eenmalige opdrachten is; 
	op sommige systemen start cron elke minuut een programma 
	dat kijkt of er nog at jobs te doen zijn. 
	Cron wordt meestal gebruikt door de systeembeheerder om 
	bijvoorbeeld 's nachts backups te draaien, maar is vaak 
	ook voor de andere gebruikers beschikbaar. 
  </P
><P
>	Net als at zal cron eventuele uitvoer van een opdracht 
	naar de opdrachtgever mailen, tenzij je de standaard 
	uitvoer omleidt; 
	er wordt doorgaans een regel in een log file geschreven 
	voor uitgevoerde jobs. 
	Een nadeel van cron is dat taken die niet op het aangegeven 
	tijdstip uitgevoerd kunnen worden, bijvoorbeeld omdat de 
	computer down is, zullen worden overgeslagen. 
	Een ander verschil met at is dat je de omgevingsvariabelen 
	mist die worden ingesteld als je inlogt. 
  </P
><P
>	De gebruiker maakt gebruik van de <I
CLASS="FIRSTTERM"
>crontab</I
> 
	opdracht om zijn/haar lijst met cron taken te wijzigen. 
	De syntaxis luidt:
  <P
><B
CLASS="COMMAND"
>		cron					</B
>  [  -u <TT
CLASS="REPLACEABLE"
><I
>user</I
></TT
>	] [		-e					 | 		-l					 | 		-r					]</P
>
  </P
><P
>	De verticale balk <TT
CLASS="LITERAL"
>|</TT
> geeft in onze 
	syntaxis-notatie aan dat <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>of</I
></SPAN
> de 
	<TT
CLASS="OPTION"
>-e</TT
> vlag, <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>of</I
></SPAN
> 
	<TT
CLASS="OPTION"
>-l</TT
> <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>of</I
></SPAN
> 
	<TT
CLASS="OPTION"
>-u</TT
> moeten worden gebruikt: 
	u dient het evenmin als de rechterhaken over te typen. 
	Met de <TT
CLASS="OPTION"
>-u</TT
> optie kan root andermans cron 
	tabel wijzigen; 
	deze optie kan ook handig zijn in combinatie met 
	<I
CLASS="FIRSTTERM"
>su</I
>. 
	Met de <TT
CLASS="OPTION"
>-r</TT
> optie wordt een cron tabel 
	verwijderd. 
	Met de <TT
CLASS="OPTION"
>-e</TT
> optie wordt de cron tabel 
	gewijzigd; 
	voor dit doel wordt <I
CLASS="FIRSTTERM"
>vi</I
> opgestart 
	tenzij de inhoud van de omgevingsvariabele 
	<TT
CLASS="ENVAR"
>$EDITOR</TT
> iets anders vermeldt. 
  </P
><P
>	Een cron tabel bestaat uit een aantal regels, die afgezien 
	van blanco of commentaarregels een zestal velden bezitten. 

    <DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN2145"
></A
><P
></P
><TABLE
BORDER="0"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>minuut</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      (0&thinsp;-&thinsp;59)
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>uur</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      (0&thinsp;-&thinsp;23)
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>datum</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      (1&thinsp;-&thinsp;31)
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>maand</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      (1&thinsp;-&thinsp;12)
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>dag</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      (maandag&thinsp;=&thinsp;0, 
		zondag&thinsp;=&thinsp;0 of 7)
	    </TD
></TR
><TR
><TD
WIDTH="25%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>opdracht</P
></LI
></UL
></TD
><TD
WIDTH="75%"
ALIGN="LEFT"
VALIGN="TOP"
>	      (gewone <TT
CLASS="FILENAME"
>/bin/sh</TT
> commandoregel)
	    </TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
>
  </P
><P
>	De dag van de week <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>of</I
></SPAN
> de dag van 
	de maand moeten overeenkomen; 
	het volgende voorbeeld zal op elke vrijdag de 
	13<SUP
>e</SUP
> tussen elf uur en middernacht 
	elke minuut de inhoud van de <TT
CLASS="FILENAME"
>/tmp</TT
> 
	directory wissen <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>en</I
></SPAN
> op 13 november 
	ongeacht de dag van de week. 
	In de plaats van een getal mogen er meerdere voorkomen 
	met komma's, maar zonder spaties ertussen. 
    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN2192"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>  
<TT
CLASS="REPLACEABLE"
><I
># een voorbeeld cron tabel				</I
></TT
>
* 23 13 11 5 find /tmp -exec rm -f {} 2&gt;/dev/null		</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="BASENAME"
></A
>basename en dirname</H3
><P
>	Het <I
CLASS="FIRSTTERM"
>basename</I
> commando verwijdert 
	het directory pad uit een filenaam en eventueel de 
	<I
CLASS="FIRSTTERM"
>extensie</I
>. De syntaxis luidt:
  <P
><B
CLASS="COMMAND"
>		basename				</B
>   <TT
CLASS="REPLACEABLE"
><I
>padnaam</I
></TT
>	  [	<TT
CLASS="REPLACEABLE"
><I
>extensie</I
></TT
>	]</P
>
  </P
><P
>	Als de filenaam niet eindigt op de extensie dan wordt 
	de hele naam weergegeven en ook als de filenaam gelijk 
	is aan de extensie. 
	Die extensie kan een willekeurige string zijn. 
	Er wordt niet gecontroleerd of de file bestaat. 
	Het volgende voorbeeld geeft de voornaam van alle html-bestanden. 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN2207"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>for file in `find . print | fgrep .html`
do
  basename $file .html
done								</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Het <I
CLASS="FIRSTTERM"
>dirname</I
> commando geeft het 
	directory pad van een filenaam. 
	De syntaxis luidt:
  <P
><B
CLASS="COMMAND"
>		dirname					</B
>   <TT
CLASS="REPLACEABLE"
><I
>padnaam</I
></TT
>	 </P
>
  </P
><P
>	Als er geen slash (<TT
CLASS="LITERAL"
>/</TT
>) in de padnaam 
	voorkomt, wordt de huidige directory (<TT
CLASS="LITERAL"
>.</TT
>) 
	geretourneerd. 
	Het volgende voorbeeld geeft alle directory's die 
	html-bestanden bevatten, met dien verstande dat 
	alleen de naam en niet de inhoud van de file wordt getest. 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN2218"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>find . -print | fgrep .html | xargs -l1 dirname | uniq -c 	</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CLEAR"
></A
>clear</H3
><P
>	Het commando <B
CLASS="COMMAND"
>clear</B
> wist de inhoud 
	van het scherm en zet de cursor in de linker bovenhoek. 
	De omgevingsvariabele <TT
CLASS="ENVAR"
>TERM</TT
> bevat het type 
	van uw terminal; 
	als clear niet werkt, kijk of uw terminal wordt ondersteund. 
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SORT"
></A
>sort en uniq</H3
><P
>	Met <I
CLASS="FIRSTTERM"
>sort</I
> kunnen bestanden worden 
	gesorteerd en&thinsp;/&thinsp;of samengevoegd. 
	De sorteervolgorde wordt bepaald door de ingestelde taal 
	en de standaardinstelling is dat de hele regel als 
	sorteersleutel wordt gebruikt. De syntaxis luidt: 

  <P
><B
CLASS="COMMAND"
>		sort					</B
>  [	-c					] [	-m					] [	-u					] [	-t<TT
CLASS="REPLACEABLE"
><I
>teken</I
></TT
>	] [	+<TT
CLASS="REPLACEABLE"
><I
>pos</I
></TT
>1
       [		-<TT
CLASS="REPLACEABLE"
><I
>pos</I
></TT
>2	]
    ]<BR> [	-o <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>	] [	-T <TT
CLASS="REPLACEABLE"
><I
>directory</I
></TT
>	] [	file			...]</P
>
  </P
><P
>	De volgende opties zijn mogelijk:

   <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-c</TT
> (check)</DT
><DD
><P
>	alleen controleren of de invoer reeds 
			gesorteerd is 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-m</TT
> (merge)</DT
><DD
><P
>	samenvoegen van bestanden die reeds 
			gesorteerd zijn
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-u</TT
> (unique)</DT
><DD
><P
>	neem identieke regels slechts 
			&eacute;&eacute;n keer op in de uitvoer 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-t</TT
> (tab)</DT
><DD
><P
>	het volgende teken wordt gebruikt 
			om velden te scheiden; 
			gebruik een teken dat niet in de invoer 
			voorkomt als u puur op positie wildt 
			sorteren. 
			Standaard worden tabs en spaties gebruikt 
			om velden te scheiden en na een 
			spatie worden volgende spaties als deel 
			van een veld beschouwd.  
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-o</TT
> (output)</DT
><DD
><P
>	hiermee wordt aangegeven naar welk bestand 
			de uitvoer wordt geschreven; 
			de uitvoer mag een invoerbestand overschrijven
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-T</TT
> (temporary)</DT
><DD
><P
>	hiermee kan de directory voor tijdelijke 
			bestanden worden opgegeven 
	</P
></DD
></DL
></DIV
>
  </P
><P
>	Verder kan worden opgegeven dat de velden vanaf 
	<TT
CLASS="REPLACEABLE"
><I
>pos</I
></TT
>1 tot en zonder 
	<TT
CLASS="REPLACEABLE"
><I
>pos</I
></TT
>2 de sorteersleutel vormen. 
	Als <TT
CLASS="REPLACEABLE"
><I
>pos</I
></TT
>2 ontbreekt dan vormt 
	de hele rest van de regel de zoeksleutel. 
	Er wordt geteld vanaf 0. 
	Regels waarvan de eerste <TT
CLASS="REPLACEABLE"
><I
>i</I
></TT
> 
	velden gelijk zijn worden gesorteerd op basis van het 
	<TT
CLASS="REPLACEABLE"
><I
>i&thinsp;+&thinsp;1<SUP
>e</SUP
></I
></TT
> 
	veld. 
	De posities kunnen van de vorm <TT
CLASS="REPLACEABLE"
><I
>m.n</I
></TT
> 
	zijn, waarin <TT
CLASS="REPLACEABLE"
><I
>m</I
></TT
> het veldnummer is 
	en <TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
> de positie binnen het veld. 
	De volgende opties zijn globaal geldig als ze voor 
	<TT
CLASS="REPLACEABLE"
><I
>pos</I
></TT
>1 staan, maar als ze achter een 
	positie staan hebben ze betrekking op dat veld. 

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-b</TT
> (blanks)</DT
><DD
><P
>	negeer voorloopspaties 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-d</TT
> (check)</DT
><DD
><P
>	alleen letters, cijfers en spaties zijn
			bepalend voor de volgorde 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-i</TT
> (ignore)</DT
><DD
><P
>	negeer tekens die niet tot het 7-bits
			<SPAN
CLASS="ACRONYM"
>ASCII</SPAN
> alfabet behoren
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-f</TT
> (fold)</DT
><DD
><P
>	verander hoofdletters in kleine letters; 
			hoofdletters verschijnen wel gewoon in 
			de uitvoer
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-n</TT
> (numeric)</DT
><DD
><P
>	de invoer sorteren op getalswaarde i.p.v. 
			alfabetische volgorde; 
			dit maakt de <TT
CLASS="OPTION"
>b</TT
> optie 
			automatisch aktief. De invoer moet rechts
			aangelijnd zijn, wat met <B
CLASS="COMMAND"
>printf</B
> 
			kan, zie <A
HREF="#PRINTF"
>paragraaf 3.7</A
>.
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-r</TT
> (reverse)</DT
><DD
><P
>	sorteer in omgekeerde volgorde	
	</P
></DD
></DL
></DIV
>
  </P
><P
>	Het volgende voorbeeld sorteert het wachtwoordbestand op 
	<I
CLASS="FIRSTTERM"
>Group ID</I
> en binnen een groep worden 
	de <I
CLASS="FIRSTTERM"
>User IDs</I
> in omgekeerde volgorde 
	gezet en per UID op het <I
CLASS="FIRSTTERM"
><SPAN
CLASS="ACRONYM"
>GCOS</SPAN
></I
>
	alias comment veld, dat vaak de volledige naam van de 
	gebruiker en evt. kamernummer en telefoontoestel bevat. 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN2329"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>sort -bdft: +3n +2nr -5 /etc/passwd 				</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
> 
	Het <I
CLASS="FIRSTTERM"
>uniq</I
> commando kan in veel 
	gevallen worden weggelaten en <B
CLASS="COMMAND"
>`sort -u'</B
> 
	worden gebruikt om dubbele regels te verwijderen. 
	De syntaxis luidt:

  <P
><B
CLASS="COMMAND"
>		uniq					</B
>  [		-u					 | 		-c					 | 		-d					] [	-<TT
CLASS="REPLACEABLE"
><I
>kolommen</I
></TT
>	] [	+<TT
CLASS="REPLACEABLE"
><I
>tekens</I
></TT
>	] [	<TT
CLASS="REPLACEABLE"
><I
>in</I
></TT
>
       [		<TT
CLASS="REPLACEABLE"
><I
>uit</I
></TT
>		]
    ]</P
>
  </P
><P
>	De <TT
CLASS="OPTION"
>-u</TT
> optie zorgt ervoor dat enkel de 
	regels die niet dubbel voorkomen worden afgedrukt, 
	terwijl de <TT
CLASS="OPTION"
>-d</TT
> optie elke vaker voorkomende 
	regel een keer in de uitvoer verschijnt en met 
	<TT
CLASS="OPTION"
>-c</TT
> worden alle regels 
	voorafgegaan door het aantal keren dat ze voorkomen. 
  </P
><P
>	Achter het <TT
CLASS="LITERAL"
>-</TT
> teken komt een eventueel 
	aantal kolommen dat voor de vergelijking wordt overgeslagen; 
	achter het <TT
CLASS="LITERAL"
>+</TT
> teken komt een aantal 
	tekenposities dat wordt overgeslagen, nadat de voorafgaande 
	kolommen zijn overgeslagen. 
  </P
><P
>	Veel commando's geven eerst een titelregel, die we niet mee 
	willen sorteren. 
	In plaats van <I
CLASS="FIRSTTERM"
>head</I
> (zie 
	<A
HREF="#HEAD"
>paragraaf <I
>head en tail</I
></A
>) en <I
CLASS="FIRSTTERM"
>tail</I
>
	te gebruiken kan het ook met het scriptje `knip'. 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN2359"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>read LINE
echo "$LINE" 1&gt;&#38;2
while read LINE
do
  echo "$LINE"
done								</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
	Dit leidt de eerste regel om naar het standaard error 
	kanaal; 
	na het sorteren kunnen we beide kanalen weer samenvoegen. 
	Het <B
CLASS="COMMAND"
>w</B
> commando geeft een tabel van ingelogde 
gebruikers met twee titelregels. 
    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN2362"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>w | knip | knip | sort -f 2&#62;&#38;1 					</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="DIFF"
></A
>cmp, comm en diff</H3
><P
>	Met het <I
CLASS="FIRSTTERM"
>cmp</I
> commando kunnen twee 
	files worden vergeleken. De syntaxis luidt: 
  <P
><B
CLASS="COMMAND"
>		cmp					</B
>  [		-l					 | 		-s					]  <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>1	   <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>2	 </P
>
  </P
><P
>	Standaard wordt het nummer en de inhoud van het eerste 
	byte getoond dat verschilt als octaal getal. 
	Met de <TT
CLASS="OPTION"
>-s</TT
> (silent) optie is er geen 
	uitvoer en kan slechts de exit status worden getest, 
	terwijl <TT
CLASS="OPTION"
>-l</TT
> alle bytes die verschillenden 
	weergeeft. 
  </P
><P
>	Cmp is geschikt voor binaire files; 
	<I
CLASS="FIRSTTERM"
>comm</I
> vergelijkt twee bestanden 
	regel voor regel. De bestanden dienen gesorteerd te zijn. 
	De syntaxis luidt: 

  <P
><B
CLASS="COMMAND"
>		comm					</B
>  [	-1					] [	-2					] [	-3					]  <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>1	   <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>2	 </P
>
  </P
><P
>	Zonder vlaggen wordt de uitvoer weergegeven in drie 
	kolommen: 
	in de eerste regels die alleen in file1 voorkomen, in 
	de tweede regels die in file2 voorkomen, en in de derde 
	kolom de gemeenschappelijke regels. 
	De kolommen worden gemarkeerd door de regel met nul, 
	een of twee tab-tekens te beginnen; 
	de uitvoer is niet bijster overzichtelijk. 
	De vlaggen geven de optie een of meerdere kolommen weg 
	te laten, bijv. <B
CLASS="COMMAND"
>comm -12 &hellip;</B
> 
	om alleen gemeenschappelijke regels te zien. 
  </P
><P
>	Het <I
CLASS="FIRSTTERM"
>diff</I
> commando zoekt naar de 
	verschillen tussen twee bestanden. 
	De syntaxis luidt:
 
  <P
><B
CLASS="COMMAND"
>		diff					</B
>  [	-b					] [	-r					] [	-e					]  <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>1	   <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>2	 </P
>
  </P
><P
>	Met de optie <TT
CLASS="OPTION"
>-b</TT
> worden spaties aan het 
	eind van een regel genegeerd. 
	Met de optie <TT
CLASS="OPTION"
>-r</TT
> worden&mdash;als 
	<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>1 en 
	<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>2 directory's zijn&mdash;alle 
	files in die directory's vergeleken. 
	Met de optie <TT
CLASS="OPTION"
>-e</TT
> wordt de uitvoer in de
	vorm van commando's voor de <I
CLASS="FIRSTTERM"
>ed</I
> 
	editor (grootvader van vi) geschreven. 
  </P
><P
>	De uitvoer van diff kan worden gebruikt om met het 
	<I
CLASS="FIRSTTERM"
>patch</I
> tool 
	<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>1 te veranderen in 
	<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>2 of andersom. 
	Als een programmeur aan een groot programma een paar 
	regels heeft veranderd, hoeft hij&thinsp;/&thinsp;zij 
	slechts de patch te verspreiden. 
	De uitvoer van diff heeft de volgende vorm:

<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>n1a n3,n4 	(regels toevoegen) 
n1,n2d n3 	(regels verwijderen) 
n1,n2c n3,n4	(regels wijzigen)  </PRE
></TD
></TR
></TABLE
> 
  </P
><P
>	Achter een edit commando volgt een lijst van de betroffen 
	regels in <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>1 met telkens een 
	<TT
CLASS="LITERAL"
>&lt;</TT
> ervoor en een lijst regels uit 
	<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>2 voorafgegaan door een 
	<TT
CLASS="LITERAL"
>&gt;</TT
>; 
	bijv. als in de ene file op regel 13 een fiets staat waar 
	de andere een rijwiel heeft: 

<TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>13c13
&#60; fiets

---

&#62; rijwiel							</PRE
></TD
></TR
></TABLE
>
 </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="COLUMN"
></A
>column</H3
><P
>	Het column commando (<SPAN
CLASS="ACRONYM"
>BSD</SPAN
>, Linux) kan 
	tekst in kolommen verdelen om een nette uitvoer te geven. 
	De syntaxis luidt:

  <P
><B
CLASS="COMMAND"
>		column					</B
>  [	-t					] [	-x					] [	-c <TT
CLASS="REPLACEABLE"
><I
>kolommen</I
></TT
>	] [	-s <TT
CLASS="REPLACEABLE"
><I
>teken</I
></TT
>	] [<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>...]</P
>
  </P
><P
>	De opties zijn:

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-c</TT
> (count)</DT
><DD
><P
>	hiermee geef je de breedte van het 
			scherm op. 
			In de meeste gevallen is dat niet nodig 
			omdat de omgevingsvariabele 
			<TT
CLASS="ENVAR"
>$COLUMNS</TT
> de juiste 
			breedte bevat. 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-s</TT
> (separator)</DT
><DD
><P
>	geeft het scheidingsteken tussen de 
			kolommen (bijv <TT
CLASS="LITERAL"
>:</TT
> 
			voor <TT
CLASS="FILENAME"
>/etc/passwd</TT
>) 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-x</TT
> (cross)</DT
><DD
><P
>	vult de uitvoer regel voor regel op in 
			plaats van kolom voor kolom 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-t</TT
> (table)</DT
><DD
><P
>	bepaalt het aantal kolommen in de 
			invoertekst in maakt deze netjes op 
	</P
></DD
></DL
></DIV
>
  </P
><P
>	Op de volgende manier kan de uitvoer van 
	<B
CLASS="COMMAND"
>find</B
> op een 
	ls-achtige manier in kolommen worden gezet. 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN2466"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>find . -mindepth 1 -print | xargs -l1 basename | \
  sort -u | column 						</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	In het volgende voorbeeld wordt de uitvoer van 
	<B
CLASS="COMMAND"
>ls</B
> van een titelregel voorzien. 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN2470"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>( printf \
  "PERM LINKS OWNER GROUP SIZE MONTH DAY HH:MM/YEAR NAME\n" 
  /bin/ls -l | sed 1d
) | column -t							</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="CUT"
></A
>colrm, cut, paste, join</H3
><P
>	Het <I
CLASS="FIRSTTERM"
>colrm</I
> commando van 
	<SPAN
CLASS="ACRONYM"
>BSD</SPAN
> <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> verwijdert 
	kolommen uit elke regel van de standaard invoer. 
	Met kolommen worden hier tekenposities bedoeld. 
	De syntaxis luidt:

  <P
><B
CLASS="COMMAND"
>		colrm					</B
>  [	<TT
CLASS="REPLACEABLE"
><I
>startpositie</I
></TT
>
       [<TT
CLASS="REPLACEABLE"
><I
>eindpositie</I
></TT
>	]
    ]</P
>
  </P
><P
>	De posities worden geteld vanaf 1. 
	Als alleen de startpositie wordt opgegeven wordt de 
	rest van de regel verwijderd, anders van start tot en 
	met eind. 
  </P
><P
>	System V <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> kent een <I
CLASS="FIRSTTERM"
>cut</I
> 
	commando dat ongeveer hetzelfde doet, met de volgende syntaxis:

    <P
><B
CLASS="COMMAND"
>		cut					</B
>  [		-b					 | 		-c					 | 		-f					]  <TT
CLASS="REPLACEABLE"
><I
>lijst</I
></TT
>	  [-d <TT
CLASS="REPLACEABLE"
><I
>teken</I
></TT
>	] [			<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>
      ...]</P
>
  </P
><P
>	De opties zijn als volgt:

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-b</TT
> (bytes)</DT
><DD
><P
>	de kolommen worden opgegeven als 
			byte-posities
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-c</TT
> (character)</DT
><DD
><P
>	de kolommen worden aangegeven als tekenposities; 
			in Oostaziatische en Unicode alfabetten 
			kan een teken meer dan een byte lang zijn
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-f</TT
> (field)</DT
><DD
><P
>	de kolommen zijn velden gescheiden door
			tabulatie-tekens
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-d</TT
> (delimiter)</DT
><DD
><P
>	geeft een alternatief scheidingsteken aan; 
			alleen toegestaan in combinatie met de 
			<TT
CLASS="OPTION"
>-f</TT
> optie  
	</P
></DD
></DL
></DIV
>
  </P
><P
>	Achter de <TT
CLASS="OPTION"
>-b</TT
>, <TT
CLASS="OPTION"
>-c</TT
> of 
	<TT
CLASS="OPTION"
>-f</TT
> optie volgt een lijst met veldnummers 
	die in de uitvoer moeten worden meegenomen. 
	Dit kan een reeks nummers zijn, gescheiden door komma's 
	zonder spaties ertussen. 
	Voor een enkel getal kan ook een bereik 
	<TT
CLASS="REPLACEABLE"
><I
>start-eind</I
></TT
> staan, waarbij de 
	start of het eind ook mogen worden weggelaten om de rest 
	van de regel aan te duiden. 
	Zo doen de volgende twee regels hetzelfde 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN2528"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>ls -al | colrm 42 54   
ls -al | cut -b -41,55-						</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	De volgende opdrachten doen niet hetzelfde, omdat de uitvoer 
	van <B
CLASS="COMMAND"
>ls</B
> niet door tabulatie-tekens 
	gescheiden is, maar door rijen spaties. 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN2532"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>ls -al | awk '{ print $9}' 
ls -al | cut -f 9 -d ' ' 					</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
></P
><P
>Om het effekt van de awk regel te bereiken doe je 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN2535"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>ls -al | sed -e 's/[ ][ ]*/ /g' | cut -f 9 -d ' ' 		</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Op de volgende manier kun je een directory listing 
	sorteren op extensie, waarbij functies uit een voorbeeld 
	in <A
HREF="#SED"
>paragraaf <I
>sed, editen vanuit een script</I
></A
> worden gebruikt. 
	Voor bash is de optie <TT
CLASS="OPTION"
>-e</TT
> vereist. 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN2540"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><TT
CLASS="REPLACEABLE"
><I
># optioneel argument: directory naam</I
></TT
> 

  ls $1 | while read
  	  do
	    echo -e "`extension "$REPLY"`""\t""$REPLY"
	  done | sort -df | cut -f 2 				</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Het omgekeerde van cut is <I
CLASS="FIRSTTERM"
>paste</I
>. 
	Hiermee worden regels uit meerdere files samengevoegd tot 
	een regel, gescheiden door tabs. 
	Paste is wat beperkter dan het join commando. 
	De syntaxis luidt: 

    <P
><B
CLASS="COMMAND"
>		paste					</B
>  [	 [		-s					]
      			-d <TT
CLASS="REPLACEABLE"
><I
>lijst</I
></TT
>
      ]  			<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>
      ... </P
>
  </P
><P
>	De opties zijn als volgt:

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-d</TT
>	(delimiter)</DT
><DD
><P
>	gebruik een element uit de lijst als 
			veld-scheidingstekens; 
			er wordt telkens een volgend teken uit 
			de lijst gebruikt, om aan het eind weer 
			het eerste te nemen
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-s</TT
>	(serial)</DT
><DD
><P
>	geeft een alternatief scheidingsteken aan; 
			alleen toegestaan in combinatie met de 
			optie <TT
CLASS="OPTION"
>-f</TT
>  
	</P
></DD
></DL
></DIV
>
  </P
><P
>	Het volgende voorbeeld geeft een lijst bestanden in 
	drie kolommen. 
  
    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN2566"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>ls | paste - - - | column -t 					</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
><P
>	Met <I
CLASS="FIRSTTERM"
>join</I
> worden twee tekstbestanden 
	samengevoegd, die vooraf gesorteerd moeten zijn. 
	Join voegt regels uit beide bestanden samen met dezelfde 
	inhoud van het <I
CLASS="FIRSTTERM"
>sleutelveld</I
>. 
	Het sleutelveld is standaard het eerste veld; 
	velden worden gescheiden door spaties of tabulatie-tekens. 
	Join is een standaard operatie voor databases. 
  </P
><P
>	De uitvoer bevat alle velden van beide bestanden, en het 
	sleutelveld wordt maar &eacute;&eacute;n keer gekopieerd. 
	Als een sleutelveld in de eerste file <TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
> 
	keer voorkomt en <TT
CLASS="REPLACEABLE"
><I
>m</I
></TT
> keer in de 
	tweede, dan zal de uitvoer <TT
CLASS="REPLACEABLE"
><I
>n &times; 
	m</I
></TT
> regels met deze waarde bevatten. 
	De syntaxis luidt: 

    <P
><B
CLASS="COMMAND"
>		join					</B
>  [	-a <TT
CLASS="REPLACEABLE"
><I
>filenr</I
></TT
>		 | 	-v <TT
CLASS="REPLACEABLE"
><I
>filenr</I
></TT
>		] [-e <TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>	] [-o <TT
CLASS="REPLACEABLE"
><I
>lijst</I
></TT
>	] [-t <TT
CLASS="REPLACEABLE"
><I
>teken</I
></TT
>	]<BR> [	-j [<TT
CLASS="REPLACEABLE"
><I
>filenr</I
></TT
>] 
		<TT
CLASS="REPLACEABLE"
><I
>veldnr</I
></TT
> | 	-1 <TT
CLASS="REPLACEABLE"
><I
>veldnr</I
></TT
>
		-2 <TT
CLASS="REPLACEABLE"
><I
>veldnr</I
></TT
>		]  <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>1	   <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>2	 </P
>
  </P
><P
>	Join bezit een aantal opties:

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-a</TT
>	(all)</DT
><DD
><P
>	produceer ook een regel in de uitvoer 
			voor iedere regel in 
			<TT
CLASS="REPLACEABLE"
><I
>filenr</I
></TT
> die geen 
			corresponderende regel in het andere 
			bestand heeft; 
			<TT
CLASS="REPLACEABLE"
><I
>filenr</I
></TT
> is een 
			<TT
CLASS="LITERAL"
>1</TT
> of <TT
CLASS="LITERAL"
>2</TT
> 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-e</TT
>	(empty)</DT
><DD
><P
>	vul lege velden met de opgegeven string 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-j</TT
>	(join)</DT
><DD
><P
>	geef het nummer op van het veld, 
			dat als sleutelveld moet worden 
			gebruikt; 
			<TT
CLASS="REPLACEABLE"
><I
>filenr</I
></TT
> is een 
			<TT
CLASS="LITERAL"
>1</TT
> of <TT
CLASS="LITERAL"
>2</TT
> 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-1, -2</TT
></DT
><DD
><P
>	<TT
CLASS="OPTION"
>-1</TT
> is een synomiem 
			voor <TT
CLASS="OPTION"
>-j1</TT
> en 
			<TT
CLASS="OPTION"
>-2</TT
> voor 
			<TT
CLASS="OPTION"
>-j2</TT
>
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-o</TT
>	(output)</DT
><DD
><P
>	geeft een lijst van velden die 
			in de uitvoer moeten komen, wat 
			een cut bespaart; 
			een veld wordt aangeduid met 
			<TT
CLASS="REPLACEABLE"
><I
>filenr.veldnr</I
></TT
> 
			en velden worden gescheiden door komma's
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-t</TT
>	(tab)</DT
><DD
><P
>	geeft aan welk teken wordt gebruikt 
			om de velden te scheiden 
			(helaas is <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> 
			niet erg consequent in de naamgeving 
			van de opties) 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-v</TT
></DT
><DD
><P
>	produceer uitsluitend een regel 
			in de uitvoer voor iedere regel 
			in <TT
CLASS="REPLACEABLE"
><I
>filenr</I
></TT
> 
			die geen corresponderende regel 
			in het andere bestand heeft;
			<TT
CLASS="REPLACEABLE"
><I
>filenr</I
></TT
> is een 
			<TT
CLASS="LITERAL"
>1</TT
> of <TT
CLASS="LITERAL"
>2</TT
> 
	</P
></DD
></DL
></DIV
>
  </P
><P
>	Met behulp van join maken we een korte variant op het 
	voorbeeld van <A
HREF="#VOORBEELDEN"
>paragraaf <I
>enkele voorbeelden</I
></A
>.

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN2657"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
><TT
CLASS="REPLACEABLE"
><I
># sorteer de wachtwoord file op login naam		</I
></TT
>
sort &lt;/etc/passwd &gt;een
<TT
CLASS="REPLACEABLE"
><I
># knip de titelregels uit lijst van gebruikers, 
	# scheid de velden door dubbele punt en sorteer 	</I
></TT
>
w | ( read; read; cat) | sed -e 's/[ ][ ]*/:/g' \
| sort &gt;twee
<TT
CLASS="REPLACEABLE"
><I
># voeg de bestanden samen en maak er nette tabel van</I
></TT
>
(echo "USER:FULL NAME:TTY"; join een twee -t ':' \
  -o 1.1,1.5,2.2 ) | column -t -s ':'; rm -f een twee		</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="HEAD"
></A
>head en tail</H3
><P
>	Na een aantal opdrachten die velden uit bestanden 
	manipuleren, zijn er nog een paar die regels uit tekst 
	filteren. 
	Naast grep hebben we <I
CLASS="FIRSTTERM"
>head</I
> en 
	<I
CLASS="FIRSTTERM"
>tail</I
> die respectievelijk de eerste 
	en de laatste paar regels van een bestand laten zien; 
	standaard zijn dat tien (10) regels. 
	De syntaxis luidt: 

    <P
><B
CLASS="COMMAND"
>		head					</B
>  [		-<TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
>	 | 		-n <TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
>	] [		<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>	
      ...]<BR><BR><B
CLASS="COMMAND"
>		tail					</B
>  [	 [		+					 | 		-					]
			<TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
> [		l					 | 		b					 | 		c					]
      ] [-f					] [-r					] [<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>		]<BR><BR><B
CLASS="COMMAND"
>		tail					</B
>  [		-c <TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
>	 | 		-n <TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
>	] [<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>		]</P
>
  </P
><P
>	De opties zijn als volgt:

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-n</TT
>	(number)</DT
><DD
><P
>	het aantal regels dat wordt weergegeven;
			dit is hetzelfde als de optie 
			<TT
CLASS="OPTION"
>-aantal</TT
>
	</P
></DD
><DT
><TT
CLASS="OPTION"
>+<TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
>[l|b|c]</TT
></DT
><DD
><P
>	alleen voor tail; 
			er wordt nu vanaf het begin van de file 
			geteld in plaats vanaf het eind: 
			dit is hetzelfde als 
			<TT
CLASS="OPTION"
>-n +<TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
></TT
>, 
			terwijl 
			<TT
CLASS="OPTION"
>-n -<TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
></TT
> 
			equivalent is met 
			<TT
CLASS="OPTION"
>-n <TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
></TT
> 
			en head geen teken voor het aantal krijgt
	</P
><P
>	de optionele <TT
CLASS="OPTION"
>l</TT
> achter 
			het aantal betekent dat er regels geteld 
			worden; 
			als er <TT
CLASS="OPTION"
>c</TT
> staat worden 
			bytes geteld en een <TT
CLASS="OPTION"
>b</TT
> 
			staat voor disk blokken van 512 bytes 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-c</TT
>	(character)</DT
><DD
><P
>	Een alternatieve notatie voor 
			<TT
CLASS="OPTION"
>+&thinsp;/&thinsp;-<TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
>c</TT
>
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-r</TT
>	(reverse)</DT
><DD
><P
>	de regels worden in omgekeerde volgorde 
			afgedrukt; 
			alleen voor <SPAN
CLASS="ACRONYM"
>BSD</SPAN
> 
			<SPAN
CLASS="ACRONYM"
>Unix</SPAN
>
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-f</TT
>	(follow)</DT
><DD
><P
>	laat het programma niet be&euml;indigen 
			als het eind van het bestand is bereikt, 
			maar kijkt om de zoveel seconden of de 
			file is gegroeid en drukt nieuwe regels
			af; 
			handig voor log files. 
	</P
></DD
></DL
></DIV
>
  </P
><P
>	De <SPAN
CLASS="ACRONYM"
>GNU</SPAN
> versie van head kent een 
	aantal van de opties van tail. 
	Het eerste voorbeeld geeft alleen de namen van de bestanden; 
	het tweede is equivalent met 
	<B
CLASS="COMMAND"
>(read; read; cat)</B
>. 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN2746"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>head -0 * 
tail -n +3l							</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SPLIT"
></A
>split en dd</H3
><P
>	Een heel andere manier om een bestand in regels 
	te splitsen is <I
CLASS="FIRSTTERM"
>split</I
>, dat meerdere 
	output files aanmaakt van gelijke lengte. 
	De syntaxis luidt:

    <P
><B
CLASS="COMMAND"
>		split					</B
>  [		- [l]<TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
>	 | 		 [-b]<TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
> [k | m]] [<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>
	 [<TT
CLASS="REPLACEABLE"
><I
>prefix</I
></TT
>	]
      ]</P
>
  </P
><P
>	De namen van de output files beginnen met de opgegeven prefix. 
	Zonder prefix heten ze <TT
CLASS="FILENAME"
>xaa, xab, &hellip;</TT
> 
	De opties zijn: 

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-l</TT
>	(lines)</DT
><DD
><P
>	geeft het aantal regels per 
			uitvoer file; 
			de letter <TT
CLASS="OPTION"
>l</TT
> mag 
			worden weggelaten; 
			standaard worden files van 1000 
			regels gemaakt
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-b</TT
>	(bytes)</DT
><DD
><P
>	maakt files met het opgegeven 
			aantal bytes; 
			als er <TT
CLASS="OPTION"
>k</TT
> achter staat, 
			worden het kilobytes en met 
			<TT
CLASS="OPTION"
>m</TT
> megabytes: 
			handig als de uitvoer een vaste grootte 
			moet hebben voor bijvoorbeeld floppy disks.  
	</P
></DD
></DL
></DIV
>
  </P
><P
>	Een gesplitste file kan worden samengevoegd met 
	<B
CLASS="COMMAND"
>cat x* &gt;<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
></B
>.
  </P
><P
>	De functie van <I
CLASS="FIRSTTERM"
>dd</I
> wordt omschreven 
	als `convert and copy', maar omdat cc al bestond, is 
	voor `disk dumper' gekozen. 
	Het wordt vooral gebruikt voor direkte in- en uitvoer naar 
	een fysiek randapparaat, omdat het niet regels maar records 
	met vaste lengte kopieert. 
	De syntaxis luidt:

    <P
><B
CLASS="COMMAND"
>		dd					</B
>  [			<TT
CLASS="REPLACEABLE"
><I
>optie</I
></TT
>=<TT
CLASS="REPLACEABLE"
><I
>waarde</I
></TT
>...]</P
>
  </P
><P
>	Zonder verdere argumenten lijkt het op cat, maar dd kent 
	een respektabele lijst opties: 

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>if=<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
></TT
></DT
><DD
><P
>	lees van de opgegeven file c.q. randapparaat
	</P
></DD
><DT
><TT
CLASS="OPTION"
>of=<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
></TT
></DT
><DD
><P
>	schrijf naar de opgegeven file c.q. randapparaat 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>ibs=<TT
CLASS="REPLACEABLE"
><I
>bytes</I
></TT
>[w|b|k]</TT
></DT
><DD
><P
>	geeft het aantal bytes dat in 
			&eacute;&eacute;n keer gelezen wordt 
			(record grootte) op,
			standaard 512 bytes;
			als achtervoegsel kan de eenheid worden 
			opgegeven: 
			een woord is twee bytes, een disk-blok 
			512 bytes, een kilobyte 1024 bytes 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>obs=<TT
CLASS="REPLACEABLE"
><I
>bytes</I
></TT
>[w|b|k]</TT
></DT
><DD
><P
>	geeft het aantal bytes dat in 
			&eacute;&eacute;n keer weggeschreven 
			wordt (record grootte) op
	</P
></DD
><DT
><TT
CLASS="OPTION"
>bs=<TT
CLASS="REPLACEABLE"
><I
>bytes</I
></TT
>[w|b|k]</TT
></DT
><DD
><P
>	geeft het aantal bytes dat in 
			&eacute;&eacute;n keer gelezen en 
			geschreven wordt; 
			<TT
CLASS="OPTION"
>ibs</TT
> en <TT
CLASS="OPTION"
>obs</TT
>
			worden genegeerd als <TT
CLASS="OPTION"
>bs</TT
>
			is opgegeven 			
	</P
></DD
><DT
><TT
CLASS="OPTION"
>cbs=<TT
CLASS="REPLACEABLE"
><I
>bytes</I
></TT
></TT
></DT
><DD
><P
>	geeft de grootte van de conversie-buffer aan
			voor conversie naar of van <SPAN
CLASS="ACRONYM"
>IBM</SPAN
>
			of <SPAN
CLASS="ACRONYM"
>EBCDIC</SPAN
> formaat
	</P
></DD
><DT
><TT
CLASS="OPTION"
>skip=<TT
CLASS="REPLACEABLE"
><I
>records</I
></TT
></TT
></DT
><DD
><P
>	geeft het aantal records dat van de invoer 
			wordt gelezen maar niet naar de uitvoer
			wordt geschreven
	</P
></DD
><DT
><TT
CLASS="OPTION"
>seek=<TT
CLASS="REPLACEABLE"
><I
>records</I
></TT
></TT
></DT
><DD
><P
>	geeft het aantal records in de uitvoerfile
			dat wordt overgeslagen voordat dd begint
			met kopi&euml;ren
	</P
></DD
><DT
><TT
CLASS="OPTION"
>iseek=<TT
CLASS="REPLACEABLE"
><I
>records</I
></TT
></TT
></DT
><DD
><P
>	net als <TT
CLASS="OPTION"
>skip</TT
>, maar dd
			springt over de records heen, wat tijd
			bespaart
	</P
></DD
><DT
><TT
CLASS="OPTION"
>oseek=<TT
CLASS="REPLACEABLE"
><I
>records</I
></TT
></TT
></DT
><DD
><P
>	net als seek
	</P
></DD
><DT
><TT
CLASS="OPTION"
>count=<TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
></TT
></DT
><DD
><P
>	kopieert slechts een 
			<TT
CLASS="OPTION"
><TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
></TT
>
			records
	</P
></DD
><DT
><TT
CLASS="OPTION"
>files=<TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
></TT
></DT
><DD
><P
>	voegt een aantal bestanden met <SPAN
CLASS="TOKEN"
>EOF</SPAN
>
			ertussen samen;
			alleen handig voor tape 
	</P
></DD
><DT
><TT
CLASS="OPTION"
>conv=<TT
CLASS="REPLACEABLE"
><I
>code</I
></TT
>,&hellip;</TT
></DT
><DD
><DIV
CLASS="INFORMALTABLE"
><A
NAME="AEN2882"
></A
><P
></P
><TABLE
BORDER="0"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>ascii</P
></LI
></UL
></TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>	converteer van <SPAN
CLASS="ACRONYM"
>EBCDIC</SPAN
>
			naar <SPAN
CLASS="ACRONYM"
>ASCII</SPAN
> 
		</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>ebcdic</P
></LI
></UL
></TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>	converteer van <SPAN
CLASS="ACRONYM"
>ASCII</SPAN
>
			naar <SPAN
CLASS="ACRONYM"
>EBCDIC</SPAN
> 
		</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>ibm</P
></LI
></UL
></TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>	converteer van <SPAN
CLASS="ACRONYM"
>IBM</SPAN
>
			<SPAN
CLASS="ACRONYM"
>EBCDIC</SPAN
>
			naar <SPAN
CLASS="ACRONYM"
>ASCII</SPAN
> 
		</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>block</P
></LI
></UL
></TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>	converteer tekstbestand met regels van 
			variabele lengte naar records van 
			<TT
CLASS="OPTION"
>cbs</TT
> bytes door regels 
			aan te vullen met spaties
		</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>unblock</P
></LI
></UL
></TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>	haal spaties aan het eind weg en sluit regel 
			af met <SPAN
CLASS="TOKEN"
>newline</SPAN
>
		</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>lcase</P
></LI
></UL
></TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>	vervang hoofdletters door kleine letters
		</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>ucase</P
></LI
></UL
></TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>	vervang kleine letters door hoofdletters
		</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>swab</P
></LI
></UL
></TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>	verwissel even en oneven bytes
		</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>sync</P
></LI
></UL
></TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>	als het invoer record kleiner is dan 
			<TT
CLASS="OPTION"
>ibs</TT
>, dan wordt het
			aangevuld met <SPAN
CLASS="TOKEN"
>NULL</SPAN
> bytes
			of&mdash;als de optie <TT
CLASS="OPTION"
>block</TT
>
			gekozen is&mdash;bytes
		</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>noerror</P
></LI
></UL
></TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>	ga door als er een fout optreedt
		</TD
></TR
><TR
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
><P
></P
><UL
><LI
><P
CLASS="LITERALLAYOUT"
>notrunc</P
></LI
></UL
></TD
><TD
WIDTH="80%"
ALIGN="LEFT"
VALIGN="TOP"
>	maak het uitvoer bestand niet leeg
			alvorens ernaar te schrijven 
		</TD
></TR
></TBODY
></TABLE
><P
></P
></DIV
></DD
></DL
></DIV
>
  </P
><P
>	De <SPAN
CLASS="ACRONYM"
>GNU</SPAN
> versie kent de opties
	<TT
CLASS="OPTION"
>files=</TT
>, <TT
CLASS="OPTION"
>iseek=</TT
> en 
	<TT
CLASS="OPTION"
>oseek=</TT
> niet. 
	Het volgende voorbeeld misbruikt dd voor string manipulatie. 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN2970"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>echo "Hello, world" | dd bs=1 skip=7 count=6 2&gt;&thinsp;&gt;/dev/null </PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="ENV"
></A
>env</H3
><P
>	Het commando <I
CLASS="FIRSTTERM"
>env</I
> is een aanvulling 
	op <I
CLASS="FIRSTTERM"
>set</I
>, waarmee een 
	omgevingsvariabele kan worden ingesteld voor de duur van 
	&eacute;&eacute;n commando. 
	De syntaxis luidt: 

   <P
><B
CLASS="COMMAND"
>		env					</B
>  [		-					 | 		-i					] [			<TT
CLASS="REPLACEABLE"
><I
>naam</I
></TT
>=<TT
CLASS="REPLACEABLE"
><I
>waarde</I
></TT
>...] [<TT
CLASS="REPLACEABLE"
><I
>programma</I
></TT
>
	 [<TT
CLASS="REPLACEABLE"
><I
>argumenten</I
></TT
>	]
      ]</P
>
  </P
><P
>	Env start het programma, dat de opgegeven namen met de 
	bijbehorende waarden als omgevingsvariabelen meekrijgt. 
	Met de optie <TT
CLASS="OPTION"
>-</TT
> alias <TT
CLASS="OPTION"
>-i</TT
> 
	worden de bestaande omgevingsvariabelen ontzichtbaar voor 
	het programma. 
  </P
><P
>	Env zonder argumenten geeft de waarde van alle 
	omgevingsvariabelen, net als het commando 
	<I
CLASS="FIRSTTERM"
>printenv</I
> 
	(zie <A
HREF="#PRINTENV"
>paragraaf <I
>printenv</I
></A
>). 
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="EXPAND"
></A
>expand, unexpand en tabs</H3
><P
>	Expand is een hulpmiddel om tabulatie-tekens in een 
	tekstbestand te vervangen door spaties met behoud van 
	paginaindeling.
	Programmeurs gebruiken het bijvoorbeeld als een 
	printer tabs niet goed verwerkt. 
	Unexpand vervangt reeksen spaties door tab-tekens, wat 
	ruimte bespaart. 
	De syntaxis luidt 

    <P
><B
CLASS="COMMAND"
>		expand					</B
>  [	- [t]<TT
CLASS="REPLACEABLE"
><I
>tabstops</I
></TT
>] [			<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>		...]<BR><BR><B
CLASS="COMMAND"
>		unexpand				</B
>  [	  			-a					 | 			-t					 
			<TT
CLASS="REPLACEABLE"
><I
>tabstops</I
></TT
>	
      ] [			<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>		...]</P
>
  </P
><P
>	Posities worden geteld vanaf 1. 
	Standaard wordt een tabstop om de 8 posities aangenomen. 
	Met de optie <TT
CLASS="OPTION"
>-t</TT
> kan een andere waarde 
	worden opgegeven. 
	Het is ook mogelijk om de lijst van tabstops expliciet 
	op te geven, gescheiden door komma's, als ze op ongelijke 
	afstanden voorkomen. 
	Unexpand vervangt alleen de spaties totaan het eerste 
	afdrukbare teken, of alles als de optie <TT
CLASS="OPTION"
>-a</TT
> 
	is gespecificeerd. 
  </P
><P
>	In <I
CLASS="FIRSTTERM"
>vi</I
> kun je de tabstops zetten 
	met <B
CLASS="COMMAND"
>:set ts=n</B
>; 
	gerelateerde instellingen zijn <B
CLASS="COMMAND"
>:set ai</B
> 
	(automatisch inspringen) en 
	<B
CLASS="COMMAND"
>:set sw=<TT
CLASS="REPLACEABLE"
><I
>m</I
></TT
></B
> 
	(inspringdiepte). 
	Om de tab-instellingen te wijzigen op terminals die dit 
	ondersteunen wordt het commando <I
CLASS="FIRSTTERM"
>tabs</I
>  
	gebruikt, met de syntaxis: 

    <P
><B
CLASS="COMMAND"
>		tabs					</B
>  [		-<TT
CLASS="REPLACEABLE"
><I
>code</I
></TT
>	 | 		-<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>		 | <TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>1,&hellip;] [-T<TT
CLASS="REPLACEABLE"
><I
>term</I
></TT
>	] [+m<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>		]<BR><BR><B
CLASS="COMMAND"
>		tabs					</B
>  [-T<TT
CLASS="REPLACEABLE"
><I
>term</I
></TT
>	] [+m [<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>]]  <TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>1  [,<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>2...]</P
>
  </P
><P
>	De opties zijn als volgt:

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-T</TT
>	(terminal)</DT
><DD
><P
>	geef het terminaltype op, als 
			<SPAN
CLASS="ACRONYM"
>Unix</SPAN
> dat niet in de 
			omgevingsvariabele <TT
CLASS="ENVAR"
>TERM</TT
> 
			vindt
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>+m</TT
>	(margin)</DT
><DD
><P
>	geef de linker marge op; 
			in de tweede notatie mag <TT
CLASS="OPTION"
>m</TT
> 
			zonder getal gebruikt worden voor de 
			standaardwaarde van 10
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-<TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
></TT
></DT
><DD
><P
>	geef een repeterende tabstop op. 
			In de tweede vorm wordt de 
			<TT
CLASS="OPTION"
>-</TT
> weggelaten 
	  </P
></DD
><DT
><TT
CLASS="OPTION"
><TT
CLASS="REPLACEABLE"
><I
>n</I
></TT
>1,&hellip;</TT
></DT
><DD
><P
>	geef de lijst van tabstops expliciet op
	  </P
></DD
><DT
><TT
CLASS="OPTION"
><TT
CLASS="REPLACEABLE"
><I
>code</I
></TT
></TT
></DT
><DD
><P
>	een aantal sets tabstops zijn 
			voorgedefinieerd, 
			bijv. <TT
CLASS="OPTION"
>-a</TT
> voor S/370 
			assembler, <TT
CLASS="OPTION"
>-c</TT
> voor Cobol, 
			<TT
CLASS="OPTION"
>-f</TT
> voor Fortran, etc. 
	  </P
></DD
></DL
></DIV
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="FILE"
></A
>file</H3
><P
>	Het commando <I
CLASS="FIRSTTERM"
>file</I
> onderzoekt het 
	begin van een file en probeert daaruit af te leiden wat 
	voor type bestand het is. 
	Dit is iets betrouwbaarder dan op de extensie van de 
	filenaam af te gaan, maar het blijft gissen. 
	Als uw systeem een bepaald soort document niet herkent, 
	kunt u zelf patronen toevoegen aan 
	<TT
CLASS="FILENAME"
>/etc/magic</TT
>. 
	De syntaxis luidt:

    <P
><B
CLASS="COMMAND"
>		file					</B
>  [		-c					] [		-f <TT
CLASS="REPLACEABLE"
><I
>ffile</I
></TT
>	] [		-m <TT
CLASS="REPLACEABLE"
><I
>mfile</I
></TT
>	] [<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>		...]</P
>
  </P
><P
>	De opties zijn als volgt:

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-c</TT
>	(check)</DT
><DD
><P
>	controleer het formaat van de magic file
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-f</TT
>	(files)</DT
><DD
><P
>	onderzoek de files waarvan de 
			namen in 
			<TT
CLASS="OPTION"
><TT
CLASS="REPLACEABLE"
><I
>ffile</I
></TT
></TT
> 
			staan
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-m</TT
>	(magic)</DT
><DD
><P
>	lees de zoekpatronen uit 
			<TT
CLASS="OPTION"
><TT
CLASS="REPLACEABLE"
><I
>mfile</I
></TT
></TT
>
			in plaats van de standaard locatie
	  </P
></DD
></DL
></DIV
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="FOLD"
></A
>fold en fmt</H3
><P
>		Fold breekt lange tekstregels af, zodat de rest 
	op de volgende regel terechtkomt. 
	De syntaxis luidt:

    <P
><B
CLASS="COMMAND"
>		fold					</B
>  [-bs					] [-w <TT
CLASS="REPLACEABLE"
><I
>lengte</I
></TT
>	] [<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>		...]</P
>
  </P
><P
>	De volgende opties worden herkend:

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-b</TT
>	(backspace)</DT
><DD
><P
>	de speciale behandeling van 
			<SPAN
CLASS="TOKEN"
>backspace</SPAN
>, 
			<SPAN
CLASS="TOKEN"
>tab</SPAN
> en 
			<SPAN
CLASS="TOKEN"
>carriage return</SPAN
> wordt 
			opgeheven, zodat ze als gewone tekens 
			met breedte 1 tellen
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-s</TT
>	(spaces)</DT
><DD
><P
>	breek de regel af na een spatie in plaats 
			van midden in een woord
	</P
></DD
><DT
><TT
CLASS="OPTION"
>-w</TT
>	(width)</DT
><DD
><P
>	hanteer de opgegeven regellengte in plaats 
			van de standaardwaarde 80
	</P
></DD
></DL
></DIV
>
  </P
><P
> 
	Fmt is een simpel programma uit <SPAN
CLASS="ACRONYM"
>BSD</SPAN
> 
	<SPAN
CLASS="ACRONYM"
>Unix</SPAN
> om een tekstbestand wat netter 
	op te maken met een standaard regellengte van 72 (75 
	voor <SPAN
CLASS="ACRONYM"
>GNU</SPAN
>). 
	Blanco en ingesprongen regels blijven behouden. 
	Het programma <I
CLASS="FIRSTTERM"
>pr</I
> is gemaakt om 
	tekst in kolommen te zetten met kop- en voetregels voor 
	het afdrukken. 
	Voor C code is er <I
CLASS="FIRSTTERM"
>indent</I
>, dat de 
	lay-out van een programma helemaal kan omgooien. 
	De syntaxis luidt: 

    <P
><B
CLASS="COMMAND"
>		fmt					</B
>  [-<TT
CLASS="REPLACEABLE"
><I
>opties</I
></TT
>	] [<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>		...]</P
>
  </P
><P
>	De oude <SPAN
CLASS="ACRONYM"
>BSD</SPAN
> versie kent geen opties; 
	de <SPAN
CLASS="ACRONYM"
>GNU</SPAN
> versie heeft o.a.: 

   <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-c</TT
>	(crown-margin)</DT
><DD
><P
>	de inspringing van de eerste twee regels
			van elke alinea blijft bewaard en de
			rest springt evenveel in als de tweede regel; 
			bedoeld voor wie alinea's begint met in 
			te springen
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-t</TT
>	(tagged)</DT
><DD
><P
>	als de optie <TT
CLASS="OPTION"
>-c</TT
>, maar 
			de eerste twee regels moeten verschillend 
			inspringen
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-u</TT
>	(uniform)</DT
><DD
><P
>	vervangt meervoudige spaties door een 
			enkele, behalve aan het eind van een 
			regel, waar een enkele spatie blijft 
			staan, maar meerdere spaties door twee  
			worden vervangen
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-w=<TT
CLASS="REPLACEABLE"
><I
>lengte</I
></TT
></TT
>	(width)</DT
><DD
><P
>	geeft de regellengte op
	  </P
></DD
></DL
></DIV
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="INSTALL"
></A
>install</H3
><P
>	Het commando <I
CLASS="FIRSTTERM"
>install</I
> commando 
	wordt het meest gebruikt in <I
CLASS="FIRSTTERM"
>make</I
> 
	files om bestanden naar hun bestemming te kopi&euml;ren. 
	De vergelijking van de man pages laat zien dat de System 
	V en <SPAN
CLASS="ACRONYM"
>GNU</SPAN
> uitvoeringen sterk verschillen. 
	De syntaxis luidt ongeveer:

    <P
><B
CLASS="COMMAND"
>		install					</B
>  [-f					] [-m <TT
CLASS="REPLACEABLE"
><I
>mode</I
></TT
>	] [-u <TT
CLASS="REPLACEABLE"
><I
>user</I
></TT
>	] [-g <TT
CLASS="REPLACEABLE"
><I
>groep</I
></TT
>	]  <TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>	   <TT
CLASS="REPLACEABLE"
><I
>directory</I
></TT
>	 </P
>
  </P
><P
>	Enkele van de opties:

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-f</TT
>	(force)</DT
><DD
><P
>	overschrijf een eventueel bestaand bestand 
			in de doeldirectory
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-m</TT
>	(mode)</DT
><DD
><P
>	de toegangsrechten van de kopie worden 
			ingesteld op de opgegeven 
			<I
CLASS="FIRSTTERM"
>mode</I
>, die zowel 
			als octaal getal als in symbolische vorm 
			kan worden opgegeven (voor meer info:
			<B
CLASS="COMMAND"
>man chmod</B
>)
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-u</TT
>	(user), <TT
CLASS="OPTION"
>-o</TT
>	(owner)</DT
><DD
><P
>	stelt de eigenaar van de kopie in: 
			dit mag een naam of nummer uit 
			<TT
CLASS="FILENAME"
>/etc/passwd</TT
> zijn; 
			install wordt doorgaans door 
			<I
CLASS="FOREIGNPHRASE"
>root</I
> uitgevoerd 
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-g</TT
>	(groep)</DT
><DD
><P
>	geeft de groep op die de kopie zal bezitten
	  </P
></DD
></DL
></DIV
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="LOOK"
></A
>look</H3
><P
>	<I
CLASS="FIRSTTERM"
>Look</I
> print alle regels in een 
	gesorteerd tekstbestand die met de opgegeven string 
	beginnen. 
	Het maakt gebruik van een binair zoekalgorithme, waardoor 
	het veel sneller is dan fgrep, maar ook beperkter in zijn 
	functionaliteit. 
	De syntaxis luidt: 

    <P
><B
CLASS="COMMAND"
>		look					</B
>  [-d					] [-f					]  <TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>	  [<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>		]</P
>
  </P
><P
>	Tenzij een bestand is opgegeven, kijkt look in het 
	standaardwoordenboek, bijv. 
	<TT
CLASS="FILENAME"
>/usr/dict/words</TT
> of
	<TT
CLASS="FILENAME"
>/usr/share/dict/words</TT
>. 
	Enkele opties zijn:

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-d</TT
>	(dictionary)</DT
><DD
><P
>	houdt lexigrafische volgorde aan en 
			vergelijkt enkel letters, cijfers en 
			witruimte
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-f</TT
>	(fold)</DT
><DD
><P
>	maakt geen onderscheid tussen hoofd- en 
			kleine letter
	  </P
></DD
></DL
></DIV
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MAIL"
></A
>mail</H3
><P
>	<I
CLASS="FIRSTTERM"
>Mail</I
> is het standaard interactieve 
	e-mail programma voor <SPAN
CLASS="ACRONYM"
>Unix</SPAN
> gebruikers. 
	Er zijn inmiddels e-mail clients met heel wat meer features, 
	maar mail kan gebruikt worden om berichten te versturen 
	vanuit een programma. 
	De sterk vereenvoudigde syntaxis luidt: 

    <P
><B
CLASS="COMMAND"
>		mail					</B
>  [-s <TT
CLASS="REPLACEABLE"
><I
>onderwerp</I
></TT
>	] [<TT
CLASS="REPLACEABLE"
><I
>adres</I
></TT
>	...]</P
>
  </P
><P
>	Als het adres ontbreekt, dan wordt mail gebruikt om 
	interactief te binnengekomen post te lezen en eventueel 
	te wissen; 
	met een adres zal mail een bericht van de standaard 
	invoer lezen en versturen met de eventuele onderwerp-regel 
	(graag tussen aanhalingstekens als er spaties in voorkomen). 
	Als er meerdere ontvangers zijn, moeten de adressen 
	met komma's worden gescheiden. 
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="MESG"
></A
>mesg</H3
><P
>	<I
CLASS="FIRSTTERM"
>Mesg</I
> wordt meestal in 
	<TT
CLASS="FILENAME"
>~/.profile</TT
> (zie <A
HREF="#HALLO"
>paragraaf <I
>hallo</I
></A
>) 
	gebruikt om het ontvangen van berichten op de terminal 
	met <I
CLASS="FIRSTTERM"
>talk</I
> of 
	<I
CLASS="FIRSTTERM"
>write</I
> toe te staan of te blokkeren. 
	De syntaxis luidt: 
  
   <P
><B
CLASS="COMMAND"
>		mesg					</B
>  [		n					 | 		y					]</P
>
  </P
><P
>	Met <TT
CLASS="OPTION"
>y</TT
> worden berichten aan u doorgegeven, 
	met <TT
CLASS="OPTION"
>n</TT
> niet. 
	Zonder argument geeft mesg de momentane instelling. 
	De volgende listing laat zien dat er van twee ingelogde 
	gebruikers een mesg aan heeft staan en de ander uit. 
    <TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="SCREEN"
>crw-rw-rw- 1 root  root  3, 0 Jun  5 19:29 /dev/ttyp0
crw--w---- 1 daniel tty  3, 1 Jun  5 19:26 /dev/ttyp1
crw------- 1 radical tty 3, 2 Jun  5 19:31 /dev/ttyp2
crw-rw-rw- 1 root   root 3, 3 May 18 00:44 /dev/ttyp3		</PRE
></TD
></TR
></TABLE
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="OD"
></A
>od en strings</H3
><P
>	<I
CLASS="FIRSTTERM"
>Od</I
> wordt gebruikt om de inhoud van 
	binaire files in octaal of andere formaten weer te geven. 
	De vereenvoudigde syntaxis luidt: 

    <P
><B
CLASS="COMMAND"
>		od					</B
>  [-		
	 [		b					]
	 [		c					]
	 [		d					]
	 [		h					]
	 [		o					]
	 [		x					]
      ] [-A <TT
CLASS="REPLACEABLE"
><I
>radix</I
></TT
>	] [-j <TT
CLASS="REPLACEABLE"
><I
>bytes</I
></TT
>	] [-N <TT
CLASS="REPLACEABLE"
><I
>bytes</I
></TT
>	]  \					 <BR> [-t <TT
CLASS="REPLACEABLE"
><I
>formaat</I
></TT
>	] [<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>		]</P
>
  </P
><P
>	Er zijn onder andere de volgende opties: 

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-b</TT
>	(bytes)</DT
><DD
><P
>	bytes worden weergegeven als octaal getal 
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-c</TT
>	(character)</DT
><DD
><P
>	bytes worden weergegeven in 
			<SPAN
CLASS="ACRONYM"
>ASCII</SPAN
>, met onzichtbare 
			tekens als escape 
			(zie <A
HREF="#AANHALING"
>paragraaf <I
>aanhaling</I
></A
>)
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-d</TT
>	(decimal)</DT
><DD
><P
>	woorden van twee bytes worden weergegeven 
			als positief decimaal getal 
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-x</TT
>	(hexadecimal)</DT
><DD
><P
>	woorden worden weergeven in hexadecimale notatie
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-v</TT
>	(verbose)</DT
><DD
><P
>	als een regel meerdere keren herhaald 
			wordt, dan wordt-ie ook net zo vaak 
			afgedrukt
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-A</TT
>	(address)</DT
><DD
><P
>	geef het getallenstelsel op dat voor de 
			adressen moet worden gebruikt
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-j</TT
>	(jump)</DT
><DD
><P
>	geeft aan dat een aantal bytes moet 
			worden overgeslagen alvorens de rest af 
			te drukken; 
			het aantal wordt in het decimale stelsel 
			genoteerd, tenzij het met een 
			<TT
CLASS="LITERAL"
>0</TT
> (octaal) of 
			<TT
CLASS="LITERAL"
>0x</TT
> (hexadecimaal) begint;
	  </P
><P
> 
			achter het aantal kan nog de eenheid 
			<TT
CLASS="LITERAL"
>b</TT
> (blokken van 512 
			bytes), <TT
CLASS="LITERAL"
>k</TT
> (1024 bytes) 
			of <TT
CLASS="LITERAL"
>m</TT
> (1048576 bytes) 
			volgen; 
			oudere versies van od zetten dit aantal 
			achter de filenaam met een 
			<TT
CLASS="LITERAL"
>+</TT
> ervoor in octale 
			notatie of decimaal met een punt achter 
			het getal
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-N</TT
>	(number)</DT
><DD
><P
>	geef het aantal bytes aan dat van iedere 
			file moet worden afgedrukt;
			achter het aantal kan nog de eenheid 
			<TT
CLASS="LITERAL"
>b</TT
> (blokken van 512 
			bytes), <TT
CLASS="LITERAL"
>k</TT
> (1024 bytes) 
			of <TT
CLASS="LITERAL"
>m</TT
> (1048576 bytes) 
			volgen 
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-t</TT
>	(type)</DT
><DD
><P
>	een alternatieve manier om het formaat 
			aan te geven: 
			het type kan met <TT
CLASS="LITERAL"
>a</TT
>, 
			<TT
CLASS="LITERAL"
>c</TT
>, <TT
CLASS="LITERAL"
>d</TT
>, 
			<TT
CLASS="LITERAL"
>f</TT
>, <TT
CLASS="LITERAL"
>o</TT
>, 
			<TT
CLASS="LITERAL"
>u</TT
> of <TT
CLASS="LITERAL"
>x</TT
> 
			worden aangeduid, 
			waarin <TT
CLASS="LITERAL"
>a</TT
> staat voor 
			<SPAN
CLASS="ACRONYM"
>ASCII</SPAN
>, <TT
CLASS="LITERAL"
>f</TT
> 
			voor <I
CLASS="FOREIGNPHRASE"
>floating point</I
>,
			<TT
CLASS="LITERAL"
>d</TT
> voor decimaal en 
			<TT
CLASS="LITERAL"
>u</TT
> voor een positief decimaal
			getal;
			achter de letter kan nog de lengte worden 
			opgegeven met <TT
CLASS="LITERAL"
>1</TT
>, 
			<TT
CLASS="LITERAL"
>2</TT
>, <TT
CLASS="LITERAL"
>4</TT
> 
			of <TT
CLASS="LITERAL"
>8</TT
> bytes
	  </P
></DD
></DL
></DIV
>
  </P
><P
>	<I
CLASS="FIRSTTERM"
>Strings</I
> is een ruw tooltje om 
	tekstfragmenten uit binaire bestanden, met name 
	programma's, te filteren. 
	De syntaxis luidt:  

   <P
><B
CLASS="COMMAND"
>		strings					</B
>  [- [a]		] [- [n]<TT
CLASS="REPLACEABLE"
><I
>lengte</I
></TT
>] [-t
	  		d					 | 		o					 | 		x					 
      ] [			file					
      ...]</P
>
  </P
><P
>	De opties luiden: 

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-a</TT
>	(all)</DT
><DD
><P
>	doorzoek hele bestand in plaats van 
			alleen de <I
CLASS="FIRSTTERM"
>data sectie</I
> 
			van een programma;
			deze optie kan worden afgekort tot een 
			enkel min-teken
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-n</TT
>	(number)</DT
><DD
><P
>	geeft aan dat alle strings met minimum 
			<TT
CLASS="REPLACEABLE"
><I
>lengte</I
></TT
> worden 
			geretourneerd in plaats van de standaard 
			waarde 4; 
			deze optie mag worden afgekort tot 
			<TT
CLASS="OPTION"
>-<TT
CLASS="REPLACEABLE"
><I
>lengte</I
></TT
></TT
>
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-t</TT
>	(type)</DT
><DD
><P
>	zorgt ervoor dat voor elke gevonden string 
			de positie in de file wordt afgedrukt 
			in decimale, octale, of hexadecimale notatie
	  </P
></DD
></DL
></DIV
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="PRINTENV"
></A
>printenv</H3
><P
>	<I
CLASS="FIRSTTERM"
>Printenv</I
> drukt de waarde 
	van omgevingsvariabelen af. 
	De syntaxis luidt:
  
   <P
><B
CLASS="COMMAND"
>		printenv				</B
>  [			variabele				...]</P
>
  </P
><P
>	Zonder argumenten worden alle variabelen afgedrukt, 
	net als met <B
CLASS="COMMAND"
>set</B
>; 
	als de namen van variabelen worden meegegeven, 
	dan worden die afgedrukt. 
	<B
CLASS="COMMAND"
>printenv TERM</B
> doet vrijwel
	hetzelfde als <B
CLASS="COMMAND"
>echo $TERM</B
>. 
  </P
><P
>	De exit status is <TT
CLASS="LITERAL"
>0</TT
> (true) als 
	alle variabelen bestaan en <TT
CLASS="LITERAL"
>1</TT
> (false) 
	als er &eacute;&eacute;n ongedefinieerd is. 
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SLEEP"
></A
>sleep</H3
><P
>	<I
CLASS="FIRSTTERM"
>Sleep</I
> onderbreekt de uitvoering 
	van een programma tijdelijk. 
	De syntaxis luidt:
   <P
><B
CLASS="COMMAND"
>		sleep					</B
>   			<TT
CLASS="REPLACEABLE"
><I
>seconden</I
></TT
>	 </P
>
  </P
><P
>	Sleep wordt vooral gebruikt om in een oneindige lus de 
	processor niet nodeloos te belasten in de trant van 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN3450"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>while true
do
  if [ <TT
CLASS="REPLACEABLE"
><I
>er_is_post</I
></TT
> ] 
  then
    <TT
CLASS="REPLACEABLE"
><I
>lees_post</I
></TT
>
    break
  sleep 10
done								</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="SU"
></A
>su</H3
><P
>	Met het <I
CLASS="FIRSTTERM"
>substitute user</I
> kan een 
	nieuwe shell worden opgestart onder een andere naam;
	standaard is dat root, ook wel eens als superuser aangeduid. 
	Na een <B
CLASS="COMMAND"
>exit</B
> commando komt u weer terug 
	in de oude shell. 
	Su vraagt uiteraard om het wachtwoord, tenzij het door 
	root wordt uitgevoerd. 
	Het wordt ook vaak gebruikt om een programma juist 
	minder privileges te geven voor de veiligheid. 
	De syntaxis luidt:

   <P
><B
CLASS="COMMAND"
>		su					</B
>  [-					] [<TT
CLASS="REPLACEABLE"
><I
>naam</I
></TT
>		] [-c <TT
CLASS="REPLACEABLE"
><I
>commando</I
></TT
>	]</P
>
  </P
><P
>	Standaard erft de nieuwe shell de oude omgeving 
	(directory en variabelen), maar de <TT
CLASS="OPTION"
>-</TT
> 
	optie maakt een <I
CLASS="FIRSTTERM"
>login shell</I
> en 
	voert <TT
CLASS="FILENAME"
>~/.profile</TT
> uit e.d. 
	Met de <TT
CLASS="OPTION"
>-c</TT
> optie wordt in plaats van een 
	interactieve shell een enkel commando uitgevoerd. 
	Vergelijk eens de volgende twee opdrachten. 

    <DIV
CLASS="INFORMALEXAMPLE"
><A
NAME="AEN3471"
></A
><P
></P
><TABLE
BORDER="1"
BGCOLOR="#d3dce3"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>su -c "whoami "
su -c "who am i" 						</PRE
></TD
></TR
></TABLE
><P
></P
></DIV
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="TEE"
></A
>tee</H3
><P
>	<I
CLASS="FIRSTTERM"
>Tee</I
> vormt een t-stuk in een 
	pijpleiding. 
	Het is een eenvoudig filter dat de standaard invoer 
	behalve naar de uitvoer ook naar de opgegeven files 
	kopieert. Zie ook <A
HREF="#PIJPLEIDINGEN"
>paragraaf <I
>pijpleidingen</I
></A
>. 
	De syntaxis luidt: 
 
    <P
><B
CLASS="COMMAND"
>		tee					</B
>  [-a					] [-i					] [			<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>	
      ...]</P
>
  </P
><P
>	De opties luiden: 

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-a</TT
>	(append)</DT
><DD
><P
>	plakt de uitvoer achter de file(s) in 
			plaats van ze te overschrijven
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-i</TT
>	(ignore)</DT
><DD
><P
>	Negeer een eventueel <TT
CLASS="LITERAL"
>SIGINT</TT
> 
			signaal
	  </P
></DD
></DL
></DIV
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="TIME"
></A
>time</H3
><P
>	<I
CLASS="FIRSTTERM"
>Time</I
> kan zowel een intern 
	shell commando als extern programma zijn. 
	Het voert een programma uit en geeft weer hoeveel tijd 
	het gekost heeft als verstreken tijd en het aantal 
	seconden dat de computer eraan heeft besteed in de 
	<I
CLASS="FOREIGNPHRASE"
>user</I
> en 
	<I
CLASS="FOREIGNPHRASE"
>system</I
> modus. 
	De syntaxis luidt:  

     <P
><B
CLASS="COMMAND"
>		time					</B
>   			<TT
CLASS="REPLACEABLE"
><I
>commando</I
></TT
> 
        [			<TT
CLASS="REPLACEABLE"
><I
>argument</I
></TT
>	
      ...]</P
>
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="TR"
></A
>tr</H3
><P
>	<I
CLASS="FIRSTTERM"
>Tr</I
> is een eenvoudig filter 
	waarmee tekens in een tekstbestand door andere vervangen 
	kunnen worden zonder de kracht of complexiteit van 
	bijvoorbeeld sed; 
	de bewerkte standaard invoer verschijnt op de standaard 
	uitvoer. 
	De Sytem V, <SPAN
CLASS="ACRONYM"
>BSD</SPAN
> en <SPAN
CLASS="ACRONYM"
>GNU</SPAN
> 
	versies lopen nogal uiteen. 
	De syntaxis luidt ongeveer: 

     <P
><B
CLASS="COMMAND"
>		tr					</B
>  [-c					] [-s					] [-d					]  <TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>1	  [<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>2	]</P
>
  </P
><P
>	De opties zijn:

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
> </TT
>	(geen)</DT
><DD
><P
>	Vervang alle tekens in de verzameling 
			<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>1 door 
			het corresponderende teken in 
			<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>2, 
			die even lang moeten zijn, bijvoorbeeld 
			<B
CLASS="COMMAND"
>tr '[:upper:]' '[:lower:]'</B
> 
			om alle hoofdletters door kleine te 
			vervangen
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-c</TT
>	(complement)</DT
><DD
><P
>	Vervang alle tekens in 
			<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>1 door 
			tekens die niet in 
			<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>1 voorkomen; 
			het resultaat kan per besturingssysteem
			verschillen
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-d</TT
>	(delete)</DT
><DD
><P
>	Verwijder alle tekens die voorkomen in
			<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>1
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-s</TT
>	(squeeze)</DT
><DD
><P
>	als een teken uit 
			<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
>1 meerdere 
			keren achter elkaar voorkomt, dan blijft er 
			maar &eacute;&eacute;n over in de output, 
			bijvoorbeeld 
			<B
CLASS="COMMAND"
>tr -s '\000-\040'</B
> verwijdert 
			dubbele spaties, lege regels e.d.
	  </P
></DD
></DL
></DIV
>
  </P
><P
>	De opties kunnen ook gecombineerd worden. 
	In de strings mogen de backslash escapes van 
	<A
HREF="#AANHALING"
>paragraaf <I
>aanhaling</I
></A
> en de karakter klassen van 
	<A
HREF="#GREP"
>paragraaf <I
>grep en reguliere expressies</I
></A
> worden gebruikt. 
	Tevens kunnen reeksen tekens worden aangegeven met 
	<TT
CLASS="OPTION"
><TT
CLASS="REPLACEABLE"
><I
>begin-eind</I
></TT
></TT
> en 
	<TT
CLASS="OPTION"
>[<TT
CLASS="REPLACEABLE"
><I
>teken</I
></TT
>*<TT
CLASS="REPLACEABLE"
><I
>aantal</I
></TT
>]</TT
>. 
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="WC"
></A
>wc</H3
><P
>	<I
CLASS="FIRSTTERM"
>Wc</I
> is een eenvoudig tooltje om de 
	lengte van een tekst te tellen. 
	De syntaxis luidt: 

     <P
><B
CLASS="COMMAND"
>		wc					</B
>  [-l					] [-w					] [-c					] [			<TT
CLASS="REPLACEABLE"
><I
>file</I
></TT
>	
      ...]</P
>
  </P
><P
>	De opties zijn:

    <P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
><TT
CLASS="OPTION"
>-l</TT
>	(lines)</DT
><DD
><P
>	tel het aantal regels 
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-w</TT
>	(words)</DT
><DD
><P
>	tel het aantal woorden
	  </P
></DD
><DT
><TT
CLASS="OPTION"
>-c</TT
>	(characters)</DT
><DD
><P
>	telt het aantal <SPAN
CLASS="emphasis"
><I
CLASS="EMPHASIS"
>bytes</I
></SPAN
>; 
			sommige versies hebben een optie
			<TT
CLASS="OPTION"
>-m</TT
> die karakters telt
	  </P
></DD
></DL
></DIV
>
  </P
><P
>	Standaard worden regels, woorden en bytes of tekens geteld. 
	Als er meerdere files worden opgegeven, dan volgt nog een 
	regel met het totaal over alle files (verwarrend als u een 
	bestand <TT
CLASS="FILENAME"
>total</TT
> hebt :-) 
  </P
></DIV
><DIV
CLASS="SECT2"
><HR><H3
CLASS="SECT2"
><A
NAME="YES"
></A
>yes</H3
><P
>	<I
CLASS="FIRSTTERM"
>Yes</I
> is een simpel programmaatje, 
	dat zolang <TT
CLASS="COMPUTEROUTPUT"
>y</TT
> of een 
	andere string produceert totdat het wordt afgebroken. 
	De syntaxis luidt: 

     <P
><B
CLASS="COMMAND"
>		yes					</B
>  [<TT
CLASS="REPLACEABLE"
><I
>string</I
></TT
> 	]</P
>
  </P
><P
>	Het wordt vooral gebruikt in pijpleidingen, zoals 
	<B
CLASS="COMMAND"
>yes n | fsck /</B
> 
	Fsck zal vragen of u wel zeker weet dat u het root file 
	systeem wilt controleren; 
	omdat dat riskant is op een aktief systeem wordt die 
	vraag automatisch met <TT
CLASS="LITERAL"
>n</TT
>(ee) beantwoord. 
  </P
></DIV
></DIV
></DIV
></BODY
></HTML
>