<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD>
 <META NAME="GENERATOR" CONTENT="SGML-Tools 1.0.9">
 <TITLE>BASH Programmering - Introductie HOW-TO</TITLE>


</HEAD>
<BODY>
<H1>BASH Programmering - Introductie HOW-TO</H1>

<H2>door Mike G <CODE>mikkey at dynamo.com.ar</CODE><BR>
    Vertaald door: Ellen Bokhorst, bokkie at nl.linux.org</H2>Do jul 27 09:36:18 ART 2000
<P><HR>
<EM>     Dit artikel is bedoeld om je te helpen een begin te maken met
    het programmeren van basis tot middelmatige shell-scripts.     Het is niet bedoeld als een document voor gevorderden (zie de titel).
    Ik ben GEEN expert noch een goeroe shellprogrammeur.
    Ik besloot dit te schrijven omdat ik er veel van zal leren en het wellicht
    van nut kan zijn voor andere mensen. Feedback wordt zeer gewaardeerd vooral
    in de vorm van een patch :).
    </EM>
<HR>
<H2><A NAME="s1">1. Introductie</A></H2>

<H2>1.1 Ophalen van de laatste versie</H2>

<P>
<A HREF="http://www.linuxdoc.org/HOWTO/Bash-Prog-Intro-HOWTO.html">http://www.linuxdoc.org/HOWTO/Bash-Prog-Intro-HOWTO.html</A><H2>1.2 Benodigdheden</H2>

<P> Bekendheid met GNU/Linux opdrachtregels, en bekendheid met
basisprogrammeerconcepten is prettig. Alhoewel dit geen introductie
is in programmeren, wordt er van veel basisconcepten een uitleg
gegeven (of op z'n minst wordt dit geprobeerd).
<H2>1.3 Gebruik van dit document</H2>

<P>Dit document probeert te helpen bij de volgende situtaties
<UL>
<LI>Je hebt een idee over programmeren en je wilt beginnen
een aantal shellscripts te coderen.</LI>
<LI>Je hebt een vaag idee over shellprogrammering en wilt
een soort van referentie.</LI>
<LI>Je wilt een aantal shellscripts zien met wat opmerkingen
om te beginnen je eigen shellscripts te gaan schrijven.</LI>
<LI>Je gaat over van DOS/Windows (of je deed dit al) en wil
"batch" processen maken.</LI>
<LI>Je bent een echte nerd en leest iedere beschikbare how-to</LI>
</UL>
<H2><A NAME="s2">2. Zeer eenvoudige Scripts</A></H2>

<P>In deze HOW-TO wordt getracht je een aantal hints te geven over
shellscriptprogrammering welke sterk is gebaseerd op voorbeelden.
<P>In deze sectie zijn een aantal kleine scripts te vinden die je
hopelijk op weg helpen een aantal technieken te doorgronden.
<H2>2.1     Traditioneel hello world script</H2>

<P>
<P>
<BLOCKQUOTE><CODE>
<PRE>
          #!/bin/bash          
          echo Hello World    
        
</PRE>
</CODE></BLOCKQUOTE>
<P>Dit script bestaat slechts uit twee regels.
In de eerste regel wordt het systeem duidelijk gemaakt welk programma
moet worden gebruikt om het bestand uit te voeren.
<P>De tweede regel bestaat uit alleen die actie waarmee 'Hello World!
op de terminal wordt afgedrukt.
<P>Als je iets krijgt als <I>./hello.sh: Command not found.</I>
is waarschijnlijk de eerste regel `#!/bin/bash' niet goed, roep
`whereis bash' of zie `bash zoeken' om te bezien hoe je deze regel
zou moeten schrijven.
<H2>2.2 Een zeer eenvoudig backupscript</H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
        #!/bin/bash          
        tar -cZf /var/my-backup.tgz /home/me/
        
</PRE>
</CODE></BLOCKQUOTE>
<P>In plaats dat er nu een bericht op de terminal wordt weergegeven,
maken we in dit script een tar-ball van de homedirectory van een
gebruiker. Het is niet de bedoeling dat dit wordt gebruikt. Later in
dit document wordt een handiger backupscript gepresenteerd.
<H2><A NAME="s3">3. Alles over omleiding</A></H2>

<H2>3.1 Theorie en snelle naslag</H2>

<P>Er zijn 3 file descriptors, stdin, stdout en stderr (std=standaard).
<P>In principe kun je:
<OL>
<LI> stdout naar een bestand omleiden</LI>
<LI> stderr naar een bestand omleiden</LI>
<LI> stdout naar stderr omleiden</LI>
<LI> stderr naar stdout omleiden</LI>
<LI> stderr en stdout naar een bestand omleiden</LI>
<LI> stderr en stdout naar stdout omleiden</LI>
<LI> stderr en stdout naar stderr omleiden</LI>
</OL>

1  is een representatie van stdout en 2 van stderr.
<P> Een opmerking hierover: met de opdracht less kun je zowel
stdout (welke in de buffer blijft) en stderr, welke op het scherm
wordt weergegeven, bekijken, maar is verwijderd als je door de buffer
probeert te 'bladeren'.
<H2>3.2 Voorbeeld: stdout naar bestand</H2>

<P>Hiermee wordt de uitvoer van een programma naar een bestand
weggeschreven.
<BLOCKQUOTE><CODE>
<PRE>
        ls -l > ls-l.txt
        
</PRE>
</CODE></BLOCKQUOTE>

Hier zal een bestand, genaamd 'ls-l.txt' worden aangemaakt en hierin
zal worden opgevangen wat je krijgt als je de opdracht 'ls -l' typt
en uitvoert.
<H2>3.3 Voorbeeld: stderr naar bestand</H2>

<P> Dit zorgt dat de uitvoer van stderr van een programma naar
een bestand wordt weggeschreven.
<BLOCKQUOTE><CODE>
<PRE>
        grep da * 2> grep-errors.txt
        
</PRE>
</CODE></BLOCKQUOTE>

Hier zal een bestand, genaamd 'grep-errors.txt' worden aangemaakt en
hier zal dan het stderr gedeelte van de uitvoer in staan van de
opdracht 'grep da *'.
<H2>3.4 Voorbeeld: stdout naar stderr</H2>

<P>Dit zorgt dat de sterr uitvoer van een programma naar
dezelfde filedescriptor als stdout wordt weggeschreven.
<BLOCKQUOTE><CODE>
<PRE>
        grep da * 1>&amp;2 
        
</PRE>
</CODE></BLOCKQUOTE>

Hier wordt het stdout gedeelte van de opdracht naar stderr gezonden,
je merkt dat mogelijk op verschillende manieren.
<H2>3.5 Voorbeeld: stderr naar stdout</H2>

<P> Dit zorgt dat de stderr uitvoer van een programma naar
dezelfde filedescriptor wordt weggeschreven als stdout.
<BLOCKQUOTE><CODE>
<PRE>
        grep * 2>&amp;1
        
</PRE>
</CODE></BLOCKQUOTE>

Hier wordt het stderr gedeelte van de opdracht naar stdout gestuurd,
als je middels een pipe-symbool de uitvoer naar less stuurt, zul je
zien dat de regels die normaal gesproken 'verdwijnen' (als ze naar
stderr worden geschreven) nu behouden blijven (omdat ze zich op
stdout bevinden).
<H2>3.6 Voorbeeld: stderr en stdout naar bestand</H2>

<P> Hiermee zal alle uitvoer van een programma in een bestand worden
geplaatst. Soms is dit geschikt voor cron entries, als je een opdracht
in absolute stilte wilt laten uitvoeren.
<BLOCKQUOTE><CODE>
<PRE>
        rm -f $(find / -name core) &amp;> /dev/null 
        
</PRE>
</CODE></BLOCKQUOTE>

Dit (denkend aan een cron entry) zal ieder bestand genaam 'core'
in iedere directory verwijderen. Merk op dat je er nogal zeker
van moet zijn wat een opdracht doet als je de uitvoer ervan gaat
verwijderen.
<H2><A NAME="s4">4. Pipes</A></H2>

<P>In deze sectie wordt op een zeer eenvoudige en praktische wijze uitgelegd
hoe gebruik te maken van het pipe-symbool en waarvoor je het zou kunnen
gebruiken.
<H2>4.1 Wat het zijn en waarvoor je het zou kunnen gebruiken</H2>

<P> Pipe-symbolen laten je gebruik maken van (zeer eenvoudig uitgelegd) de
uitvoer van een programma als de invoer van een ander programma.
<H2>4.2 Voorbeeld: eenvoudige pipe met sed</H2>

<P> Dit is een zeer eenvoudige manier om gebruik te maken van een
pipe-symbool.
<BLOCKQUOTE><CODE>
<PRE>
ls -l | sed -e "s/[aeio]/u/g"   
</PRE>
</CODE></BLOCKQUOTE>

Wat er hier gebeurt is het volgende: eerst wordt de opdracht 'ls -l' 
uitgevoerd, en in plaats dat de uitvoer ervan wordt afgedrukt, wordt
het naar het programma sed gestuurd (piped), wat op zijn beurt afdrukt wat
het moet afdrukken.
<H2>4.3 Voorbeeld: een alternatief voor ls -l *.txt</H2>

<P> Waarschijnlijk is dit een moeilijkere manier om een ls -l *.txt uit
te voeren, maar het dient hier ter illustratie, niet voor het oplossen van
een opsommingsdilemma.
<BLOCKQUOTE><CODE>
<PRE>
ls -l | grep "\.txt$"
</PRE>
</CODE></BLOCKQUOTE>

Hier wordt de uitvoer van het programma ls -l naar het grep programma
gezonden, welke op zijn beurt de regels afdrukt die overeenkomen met de
reguliere expressie "\.txt$".
<H2><A NAME="s5">5. Variabelen</A></H2>

<P> Je kunt net als in iedere andere programmeertaal gebruik maken
van variabelen. Er zijn geen gegevenstypen.
Onder bash kan een variabele bestaan uit een nummer, een teken, of een
reeks tekens.
<P>Je hoeft een variabele niet te declareren. Door er slechts een
waarde aan toe te kennen zal het worden aangemaakt.
<H2>5.1        Voorbeeld: Hello World! door gebruik te maken van variabelen</H2>

<P> 
<BLOCKQUOTE><CODE>
<PRE>
            #!/bin/bash          
            STR="Hello World!"
            echo $STR    
            
</PRE>
</CODE></BLOCKQUOTE>
<P>In regel 2 wordt een variabele aangemaakt met de naam STR
en hieraan wordt de string "Hello World!" toegekend.
De WAARDE van deze variabele wordt vervolgens opgehaald door er
een '$' voor te plaatsen.
Let er alsjeblieft op (probeer het uit!) dat als je het '$' teken
niet gebruikt, de uitvoer van het programma iets anders zal zijn,
en het waarschijnlijk niet datgene zal zijn wat je wilt dat 't is.
<H2>5.2           Voorbeeld: Een zeer eenvoudig backupscript (iets beter)</H2>

<P> 
<BLOCKQUOTE><CODE>
<PRE>
           #!/bin/bash          
           OF=/var/my-backup-$(date +%Y%m%d).tgz
           tar -cZf $OF /home/me/
           
</PRE>
</CODE></BLOCKQUOTE>
<P>In dit script wordt iets anders ge&iuml;ntroduceerd. Ten
eerste zou je nu bekend moeten zijn met de aanmaak van de
variabele en de toekenning in regel 2. Let op de expressie
`$(date +%Y%m%d)'.
Als je het script uit laat voeren, zal je bemerken dat het
de opdracht binnen de haakjes uitvoert, en de uitvoer ervan
afvangt.
<P>Merk op dat de naam van het bestand, de uitvoer, iedere dag
anders zal zijn, vanwege de opmaakoptie van de opdracht date 
(+%Y%m%d). Je kunt dit wijzigen door een ander formaat op te geven.
<P>Nog wat meer voorbeelden:
<P> echo ls
<P> echo $(ls)
<H2>5.3 Lokale variabelen</H2>

<P> Lokale variabelen kunnen worden aangemaakt door gebruik te maken van het
keyword <I>local</I>.
<P>
<BLOCKQUOTE><CODE>
<PRE>
        #!/bin/bash
        HELLO=Hello 
        function hello {
                local HELLO=World
                echo $HELLO
        }
        echo $HELLO
        hello
        echo $HELLO
</PRE>
</CODE></BLOCKQUOTE>

Dit voorbeeld zou genoeg moeten zijn om aan te tonen hoe je
een lokale variabele gebruikt.
<H2><A NAME="s6">6. Voorwaardelijke opdrachten</A></H2>

<P>Voorwaardelijke opdrachten laten je een beslissing nemen of een
actie wel of niet zal worden uitgevoerd, de beslissing wordt genomen door
de waarde te bepalen van een expressie.
<H2>6.1     Droge Theorie</H2>

<P>Voorwaardelijke opdrachten bestaan er in veel vormen. 
De basisvorm is:
<B>if</B> <I>expressie</I> <B>then</B> <I>statement</I>
hierbij wordt 'statement' alleen uitgevoerd wanneer de 'expressie'
de waarde true oplevert.
<P>`2&lt;1' is een expressie die de waarde false oplevert, 
terwijl `2&gt;1' 
de waarde true oplevert.
<P> Er zijn nog andere vormen voorwaardelijke opdrachten, zoals:
<B>if</B> <I>expressie</I> 
<B>then</B> <I>statement1</I> <B>else</B> <I>statement2</I>.
Hier wordt 'statement1' uitgevoerd als de 'expressie' true
oplevert, anders wordt 'statement2' uitgevoerd.
<P>Nog een andere vorm van een voorwaardelijke opdracht is:
<B>if</B> <I>expressie1</I> 
<B>then</B> <I>statement1</I> 
<B>else if</B> <I>expressie2</I> <B>then</B> <I>statement2</I> 
<B>else</B> <I>statement3</I>
In deze vorm is slechts de
"ELSE IF 'expressie2' THEN 'statement2'" toegevoegd wat 
maakt dat statement2 wordt uitgevoerd als expressie2 de waarde true
oplevert. De rest is wat je er zelf van maakt. 
(zie vorige vormen).
<P> Iets over syntax:
<P> De basis van een 'if' constructie onder bash is:
<P> if [expressie];
<P> then
<P>    code als 'expressie' is true.
<P> fi
<H2>6.2        Voorbeeld: Basis voorwaardelijke opdracht if .. then</H2>

<P> 
<BLOCKQUOTE><CODE>
<PRE>
            #!/bin/bash
            if [ "foo" = "foo" ]; then
               echo waarde van expressie leverde true op
            fi
            
</PRE>
</CODE></BLOCKQUOTE>
<P>De code die zal worden uitgevoerd als de expressie tussen de
blokhaken true oplevert, is te vinden achter het 'then' woord en
voor het 'fi' woord waarmee het einde van de voorwaardelijk
uit te voeren code wordt aangegeven.
<H2>6.3        Voorbeeld: Voorbeeld basis voorwaardelijke opdracht if .. then ... else        </H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
            #!/bin/bash
            if [ "foo" = "foo" ]; then
               echo expressie levert de waarde true op
            else
               echo expressie levert de waarde false op
            fi
            
</PRE>
</CODE></BLOCKQUOTE>
<H2>6.4        Voorbeeld: Voorwaardelijke opdrachten met variabelen</H2>

<P> 
<BLOCKQUOTE><CODE>
<PRE>
            #!/bin/bash
            T1="foo"
            T2="bar"
            if [ "$T1" = "$T2" ]; then
                echo expressie levert de waarde true op
            else
                echo expressie levert de waarde false op
            fi
            
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="s7">7. Loops for, while en until</A></H2>

<P>In deze sectie tref je for, while en until loops aan.
<P> De <B>for</B> loop werkt iets anders dan in andere programmeertalen.
Eigenlijk laat het je een serie 'woorden' binnen een string herhalen.
<P>De <B>while</B> voert een stuk code uit als de controlerende 
expressie true oplevert, en stopt alleen wanneer het false is
(of als er binnen de
uitgevoerde code een expliciete break werd gevonden).
<P>De <B>until</B> loop is bijna gelijk aan de while loop behalve dat
de code  wordt uitgevoerd terwijl de controlerende expressie de waarde
false oplevert.
<P>Als je het vermoeden hebt dat while en until erg op elkaar lijken, heb je gelijk.
<H2>7.1 Voorbeeld met for</H2>

<P> 
<BLOCKQUOTE><CODE>
<PRE>
        #!/bin/bash
        for i in $( ls ); do
            echo item: $i
        done
        
</PRE>
</CODE></BLOCKQUOTE>
<P>In de tweede regel, declareren we i als variabele voor de
verschillende waarden in $( ls ).
<P>De derde regel zou zonodig langer kunnen zijn, of er zouden meer
regels voor kunnen komen voor de done (4).
<P> `done' (4) geeft aan dat de code die de waarde van $i gebruikte
be&euml;indigd is en $i een nieuwe waarde aan kan nemen.
<P>Dit script heeft weinig nut, en een nuttiger wijze om gebruik te
maken van de for loop zou zijn het in het voorgaande voorbeeld 
te gebruiken waarbij slechts bepaalde bestanden overeenkomen.
<H2>7.2 Met C vergelijkende for</H2>

<P> fiesh raadde het toevoegen van deze vorm van een loop aan. 
Het is een for loop
meer vergelijkbaar met die van C/perl...
<BLOCKQUOTE><CODE>
<PRE>
        #!/bin/bash
        for i in `seq 1 10`;
        do
                echo $i
        done    
        
</PRE>
</CODE></BLOCKQUOTE>
<H2>7.3 Voorbeeld met while</H2>

<P> 
<BLOCKQUOTE><CODE>
<PRE>
         #!/bin/bash 
         COUNTER=0
         while [  $COUNTER -lt 10 ]; do
             echo De teller is $COUNTER
             let COUNTER=COUNTER+1 
         done
         
</PRE>
</CODE></BLOCKQUOTE>
<P> Dit script 'emuleert' de welbekende
(C, Pascal, perl, enz) 'for' structuur
<H2>7.4 Until voorbeeld</H2>

<P> 
<BLOCKQUOTE><CODE>
<PRE>
         #!/bin/bash 
         COUNTER=20
         until [  $COUNTER -lt 10 ]; do
             echo COUNTER $COUNTER
             let COUNTER-=1
         done
         
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="s8">8. Functies</A></H2>

<P>Zoals in bijna iedere programmeertaal, kun je functies gebruiken om
stukken code op een wat logischer wijze te groeperen of te oefenen in
de goddelijke kunst van recursie.
<P>Het declareren van een functie is slecht een kwestie van het
schrijven van function mijn_func { mijn_code }.
<P>Het aanroepen van een functie is net als het aanroepen van ieder ander
programma, je tikt gewoon de naam ervan in.
<H2>8.1 Voorbeeld van een functie</H2>

<P> 
<BLOCKQUOTE><CODE>
<PRE>
           #!/bin/bash 
           function quit {
                exit
           }
           function hello {
                echo Hello!
           }
           hello
           quit
           echo foo 
           
</PRE>
</CODE></BLOCKQUOTE>
<P>In de regels 2-4 staat de 'quit' functie. 
In de regels 5-7 staat de 'hello' functie.
Als je er niet geheel zeker van bent wat dit script doet, probeer
het dan uit!
<P>Merk op dat functies niet in een specifieke volgorde hoeven te
staan.
<P>Bij het uitvoeren van het script, zal je bemerken dat als eerste
de functie 'hello' wordt aangeroepen en ten tweede de 'quit'
functie en de functie komt nooit bij regel 10.
<H2>8.2 Voorbeeld van een functie met parameters</H2>

<P> 
<BLOCKQUOTE><CODE>
<PRE>
                #!/bin/bash 
                function quit {
                   exit
                }  
                function e {
                    echo $1 
                }  
                e Hello
                e World
                quit
                echo foo 

           
</PRE>
</CODE></BLOCKQUOTE>

Dit script is bijna identiek aan het voorgaande script. Het belangrijkste
verschil is de functie 'e'. Deze functie drukt het eerste argument dat het
ontvangt af. Argumenten binnen functies worden op dezelfde wijze behandeld
als argumenten die aan het script worden gegeven.
<H2><A NAME="s9">9. Gebruikersinterfaces</A></H2>

<H2>9.1 Het gebruik van select om eenvoudige menu's te maken</H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
           #!/bin/bash
           OPTIONS="Hello Quit"
           select opt in $OPTIONS; do
               if [ "$opt" = "Quit" ]; then
                echo klaar
                exit
               elif [ "$opt" = "Hello" ]; then
                echo Hello World
               else
                clear
                echo onjuiste keuze
               fi
           done
          
</PRE>
</CODE></BLOCKQUOTE>
 
<P>Als je dit script uitvoert, zal je zien dat dit de droom is
van een programmeur voor op tekst gebaseerde menu's.
Je zal waarschijnlijk bemerken dat het erg lijkt op de 'for'
instructie, in plaats van dat ieder 'woord' in $OPTIONS wordt
doorlopen, geeft het de gebruiker een prompt.
<H2>9.2     Gebruik maken van de opdrachtregel</H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
          #!/bin/bash        
          if [ -z "$1" ]; then 
              echo usage: $0 directory
              exit
          fi
          SRCD=$1
          TGTD="/var/backups/"
          OF=home-$(date +%Y%m%d).tgz
          tar -cZf $TGTD$OF $SRCD
         
</PRE>
</CODE></BLOCKQUOTE>
<P>Het zou je duidelijk moeten zijn wat dit script doet. 
De expressie in de eerste voorwaardelijke opdracht test of het
programma een argument ($1) meekreeg en stopt als het dit niet deed,
waarbij een kort bericht over het gebruik aan de gebruiker wordt
getoond. De rest van het script zou vanaf hier duidelijk moeten zijn.
<H2><A NAME="s10">10. Diversen</A></H2>

<H2>10.1 Inlezen van gebruikersinvoer met read</H2>

<P>In veel situaties wil je de gebruiker wellicht vragen om wat invoer, en
er zijn verscheidene manieren om dit te bereiken:
Dit is &eacute;&eacute;n van die manieren:
<BLOCKQUOTE><CODE>
<PRE>
                #!/bin/bash
                echo Vul alsjeblieft je naam in
                read NAME
                echo "Hi $NAME!"
        
</PRE>
</CODE></BLOCKQUOTE>

Een variant daarop zal het volgende voorbeeld verduidelijken waarmee
je meerdere waarden met read kan verkrijgen.
<BLOCKQUOTE><CODE>
<PRE>
                #!/bin/bash
                echo Vul alsjeblieft je voornaam en achternaam in
                read FN LN 
                echo "Hi! $LN, $FN !"
        
</PRE>
</CODE></BLOCKQUOTE>
<H2>10.2     Rekenkundige waarde bepalen</H2>

<P>Probeer het volgende achter de opdrachtregel (of in een shell):
<P>echo 1 + 1
<P>Als je verwachtte '2' te zien te krijgen, zal je wel teleurgesteld
zijn. Wat als je wilt dat BASH van een aantal getallen de waarde
bepaalt?
Dit is de oplossing:
<P> echo $((1+1))
<P>Hiermee zal een 'logischer' uitvoer worden geproduceerd.
Dit is voor het bepalen van de waarde van een rekenkundige expressie.
Je kunt dit ook als volgt bereiken:
<P> echo $[1+1]
<P>Als je breuken of meer rekenkunde nodig hebt of dit gewoon wilt,
kun je bc gebruiken om de waarde te bepalen van rekenkundige
expressies.
<P>als ik op de opdrachtregel "echo $[3/4]" opgaf, zou het 0
retourneren omdat bash alleen integers gebruikt bij beantwoording.
Als je "echo 3/4|bc -l" opgaf, zou het op juiste wijze 0.75
retourneren.
<H2>10.3 Bash zoeken</H2>

<P> UIt een bericht van mike (zie Met dank aan) 
<P> je gebruikt altijd #!/bin/bash .. je zou wellicht een voorbeeld
<P> kunnen geven van waar bash is te vinden.
<P> de voorkeur is 'locate bash', maar niet op alle computers is
<P> locate ge&euml;nstalleerd.
<P> `find ./ -name bash' vanaf de rootdir zal gewoonlijk wel werken.
<P> Aanbevolen te doorzoeken locaties:
<P>         ls -l /bin/bash
<P>         ls -l /sbin/bash
<P>         ls -l /usr/local/bin/bash
<P>         ls -l /usr/bin/bash
<P>         ls -l /usr/sbin/bash
<P>         ls -l /usr/local/sbin/bash
<P> (kan zo geen andere directory's bedenken...  ik heb het voorheen
<P> meestal wel op een ander systeem op &eacute;&eacute;n van deze
<P> plaatsen kunnen vinden.
<P> Je zou ook nog 'which bash' kunnen proberen.
<H2>10.4 De return waarde van een programma verkrijgen</H2>

<P>Onder Bash, wordt de return waarde van een programma in een speciale
variabele, genaamd $?, opgeslagen.
<P>Hiermee wordt ge&iuml;llustreerd hoe de return waarde van een programma
kan worden afgevangen, waarbij ik ervan uit ga dat de directory <I>dada</I>
niet voorkomt.
(Ook dit was een suggestie van mike)
<BLOCKQUOTE><CODE>
<PRE>
        #!/bin/bash
        cd /dada &amp;> /dev/null
        echo rv: $?
        cd $(pwd) &amp;> /dev/null
        echo rv: $?
        
</PRE>
 
</CODE></BLOCKQUOTE>
<H2>10.5 Afvangen van de uitvoer van een opdracht</H2>

<P>Dit kleine script laat alle tabellen van alle databases zien (ervan
uitgaande dat je MySQL hebt ge&iuml;nstalleerd). Overweeg tevens het
wijzigen van de opdracht 'mysql' waarbij een geldige gebruikersnaam en
wachtwoord wordt gebruikt.
<BLOCKQUOTE><CODE>
<PRE>
        #!/bin/bash
        DBS=`mysql -uroot  -e"show databases"`
        for b in $DBS ;
        do
                mysql -uroot -e"show tables from $b"
        done
        
</PRE>
</CODE></BLOCKQUOTE>
<H2>10.6 Meerdere bronbestanden</H2>

<P>Je kunt met de opdracht source meerdere bestanden gebruiken.
<P> __TO-DO__
<H2><A NAME="s11">11. Tabellen</A></H2>

<H2>11.1 Stringvergelijkings operatoren</H2>

<P> (1) s1 = s2
<P> (2) s1 != s2
<P> (3) s1 &lt; s2
<P> (4) s1 &gt; s2
<P> (5) -n s1 
<P> (6) -z s1 
<P> (1) s1 komt overeen met s2
<P> (2) s1 komt niet overeen met s2
<P> (3) __TO-DO__
<P> (4) __TO-DO__
<P> (5) s1 is niet gelijk aan null
(bevat &eacute;&eacute;n of meer tekens)
<P> (6) s1 is null 
<H2>11.2 Stringvergelijking voorbeelden</H2>

<P> Vergelijken van twee strings. 
<BLOCKQUOTE><CODE>
<PRE>
        #!/bin/bash
        S1='string'
        S2='String'
        if [ $S1=$S2 ];
        then
                echo "S1('$S1') is niet gelijk aan S2('$S2')"
        fi
        if [ $S1=$S1 ];
        then
                echo "S1('$S1') is gelijk aan S1('$S1')"
        fi
        
</PRE>
</CODE></BLOCKQUOTE>
<P> Ik haal hier een opmerking aan vanuit een mail ingezonden door
Andreas Beck, verwijzend naar het gebruik van
<I>if [ $1 = $2 ]</I>.
<P>Dit is niet zo'n goed idee, omdat als $S1 of $S2 leeg is, je een
parse error krijgt.
x$1=x$2 of "$1"="$2" is beter.
<H2>11.3 Rekenkundige operators</H2>

<P> +
<P> -
<P> *
<P> /
<P> % (rest)
<H2>11.4 Rekenkundige relationele operators</H2>

<P> -lt (&lt;) 
<P> -gt (>)
<P> -le (&lt;=)
<P> -ge (&gt;=)
<P> -eq (==)
<P> -ne (!=)
<P> C programmeurs zouden de operator eenvoudigweg indelen naar
de overeenkomstige haakjes.
<H2>11.5 Handige opdrachten</H2>

<P>Deze sectie werd door Kees herschreven (zie met dank aan...)
<P>Een paar van deze opdrachten zijn bijna volledige programmeertalen.
Van deze opdrachten wordt alleen de basis uitgelegd. Voor een meer 
gedetailleerde beschrijving, kun je de man pages van de opdrachten raadplegen.
<P><B>sed</B> (stream editor)
<P> Sed is een niet interactieve editor. In plaats dat een bestand wordt
aangepast door de cursor op het scherm te verplaatsen, maak je gebruik van
een script met de sed-instructies en geef je deze als argument samen met
het te wijzigen bestand op aan sed. Je kunt sed ook als een filter beschrijven.
Laten we eens wat voorbeelden bekijken:
<P>
<BLOCKQUOTE><CODE>
<PRE>
        $sed 's/te_vervangen/vervangen_door/g' /tmp/dummy
        
</PRE>
</CODE></BLOCKQUOTE>
<P> Sed vervangt de string 'te_vervangen' door de string 'vervangen_door' en
leest vanuit het /tmp/dummy bestand.
Het resultaat zal naar stdout (normaal gesproken de console) worden
gezonden, maar je kunt aan het einde van deze regel ook '> capture' toevoegen
waardoor sed de uitvoer naar het bestand 'capture' zal sturen.
<P>
<BLOCKQUOTE><CODE>
<PRE>
        $sed 12, 18d /tmp/dummy
        
</PRE>
</CODE></BLOCKQUOTE>
        
<P> Sed laat alle regels zien behalve de regels 12 tot 18. Het oorspronkelijke
bestand wordt door deze opdracht niet aangepast.
<P><B>awk</B> (manipulatie van gegevensbestanden, ophalen en verwerken van tekst)
<P>Er bestaan veel implementaties van de programmeertaal AWK
(de bekendste interpreters zijn GNU's
gawk en 'new awk' mawk.) Het principe is eenvoudig: AWK scant op een patroon,
en voor ieder overeenkomend patroon zal een actie worden uitgevoerd.
<P> Wederom heb ik een dummy-bestand aangemaakt met de volgende regels:
<P> <I>"test123</I>
<P> <I>test</I>
<P> <I>tteesstt"</I>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        $awk '/test/ {print}' /tmp/dummy
        
</PRE>
</CODE></BLOCKQUOTE>
<P> test123
<P> test
<P> Het patroon waar AWK naar zoekt, is 'test' en de actie die het uitvoert
wanneer het een regel in het bestand /tmp/dummy met de string 'test' vindt, is
`print'.
<P>
<BLOCKQUOTE><CODE>
<PRE>
        $awk '/test/ {i=i+1} END {print i}' /tmp/dummy
        
</PRE>
</CODE></BLOCKQUOTE>
<P>3
<P>Wanneer je naar meer patronen zoekt, kun je de tekst tussen de 
aanhalingstekens beter vervangen door '-f file.awk' zodat je alle patronen
en acties in het bestand 'file.awk' kunt plaatsen.
<P><B>grep</B> (druk regels af overeenkomend met een zoekpatroon)
<P>We hebben in de vorige hoofdstuk reeds heel wat grep opdrachten gezien,
die de regels laten zien die met een patroon overeenkomen. Maar grep kan meer.
<BLOCKQUOTE><CODE>
<PRE>
        $grep "zoek naar dit" /var/log/messages -c
        
</PRE>
</CODE></BLOCKQUOTE>
<P> 12
<P>De string "zoek naar dit" is 12 keer in het bestand /var/log/messages
gevonden.
<P> [ok, dit voorbeeld was nep, het bestand /var/log/messages was aangepast :-)]
<P><B>wc</B> (telt regels, woorden en bytes)
<P>In het volgende voorbeeld, zien we dat de uitvoer niet hetgeen is wat we
ervan verwachtte. Het dummy bestand, zoals in dit voorbeeld gebruikt, bevat
de volgende tekst:
<I>"bash introduction</I>
<I> howto test file"</I>
<P>
<BLOCKQUOTE><CODE>
<PRE>
        $wc --words --lines --bytes /tmp/dummy
        
</PRE>
</CODE></BLOCKQUOTE>
<P> 2 5 34 /tmp/dummy
<P>De volgorde van de parameters doet er voor wc niet toe. Wc drukt ze altijd
in de standaardvolgorde af, dus zoals je kunt zien:
&lt;lines&gt;&lt;words&gt;&lt;bytes&gt;&lt;filename&gt;.
<P><B>sort</B> (sorteer regels van tekstbestanden)
<P> Ditmaal bevat het dummy bestand de volgende tekst:
<P> <I>"b</I>
<P> <I>c</I>
<P> <I>a"</I>
<BLOCKQUOTE><CODE>
<PRE>
        $sort /tmp/dummy
        
</PRE>
</CODE></BLOCKQUOTE>
<P> Zo ziet de uitvoer er ongeveer uit:
<P> <I>a</I>
<P> <I>b</I>
<P> <I>c</I>
<P> Opdrachten zouden niet zo eenvoudig moeten zijn :-)
<B>bc</B> (een calculator programmeertaal)
<P>Met Bc kunnen berekeningen vanaf de opdrachtregel worden gemaakt
(invoer vanuit een bestand, niet via omleiding of een pipe
maar wel vanuit een gebruikersinterface.)
Het volgende demonstreert een aantal opdrachten. Merk op dat ik gebruik
maak van de parameter -q om een welkomstbericht te voorkomen.
<P>
<BLOCKQUOTE><CODE>
<PRE>
   $bc -q
        
</PRE>
</CODE></BLOCKQUOTE>
<P> <I>1 == 5</I>
<P> <I>0</I>
<P> <I>0.05 == 0.05</I>
<P> <I>1</I>
<P> <I>5 != 5</I>
<P> <I>0</I>
<P> <I>2 ^ 8</I>
<P> <I>256</I>
<P> <I>sqrt(9)</I>
<P> <I>3</I>
<P> <I>while (i != 9) {</I>
<P> <I>i = i + 1;</I>
<P> <I>print i</I>
<P> <I>}</I>
<P> <I>123456789</I>
<P> <I>quit</I>
<P><B>tput</B> (initialiseer een terminal of ondervraag een terminfo database)
<P> Een kleine demonstratie van de mogelijkheden van tput:
<BLOCKQUOTE><CODE>
<PRE>
        $tput cup 10 4
        
</PRE>
</CODE></BLOCKQUOTE>
<P> De prompt verschijnt op (y10,x4).
<BLOCKQUOTE><CODE>
<PRE>
        $tput reset
        
</PRE>
</CODE></BLOCKQUOTE>
<P> Maak het scherm schoon en de prompt verschijnt op (y1,x1). 
Merk op dat (y0,x0) de linkerbovenhoek is.
<BLOCKQUOTE><CODE>
<PRE>
        $tput cols
        
</PRE>
</CODE></BLOCKQUOTE>

<I>80</I>
<P> Toont het aantal mogelijke tekens in richting x.
<P> Het is zeer aan te bevelen (op z'n minst) met deze programma's bekend
te zijn. Er zijn heel veel van deze kleine programma's die je echte
magie op de opdrachtregel laten doen.
<P> [een aantal voorbeelden zijn overgenomen uit de man pages of FAQ's]
<H2><A NAME="s12">12. Meer Scripts</A></H2>

<H2>12.1      Een opdracht toepassen voor alle bestanden in een directory.     </H2>

<H2>12.2      Voorbeeld: Een zeer eenvoudig backupscript (iets beter)     </H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
            #!/bin/bash          
            SRCD="/home/"
            TGTD="/var/backups/"
            OF=home-$(date +%Y%m%d).tgz
            tar -cZf $TGTD$OF $SRCD
           
</PRE>
</CODE></BLOCKQUOTE>
 
<H2>12.3      Bestandshernoemer</H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
          
             #!/bin/sh
             # renna: hernoem meerdere bestanden op basis van verscheidene
             # regels geschreven door felix hudson jan - 2000
             
             # controleer dit bestand eerst op de diverse 'modes'
             # als de eerste ($1) voorwaarde overeenkomt dan voeren we dat
             # deel van het programma uit en stoppen
             
             # controleer op de prefix voorwaarde
             if [ $1 = p ]; then
             
             # nu ontdoen we ons van de mode ($1) variabele en prefix ($2)
               prefix=$2 ; shift ; shift
             
             # een snelle controle of er bestanden werden opgegeven
             # als dit niet zo is dan kunnen we maar beter niets doen dan een
             # een aantal niet bestaande bestanden te hernoemen!!
             
               if [$1 = ]; then
                  echo "geen bestanden opgegeven"
                  exit 0
               fi
             
             # deze for loop verwerkt alle bestanden die we aan het programma
             # opgaven
             # het hernoemt per opgegeven naam
               for file in $*
                 do
                 mv ${file} $prefix$file
               done
             
             # we verlaten nu het programma
               exit 0
             fi
             
             # controle op het hernoemen van een suffix
             # de rest van dit gedeelte is vrijwel gelijk aan de vorige sectie
             # kijk alsjeblieft in die notities
             if [ $1 = s ]; then
               suffix=$2 ; shift ; shift
             
                if [$1 = ]; then
                 echo "geen bestanden opgegeven"
                exit 0
                fi
             
              for file in $*
               do
                mv ${file} $file$suffix
              done
             
              exit 0
             fi
             
             # controleer op de replacement hernoeming
             if [ $1 = r ]; then
             
               shift
             
             # ik nam deze op uit voorzorg dat er geen bestanden beschadigd
             # raken als de gebruiker niets opgeeft
             # slechts een veiligheidsmaatregel
             
               if [ $# -lt 3 ] ; then
                 echo "usage: renna r [expression] [replacement] files... "
                 exit 0
               fi
             
             # verwijder andere informatie
               OLD=$1 ; NEW=$2 ; shift ; shift
             
             # deze for loop verwerkt alle bestanden die we aan het programma
             # opgaven, het hernoemt &eacute;&eacute;n bestand tegelijkertijd
             # door gebruik te maken van het programma 'sed'
             # dit is een eenvoudig opdrachtregelprogramma dat standaardinvoer
             # verwerkt en een expressie vervangt door een opgegeven string
             # hier geven we het de bestandsnaam door (als standaardinvoer) en
             # vervangen de nodige tekst
             
               for file in $*
               do
                 new=`echo ${file} | sed s/${OLD}/${NEW}/g`
                 mv ${file} $new
               done
             exit 0
             fi
             
             # als we hier zijn aangekomen dat wil dat zeggen dat niets
             # zinnigs aan het programma werd doorgegeven, dus vertellen
             # we de gebruiker hoe het te gebruiken
             echo "Gebruik;"
             echo " renna p [prefix] files.."
             echo " renna s [suffix] files.."
             echo " renna r [expression] [replacement] files.."
             exit 0
             
             # done!
             
          
</PRE>
</CODE></BLOCKQUOTE>
<H2>12.4      Bestandshernoemer (eenvoudig)</H2>

<P>
<BLOCKQUOTE><CODE>
<PRE>
     #!/bin/bash
     # renames.sh
     # basis bestandshernoemer

     criteria=$1
     re_match=$2
     replace=$3
     
     for i in $( ls *$criteria* ); 
     do
         src=$i
         tgt=$(echo $i | sed -e "s/$re_match/$replace/")
         mv $src $tgt
     done
     
</PRE>
</CODE></BLOCKQUOTE>
<H2><A NAME="s13">13. Wanneer er iets niet goed gaat (debuggen)</A></H2>

<H2>13.1      Manieren om BASH aan te roepen</H2>

<P>Aardig om te doen is het volgende op de eerste regel toe te voegen
<BLOCKQUOTE><CODE>
<PRE>
          #!/bin/bash -x
          
</PRE>
</CODE></BLOCKQUOTE>
<P>Hierdoor zal wat interessante uitvoer worden geproduceerd
<H2><A NAME="s14">14. Over het document</A></H2>

<P>Geef me gerust je aanbevelingen/correcties, of wat je dan ook 
interessant vindt om in dit document terug te vinden. Ik zal het
zo spoedig mogelijk bijwerken.
<H2>14.1 (geen) garantie</H2>

<P>Dit document wordt zonder enige garantie geleverd.
<H2>14.2 Vertalingen</H2>

<P> Italiaans: door William Ghelfi (wizzy at tiscalinet.it) 
<A HREF="http://web.tiscalinet.it/penguin_rules">is hier</A><P> Frans: door Laurent Martelli 
<A HREF="http://">ontbreekt</A><P> 
Koreaans: Minseok Park 
<A HREF="http://kldp.org">http://kldp.org</A><P> 
Koreaans: Chun Hye Jin 
<A HREF="">unknown</A><P> Spaans: onbekend 
<A HREF="http://www.insflug.org">http://www.insflug.org</A><P> Ik denk dat er meer vertalingen zijn, maar heb daar geen informatie
over, mail het alsjeblieft naar me als je hier informatie over hebt, zodat
ik deze sectie kan bijwerken.
<H2>14.3 Met dank aan</H2>

<P>
<UL>
<LI>Mensen die dit document naar andere talen vertaalde (vorige
sectie).</LI>
<LI> Nathan Hurst voor het opsturen van heel wat correcties.</LI>
<LI> Jon Abbott voor het opsturen van opmerkingen over het
berekenen van de waarde van rekenkundige expressies.</LI>
<LI> Felix Hudson voor het schrijven van het <I>renna</I>
script</LI>
<LI>Kees van den Broek (voor het opsturen van de vele correcties,
het herschrijven van de sectie handige opdrachten)</LI>
<LI>Mike (pink) deed een aantal suggesties betreft het lokaliseren
van bash en het testen van bestanden</LI>
<LI>Fiesh deed een aardige suggestie over de sectie loops</LI>
<LI>Lion raadde aan melding te maken van een gebruikelijke
foutmelding (./hello.sh: Command not found).</LI>
<LI>Andreas Beck voor verscheidene correcties en opmerkingen</LI>
</UL>
<H2>14.4 Historie</H2>

<P> Nieuwe vertalingen opgenomen en kleine correcties aangebracht.
<P> De sectie handige opdrachten herschreven door Kees.
<P> Meer correcties en suggesties opgenomen.
<P> Voorbeelden toegevoegd over het vergelijken van strings.
<P> v0.8 de versie gedropt, ik denk dat de datum voldoende is.
<P> v0.7 Meer correcties en een aantal oude TO-DO secties geschreven.
<P> v0.6 Kleine correcties.
<P> v0.5 De sectie over omleiding toegevoegd.
<P> v0.4 verdween van zijn lokatie vanwegen mijn ex-baas en dit
document vond een nieuwe plaats op de juiste url: www.linuxdoc.org.
<P> voorgaand: Ik weet het niet meer en maakte geen gebruik van rcs of
cvs :(
<H2>14.5 Meer bronnen</H2>

<P> Introductie bash (onder BE)
<A HREF="http://org.laol.net/lamug/beforever/bashtut.htm">http://org.laol.net/lamug/beforever/bashtut.htm</A><P> Bourne Shell Programming 
http://207.213.123.70/book/ 
</BODY>
</HTML>
