<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<!--Converted with LaTeX2HTML 96.1-h (September 30, 1996) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<HTML>
<HEAD>
<TITLE>3 Linux Tutorial</TITLE>
<META NAME="description" CONTENT="3 Linux Tutorial">
<META NAME="keywords" CONTENT="gs">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<LINK REL=STYLESHEET HREF="gs.css">
</HEAD>
<BODY LANG="EN" >
 <A NAME="tex2html846" HREF="node6.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="next_motif.gif"></A> <A NAME="tex2html844" HREF="gs.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="up_motif.gif"></A> <A NAME="tex2html838" HREF="node4.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="previous_motif.gif"></A> <A NAME="tex2html848" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="contents_motif.gif"></A>  <BR>
<B> Next:</B> <A NAME="tex2html847" HREF="node6.html">4 System Administration</A>
<B>Up:</B> <A NAME="tex2html845" HREF="gs.html">Linux Installation and Getting </A>
<B> Previous:</B> <A NAME="tex2html839" HREF="node4.html">2 Obtaining and Installing </A>
<BR> <P>
<H1><A NAME="SECTION00500000000000000000">3 Linux Tutorial</A></H1>
<A NAME="chaptutorial">&#160;</A>
<A NAME="chaptutorialnum">&#160;</A>
<P>
<H1><A NAME="SECTION00510000000000000000">3.1 Introduction.</A></H1>
<P>
If you're new to UNIX and Linux, you may be a bit intimidated by the size and
apparent complexity of the system before you. 
This chapter does not go into great detail or cover
advanced topics. Instead, we want you to hit the ground running.
<P>
We assume very little here about your background, except perhaps 
that you have some familiarity with 
personal computer systems, and MS-DOS. However, even if you're not an MS-DOS
user, you should be able to understand everything here. At first glance,
Linux looks a lot like MS-DOS--after all, parts of MS-DOS were modeled on 
the CP/M operating system, which in turn was modeled on UNIX. However, 
only the most superficial features of Linux resemble MS-DOS. 
Even if you're completely new to the PC world, this tutorial should help.
<P>
And, before we begin: <EM>Don't be afraid to experiment.</EM> The system
won't bite you. You can't destroy anything by working on the system. 
Linux has built-in security features to prevent ``normal'' users
from damaging files that are
essential to the system. Even so, the worst thing that can
happen is that you may delete some or all of your files 
and you'll have to
re-install the system. So, at this point, you have nothing
to lose.
<P>
<H1><A NAME="SECTION00520000000000000000">3.2 Basic Linux concepts.</A></H1>
<P>
<A NAME="2333">&#160;</A>
<A NAME="2334">&#160;</A>
<A NAME="2335">&#160;</A>
<A NAME="2336">&#160;</A>
<A NAME="2337">&#160;</A>
<A NAME="2338">&#160;</A>
Linux is a multitasking, multiuser operating system, which means that
many people can run many different applications on one computer at
the same time. This differs from MS-DOS, where only one
person can use the system at any one time. Under Linux,
to identify yourself to the system, you must <B>log in</B>, which 
entails entering your <B>login name</B> (the name the system uses to identify you), and entering your <B>password</B>, which 
is your personal key for logging in to your account. Because only
you know your password, no one else can log in to the system under your
user name.
<P>
On traditional UNIX systems, the system administrator assigns you
a user name and an initial password when you are given an account on the
system. However, because in Linux tt you are the system administrator,
you must set up your own account before you can log in.
For the following discussions, 
we'll use the imaginary user name, ``<TT>larry</TT>.''
<P>
<A NAME="2344">&#160;</A>
In addition, each system has a <B>host name</B> assigned to it.
It is this host name that gives your machine a name, gives it character
and charm. The host name is used to identify individual machines on 
a network, but even if your machine isn't networked, it should have a
host name. For our examples below, the system's host name is
``<TT>mousehouse</TT>''.
<P>
<H2><A NAME="SECTION00521000000000000000">3.2.1 Creating an account.</A></H2>
<P>
<A NAME="seccreateaccount">&#160;</A>
<A NAME="2349">&#160;</A>
<A NAME="2350">&#160;</A>
Before you can use a newly installed Linux system, you must set up a
user account for yourself. It's usually not a good idea to use the
<TT>root</TT> account for normal use; you should reserve the  <TT>root</TT>
account for running privileged commands and for maintaining the system
as discussed below.
<P>
In order to create an account for yourself, log in as
<TT>root</TT> and use the <TT>useradd</TT> or <TT>adduser</TT> command. See
Section&nbsp;<A HREF="node6.html#secadduser">4.6</A> for information on this procedure.
<P>
<H2><A NAME="SECTION00522000000000000000">3.2.2 Logging in.</A></H2>
<P>
<A NAME="2358">&#160;</A>
<A NAME="2359">&#160;</A> At login time, you'll see a prompt resembling
the following:
<P>
<BR><IMG WIDTH=142 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen2360" SRC="img113.gif"><BR>
<P>
Enter your user name and press the Enter key. Our
hero, <TT>larry</TT>, would type:
<P>
<BR><IMG WIDTH=206 HEIGHT=31 ALIGN=BOTTOM ALT="tscreen2364" SRC="img114.gif"><BR>
<P>
Next, enter your password. The characters you enter won't be echoed to the screen,
so type carefully. If you mistype your password, you'll see
the message
<BR><IMG WIDTH=126 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen2366" SRC="img115.gif"><BR>
and you'll have to try again.
<P>
Once you have correctly entered the user name and password, you are
officially logged in to the system, and are free to roam.
<P>
<H2><A NAME="SECTION00523000000000000000">3.2.3 Virtual consoles.</A></H2>
<P>
<A NAME="2369">&#160;</A>
<A NAME="2370">&#160;</A>
The system's <B>console</B> is the monitor and keyboard connected directly
to the system. (Because Linux is a multiuser operating system, you may
have other terminals connected to serial ports on your system, but these
would not be the console.) Linux, like some other versions of UNIX, provides
access to <B>virtual consoles</B> (or VCs), that let you have more than 
one login session on the console at one time.
<P>
To demonstrate this, log in to your system. Next,
press Alt-F2. You should see the <TT>login:</TT> prompt again. You're
looking at the second virtual console. To
switch back to the first VC, press Alt-F1. <EM>Voila!</EM> You're
back to your first <TT>login</TT> session.
<P>
A newly-installed Linux system probably lets you to access only the
first half-dozen or so VCs, by pressing Alt-F1 through
Alt-F4, or however many VCs are configured on your system. 
It is possible to enable up to 12 VCs--one for each function key on
your keyboard. As you can see, use of VCs can be very powerful
because you can work in several different sessions at the same time.
<P>
While the use of VCs is somewhat limiting (after all, you can 
look at only one VC at a time), it should give you a feel for the
multiuser capabilities of Linux. While you're working on the first VC, you
can switch over to the second VC and work on something else.
<P>
<H2><A NAME="SECTION00524000000000000000">3.2.4 Shells and commands.</A></H2>
<P>
<A NAME="secshellscmds">&#160;</A>
<A NAME="2382">&#160;</A>
For most of your explorations in the world of Linux, you'll be talking
to the system through a <B>shell</B>, a program that takes the commands
you type and translates them into instructions to the operating
system.  This can be compared to the <TT>COMMAND.COM</TT> program under
MS-DOS, which does essentially the same thing. A shell is just one
interface to Linux. There are many possible interfaces--like the
X&nbsp;Window System, which lets you run commands by using the mouse and
keyboard.
<P>
As soon as you log in, the system starts the shell, and you can begin entering
commands. Here's a quick example. Larry logs in and is
waiting at the shell <B>prompt</B>.
<BR><IMG WIDTH=233 HEIGHT=99 ALIGN=BOTTOM ALT="tscreen2386" SRC="img116.gif"><BR>
<A NAME="2388">&#160;</A>
The last line of this text is the shell's prompt, indicating that it's
ready to take commands. (More on what the prompt itself means later.) 
Let's try telling the system to do something interesting:
<P>
<BR><IMG WIDTH=400 HEIGHT=56 ALIGN=BOTTOM ALT="tscreen2389" SRC="img117.gif"><BR>
<P>
Well, as it turns out, <TT>make</TT> is the name of an actual program
on the system, and the shell executed this program when given the command. 
(Unfortunately, the system was being unfriendly.)
<P>
<A NAME="2392">&#160;</A>
<A NAME="2393">&#160;</A>
<A NAME="2394">&#160;</A>
This brings us to the burning question: What is a command? What 
happens when you type ``<TT>make love</TT>''? The first word on the command 
line, ``<TT>make</TT>'', is the name of the command to be executed. Everything
else on the command line is taken as arguments to this command. Example:
<BR><IMG WIDTH=195 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen2397" SRC="img118.gif"><BR>
The name of this command is ``<TT>cp</TT>'', and the arguments are
``<TT>foo</TT>'' and ``<TT>bar</TT>''.
<P>
When you enter a command, the shell does several things. First, it
checks the command to see if it
is internal to the shell. (That is, a command which the shell knows how
to execute itself. There are a number of these commands, and we'll go
into them later.) The shell also checks to see if the command is an 
alias, or substitute name, for another command. If neither of these conditions
apply, the shell looks for a program, on disk, having the specified name.
If successful, the shell runs the program, sending the
arguments specified on the command line.
<P>
In our example, the shell looks for a program called <TT>make</TT>, and 
runs it with the argument <TT>love</TT>. <TT>Make</TT> is a program often used 
to compile large programs, and takes as arguments the name of a 
``target'' to compile. In the case of ``<TT>make love</TT>'', we instructed
<TT>make</TT> to compile the target <TT>love</TT>. Because <TT>make</TT> can't
find a target by this name, it fails with a humorous error message, and
returns us to the shell prompt.
<P>
<A NAME="2536">&#160;</A>
<A NAME="2537">&#160;</A>
What happens if we type a command to a shell and the shell can't
find a program having the specified name? Well, we can try the following:
<BR><IMG WIDTH=197 HEIGHT=56 ALIGN=BOTTOM ALT="tscreen2411" SRC="img119.gif"><BR>
Quite simply, if the shell can't find a program having the name given
on the command line (here, ``<TT>eat</TT>''), it prints an error message.
You'll often see this error message
if you mistype a command (for example, if you had typed ``<TT>mkae love</TT>''
instead of ``<TT>make love</TT>'').
<P>
<H2><A NAME="SECTION00525000000000000000">3.2.5 Logging out.</A></H2>
<P>
<A NAME="2538">&#160;</A>
<A NAME="2539">&#160;</A>
Before we delve much further, we should tell you how to log out of the
system. At the shell prompt, use the command
<BR><IMG WIDTH=143 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen2419" SRC="img120.gif"><BR>
to log out. There are other ways of logging out, but this
is the most foolproof one.
<P>
<H2><A NAME="SECTION00526000000000000000">3.2.6 Changing your password.</A></H2>
<P>
<A NAME="2540">&#160;</A>
<A NAME="2541">&#160;</A>
You should also know how to change your password. The command
<TT>passwd</TT> prompts you for your old password, and a new password.
It also asks you to reenter the new password for validation. Be careful
not to forget your password--if you do, you will have to ask the
system administrator to reset it for you. (If you are the system 
administrator, see page&nbsp;<A HREF="node6.html#secmanageusers"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>.)
<P>
<H2><A NAME="SECTION00527000000000000000">3.2.7 Files and directories.</A></H2>
<P>
<A NAME="2427">&#160;</A>
Under most operating systems (including Linux), there is the concept of a 
<B>file</B>, which is just a bundle of information given a 
name (called a <B>filename</B>). Examples of files might be your
history term paper, an e-mail message, or an actual program that can be
executed. Essentially, anything saved on disk is saved in 
an individual file.
<P>
<A NAME="2430">&#160;</A>
Files are identified by their file names. For example, the file
containing your history paper might be saved with the file name <TT>
history-paper</TT>.  These names usually identify the file and its
contents in some form that is meaningful to you. There is no standard
format for file names as there is under MS-DOS and some other
operating systems; in general, a file name can contain any character
(except the <TT>/</TT> character--see the discussion of path names,
below) and is limited to 256 characters in length.
<P>
<A NAME="2433">&#160;</A>
With the concept of files comes the concept of directories. A <B>
directory</B> is a collection of files. It can be thought of as a
``folder'' that contains many different files. Directories are given
names, with which you can identify them.  Furthermore, directories are
maintained in a tree-like structure; that is, directories may contain
other directories.
<P>
<A NAME="2435">&#160;</A>
Consequently, you can refer to a file by its <B>path name</B>, which is
made up of the filename, preceded by the name of the directory
containing the file.  For example, let's say that Larry has a
directory called <TT>papers</TT>, which contains three files: <TT>
history-final</TT>, <TT>english-lit</TT>, and <TT>masters-thesis</TT>. Each of
these three files contains information for three of Larry's ongoing
projects. To refer to the <TT>english-lit</TT> file, Larry can specify
the file's pathname, as in:
<BR><IMG WIDTH=153 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen2442" SRC="img121.gif"><BR>
<P>
<A NAME="2542">&#160;</A>
As you can see, the directory and filename are separated by a single
slash (<TT>/</TT>). For this reason, filenames themselves cannot contain the
<TT>/</TT> character.  MS-DOS users will find this convention familiar, 
although in the MS-DOS world the backslash (<code>\</code>) is used instead.
<P>
<A NAME="2447">&#160;</A>
As mentioned, directories can be nested within each other as well. For
example, let's say that there is another directory within <TT>
papers</TT>, called <TT>notes</TT>. The <TT>notes</TT> directory contains the
files <TT>math-notes</TT> and <TT>cheat-sheet</TT>. The pathname of the file
<TT>cheat-sheet</TT> would be
<BR><IMG WIDTH=205 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen2454" SRC="img122.gif"><BR>
<P>
<A NAME="2456">&#160;</A>
<A NAME="2457">&#160;</A>
Therefore, a path name is really like a path to the file. The
directory that contains a given subdirectory is known as the <B>
parent directory</B>. Here, the directory <TT>papers</TT> is the parent of
the <TT>notes</TT> directory.
<P>
<H2><A NAME="SECTION00528000000000000000">3.2.8 The directory tree.</A></H2>
<P>
<A NAME="2462">&#160;</A>
<A NAME="2463">&#160;</A>
<A NAME="2464">&#160;</A>
<A NAME="2465">&#160;</A>
<A NAME="2543">&#160;</A>
<A NAME="2467">&#160;</A>
Most Linux systems use a standard layout for files so that system
resources and programs can be easily located. This layout forms a 
directory tree, which starts at the ``<TT>/</TT>'' directory, also known
as the ``root directory''. Directly underneath <TT>/</TT> are important
subdirectories: <TT>/bin</TT>, <TT>/etc</TT>, <TT>/dev</TT>, and <TT>/usr</TT>,
among others. These directories in turn contain other directories which
contain system configuration files, programs, and so on.
<P>
<A NAME="2474">&#160;</A>
<A NAME="2475">&#160;</A>
In particular, each user has a <B>home directory</B>, which is the
directory set aside for that user to store his or her files. In the
examples above, all of Larry's files (like <TT>cheat-sheet</TT> and <TT>
history-final</TT>) are contained in Larry's home directory. Usually, user
home directories are contained under <TT>/home</TT>, and are named for
the user owning that directory. Larry's home directory is <TT>
/home/larry</TT>.
<P>

The diagram on page&nbsp;<A HREF="node5.html#dirtree"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A> shows a sample directory tree,
which should give you an idea of how the directory tree on your system
is organized.
<P>
=1.0pt
<P><A NAME="2485">&#160;</A><A NAME="dirtree">&#160;</A><IMG WIDTH=255 HEIGHT=368 ALIGN=BOTTOM ALT="figure2482" SRC="img123.gif"><BR>
<STRONG>Figure 3.1:</STRONG> A typical (abridged) Linux directory tree.<BR>
<P>  
<H2><A NAME="SECTION00529000000000000000">3.2.9 The current working directory.</A></H2>
<P>
<A NAME="2488">&#160;</A>
<A NAME="2489">&#160;</A>
<A NAME="2490">&#160;</A>
<A NAME="2491">&#160;</A>
At any moment, commands that you enter are assumed to be relative to
your <B>current working directory</B>. You can think of your working
directory as the directory in which you are currently ``located''.
When you first log in, your working directory is set to your home
directory--<TT>/home/larry</TT>, in our case. Whenever you refer to a
file, you may refer to it in relationship to your current working
directory, rather than specifying the full pathname of the file.
<P>
Here's an example. Larry has the directory <TT>papers</TT>, and
<TT>papers</TT> contains the file 
<TT>history-final</TT>. If Larry wants to look at this file, he can use
the command
<BR><IMG WIDTH=427 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen2497" SRC="img124.gif"><BR>
The <TT>more</TT> command simply displays a file, one screen at a time.
However, because Larry's current working directory is <TT>/home/larry</TT>,
he can instead refer to the file <EM>relative</EM> to his current
location by using the command 
<BR><IMG WIDTH=323 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen2502" SRC="img125.gif"><BR>
<A NAME="2504">&#160;</A>
If you begin a filename (like <TT>papers/final</TT>) with a character
other than <TT>/</TT>, you're referring to the file in terms relative to
your current working directory.  This is known as a <B>relative
path name</B>.
<P>
<A NAME="2508">&#160;</A>
<A NAME="2509">&#160;</A>
On the other hand, if you begin a file name with a <TT>/</TT>, the system
interprets this as a full path name--that is, a path name that
includes the entire path to the file, starting from the root
directory, <TT>/</TT>.  This is known as an <B>absolute path name</B>.
<P>
<H2><A NAME="SECTION005210000000000000000">3.2.10 Referring to home directories.</A></H2>
<P>
<A NAME="2554">&#160;</A>
<A NAME="2555">&#160;</A>
<A NAME="2556">&#160;</A>
Under both <TT>tcsh</TT> and <TT>bash</TT><A NAME="tex2html124" HREF="footnode.html#2548"><IMG  ALIGN=BOTTOM ALT="gif" SRC="foot_motif.gif"></A>
you can specify your home directory with
the tilde character (<TT>~</TT>). For example, the command
<BR><IMG WIDTH=341 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen2525" SRC="img126.gif"><BR>
is equivalent to
<BR><IMG WIDTH=427 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen2497" SRC="img124.gif"><BR>
The shell replaces the <TT>~</TT> character with the name of your 
home directory.
<P>
You can also specify other user's home directories with the
tilde character. The pathname <TT>~karl/letters</TT> translates to
<TT>/home/karl/letters</TT> by the shell (if <TT>/home/karl</TT> is
karl's home directory). Using a tilde is simply a shortcut;
there is no directory named <TT>~</TT>--it's just syntactic sugar
provided by the shell.
<P>
<A NAME="2535">&#160;</A>
<P>
<H1><A NAME="SECTION00530000000000000000">3.3 First steps into Linux.</A></H1>
<P>
Before we begin, it is important to know that all file and command names
on a Linux system are case-sensitive (unlike operating systems such as MS-DOS).
For example, the command <TT>make</TT> is very different from <TT>Make</TT> or
<TT>MAKE</TT>. The same is true for file and directory names.
<P>
<H2><A NAME="SECTION00531000000000000000">3.3.1 Moving around.</A></H2>
<P>
Now that you can log in, and you know how to refer to files using pathnames,
how can you change your current working directory, to make life easier?
<P>
<A NAME="2730">&#160;</A>
<A NAME="2731">&#160;</A>
The command for moving around in the directory structure is
<TT>cd</TT>, which is short for ``change directory''. 
Many often-used Linux commands are two or three letters.
The usage of the <TT>cd</TT> command is 
<BR><IMG WIDTH=77 HEIGHT=13 ALIGN=BOTTOM ALT="tscreen2568" SRC="img127.gif"><BR>
where <i>directory</i> is the name of the directory which you wish
to become the current working directory.
<P>
As mentioned earlier, when you log in, you begin in your home directory. If
Larry wanted to switch to the <TT>papers</TT> subdirectory, he'd
use the command
<BR><IMG WIDTH=186 HEIGHT=34 ALIGN=BOTTOM ALT="tscreen2573" SRC="img128.gif"><BR>
As you can see, Larry's prompt changes to reflect his current working
directory (so he knows where he is). Now that he's in the <TT>papers</TT>
directory, he can look at his history final with the command
<BR><IMG WIDTH=323 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen2576" SRC="img129.gif"><BR>
<P>
<A NAME="2732">&#160;</A>
<A NAME="2733">&#160;</A>
<A NAME="2734">&#160;</A>
Now, Larry is stuck in the <TT>papers</TT> subdirectory. To move back
up to the next higher (or parent) directory, use the command
<BR><IMG WIDTH=218 HEIGHT=34 ALIGN=BOTTOM ALT="tscreen2582" SRC="img130.gif"><BR>
(Note the space between the ``<TT>cd</TT>'' and the ``<TT>..</TT>''.) 
Every directory has an entry named ``<TT>..</TT>'' which refers to
the parent directory. Similarly, every directory has an entry
named ``<TT>.</TT>'' which refers to itself. Therefore, the command
<BR><IMG WIDTH=209 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen2588" SRC="img131.gif"><BR>
gets us nowhere.
<P>
You can also use absolute pathnames with the <TT>cd</TT> command.
To <TT>cd</TT> into Karl's home directory, we can use the command
<BR><IMG WIDTH=280 HEIGHT=31 ALIGN=BOTTOM ALT="tscreen2592" SRC="img132.gif"><BR>
<P>
Also, using <TT>cd</TT> with no argument will return you to your own
home directory.
<BR><IMG WIDTH=118 HEIGHT=34 ALIGN=BOTTOM ALT="tscreen2595" SRC="img133.gif"><BR>
<A NAME="2735">&#160;</A>
<P>
<H2><A NAME="SECTION00532000000000000000">3.3.2 Looking at the contents of directories.</A></H2>
<P>
<A NAME="secls">&#160;</A>
<A NAME="2600">&#160;</A>
<A NAME="2736">&#160;</A>
<A NAME="2602">&#160;</A>
<A NAME="2603">&#160;</A>
Now that you know how to move around directories, you might think,
``So what?''  Moving around directories is fairly
useless by itself, so let's introduce a new command, <TT>ls</TT>. The <TT>ls</TT> command 
displays a listing of files and directories, by default from your current
directory. For example:
<P>
<BR><IMG WIDTH=127 HEIGHT=99 ALIGN=BOTTOM ALT="tscreen2606" SRC="img134.gif"><BR>
<P>
Here we can see that Larry has three entries in his current 
directory: <TT>Mail</TT>, <TT>letters</TT>, and <TT>papers</TT>. This
doesn't tell us much--are these directories or files? We can use the 
<TT>-F</TT> option of the <TT>ls</TT> command to get more detailed information.
<P>
<BR><IMG WIDTH=162 HEIGHT=99 ALIGN=BOTTOM ALT="tscreen2613" SRC="img135.gif"><BR>
From the <TT>/</TT> appended to each filename, we know that these three
entries are in fact subdirectories.
<P>
<A NAME="2616">&#160;</A>
<A NAME="2617">&#160;</A>
Using <TT>ls -F</TT> may also append ``<TT>*</TT>'' to the end of a filename
in the resulting list
which would indicate that the file is an <B>executable</B>, or a program which
can be run. If nothing is appended to the filename using <TT>ls -F</TT>, the
file is a ``plain old file'', that is, it's neither a directory nor an
executable.
<P>
In general, each UNIX command may take a number of options in addition
to other arguments. These options usually begin with a ``<TT>-</TT>'',
as demonstrated above with the <TT>-F</TT> option. The <TT>-F</TT> option tells <TT>ls</TT>
to give more information about the type of the files involved--in 
this case, printing a <TT>/</TT> after each directory name.
<P>
If you give <TT>ls</TT> a directory name, the system will print the contents of
that directory.
<BR><IMG WIDTH=222 HEIGHT=121 ALIGN=BOTTOM ALT="tscreen2628" SRC="img136.gif"><BR>
<P>
Or, for a more interesting listing, let's see what's in the
system's <TT>/etc</TT> directory.
<P>
<BR><IMG WIDTH=671 HEIGHT=291 ALIGN=BOTTOM ALT="tscreen2631" SRC="img137.gif"><BR>
<P>
If you're a MS-DOS user,
you may notice that the filenames can be longer than 8 characters, and can
contain periods in any position. You can even use more than one
period in a filename.
<P>
Let's move to the top of the directory tree, 
and then down to another directory with the commands
<P>
<BR><IMG WIDTH=149 HEIGHT=96 ALIGN=BOTTOM ALT="tscreen2633" SRC="img138.gif"><BR>
You can also move into directories in one step, as in <TT>cd /usr/bin</TT>.
<P>
Try moving around various directories, using <TT>ls</TT> and <TT>cd</TT>.
In some cases, you may run into the foreboding ``<TT>Permission denied</TT>''
error message. This is simply UNIX security kicking in:
in order to use the <TT>ls</TT> or <TT>cd</TT> commands, you must have
permission to do so. We talk more about this starting on 
 <A NAME="2641">&#160;</A>
 <A NAME="2737">&#160;</A>
 <A NAME="2643">&#160;</A>
 <A NAME="2644">&#160;</A>
page&nbsp;<A HREF="node5.html#secfileperms"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>.
<P>
<H2><A NAME="SECTION00533000000000000000">3.3.3 Creating new directories.</A></H2>
<P>
<A NAME="2647">&#160;</A>
<A NAME="2738">&#160;</A>
It's time to learn how to create directories. This involves the use
of the <TT>mkdir</TT> command. Try the following:
<P>
<BR><IMG WIDTH=188 HEIGHT=186 ALIGN=BOTTOM ALT="tscreen2650" SRC="img139.gif"><BR>
<P>
Congratulations!  You made a new directory and moved into it.  Since
there aren't any files in this new directory, let's learn how to copy
files from one place to another.
<P>
<H2><A NAME="SECTION00534000000000000000">3.3.4 Copying files.</A></H2>
<P>
<A NAME="2653">&#160;</A>
<A NAME="2654">&#160;</A>
<A NAME="2739">&#160;</A>
To copy files, use the command <TT>cp</TT>, as shown here:
<P>
<BR><IMG WIDTH=297 HEIGHT=164 ALIGN=BOTTOM ALT="tscreen2657" SRC="img140.gif"><BR>
<P>
The <TT>cp</TT> command copies the files listed on the command line to the
file or directory given as the last argument. Notice that we use
``<TT>.</TT>'' to refer to the current directory.
<P>
<H2><A NAME="SECTION00535000000000000000">3.3.5 Moving files.</A></H2>
<P>
<A NAME="2662">&#160;</A>
<A NAME="2663">&#160;</A>
<A NAME="2740">&#160;</A>
The <TT>mv</TT> command moves files, rather than copying them.
The syntax is very straightforward:
<P>
<BR><IMG WIDTH=282 HEIGHT=77 ALIGN=BOTTOM ALT="tscreen2666" SRC="img141.gif"><BR>
<P>
Notice that the <TT>termcap</TT> file has been renamed 
<TT>sells</TT>. You can also use the <TT>mv</TT> command to move a file to a 
completely new directory.
<P>
<B>Note:</B> <TT>mv</TT> and <TT>cp</TT> will overwrite 
a destination file having the same name without asking you. Be careful 
when you move a 
file into another directory. There may already be a file having the same 
name in that directory, which you'll overwrite!
<P>
<H2><A NAME="SECTION00536000000000000000">3.3.6 Deleting files and directories.</A></H2>
<P>
<A NAME="2675">&#160;</A>
<A NAME="2676">&#160;</A>
<A NAME="2741">&#160;</A>
You now have an ugly rhyme developing with the use of the <TT>ls</TT> command.
To delete a file, use the <TT>rm</TT> command, which stands for
``remove'', as shown here:
<P>
<BR><IMG WIDTH=264 HEIGHT=77 ALIGN=BOTTOM ALT="tscreen2680" SRC="img142.gif"><BR>
<P>
We're left with nothing but shells, but we won't complain. Note that
<TT>rm</TT> by default won't prompt you before deleting a file--so be
careful.
<P>
<A NAME="2683">&#160;</A>
<A NAME="2684">&#160;</A>
<A NAME="2742">&#160;</A>
A related command to <TT>rm</TT> is <TT>rmdir</TT>. This command deletes
a directory, but only if the directory is empty. If the directory
contains any files or subdirectories, <TT>rmdir</TT> will complain.
<P>
<H2><A NAME="SECTION00537000000000000000">3.3.7 Looking at files.</A></H2>
<P>
<A NAME="2690">&#160;</A>
<A NAME="2743">&#160;</A>
<A NAME="2744">&#160;</A>
The commands <TT>more</TT> and <TT>cat</TT> are used for viewing the
contents of files. <TT>more</TT> displays a file, one screenful at a
time, while <TT>cat</TT> displays the whole file at once.
<P>
To look at the file <TT>shells</TT>, use the command
<BR><IMG WIDTH=237 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen2698" SRC="img143.gif"><BR>
<P>
In case you're interested what <TT>shells</TT> contains, it's a list
of valid shell programs on your system. On most systems, this includes
<TT>/bin/sh</TT>, <TT>/bin/bash</TT>, and <TT>/bin/csh</TT>. We'll talk about
these different types of shells later.
<P>
While using <TT>more</TT>, press Space to display the next page
of text, and b to display the previous page. There are other
commands available in <TT>more</TT> as well, these are just the basics.
Pressing q will quit <TT>more</TT>.
<P>
Quit <TT>more</TT> and try <TT>cat /etc/termcap</TT>. The text will probably fly
by too quickly for you to read it all. 
The name ``<TT>cat</TT>'' actually stands for ``concatenate'', which is the
real use of the program. The <TT>cat</TT> command can be used to concatenate
the contents of several files and save the result to another file.
This will be again in section &nbsp;<A HREF="node5.html#secshellscript">3.14.1</A>.
<P>
<H2><A NAME="SECTION00538000000000000000">3.3.8 Getting online help.</A></H2>
<P>
<A NAME="2716">&#160;</A>
<A NAME="2717">&#160;</A>
<A NAME="2718">&#160;</A>
Almost every UNIX system, including Linux, provides a facility known
as <B>manual pages</B>. These manual pages contain online documentation
for system commands, resources, configuration files and so on.
<P>
<A NAME="2745">&#160;</A>
The command used to access manual pages is <TT>man</TT>. If you're
interested in learning about other options of the <TT>ls</TT> command,
you can type
<BR><IMG WIDTH=160 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen2723" SRC="img144.gif"><BR>
and the manual page for <TT>ls</TT> will be displayed.
<P>
Unfortunately, most manual pages are written for those
who already have some idea of what the command or resource does. For
this reason, manual pages usually contain only the technical 
details of the command, without much explanation. However, manual pages 
can be an invaluable resource for jogging your memory if you forget
the syntax of a command. Manual pages will also tell you about
commands that we don't cover in this book.
<P>
I suggest that you try <TT>man</TT> for the commands that we've already
gone over and whenever I introduce a new command. Some of these
commands won't have manual pages, for several reasons.  First, the
manual pages may not have been written yet. (The Linux Documentation
Project is responsible for manual pages under Linux as well. We are
gradually accumulating most of the manual pages available for the
system.) Second, the the command might be an internal shell command,
or an alias (discussed on page&nbsp;<A HREF="node5.html#secshellscmds"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>), which would
not have a manual page of its own. One example is <TT>cd</TT>, which is
an internal shell command. The shell itself actually processes the
<TT>cd</TT>--there is no separate program that implements this command.
<P>
<H1><A NAME="SECTION00540000000000000000">Accessing MS-DOS files.</A></H1>
<P>
<A NAME="secmsdosmount">&#160;</A>
<A NAME="2750">&#160;</A>
<A NAME="2751">&#160;</A>
If, for some twisted and bizarre reason, you want to access files from
MS-DOS, it's easily done under Linux.
<P>
<A NAME="2752">&#160;</A>
<A NAME="2780">&#160;</A>
The usual way to access MS-DOS files is to mount an MS-DOS partition or
floppy under Linux, allowing you to access the files directly through the
file system. For example, if you have an MS-DOS floppy in 
<TT>/dev/fd0</TT>, the command
<BR><IMG WIDTH=255 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen2755" SRC="img145.gif"><BR>
will mount it under <TT>/mnt</TT>. See Section&nbsp;<A HREF="node6.html#secfloppy">4.8.4</A> for more
information on mounting floppies.
<P>
You can also mount an MS-DOS partition of your hard drive for access
under Linux. If you have an MS-DOS partition on <TT>/dev/hda1</TT>, the
command
<BR><IMG WIDTH=264 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen2760" SRC="img146.gif"><BR>
mounts it. Be sure to <TT>umount</TT> the partition when you're done
using it. You can have a MS-DOS partition automatically mounted at
boot time if you include the entry in <TT>/etc/fstab</TT>. See
Section&nbsp;<A HREF="node6.html#secmanagefs">4.4</A> for details. The following line in <TT>
/etc/fstab</TT> will mount an MS-DOS partition on <TT>/dev/hda1</TT> on the
directory <TT>/dos</TT>.
<BR><IMG WIDTH=357 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen2768" SRC="img147.gif"><BR>
<P>
You can also mount the VFAT file systems that are used by Windows 95:
<BR><IMG WIDTH=255 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen2770" SRC="img148.gif"><BR>
This allows access to the long filenames of Windows 95. This only
applies to partitions that actually have the long filenames
stored. You can't mount a normal FAT16 file system and use this to get
long filenames.
<P>
<A NAME="2772">&#160;</A>
The Mtools software may also be used to access MS-DOS files.  The
commands <TT>mcd</TT>, <TT>mdir</TT>, and <TT>mcopy</TT> all behave like their
MS-DOS counterparts. If you install Mtools, there should be manual
pages available for these commands.
<P>
 <A NAME="2776">&#160;</A>
 <A NAME="2777">&#160;</A>
 <A NAME="2778">&#160;</A> 
Accessing MS-DOS files is one thing; running MS-DOS programs is
another. There is an MS-DOS Emulator under development for Linux; it
is widely available, and included in most distributions. It can also
be retrieved from a number of locations, including the various Linux
FTP sites listed in Appendix&nbsp;<A HREF="app-ftp/node1.html">B</A>. The MS-DOS Emulator is
reportedly powerful enough to run a number of applications, including
WordPerfect, from Linux. However, Linux and MS-DOS are vastly
different operating systems. The power of any MS-DOS emulator under
UNIX is limited.  In addition, a Microsoft Windows emulator that runs
under X&nbsp;Windows is under development.
<P>
<H1><A NAME="SECTION00550000000000000000">3.5 Summary of basic UNIX commands.</A></H1>
<A NAME="seccommandsumm">&#160;</A>
<P>
<A NAME="2785">&#160;</A>
This section introduces some of the most useful basic commands of a UNIX
system, including those that are covered in the previous section.
<P>
<A NAME="2891">&#160;</A>
<A NAME="2892">&#160;</A>
Note that options usually begin with ``<TT>-</TT>'', and in most cases 
you can specify more than one 
option with a single ``<TT>-</TT>''. For example,
rather than use the command <TT>ls -l -F</TT>, you can use
<TT>ls -lF</TT>.
<P>
Rather than listing every option for each command, we only present
useful or important commands at this time.  In fact, most of these
commands have many options that you'll never use. You can use <TT>
man</TT> to see the manual pages for each command, which list all of the
available options.
<P>
Also note that many of these commands take as arguments a list of files or directories,
denoted in this table by ``<i>file1</i> ...<i>fileN</i>''. For
example, the <TT>cp</TT> command takes as arguments a list of files to copy,
followed by the destination file or directory. When copying more than one
file, the destination must be a directory.
<P>
<BR><IMG WIDTH=576 HEIGHT=900 ALIGN=BOTTOM ALT="dispitems2796" SRC="img149.gif"><BR>
<P>
<A NAME="2890">&#160;</A>
<P>
<H1><A NAME="SECTION00560000000000000000">3.6 Exploring the file system.</A></H1>
<A NAME="secfilesystemtour">&#160;</A>
<P>
<A NAME="2933">&#160;</A>
A <B>file system</B> is the collection of files and the hierarchy of
directories on a system. The time has now come to escort you around the 
file system.
<P>

You now have the skills and the knowledge to understand the Linux file
system, and you have a roadmap. (Refer to diagram on
page&nbsp;<A HREF="node5.html#dirtree"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>).  
<P>
First, change to the root directory (<TT>cd /</TT>), and then enter <TT>
ls -F</TT> to display a listing of its contents.  You'll probably see the
following directories<A NAME="tex2html176" HREF="footnode.html#2938"><IMG  ALIGN=BOTTOM ALT="gif" SRC="foot_motif.gif"></A>:
<TT>bin</TT>, <TT>dev</TT>, <TT>etc</TT>, <TT>home</TT>, <TT>install</TT>, <TT>lib</TT>,
<TT>mnt</TT>, <TT>proc</TT>, <TT>root</TT>, <TT>tmp</TT>, <TT>user</TT>, <TT>usr</TT>,
and <TT>var</TT>.
<P>
Now, let's take a look at each of these directories.
<P>
<BR><IMG WIDTH=573 HEIGHT=900 ALIGN=BOTTOM ALT="dispitems2952" SRC="img150.gif"><BR>
<P>
The various directories described above are essential for the system
to operate, but most of the items found in <TT>/usr</TT> are optional.
However, it is these optional items that make the system useful and
interesting. Without <TT>/usr</TT>, you'd have a boring system that
supports only programs like <TT>cp</TT> and <TT>ls</TT>.  <TT>/usr</TT>
contains most of the larger software packages and the configuration
files that accompany them.
<P>
<BR><IMG WIDTH=574 HEIGHT=899 ALIGN=BOTTOM ALT="dispitems3097" SRC="img151.gif"><BR>
<A NAME="3172">&#160;</A>
<P>
<H1><A NAME="SECTION00570000000000000000">3.7 Types of shells.</A></H1>
<P>
<A NAME="3262">&#160;</A>
As mentioned before, Linux is a multitasking, multiuser operating
system.  Multitasking is <EM>very</EM> useful, and once you understand
it, you'll use it all of the time. Before long, you'll run programs in
the background, switch between tasks, and pipeline programs together
to achieve complicated results with a single command.
<P>
Many of the features we'll cover in this section are features
provided by the shell itself. Be careful not to confuse Linux
(the actual operating system) with a shell--a shell is just an
interface to the underlying system. The shell provides 
functionality inaddition to Linux itself.
<P>
<A NAME="3264">&#160;</A>
A shell is not only an interpreter for the interactive commands you
type at the prompt, but also a powerful programming language.  It lets
you to write <B>shell scripts</B>, to ``batch'' several shell commands
together in a file. If you know MS-DOS you'll recognize the similarity
to ``batch files''.  Shell scripts are a very powerful tool, that will
let you automate and expand your use of Linux. See
page&nbsp;<A HREF="node5.html#secshellscript"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A> for more information.
<P>
<A NAME="3267">&#160;</A>
<A NAME="3268">&#160;</A>
<A NAME="3269">&#160;</A>
<A NAME="3295">&#160;</A>
<A NAME="3296">&#160;</A>
<A NAME="3297">&#160;</A>
There are several types of shells in the Linux world. The two major
types are the ``Bourne shell'' and the ``C shell''. The Bourne shell
uses a command syntax like the original shell on early UNIX systems,
like System III. The name of the Bourne shell on most Linux systems is
<TT>/bin/sh</TT> (where <TT>sh</TT> stands for ``shell''). The C shell (not
to be confused with sea shell) uses a different syntax, somewhat like
the programming language C, and on most Linux systems is named <TT>
/bin/csh</TT>.
<P>
<A NAME="3276">&#160;</A>
<A NAME="3277">&#160;</A>
<A NAME="3298">&#160;</A>
<A NAME="3299">&#160;</A>
<A NAME="3280">&#160;</A>
<A NAME="3300">&#160;</A>
<A NAME="3301">&#160;</A>
Under Linux, several variations of these shells are available.  The
two most commonly used are the Bourne Again Shell, or ``Bash'' (<TT>
/bin/bash</TT>), and ``Tcsh'' (<TT>/bin/tcsh</TT>). <TT>bash</TT> is a form of
the Bourne shell that includes many of the advanced features found in
the C shell. Because <TT>bash</TT> supports a superset of the Bourne
shell syntax, shell scripts written in the standard Bourne shell
should work with <TT>bash</TT>.  If you prefer to use the C shell syntax,
Linux supports <TT>tcsh</TT>, which is an expanded version of the
original C shell.
<P>
The type of shell you decide to use is mostly a religious issue.  Some
folks prefer the Bourne shell syntax with the advanced features of
<TT>bash</TT>, and some prefer the more structured C shell syntax. As far
as normal commands such as <TT>cp</TT> and <TT>ls</TT> are concerned, the
shell you use doesn't matter--the syntax is the same.  Only when you
start to write shell scripts or use advanced features of a shell do
the differences between shell types begin to matter.
<P>
As we discuss the features of the various shells, we'll note
differences between Bourne and C shells. However, for the purposes of
this manual most of those differences are minimal.  (If you're really
curious at this point, read the man pages for <TT>bash</TT> and <TT>
tcsh</TT>).
<P>
<A NAME="3294">&#160;</A>
<P>
<H1><A NAME="SECTION00580000000000000000">3.8 Wildcards.</A></H1>
<P>
<A NAME="3305">&#160;</A>
<A NAME="3306">&#160;</A>
<A NAME="3307">&#160;</A>
<A NAME="3308">&#160;</A>
A key feature of most Linux shells is the ability to refer to more than
one file by name using special characters. These <B>wildcards</B> let
you refer to, say, all file names that contain the character ``<TT>
n</TT>''.
<P>
<A NAME="3402">&#160;</A>
<A NAME="3403">&#160;</A>
The wildcard ``<TT>*</TT>'' specifies any character or string of
characters in a file name. When you use the character ``<TT>*</TT>'' in a
file name, the shell replaces it with all possible substitutions from
file names in the directory you're referencing.
<P>
Here's a quick example. Suppose that Larry has the files <TT>frog</TT>,
<TT>joe</TT>, and <TT>stuff</TT> in his current directory.
<BR><IMG WIDTH=188 HEIGHT=56 ALIGN=BOTTOM ALT="tscreen3318" SRC="img152.gif"><BR>
<P>
To specify all files containing the letter ``o'' in the filename, use
the command
<BR><IMG WIDTH=160 HEIGHT=56 ALIGN=BOTTOM ALT="tscreen3320" SRC="img153.gif"><BR>
As you can see, each instance of ``<TT>*</TT>'' is replaced with
all substitutions that match the wildcard from filenames in the
current directory.
<P>
The use of ``<TT>*</TT>'' by itself simply matches all filenames, because
all characters match the wildcard.
<BR><IMG WIDTH=188 HEIGHT=56 ALIGN=BOTTOM ALT="tscreen3324" SRC="img154.gif"><BR>
<P>
Here are a few more examples:
<BR><IMG WIDTH=161 HEIGHT=186 ALIGN=BOTTOM ALT="tscreen3326" SRC="img155.gif"><BR>
<P>
<A NAME="3328">&#160;</A>
<A NAME="3329">&#160;</A>
The process of changing a ``<TT>*</TT>'' into a series of filenames is called <B>wildcard 
expansion</B> and is done by the shell. This is
important: an individual command, such as <TT>ls</TT>, <EM>never</EM> sees
the ``<TT>*</TT>'' in its list of parameters. The shell expands the
wildcard to include all filenames that match. So, the command
<BR><IMG WIDTH=160 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen3335" SRC="img156.gif"><BR>
is expanded by the shell to 
<BR><IMG WIDTH=203 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen3337" SRC="img157.gif"><BR>
<P>
<A NAME="3339">&#160;</A>
One important note about the ``<TT>*</TT>'' wildcard: it does <EM>not</EM>
match file names that begin with a single period (``<TT>.</TT>'').  These
files are treated as <B>hidden</B> files--while they are not really
hidden, they don't show up on normal <TT>ls</TT> listings and aren't
touched by the use of the ``<TT>*</TT>'' wildcard.
<P>
Here's an example. We mentioned earlier that each directory contains two
special entries: ``<TT>.</TT>'' refers to the current directory,
and ``<TT>..</TT>'' refers to the parent directory. However, when you use
<TT>ls</TT>, these two entries don't show up.
<BR><IMG WIDTH=188 HEIGHT=56 ALIGN=BOTTOM ALT="tscreen3318" SRC="img152.gif"><BR>
If you use the <TT>-a</TT> switch with <TT>ls</TT>, however, you can display
filenames that begin with ``<TT>.</TT>''. Observe:
<BR><IMG WIDTH=476 HEIGHT=77 ALIGN=BOTTOM ALT="tscreen3354" SRC="img158.gif"><BR>
The listing contains the two special entries, ``<TT>.</TT>'' and ``<TT>
..</TT>'', as well as two other ``hidden'' files--<TT>.bash_profile</TT>
and <TT>.bashrc</TT>. These two files are startup files used by <TT>
bash</TT> when <TT>larry</TT> logs in.  They are described starting on
page&nbsp;<A HREF="node5.html#secinitscripts"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>.
<P>
Note that when you use the ``<TT>*</TT>'' wildcard, none of the filenames
beginning with ``<TT>.</TT>'' are displayed.
<BR><IMG WIDTH=188 HEIGHT=56 ALIGN=BOTTOM ALT="tscreen3324" SRC="img154.gif"><BR>
This is a safety feature: if the ``<TT>*</TT>'' wildcard matched filenames
beginning with ``<TT>.</TT>'', it would also match the directory names
``<TT>.</TT>'' and ``<TT>..</TT>''. This can be dangerous when using certain
commands.
<P>
<A NAME="3404">&#160;</A>
<A NAME="3405">&#160;</A>
Another wildcard is ``<TT>?</TT>''.  The ``<TT>?</TT>'' wildcard expands to
only a single character. Thus, ``<TT>ls ?</TT>'' displays all
one-character filenames.  And ``<TT>ls termca?</TT>'' would display
``<TT>termcap</TT>'' but <EM>not</EM> ``<TT>termcap.backup</TT>''.  Here's
another example:
<BR><IMG WIDTH=179 HEIGHT=143 ALIGN=BOTTOM ALT="tscreen3380" SRC="img159.gif"><BR>
<P>
As you can see, wildcards lets you specify many files at one time.  In
the command summary that starts on page&nbsp;<A HREF="node5.html#seccommandsumm"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>, we
said that the <TT>cp</TT> and <TT>mv</TT> commands actually can copy or move
more than one file at a time. For example,
<BR><IMG WIDTH=299 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen3385" SRC="img160.gif"><BR>
copies all filenames in <TT>/etc</TT> beginning with ``<TT>s</TT>'' to the
directory <TT>/home/larry</TT>. The format of the <TT>cp</TT> command is
really
<BR><IMG WIDTH=119 HEIGHT=13 ALIGN=BOTTOM ALT="tscreen3391" SRC="img161.gif"><BR>
where <i>files</i> lists the filenames to
copy, and <i>destination</i> is the destination file or directory.
<TT>mv</TT> has an identical syntax.
<P>
If you are copying or moving more than one file, the
<i>destination</i> must be a directory. You can only copy or move
a single file to another file.
<P>
<A NAME="3399">&#160;</A>
<A NAME="3400">&#160;</A>
<A NAME="3401">&#160;</A>
<P>
<H1><A NAME="SECTION00590000000000000000">3.9 Linux plumbing.</A></H1>
 <A NAME="secplumbing">&#160;</A>
<P>
<H2><A NAME="SECTION00591000000000000000">3.9.1 Standard input and standard output.</A></H2>
<P>
<A NAME="3411">&#160;</A>
<A NAME="3412">&#160;</A>
<A NAME="3413">&#160;</A>
<A NAME="3414">&#160;</A>
Many Linux commands get input from what is called <B>standard input</B>
and send their output to <B>standard output</B> (often abbreviated as
<TT>stdin</TT> and <TT>stdout</TT>). Your shell sets things up so that
standard input is your keyboard, and standard output is the screen.
<P>
Here's an example using the <TT>cat</TT> command. Normally, <TT>cat</TT> reads data 
from all of the files specified by the command line, and sends this data 
directly to <TT>stdout</TT>. Therefore, using the command
<BR><IMG WIDTH=444 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen3422" SRC="img162.gif"><BR>
displays the contents of the file <TT>history-final</TT> followed by
<TT>masters-thesis</TT>.
<P>
However, if you don't specify a filename, <TT>cat</TT> reads data from
<TT>stdin</TT> and sends it back to <TT>stdout</TT>. Here's an example:
<BR><IMG WIDTH=196 HEIGHT=143 ALIGN=BOTTOM ALT="tscreen3429" SRC="img163.gif"><BR>
<A NAME="3432">&#160;</A>
<A NAME="3433">&#160;</A>
Each line that you type is immediately echoed back by <TT>cat</TT>. When
reading from standard input, you indicate the input is ``finished'' by
sending an EOT (end-of-text) signal, in general, generated by pressing
Ctrl-D.
<P>
Here's another example. The <TT>sort</TT> command reads lines of
text (again, from stdin, unless you specify one or more filenames)
and sends the sorted output to stdout. Try the following.
<BR><IMG WIDTH=205 HEIGHT=186 ALIGN=BOTTOM ALT="tscreen3437" SRC="img164.gif"><BR>
Now we can alphabetize our shopping list... isn't Linux useful?
<P>
<H2><A NAME="SECTION00592000000000000000">3.9.2 Redirecting input and output.</A></H2>
<P>
<A NAME="3441">&#160;</A>
<A NAME="3442">&#160;</A>
<A NAME="3443">&#160;</A>
<A NAME="3444">&#160;</A>
<A NAME="3536">&#160;</A>
Now, let's say that you want to send the output of <TT>sort</TT> to a
file, to save our shopping list on disk. The shell lets you
<B>redirect</B> standard output to a filename, by using the ``<TT>&gt;</TT>''
symbol. Here's how it works:
<BR><IMG WIDTH=345 HEIGHT=121 ALIGN=BOTTOM ALT="tscreen3449" SRC="img165.gif"><BR>
As you can see, the result of the <TT>sort</TT> command isn't 
displayed, but is saved to the file named <TT>shopping-list</TT>. 
Let's look at this file:
<BR><IMG WIDTH=317 HEIGHT=99 ALIGN=BOTTOM ALT="tscreen3454" SRC="img166.gif"><BR>
Now you can sort your shopping list, and save it, too!
But let's suppose that you are storing the unsorted, original shopping
list in the file <TT>items</TT>. One way of sorting the information
and saving it to a file would be to give <TT>sort</TT> the name of the
file to read, in lieu of standard input, and redirect standard output
as we did above, as follows:
<BR><IMG WIDTH=396 HEIGHT=121 ALIGN=BOTTOM ALT="tscreen3458" SRC="img167.gif"><BR>
<A NAME="3460">&#160;</A>
<A NAME="3461">&#160;</A>
<A NAME="3537">&#160;</A>
However, there's another way to do this. Not only can you
redirect standard output, you can redirect standard <EM>input</EM>
as well, using the ``<TT>&lt;</TT>'' symbol.
<BR><IMG WIDTH=276 HEIGHT=99 ALIGN=BOTTOM ALT="tscreen3465" SRC="img168.gif"><BR>
Technically, <TT>sort &lt; items</TT> is equivalent to <TT>sort items</TT>, but
lets you demonstrate the following point: <TT>sort &lt; items</TT>
behaves as if the data in the file <TT>items</TT> was typed to
standard input. The shell handles the redirection. <TT>sort</TT> wasn't given 
the name of the file (<TT>items</TT>) to read; as far as <TT>sort</TT> is
concerned, it still reads from standard input as if you had typed
the data from your keyboard.
<P>
<A NAME="3474">&#160;</A>
This introduces the concept of a <B>filter</B>. A filter is a program
that reads data from standard input, processes it in some way, and
sends the processed data to standard output. Using redirection,
standard input and standard output can be referenced from files.  As
mentioned above, <TT>stdin</TT> and <TT>stdout</TT> default to the keyboard
and screen respectively.  <TT>sort</TT> is a simple filter.  It sorts the
incoming data and sends the result to standard output. <TT>cat</TT> is
even simpler. It doesn't do anything with the incoming data, it simply
outputs whatever is given to it.
<P>
<H2><A NAME="SECTION00593000000000000000">3.9.3 Using pipes.</A></H2>
<P>
<A NAME="3481">&#160;</A>
We already demonstrated how to use <TT>sort</TT> as a filter. However,
these examples assume that you have data stored in a file somewhere or
are willing to type the data from the standard input yourself. What if
the data that you wanted to sort came from the output of another
command, like <TT>ls</TT>?
<P>
The <TT>-r</TT> option to <TT>sort</TT> sorts the data in
reverse-alphabetical order. If you want to list the files in your
current directory in reverse order, one way to do it is
follows:
<BR><IMG WIDTH=187 HEIGHT=96 ALIGN=BOTTOM ALT="tscreen3486" SRC="img169.gif"><BR>
Now redirect the output of the <TT>ls</TT> command into a file called
<TT>file-list</TT>:
<BR><IMG WIDTH=317 HEIGHT=143 ALIGN=BOTTOM ALT="tscreen3490" SRC="img170.gif"><BR>
Here, you save the output of <TT>ls</TT> in a file, and then run
<TT>sort -r</TT> on that file. But this is unwieldy and 
uses a temporary file to save the data from <TT>ls</TT>.
<P>
<A NAME="3495">&#160;</A>
<A NAME="3496">&#160;</A>
The solution is <B>pipelining</B>. This is a shell feature that
connects a string of commands via a ``pipe.''  The <TT>stdout</TT> of the
first command is sent to the <TT>stdin</TT> of the second command.  In
this case, we want to send the <TT>stdout</TT> of <TT>ls</TT> to the <TT>
stdin</TT> of <TT>sort</TT>.  Use the ``<TT>|</TT>'' symbol to create a pipe, as
follows:
<BR><IMG WIDTH=269 HEIGHT=123 ALIGN=BOTTOM ALT="tscreen3505" SRC="img171.gif"><BR>
This command is shorter and easier to type.
<P>
Here's another useful example, the command
<BR><IMG WIDTH=264 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen3507" SRC="img172.gif"><BR>
displays a long list of files, most of which fly
past the screen too quickly for you to read. So, let's use
<TT>more</TT> to display the list of files in <TT>/usr/bin</TT>.
<BR><IMG WIDTH=319 HEIGHT=15 ALIGN=BOTTOM ALT="tscreen3511" SRC="img173.gif"><BR>
Now you can page down the list of files at your leisure.
<P>
But the fun doesn't stop here! You can pipe more than two commands together.
The command <TT>head</TT> is a filter that displays the first lines from
an input stream (in this case, input from a pipe). If you want to display
the last filename in alphabetical order in the current directory, 
use commands like the following:
<BR><IMG WIDTH=349 HEIGHT=58 ALIGN=BOTTOM ALT="tscreen3514" SRC="img174.gif"><BR>
where <TT>head -1</TT> displays the first line of input that it
receives (in this case, the stream of reverse-sorted data from <TT>ls</TT>). 
<A NAME="3518">&#160;</A>
<P>
<H2><A NAME="SECTION00594000000000000000">Non-destructive redirection of output.</A></H2>
<P>
<A NAME="3520">&#160;</A>
<A NAME="3521">&#160;</A>
Using ``<TT>&gt;</TT>'' to redirect output to a file is destructive: in other
words, the command
<BR><IMG WIDTH=291 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen3523" SRC="img175.gif"><BR>
overwrites the contents of the file <TT>file-list</TT>. If instead, you
redirect with the symbol ``<TT>&gt;&gt;</TT>'', the output is appended to
(added to the end of) the named file instead of overwriting it.  For 
example,
<BR><IMG WIDTH=303 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen3527" SRC="img176.gif"><BR>
appends the output of the <TT>ls</TT> command to <TT>file-list</TT>.
<P>
Keep in mind that redirection and pipes are features of the
shell--which supports the use of ``<TT>&gt;</TT>'', ``<TT>&gt;&gt;</TT>'' and ``<TT>
|</TT>''. It has nothing to do with the commands themselves.
<P>
<A NAME="3534">&#160;</A>
<A NAME="3535">&#160;</A>
<P>
<H1><A NAME="SECTION005100000000000000000">3.10 File permissions.</A></H1>
<P>
<A NAME="secfileperms">&#160;</A><A NAME="secperms">&#160;</A>
<P>
<A NAME="3543">&#160;</A>
<A NAME="3544">&#160;</A>
<H2><A NAME="SECTION005101000000000000000">3.10.1 Concepts of file permissions.</A></H2>
<P>
<A NAME="3546">&#160;</A>
<A NAME="3547">&#160;</A>
<A NAME="3548">&#160;</A>
Because there is typically more than one user on a Linux system, Linux
provides a mechanism known as <B>file permissions</B>, which protect
user files from tampering by other users.  This mechanism lets files
and directories be ``owned'' by a particular user. For example,
because Larry created the files in his home directory, Larry owns
those files and has access to them.
<P>
Linux also lets files be shared between users and groups of users.  If
Larry desired, he could cut off access to his files so that no other
user could access them. However, on most systems the default is to
allow other users to read your files but not modify or delete them in
any way.
<P>
<A NAME="3550">&#160;</A>
Every file is owned by a particular user.  However, files are also
owned by a particular <B>group</B>, which is a defined group of users
of the system. Every user is placed into at least one group when that
user's account is created. However, the system administrator may grant
the user access to more than one group.
<P>
<A NAME="3552">&#160;</A>
<A NAME="3553">&#160;</A>
Groups are usually defined by the type of users who access the
machine.  For example, on a university Linux system users may be placed
into the groups <TT>student</TT>, <TT>staff</TT>, <TT>faculty</TT> or <TT>
guest</TT>. There are also a few system-defined groups (like <TT>bin</TT> and
<TT>admin</TT>) which are used by the system itself to control access to
resources--very rarely do actual users belong to these system groups.
<P>
Permissions fall into three main divisions: read, write, and execute.
These permissions may be granted to three classes of users: the owner
of the file, the group to which the file belongs, and to all users, 
regardless of group.
<P>
<A NAME="3560">&#160;</A>
<A NAME="3561">&#160;</A>
<A NAME="3562">&#160;</A>
<A NAME="3563">&#160;</A>
<A NAME="3564">&#160;</A>
<A NAME="3565">&#160;</A>
<A NAME="3566">&#160;</A>
<A NAME="3567">&#160;</A>
<A NAME="3568">&#160;</A>
Read permission lets a user read the contents of the file, or in the
case of directories, list the contents of the directory (using <TT>
ls</TT>). Write permission lets the user write to and modify the file. For
directories, write permission lets the user create new files or delete
files within that directory. Finally, execute permission lets the user
run the file as a program or shell script (if the file is a program or
shell script).  For directories, having execute permission lets the
user <TT>cd</TT> into the directory in question.
<P>
<H2><A NAME="SECTION005102000000000000000">3.10.2 Interpreting file permissions.</A></H2>
<P>
<A NAME="3572">&#160;</A>
<A NAME="3573">&#160;</A>
<A NAME="3654">&#160;</A>
<A NAME="3655">&#160;</A>
Let's look at an example that demonstrates file permissions. Using the
<TT>ls</TT> command with the <TT>-l</TT> option displays a ``long''
listing of the file, including file permissions. 
<BR><IMG WIDTH=514 HEIGHT=92 ALIGN=BOTTOM ALT="tscreen3578" SRC="img177.gif"><BR>
<P>
The first field in the listing represents the file permissions.
The third field is the owner of the file (<TT>larry</TT>) and the fourth
field is the group to which the file belongs (<TT>users</TT>). Obviously,
the last field is the name of the file (<TT>stuff</TT>). We'll cover the
other fields later.
<P>
This file is owned by <TT>larry</TT>, and belongs to the group <TT>users</TT>.
The string <TT>-rw-r-r-</TT> lists,
in order, the permissions granted to the file's owner, the file's group,
and everybody else.
<P>
The first character of the permissions string (``<TT>-</TT>'') represents the
type of file. A ``<TT>-</TT>'' means that this is a regular file (as
opposed to a directory or device driver). The next three characters 
(``<TT>rw-</TT>'') represent the permissions granted to the file's owner,
<TT>larry</TT>. The ``<TT>r</TT>'' stands for ``read'' and the ``<TT>w</TT>''
stands for ``write''. Thus, <TT>larry</TT> has read and write permission
to the file <TT>stuff</TT>.
<P>
As mentioned, besides read and write permission, there is also
``execute'' permission--represented by an ``<TT>x</TT>''. However, 
a ``<TT>-</TT>'' is listed here in place of an ``<TT>x</TT>'', so Larry doesn't
have execute permission on this file. This is fine, as the file <TT>stuff</TT>
isn't a program of any kind. Of course, because Larry owns the file,
he may grant himself execute permission for the file if he so desires.
(This will be covered shortly.)
<P>
The next three characters, (``<TT>r-</TT>''), represent the group's permissions
on the file. The group that owns this file is <TT>users</TT>. Because
only an ``<TT>r</TT>'' appears here, any user who belongs to the group
<TT>users</TT> may read this file.
<P>
The last three characters, also (``<TT>r-</TT>''), represent the permissions
granted to every other user on the system (other than the owner of the
file and those in the group <TT>users</TT>). Again, because only an
``<TT>r</TT>'' is present, other users may read the file, but not write to
it or execute it.
<P>
Here are some other examples of permissions:
<BR><IMG WIDTH=574 HEIGHT=130 ALIGN=BOTTOM ALT="dispitems3605" SRC="img178.gif"><BR><H2><A NAME="SECTION005103000000000000000">3.10.3 Permissions Dependencies.</A></H2>
<P>
<A NAME="3611">&#160;</A>
<A NAME="3612">&#160;</A>
<A NAME="3613">&#160;</A>
The permissions granted to a file also
depend on the permissions of the directory in which the file is located.
For example, even if a file is set to <TT>-rwxrwxrwx</TT>, other users cannot
access the file unless they have read and execute access to the directory 
in which the file is located. For example, if Larry wanted to 
restrict access to all of his files, he could set the permissions
to his home directory <TT>/home/larry</TT> to <TT>-rwx---</TT>. In this
way, no other user has access to his directory, and all
files and directories within it. Larry doesn't need to worry about the
individual permissions on each of his files.
<P>
In other words, to access a file at all, you must have execute
access to all directories along the file's pathname, and read 
(or execute) access to the file itself.
<P>
Typically, users on a Linux system are very open with their files. 
The usual set of permissions given to files is <TT>-rw-r-r-</TT>, which 
lets other users read the file but not change it in any way.
The usual set of permissions given to directories is <TT>-rwxr-xr-x</TT>, which
lets other users look through your directories, but not 
create or delete files within them.
<P>
However, many users wish to keep other users out of their files. 
Setting the permissions of a file to <TT>-rw----</TT> will prevent
any other user from accessing the file. Likewise, setting the permissions of
a directory to <TT>-rwx---</TT> keeps other users out of the 
directory in question.
<P>
<H2><A NAME="SECTION005104000000000000000">3.10.4 Changing permissions.</A></H2>
<P>
<A NAME="3622">&#160;</A>
<A NAME="3623">&#160;</A>
<A NAME="3624">&#160;</A>
<A NAME="3659">&#160;</A>
The command <TT>chmod</TT> is used to set the permissions on a file. Only
the owner of a file may change the permissions on that file.
The syntax of <TT>chmod</TT> is
<BR><IMG WIDTH=287 HEIGHT=15 ALIGN=BOTTOM ALT="tscreen3628" SRC="img179.gif"><BR>
<P>
Briefly, you supply one or more of
<B>a</B>ll, <B>u</B>ser, <B>g</B>roup, or <B>o</B>ther. Then you specify 
whether you are adding rights (<TT>+</TT>) or taking them away (<TT>-</TT>).
Finally, you specify one or more of
<B>r</B>ead, <B>w</B>rite, and e<B>x</B>ecute. Some examples of legal
commands are:
<P>
<BR><IMG WIDTH=574 HEIGHT=289 ALIGN=BOTTOM ALT="dispitems3640" SRC="img180.gif"><BR>
<P>
<A NAME="3652">&#160;</A>
<A NAME="3653">&#160;</A>
<P>
<H1><A NAME="SECTION005110000000000000000">3.11 Managing file links.</A></H1>
<A NAME="secmanagelinks">&#160;</A>
<P>
<A NAME="3669">&#160;</A>
<A NAME="3670">&#160;</A>
<A NAME="3671">&#160;</A>
<A NAME="3672">&#160;</A>
Links let you give a single file more than one name. Files are
actually identified by the system by their <B>inode number</B>, which is
just the unique file system identifier for the file.
A directory is actually
a listing of inode numbers with their corresponding filenames. Each 
filename in a directory is a <B>link</B> to a particular inode.
<P>
<H2><A NAME="SECTION005111000000000000000">3.11.1 Hard links.</A></H2>
<P>
<A NAME="3676">&#160;</A>
The <TT>ln</TT> command is used to create multiple links for one
file. For example, let's say that you have a file called <TT>foo</TT> in 
a directory. Using <TT>ls -i</TT>, you can look at the inode number
for this file.
<BR><IMG WIDTH=187 HEIGHT=56 ALIGN=BOTTOM ALT="tscreen3680" SRC="img181.gif"><BR>
Here, <TT>foo</TT> has an inode number of 22192 in the
file system. You can create another link to <TT>foo</TT>, named <TT>bar</TT>, as follows:
<BR><IMG WIDTH=195 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen3685" SRC="img182.gif"><BR>
With <TT>ls -i</TT>, you see that the two files have the same inode.
<BR><IMG WIDTH=221 HEIGHT=56 ALIGN=BOTTOM ALT="tscreen3688" SRC="img183.gif"><BR>
Now, specifying either <TT>foo</TT> or <TT>bar</TT> will access
the same file. If you make changes to <TT>foo</TT>, those changes
appear in <TT>bar</TT> as well. For all purposes, <TT>foo</TT>
and <TT>bar</TT> are the same file.
<P>
These links are known as <B>hard links</B> because they 
create a direct link to an inode. Note that you can hard-link files only when they're on
the same file system; symbolic links (see below) don't have this
restriction.
<P>
When you delete a file with <TT>rm</TT>, you are actually only 
deleting one link to a file. If you use the command
<BR><IMG WIDTH=161 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen3698" SRC="img184.gif"><BR>
then only the link named <TT>foo</TT> is deleted, <TT>bar</TT>
will still exist. A file is only truly deleted on the system
when it has no links to it. Usually, files have only one
link, so using the <TT>rm</TT> command deletes the file. However,
if a file has multiple links to it, using <TT>rm</TT> will delete only
a single link; in order to delete the file, you must
delete all links to the file.
<P>
<A NAME="3704">&#160;</A>
The command <TT>ls -l</TT> displays the number of links to a
file (among other information).
<BR><IMG WIDTH=489 HEIGHT=77 ALIGN=BOTTOM ALT="tscreen3706" SRC="img185.gif"><BR>
The second column in the listing, ``<TT>2</TT>'', specifies the number of
links to the file.
<P>
As it turns out, a directory is actually just a file containing information
about link-to-inode associations. Also, every directory contains at least two
hard links: ``<TT>.</TT>'' (a link pointing to itself), and 
``<TT>..</TT>'' (a link
pointing to the parent directory). The root directory (<TT>/</TT>) 
``<TT>..</TT>'' link
just points back to <TT>/</TT>.  (In other words, the parent of the root
directory is the root directory itself.)
<P>
<H2><A NAME="SECTION005112000000000000000">3.11.2 Symbolic links.</A></H2>
<P>
<A NAME="3715">&#160;</A>
Symbolic links, or <B>symlinks</B>, are another type of link, which are
different from hard links.  A symbolic link lets you give a
file another name, but doesn't link the file by inode.
<P>
The command <TT>ln -s</TT> creates a symbolic link to a file.
For example, if you use the command
<BR><IMG WIDTH=221 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen3718" SRC="img186.gif"><BR> 
you will create a symbolic link named <TT>bar</TT> that points to the file
<TT>foo</TT>. If you use <TT>ls -i</TT>, you'll see that the two
files have different inodes, indeed.
<BR><IMG WIDTH=179 HEIGHT=57 ALIGN=BOTTOM ALT="tscreen3723" SRC="img187.gif"><BR>
However, using <TT>ls -l</TT>, we see that the file <TT>bar</TT>
is a symlink pointing to <TT>foo</TT>.
<BR><IMG WIDTH=550 HEIGHT=77 ALIGN=BOTTOM ALT="tscreen3729" SRC="img188.gif"><BR>
<P>
The file permissions on a symbolic link are not used (they always
appear as <TT>rwxrwxrwx</TT>). Instead, the permissions on the symbolic link 
are determined by the permissions on the target of the symbolic link (in
our example, the file <TT>foo</TT>).
<P>
Functionally, hard links and symbolic links are similar, but
there are differences. For one thing,
you can create a symbolic link to a file that doesn't exist; the
same is not true for hard links. Symbolic links are processed by 
the kernel differently than are hard links, which is just a
technical difference but sometimes an important one. Symbolic links
are helpful because they identify the file they point to; with
hard links, there is no easy way to determine which files are linked
to the same inode.
<P>
Links are used in many places on the Linux system. Symbolic links are
especially important to the shared library images in <TT>/lib</TT>. See
page&nbsp;<A HREF="node6.html#secupgradelibs"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A> for more information.
<A NAME="3735">&#160;</A>
<A NAME="3736">&#160;</A>
<P>
<H1><A NAME="SECTION005120000000000000000">3.12 Job control.</A></H1>
<A NAME="secjobcontrol">&#160;</A>
<P>
<A NAME="3741">&#160;</A>
<H2><A NAME="SECTION005121000000000000000">3.12.1 Jobs and processes.</A></H2>
<P>
<A NAME="secprocess">&#160;</A><A NAME="secprocesses">&#160;</A>
<P>
<A NAME="3745">&#160;</A>
<B>Job control</B> is a feature provided by many shells (including <TT>
bash</TT> and <TT>tcsh</TT>) that let you control multiple running commands, or
<B>jobs</B>, at once. Before we can delve much further, we need to talk
about <B>processes</B>.
<P>
<A NAME="3751">&#160;</A>
<A NAME="3916">&#160;</A>
<A NAME="3917">&#160;</A>
Every time you run a program, you start what is called a process.
The command <TT>ps</TT> displays a list of currently running processes,
as shown here:
<BR><IMG WIDTH=229 HEIGHT=132 ALIGN=BOTTOM ALT="tscreen3755" SRC="img189.gif"><BR>
<A NAME="3757">&#160;</A>
The <TT>PID</TT> listed in the first column is the <B>process ID</B>,
a unique number given to every running process. The last column,
<TT>COMMAND</TT>, is the name of the running command. Here, we're looking
only
at the processes which Larry himself is currently running. (There are 
many other processes running on the system as well--``<TT>ps -aux</TT>''
lists them all.) These are <TT>bash</TT>
(Larry's shell), and the <TT>ps</TT> command itself. As you can see, 
<TT>bash</TT> is running concurrently with the <TT>ps</TT> command.
<TT>bash</TT> executed <TT>ps</TT> when Larry typed the command. After
<TT>ps</TT> has finished running (after the table of processes is displayed),
control is returned to the <TT>bash</TT> process, which displays the
prompt, ready for another command.
<P>
<A NAME="3770">&#160;</A>
A running process is also called a <EM>job</EM>. The terms
<EM>process</EM> and <EM>job</EM> are interchangeable. However, a process
is usually referred to as a ``job'' when used in conjunction with <B>
job control</B>--a feature of the shell that lets you switch between
several independent jobs.
<P>
In most cases users run only a single job at a time--whatever command
they last typed to the shell. However, using job control, you can run
several jobs at once, and switch between them as needed.
<P>
How might this be useful? Let's say you are editing a text file and
want to interrupt your editing and do something else. With job
control, you can temporarily suspend the editor, go back to the shell
prompt and start to work on something else. When you're done, you can
switch back to the editor and be back where you started, as if you
didn't leave the editor. There are many other practical uses of job
control.
<P>
<H2><A NAME="SECTION005122000000000000000">3.12.2 Foreground and background.</A></H2>
<P>
<A NAME="3776">&#160;</A>
<A NAME="3777">&#160;</A>
<A NAME="3778">&#160;</A>
<A NAME="3779">&#160;</A>
<A NAME="3780">&#160;</A>
<A NAME="3781">&#160;</A>
Jobs can either be in the <B>foreground</B> or in the <B>background</B>.
There can only be one job in the foreground at a time. The foreground
job is the job with which you interact--it receives input from the
keyboard and sends output to your screen, unless, of course, you have
redirected input or output, as described starting on
page&nbsp;<A HREF="node5.html#secplumbing"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>). On the other hand, jobs in the
background do not receive input from the terminal--in general, they
run along quietly without the need for interaction.
<P>
Some jobs take a long time to finish and don't do anything interesting
while they are running.  Compiling programs is one such job, as is
compressing a large file.  There's no reason why you should sit around
being bored while these jobs complete their tasks; just run them in
the background. While jobs run in the background, you are free to run
other programs.
<P>
<A NAME="3785">&#160;</A>
Jobs may also be <B>suspended</B>. A suspended job is a job that 
is temporarily stopped. After you
suspend a job, you can tell the job to continue in the foreground
or the background as needed. Resuming a suspended job does not change
the state of the job in any way--the job continues to run where
it left off.
<P>
<A NAME="3787">&#160;</A>
<A NAME="3788">&#160;</A>
Suspending a job is not equal to interrupting a job. When you <B>
interrupt</B> a running process (by pressing the interrupt key, which is
usually Ctrl-C)<A NAME="tex2html286" HREF="footnode.html#3918"><IMG  ALIGN=BOTTOM ALT="gif" SRC="foot_motif.gif"></A>, the process is killed, for good.  Once the job
is killed, there's no hope of resuming it. You'll must run the command
again. Also, some programs trap the interrupt, so that pressing
Ctrl-C won't immediately kill the job. This is to let the
program perform any necessary cleanup operations before exiting.  In
fact, some programs don't let you kill them with an interrupt at all.
<P>
<H2><A NAME="SECTION005123000000000000000">3.12.3 Backgrounding and killing jobs.</A></H2>
<P>
Let's begin with a simple example. The command <TT>yes</TT> is a
seemingly useless command that sends an endless stream of <TT>y</TT>'s to
standard output. (This is actually useful. If you piped the output of
<TT>yes</TT> to another command which asked a series of yes and no
questions, the stream of <TT>y</TT>'s would confirm all of the
questions.)
<P>
Try it out:
<BR><IMG WIDTH=135 HEIGHT=121 ALIGN=BOTTOM ALT="tscreen3798" SRC="img190.gif"><BR>
<A NAME="3800">&#160;</A>
<A NAME="3801">&#160;</A>
<A NAME="3802">&#160;</A>
<A NAME="3803">&#160;</A>
The <TT>y</TT>'s will continue <EM>ad infinitum</EM>. You can kill the
process by pressing the interrupt key, which is usually Ctrl-C.
So that we don't have to put up with the annoying stream of <TT>y</TT>'s,
let's redirect the standard output of <TT>yes</TT> to <TT>/dev/null</TT>. As
you may remember, <TT>/dev/null</TT> acts as a ``black hole'' for data.
Any data sent to it disappears. This is a very effective method of
quieting an otherwise verbose program.
<BR><IMG WIDTH=240 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen3811" SRC="img191.gif"><BR>
Ah, much better. Nothing is printed, but the shell prompt doesn't
come back. This is because <TT>yes</TT> is still running, and is sending
those inane <TT>y</TT>'s to <TT>/dev/null</TT>. Again, to kill the job,
press the interrupt key.
<P>
Let's suppose that you want the <TT>yes</TT> command to continue to
run but wanted to get the shell prompt back so that you can work on other things.
You can put <TT>yes</TT> into the background, allowing it to
run, without need for interaction.
<P>
<A NAME="3818">&#160;</A>
<A NAME="3819">&#160;</A>
One way to put a process in the background is to append an ``<TT>&amp;</TT>''
character to the end of the command. 
<BR><IMG WIDTH=257 HEIGHT=56 ALIGN=BOTTOM ALT="tscreen3821" SRC="img192.gif"><BR>
As you can see, the shell prompt has returned. But what is this 
``<TT><code>[1] 164</code></TT>''? And is the <TT>yes</TT> command really running?
<P>
The ``<TT><code>[1]</code></TT>'' represents the <B>job number</B> for the <TT>yes</TT>
process. The shell assigns a job number to every running job. Because
<TT>yes</TT> is the one and only job we're running, it
is assigned job number <TT>1</TT>. The ``<TT>164</TT>'' is the process ID, or
PID, number given by the system to the job. You can use either number to
refer to the job, as you'll see later.
<P>
<A NAME="3919">&#160;</A>
You now have the <TT>yes</TT> process running in the background, continuously
sending a stream of <TT>y</TT>'s to <TT>/dev/null</TT>. To check on the
status of this process, use the internal shell command <TT>jobs</TT>.
<BR><IMG WIDTH=401 HEIGHT=56 ALIGN=BOTTOM ALT="tscreen3836" SRC="img193.gif"><BR>
Sure enough, there it is. You could also use the <TT>ps</TT> command as 
demonstrated above to check on the status of the job.
<P>
<A NAME="3920">&#160;</A>
<A NAME="3840">&#160;</A>
<A NAME="3841">&#160;</A>
To terminate the job, use the <TT>kill</TT> command.
This command takes either a job number or a process ID number as an
argument. This was job number 1, so using the command
<BR><IMG WIDTH=168 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen3843" SRC="img194.gif"><BR>
kills the job. When identifying the job with the job number, you must
prefix the number with a percent (``<TT>%</TT>'') character.
<P>
Now that you've killed the job, use <TT>jobs</TT> again to check on it:
<BR><IMG WIDTH=374 HEIGHT=92 ALIGN=BOTTOM ALT="tscreen3847" SRC="img195.gif"><BR>
The job is in fact dead, and if you use the <TT>jobs</TT> command again
nothing should be printed.
<P>
You can also kill the job using the process ID (PID) number, 
displayed along with the job ID when you start the job. In our example,
the process ID is 164, so the command
<BR><IMG WIDTH=177 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen3850" SRC="img196.gif"><BR>
is equivalent to
<BR><IMG WIDTH=168 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen3843" SRC="img194.gif"><BR>
You don't need to use the ``<TT>%</TT>'' when referring to a job by its
process ID.
<P>
<H2><A NAME="SECTION005124000000000000000">3.12.4 Stopping and restarting jobs.</A></H2>
<P>
<A NAME="3856">&#160;</A>
There is another way to put a job into the background. You can
start the job normally (in the foreground), <B>stop</B> the job,
and then restart it in the background.
<P>
First, start the <TT>yes</TT> process in the foreground, as you
did before:
<BR><IMG WIDTH=240 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen3811" SRC="img191.gif"><BR>
Again, because <TT>yes</TT> is running in the foreground, you shouldn't get
the shell prompt back.
<P>
Now, rather than interrupt the job with Ctrl-C, <B>suspend</B>
the job. Suspending a job doesn't kill it: it only temporarily stops
the job until you restart it. To do this, press the suspend key, which
is usually Ctrl-Z.
<BR><IMG WIDTH=377 HEIGHT=77 ALIGN=BOTTOM ALT="tscreen3865" SRC="img197.gif"><BR>
While the job is suspended, it's simply not running. No CPU time is
used for the job. However, you can restart the job, which causes the
job to run again as if nothing ever happened. It will continue to run
where it left off.
<P>
<A NAME="3921">&#160;</A>
<A NAME="3869">&#160;</A>
To restart the job in the foreground, use the 
<TT>fg</TT> command (for ``foreground''). 
<BR><IMG WIDTH=127 HEIGHT=34 ALIGN=BOTTOM ALT="tscreen3871" SRC="img198.gif"><BR>
<A NAME="3873">&#160;</A>
<A NAME="3922">&#160;</A>
The shell displays the name of the command again so you're aware of which job
you just put into the foreground. Stop the job again with Ctrl-Z.
This time, use the <TT>bg</TT> command to put the job into the background.
This causes the command to run just as if you started the command
with ``<TT>&amp;</TT>'' as in the last section.
<BR><IMG WIDTH=176 HEIGHT=56 ALIGN=BOTTOM ALT="tscreen3878" SRC="img199.gif"><BR>
And you have your prompt back. <TT>Jobs</TT> should report that <TT>yes</TT>
is indeed running, and you can kill the job with <TT>kill</TT> as we
did before.
<P>
How can you stop the job again? Using Ctrl-Z won't work, because
the job is in the background. The answer is to put the job in the
foreground with <TT>fg</TT>, and then stop it. As it turns out, you can
use <TT>fg</TT> on either stopped jobs or jobs in the background.
<P>
There is a big difference between a job in the background and a job
that is stopped. A stopped job is not running--it's not using any
CPU time, and it's not doing any work (the job still occupies
system memory, although it may have been swapped out to disk). A job in the 
background is running and using memory, as well as completing some task 
while you
do other work.
<P>
However, a job in the background may try to display text on
your terminal, which can be annoying if you're trying to work on
something else. For example, if you used the command
<BR><IMG WIDTH=151 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen3886" SRC="img200.gif"><BR>
without redirecting stdout to <TT>/dev/null</TT>, a stream of <TT>y</TT>'s
would be displayed on your screen, without any way for you to
interrupt it. (You can't use Ctrl-C to interrupt jobs in the
background.)  In order to stop the endless <TT>y</TT>'s, use the <TT>fg</TT>
command to bring the job to the foreground, and then use Ctrl-C
to kill it.
<P>
Another note. The <TT>fg</TT> and <TT>bg</TT> commands normally affect
the job that was last stopped (indicated by a 
``<TT>+</TT>'' next to the job number when you use the <TT>jobs</TT> command).
If you are running multiple jobs at once, you can put jobs in the foreground or
background by giving the job ID as
an argument to <TT>fg</TT> or <TT>bg</TT>, as in
<BR><IMG WIDTH=151 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen3900" SRC="img201.gif"><BR>
(to put job number 2 into the foreground), or
<BR><IMG WIDTH=151 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen3902" SRC="img202.gif"><BR>
(to put job number 3 into the background). You can't use process ID numbers with
<TT>fg</TT> or <TT>bg</TT>.
<P>
Furthermore, using the job number alone, as in
<BR><IMG WIDTH=125 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen3906" SRC="img203.gif"><BR>
is equivalent to
<BR><IMG WIDTH=151 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen3900" SRC="img201.gif"><BR>
<P>
Just remember that using job control is a feature of the shell. The
<TT>fg</TT>, <TT>bg</TT> and <TT>jobs</TT> commands are internal to the shell.
If for some reason you use a shell that doesn't support job control,
don't expect to find these commands available.
<P>
In addition, there are some aspects of job control that differ between
<TT>bash</TT> and <TT>tcsh</TT>. In fact, some shells don't provide job
control at all--however, most shells available for Linux do.
<P>
<A NAME="3915">&#160;</A>
<P>
<H1><A NAME="SECTION005130000000000000000">3.13 Using the <TT>vi</TT> editor.</A></H1>
<A NAME="secvi">&#160;</A>
<P>
<A NAME="4277">&#160;</A>
<A NAME="3928">&#160;</A>
<A NAME="3929">&#160;</A>
A <B>text editor</B> is a program used to edit files that are composed
of text: a letter, C program, or a system configuration file.  While
there are many such editors available for Linux, the only editor that
you are guaranteed to find on any UNIX or Linux system is <TT>vi</TT>-- the
``visual editor.'' <TT>vi</TT> is not the easiest editor to use, nor is
it very self-explanatory. However, because <TT>vi</TT> is so common in
the UNIX/Linux world, and sometimes necessary, it deserves discussion here.
<P>
<A NAME="3934">&#160;</A>
<A NAME="3935">&#160;</A>
Your choice of an editor is mostly a question of personal taste
and style. Many users prefer the baroque, self-explanatory and powerful
<TT>emacs</TT>--an editor with more features than any other single program in
the UNIX world. For example, Emacs has its own built-in dialect of the
LISP programming language, and has many extensions (one of which is an
Eliza-like artificial intelligence program). However, because Emacs and its support
files are relatively large, it may not be installed on some systems.
<TT>vi</TT>, on the other hand, is small and powerful but more difficult to
use. However, once you know your way around <TT>vi</TT>, it's actually very
easy.
<P>
This section presents an introduction to <TT>vi</TT>--we won't discuss
all of its features, only the ones you need to know to get started.
You can refer to the man page for <TT>vi</TT> if you're interested in
learning more about this editor's features. Alternatively, you can
read the book <EM>Learning the vi Editor</EM> from O'Reilly and
Associates, or the <EM>VI Tutorial</EM> from Specialized Systems
Consultants (SSC) Inc. See Appendix&nbsp;<A
HREF="app-sources/node1.html">A</A> for information.
<P>
<H2><A NAME="SECTION005131000000000000000">3.13.1 Concepts.</A></H2>
<P>
While using <TT>vi</TT>, at any one time you are in one of three modes of 
operation. These modes are called <EM>command mode</EM>, <EM>insert mode</EM>,
and <EM>last line mode</EM>.
<P>
<A NAME="4278">&#160;</A>
When you start up <TT>vi</TT>, you are in <EM>command mode</EM>. This mode
lets you use commands to edit files or change to other modes. For
example, typing ``<TT>x</TT>'' while in command mode deletes the
character underneath the cursor. The arrow keys move the cursor around
the file you're editing. Generally, the commands used in command mode
are one or two characters long.
<P>
<A NAME="4279">&#160;</A>
You actually insert or edit text within <EM>insert mode</EM>. When using
<TT>vi</TT>, you'll probably spend most of your time in this mode.  You
start insert mode by using a command such as ``<TT>i</TT>'' (for
``insert'') from command mode. While in insert mode, you can insert
text into the document at the current cursor location. To end insert
mode and return to command mode, press Esc.
<P>
<A NAME="4280">&#160;</A>
<EM>Last line mode</EM> is a special mode used to give certain extended
commands to <TT>vi</TT>. While typing these commands, they appear on the
last line of the screen (hence the name). For example, when you type
``<TT>:</TT>'' in command mode, you jump into last line mode and can use
commands like ``<TT>wq</TT>'' (to write the file and quit <TT>vi</TT>), or
``<TT>q!</TT>'' (to quit <TT>vi</TT> without saving changes). Last line mode
is generally used for <TT>vi</TT> commands that are longer than one
character.  In last line mode, you enter a single-line command and
press Enter to execute it.
<P>
<H2><A NAME="SECTION005132000000000000000">3.13.2 Starting <TT>vi</TT>.</A></H2>
<P>
<A NAME="4282">&#160;</A>
The best way to understand these concepts is to fire up <TT>vi</TT> and
edit a file. The example ``screens'' below show only a few lines of
text, as if the screen were only six lines high instead of
twenty-four.
<P>
The syntax for <TT>vi</TT> is
<BR><IMG WIDTH=76 HEIGHT=10 ALIGN=BOTTOM ALT="tscreen3972" SRC="img204.gif"><BR>
where <i>filename</i> is the name of the file to edit.
<P>
Start up <TT>vi</TT> by typing
<BR><IMG WIDTH=168 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen3977" SRC="img205.gif"><BR>
to edit the file <TT>test</TT>.  You should see something like
<BR><IMG WIDTH=471 HEIGHT=141 ALIGN=BOTTOM ALT="tscreen3980" SRC="img206.gif"><BR>
<P>
The column of ``<TT>~</TT>'' characters indicates you are at the end of 
the file.
The <U> represents the cursor.
<P>
</U><H2><A NAME="SECTION005133000000000000000">3.13.3 Inserting text.</A></H2>
<P>
<A NAME="4285">&#160;</A>
The <TT>vi</TT> program is now in command mode. Insert text into the file
by pressing i, which places the editor into insert mode, and
begin typing.
<BR><IMG WIDTH=471 HEIGHT=140 ALIGN=BOTTOM ALT="tscreen3997" SRC="img207.gif"><BR>
<P>
Type as many lines as you want (pressing Enter after each). You
may correct mistakes with the Backspace key.
<P>
To end insert mode and return to command mode, press Esc.
<P>
In command mode you can use the arrow keys to move around in the
file. (If you have only one line of text, trying to use the
up- or down-arrow keys will probably cause <TT>vi</TT> to beep at you.)
<P>
There are several ways to insert text other than the <TT>i</TT>
command. The <TT>a</TT> command inserts text beginning after the current
cursor position, instead of at the current cursor position. For
example, use the left arrow key to move the cursor between the words
``good'' and ``men.''
<BR><IMG WIDTH=471 HEIGHT=140 ALIGN=BOTTOM ALT="tscreen4014" SRC="img208.gif"><BR>
Press a to start insert mode, type ``<TT>wo</TT>'', and then press
Esc to return to command mode.
<BR><IMG WIDTH=471 HEIGHT=140 ALIGN=BOTTOM ALT="tscreen4028" SRC="img209.gif"><BR>
<P>
To begin inserting text at the next line, use the <TT>o</TT>
command. Press o and enter another line or two:
<BR><IMG WIDTH=471 HEIGHT=140 ALIGN=BOTTOM ALT="tscreen4041" SRC="img210.gif"><BR>
<P>
<A NAME="4290">&#160;</A>
<P>
<H2><A NAME="SECTION005134000000000000000">3.13.4 Deleting text.</A></H2>
<P>
<A NAME="4291">&#160;</A>
From command mode, the <TT>x</TT> command deletes the character under the
cursor. If you press x five times, you'll end up with:
<BR><IMG WIDTH=471 HEIGHT=140 ALIGN=BOTTOM ALT="tscreen4056" SRC="img211.gif"><BR>
Now press a and insert some text, followed by esc:
<BR><IMG WIDTH=471 HEIGHT=140 ALIGN=BOTTOM ALT="tscreen4068" SRC="img212.gif"><BR>
<P>
You can delete entire lines using the command <TT>dd</TT> (that is, 
press d twice in a row). If the cursor is on the second line
and you type <TT>dd</TT>, you'll see: 
<BR><IMG WIDTH=471 HEIGHT=140 ALIGN=BOTTOM ALT="tscreen4081" SRC="img213.gif"><BR>
<P>
To delete the word that the cursor is on, use the <TT>dw</TT> command.
Place the cursor on the word ``good'', and type <TT>dw</TT>.
<BR><IMG WIDTH=471 HEIGHT=140 ALIGN=BOTTOM ALT="tscreen4094" SRC="img214.gif"><BR>
<A NAME="4296">&#160;</A>
<P>
<H2><A NAME="SECTION005135000000000000000">3.13.5 Changing text.</A></H2>
<P>
<A NAME="4297">&#160;</A>
You can replace sections of text using the <TT>R</TT> command. Place the
cursor on the first letter in ``party'', press R, and type the 
word ``hungry''.
<BR><IMG WIDTH=471 HEIGHT=140 ALIGN=BOTTOM ALT="tscreen4110" SRC="img215.gif"><BR>
Using <TT>R</TT> to edit text is like the <TT>i</TT> and <TT>a</TT> commands,
but <TT>R</TT> overwrites, rather than inserts, text.
<P>
The <TT>r</TT> command replaces the single character under the cursor.
For example, move the cursor to the beginning of the word ``Now'', and
press <TT>r</TT> followed by <TT>C</TT>, you'll see:
<BR><IMG WIDTH=471 HEIGHT=140 ALIGN=BOTTOM ALT="tscreen4128" SRC="img216.gif"><BR>
<P>
The ``<TT>~</TT>'' command changes the case of the letter under the
cursor from upper- to lower-case, and back. For example, if you 
place the cursor on the ``o'' in ``Cow'' above and repeatedly press
~, you'll end up with:
<BR><IMG WIDTH=471 HEIGHT=139 ALIGN=BOTTOM ALT="tscreen4141" SRC="img217.gif"><BR>
<A NAME="4303">&#160;</A>
<P>
<H2><A NAME="SECTION005136000000000000000">3.13.6 Commands for moving the cursor.</A></H2>
<P>
<A NAME="4304">&#160;</A>
You already know how to use the arrow keys to move around the document.
In addition, you can use the <TT>h</TT>, <TT>j</TT>, <TT>k</TT>, and <TT>l</TT> 
commands to move the cursor left, down, up, and right, respectively. 
This comes in handy when (for some reason) your arrow keys aren't working
correctly.
<P>
The <TT>w</TT> command moves the cursor to the beginning of the next word;
the <TT>b</TT> command moves it to the beginning of the previous word.
<P>
The <TT>0</TT> command (that's the zero key) moves the cursor to the beginning of
the current line, and the <TT>$</TT> command moves it to the end of the line.
<P>
When editing large files, you'll want to move forwards or backwards
through the file a screenful at a time. Pressing Ctrl-F moves
the cursor one screenful forward, and Ctrl-B moves it a
screenful back.
<P>
To move the cursor to the end of the file, press <TT>G</TT>. You can
also move to an arbitrary line; for example, typing the command
<TT>10G</TT> would move the cursor to line 10 in the file. To move to the
beginning of the file, use <TT>1G</TT>.
<P>
You can couple moving commands with other commands, such as those for deleting text.
For example, the <TT>d$</TT> command deletes everything from the
cursor to the end of the line; <TT>dG</TT> deletes everything from the
cursor to the end of the file, and so on.
<P>
<H2><A NAME="SECTION005137000000000000000">3.13.7 Saving files and quitting <TT>vi</TT>.</A></H2>
<P>
<A NAME="4306">&#160;</A>
<A NAME="4307">&#160;</A>
<A NAME="4308">&#160;</A>
To quit <TT>vi</TT> without making changes to the file, use the
command <TT>:q!</TT>. When you press the ``<TT>:</TT>'', the cursor moves
to the last line on the screen and you'll be in last line mode.
<BR><IMG WIDTH=471 HEIGHT=162 ALIGN=BOTTOM ALT="tscreen4177" SRC="img218.gif"><BR>
In last line mode, certain extended commands are available. One of
them is <TT>q!</TT>, which quits <TT>vi</TT> without saving. The command
<TT>:wq</TT> saves the file and then exits <TT>vi</TT>. The command <TT>ZZ</TT>
(from command mode, without the ``<TT>:</TT>'') is equivalent to <TT>
:wq</TT>. If the file has not been changed since the last save, it merely
exits, preserving the modification time of the last change.
Remember that you must press Enter after a command
entered in last line mode.
<P>
To save the file without quitting vi, use <TT>:w</TT>.
<P>
<H2><A NAME="SECTION005138000000000000000">3.13.8 Editing another file.</A></H2>
<P>
<A NAME="4310">&#160;</A>
To edit another file, use the <TT>:e</TT> command. For example, 
to stop editing <TT>test</TT> and edit the file <TT>foo</TT> instead, use
the command
<BR><IMG WIDTH=471 HEIGHT=162 ALIGN=BOTTOM ALT="tscreen4202" SRC="img219.gif"><BR>
If you use <TT>:e</TT> without saving the file first, you'll get the error
message
<BR><IMG WIDTH=471 HEIGHT=23 ALIGN=BOTTOM ALT="tscreen4214" SRC="img220.gif"><BR>
which means that <TT>vi</TT> doesn't want to edit another file until you
save the first one. At this point, you can use <TT>:w</TT> to save the
original file, and then use <TT>:e</TT>, or you can use the command
<BR><IMG WIDTH=471 HEIGHT=162 ALIGN=BOTTOM ALT="tscreen4222" SRC="img221.gif"><BR>
The ``<TT>!</TT>'' tells <TT>vi</TT> that you really mean it--edit the new file
without saving changes to the first.
<P>
<H2><A NAME="SECTION005139000000000000000">3.13.9 Including other files.</A></H2>
<P>
<A NAME="4314">&#160;</A>
If you use the <TT>:r</TT> command, you can include the contents of another
file in the current file. For example, the command
<BR><IMG WIDTH=82 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen4238" SRC="img222.gif"><BR>
inserts the contents of the file <TT>foo.txt</TT> in the text at the
location of the cursor.
<P>
<H2><A NAME="SECTION0051310000000000000000">3.13.10 Running shell commands.</A></H2>
<P>
<A NAME="4315">&#160;</A>
You can also run shell commands within <TT>vi</TT>. The <TT>:r!</TT> command
works like <TT>:r</TT>, but rather than read a file, it inserts the 
output of the given command into the buffer at the current cursor location.
For example, if you use the command 
<BR><IMG WIDTH=82 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen4246" SRC="img223.gif"><BR>
you'll end up with
<BR><IMG WIDTH=471 HEIGHT=139 ALIGN=BOTTOM ALT="tscreen4248" SRC="img224.gif"><BR>
<P>
You can also ``shell out'' of <TT>vi</TT>, in other words, run a command
from within <TT>vi</TT>, and return to the editor when you're done. For
example, if you use the command
<BR><IMG WIDTH=73 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen4258" SRC="img225.gif"><BR>
the <TT>ls -F</TT> command will be executed and the results displayed on
the screen, but not inserted into the file you're editing. 
If you use the command
<BR><IMG WIDTH=47 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen4261" SRC="img226.gif"><BR>
<TT>vi</TT> starts an instance of the shell, letting you temporarily
put vi ``on hold'' while you execute other commands. Just log out of the
shell (using the <TT>exit</TT> command) to return to <TT>vi</TT>.
<P>
<H2><A NAME="SECTION0051311000000000000000">3.13.11 Getting <TT>vi</TT> help.</A></H2>
<P>
<TT>vi</TT> doesn't provide much in the way of interactive help (most
Linux 
programs don't), but you can always read the man page for <TT>vi</TT>. 
<TT>vi</TT> is a visual front-end to the <TT>ex</TT> editor; which 
handles many of the last-line mode commands in <TT>vi</TT>. So, in
addition to reading the man page for <TT>vi</TT>, see <TT>ex</TT> as well.
<A NAME="4318">&#160;</A>
<P>
<H1><A NAME="SECTION005140000000000000000">3.14 Customizing your environment.</A></H1>
<P>
<A NAME="4323">&#160;</A>
A shell provides many mechanisms to customize your work environment.
As mentioned above, a shell is more than a command interpreter--it is
also a powerful programming language. Although writing shell scripts
is an extensive subject, we'd like to introduce you to some of the
ways that you can simplify your work on a Linux system by using these
advanced features of the shell.
<P>
As mentioned before, different shells use different syntaxes 
when executing shell scripts. For example, Tcsh uses a C-like syntax,
while Bourne shells use another type of syntax. In this section, we
won't be encountering many differences between the two, but we
will assume that shell scripts are executed using the Bourne shell syntax.
<P>
<H2><A NAME="SECTION005141000000000000000">3.14.1 Shell scripts.</A></H2>
<A NAME="secshellscript">&#160;</A>
<A NAME="4326">&#160;</A>
<A NAME="4327">&#160;</A>
Let's say that you use a series of commands often and
would like to save time by grouping all
of them together into a single ``command''. For example, the three commands
<BR><IMG WIDTH=430 HEIGHT=56 ALIGN=BOTTOM ALT="tscreen4328" SRC="img227.gif"><BR>
concatenates the files <TT>chapter1</TT>, <TT>chapter2</TT>, and
<TT>chapter3</TT> and places the result in the file <TT>book</TT>. The second
command displays a count of the number of lines in <TT>book</TT>,
and the third command <TT>lp book</TT> prints <TT>book</TT>.
<P>
Rather than type all these commands, you can group them into a
<B>shell script</B>.
The shell script used to run all these
commands might look like this:
<BR><IMG WIDTH=386 HEIGHT=92 ALIGN=BOTTOM ALT="tscreen4338" SRC="img228.gif"><BR>
Shell scripts are just
plain text files; you can create them with an editor such as <TT>emacs</TT>
or <TT>vi</TT>, which is described starting on page&nbsp;<A HREF="node5.html#secvi"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>.
<P>
Let's look at this shell script. The first line, ``<TT>#!/bin/sh</TT>'',
identifies the file as a shell script and tells the shell how to
execute the script. It instructs the shell to pass the script to <TT>
/bin/sh</TT> for execution, where <TT>/bin/sh</TT> is the shell program
itself. Why is this important? On most Linux systems, <TT>/bin/sh</TT> is
a Bourne-type shell, like <TT>bash</TT>. By forcing the shell script to
run using <TT>/bin/sh</TT>, you ensure that the script will run under a
Bourne-syntax shell (rather than a C shell). This will cause your
script to run using the Bourne syntax even if you use <TT>tcsh</TT> (or
another C shell) as your login shell.
<P>
<A NAME="4350">&#160;</A>
The second line is a <B>comment</B>. Comments begin with the character
``<TT>#</TT>'' and continue to the end of the line. Comments are ignored
by the shell--they are commonly used to identify the shell script to
the programmer and make the script easier to understand.
<P>
The rest of the lines in the script are just commands, as you
would type them to the shell directly. In effect, the shell reads
each line of the script and runs that line as if you had typed it
at the shell prompt.
<P>
<A NAME="4353">&#160;</A>
<A NAME="4354">&#160;</A>
Permissions are important for shell scripts. If you create a shell
script, make sure that you have execute permission on the script in
order to run it.  When you create text files, the default permissions
usually don't include execute permission, and you must set them
explicitly. See the discussion of file permissions on
page&nbsp;<A HREF="node5.html#secfileperms"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A> for details.  Briefly, if this script
were saved in the file called <TT>makebook</TT>, you could use the
command
<BR><IMG WIDTH=264 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen4357" SRC="img229.gif"><BR>
to give yourself execute permission for the shell script <TT>
makebook</TT>.
<P>
You can use the command
<BR><IMG WIDTH=178 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen4360" SRC="img230.gif"><BR>
to run all the commands in the script.
<P>
<H2><A NAME="SECTION005142000000000000000">3.14.2 Shell variables and the environment.</A></H2>
<P>
<A NAME="4363">&#160;</A>
<A NAME="4364">&#160;</A>
<A NAME="4365">&#160;</A>
<A NAME="4366">&#160;</A>
A shell lets you define <B>variables</B>, as do most programming
languages. A variable is just a piece of data that is given a
name.
<P>
<TT>tcsh</TT>, as well as other C-type shells, use a 
different mechanism for setting variables than is described here. This
discussion assumes the use of a Bourne shell like <TT>bash</TT>. See the
<TT>tcsh</TT> manual page for details.
<P>
When you assign a value to a variable (using the ``<TT>=</TT>'' operator), 
you can access the variable by prepending a ``<TT>$</TT>'' to the
variable name, as demonstrated below.
<BR><IMG WIDTH=269 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen4373" SRC="img231.gif"><BR>
The variable <TT>foo</TT> is given the value <TT>hello there</TT>. You 
can then refer to this value by the variable name prefixed with a
``<TT>$</TT>'' character. For example, the command
<BR><IMG WIDTH=188 HEIGHT=57 ALIGN=BOTTOM ALT="tscreen4378" SRC="img232.gif"><BR>
produces the same results as
<BR><IMG WIDTH=279 HEIGHT=56 ALIGN=BOTTOM ALT="tscreen4380" SRC="img233.gif"><BR>
<P>
These variables are internal to the shell, which means that only the
shell can access them. This can be useful in shell scripts;
if you need to keep track of a filename, for example, you can store
it in a variable, as above. Using the <TT>set</TT> command 
displays a list of all defined shell variables.
<P>
<A NAME="4383">&#160;</A>
<A NAME="4507">&#160;</A>
However, the shell lets you <B>export</B> variables to the
<B>environment</B>. The environment is the set of variables that
are accessible by 
all commands that you execute. Once you define a variable
inside the shell, exporting it makes the variable part of the environment
as well. Use the <TT>export</TT> command to export a variable to
the environment.
<P>
<A NAME="4508">&#160;</A>
Again, here we differ between <TT>bash</TT> and <TT>
tcsh</TT>.  If you use <TT>tcsh</TT>, another syntax is used for setting
environment variables (the <TT>setenv</TT> command is used). See the <TT>
tcsh</TT> manual page for more information.
<P>
<A NAME="4394">&#160;</A>
The environment is very important to the UNIX system. It lets you
configure certain commands just by setting variables which the
commands know about.
<P>
Here's a quick example. The environment variable <TT>PAGER</TT> is used
by the <TT>man</TT> command and it specifies the command to use to display
manual pages one screenful at a time. If you set <TT>PAGER</TT> to the
name of a command, it uses that command to display the man pages,
instead of <TT>more</TT> (which is the default).
<P>
Set <TT>PAGER</TT> to ``<TT>cat</TT>''. This causes output from <TT>man</TT>
to be displayed to the screen all at once, without pausing between 
pages.
<BR><IMG WIDTH=186 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen4402" SRC="img234.gif"><BR>
Now, export <TT>PAGER</TT> to the environment.
<BR><IMG WIDTH=213 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen4405" SRC="img235.gif"><BR>
Try the command <TT>man ls</TT>. The man page should fly past your screen
without pausing for you.
<P>
Now, if we set <TT>PAGER</TT> to ``<TT>more</TT>'', the <TT>more</TT> command
is used to display the man page.
<BR><IMG WIDTH=195 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen4411" SRC="img236.gif"><BR>
Note that we don't have to use the <TT>export</TT> command after we
change the value of <TT>PAGER</TT>. We only need to export a variable
once; any changes made to it thereafter will automatically be
propagated to the environment.
<P>
It is often necessary to quote strings in order to prevent the shell
from treating various characters as special. For example, you need to
quote a string in order to prevent the shell from interpreting the
special meaning of characters such as ``*'', ``?'' or a space. There are many
other characters that may need to be protected from interpretation.
A detailed explanation and desription of quoting is described in SSC's
<EM>Bourne Shell Tutorial</EM>.
<P>
The manual pages for a particular command tell you if the command uses
any environment variables.  For example, the <TT>man</TT> man page
explains that <TT>PAGER</TT> is used to specify the pager command.
<P>
Some commands share environment variables.  For example, many commands
use the <TT>EDITOR</TT> environment variable to specify the default editor
to use when one is needed.
<P>
The environment is also used to keep track of important information
about your login session. An example is the <TT>HOME</TT> environment
variable, which contains the name of your home directory.
<BR><IMG WIDTH=255 HEIGHT=35 ALIGN=BOTTOM ALT="tscreen4420" SRC="img237.gif"><BR>
<P>
Another interesting environment variable is <TT>PS1</TT>, which defines
the main shell prompt. For example,
<BR><IMG WIDTH=373 HEIGHT=34 ALIGN=BOTTOM ALT="tscreen4423" SRC="img238.gif"><BR>
To set the prompt back (which contains the current 
working directory followed by a ``<TT>#</TT>'' symbol), 
<BR><IMG WIDTH=296 HEIGHT=34 ALIGN=BOTTOM ALT="tscreen4426" SRC="img239.gif"><BR>
The <TT>bash</TT> manual page describes the syntax used for setting the
prompt.
<P>
<H5><A NAME="SECTION005142001000000000000">The <TT>PATH</TT> environment variable.</A></H5>
<P>
<A NAME="4510">&#160;</A>
When you use the <TT>ls</TT> command, how does the shell find the <TT>
ls</TT> executable itself? In fact, <TT>ls</TT> is in <TT>/bin</TT> on most
systems. The shell uses the environment variable <TT>PATH</TT> to locate
executable files for commands you type.
<P>
For example, your <TT>PATH</TT> variable may be set to
<BR><IMG WIDTH=253 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen4437" SRC="img240.gif"><BR>
This is a list of directories for the shell to search, each directory
separated by a ``<TT>:</TT>''. When you use the command <TT>ls</TT>, the
shell first looks for <TT>/bin/ls</TT>, then <TT>/usr/bin/ls</TT>, and so on.
<P>
Note that the <TT>PATH</TT> has nothing to do with finding regular files. 
For example, if you use the command 
<BR><IMG WIDTH=195 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen2397" SRC="img118.gif"><BR>
the shell does not use <TT>PATH</TT> to locate the files <TT>foo</TT> and
<TT>bar</TT>--those filenames are assumed to be complete. The shell only
uses <TT>PATH</TT> to locate the <TT>cp</TT> executable.
<P>
This saves you time, and means that you don't have to remember where 
all the command executables are stored. On many systems, executables are 
scattered about in many places, such as <TT>/usr/bin</TT>, <TT>/bin</TT>, or 
<TT>/usr/local/bin</TT>. Rather than give the command's full pathname (such 
as <TT>/usr/bin/cp</TT>), you can set <TT>PATH</TT> to the list of 
directories that you want the shell to automatically search.
<P>
Notice that <TT>PATH</TT> contains ``<TT>.</TT>'', which is the current working
directory. This lets you create a shell script or program and run it as 
a command from your current directory without having
to specify it directly (as in <TT>./makebook</TT>). If a directory isn't in
your <TT>PATH</TT>, then the shell will not search it for commands to run; this 
also includes the current directory.
<P>
<H2><A NAME="SECTION005143000000000000000">3.14.3 Shell initialization scripts.</A></H2>
<A NAME="secinitscripts">&#160;</A>
<A NAME="4462">&#160;</A>
<A NAME="4463">&#160;</A>
In addition to the shell scripts that you create, there are a number
of scripts that the shell itself uses for certain purposes. The most
important of these are <B>initialization scripts</B>, which are scripts
executed by the shell when you log in.
<P>
The initialization scripts themselves are simply shell
scripts. However, they initialize your environment by executing
commands automatically when you log in. If you always use the <TT>
mail</TT> command to check your mail when you log in, you place the
command in the initialization script so it will execute automatically.
<P>
<A NAME="4466">&#160;</A>
Both <TT>bash</TT> and <TT>tcsh</TT> distinguish between a <B>login shell</B>
and other invocations of the shell. A <TT>login</TT> shell is a shell
invoked when you log in. Usually, it's the only shell you'll
use. However, if you ``shell out'' of another program like <TT>vi</TT>,
you start another instance of the shell, which isn't your <TT>login</TT>
shell. In addition, whenever you run a shell script, you automatically
start another instance of the shell to execute the script.
<P>
<A NAME="4473">&#160;</A>
<A NAME="4474">&#160;</A>
<A NAME="4511">&#160;</A>
<A NAME="4512">&#160;</A>
<A NAME="4513">&#160;</A>
<A NAME="4514">&#160;</A>
The initialization files used by <TT>bash</TT> are: <TT>/etc/profile</TT>
(set up by the system administrator and executed by all <TT>bash</TT>
users at <TT>login</TT> time), <TT>$HOME/.bash_profile</TT> (executed by a
<TT>login</TT> <TT>bash</TT> session), and <TT>$HOME/.bashrc</TT> (executed by
all non-<TT>login</TT> instances of <TT>bash</TT>).  If <TT>.bash_profile</TT>
is not present, <TT>.profile</TT> is used instead.
<P>
<A NAME="4515">&#160;</A>
<A NAME="4516">&#160;</A>
<TT>tcsh</TT> uses the following initialization scripts: <TT>
/etc/csh.login</TT> (executed by all <TT>tcsh</TT> users at <TT>login</TT>
time), <TT>$HOME/.tcshrc</TT> (executed at login time and by all new
instances of <TT>tcsh</TT>), and <TT>$HOME/.login</TT> (executed at <TT>
login</TT> time, following <TT>.tcshrc</TT>).  If <TT>.tcshrc</TT> is not
present, <TT>.cshrc</TT> is used instead.
<P>
A complete guide to shell programming would be beyond the scope of
this book. See the manual pages for <TT>bash</TT> or <TT>tcsh</TT> to learn
more about customizing the Linux environment.
<P>
<A NAME="4506">&#160;</A>
<P>
<H1><A NAME="SECTION005150000000000000000">3.15 So you want to strike out on your own?</A></H1>
<P>
This chapter should give you enough information for basic Linux
use. 
The manual pages are indispensable tools for learning about
Linux. They may appear confusing at first, but if you dig beneath the
surface, there is a wealth of information.
<P>
We also suggest that you read a general Linux reference book. Linux has
more features than first meet the eye. Unfortunately, many of them are
beyond the scope of this book. Other recommended Linux books are listed
in Appendix&nbsp;<A HREF="app-sources/node1.html">A</A>.
<P>
<HR><A NAME="tex2html846" HREF="node6.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="next_motif.gif"></A> <A NAME="tex2html844" HREF="gs.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="up_motif.gif"></A> <A NAME="tex2html838" HREF="node4.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="previous_motif.gif"></A> <A NAME="tex2html848" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="contents_motif.gif"></A>  <BR>
<B> Next:</B> <A NAME="tex2html847" HREF="node6.html">4 System Administration</A>
<B>Up:</B> <A NAME="tex2html845" HREF="gs.html">Linux Installation and Getting </A>
<B> Previous:</B> <A NAME="tex2html839" HREF="node4.html">2 Obtaining and Installing </A>
<P><ADDRESS>
<I>Clarica Grove <BR>
Wed Mar  4 10:46:42 PST 1998</I>
</ADDRESS>
</BODY>
</HTML>
