<!DOCTYPE HTML PUBLIC "-//IETF//DTD HTML 2.0//EN">
<!--Converted with LaTeX2HTML 96.1-h (September 30, 1996) by Nikos Drakos (nikos@cbl.leeds.ac.uk), CBLU, University of Leeds -->
<HTML>
<HEAD>
<TITLE>4 System Administration</TITLE>
<META NAME="description" CONTENT="4 System Administration">
<META NAME="keywords" CONTENT="gs">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<LINK REL=STYLESHEET HREF="gs.css">
</HEAD>
<BODY LANG="EN" >
 <A NAME="tex2html857" HREF="node7.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="next_motif.gif"></A> <A NAME="tex2html855" HREF="gs.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="up_motif.gif"></A> <A NAME="tex2html849" HREF="node5.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="previous_motif.gif"></A> <A NAME="tex2html859" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="contents_motif.gif"></A>  <BR>
<B> Next:</B> <A NAME="tex2html858" HREF="node7.html">5 The X Window </A>
<B>Up:</B> <A NAME="tex2html856" HREF="gs.html">Linux Installation and Getting </A>
<B> Previous:</B> <A NAME="tex2html850" HREF="node5.html">3 Linux Tutorial</A>
<BR> <P>
<H1><A NAME="SECTION00600000000000000000">4 System Administration</A></H1>
<A NAME="chapsysadm">&#160;</A>
<P>
<A NAME="chapsysadmnum">&#160;</A>
<P>
	This chapter covers the most important things that you need to
	know about system administration under Linux in sufficient
	detail to start using the system comfortably.  In order to
	keep the chapter manageable, it covers just the basics and
	omits many important details. The <EM>Linux System
	Administrator's Guide</EM>, by Lars Wirzenius (see
	Appendix&nbsp;<A HREF="app-sources/node1.html">A</A>) provides considerably more detail on
	system administration topics.  It will help you understand
	better how things work and hang together.  At least, skim
	through the SAG so that you know what it contains and what
	kind of help you can expect from it.
<P>
<H1><A NAME="SECTION00610000000000000000">4.1 The <TT>root</TT> account.</A></H1>
<P>
	Linux differentiates between different users. What they can do
	to each other and the system is regulated. File permissions
	are arranged so that normal users can't delete or modify files
	in directories like <TT>/bin</TT> and <TT>/usr/bin</TT>. Most users
	protect their own files with the appropriate permissions so
	that other users can't access or modify them. (One wouldn't
	want anybody to be able to read one's love letters.) Each
	user is given an <B>account</B> that includes a user name and
	home directory. In addition, there are special, system
	defined accounts which have special privileges. The most
	important of these is the <B>root account</B>, which is used by
	the system administrator. By convention, the system
	administrator is the user, <TT>root</TT>.
<P>
	There are no restrictions on <TT>root</TT>. He or she can read,
	modify, or delete any file on the system, change permissions
	and ownerships on any file, and run special programs like
	those which partition a hard drive or create file systems.
	The basic idea is that a person who cares for the system logs
	in as <TT>root</TT> to perform tasks that cannot be executed as a
	normal user. Because <TT>root</TT> can do anything, it is easy
	to make mistakes that have catastrophic consequences.
<P>
If a normal user tries inadvertently to delete all of the files in
<TT>/etc</TT>, the system will not permit him or her to do so. However,
if <TT>root</TT> tries to do the same thing, the system doesn't complain
at all. It is very easy to trash a Linux system when using <TT>
root</TT>. The best way to prevent accidents is:
<P>
<UL>
<LI> Sit on your hands before you press Enter for any command 
that is non-reversible. If you're about to clean out a directory,
re-read the entire command to make sure that it is correct.
<LI> Use a different prompt for the <TT>root</TT> account. <TT>root</TT>'s 
<TT>.bashrc</TT> or <TT>.login</TT> file should set the shell prompt to
something different than the standard user prompt. Many people reserve
the character ``<TT>#</TT>'' in prompts for <TT>root</TT> and use the
prompt character ``<TT>$</TT>'' for everyone else.
<LI> Log in as <TT>root</TT> only when absolutely necessary. When
you have finished your work as <TT>root</TT>, log out. The less you use
the <TT>root</TT> account, the less likely you are to damage the system.
You are less likely to confuse the privileges of <TT>root</TT> with those
of a normal user.
</UL>
<P>
Picture the <TT>root</TT> account as a special, magic hat that
gives you lots of power, with which you can, by waving your hands,
destroy entire cities. It is a good idea to be a bit careful about
what you do with your hands. Because it is easy to wave your hands in
a destructive manner, it is not a good idea to wear the magic hat when
it is not needed, despite the wonderful feeling.
<P>
We'll talk in greater detail about the system administrator's
responsibilities starting on page&nbsp;<A HREF="node6.html#secmanageusers"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>.
<P>
<H1><A NAME="SECTION00620000000000000000">4.2 Booting the system.</A></H1>
<P>
<A NAME="secbootfloppy">&#160;</A> 
Some people boot Linux with a floppy diskette that contains a copy of
the Linux kernel. This kernel has the Linux root partition coded into
it, so it knows where to look for the root file system. This is the
type of floppy created by Slackware during installation, for example.
<P>
To create your own boot floppy, locate the kernel image on your hard
disk. It should be in the file <TT>/vmlinuz</TT>, or <TT>/vmlinux</TT>. In
some installations, <TT>/vmlinuz</TT> is a soft link to the actual
kernel, so you may need to track down the kernel by following the
links.
<P>
Once you know where the kernel is, set the root device of the kernel
image to the name of your Linux root partition with the <TT>rdev</TT>
command. The format of the command is
<P>
<BR><IMG WIDTH=187 HEIGHT=10 ALIGN=BOTTOM ALT="tscreen4572" SRC="img241.gif"><BR>
where <i>kernel-name</i> is the name of the kernel image, and 
<i>root-device</i> is the name of the Linux root partition. For
example, to set the root device in the kernel <TT>/vmlinuz</TT> to
<TT>/dev/hda2</TT>, use the command
<BR><IMG WIDTH=213 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen4580" SRC="img242.gif"><BR>
<TT>rdev</TT> can set other options in the kernel, like the default SVGA
mode to use at boot time. The command
<BR><IMG WIDTH=75 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen4583" SRC="img243.gif"><BR>
prints a help message on the screen. After setting the root
device, simply copy the kernel image to the floppy. Before copying
data to any floppy, however, it's a good idea to use the MS-DOS <TT>
FORMAT.COM</TT> or the Linux <TT>fdformat</TT> program to format the
diskette. This lays down the sector and track information that is
appropriate to the floppy's capacity.
<P>
Floppy diskette formats and their device driver files are discussed
further starting on page&nbsp;<A HREF="node6.html#secbackfloppy"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>.
<P>
Device driver files, as mentioned earlier, reside in the <TT>/dev</TT>
directory. To copy the kernel in the file <TT>/etc/Image</TT> to the
floppy in <TT>/dev/fd0</TT>, use the command
<BR><IMG WIDTH=187 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen4591" SRC="img244.gif"><BR>
This floppy should now boot Linux.
<P>
<H2><A NAME="SECTION00621000000000000000">4.2.1 Using LILO.</A></H2>
<A NAME="seclilo">&#160;</A>
<P>
LILO is a separate boot loader which resides on your hard disk. It is
executed when the system boots from the hard drive and can
automatically boot Linux from a kernel image stored there.
<P>
LILO can also be used as a first-stage boot loader for several
operating systems, which allows you to select the operating system you
to boot, like Linux or MS-DOS. With LILO, the default operating system
is booted unless you press Shift during the boot-up sequence, or
if the <TT>prompt</TT> directive is given in the <TT>lilo.conf</TT> file.
In either case, you will be provided with a boot prompt, where you
type the name of the operating system to boot (such as ``<TT>linux</TT>''
or ``<TT>msdos</TT>''). If you press Tab at the boot prompt, a
list of operating systems that the system knows about will be
provided.
<P>
The easy way to install LILO is to edit the configuration file, 
<TT>/etc/lilo.conf</TT>. The command
<BR><IMG WIDTH=101 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen4602" SRC="img245.gif"><BR>
rewrites the modified <TT>lilo.conf</TT> configuration to the boot sector
of the hard disk, and must be run every time you modify <TT>
lilo.conf</TT>.
<P>
The LILO configuration file contains a ``stanza'' for each operating
system that you want to boot. The best way to demonstrate this is with
an example. The <TT>lilo.conf</TT> file below is for a system which has
a Linux root partition on <TT>/dev/hda1</TT> and a MS-DOS partition on
<TT>/dev/hda2</TT>.
<P>
<BR><IMG WIDTH=558 HEIGHT=709 ALIGN=BOTTOM ALT="tscreen4609" SRC="img246.gif"><BR>
<P>
The first operating system stanza is the default operating system for
LILO to boot. Also note that if you use the ``<TT>root =</TT>'' line,
above, there's no reason to use <TT>rdev</TT> to set the root partition
in the kernel image. LILO sets it at boot time.
<P>
The Microsoft Windows '95 installer will overwrite the LILO boot
manager. If you are going to install Windows '95 on your system after
installing LILO, make sure to create a boot disk first (see
Section&nbsp;<A HREF="node6.html#secbootfloppy">4.2</A>). With the boot disk, you can boot Linux
and re-install LILO after the Windows '95 installation is completed.
This is done simply by typing, as root, the command <TT>/sbin/lilo</TT>,
as in the step above. Partitions with Windows '95 can be configured
to boot with LILO using the same <TT>lilo.conf</TT> entries that are used
to boot the MS-DOS partition.
<P>
The <EM>Linux FAQ</EM> (see Appendix&nbsp;<A
HREF="app-sources/node1.html">A</A>) provides more information
on LILO, including how to use LILO to boot with the OS/2 Boot Manager.
<P>
<H1><A NAME="SECTION00630000000000000000">4.3 Shutting down.</A></H1>
<P>
<A NAME="secsysadmshutdown">&#160;</A>
<P>
Shutting down a Linux system can be tricky. You should never simply
turn off the power or press the reset switch. The kernel keeps track
of the disk read/write data in memory buffers. If you reboot the
system without giving the kernel a chance to write its buffers to
disk, you can corrupt the file systems.
<P>
Other precautions are taken during shutdown as well. All processes are
sent a signal that allows them to die gracefully (by first writing and
closing all files, for example). File systems are unmounted for
safety. If you wish, the system can also alert users that the system
is going down and give them a chance to log off.
<P>
The easiest way to shut down is with the <TT>shutdown</TT> command. The
format of the command is
<BR><IMG WIDTH=210 HEIGHT=13 ALIGN=BOTTOM ALT="tscreen4623" SRC="img247.gif"><BR>
The <i>time</i> argument is the time to shut down the system (in
the format <EM>hh:mm:ss</EM>), and <i>warning-message</i> is a message
displayed on all user's terminals before shutdown. Alternately, you
can specify the <i>time</i> as ``<TT>now</TT>'', to shut down 
immediately. The <TT>-r</TT> option may be given to <TT>shutdown</TT> to
reboot the system after shutting down.
<P>
For example, to shut down and reboot the system at 8:00 pm, use the
command
<BR><IMG WIDTH=161 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen4634" SRC="img248.gif"><BR>
<P>
The command <TT>halt</TT> may be used to force an immediate shutdown
without any warning messages or grace period. <TT>halt</TT> is useful if
you're the only one using the system and want to shut down and turn
off the machine.
<P>
Don't turn off the power or reboot the system until you
see the message:
<BR><IMG WIDTH=171 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen4638" SRC="img249.gif"><BR>
It is very important that you shut down the system, ``cleanly,'' using
the <TT>shutdown</TT> or <TT>halt</TT> command. On some systems, pressing
Ctrl-Alt-Del will be trapped and cause a <TT>shutdown</TT>. On other
systems, using the ``Vulcan nerve pinch'' will reboot the system
immediately and cause disaster.
<P>
<H2><A NAME="SECTION00631000000000000000">4.3.1 The <TT>/etc/inittab</TT> file.</A></H2>
 <A NAME="secinittab">&#160;</A>
<P>
Immediately after Linux boots and the kernel mounts the root file
system, the first program that the system executes is <TT>init</TT>.
This program is responsible for starting the system startup scripts,
and modifies the system operatiing from its initial boot-up state to
its standard, multiuser state. <TT>init</TT> also spawns the <TT>
login:</TT> shells for all of the tty devices on the system, and specifies
other startup and shutdown procedures.
<P>
After startup, <TT>init</TT> remains quietly in the background,
monitoring and if necessary altering the running state of the system.
There are many details that the <TT>init</TT> program must see to. These
tasks are defined in the <TT>/etc/inittab</TT> file. A sample <TT>
/etc/inittab</TT> file is shown below.
<P>
Modifying the <TT>/etc/inittab</TT> file incorrectly can
prevent you from logging in to your system. At the very least, when
changing the <TT>/etc/inittab</TT> file, keep on hand a copy of the
original, correct file, and a boot/root emergency floppy in case you
make a mistake.
<P>
<BR><IMG WIDTH=589 HEIGHT=890 ALIGN=BOTTOM ALT="tscreen4659" SRC="img250.gif"><BR>
<P>
At startup, this <TT>/etc/inittab</TT> starts six virtual consoles, a
<TT>login:</TT> prompt on the modem attached to <TT>/dev/ttyS0</TT>, and a
<TT>login:</TT> prompt on a character terminal connected via a RS-232
serial line to <TT>/dev/ttyS1</TT>.
<P>
Briefly, <TT>init</TT> steps through a series of <B>run levels</B>, which
correspond to various operationing states of the system. Run level 1
is entered immediately after the system boots, run levels 2 and 3 are
the normal, multiuser operation modes of the system, run level 4
starts the X Window System via the X display manager <TT>xdm</TT>, and
run level 6 reboots the system. The run level(s) associated with each
command are the second item in each line of the <TT>/etc/inittab</TT>
file.
<P>
For example, the line
<BR><IMG WIDTH=418 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen4670" SRC="img251.gif"><BR>
will maintain a <TT>login</TT> prompt on a serial terminal for runlevels
1-5. The ``<TT>s2</TT>'' before the first colon is a symbolic
identifier used internally by <TT>init</TT>. <TT>respawn</TT> is an <TT>
init</TT> keyword that is often used in conjunction with serial terminals.
If, after a certain period of time, the <TT>agetty</TT> program, which
spawns the terminal's <TT>login:</TT> prompt, does not receive input at
the terminal, the program times out and terminates execution. ``<TT>
respawn</TT>'' tells <TT>init</TT> to re-execute <TT>agetty</TT>, ensuring that
there is always a <TT>login:</TT> prompt at the terminal, regardless of
whether someone has logged in. The remaining parameters are passed
directly to <TT>agetty</TT> and instruct it to spawn the <TT>login</TT>
shell, the data rate of the serial line, the serial device, and the
terminal type, as defined in <TT>/etc/termcap</TT> or <TT>
/etc/terminfo</TT>.
<P>
The <TT>/sbin/agetty</TT> program handles many details related to
terminal I/O on the system. There are several different versions that
are commonly in use on Linux systems. They include <TT>mgetty</TT>, <TT>
psgetty</TT>, or simply, <TT>getty</TT>.
<P>
In the case of the <TT>/etc/inittab</TT> line 
<BR><IMG WIDTH=324 HEIGHT=34 ALIGN=BOTTOM ALT="tscreen4692" SRC="img252.gif"><BR>
which allows users to log in via a modem connected to serial line <TT>
/dev/ttyS0</TT>, the <TT>/sbin/agetty</TT> parameters ``<TT>-mt60</TT>'' allow
the system to step through all of the modem speeds that a caller
dialing into the system might use, and to shut down <TT>/sbin/agetty</TT>
if there is no connection after 60 seconds. This is called <B>
negotiating</B> a connection. The supported modem speeds are enumerated
on the command line also, as well as the serial line to use, and the
terminal type. Of course, both of the modems must support the data
rate which is finally negotiated by both machines.
<P>
Many important details have been glossed over in this section. The
tasks that <TT>/etc/inittab</TT> maintains would comprise a book of their
own. For further information, the manual pages of the <TT>init</TT> and
<TT>agetty</TT> programs, and the Linux Documentation Project's Serial
HOWTO, available from the sources listed in
Appendix&nbsp;<A HREF="app-sources/node1.html">A</A>, are starting points.
<P>
<H1><A NAME="SECTION00640000000000000000">4.4 Managing file systems.</A></H1>
<A NAME="secmanagefs">&#160;</A>
<P>
Another task of the system administrator is caring for file systems.
Most of this job entails periodically checking the file systems for
damage or corrupted files. Many Linux systems also automatically
check the file systems at boot time.
<P>
<H2><A NAME="SECTION00641000000000000000">4.4.1 Mounting file systems.</A></H2>
<P>
Before a file system is accessible to the system, it must be <B>
mounted</B> on a directory. For example, if you have a file system on a
floppy, you must mount it under a directory like <TT>/mnt</TT> in order
to access the files on the floppy (see
page&nbsp;<A HREF="node6.html#secfloppy"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>). After mounting the file system, all of the
files in the file system appear in that directory. After unmounting
the file system, the directory (in this case, <TT>/mnt</TT>) will be
empty.
<P>
The same is true of file systems on the hard drive. The system
automatically mounts file systems on your hard drive at bootup
time. The so-called ``root file system'' is mounted on the directory
<TT>/</TT>. If you have a separate file system for <TT>/usr</TT>, it is
mounted on <TT>/usr</TT>. If you only have a root file system, all files
(including those in <TT>/usr</TT>) exist on that file system.
<P>
<TT>mount</TT> and <TT>umount</TT> (not <EM>unmount</EM>) are used to mount and
unmount file systems. The command
<P>
<BR><IMG WIDTH=76 HEIGHT=8 ALIGN=BOTTOM ALT="tscreen4721" SRC="img253.gif"><BR>
is executed automatically by the file <TT>/etc/rc</TT> at boot time, or
by the file <TT>/etc/rc.d/boot</TT> (see page&nbsp;<A HREF="node6.html#secrc"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>) on some
Linux systems. The file <TT>/etc/fstab</TT> provides information on file
systems and mount points. An example <TT>/etc/fstab</TT> file is
<P>
<A NAME="examplesysadmfstab">&#160;</A>
<BR><IMG WIDTH=402 HEIGHT=92 ALIGN=BOTTOM ALT="tscreen4729" SRC="img254.gif"><BR>
<P>
The first field, <TT>device</TT>, is the name of the partition to
mount. The second field is the mount point. The third field is the
file system type, like <TT>ext2</TT> (for ext2fs) or <TT>minix</TT> (for
Minix file systems). 
Table&nbsp;<A HREF="node6.html#tablefstypes">4.1</A> 
lists the various file
system types that are mountable under Linux.<A NAME="tex2html354" HREF="footnode.html#4735"><IMG  ALIGN=BOTTOM ALT="gif" SRC="foot_motif.gif"></A> Not all of these file system
types may be available on your system, because the kernel must have
support for them compiled in. See page&nbsp;<A HREF="node6.html#secsysadmupgrade"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>
for information on building the kernel.
<P><A NAME="4758">&#160;</A><A NAME="tablefstypes">&#160;</A><IMG WIDTH=617 HEIGHT=258 ALIGN=BOTTOM ALT="table4737" SRC="img255.gif"><BR>
<STRONG>Table 4.1:</STRONG> Linux File system Types<BR>
<P>
<P>
The last field of the <TT>fstab</TT> file are the <TT>mount</TT> options.
This is normally set to <TT>defaults</TT>.
<P>
Swap partitions are included in the <TT>/etc/fstab</TT> file. They have a
mount directory of <TT>none</TT>, and type <TT>swap</TT>. The <TT>swapon
-a</TT> command, which is executed from <TT>/etc/rc</TT> or <TT>
/etc/init.d/boot</TT>, is used to enable swapping on all of the swap
devices that are listed in <TT>/etc/fstab</TT>.
<P>
The <TT>/etc/fstab</TT> file contains one special entry for the <TT>
/proc</TT> file system. As described on page&nbsp;<A HREF="node5.html#secprocesses"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>, the
<TT>/proc</TT> file system is used to store information about system
processes, available memory, and so on. If <TT>/proc</TT> is not mounted,
commands like <TT>ps</TT> will not work.
<P>
The <TT>mount</TT> command may be used only by root. This 
ensures security on the system. You wouldn't want regular users
mounting and unmounting file systems on a whim. Several software
packages are available which allow non-root users to mount and unmount
file systems, especially floppies, without compromising system
security.
<P>
The <TT>mount -av</TT> command actually mounts all of the file systems
other than the root file system (in the table above, <TT>
/dev/hda2</TT>). The root file system is automatically mounted at boot
time by the kernel.
<P>
Instead of using <TT>mount -av</TT>, you can mount a file system by 
hand. The command
<BR><IMG WIDTH=256 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen4782" SRC="img256.gif"><BR>
is equivalent to mounting the file system with the entry for
<TT>/dev/hda3</TT> in the example <TT>/etc/fstab</TT> file, above.
<P>
<H2><A NAME="SECTION00642000000000000000">4.4.2 Device driver names.</A></H2>
<P>
<A NAME="devicedrivernames">&#160;</A>
In addition to the partition names listed in the <TT>/etc/fstab</TT>
file, Linux recognizes a number of fixed and removable media devices.
They are classified by type, interface, and the order they are
installed. For example, the first hard drive on your system, if it is
an IDE or older MFM hard drive, is controlled by the device driver
pointed to by <TT>/dev/hda</TT>. The first partition on the hard drive is <TT>
/dev/hda1</TT>, the second partition is <TT>/dev/hda2</TT>, the third
partition is <TT>/dev/hda3</TT>, and so on. The first partition of the
second IDE drive is often <TT>/dev/hdb1</TT>, the second partition <TT>
/dev/hdb2</TT>, and so on. The naming scheme for the most commonly
installed IDE drives for Intel-architecture, ISA and PCI bus machines,
is given in Table&nbsp;<A HREF="node6.html#tableidedevicedrivers">4.2</A>.
<P><A NAME="4805">&#160;</A><A NAME="tableidedevicedrivers">&#160;</A><IMG WIDTH=335 HEIGHT=98 ALIGN=BOTTOM ALT="table4796" SRC="img257.gif"><BR>
<STRONG>Table 4.2:</STRONG> IDE device driver names.<BR>
<P>
<P>
CD-ROM and tape drives which use the extended IDE/ATAPI drive
interface also use these device names.
<P>
Many machines, however, including high-end personal computer
workstations, and machines based on Digital Equipment Corporation's
Alpha processor, use the Small Computer System Interface (SCSI). The
naming conventions for SCSI devices are somewhat different than that
given above, due the greater flexibility of SCSI addressing. The
first SCSI hard drive on a system is <TT>/dev/sda</TT>, the second SCSI
drive is <TT>/dev/sdb</TT>, and so on. A list of common SCSI devices is
given in Table&nbsp;<A HREF="node6.html#tablescsidevices">4.3</A>.
<P>
<P><A NAME="4823">&#160;</A><A NAME="tablescsidevices">&#160;</A><IMG WIDTH=288 HEIGHT=135 ALIGN=BOTTOM ALT="table4812" SRC="img258.gif"><BR>
<STRONG>Table 4.3:</STRONG> SCSI device drivers<BR>
<P>
<P>
Note that SCSI CD-ROM and tape drives are named differently than SCSI
hard drives. Removable SCSI media, like the Iomega Zip drive, follow
naming conventions for non-removable SCSI drives. The use of a Zip
drive for making backups is described starting on
page&nbsp;<A HREF="node6.html#seczipbackup"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>
<P>
Streaming tape drives, like those which read and write QIC-02, QIC-40,
and QIC-80 format magnetic tapes, have their own set of device names,
which are described on page&nbsp;<A HREF="node6.html#sectapebackups"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>.
<P>
Floppy disk drives use still another naming scheme, which is described
on page&nbsp;<A HREF="node6.html#secbackfloppy"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>.
<P>
<H2><A NAME="SECTION00643000000000000000">4.4.3 Checking file systems.</A></H2>
 <A NAME="seccheckingfilesystem">&#160;</A>
<P>
It is usually a good idea to check your file systems for damaged or
corrupted files every now and then. Some systems automatically check
their file systems at boot time (with the appropriate commands in <TT>
/etc/rc</TT> or <TT>/etc/init.d/boot</TT>).
<P>
The command used to check a file system depends on the type of the
file system. For ext2fs file systems (the most commonly used type),
this command is <TT>e2fsck</TT>. For example, the command
<BR><IMG WIDTH=186 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen4835" SRC="img259.gif"><BR>
checks the ext2fs file system on <TT>/dev/hda2</TT> and automatically
corrects any errors.
<P>
It is usually a good idea to unmount a file system before checking it,
and necessary, if <TT>e2fsck</TT> is to perform any repairs on the file
system. The command
<BR><IMG WIDTH=152 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen4839" SRC="img260.gif"><BR>
unmounts the file system on <TT>/dev/hda2</TT>. The one exception is that
you cannot unmount the root file system. In order to check the root
file system when it's unmounted, you should use a maintenance
boot/root diskette (see page&nbsp;<A HREF="node6.html#secmaintdiskette"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>). You also
cannot unmount a file system if any of the files which it contains are
``busy''--that is, in use by a running process. For example, you
cannot unmount a file system if any user's current working directory
is on that file system. You will instead receive a ``<TT>Device
busy</TT>'' error message.
<P>
Other file system types use different forms of the <TT>e2fsck</TT>
command, like <TT>efsck</TT> and <TT>xfsck</TT>. On some systems, you can
simply use the command <TT>fsck</TT>, which automatically determines the
file system type and executes the appropriate command.
<P>
If e2fsck reports that it performed repairs on a
mounted file system, you <EM>must</EM> reboot the system immediately.
You should give the command <TT>shutdown -r</TT> to perform the
reboot. This allows the system to re-synchronize the information about
the file system after <TT>e2fsck</TT> modifies it.
<P>
The <TT>/proc</TT> file system never needs to be checked in this
manner. <TT>/proc</TT> is a memory file system and is managed directly by
the kernel.
<P>
<H1><A NAME="SECTION00650000000000000000">4.5 Using a swap file.</A></H1>
<A NAME="secswapfile">&#160;</A>
<P>
Instead of reserving a separate partition for swap space, you can use
a swap file. However, you need to install Linux and get everything
running before you create the swap file.
<P>
With Linux installed, you can use the following commands
to create a swap file. The command below creates a swap file of
size 8208 blocks (about 8 Mb).
<BR><IMG WIDTH=384 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen4858" SRC="img261.gif"><BR>
This command creates the swap file, <TT>/swap</TT>. The ``<TT>count=</TT>''
parameter is the size of the swap file in blocks.
<BR><IMG WIDTH=161 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen4862" SRC="img262.gif"><BR>
This command initializes the swap file. Again, replace the name and
size of the swapfile with the appropriate values.
<BR><IMG WIDTH=118 HEIGHT=34 ALIGN=BOTTOM ALT="tscreen4864" SRC="img263.gif"><BR>
Now the system is swapping on the file <TT>/swap</TT>. The <TT>
sync</TT> command ensures that the file has been written to disk.
<P>
One major drawback to using a swap file is that all access to the swap
file is done through the file system. This means the blocks which make
up the swap file may not be contiguous. Performance may not be as good
as a swap partition, where the blocks are always contiguous and I/O
requests are made directly to the device.
<P>
Another drawback of large swap files is the greater chance that the
file system will be corrupted if something goes wrong. Keeping the
regular file systems and swap partitions separate prevents this from
happening.
<P>
Swap files can be useful if you need to use more swap space
temporarily. If you're compiling a large program and would like to
speed things up somewhat, you can create a temporary swap file and use
it in addition to the regular swap space.
<P>
To remove a swap file, first use <TT>swapoff</TT>, as in 
<BR><IMG WIDTH=127 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen4869" SRC="img264.gif"><BR>
Then the file can be deleted.
<BR><IMG WIDTH=84 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen4871" SRC="img265.gif"><BR>
<P>
Each swap file or partition may be as large as 16 megabytes, but you
may use up to 8 swap files or partitions on your system.
<P>
<H1><A NAME="SECTION00660000000000000000">4.6 Managing users.</A></H1>
<A NAME="secmanageusers">&#160;</A><A NAME="secadduser">&#160;</A>
<P>
Even if you're the only user on your system, it's important to
understand the aspects of user management under Linux. You should at
least have an account for yourself (other than <TT>root</TT>) to do most
of your work.
<P>
	Each user should have his or her own account. It is seldom a
	good idea to have several people share the same
	account. Security an issue, and accounts uniquely identify
	users to the system. You must be able to keep track of who is
	doing what.
<P>
<H2><A NAME="SECTION00661000000000000000">4.6.1 User management concepts.</A></H2>
<P>
The system keeps track of the following information about each user:
<BR><IMG WIDTH=576 HEIGHT=468 ALIGN=BOTTOM ALT="dispitems4880" SRC="img266.gif"><BR>
<P>
This information is stored in the file <TT>/etc/passwd</TT>. Each line
in the file has the format
<BR><IMG WIDTH=436 HEIGHT=34 ALIGN=BOTTOM ALT="tscreen4901" SRC="img267.gif"><BR>
An example might be
<BR><IMG WIDTH=274 HEIGHT=31 ALIGN=BOTTOM ALT="tscreen4903" SRC="img268.gif"><BR>
In this example, the first field, ``<TT>kiwi</TT>,'' is the user name.
<P>
The next field, ``<TT>Xv8Q981g71oKK</TT>'', is the encrypted password.
Passwords are not stored on the system in human-readable format. The
password is encrypted using itself as the secret key. In other words,
one must know the password in order to decrypt it. This form of
encryption is reasonably secure.
<P>
Some systems use ``shadow passwords,'' in which password information
is stored in the file <TT>/etc/shadow</TT>. Because <TT>/etc/passwd</TT> is
world-readable, <TT>/etc/shadow</TT> provides some degree of extra
security because its access permissions are much more
restricted. Shadow passwords also provide other features, like password
expiration.
<P>
The third field, ``<TT>102</TT>'', is the UID. This must be unique for
each user. The fourth field, ``<TT>100</TT>'', is the GID. This user
belongs to the group numbered 100. Group information is stored in the
file <TT>/etc/group</TT>. See Section&nbsp;<A HREF="node6.html#secmanagegroups">4.6.5</A> for more
information.
<P>
The fifth field is the user's full name, ``<TT>Laura Poole</TT>''. The
last two fields are the user's home directory (<TT>/home/kiwi</TT>), and
login shell (<TT>/bin/bash</TT>), respectively. It is not required that
the user's home directory be given the same name as the user name. It
simply helps identify the directory.
<P>
<H2><A NAME="SECTION00662000000000000000">4.6.2 Adding users.</A></H2>
<P>
When adding users, several steps must be taken. First, the user is
given an entry in <TT>/etc/passwd</TT>, with a unique user name and
UID. The GID, full name, and other information must be specified. The
user's home directory must be created, and the permissions on the
directory set so that the user owns the directory. Shell
initialization files must be installed in the home directory, and
other files must be configured system-wide (for example, a spool for
the user's incoming e-mail).
<P>
It is not difficult to add users by hand, but when you are running a
system with many users, it is easy to forget something. The easiest
way to add users is to use an interactive program which updates all of
the system files automatically. The name of this program is <TT>
useradd</TT> or <TT>adduser</TT>, depending on what software is installed.
<P>
The <TT>adduser</TT> command takes its information from the file <TT>
/etc/adduser.conf</TT>, which defines a standard, default configuration
for all new users.
<P>
A typical <TT>/etc/adduser.conf</TT> file is shown below. 
<BR><IMG WIDTH=600 HEIGHT=869 ALIGN=BOTTOM ALT="tscreen4924" SRC="img269.gif"><BR>
<P>
In addition to defining preset variables that the <TT>adduser</TT>
command uses, <TT>/etc/adduser.conf</TT> also specifies where default
system configuration files for each user are located. In this
example, they are located in the directory <TT>/etc/skel</TT>, as defined
by the <TT>SKEL=</TT> line, above. Files which are placed in this
directory, like a system-wide, default <TT>.profile</TT>, <TT>.tcshrc</TT>,
or <TT>.bashrc</TT> file, will be automatically installed in a new user's
home directory by the <TT>adduser</TT> command.
<P>
<H2><A NAME="SECTION00663000000000000000">4.6.3 Deleting users.</A></H2>
<P>
Deleting users can be accomplished with the commands <TT>userdel</TT> or
<TT>deluser</TT>, depending on the software installed on the system.
<P>
If you'd like to temporarily ``disable'' a user from logging in to the
system without deleting his or her account, simply prepend an asterisk
(``<TT>*</TT>'') to the password field in <TT>/etc/passwd</TT>. For example,
changing <TT>kiwi</TT>'s <TT>/etc/passwd</TT> entry to
<BR><IMG WIDTH=283 HEIGHT=31 ALIGN=BOTTOM ALT="tscreen4941" SRC="img270.gif"><BR>
prevents <TT>kiwi</TT> from logging in.
<P>
<H2><A NAME="SECTION00664000000000000000">4.6.4 Setting user attributes.</A></H2>
<P>
After you have created a user, you may need to change attributes for
that user, like the home directory or password. The easiest way to do
this is to change the values directly in <TT>/etc/passwd</TT>. To set a
user's password, use <TT>passwd</TT>. The command
<BR><IMG WIDTH=118 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen4947" SRC="img271.gif"><BR>
will change <TT>larry</TT>'s password. Only <TT>root</TT> may change other
users' passwords in this manner. Users can change their own passwords,
however.
<P>
On some systems, the commands <TT>chfn</TT> and <TT>chsh</TT> allow users to
set their own full name and login shell attributes. If not, the system
administrator must change these attributes for them.
<P>
<H2><A NAME="SECTION00665000000000000000">4.6.5 Groups.</A></H2>
<A NAME="secmanagegroups">&#160;</A>
<P>
As mentioned above, each user belongs to one or more groups. The only
real importance of group relationships pertains to file permissions.
As you'll recall from Section&nbsp;<A HREF="node5.html#secperms">3.10</A>, each file has a ``group
ownership'' and a set of group permissions which defines how users in
that group may access the file.
<P>
There are several system-defined groups, like <TT>bin</TT>, <TT>mail</TT>,
and <TT>sys</TT>. Users should not belong to any of these groups; they
are used for system file permissions. Instead, users should belong to
an individual group like <TT>users</TT>. You can also maintain several
groups for users, like <TT>student</TT>, <TT>staff</TT>, and <TT>faculty</TT>.
<P>
The file <TT>/etc/group</TT> contains information about groups. 
The format of each line is
<BR><IMG WIDTH=316 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen4964" SRC="img272.gif"><BR>
Some example groups might be:
<BR><IMG WIDTH=179 HEIGHT=74 ALIGN=BOTTOM ALT="tscreen4966" SRC="img273.gif"><BR>
The first group, <TT>root</TT>, is a special system group reserved for
the <TT>root</TT> account. The next group, <TT>users</TT>, is for regular
users. It has a GID of 100. The users <TT>mdw</TT> and <TT>larry</TT>
are given access to this group. Remember that in <TT>/etc/passwd</TT>
each user was given a default GID. However, users may belong to 
more than one group, by adding their user names to other group lines
in <TT>/etc/group</TT>. The <TT>groups</TT> command lists what groups you
are given access to.
<P>
The third group, <TT>guest</TT>, is for guest users, and <TT>other</TT>
is for ``other'' users. The user <TT>kiwi</TT> is given access to this
group as well.
<P>
The ``password'' field of <TT>/etc/group</TT> is sometimes used to set a
password on group access. This is seldom necessary. To protect users
from changing into privileged groups (with the <TT>newgroup</TT>
command), set the password field to ``<TT>*</TT>''.
<P>
The commands <TT>addgroup</TT> or <TT>groupadd</TT> may be used to
add groups to your system. Usually, it's easier just to add
entries in <TT>/etc/group</TT> yourself, as no other configuration
needs to be done to add a group. To delete a group, simply delete
its entry in <TT>/etc/group</TT>.
<P>
<H2><A NAME="SECTION00666000000000000000">4.6.6 System administration responsibilities.</A></H2>
<P>
Because the system administrator has so much power and responsibility,
when some users have their first opportunity to login as <TT>root</TT>.
either on a Linux system or elsewhere, the tendency is to abuse <TT>
root</TT>'s privileges. I have known so-called ``system administrators''
who read other users' mail, delete users' files without warning, and
generally behave like children when given such a powerful ``toy''.
<P>
Because the administrator has such power on the system, it takes a
certain amount of maturity and self-control to use the <TT>root</TT>
account as it was intended--to run the system. There is an unspoken
code of honor which exists between the system administrator and the
users on the system. How would you feel if your system administrator
was reading your e-mail or looking over your files? There is still no
strong legal precedent for electronic privacy on time-sharing computer
systems. On UNIX systems, the <TT>root</TT> user has the ability to
forego all security and privacy mechanisms on the system. It is
important that the system administrator develop a trusting
relationship with his or her users. I can't stress that enough.
<P>
<H2><A NAME="SECTION00667000000000000000">4.6.7 Coping with users.</A></H2>
<P>
System administrators can take two stances when dealing with abusive
users: they can be either paranoid or trusting. The paranoid system
administrator usually causes more harm than he or she prevents. One of
my favorite sayings is, ``Never attribute to malice anything which can
be attributed to stupidity.'' Put another way, most users don't have
the ability or knowledge to do real harm on the system. Ninety
percent of the time, when a user is causing trouble on the system (for
instance, by filling up the user partition with large files, or
running multiple instances of a large program), the user is simply
unaware that he or she is creation a problem. I have come down on
users who were causing a great deal of trouble, but they were simply
acting out of ignorance--not malice.
<P>
When you deal with users who cause potential trouble, don't be
accusatory. The burden of proof is on you; that is, the rule of
``innocent until proven guilty'' still holds. It is best to simply
talk to the user and question him or her about the trouble instead of
being confrontational. The last thing you want is to be on the user's
bad side. This will raise a lot of suspicion about you--the system
administrator--running the system correctly. If a user believes that
you distrust or dislike them, they might accuse you of deleting files
or breaching privacy on the system. This is certainly not the kind of
position you want to be in.
<P>
If you find that a user is attempting to ``crack,'' or otherwise
intentionally do harm to the system, don't return the malicious
behavior with malice of your own. Instead, provide a warning, but be
flexible. In many cases, you may catch a user ``in the act'' of doing
harm to the system. Give them a warning. Tell them not to let it
happen again. However, if you <EM>do</EM> catch them causing harm
again, be absolutely sure that it is intentional. I can't even begin
to describe the number of cases where it appeared as though a user was
causing trouble, when in fact it was either an accident or a fault of
my own.
<P>
<H2><A NAME="SECTION00668000000000000000">4.6.8 Setting the rules.</A></H2>
<P>
The best way to run a system is not with an iron fist. That may be how
you run the military, but Linux is not designed for such discipline.
It makes sense to lay down a few simple and flexible guidelines. The
fewer rules you have, the less chance there is of breaking them. Even
if your rules are perfectly reasonable and clear, users will still at
times break them without intending to. This is especially true of new
users learning the ropes of the system. It is not patently obvious
that you shouldn't download a gigabyte of files and mail them to
everyone on the system. Users need help to understand the rules and
why they are there.
<P>
If you do specify usage guidelines for your system, make sure also
that the rationale for a particular guideline is clear. If you don't,
users will find all sorts of creative ways to get around the rule, and
not know that they are breaking it.
<P>
<H2><A NAME="SECTION00669000000000000000">4.6.9 What it all means.</A></H2>
<P>
We don't tell you how to run your system down to the last detail. That
depends on how you're using the system. If you have many users, things
are much different than if you have only a few users, or if you're the
only user on the system. However, it's always a good idea--in any
situation--to understand what being the system administrator <EM>
really</EM> means.
<P>
Being the system administrator doesn't make a Linux wizard. There are
many administrators who know very little about Linux. Likewise, many
``normal'' users know more about Linux than any system
administrator. Also, being the system administrator does not allow one
to use malice against users. Just because the system gives
administrators the ability to mess with user files does not mean that
he or she has a right to do so.
<P>
Being the system administrator is not a big deal. It doesn't matter if
your system is a tiny 386 or a Cray supercomputer. Running the system
is the same, regardless. Knowing the <TT>root</TT> password isn't going
to earn you money or fame. It will allow you to maintain the system
and keep it running. That's it.
<P>
<H1><A NAME="SECTION00670000000000000000">4.7 Archiving and compressing files.</A></H1>
<P>
Before we can talk about backups, we need to introduce the tools used
to archive files on UNIX systems.
<P>
<H2><A NAME="SECTION00671000000000000000">4.7.1 Using <TT>tar</TT>.</A></H2>
<P>
The <TT>tar</TT> command is most often used to archive files. Its
command syntax is
<P>
<BR><IMG WIDTH=109 HEIGHT=13 ALIGN=BOTTOM ALT="tscreen5009" SRC="img274.gif"><BR>
where <i>options</i> is the list of commands and options for <TT>tar</TT>,
and <i>files</i> is the list of files to 
add or extract from the archive.
<P>
For example, the command
<BR><IMG WIDTH=213 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen5016" SRC="img275.gif"><BR>
packs all of the files in <TT>/etc</TT> into the tar archive <TT>
backup.tar</TT>. The first argument to <TT>tar</TT>, ``<TT>cvf</TT>'', is the
<TT>tar</TT> ``command.'' <TT>c</TT> tells <TT>tar</TT> to create a new archive
file. <TT>v</TT> forces <TT>tar</TT> to use verbose mode, printing each file
name as it is archived. The ``<TT>f</TT>'' option tells <TT>tar</TT> that
the next argument, <TT>backup.tar</TT>, is the name of the archive to
create. The rest of the arguments to <TT>tar</TT> are the file and
directory names to add to the archive.
<P>
The command
<BR><IMG WIDTH=171 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen5031" SRC="img276.gif"><BR>
will extract the tar file <TT>backup.tar</TT> in the current directory.
<P>
Old files with the same name are overwritten when
extracting files into an existing directory.
<P>
Before extracting tar files it is important to know where the files
should be unpacked. Let's say that you archive the following files:
<TT>/etc/hosts</TT>, <TT>/etc/group</TT>, and <TT>/etc/passwd</TT>. If you use
the command
<BR><IMG WIDTH=463 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen5037" SRC="img277.gif"><BR>
the directory name <TT>/etc/</TT> is added to the beginning of each file
name. In order to extract the files to the correct location, use
<BR><IMG WIDTH=171 HEIGHT=34 ALIGN=BOTTOM ALT="tscreen5040" SRC="img278.gif"><BR>
because files are extracted with the path name saved in the archive
file.
<P>
However, if you archive the files with the command
<BR><IMG WIDTH=240 HEIGHT=34 ALIGN=BOTTOM ALT="tscreen5042" SRC="img279.gif"><BR>
the directory name is not saved in the archive file. Therefore, you
need to ``<TT>cd /etc</TT>'' before extracting the files. As you can
see, how the tar file is created makes a large difference in where you
extract it. The command
<BR><IMG WIDTH=171 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen5045" SRC="img280.gif"><BR>
can be used to display a listing of the archive's files without
extracting them. You can see what directory the files in the archive
are stored relative to, and extract the archive in the correct
location.
<P>
<H2><A NAME="SECTION00672000000000000000">4.7.2 <TT>gzip</TT> and <TT>compress</TT>.</A></H2>
<P>
Unlike archiving programs for MS-DOS, <TT>tar</TT> does not automatically
compress files as it archives them. If you are archiving two, 1-megabyte
files, the resulting tar file is two megabytes in size. The <TT>gzip</TT>
command compresses a file (it need not be a tar file). The command
<BR><IMG WIDTH=170 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen5051" SRC="img281.gif"><BR>
compresses <TT>backup.tar</TT> and leaves you with <TT>backup.tar.gz</TT>, a
compressed version of the file. The <TT>-9</TT> switch tells <TT>gzip</TT>
to use the highest compression factor.
<P>
The <TT>gunzip</TT> command may be used to uncompress a gzipped file.
Equivalently, you may use ``<TT>gzip&nbsp;-d</TT>''.
<P>
<TT>gzip</TT> is a relatively new tool in the UNIX community. For many
years, the <TT>compress</TT> command was used instead. However, because
of several factors, including a software patent dispute against the
<TT>compress</TT> data compression algorithm, and the fact that <TT>gzip</TT>
is much more efficient, <TT>compress</TT> is being phased out.
<P>
Files that are output by <TT>compress</TT> end in ``<TT>.Z</TT>.'' <TT>
backup.tar.Z</TT> is the compressed version of <TT>backup.tar</TT>, while
<TT>backup.tar.gz</TT> is the gzipped version<A NAME="tex2html357" HREF="footnode.html#5115"><IMG  ALIGN=BOTTOM ALT="gif" SRC="foot_motif.gif"></A>. The
<TT>uncompress</TT> command is used to expand a <TT>compress</TT>ed file.
It is equivalent to ``<TT>compress&nbsp;-d</TT>.'' <TT>gunzip</TT> knows how to
handle <TT>compress</TT>ed files as well.
<P>
<H2><A NAME="SECTION00673000000000000000">4.7.3 Putting them together.</A></H2>
<P>
To archive a group of files and compress the result, use the commands:
<BR><IMG WIDTH=213 HEIGHT=34 ALIGN=BOTTOM ALT="tscreen5079" SRC="img282.gif"><BR>
The result is <TT>backup.tar.gz</TT>. To unpack this file, use the
reverse commands:
<BR><IMG WIDTH=186 HEIGHT=34 ALIGN=BOTTOM ALT="tscreen5082" SRC="img283.gif"><BR>
Always make sure that you are in the correct directory before
unpacking a tar file.
<P>
You can use some Linux cleverness to do this on one command line.
<BR><IMG WIDTH=366 HEIGHT=15 ALIGN=BOTTOM ALT="tscreen5084" SRC="img284.gif"><BR>
Here, we send the tar file to ``<TT>-</TT>'', which stands for <TT>
tar</TT>'s standard output. This is piped to <TT>gzip</TT>, which compresses
the incoming tar file. The result is saved in <TT>backup.tar.gz</TT>.
The <TT>-c</TT> option tells <TT>gzip</TT> to send its output to standard
output, which is redirected to <TT>backup.tar.gz</TT>.
<P>
A single command to unpack this archive would be:
<BR><IMG WIDTH=311 HEIGHT=15 ALIGN=BOTTOM ALT="tscreen5093" SRC="img285.gif"><BR>
Again, <TT>gunzip</TT> uncompresses the contents of <TT>backup.tar.gz</TT>
and sends the resulting tar file to standard output. This is piped to
<TT>tar</TT>, which reads ``<TT>-</TT>'', this time referring to <TT>tar</TT>'s
standard input.
<P>
Happily, the <TT>tar</TT> command also includes the <TT>z</TT> option to 
automatically compress/uncompress files on the fly, using the
<TT>gzip</TT> compression algorithm.
<P>
The command
<BR><IMG WIDTH=248 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen5103" SRC="img286.gif"><BR>
is equivalent to
<BR><IMG WIDTH=213 HEIGHT=34 ALIGN=BOTTOM ALT="tscreen5105" SRC="img287.gif"><BR>
Just as the command
<BR><IMG WIDTH=195 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen5107" SRC="img288.gif"><BR>
may be used instead of
<BR><IMG WIDTH=212 HEIGHT=34 ALIGN=BOTTOM ALT="tscreen5109" SRC="img289.gif"><BR>
<P>
Refer to the <TT>tar</TT> and <TT>gzip</TT> manual pages for more
information.
<P>
<H1><A NAME="SECTION00680000000000000000">4.8 Using floppies and making backups.</A></H1>
<P>
 <A NAME="secbackfloppy">&#160;</A>
 <A NAME="5120">&#160;</A>
 <A NAME="5121">&#160;</A>
Floppies are often used as backup media. If you don't have a tape
drive connected to your system, floppy disks can be used (although
they are slower and somewhat less reliable).
<P>
As mentioned earlier, floppy diskettes must be formatted with the
MS-DOS <TT>FORMAT.COM</TT> or the Linux <TT>fdformat</TT> program. This lays
down the sector and track information that is appropriate to the
floppy's capacity.
<P>
A few of the device names and formats of floppy disks which are
accessible by Linux are given in Table&nbsp;<A HREF="node6.html#tablediskformats">4.4</A>.
<P>
<P><A NAME="5130">&#160;</A><A NAME="tablediskformats">&#160;</A><IMG WIDTH=357 HEIGHT=78 ALIGN=BOTTOM ALT="table5125" SRC="img290.gif"><BR>
<STRONG>Table 4.4:</STRONG> Linux floppy disk formats.<BR>
<P>
<P>
Devices which begin with <TT>fd0</TT> are the first floppy diskette
drive, which is named the <TT>A:</TT> drive under MS-DOS. The driver
file names of second floppy device begin with <TT>fd1</TT>. Generally,
the Linux kernel can detect the format of a diskette that has already
been formatted--you can simply use <TT>/dev/fd0</TT> and let the system
detect the format. But when you first use completely new, unformatted
floppy disks, you may need to use the driver specification if the
system can't detect the diskette's type.
<P>
A complete list of Linux devices and their device driver names is
given in <EM>Linux Allocated Devices,</EM> by H. Peter Anvin (see
Appendix&nbsp;<A HREF="app-sources/node1.html">A</A>).
<P>
You can also use floppies to hold individual file systems and <TT>
mount</TT> the floppy to access the data on it. See section&nbsp;<A HREF="node6.html#secfloppy">4.8.4</A>.
<P>
<H2><A NAME="SECTION00681000000000000000">4.8.1 Using floppies for backups.</A></H2>
<P>
<A NAME="5143">&#160;</A>
<A NAME="5144">&#160;</A>
<A NAME="5145">&#160;</A>
The easiest way to make a backup using floppies is with <TT>tar</TT>. 
The command
<BR><IMG WIDTH=186 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen5147" SRC="img291.gif"><BR>
will make a complete backup of your system using the floppy drive <TT>
/dev/fd0</TT>. The ``<TT>M</TT>'' option to <TT>tar</TT> allows the backup to
span multiple volumes; that is, when one floppy is full, <TT>tar</TT>
will prompt for the next. The command
<BR><IMG WIDTH=170 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen5153" SRC="img292.gif"><BR>
restores the complete backup. This method can also be used with a 
tape drive connected to your system. See section&nbsp;<A HREF="node6.html#sectapebackups">4.8.3</A>.
<P>
<A NAME="5255">&#160;</A>
<A NAME="5256">&#160;</A>
Several other programs exist for making multiple-volume backups; the
<TT>backflops</TT> program found on <TT>tsx-11.mit.edu</TT> may come in handy.
<P>
Making a complete backup of the system with floppies can be time- and
resource-consuming. Many system administrators use an <B>
incremental backup</B> policy. Every month, a complete backup is made,
and every week only those files which have been modified in the last
week are backed up. In this case, if you trash your system in the
middle of the month, you can simply restore the last full monthly
backup, and then restore the last weekly backups as needed.
<P>
<A NAME="5161">&#160;</A>
<A NAME="5257">&#160;</A>
The <TT>find</TT> command is useful for locating files which were
modified after a certain date. Several scripts for managing
incremental backups can be found on <TT>sunsite.unc.edu</TT>.
<A NAME="5165">&#160;</A>
<A NAME="5166">&#160;</A>
<P>
<H2><A NAME="SECTION00682000000000000000">4.8.2 Backups with a Zip drive.</A></H2>
 <A NAME="seczipbackup">&#160;</A>
<P>
Making backups to a Zip drive is similar to making floppy backups, but
because Zip disks commonly have a capacity of 98 Kb, it is feasible to
use a single, mounted Zip disk for a single backup archive.
<P>
Zip drives are available with three different hardware interfaces: a
SCSI interface, an IDE interface
and a parallel port PPA interface. Zip drive support
is not included as a pre-compiled Linux option, but it can be
specified when building a custom kernel for your system.
Page&nbsp;<A HREF="node6.html#kernelppadriver"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A> describes the installation of an
Iomega Zip device driver.
<P>
The SCSI and PPA interface Zip drives use the SCSI interface and
follow the naming conventions for other SCSI devices, which are
described on page&nbsp;<A HREF="node6.html#devicedrivernames"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>.
<P>
Zip disks are commonly pre-formatted with a MS-DOS file system. You
can either use the existing MS-DOS filesystem, which must be supported
by your Linux kernel, or use <TT>mke2fs</TT> or a similar program to
write a Linux file system to the disk.
<P>
A Zip disk, when mounted as the first SCSI device, is <TT>/dev/sda4</TT>.
<BR><IMG WIDTH=186 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen5173" SRC="img293.gif"><BR>
<P>
It is often convenient to provide a separate mount point for Zip file
systems; for example, <TT>/zip</TT>. The following steps, which must be
executed as <TT>root</TT>, would create the mount point:
<BR><IMG WIDTH=145 HEIGHT=34 ALIGN=BOTTOM ALT="tscreen5177" SRC="img294.gif"><BR>
Then you can use <TT>/zip</TT> for mounting the Zip file system.
<P>
Writing archives to Zip disks is similar to archiving to floppies. To
archive and compress the <TT>/etc</TT> directory to a mounted Zip drive,
the command used would be
<BR><IMG WIDTH=239 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen5181" SRC="img295.gif"><BR>
<P>
This command could be executed from any directory because it specifies
absolute path names. The archive name <TT>etc.tgz</TT> is necessary if
the Zip drive contains a MS-DOS file system, because any files written
to the disk must have names which conform to MS-DOS's 8+3 naming
conventions; otherwise, the file names will be truncated.
<P>
Similarly, extracting this archive requires the commands
<BR><IMG WIDTH=195 HEIGHT=34 ALIGN=BOTTOM ALT="tscreen5184" SRC="img296.gif"><BR>
<P>
To create, for example, an ext2 file system on a Zip drive, you would
give the command (for an <EM>unmounted</EM> Zip disk)
<BR><IMG WIDTH=152 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen5187" SRC="img297.gif"><BR>
<P>
With a Zip drive mounted in this manner, with an ext2 file system, it
is possible to back up entire file systems with a single command.
<BR><IMG WIDTH=333 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen5189" SRC="img298.gif"><BR>
<P>
Note that backing up with <TT>tar</TT> is still preferable in many cases
to simply making an archival copy with the <TT>cp -a</TT> command,
because <TT>tar</TT> preserves the original files' modification times.
<P>
<H2><A NAME="SECTION00683000000000000000">4.8.3 Making backups to tape devices.</A></H2>
 <A NAME="sectapebackups">&#160;</A>
<P>
Archiving to a streaming tape drive is similar to making a backup to a
floppy file system, only to a different device driver. Tapes are also
formatted and handled differently that floppy diskettes. Some
representative tape device drivers for Linux systems are listed in
Table&nbsp;<A HREF="node6.html#tabletapedevices">4.5</A>.
<P>
<P><A NAME="5208">&#160;</A><A NAME="tabletapedevices">&#160;</A><IMG WIDTH=370 HEIGHT=138 ALIGN=BOTTOM ALT="table5197" SRC="img299.gif"><BR>
<STRONG>Table 4.5:</STRONG> Tape device drivers.<BR>
<P>
Floppy tape drives use the floppy drive controller interface and are
controlled by the ftape device driver, which is covered below.
Installation of the ftape device driver module is described on
page&nbsp;<A HREF="node6.html#ftapemodule"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>. SCSI tape devices are listed in
Table&nbsp;<A HREF="node6.html#tablescsidevices">4.3</A>.
<P>
To archive the <TT>/etc</TT> directory a tape device with <TT>tar</TT>, use 
the command
<BR><IMG WIDTH=205 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen5216" SRC="img300.gif"><BR>
<P>
Similarly, to extract the files from the tape, use the commands
<BR><IMG WIDTH=160 HEIGHT=34 ALIGN=BOTTOM ALT="tscreen5218" SRC="img301.gif"><BR>
<P>
These tapes, like diskettes, must be formatted before they can be used. The
ftape driver can format tapes under Linux. To format a QIC-40 format
tape, use the command
<BR><IMG WIDTH=454 HEIGHT=31 ALIGN=BOTTOM ALT="tscreen5220" SRC="img302.gif"><BR>
Other tape drives have their own formatting software. Check the
hardware documentation for the tape drive or the documentation of the
Linux device driver associated with it.
<P>
Before tapes can be removed from the drive, they must be rewound and
the I/O buffers written to the tape. This is analogous to unmounting
a floppy before ejecting it, because the tape driver also caches data
in memory. The standard UNIX command to control tape drive operations
is <TT>mt</TT>. Your system may not provide this command, depending on
whether it has tape drive facilities. The ftape driver has a similar
command, <TT>ftmt</TT>, which is used to control tape operations.
<P>
To rewind a tape before removing it, use the command
<BR><IMG WIDTH=229 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen5224" SRC="img303.gif"><BR>
Of course, substitute the correct tape device driver for your system.
<P>
It is also a good idea to retension a tape after writing to it,
because magnetic tapes are susceptible to stretch. The command
<BR><IMG WIDTH=248 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen5226" SRC="img304.gif"><BR>
<P>
To obtain the status of the tape device, with a formatted tape
in the drive, give the command
<BR><IMG WIDTH=220 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen5228" SRC="img305.gif"><BR><H2><A NAME="SECTION00684000000000000000">4.8.4 Using floppies as file systems.</A></H2>
<A NAME="secfloppy">&#160;</A>
 <A NAME="5232">&#160;</A>
 <A NAME="5233">&#160;</A>
 <A NAME="5258">&#160;</A>
You can create a file system on a floppy as you would on a hard
drive partition. For example,
<BR><IMG WIDTH=187 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen5235" SRC="img306.gif"><BR>
creates a file system on the floppy in <TT>/dev/fd0</TT>. The size of the
file system must correspond to the size of the floppy. High-density
3.5&quot; disks are 1.44 megabytes, or 1440 blocks, in size. High-density
5.25&quot; disks are 1200 blocks. It is necessary to specify the size of
the file system in blocks if the system cannot automatically detect
the floppy's capacity.
<P>
<A NAME="5259">&#160;</A>
In order to access the floppy, you must mount the file system
contained on it. The command
<BR><IMG WIDTH=178 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen5239" SRC="img307.gif"><BR>
will mount the floppy in <TT>/dev/fd0</TT> on the directory <TT>/mnt</TT>. 
Now, all of the files on the floppy will appear under <TT>/mnt</TT>
on your drive.
<P>
The <B>mount point</B>, the directory where you're mounting the file
system, must exist when you use the <TT>mount</TT> command. If it doesn't
exist, create it with <TT>mkdir</TT> as described on
page&nbsp;<A HREF="node6.html#seczipbackup"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>.
<P>
See page&nbsp;<A HREF="node6.html#secmanagefs"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A> for more information on file systems,
mounting, and mount points.
<P>
<A NAME="5249">&#160;</A>
<A NAME="5260">&#160;</A>
Note that any I/O to the floppy is buffered the same as hard 
disk I/O is. If you change data on the floppy, you may not see the
drive light come on until the kernel flushes its I/O buffers. It's
important that you not remove a floppy before you unmount it with the
command
<BR><IMG WIDTH=144 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen5251" SRC="img308.gif"><BR>
Do not simply switch floppies as you would on a MS-DOS system.
Whenever you change floppies, <TT>umount</TT> the first floppy and <TT>
mount</TT> the next.
<P>
<H1><A NAME="SECTION00690000000000000000">4.9 Upgrading and installing new software.</A></H1>
<P>
<A NAME="secsysadmupgrade">&#160;</A>
<P>
<A NAME="5265">&#160;</A>
<A NAME="5266">&#160;</A>
Another duty of the system administrator is the upgrading and
installation of new software.
<P>
Linux system development is rapid. New kernel releases appear every
few weeks, and other software is updated nearly as often. Because of
this, new Linux users often feel the need to upgrade their systems
constantly to keep up the the rapidly changing pace. This is
unnecessary and a waste of time. If you kept up with all of the
changes in the Linux world, you would spend all of your time upgrading
and none of your time using the system.
<P>
Some people feel that you should upgrade when a new distribution
release is made; for example, when Slackware comes out with a new
version. Many Linux users completely reinstall their system with the
newest Slackware release every time.
<P>
The best way to upgrade your system depends on the Linux distribution
you have. Debian, S.u.S.E., Caldera and Red Hat Linux all have intelligent
package management software which allows easy upgrades by installing a
new package. For example, the C compiler, <TT>gcc</TT>, comes in a
pre-built binary package. When it is installed, all of the files of
the older version are overwritten or removed.
<P>
For the most part, senselessly upgrading to ``keep up with the trend''
is not important at all. This isn't MS-DOS or Microsoft Windows.
There is no important reason to run the newest version of all of the
software. If you find that you would like or need features that a new
version offers, then upgrade. If not, don't upgrade. In other words,
upgrade only what you must, when you must. Don't upgrade for
the sake of upgrading. This wastes a lot of time and effort.
<P>
<H2><A NAME="SECTION00691000000000000000">4.9.1 Upgrading the kernel</A></H2>
<P>
<A NAME="5269">&#160;</A>
Upgrading the kernel is a matter of obtaining the kernel sources and
compiling them. This is generally a painless procedure, but you can
run into problems if you try to upgrade to a development kernel, or
upgrade to a new kernel version. The version of a kernel has two
parts, the kernel version and patchlevel. As of the time of this
writing, the latest stable kernel is version <TT>2.0.33</TT>. The <TT>
2.0</TT> is the kernel version and <TT>33</TT> is the patch level.
Odd-numbered kernel versions like <TT>2.1</TT> are development kernels.
Stay away from development kernels unless you want to live
dangerously! As a general rule, you should be able to upgrade easily
to another patch level, but upgrading to a new version requires the
upgrade of system utilities which interact closely with the kernel.
<P>
<A NAME="5274">&#160;</A>
The Linux kernel sources may be retrieved from any of the Linux FTP
sites (see page&nbsp;<A HREF="app-ftp/node1.html"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A> for a list). On <TT>
sunsite.unc.edu</TT>, for instance, the kernel sources are found in <TT>
/pub/Linux/kernel</TT>, organized into subdirectories by version number.
<P>
Kernel sources are released as a gzipped tar file. For example, the
file containing the 2.0.33 kernel sources is <TT>linux-2.0.33.tar.gz</TT>.
<P>
Kernel sources are unpacked in the <TT>/usr/src</TT> directory, creating
the directory <TT>/usr/src/linux</TT>. It is common practice for <TT>
/usr/src/linux</TT> to be a soft link to another directory which contains
the version number, like <TT>/usr/src/linux-2.0.33</TT>. This way, you
can install new kernel sources and test them out before removing the
old kernel sources. The commands to create the kernel directory link
are
<BR><IMG WIDTH=247 HEIGHT=99 ALIGN=BOTTOM ALT="tscreen5283" SRC="img309.gif"><BR>
<P>
When upgrading to a newer patchlevel of the same kernel version,
kernel patch files can save file transfer time because the kernel
source is around 7MB after being compressed by <TT>gzip</TT>. To upgrade
from kernel 2.0.31 to kernel 2.0.33, you would download the patch
files <TT>patch-2.0.32.gz</TT> and <TT>patch-2.0.33.gz</TT>, which can be
found at the same FTP site as the kernel sources. After you have
placed the patches in the <TT>/usr/src</TT> directory, apply the patches
to the kernel in sequence to update the source. One way to do this
would be 
<BR><IMG WIDTH=319 HEIGHT=57 ALIGN=BOTTOM ALT="tscreen5289" SRC="img310.gif"><BR>
After the sources are unpacked and any patches have been applied, you
need to make sure that three symbolic links in <TT>/usr/include</TT> are
correct for your kernel distribution. To create these links use the
commands
<BR><IMG WIDTH=369 HEIGHT=96 ALIGN=BOTTOM ALT="tscreen5292" SRC="img311.gif"><BR>
After you create the links, there is no reason to create them again
when you install the next kernel patch or a newer kernel version.
(See Section&nbsp;<A HREF="node5.html#secmanagelinks">3.11</A> for more about symbolic links.)
<P>
<A NAME="5295">&#160;</A>
In order to compile the kernel, you must have the <TT>gcc</TT> C compiler
installed on your system. <TT>gcc</TT> version 2.6.3 or a more recent
version is required to compile the 2.0 kernel.
<P>
First <TT>cd</TT> to <TT>/usr/src/linux</TT>. The command <TT>make config</TT>
prompts you for a number of configuration options. This is the step
where you select the hardware that your kernel will support. The
biggest mistake to avoid is not including support for your hard disk
controller. Without the correct hard disk support in the kernel, the
system won't even boot. If you are unsure about what a kernel
option means, a short description is available by pressing
? and Enter.
<P>
Next, run the command <TT>make dep</TT> to update all of the source
dependencies. This is an important step. <TT>make clean</TT> removes old
binary files from the kernel source tree.
<P>
<A NAME="5305">&#160;</A>
The command <TT>make zImage</TT> compiles the kernel and writes it to
<TT>/usr/src/linux/arch/i386/boot/zImage</TT>. Linux kernels on Intel
systems are always compressed. Sometimes the kernel you want to
compile is too large to be compressed with the compression system that
<TT>make zImage</TT> uses. A kernel which is too large will exit the
kernel compile with the error message: <TT>Kernel Image Too Large</TT>.
If this happens, try the command <TT>make bzImage</TT>, which uses a
compression system that supports larger kernels. The kernel is
written to <TT>/usr/src/linux/arch/i386/boot/bzImage</TT>.
<P>
Once you have the kernel compiled, you need to either copy it to a
boot floppy (with a command like ``<TT>cp zImage /dev/fd0</TT>'') or
install the image so LILO will boot from your hard drive. See
page&nbsp;<A HREF="node6.html#seclilo"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A> for more information.
<P>
<H2><A NAME="SECTION00692000000000000000">4.9.2 Adding a device driver to the kernel.</A></H2>
<P>
<A NAME="kernelppadriver">&#160;</A>
<P>
Page&nbsp;<A HREF="node6.html#seczipbackup"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A> describes how to use an Iomega Zip drive
to make backups. Support for the Iomega Zip drive, like many other
devices, is not generally compiled into stock Linux distribution
kernels--the variety of devices is simply too great to support all of
them in a usable kernel. However, the source code for the Zip
parallel port device driver is included as part of the kernel source
code distribution. This section describes how to add support for an
Iomega Zip parallel port drive and have it co-exist with a printer
connected to a different parallel port.
<P>
You must have installed and sucessfully built a custom Linux kernel,
as described in the previous section.
<P>
Selecting the Zip drive <TT>ppa</TT> device as a kernel option requires
that you answer <TT>Y</TT> to the appropriate questions during the <TT>
make config</TT> step, when you determine the configuration of the custom
kernel. In particular, the <TT>ppa</TT> device requires answering ``<TT>
Y</TT>'' to three options:
<BR><IMG WIDTH=471 HEIGHT=56 ALIGN=BOTTOM ALT="tscreen5322" SRC="img312.gif"><BR>
<P>
After you have sucessfully run <TT>make config</TT> with all of the
support options you want included in the kernel, then run <TT>make
dep</TT>, <TT>make clean</TT>, and <TT>make zImage</TT> to build the kernel, you
must tell the kernel how to install the driver. This is done via a
command line to the LILO boot loader. As described in
section&nbsp;<A HREF="node6.html#seclilo">4.2.1</A>, the LILO configuration file, <TT>
/etc/lilo.conf</TT> has ``stanzas'' for each operating system that it
knows about, and also directives for presenting these options to the
user at boot time.
<P>
Another directive that LILO recognizes is ``<TT>append=</TT>'', which
allows you to add boot-time information required by various device
drivers to the command line. In this case, the Iomega Zip <TT>ppa</TT>
driver requires an unused interrupt and I/O port address. This is
exactly analogous to specifying separate printer devices like <TT>
LPT1:</TT> and <TT>LPT2:</TT> under MS-DOS.
<P>
For example, if your printer uses the hexadecimal (base 16) port
address <TT>0x378</TT> (see the installation manual for your parallel
port card if you don't know what the address is) and is polled (that
is, it doesn't require an IRQ line, a common Linux configuration), you
would place the following line in your system's <TT>/etc/lilo.conf</TT>
file:
<BR><IMG WIDTH=160 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen5336" SRC="img313.gif"><BR>
It is worth noting that Linux automatically recognizes one <TT>/dev/lp</TT>
port at boot time, but when specifying a custom port configurations,
the boot-time instructions are needed.
<P>
The ``<TT>0</TT>'' after the port address tells the kernel <EM>not</EM> to
use a IRQ (interrupt request) line for the printer. This is generally
acceptable because printers are much slower than CPUs, so a slower
method of accessing I/O devices, known as <B>polling</B>, where the
kernel periodically checks the printer status on its own, still allows
the computer to keep up with the printer.
<P>
However, devices that operate at higher speeds, like serial lines and
disks, each require an <B>IRQ,</B> or <B>interrupt request,</B> line.
This is a hardware signal sent by the device to the processor whenever
the device requires the processor's attention; for example, if the
device has data waiting to be input to the processor. The processor
stops whatever it is doing and handles the interrupt request of the
device. The Zip drive <TT>ppa</TT> device requires a free interrupt,
which must correspond to the interrupt that is set on the printer card
that you connect the Zip drive to. At the time of this writing, the
Linux <TT>ppa</TT> device driver does not support ``chaining'' of
parallel port devices, and separate parallel ports must be used for
the Zip <TT>ppa</TT> device and each printer.
<P>
To determine which interrupts are already in use on your system, the
command
<BR><IMG WIDTH=178 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen5347" SRC="img314.gif"><BR>
displays a list of devices and the IRQ lines they use. However, you
also need to be careful not to use any automatically configured serial
port interrupts as well, which may not be listed in the <TT>
/proc/interrupt</TT> file. The Linux Documentation Project's Serial
HOWTO, available from the sources listed in
Appendix&nbsp;<A HREF="app-sources/node1.html">A</A>, describes in detail the configuration
of serial ports.
<P>
You should also check the hardware settings of various 
interface cards on your machine by opening the machine's case and
visually checking the jumper settings if necessary, to ensure that you
are not co-opting an IRQ line that is already in use by another
device. Multiple devices fighting for an interrupt line is perhaps
the single most common cause of non-functioning Linux systems.
<P>
A typical <TT>/proc/interrupt</TT> file looks like
<BR><IMG WIDTH=160 HEIGHT=118 ALIGN=BOTTOM ALT="tscreen5352" SRC="img315.gif"><BR>
The first column is of interest here. These are the numbers of the
IRQ lines that are in use on the system. For the <TT>ppa</TT> driver, we
want to choose a line which is <EM>not</EM> listed. IRQ 7 is often a
good choice, becuase it is seldom used in default system
configurations. We also need to specify the port address which the
<TT>ppa</TT> device will use. This address needs to be physically
configured on the interface card. Parallel I/O ports are assigned
specific addresses, so you will need to read the documentation for
your parallel port card. In this example, we will use the I/O port
address <TT>0x278</TT>, which corresponds to the LPT2: printer port
under MS-DOS. Adding both the IRQ line and port address to our
boot-time command line, above, yields the following statement as it
would appear in the appropriate stanza of the <TT>/etc/lilo.conf</TT>
file:
<BR><IMG WIDTH=263 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen5360" SRC="img316.gif"><BR>
<P>
These statements are appended to the kernel's start-up parameters at
boot time. They ensure that any printer attached to the system does
not interfere with the Zip drive's operation. Of course, if your
system does not have a printer installed, the ``<TT>lp=</TT>'' directive
can, and should, be omitted.
<P>
After you have installed the custom kernel itself, as described in
section&nbsp;<A HREF="node6.html#seclilo">4.2.1</A>, and before you reboot the system, be sure to
run the command
<BR><IMG WIDTH=101 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen4602" SRC="img245.gif"><BR>
to install the new LILO configuration on the hard drive's boot sector.
<P>
<H2><A NAME="SECTION00693000000000000000">4.9.3 Installing a device driver module.</A></H2>
<P>
<A NAME="ftapemodule">&#160;</A>
<P>
Page&nbsp;<A HREF="node6.html#sectapebackups"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A> describes how to back up files to a
tape drive. Linux provides support for a variety of tape drives with
IDE, SCSI, and some proprietary interfaces. Another common type of
tape drive connects directly to the floppy drive controller. Linux
provides the ftape device driver as a module.
<P>
At the time of this writing, the most recent version of ftape is
3.04d. You can retrieve the package from the <TT>sunsite.unc.edu</TT>
FTP archive (see Appendix&nbsp;<A HREF="app-ftp/node1.html">B</A> for instructions). The ftape
archive is located in <TT>/pub/Linux/kernel/tapes</TT>. Be sure to get
the most recent version. At the time of this writing, this is <TT>
ftape-3.04d.tar.gz</TT>.
<P>
After unpacking the ftape archive in the <TT>/usr/src</TT> directory,
typing <TT>make install</TT> in the top-level ftape directory will
compile the ftape driver modules and utilities, if necessary, and
install them. If you experience compatibility problems with the ftape
executable distribution files and your system kernel or libraries,
executing the commands <TT>make&nbsp;clean</TT> and <TT>make&nbsp;install</TT> will
ensure that the modules are compiled on your system.
<P>
To use this version of the ftape driver, you must have
module support compiled into the kernel, as well as support for the
<TT>kerneld</TT> kernel daemon. However, you must <EM>not</EM> include the
kernel's built-in ftape code as a kernel option, as the more recent
ftape module completely replaces this code.
<P>
<TT>make install</TT> also installs the device driver modules in the
correct directories. On standard Linux systems, modules are located
in the directory
<BR><IMG WIDTH=192 HEIGHT=10 ALIGN=BOTTOM ALT="tscreen5380" SRC="img317.gif"><BR>
If your kernel version is 2.0.30, the modules on your system are
located in <TT>/lib/modules/2.0.30</TT>. The <TT>make install</TT> step
also insures that these modules are locatable by adding the
appropriate statements to the <TT>modules.dep</TT> file, located in the
top-level directory of the module files, in this case <TT>
/lib/modules/2.0.30</TT>. The ftape installation adds the following
modules to your system (using kernel version 2.0.30 in this example):
<BR><IMG WIDTH=351 HEIGHT=56 ALIGN=BOTTOM ALT="tscreen5387" SRC="img318.gif"><BR>
<P>
The instructions to load the modules also need to be added to the
system-wide module configuration file. This is the file <TT>
/etc/conf.modules</TT> on many systems. To automatically load the ftape
modules on demand, add the following lines to the <TT>
/etc/conf.modules</TT> file:
<BR><IMG WIDTH=281 HEIGHT=34 ALIGN=BOTTOM ALT="tscreen5391" SRC="img319.gif"><BR>
The first statement loads all of the ftape related modules if
necessary when a device with the major number 27 (the ftape device) is
accessed by the kernel. Because support for the zftape module (which
provides automatic data compression for tape devices) requires the
support of the other ftape modules, all of them are loaded on demand
by the kernel. The second line specifies load-time
parameters for the modules. In this case, the utility <TT>
/sbin/swapout</TT>, which is provided with the ftape package, ensures that
sufficient DMA memory is available for the ftape driver to function.
<P>
To access the ftape device, you must first place a formatted tape in
the drive. Instructions for formatting tapes and operation of the
tape drive are given in section&nbsp;<A HREF="node6.html#sectapebackups">4.8.3</A>.
<P>
<H2><A NAME="SECTION00694000000000000000">4.9.4 Upgrading the libraries.</A></H2>
<A NAME="secupgradelibs">&#160;</A>
<A NAME="5397">&#160;</A>
As mentioned before, most of the software on the system is compiled
to use shared libraries, which contain common subroutines shared
among different programs.
<P>
If you see the message
<BR><IMG WIDTH=238 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen5398" SRC="img320.gif"><BR>
when attempting to run a program, then you need to upgrade to the
version of the libraries which the program requires. Libraries are
backwardly compatible. A program compiled to use an older version of
the libraries should work with the new version of the libraries
installed. However, the reverse is not true.
<P>
The newest version of the libraries can be found on Linux FTP sites.
On <TT>sunsite.unc.edu</TT>, they are located in <TT>/pub/Linux/GCC</TT>.
The ``release'' files there should explain what files you need to
download and how to install them. Briefly, you should get the files
<TT>image-<EM>version</EM>.tar.gz</TT> and <TT>inc-<EM>version</EM>.tar.gz</TT>
where <EM>version</EM> is the version of the libraries to install, such
as <TT>4.4.1</TT>. These are tar files compressed with <TT>gzip</TT>. The
<TT>image</TT> file contains the library images to install in <TT>/lib</TT>
and <TT>/usr/lib</TT>. The <TT>inc</TT> file contains include files to
install in <TT>/usr/include</TT>
<P>
The <TT>release-</TT><EM>version</EM><TT>.tar.gz</TT> should explain the
installation procedure in detail (the exact instructions vary with
each release). In general, you need to install the library's <TT>.a</TT>
and <TT>.sa</TT> files in <TT>/usr/lib</TT>. These are the libraries used at
compilation time.
<P>
In addition, the shared library image files,
<TT>libc.so.</TT><EM>version</EM> are installed in <TT>/lib</TT>. These
are the shared library images loaded at run time by programs
using the libraries. Each library has a symbolic link using the major
version number of the library in <TT>/lib</TT>.
<P>
The <TT>libc</TT> library version 4.4.1 has a major version number of
<TT>4</TT>. The file containing the library is <TT>libc.so.4.4.1</TT>. A
symbolic link of the name <TT>libc.so.4</TT> is also placed in <TT>/lib</TT>
pointing to the library. You must change this symbolic link when
upgrading the libraries. For example, when upgrading from <TT>
libc.so.4.4</TT> to <TT>libc.so.4.4.1</TT>, you need to change the symbolic
link to point to the new version.
<P>
You must change the symbolic link
in one step, as described below. If you delete the symbolic
link <TT>libc.so.4</TT>, then programs which depend on the link
(including basic utilities like <TT>ls</TT> and <TT>cat</TT>) will stop
working. Use the following command to update the symbolic link <TT>
libc.so.4</TT> to point to the file <TT>libc.so.4.4.1</TT>:
<BR><IMG WIDTH=358 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen5434" SRC="img321.gif"><BR>
You also need to change the symbolic link <TT>libm.so.</TT><EM>version</EM>
in the same manner. If you are upgrading to a different version of the
libraries, substitute the appropriate file names, above. The library
release notes should explain the details. (See
page&nbsp;<A HREF="node5.html#secmanagelinks"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A> for more information about symbolic
links.)
<P>
<H2><A NAME="SECTION00695000000000000000">4.9.5 Upgrading <TT>gcc</TT>.</A></H2>
<A NAME="secupgradegcc">&#160;</A>
<A NAME="5466">&#160;</A>
The <TT>gcc</TT> C and C++ compiler is used to compile software on your
system, most importantly the kernel. The newest version of <TT>gcc</TT>
is found on the Linux FTP sites. On <TT>sunsite.unc.edu</TT>, it is
found in the directory <TT>/pub/Linux/GCC</TT> (along with the libraries).
There should be a <TT>release</TT> file for the <TT>gcc</TT> distribution
detailing what files you need to download and how to install them.
Most distributions 
have upgrade versions that work with their package management
software. In general, these packages are much easier to install than
``generic'' distributions.
<P>
<H2><A NAME="SECTION00696000000000000000">4.9.6 Upgrading other software.</A></H2>
<P>
Upgrading other software is often simply a matter of downloading the
appropriate files and installing them. Most software for Linux is
distributed as compressed tar files that include sources, binaries, or
both. If binaries are not included in the release, you may need to
compile them yourself. This means at least typing <TT>make</TT> in the
directory where the sources are located.
<P>
<A NAME="5450">&#160;</A>
Reading the Usenet newsgroup <TT>comp.os.linux.announce</TT> for
announcements of new software releases is the easiest way to find out
about new software. Whenever you are looking for software on an FTP
site, downloading the <TT>ls-lR</TT> index file from the FTP site and
using <TT>grep</TT> to find the files you want is the easiest way to
locate software. If you have <TT>archie</TT> available to you, it can be
of assistance as well<A NAME="tex2html386" HREF="footnode.html#5467"><IMG  ALIGN=BOTTOM ALT="gif" SRC="foot_motif.gif"></A>. There
are also other Internet resources which are devoted specifically to
Linux. See Appendix&nbsp;<A HREF="app-sources/node1.html">A</A> for more details.
<P>
<A NAME="5461">&#160;</A>
<A NAME="5462">&#160;</A>
<P>
<H1><A NAME="SECTION006100000000000000000">4.10 Miscellaneous tasks.</A></H1>
<P>
Believe it or not, there are a number of housekeeping tasks for the
system administrator which don't fall into any major category.
<P>
<H2><A NAME="SECTION006101000000000000000">4.10.1 System startup files.</A></H2>
<A NAME="secrc">&#160;</A>
<A NAME="5473">&#160;</A>
<A NAME="5474">&#160;</A>
When the system boots, a number of scripts are executed automatically
by the system before any user logs in. Here is a description of what
happens.
<P>
<A NAME="5533">&#160;</A>
<A NAME="5534">&#160;</A>
<A NAME="5535">&#160;</A>
<A NAME="5536">&#160;</A>
<A NAME="5537">&#160;</A>
<A NAME="5538">&#160;</A>
At bootup time, the kernel spawns the process <TT>/etc/init</TT>.
<TT>Init</TT> is a program which reads its configuration file, 
<TT>/etc/inittab</TT>, and spawns other processes based on the contents of
this file. One of the important processes started from <TT>inittab</TT>
is the <TT>/etc/getty</TT> process started on each virtual console. 
The <TT>getty</TT> process grabs the VC for use, and starts a <TT>login</TT>
process on the VC. This allows you to login on each VC. If 
<TT>/etc/inittab</TT> does not contain a <TT>getty</TT> process for a certain
VC, you will not be able to login on that VC.
<P>
<A NAME="5539">&#160;</A>
<A NAME="5540">&#160;</A>
<A NAME="5541">&#160;</A>
<A NAME="5542">&#160;</A>
Another process executed from <TT>/etc/inittab</TT> is <TT>/etc/rc</TT>, the
main system initialization file. This file is a simple shell script
which executes any initialization commands needed at boot time, such
as mounting the file systems (see page&nbsp;<A HREF="node6.html#secmanagefs"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>) and
initializing swap space. On some systems, <TT>init</TT> executes the
file <TT>/etc/init.d/rc</TT>.
<P>
Your system may execute other initialization scripts as well. For example <TT>/etc/rc.local</TT> which usually contains initialization
commands specific to your own system, such as setting the host name (see
the next section). <TT>rc.local</TT> may be started from <TT>/etc/rc</TT>
or from <TT>/etc/inittab</TT> directly.
<P>
<H2><A NAME="SECTION006102000000000000000">4.10.2 Setting the host name.</A></H2>
<A NAME="secsethostname">&#160;</A>
<A NAME="5505">&#160;</A>
<A NAME="5543">&#160;</A>
In a networked environment, the host name is used to uniquely identify
a particular machine, while on a standalone machine, the host name
simply gives the system personality and charm. It's like naming a pet:
you can always address to your dog as ``The dog,'' but it's much more
interesting to assign the dog a name such as spot or woofie.
<P>
Setting the system's host name is a simple matter of using the
<TT>hostname</TT> command. If you are on a network, your
host name should be the full host name of your machine, such as
<TT>goober.norelco.com</TT>. If you are not on a network of any kind,
you can choose an arbitrary host and domain name, such as
<TT>loomer.vpizza.com</TT>, <TT>shoop.nowhere.edu</TT>, or <TT>floof.org</TT>.
<P>
The host name must appear in the file <TT>/etc/hosts</TT>, which assigns
an IP address to each host. Even if your machine is not on a network,
you should include your own host name in <TT>/etc/hosts</TT>.
If you are not on a TCP/IP network, and your host name is <TT>
floof.org</TT>, simply include the following line in <TT>/etc/hosts</TT>:
<BR><IMG WIDTH=297 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen5516" SRC="img322.gif"><BR>
This assigns your host name, <TT>floof.org</TT>, to the loopback address
127.0.0.1. The loopback interface is present whether the machine is
connected to a network or not. The <TT>localhost</TT> alias is always 
assigned to this address.
<P>
If you are on a TCP/IP network, your actual IP address and host name
should appear in <TT>/etc/hosts</TT>. For example, if your host name is
<TT>goober.norelco.com</TT>, and your IP address is 128.253.154.32, add
the following line to <TT>/etc/hosts</TT>:
<BR><IMG WIDTH=334 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen5523" SRC="img323.gif"><BR>
<P>
To set your host name, simply use the <TT>hostname</TT> command. For
example, the command
<BR><IMG WIDTH=275 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen5526" SRC="img324.gif"><BR>
sets the host name to <TT>goober.norelco.com</TT>. In most cases, the
<TT>hostname</TT> command is executed from one of the system startup
files, like <TT>/etc/rc</TT> or <TT>/etc/rc.local</TT>. Edit these two files
and change the <TT>hostname</TT> command found there to set your own host
name. Upon rebooting, the system will use the new name.
<P>
<H1><A NAME="SECTION006110000000000000000">4.11 What to do in an emergency.</A></H1>
<P>
<A NAME="5547">&#160;</A>
<A NAME="5548">&#160;</A>
On some occasions, the system administrator will be faced with the
problem of recovering from a complete disaster, such as 
forgetting the root password or trashing file systems. The best advice
is, <EM>don't panic.</EM> Everyone makes stupid mistakes--that's the
best way to learn about system administration: the hard way.
<P>
Linux is not an unstable version of UNIX. In fact, I have had
fewer problems with system hangs than with commercial
versions of UNIX on many platforms. Linux also benefits from a
strong complement of wizards who can help you out of a bind. (The
<EM>double entendre</EM> is intended.)
<P>
The first step to fixing any problem youself is finding out what it
is. Poke around, and see how things work. Much of the time, a system
administrator posts a desperate plea for help before he or she looks
into the problem at all. You'll find that fixing problems yourself is
actually very easy. It is the path to enlighenment and guruhood.
<P>
There are a few times when reinstalling the system from scratch is
necessary. Many new users accidentally delete some essential system
file, and immediately reach for the installation disks. This is not a
good idea. Before taking such drastic measures, investigate the
problem and ask others for help. In many cases, you can recover your
system from a maintenance diskette.
<P>
<H2><A NAME="SECTION006111000000000000000">4.11.1 Recovery with a maintenance diskette.</A></H2>
<P>
<A NAME="secmaintdiskette">&#160;</A>
<A NAME="5553">&#160;</A>
<A NAME="5554">&#160;</A>
<A NAME="5555">&#160;</A>
<A NAME="5556">&#160;</A>
<A NAME="5557">&#160;</A>
<A NAME="5558">&#160;</A>
<A NAME="5559">&#160;</A>
One indispensable tool of the system administrator is the so-called
``boot/root disk,'' a floppy that can be booted for a complete Linux
system, independent of your hard drive. Boot/root disks are actually
very simple--you create a root file system on the floppy, place all
of the necessary utilities on it, and install LILO and a bootable
kernel on the floppy. Another technique is to use one floppy for the
kernel and another for the root file system. In any case, the result
is the same: you are running a Linux system completely from the floppy
drive.
<P>
The canonical example of a boot/root disk is the Slackware boot
disks. These diskettes contain a bootable kernel and a root file
system, all on floppy. They are intended to be used to install the
Slackware distribution, but come in handy when doing system
maintenance.
<P>
The H.J Lu boot/root disk, available from <TT>
/pub/Linux/GCC/rootdisk</TT> on <TT>sunsite.unc.edu</TT>, is another example
of a maintenance disk. If you're ambitious, you can create your own.
In most cases, however, a ready-made boot/root disk is much easier to
use and probably will be more complete.
<P>
Using a boot/root disk is very simple. Boot the disk on your system,
and login as <TT>root</TT> (usually with no password). In order to access
the files on the hard drive, you will need to mount the file systems
by hand. For example, the command
<BR><IMG WIDTH=255 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen5563" SRC="img325.gif"><BR>
will mount an ext2fs file system on <TT>/dev/hda2</TT> under <TT>/mnt</TT>.
Remember that <TT>/</TT> is now on the boot/root disk itself; you need
to mount your hard drive file systems under some directory in order to
access the files. Therefore, <TT>/etc/passwd</TT> on your hard drive
is now <TT>/mnt/etc/passwd</TT> if you mount your root file system on
<TT>/mnt</TT>.
<P>
<H2><A NAME="SECTION006112000000000000000">4.11.2 Fixing the root password.</A></H2>
<P>
<A NAME="5572">&#160;</A>
<A NAME="5573">&#160;</A>
If you forget your root password, this is not a problem,
surprisingly. Boot the boot/root disk, mount the root file system on
<TT>/mnt</TT>, and blank out the password field for <TT>root</TT> in <TT>
/mnt/etc/passwd</TT>, as in this example:
<BR><IMG WIDTH=205 HEIGHT=9 ALIGN=BOTTOM ALT="tscreen5577" SRC="img326.gif"><BR>
Now <TT>root</TT> has no password. When you reboot from the hard drive
you should be able to login as <TT>root</TT> and reset the password
using <TT>passwd</TT>.
<P>
Aren't you glad that you learned how to use <TT>vi</TT>? On your
boot/root disk, editors like Emacs probably aren't available, but <TT>
vi</TT> should be.
<P>
<H2><A NAME="SECTION006113000000000000000">4.11.3 Trashed file systems.</A></H2>
<P>
<A NAME="5585">&#160;</A>
<A NAME="5618">&#160;</A>
<A NAME="5619">&#160;</A>
If you somehow trash a file systems, you can run <TT>e2fsck</TT> or the
appropriate form of <TT>fsck</TT> for the file system type. (See
page&nbsp;<A HREF="node6.html#seccheckingfilesystem"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>.) In most cases, it is safest
to correct any damaged data on the hard drive file systems from
floppy.
<P>
<A NAME="5591">&#160;</A>
<A NAME="5592">&#160;</A>
One common cause of file system damage is a damaged super block. The
<B>super block</B> is the ``header'' of the file system that contains
information about its status, size, free blocks, and so forth. If you
damage the super block, by accidentally writing data directly to the
file system's partition table for example, the system probably will
not recognize the file system at all. Attempt to mount the file system
will fail, and <TT>e2fsck</TT> won't be able to fix the problem.
<P>
Happily, an ext2fs file system type saves copies of the superblock at
``block group'' boundaries on the drive, usually every 8K blocks. To
tell <TT>e2fsck</TT> to use a copy of the superblock, use a command like
<BR><IMG WIDTH=193 HEIGHT=13 ALIGN=BOTTOM ALT="tscreen5596" SRC="img327.gif"><BR> 
where <i>partition</i> is the partition on which the file system resides.
The <TT>-b 8193</TT> option tells <TT>e2fsck</TT> to use the copy of the superblock
stored at block 8193 in the file system.
<P>
<H2><A NAME="SECTION006114000000000000000">4.11.4 Recovering lost files.</A></H2>
<P>
<A NAME="5603">&#160;</A>
If you accidentally delete an important file on your system, there's
no way to ``undelete'' it. However, you can copy the relevant files
from the floppy to your hard drive. If you delete <TT>/bin/login</TT>,
for example, which allows you to login, simply boot the boot/root
floppy, mount the root file system on <TT>/mnt</TT>, and use the command
<BR><IMG WIDTH=282 HEIGHT=12 ALIGN=BOTTOM ALT="tscreen5606" SRC="img328.gif"><BR>
The <TT>-a</TT> option tells <TT>cp</TT> to preserve the permissions 
on the file(s) being copied.
<P>
Of course, if the files you deleted aren't essential system files that
have counterparts on the boot/root floppy, you're out of luck. If you
make backups however, you can always restore them.
<P>
<H2><A NAME="SECTION006115000000000000000">4.11.5 Trashed libraries.</A></H2>
<P>
<A NAME="5611">&#160;</A>
If you accidentally trash your libraries or symbolic links in <TT>
/lib</TT>, more than likely the commands which depend on the libraries
will no longer work (see page&nbsp;<A HREF="node6.html#secupgradelibs"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A>). The easiest
solution is to boot your boot/root floppy, mount your root file
system, and fix the libraries in <TT>/mnt/lib</TT>.
Page&nbsp;<A HREF="node6.html#secupgradelibs"><IMG  ALIGN=BOTTOM ALT="gif" SRC="cross_ref_motif.gif"></A> describes how install run time
libraries and their symbolic links.
<P>
<A NAME="5616">&#160;</A>
<A NAME="5617">&#160;</A>
<P>
<HR><A NAME="tex2html857" HREF="node7.html"><IMG WIDTH=37 HEIGHT=24 ALIGN=BOTTOM ALT="next" SRC="next_motif.gif"></A> <A NAME="tex2html855" HREF="gs.html"><IMG WIDTH=26 HEIGHT=24 ALIGN=BOTTOM ALT="up" SRC="up_motif.gif"></A> <A NAME="tex2html849" HREF="node5.html"><IMG WIDTH=63 HEIGHT=24 ALIGN=BOTTOM ALT="previous" SRC="previous_motif.gif"></A> <A NAME="tex2html859" HREF="node1.html"><IMG WIDTH=65 HEIGHT=24 ALIGN=BOTTOM ALT="contents" SRC="contents_motif.gif"></A>  <BR>
<B> Next:</B> <A NAME="tex2html858" HREF="node7.html">5 The X Window </A>
<B>Up:</B> <A NAME="tex2html856" HREF="gs.html">Linux Installation and Getting </A>
<B> Previous:</B> <A NAME="tex2html850" HREF="node5.html">3 Linux Tutorial</A>
<P><ADDRESS>
<I>Clarica Grove <BR>
Wed Mar  4 10:46:42 PST 1998</I>
</ADDRESS>
</BODY>
</HTML>
