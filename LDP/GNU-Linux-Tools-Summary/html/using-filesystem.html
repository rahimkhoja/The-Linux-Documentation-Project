<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML
><HEAD
><TITLE
>Moving around the filesystem</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.7"><LINK
REL="HOME"
TITLE="GNU/Linux Command-Line Tools Summary"
HREF="index.html"><LINK
REL="UP"
TITLE="Working with the file-system"
HREF="working-with-the-file-system.html"><LINK
REL="PREVIOUS"
TITLE="Working with the file-system"
HREF="working-with-the-file-system.html"><LINK
REL="NEXT"
TITLE="Working with files and folders"
HREF="working-files-folders.html"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>GNU/Linux Command-Line Tools Summary</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="working-with-the-file-system.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 7. Working with the file-system</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="working-files-folders.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="USING-FILESYSTEM"
></A
>7.1. Moving around the filesystem</H1
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>cd</DT
><DD
><P
>Change directory. Use <EM
>&#8220; cd ..&#8221;</EM
> to go up one directory. </P
><P
>One dot '.' represents the current directory while two dots '..' represent the parent directory. </P
><P
><EM
>&#8220; cd -&#8221;</EM
> will return you to the previous directory (a bit like an &#8220;undo&#8221;). </P
><P
>You can also use <EM
>cd absolute path</EM
> or <EM
>cd relative path</EM
> (see below):</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Absolute paths</DT
><DD
><P
>An &#8220; absolute path&#8221; is easily recognised from the leading forward slash, /. The / means that you start at the top level directory and continue down.</P
></DD
></DL
></DIV
><P
>For example to get to /boot/grub<EM
> </EM
>you would type:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>cd /boot/grub</PRE
></FONT
></TD
></TR
></TABLE
><P
>This is an absolute path because you start at the top of the hierarchy and go downwards from there (it doesn't matter where in the filesystem you were when you typed the command).</P
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>Relative paths</DT
><DD
><P
>A &#8220; relative path&#8221; doesn't have a preceding slash. Use a relative path when you start from a directory below the top level directory structure. This is dependent on where you are in the filesystem.</P
><P
>For example<EM
> </EM
>if you are in root's home directory and want to get to /root/music, you type:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>cd music</PRE
></FONT
></TD
></TR
></TABLE
></DD
></DL
></DIV
><P
>Please note that there is no / using the above<EM
> cd </EM
>command. Using a / would cause this to be an absolute path, working from the top of the hierarchy downward.</P
></DD
><DT
>ls</DT
><DD
><P
>List files and directories. Typing &#8220;ls&#8221; will list files and directories, but will not list hidden files or directories that start with a leading full stop  &#8220;.&#8221;.</P
><P
>Example options:</P
><P
></P
><UL
><LI
><P
><EM
>ls -l</EM
> --- long style, this lists permissions, file size, modification date, ownership.</P
></LI
><LI
><P
><EM
>ls -a</EM
> --- this means "show all", this shows hidden files, by default any file or directory starting with a '.' will not be shown.</P
></LI
><LI
><P
><EM
>ls -d</EM
> --- list directory entires rather than contents (see example below)</P
></LI
><LI
><P
><EM
>ls -F</EM
> --- append symbols to particular files, such as * (asterisk) for executable files. </P
></LI
><LI
><P
><EM
>ls -S </EM
>--- sort the output of the command in decending order sorted by size.</P
></LI
><LI
><P
><EM
>ls -R</EM
> --- (recursive) to list everything in the directories below as well as the current directory.</P
></LI
></UL
><P
>Command syntax, either:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>ls -options</PRE
></FONT
></TD
></TR
></TABLE
><P
>This simply lists everything in the current directory, the options are not required (options such as <EM
>-l</EM
>, <EM
>-a</EM
> et cetera).</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>ls -options string</PRE
></FONT
></TD
></TR
></TABLE
><P
>This lists files using a certain string. The string can contain standard wildcards to list multiple files, to learn more about standard wildcards please read <A
HREF="wildcards.html#STANDARD-WILDCARDS"
>Section 20.4.1</A
></P
><P
>You can use<EM
> ls -d</EM
> to show directories that match an exact string, or use standard wildcards. Type &#8220; ls -d */&#8221; to list all subdirectories of the current directory. Depending on the setup of your aliases (see <A
HREF="shell-tips.html"
>Chapter 4</A
>) you may simply be able to type<EM
> lsd </EM
>as the equivalent to<EM
> ls -d */</EM
>.</P
><P
>Examples for<EM
> ls -d</EM
>:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>ls -d<EM
> </EM
>*/</PRE
></FONT
></TD
></TR
></TABLE
><P
>Lists all subdirectories of current directory.</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>ls -d string*</PRE
></FONT
></TD
></TR
></TABLE
><P
>Lists directories that start with "string".</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>ls -d /usr/*/*/doc</PRE
></FONT
></TD
></TR
></TABLE
><P
>Lists all directories that are two levels below the /usr/ directory and have a directory called &#8220;doc&#8221;, this trick can come in quite handy sometimes.</P
><DIV
CLASS="TIP"
><P
></P
><TABLE
CLASS="TIP"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/tip.gif"
HSPACE="5"
ALT="Tip"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>You can also use</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Depending on how your aliases (see <A
HREF="shell-tips.html"
>Chapter 4</A
>) are setup you can also use <EM
>l</EM
>, <EM
>la</EM
> (list all) and <EM
>ll</EM
> (list long) to perform the above commands</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
>pwd</DT
><DD
><P
>Print working directory. Print the absolute (complete) path to the directory the user is currently in. </P
><P
>Command syntax:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>pwd</PRE
></FONT
></TD
></TR
></TABLE
><P
>This will tell you the full path to the directory you are in, for example it may output &#8220;/usr/local/bin&#8221; if you are currently in that directory.</P
></DD
><DT
>tree</DT
><DD
><P
>Outputs an <SPAN
CLASS="ACRONYM"
>ASCII</SPAN
> text tree/graph starting at a given directory (by default the current directory). This command recursively lists all files and all directories.</P
><P
>In other words, it will list files within the directories below the current one, as well as all files in the current directory.</P
><P
><EM
>tree</EM
> has a large number of options, refer to the manual page for details.</P
><P
>Command syntax:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>tree</PRE
></FONT
></TD
></TR
></TABLE
><P
>or</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>tree -option(s) /optional/directory/to/list</PRE
></FONT
></TD
></TR
></TABLE
></DD
></DL
></DIV
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="FINDING-FILES"
></A
>7.1.1. Finding files</H2
><P
></P
><DIV
CLASS="VARIABLELIST"
><DL
><DT
>find</DT
><DD
><P
><EM
>find</EM
> is a tool which looks for files on a filesystem. <EM
>find</EM
> has a large number of options which can be used to customise the search (refer to the manual/info pages).</P
><P
>Note that find works with standard wildcards,<A
HREF="wildcards.html#STANDARD-WILDCARDS"
>Section 20.4.1</A
>, and can work with regular expressions, <A
HREF="wildcards.html#REGULAR-EXPRESSIONS"
>Section 20.4.2</A
>.</P
><P
>Basic example:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>find / -name file</PRE
></FONT
></TD
></TR
></TABLE
><P
>This would look for a file named &#8220;file&#8221; and start at the root directory (it will search all directories including those that are mounted filesystems).</P
><P
>The <EM
>`-name'</EM
> option is case sensitive you can use the <EM
>`-iname'</EM
> option to find something regardless of case.</P
><P
>Use the <EM
>'-regex'</EM
> and <EM
>'-iregex'</EM
> to find something according to a regular expression (either case sensitive or case insensitive respectively).</P
><P
>The <EM
>'-exec'</EM
> option is one of the more advanced find operations. It executes a command on the files it finds (such as moving or removing it or anything else...).</P
><P
>To use the <EM
>-exec</EM
> option: use find to find something, then add the <EM
>-exec</EM
> option to the end, then:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>command_to_be_executed <A
NAME="COMMAND"
><IMG
SRC="../images/callouts/1.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(1)"></A
>  then '{}'<EM
> </EM
>(curly brackets) <A
NAME="BRACKETS"
><IMG
SRC="../images/callouts/2.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(2)"></A
> then the arguments (for example a new directory)  and finally a ';' <A
NAME="END"
><IMG
SRC="../images/callouts/3.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(3)"></A
>. </PRE
></FONT
></TD
></TR
></TABLE
><P
>See below for an example of use this command.</P
><DIV
CLASS="CALLOUTLIST"
><DL
COMPACT="COMPACT"
><DT
><A
HREF="using-filesystem.html#COMMAND"
><IMG
SRC="../images/callouts/1.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(1)"></A
></DT
><DD
>       This is the tool you want to execute on the files find locates. For example if you wanted to remove everything it finds then you would use <EM
>-exec rm -f</EM
>
      </DD
><DT
><A
HREF="using-filesystem.html#BRACKETS"
><IMG
SRC="../images/callouts/2.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(2)"></A
></DT
><DD
>       The curly brackets are used in find to represent the current file which has been found. ie. If it found the file shopping.doc then {} would be substituted with shopping.doc. It would then continue to substitute {} for each file it finds. The brackets are normally protected by backslashes (\) or single-quotation marks ('), to stop bash expanding them (trying to interpret them as a special command eg. a wildcard).
      </DD
><DT
><A
HREF="using-filesystem.html#END"
><IMG
SRC="../images/callouts/3.gif"
HSPACE="0"
VSPACE="0"
BORDER="0"
ALT="(3)"></A
></DT
><DD
>       This is the symbol used by find to signal the end of the commands. It's usually protected by a backslash (\) or quotes to stop bash from trying to expand it.
      </DD
></DL
></DIV
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>find / -name '*.doc' -exec cp '{}' /tmp/ ';'</PRE
></FONT
></TD
></TR
></TABLE
><P
>The above command would find any files with the extension '.doc' and copy them to your /tmp directory, obviously this command is quite useless, it's just an example of what find can do. Note that the quotation marks are there to stop bash from trying to interpret the other characters as something.</P
><P
>Excluding particular folders with <EM
>find</EM
> can be quite confusing, but it may be necessary if you want to search your main disk (without searching every mounted filesystem). Use the<EM
> -path </EM
> option to exclude the particular folder (note, you cannot have a '/' (forward slash) on the end) and the<EM
> -prune </EM
> option to exclude the subdirectories. An example is below:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>find / -path '/mnt/win_c' -prune -o -name "string" -print</PRE
></FONT
></TD
></TR
></TABLE
><P
>This example will search your entire directory tree (everything that is mounted under it) excluding /mnt/win_c and all of the subdirectories under /mnt/win_c. When using the <EM
>-path</EM
> option you can use wildcards.</P
><P
>Note that you could add more<EM
> -path '/directory'</EM
> statements on if you wanted.</P
><P
><EM
>find</EM
> has many, many different options, refer to the manual (and info) page for more details.</P
></DD
><DT
>slocate</DT
><DD
><P
><EM
>slocate</EM
> outputs a list of all files on the system that match the pattern, giving their full path name (it doesn't have to be an exact match, anything which contains the word is shown).</P
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>Replaces <EM
>locate</EM
></B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>Secure locate is a replacement for <EM
>locate</EM
>, both have identical syntax. On most distributions locate is an alias to <EM
>slocate</EM
>.</P
></TD
></TR
></TABLE
></DIV
><P
>Commmand syntax:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>slocate string</PRE
></FONT
></TD
></TR
></TABLE
><DIV
CLASS="NOTE"
><P
></P
><TABLE
CLASS="NOTE"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="../images/note.gif"
HSPACE="5"
ALT="Note"></TD
><TH
ALIGN="LEFT"
VALIGN="CENTER"
><B
>This won't work unless</B
></TH
></TR
><TR
><TD
>&nbsp;</TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>You need to run either <EM
>updatedb</EM
> (as root) or <EM
>slocate -u </EM
>(as root) for slocate to work.</P
></TD
></TR
></TABLE
></DIV
></DD
><DT
>whereis<EM
></EM
></DT
><DD
><P
>whereis locates the binary, source, and manual page for a particular program, it uses exact matches only, if you only know part of the name use <EM
>slocate</EM
>.</P
><P
>Command syntax:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>whereis program_name</PRE
></FONT
></TD
></TR
></TABLE
></DD
><DT
>which</DT
><DD
><P
>Virtually the same as whereis, except it only finds the executable (the physical program). It only looks in the PATH (environment variable) of a users shell. </P
><P
>Use the <EM
>-a</EM
> option to list all occurances of the particular program_name in your path (so if theres more than one you can see it).</P
><P
>Command syntax:</P
><TABLE
BORDER="1"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><FONT
COLOR="#000000"
><PRE
CLASS="SCREEN"
>which program_name</PRE
></FONT
></TD
></TR
></TABLE
></DD
></DL
></DIV
></DIV
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="working-with-the-file-system.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="working-files-folders.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Working with the file-system</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="working-with-the-file-system.html"
ACCESSKEY="U"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Working with files and folders</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>