
<HTML>
<HEAD>
<TITLE>Annotated Bibliography</TITLE>
<LINK rel="owner" href="mailto:">
<SCRIPT LANGUAGE="JavaScript">
<!-- hide this

function help(message) {
  self.status = message;
  return true;
}
// stop hiding -->
</SCRIPT>

</HEAD>
<BODY>
<strong>The
HyperNews <a href="../khg.html">Linux KHG</a>
Discussion Pages</strong>
<hr>
<h2>Annotated Bibliography</h2>

<p>This annotated bibliography covers books on operating system
theory as well as different kinds of programming in a Unix
environment.  The price marked may or may not be an exact
price, but should be close enough for government work.  <b>If
you have a book that you think should go in the bibliography,
please write a short review of it and send all the necessary
information (title, author, publisher, ISBN, and approximate
price) and the review to johnsonm@redhat.com</b>


<h4><i>The Design of the UNIX Operating System</i></h4>

<table>
<tr><th align="right">Author:</th><td>Maurice J. Bach</td></tr>
<tr><th align="right">Publisher:</th><td>Prentice Hall, 1986</td></tr>
<tr><th align="right">ISBN:</th><td>0-13-201799-7</td></tr>
<tr><th align="right">Price:</th><td>$65.00</td></tr>
</table>

<p>This is one of the books that Linus used to design Linux.
It is a description of the data structures used in the System V
kernel.  Many of the names of the important functions in the
Linux source come from this book, and are named after the
algorithms presented here. For instance, if you can't quite
figure out what exactly getblk(), brelse(), bread(), breada(),
and bwrite() are, chapter 3 explains very well.

<p>While most of the algorithms are similar or the same, a few
differences are worth noting:
<ul>
<li>The Linux buffer cache is dynamically resized, so the algorithm for
dealing with getting new buffers is a bit different.  Therefore the
above referenced explanation of getblk() is a little different than the
getblk() in Linux.
<li>Linux does not currently use streams, and if/when streams are
implemented for Linux, they are likely to have somewhat different
semantics.
<li>The semantics and calling structure for device drivers is
different.  The concept is similar, and the chapter on device drivers
is still worth reading, but for details on the device driver
structures, the KHG is the proper reference.
<li>The memory management algorithms are somewhat different.
</ul>
There are other small differences as well, but a good understanding of
this text will help you understand the Linux source.




<h4><i>Advanced Programming in the UNIX Environment</i></h4>
<table>
<tr><th align="right">Author:</th><td>W. Richard Stevens</td></tr>
<tr><th align="right">Publisher:</th><td>Addison Wesley, 1992</td></tr>
<tr><th align="right">ISBN:</th><td>0-201-56317-7</td></tr>
<tr><th align="right">Price:</th><td>$50.00</td></tr>
</table>

<p>This excellent tome covers the stuff you <i>really</i> have
to know to write <i>real</i> Unix programs.  It includes a
discussion of the various standards for Unix implementations,
including POSIX, X/Open XPG3, and FIPS, and concentrates on two
implementations, SVR4 and pre-release 4.4 BSD, which it refers
to as 4.3+BSD.  The book concentrates heavily on application
and fairly complete specification, and notes which features
relate to which standards and releases.

<p>The chapters include: Unix Standardization and
Implementations, File I/O, Files and Directories, Standard I/O
Library, System Data Files and Information, The Environment of
a Unix Process, Process Control, Process Relationships,
Signals, Terminal I/O, Advanced I/O (non-blocking, streams,
async, memory-mapped, etc.), Daemon Processes, Interprocess
Communication, Advanced Interprocess Communication, and some
example applications, including chapters on A Database Library,
Commmunicating with a PostScript Printer, A Modem Dialer, and
then a seemingly misplaced final chapter on Pseudo Terminals.

<p>I have found that this book makes it possible for me to
write useable programs for Unix.  It will help you achieve
POSIX compliance in ways that won't break SVR4 or BSD, as a
general rule.  This book will save you ten times its cost in
frustration.


<h4><i>Advanced 80386 Programming Techniques</i></h4>
<table>
<tr><th align="right">Author:</th><td>James L. Turley</td></tr>
<tr><th align="right">Publisher:</th><td>Osborne McGraw-Hill, 1988</td></tr>
<tr><th align="right">ISBN:</th><td>0-07-881342-5</td></tr>
<tr><th align="right">Price:</th><td>$22.95</td></tr>
</table>

<p>This book covers the 80386 quite well, without touching on
any other hardware.  Some code samples are included.  All major
features are covered, as are many of the concepts needed.  The
chapters of this book are: Basics, Memory Segmentation,
Privilege Levels, Paging, Multitasking, Communicating Among
Tasks, Handling Faults and Interrupts, 80286 Emulation, 8086
Emulation, Debugging, The 80387 Numeric Processor Extension,
Programming for Performance, Reset and Real Mode, Hardware, and
a few appendices, including tables of the memory management
structures as a handy reference.

<p>The author has a good writing style: If you are technically
minded, you will find yourself caught up just reading this
book.  One strong feature of this book for Linux is that the
author is very careful not to explain how to do things under
DOS, nor how to deal with particular hardware.  In fact, the
only times he mentions DOS and PC-compatible hardware are in
the introduction, where he promises never to mention them
again.


<h4><i>The C Programming Language, second edition</i></h4>
<table>
<tr><th align="right">Author:</th><td>Brian W. Kernighan and Dennis M. Ritchie</td></tr>
<tr><th align="right">Publisher:</th><td>Prentice Hall, 1988</td></tr>
<tr><th align="right">ISBN:</th><td>0-13-110362-8 (paper) 0-13-110370-9 (hard)</td></tr>
<tr><th align="right">Price:</th><td>$35.00</td></tr>
</table>

<p>The C programming bible.  Includes a C tutorial, Unix
interface reference, C reference, and standard library
reference.

<p>You program in C, you buy this book.  It's that simple.


<h4><i>Operating Systems: Design and Implementation</i></h4>
<table>
<tr><th align="right">Author:</th><td>Andrew S. Tanenbaum</td></tr>
<tr><th align="right">Publisher:</th><td>Prentice Hall, 1987</td></tr>
<tr><th align="right">ISBN:</th><td>0-13-637406-9</td></tr>
<tr><th align="right">Price:</th><td>$50.00</td></tr>
</table>

<p>This book, while a little simplistic in spots, and missing
some important ideas, is a fairly clear exposition of what it
takes to write an operating system.  Half the book is taken up
with the source code to a Unix clone called Minix, which is
based on a microkernel, unlike Linux, which sports a monolithic
design.  It has been said that Minix shows that it is possible
to to write a microkernel-based Unix, but does not adequately
explain <i>why</i> one would do so.

<p>Linux was originally intended to be a free Minix replacement
(Linus' Minix, Linus tells us). In fact, it was originally to
be binary-compatible with Minix-386. Minix-386 was the
development environment under which Linux was bootstrapped.  No
Minix code is in Linux, but vesitiges of this heritage live on
in such things as the minix filesystem in Linux.

<p>However, this book might still prove worthwhile for those
who want a basic explanation of OS concepts, as Tanenbaum's
explanations of the basic concepts remain some of the clearer
(and more entertaining, if you like to be entertained)
available.  Unfortunately, basic is the key work here, as many
things such as virtual memory are not covered at all.


<h4><i>Modern Operating Systems</i></h4>
<table>
<tr><th align="right">Author:</th><td>Andrew S. Tanenbaum</td></tr>
<tr><th align="right">Publisher:</th><td>Prentice Hall, 1992</td></tr>
<tr><th align="right">ISBN:</th><td>0-13-588187-0</td></tr>
<tr><th align="right">Price:</th><td>$51.75</td></tr>
</table>

<p>The first half of this book is a rewrite of Tanenbaum's
earlier <i>Operating Systems</i>, but this book covers several
things that the earlier book missed, including such things as
virtual memory.  Minix is not included, but overviews of MS-DOS
and several distributed systems are.  This book is probably
more useful to someone who wants to do something with his or
her knowlege than Tanenbaum's earlier <i>Operating Systems:
Design and Implementation</i>. Some clue as to the reason may
be found in the title... However, what DOS is doing in a book
on <i>modern</i> operating systems, many have failed to
discover.


<h4><i>Operating Systems</i></h4>
<table>
<tr><th align="right">Author:</th><td>William Stallings</td></tr>
<tr><th align="right">Publisher:</th><td>Macmillan, 1992 (800-548-9939)</td></tr>
<tr><th align="right">ISBN:</th><td>0-02-415481-4</td></tr>
<tr><th align="right">Price:</th><td>No one at Macmillan could find one...</td></tr>
</table>

<p>A very thorough text on operating systems, this book gives
more in-depth coverage of the topics covered in Tannebaum's
books, and covers more topics, in a much brisker style.  This
book covers all the major topics that you would need to know to
build an operating system, and does so in a clear way.  The
author uses examples from three major systems, comparing and
contrasting them: Unix, OS/2, and MVS.  With each topic
covered, these example systems are used to clarify the points
and provide an example of an implementation.

<p>Topics covered in <i>Operating Systems</i> include threads,
real-time systems, multiprocessor scheduling, distributed
systems, process migration, and security, as well as the
standard topics like memory management and scheduling.  The
section on distributed processing appears to be up-to-date, and
I found it very helpful.


<h4><i>UNIX Network Programming</i></h4>
<table>
<tr><th align="right">Author:</th><td>W. Richard Stevens</td></tr>
<tr><th align="right">Publisher:</th><td>Prentice Hall, 1990</td></tr>
<tr><th align="right">ISBN:</th><td>0-13-949876-1</td></tr>
<tr><th align="right">Price:</th><td>$48.75</td></tr>
</table>

<p>This book covers several kinds of networking under Unix, and
provides very thorough references to the forms of networking
that it does not cover directly.  It covers TCP/IP and XNS most
heavily, and fairly exhaustively describes how all the calls
work.  It also has a description and sample code using System
V's TLI, and pretty complete coverage of System V IPC.  This
book contains a lot of source code examples to get you started,
and many useful proceedures.  One example is code to provide
useable semaphores, based on the partially broken
implementation that System V provides.


<h4><i>Programming in the UNIX environment</i></h4>
<table>
<tr><th align="right">Author:</th><td>Brian W. Kernighan and Robert Pike</td></tr>
<tr><th align="right">Publisher:</th><td>Prentice Hall, 1984</td></tr>
<tr><th align="right">ISBN:</th><td>0-13-937699 (hardcover) 0-13-937681-X (paperback)</td></tr>
<tr><th align="right">Price:</th><td>?</td></tr>
</table>



<h4><i>Writing UNIX Device Drivers</i></h4>
<table>
<tr><th align="right">Author:</th><td>George Pajari</td></tr>
<tr><th align="right">Publisher:</th><td>Addison Wesley, 1992</td></tr>
<tr><th align="right">ISBN:</th><td>0-201-52374-4</td></tr>
<tr><th align="right">Price:</th><td>$32.95</td></tr>
</table>

<p>This book is written by the President and founder of Driver
Design Labs, a company which specializes in the development of
Unix device drivers.  This book is an excellent introduction to
the sometimes wacky world of device driver design.  The four
basic types of drivers (character, block, tty, STREAMS) are
first discussed briefly.  Many full examples of device drivers
of all types are given, starting with the simplest and
progressing in complexity.  All examples are of drivers which
deal with Unix on PC-compatible hardware.

<p><b>Chapters include:</b>
Character Drivers I: A Test Data Generator
Character Drivers II: An A/D Converter
Character Drivers III: A Line Printer
Block Drivers I: A Test Data Generator
Block Drivers II: A RAM Disk Driver
Block Drivers III: A SCSI Disk Driver
Character Drivers IV: The Raw Disk Driver
Terminal Drivers I: The COM1 Port
Character Drivers V: A Tape Drive
STREAMS Drivers I: A Loop-Back Driver
STREAMS Drivers II: The COM1 Port (Revisited)
Driver Installation
Zen and the Art of Device Driver Writing

<p>Although many of the calls used in the book are not
Linux-compatible, the general idea is there, and many of the
ideas map directly into Linux.

<p>Copyright (C) 1992, 1993, 1996 Michael K. Johnson,
johnsonm@redhat.com.<br>
<P>
<P><HR SIZE=3>
<P><B><A NAME="Messages">Messages</A></B>
<NOBR>
<font size=-1>







</font>
</NOBR>
 <P>
<NOBR>
<DL COMPACT>
<DT> 1. <IMG src="../../../Icons/note.gif" ALT="Note:" WIDTH=15 HEIGHT=15 ALIGN="absmiddle">
<A HREF="bib/1.html">
Please replace K&amp;R reference by Harbison/Steele</A> <i> by <A HREF="http://wwwcip.informatik.uni-erlangen.de/user/mskuhn">Markus Kuhn</A></i> </DT>
<DD>
<DL COMPACT>
<DT> 1. <IMG src="../../../Icons/feedback.gif" ALT="Feedback:" WIDTH=15 HEIGHT=15 ALIGN="absmiddle">
<A HREF="bib/1/1.html">
Replace, no; supplement, yes</A> <i> by <A HREF="../../../~johnsonm">Michael K. Johnson</A></i> </DT>
<DT> -&gt; <IMG src="../../../Icons/feedback.gif" ALT="Feedback:" WIDTH=15 HEIGHT=15 ALIGN="absmiddle">
<A HREF="bib/1/1/1.html">
Right you are Mike!</A> <i> by rohit patil</i> </DT>
</DL>
</DD>
<DT> 2. <IMG src="../../../Icons/warning.gif" ALT="Warning:" WIDTH=15 HEIGHT=15 ALIGN="absmiddle">
<A HREF="bib/2.html">
80386 book is apparently out of print now</A> <i> by <A HREF="http://valour.pem.cam.ac.uk/~and1000/">Austin Donnelly</A></i> </DT>
<DD>
<DL COMPACT>
<DT> 1. <IMG src="../../../Icons/sad.gif" ALT="Sad:" WIDTH=15 HEIGHT=15 ALIGN="absmiddle">
<A HREF="bib/2/1.html">
Very unfortunate</A> <i> by <A HREF="../../../~johnsonm">Michael K. Johnson</A></i> </DT>
</DL>
</DD>
<DT> 3. <IMG src="../../../Icons/note.gif" ALT="Note:" WIDTH=15 HEIGHT=15 ALIGN="absmiddle">
<A HREF="bib/3.html">
Linux Kernel Internals-&gt; Kernel MM IPC fs drivers net modules</A> <i> by Alex Stewart</i> </DT>
</DL>
</NOBR>

<P>
<P>



  





<BR> 
 
<BR></BODY>
</HTML>
