<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">

<html>

<head>

<meta http-equiv="content-type" content="text/html; charset=iso-8859-1">

<title>Debian User Reference Manual (Obsolete Documentation) - Files and File Systems</title>

<link href="index.html" rel="start">
<link href="ch-manpages.html" rel="prev">
<link href="ch-shells.html" rel="next">
<link href="index.html#contents" rel="contents">
<link href="index.html#copyright" rel="copyright">
<link href="ch1.html" rel="chapter" title="1 Introduction">
<link href="ch-logging-in.html" rel="chapter" title="2 Overview of a Debian GNU/Linux System">
<link href="ch-manpages.html" rel="chapter" title="3 Documentation">
<link href="ch-files.html" rel="chapter" title="4 Files and File Systems">
<link href="ch-shells.html" rel="chapter" title="5 Shells">
<link href="ch6.html" rel="chapter" title="6 Basic Commands and Tools">
<link href="ch7.html" rel="chapter" title="7 Advanced Commands and Tools">
<link href="ch-editors.html" rel="chapter" title="8 Text Editing">
<link href="ch9.html" rel="chapter" title="9 Text Processing">
<link href="ch10.html" rel="chapter" title="10 Programming">
<link href="ch11.html" rel="chapter" title="11 Science">
<link href="ch12.html" rel="chapter" title="12 Games">
<link href="ch13.html" rel="chapter" title="13 Sound">
<link href="ch14.html" rel="chapter" title="14 Image Manipulation">
<link href="ch15.html" rel="chapter" title="15 Networking">
<link href="ch16.html" rel="chapter" title="16 Databases">
<link href="ch-xwin.html" rel="chapter" title="17 X Windows">
<link href="ch18.html" rel="chapter" title="18 X Windows Managers">
<link href="ch19.html" rel="chapter" title="19 X Windows Applications">
<link href="ch20.html" rel="chapter" title="20 Index">
<link href="ch-files.html#s-files-basics" rel="section" title="4.1 Basic Concepts">
<link href="ch-files.html#s-files-commands" rel="section" title="4.2 Basic file commands - a tutorial">
<link href="ch-files.html#s-files-structure" rel="section" title="4.3 What files are on my Debian system? Where should I put my own files?">
<link href="ch-files.html#s-files-permissions" rel="section" title="4.4 File ownership and permissions">
<link href="ch-files.html#s-files-filesystems" rel="section" title="4.5 Filesystems">
<link href="ch-files.html#s-files-devices" rel="section" title="4.6 How to access particular devices (including hard disk partitions and floppy drives)">
<link href="ch-files.html#s-files-misc" rel="section" title="4.7 Miscellaneous topics">
<link href="ch-files.html#s-files-advanced" rel="section" title="4.8 Advanced Topics">
<link href="ch6.html#s6.1" rel="section" title="6.1 What this chapter covers">
<link href="ch6.html#s6.2" rel="section" title="6.2 Running commands">
<link href="ch6.html#s-regexp" rel="section" title="6.3 Regular expressions">
<link href="ch9.html#s9.1" rel="section" title="9.1 What this chapter covers">
<link href="ch9.html#s9.2" rel="section" title="9.2 Text processing">
<link href="ch9.html#s9.3" rel="section" title="9.3 LaTeX">
<link href="ch10.html#s10.1" rel="section" title="10.1 What this chapter covers">
<link href="ch11.html#s11.1" rel="section" title="11.1 What this chapter covers">
<link href="ch11.html#s11.2" rel="section" title="11.2 Plotting">
<link href="ch11.html#s11.3" rel="section" title="11.3 Combining diagrams">
<link href="ch16.html#s16.1" rel="section" title="16.1 What this chapter covers">
<link href="ch-files.html#s-files-permissions-groups" rel="subsection" title="4.4.1 Groups">
<link href="ch-files.html#s-files-permissions-mode" rel="subsection" title="4.4.2 Mode">
<link href="ch-files.html#s-files-permissions-tutorial" rel="subsection" title="4.4.3 Permissions in practice">
<link href="ch-files.html#s-files-devices-mounting" rel="subsection" title="4.6.1 Mounting a filesystem">
<link href="ch-files.html#s-files-devices-cdromexample" rel="subsection" title="4.6.2 Example: Mounting a CD-ROM">
<link href="ch-files.html#s-files-devices-fstab" rel="subsection" title="4.6.3 <samp>/etc/fstab</samp>: Automating the mount process">
<link href="ch-files.html#s-files-devices-removable" rel="subsection" title="4.6.4 Removable disks (floppies, Zip disks, etc.)">
<link href="ch-files.html#s-files-devices-preparing" rel="subsection" title="4.6.5 Preparing disks for use: formatting and creating a filesystem">
<link href="ch-files.html#s-files-misc-viewing" rel="subsection" title="4.7.1 Viewing the contents of files">
<link href="ch-files.html#s-files-misc-dotfiles" rel="subsection" title="4.7.2 Hidden files beginning with <samp>.</samp>">
<link href="ch-files.html#s-files-misc-find" rel="subsection" title="4.7.3 Finding a file on the system">
<link href="ch-files.html#s-files-misc-compression" rel="subsection" title="4.7.4 Compressing files with <samp>gzip</samp>">
<link href="ch-files.html#s-files-misc-split" rel="subsection" title="4.7.5 Splitting files into smaller parts">
<link href="ch-files.html#s-files-misc-diskspace" rel="subsection" title="4.7.6 Managing disk space">
<link href="ch-files.html#s-files-misc-tar" rel="subsection" title="4.7.7 Backups and large-scale file copying">
<link href="ch-files.html#s-files-misc-guessing" rel="subsection" title="4.7.8 Guessing a file's contents">
<link href="ch-files.html#s-files-misc-umask" rel="subsection" title="4.7.9 Defining default permissions with <samp>umask</samp>">
<link href="ch-files.html#s-files-advanced-hardlinks" rel="subsection" title="4.8.1 The real nature of files: hard links and inodes">
<link href="ch-files.html#s-files-advanced-types" rel="subsection" title="4.8.2 Types of files">
<link href="ch-files.html#s-files-advanced-types-symlinks" rel="subsection" title="4.8.2.1 Symbolic links">
<link href="ch-files.html#s-files-misc-types-devices" rel="subsection" title="4.8.2.2 Device files">
<link href="ch-files.html#s-files-advanced-types-devices-creating" rel="subsection" title="4.8.2.2.1 How to create device files.">
<link href="ch-files.html#s-files-advanced-types-devices-null" rel="subsection" title="4.8.2.2.2 <samp>/dev/null</samp>">
<link href="ch-files.html#s-files-advanced-types-pipes" rel="subsection" title="4.8.2.3 Named pipes (FIFOs)">
<link href="ch-files.html#s-files-advanced-types-sockets" rel="subsection" title="4.8.2.4 Sockets">
<link href="ch-files.html#s-files-advanced-proc" rel="subsection" title="4.8.3 The <samp>proc</samp> filesystem">
<link href="ch-files.html#s-files-advanced-permissions" rel="subsection" title="4.8.4 Advanced aspects of file permissions">
<link href="ch-files.html#s-files-advanced-permissions-absolute" rel="subsection" title="4.8.4.1 Using numeric arguments with <samp>chmod</samp>">
<link href="ch-files.html#s-files-advanced-permissions-suid" rel="subsection" title="4.8.4.2 Making files suid/sgid">
<link href="ch-files.html#s-files-advanced-permissions-sticky" rel="subsection" title="4.8.4.3 Setting the sticky bit">
<link href="ch-files.html#s-files-advanced-undocumented" rel="subsection" title="4.8.5 Other concepts not yet covered, but should be">
<link href="ch6.html#s6.2.1" rel="subsection" title="6.2.1 How to enter commands">
<link href="ch6.html#s6.2.2" rel="subsection" title="6.2.2 How Linux finds commands">
<link href="ch6.html#s6.2.3" rel="subsection" title="6.2.3 Command options">
<link href="ch6.html#s6.2.4" rel="subsection" title="6.2.4 Essential commands">
<link href="ch6.html#s6.2.4.1" rel="subsection" title="6.2.4.1 Commands for reading documentation">
<link href="ch6.html#s6.2.4.2" rel="subsection" title="6.2.4.2 Commands for basic file-handling">
<link href="ch6.html#s6.2.4.3" rel="subsection" title="6.2.4.3 These commands are used for managing file-systems">
<link href="ch6.html#s6.2.4.4" rel="subsection" title="6.2.4.4 Looking at files">
<link href="ch6.html#s-rmacs" rel="subsection" title="6.2.4.5 Managing your screen">
<link href="ch6.html#s6.2.4.6" rel="subsection" title="6.2.4.6 Compressed files">
<link href="ch6.html#s6.2.4.7" rel="subsection" title="6.2.4.7 Commands for backup">
<link href="ch6.html#s6.2.4.8" rel="subsection" title="6.2.4.8 Printing files">
<link href="ch6.html#s6.2.4.9" rel="subsection" title="6.2.4.9 Changing files">
<link href="ch6.html#s6.2.4.10" rel="subsection" title="6.2.4.10 Session management">
<link href="ch6.html#s6.2.4.11" rel="subsection" title="6.2.4.11 Identity">
<link href="ch6.html#s6.2.4.12" rel="subsection" title="6.2.4.12 Turning off the computer">
<link href="ch6.html#s6.2.5" rel="subsection" title="6.2.5 Special characters in commands">
<link href="ch6.html#s6.2.6" rel="subsection" title="6.2.6 Filters">
<link href="ch6.html#s6.2.7" rel="subsection" title="6.2.7 Standard input, standard output and standard error">
<link href="ch6.html#s6.2.8" rel="subsection" title="6.2.8 Redirection">
<link href="ch6.html#s6.2.9" rel="subsection" title="6.2.9 Shell programs">
<link href="ch6.html#s6.2.10" rel="subsection" title="6.2.10 Errors">
<link href="ch9.html#s9.3.1" rel="subsection" title="9.3.1 Invoking LaTeX">
<link href="ch9.html#s9.3.2" rel="subsection" title="9.3.2 Printing dvi-files">
<link href="ch9.html#s9.3.3" rel="subsection" title="9.3.3 Documentation on LaTeX">

</head>

<body>

<p><a name="ch-files"></a></p>
<hr>

<p>
[ <a href="ch-manpages.html">previous</a> ]
[ <a href="index.html#contents">Contents</a> ]
[ <a href="ch1.html">1</a> ]
[ <a href="ch-logging-in.html">2</a> ]
[ <a href="ch-manpages.html">3</a> ]
[ 4 ]
[ <a href="ch-shells.html">5</a> ]
[ <a href="ch6.html">6</a> ]
[ <a href="ch7.html">7</a> ]
[ <a href="ch-editors.html">8</a> ]
[ <a href="ch9.html">9</a> ]
[ <a href="ch10.html">10</a> ]
[ <a href="ch11.html">11</a> ]
[ <a href="ch12.html">12</a> ]
[ <a href="ch13.html">13</a> ]
[ <a href="ch14.html">14</a> ]
[ <a href="ch15.html">15</a> ]
[ <a href="ch16.html">16</a> ]
[ <a href="ch-xwin.html">17</a> ]
[ <a href="ch18.html">18</a> ]
[ <a href="ch19.html">19</a> ]
[ <a href="ch20.html">20</a> ]
[ <a href="ch-shells.html">next</a> ]
</p>

<hr>

<h1>
Debian User Reference Manual (Obsolete Documentation)
<br>Chapter 4 - Files and File Systems
</h1>

<hr>

<p>
author = Havoc Pennington <code><a
href="mailto:rhpennin@midway.uchicago.edu">rhpennin@midway.uchicago.edu</a></code>
</p>

<p>
topics = file handling commands, directory handling commands, directory
structure, file systems, etc.
</p>

<p>
This chapter describes how to manipulate files on your Debian GNU/Linux system,
how those files are organized into <em>filesystems</em>, and how to use
physical devices which store files (such as your hard disk).
</p>

<hr>

<h2><a name="s-files-basics"></a>4.1 Basic Concepts</h2>

<p>
Before describing any actual file-manipulation tasks, there are some general
points to make about files.  Let's look at some files on a Debian system:
</p>
<dl>
<dt><samp>/</samp></dt>
<dd>
<p>
A simple <samp>/</samp> represents the root directory.  All other files and
directories are contained in the root directory.
</p>
</dd>
</dl>
<dl>
<dt><samp>/home/janeq</samp></dt>
<dd>
<p>
This is the home directory of user &quot;janeq&quot;.  Reading left to right,
to get to this directory you start in the root directory, enter directory
<samp>home</samp>, then enter directory <samp>janeq</samp>.
</p>
</dd>
</dl>
<dl>
<dt><samp>/etc/X11/XF86Config</samp></dt>
<dd>
<p>
This is the configuration file for the X Window System.  It resides in the
<samp>X11</samp> subdirectory of the <samp>/etc</samp> directory.
<samp>/etc</samp> is in turn a subdirectory of the root directory,
<samp>/</samp>.
</p>
</dd>
</dl>

<p>
Things to note:
</p>
<ul>
<li>
<p>
Each file or directory is designated by a <em>path</em>, or sequence of
directories which must be passed through to reach it.  All paths begin with the
&quot;root&quot; directory.  There's a <samp>/</samp> between each directory or
file in the path.
</p>
</li>
</ul>
<ul>
<li>
<p>
The root directory is referred to as simply <samp>/</samp>.  Don't confuse this
&quot;root&quot; with the root user, the user on your system with &quot;super
powers.&quot;
</p>
</li>
</ul>
<ul>
<li>
<p>
Directories are arranged according to a tree metaphor.  All paths start with
the root directory.  The root directory has a number of branches, such as
<samp>/etc</samp> and <samp>/home</samp>.  These subdirectories in turn branch,
into still more subdirectories.  The whole thing together is called the
&quot;directory tree.&quot;
</p>

<p>
You can think of a path as a route from the base of the tree (<samp>/</samp>)
to the end of some branch (a file).  You'll also hear people talk about the
directory tree as if it were a <em>family</em> tree: thus subdirectories have
&quot;parents,&quot; and a path shows the complete ancestry of a file.
</p>
</li>
</ul>
<ul>
<li>
<p>
There's no directory that corresponds to a physical device, such as your hard
disk.  This differs from DOS and Windows, where all paths begin with a device
name such as <samp>C:\</samp>.  The directory tree is meant to be an
abstraction of the physical hardware, so you can use the system without knowing
what the hardware is.  All your files could be on one disk - or you could have
20 disks.  You can't tell just by looking at the directory tree, and nearly all
commands work just the same way no matter what device(s) your files are really
on.
</p>
</li>
</ul>
<ul>
<li>
<p>
Every directory except <samp>/</samp> has a name, which can contain any letters
or symbols <em>except</em> <samp>/</samp>.  [<a href="footnotes.html#f1"
name="fr1">1</a>]
</p>
</li>
</ul>
<ul>
<li>
<p>
Filenames are case sensitive.  That is, <samp>README</samp> and
<samp>readme</samp> are different files.
</p>
</li>
</ul>

<p>
Don't worry if all this isn't completely clear yet.  There are many examples to
come.
</p>

<hr>

<h2><a name="s-files-commands"></a>4.2 Basic file commands - a tutorial</h2>

<p>
To use your system you'll have to know how to create, move, rename, and delete
files and directories.  You'll do this from the <em>shell prompt</em>, which on
Debian defaults to <samp>$</samp>.  For the tutorials in this chapter, we'll
assume you've already logged in, <em>not</em> as root, and that you're looking
at the <samp>$</samp> prompt.
</p>

<p>
The best way to learn is to try things.  As long as you aren't root (and
haven't yet created any important files), there's nothing you can mess up too
seriously.  So jump in - type each of these commands at the prompt and press
enter:
</p>
<ol type="1" start="1" >
<li>
<p>
<samp>pwd</samp>
</p>

<p>
<samp>pwd</samp> stands for Present Working Directory.  You should see the name
of the directory you're in on the screen - probably
<samp>/home/yourname</samp>.
</p>
</li>
</ol>
<ol type="1" start="2" >
<li>
<p>
<samp>ls</samp>
</p>

<p>
<samp>ls</samp> stands for &quot;list,&quot; as in &quot;list files.&quot; When
you type <samp>ls</samp>, you should see a list of all the files in your
present working directory.  If you've just installed Debian, your home
directory may well be empty.  If your present working directory is empty,
<samp>ls</samp> will not show anything on the screen.
</p>
</li>
</ol>
<ol type="1" start="3" >
<li>
<p>
<samp>cd /</samp>
</p>

<p>
<samp>cd</samp> means Change Directory.  In this case, you've asked to change
to the root directory.  Type <samp>pwd</samp> again, and verify that you're
presently working in the root directory.  Type <samp>ls</samp>, and see what's
in <samp>/</samp>.
</p>
</li>
</ol>
<ol type="1" start="4" >
<li>
<p>
<samp>cd</samp>
</p>

<p>
Typing <samp>cd</samp> by itself takes you to your home directory -
<samp>/home/yourname</samp>.  Try <samp>pwd</samp> to verify this.
</p>
</li>
</ol>
<ol type="1" start="5" >
<li>
<p>
<samp>mkdir practice</samp>
</p>

<p>
In your home directory, let's make a directory called <samp>practice</samp>.
We'll use this directory to try out some other commands.  You might type
<samp>ls</samp> to verify that your new directory exists.
</p>
</li>
</ol>
<ol type="1" start="6" >
<li>
<p>
<samp>cd practice</samp>
</p>

<p>
Change directory to <samp>practice</samp>.
</p>
</li>
</ol>
<ol type="1" start="7" >
<li>
<p>
<samp>mkdir mysubdirectory</samp>
</p>

<p>
Create a subdirectory of <samp>practice</samp>.
</p>
</li>
</ol>
<ol type="1" start="8" >
<li>
<p>
<samp>cp /etc/profile .</samp>
</p>

<p>
OK, things just got more complicated!  <samp>cp</samp> is short for
&quot;copy.&quot; <samp>/etc/profile</samp> is just a random file on your
system, don't worry about what it is for now.  We've copied it to
<samp>.</samp> - but what's <samp>.</samp>?  <samp>.</samp> just means
&quot;the directory I'm in now,&quot; or present working directory.  So we've
created a copy of <samp>/etc/profile</samp>, and put it in our
<samp>practice</samp> directory.  Try typing <samp>ls</samp> to verify that
there's indeed a file called <samp>profile</samp> in the present working
directory.
</p>
</li>
</ol>
<ol type="1" start="9" >
<li>
<p>
<samp>more profile</samp>
</p>

<p>
<samp>more</samp> is used to view the contents of text files, such as
<samp>/etc/profile</samp>.  It's called <samp>more</samp> because it shows a
page of the file at a time, and you press the space bar to see more.
<samp>more</samp> will exit when you get to the end of the file, or when you
type <samp>q</samp> (quit).  You might try typing <samp>more
/etc/profile</samp> as well, to verify that your copy looks just like the
original.
</p>
</li>
</ol>
<ol type="1" start="10" >
<li>
<p>
<samp>mv profile mysubdirectory</samp>
</p>

<p>
As you might guess, <samp>mv</samp> stands for &quot;move.&quot; We've moved
the file <samp>profile</samp> from the current directory into the subdirectory
we created earlier.  Perhaps type <samp>ls</samp> and/or <samp>ls
mysubdirectory</samp> to verify the move.
</p>
</li>
</ol>
<ol type="1" start="11" >
<li>
<p>
<samp>cd mysubdirectory</samp>
</p>

<p>
Change to the subdirectory.
</p>
</li>
</ol>
<ol type="1" start="12" >
<li>
<p>
<samp>mv profile myprofile</samp>
</p>

<p>
<samp>mv</samp> is also used to rename files - by moving them to a new name.
Thus there's no separate <samp>rename</samp> command.  Note that the second
argument to <samp>mv</samp> can be a directory to move the file or directory
into, or a new filename.  <samp>cp</samp> works the same way.
</p>

<p>
As usual, you can type <samp>ls</samp> to see the result of <samp>mv</samp>.
</p>
</li>
</ol>
<ol type="1" start="13" >
<li>
<p>
<samp>mv myprofile ..</samp>
</p>

<p>
Just as <samp>.</samp> means &quot;the directory I'm in now,&quot;
<samp>..</samp> means &quot;parent of the current directory,&quot; in this case
the <samp>practice</samp> directory we created earlier.  Use <samp>ls</samp> to
verify that that's where <samp>myprofile</samp> is now.
</p>
</li>
</ol>
<ol type="1" start="14" >
<li>
<p>
<samp>cd ..</samp>
</p>

<p>
Change directories to the parent directory - in this case
<samp>practice</samp>, where you just put <samp>myprofile</samp>.
</p>
</li>
</ol>
<ol type="1" start="15" >
<li>
<p>
<samp>rm myprofile</samp>
</p>

<p>
<samp>rm</samp> means &quot;remove&quot; - this deletes <samp>myprofile</samp>.
Be careful!  Deleting a file on a GNU/Linux system is <em>permanent</em> -
there is no undelete.  If you <samp>rm</samp> it, it's gone, forever.
</p>
</li>
</ol>
<ol type="1" start="16" >
<li>
<p>
<samp>rmdir mysubdirectory</samp>
</p>

<p>
<samp>rmdir</samp> is just like <samp>rm</samp>, only it's for directories.
Notice that <samp>rmdir</samp> only works on empty directories - if the
directory contains files, you must delete those files first, or alternatively
use <samp>rm -r</samp> in place of <samp>rmdir</samp>.
</p>
</li>
</ol>
<ol type="1" start="17" >
<li>
<p>
<samp>rmdir .</samp>
</p>

<p>
Oops!  That didn't work.  You can't delete a directory you're currently working
in.
</p>
</li>
</ol>
<ol type="1" start="18" >
<li>
<p>
<samp>cd ..</samp>
</p>

<p>
So move out of the current directory, and into its parent directory.  Now you
can type:
</p>
</li>
</ol>
<ol type="1" start="19" >
<li>
<p>
<samp>rmdir practice</samp>
</p>

<p>
This will delete the last remnants of your practice session.
</p>
</li>
</ol>

<p>
So now you know how to create, copy, move, rename, and delete files and
directories.  You also learned some shortcuts, like typing simply
<samp>cd</samp> to jump to your home directory, and <samp>.</samp> and
<samp>..</samp> to refer to the current directory and its parent, respectively.
</p>

<hr>

<h2><a name="s-files-structure"></a>4.3 What files are on my Debian system? Where should I put my own files?</h2>

<p>
Now that you can navigate the directory tree, let's take a guided tour of the
files and directories you created when you installed Debian.  If you're
curious, <samp>cd</samp> to each directory and type <samp>ls</samp> to see its
contents.  If the listing doesn't fit on the screen, try <samp>ls |
more</samp>, where <samp>|</samp> is the &quot;pipe&quot; character, generally
found on the same key with backslash.
</p>
<dl>
<dt><samp>/</samp></dt>
<dd>
<p>
As already mentioned, this is the root directory, which contains every other
directory.
</p>
</dd>
</dl>
<dl>
<dt><samp>/root</samp></dt>
<dd>
<p>
But don't get <samp>/</samp> confused with <samp>/root</samp>!
<samp>/root</samp> is the home directory of the root user, or superuser.  It's
a directory called <samp>/root</samp>, but it isn't <em>the</em> root directory
<samp>/</samp>.
</p>
</dd>
</dl>
<dl>
<dt><samp>/home</samp></dt>
<dd>
<p>
This is where all normal users - that is, all users except root - have their
home directories.  Home directories are named after the user who owns them.  If
you're using a large system at a school or business, your system administrator
may create additional directories to contain home directories:
<samp>/home1</samp> and <samp>/home2</samp> for example.
</p>

<p>
Your home directory is where you put all your personal work, email and other
information, and personal configuration preferences.
</p>
</dd>
</dl>
<dl>
<dt><samp>/bin</samp></dt>
<dd>
<p>
This directory contains &quot;binaries,&quot; executable files which are
essential to the operation of the system.  Examples are: the shell
(<samp>bash</samp>), and the commands you just learned such as <samp>cp</samp>.
</p>
</dd>
</dl>
<dl>
<dt><samp>/sbin</samp></dt>
<dd>
<p>
This directory contains &quot;system binaries,&quot; things that the root user
or system administrator might want to use, but probably you won't want to use
in your day-to-day activities.
</p>
</dd>
</dl>
<dl>
<dt><samp>/usr</samp></dt>
<dd>
<p>
<samp>/usr</samp> contains most of the files you'll be interested in.  It has
many subdirectories: <samp>/usr/bin</samp> and <samp>/usr/sbin</samp> are
pretty much like <samp>/bin</samp> and <samp>/sbin</samp>, except that the
directories in <samp>/usr</samp> are not considered &quot;essential to the
operation of the system.&quot;
</p>

<p>
While not essential to get the computer operating,<samp>/usr</samp> does
contain the applications you'll use to get real work done.  Also in
<samp>/usr</samp> you'll find the <samp>/usr/man</samp>,
<samp>/usr/info</samp>, and <samp>/usr/doc</samp> directories - these contain
manual pages, info pages, and other documentation, respectively.  And don't
forget <samp>/usr/games</samp>!
</p>
</dd>
</dl>
<dl>
<dt><samp>/usr/local</samp></dt>
<dd>
<p>
The Debian system doesn't install anything in this directory.  You should use
it if you want to install software that you compile yourself, or any software
not contained in a Debian package.  You can also install software in your home
directory, if you'll be the only one using it.
</p>
</dd>
</dl>
<dl>
<dt><samp>/etc</samp></dt>
<dd>
<p>
<samp>/etc</samp> contains all the system-wide configuration files.  Whenever
you want to change something that affects all users of your computer - such as
how you connect to the internet, or what kind of video card you have - you'll
probably have to log on as root and change a file in <samp>/etc</samp>.
</p>
</dd>
</dl>
<dl>
<dt><samp>/tmp</samp></dt>
<dd>
<p>
Here you'll find temporary files, most of them created by the system.  This
directory is generally erased on a regular basis, or every time you reboot the
system.  You can create files here if you want, just be aware they might get
deleted automatically.
</p>
</dd>
</dl>
<dl>
<dt><samp>/var</samp></dt>
<dd>
<p>
<samp>/var</samp> contains &quot;variable&quot; files, that the system changes
automatically.  For example, incoming mail is stored here.  The system keeps a
log of its actions here.  There are a number of other automatically generated
files here as well.  You'll mostly be interested in the contents of
<samp>/var/log</samp>, where you can find error messages and try to figure out
what you're system's up to if something goes wrong.
</p>
</dd>
</dl>

<p>
Clearly there are many more directories on the system, too many to describe
every one.  We'll get to some of them later in the manual.
</p>

<p>
For changing things, you'll usually want to confine yourself to your home
directory and <samp>/etc</samp>.  On a Debian system, there's rarely an
occasion to change anything else, because everything else is automatically
installed for you.
</p>

<p>
<samp>/etc</samp> is used to configure the <em>system</em> as a whole.  You'll
use your own home directory, a subdirectory of <samp>/home</samp>, for
configuring your own preferences, and storing your personal data.  The idea is
that on a day-to-day basis you confine yourself to <samp>/home/yourname</samp>,
so there's no way you can break anything.  Occasionally you log in as root to
change something in a system-wide directory, but only when absolutely
necessary.  Of course, if you're using Debian at a school or business and
someone else is the system administrator, you won't have root access and will
only be able to change your home directory.
</p>

<hr>

<h2><a name="s-files-permissions"></a>4.4 File ownership and permissions</h2>

<p>
GNU and Unix systems are set up to allow many people to use the same computer,
while keeping certain files private or keeping certain people from modifying
certain files.  You can verify this for yourself:
</p>
<ol type="1" start="1" >
<li>
<p>
Log in as yourself, i.e.  <em>NOT</em> as root.
</p>
</li>
</ol>
<ol type="1" start="2" >
<li>
<p>
<samp>rm /etc/resolv.conf</samp>
</p>

<p>
You should be told &quot;Permission denied.&quot; <samp>/etc/resolv.conf</samp>
is an essential system configuration file - you aren't allowed to change or
remove it unless you're root.  This keeps you from accidentally messing up the
system, and if the computer is a public one such as at an office or school, it
keeps users from messing up the system on purpose.
</p>
</li>
</ol>

<p>
Now type <samp>ls -l /etc/resolv.conf</samp>
</p>

<p>
This should give you output that looks something like this:
</p>

<pre>
     -rw-r--r-- 1 root root 119 Feb 23 1997 /etc/resolv.conf
</pre>

<p>
The <samp>-l</samp> option to <samp>ls</samp> requests all that additional
information.  The info on the right is easy - the size of the file is 119
bytes, the date the file was last changed is Feb 23 1997, the file's name is
<samp>/etc/resolv.conf</samp>.  On the left side of the screen, things get a
little more complicated.
</p>

<p>
First, the brief, technical explanation: the <samp>-rw-r--r--</samp> is the
<em>mode</em> of the file, the <samp>1</samp> is the number of hard links to
this file (or the number of files in a directory), and the two
<samp>root</samp> are the user and group owning the file.
</p>

<p>
So that was cryptic.  Let's go through it slowly (except the hard links part -
for that see <a href="#s-files-advanced-hardlinks">The real nature of files:
hard links and inodes, Section 4.8.1</a>).
</p>

<hr>

<h3><a name="s-files-permissions-groups"></a>4.4.1 Groups</h3>

<p>
Every file has two owners - a user, and a group.  The above case is a little
confusing, since there's a group called <samp>root</samp> in addition to the
<samp>root</samp> user.  Groups are just collections of users who are
collectively permitted access to some part of the system.  A good example is a
<samp>games</samp> group.  Just to be mean, you might set up your system so
that only people in a <samp>games</samp> group are allowed to play games.
</p>

<p>
A more practical example: say you're setting up a computer for a school.  You
might want certain files to be accessible only to teachers, not students, so
you put all the teachers in a single group.  Then you can tell the system that
certain files belong to members of the group <samp>teachers</samp>, and that no
one else can access those files.  Here are some things you can do to explore
groups on your system:
</p>
<ol type="1" start="1" >
<li>
<p>
<samp>groups</samp>
</p>

<p>
Typing this at the shell prompt will tell you what groups you're a member of.
It's likely that you're a member of only one group, which is identical to your
username.  (FIXME: find what the explanation for this is)
</p>
</li>
</ol>
<ol type="1" start="2" >
<li>
<p>
<samp>more /etc/group</samp>
</p>

<p>
This file lists the groups that exist on your system.  Notice the
<samp>root</samp> group (the only member of this group is the root user), and
the group which corresponds to your username.  There are also groups like
<samp>dialout</samp> (users who are allowed to dial out on the modem), and
<samp>floppy</samp> (users who can use the floppy drive).  However, your system
is probably not configured to make use of these groups - it's likely that only
root can use the floppy or the modem right now.  For details about this file,
try typing <samp>man group</samp>.
</p>
</li>
</ol>
<ol type="1" start="3" >
<li>
<p>
<samp>ls -l /home</samp>
</p>

<p>
Observe how every user's directory is owned by that user and that user's
personal group.  (If you just installed Debian, you may be the only user.)
</p>
</li>
</ol>

<hr>

<h3><a name="s-files-permissions-mode"></a>4.4.2 Mode</h3>

<p>
In addition to being owned by one user and one group, every file and directory
also has a mode, which determines who's allowed to read, write, and execute the
file.  There are a few other things also determined by the mode, but they're
advanced topics so we'll skip them for now.
</p>

<p>
The mode looks like this in the <samp>ls</samp> output:
<samp>-rw-r--r--</samp>.  There are ten &quot;spaces&quot; here, but the mode
actually consists of twelve bits (think of bits as switches which can be on or
off).  For now, we'll consider only nine of these bits: those that control
read, write, and execute permissions for the user owning the file, the group
owning the file, and everyone on the system (sometimes called
&quot;world&quot;).  Notice that three kinds of permission (read, write,
execute) times three sets of people who can have permission (user, group,
others) makes a total of nine combinations.
</p>

<p>
In the mode line, the first &quot;space&quot; gives the type of the file.  The
<samp>-</samp> in this case means it's a regular file.  If it was
<samp>d</samp>, we'd be looking at a directory.  There are other possibilities
too complex to go into now (see <a href="#s-files-advanced-types">Types of
files, Section 4.8.2</a>).
</p>

<p>
The remaining nine &quot;spaces&quot; are used to display the 12 bits that make
up the file's mode.  The basic 9 bits (read, write, and execute for user,
group, and other) are displayed as three blocks of <samp>rwx</samp>.  So if all
permissions are turned on, the mode will look like this:
<samp>-rwxrwxrwx</samp>.  (The remaining three bits are displayed by changing
the <samp>x</samp> to <samp>s</samp>, <samp>t</samp>, <samp>S</samp>, or
<samp>T</samp>, but this is a complex topic we're saving for later.)
</p>

<p>
In this context, &quot;read&quot;, &quot;write&quot;, and &quot;execute&quot;
have the following meanings:
</p>
<ul>
<li>
<p>
Read permission, indicated by <samp>r</samp>, gives permission to examine the
contents of a file.  For directories, it gives permission to list the contents
of the directory.
</p>
</li>
</ul>
<ul>
<li>
<p>
Write permission, indicated by <samp>w</samp>, gives permission to make changes
to a file.  For directories, it gives permission to create and remove files in
the directory.
</p>
</li>
</ul>
<ul>
<li>
<p>
Execute permission, indicated by <samp>x</samp>, gives permission to run the
file as a command.  Clearly it only makes sense to set execute permission if
the file actually is a command.
</p>

<p>
Since directories can never be executed, the execute bit has a different
meaning.  For directories, execute permission means permission to access files
in the directory.  Note that this interacts with write permissions: execute
permissions must be set to be able to access files in a directory <em>at
all</em>, so without execute permission on a directory, write permission is
useless.  Execute permission for directories is often called &quot;search&quot;
permission, since it really has nothing to do with execution.  &quot;File
access&quot; permission would probably be a still better name, but no one uses
it.
</p>
</li>
</ul>

<p>
Directory modes are a little confusing, so here are some examples of the
effects of various combinations:
</p>
<ul>
<li>
<p>
<samp>r--</samp>
</p>

<p>
The user, group, or other with these permissions may list the contents of the
directory, but nothing else.  The files in the directory can't be read,
changed, deleted, or manipulated in any way.  The only permitted action is
reading the directory itself, that is, seeing what files it contains.
</p>
</li>
</ul>
<ul>
<li>
<p>
<samp>rw-</samp>
</p>

<p>
Write permission has no effect in the absence of execute permission, so this
mode behaves just like the above mode.
</p>
</li>
</ul>
<ul>
<li>
<p>
<samp>r-x</samp>
</p>

<p>
This mode permits the files in a directory to be listed, and permits access to
those files.  However, files can't be created or deleted.  <em>Access</em>
means that you can view, change, or execute the files as permitted by the
files' own permissions.
</p>
</li>
</ul>
<ul>
<li>
<p>
<samp>--x</samp>
</p>

<p>
Files in this directory can be accessed, but the contents of the directory
can't be listed, so you have to know what filename you're looking for in
advance (unless you're a good guesser).  Files can't be created or deleted.
</p>
</li>
</ul>
<ul>
<li>
<p>
<samp>rwx</samp>
</p>

<p>
You can do anything you want with the files in this directory, as long as it's
permitted by the permissions on the files themselves.
</p>
</li>
</ul>

<p>
Directory write permission determines whether you can delete files in a
directory - a read-only file can be deleted, if you have permission to write to
the directory containing it.  You can't delete a file from a read-only
directory, even if you're allowed to make changes to the file.  File
permissions have nothing to do with deleting files.
</p>

<p>
This also means that if you own a directory you can always delete files from
it, even if those files belong to root.
</p>

<p>
Directory execute permission determines whether you have access to files - and
thus whether file permissions come into play.  <em>If</em> you have execute
permissions to a directory, file permissions for that directory become
relevant.  Otherwise file permissions just don't matter; you can't access the
files anyway.
</p>

<p>
If you have execute permission for the directory, file permissions determine
whether you can read the contents of the file, change the file, and/or execute
the file as a command.
</p>

<p>
FIXME: Are the next two paragraphs correct?
</p>

<p>
Finally, permission to change permissions on a file or directory is not
affected by the permissions of that file or directory.  Rather, you can always
change the permissions on files or directories that you own, but not on files
owned by someone else, as long as you are permitted access to the file.  So if
you can access a file you own at all (that is, you have execute permission in
the directory containing it) then you can change its permissions.
</p>

<p>
This means that you can't permanently remove permissions from yourself because
you can always give them back.  Say you remove user write permission from a
file you own, then try to change the file.  It won't be permitted, but you can
always give yourself write permission again and <em>then</em> change the file.
The only way to lose the ability to change permissions back is to lose access
to the file entirely.
</p>

<hr>

<h3><a name="s-files-permissions-tutorial"></a>4.4.3 Permissions in practice</h3>

<p>
FIXME: This isn't very thorough.  However, it seems like it thorough would make
it really long and involve making files as root to show the effects of
different ownership, etc.  and perhaps it's not worth it.
</p>

<p>
To change permissions, we'll use the <samp>chmod</samp> command.
</p>
<ol type="1" start="1" >
<li>
<p>
<samp>cd; touch myfile</samp>
</p>

<p>
There are a couple of new tricks here.  First, you can use <samp>;</samp> to
put two commands on one line.  You can type the above as:
</p>

<pre>
     $ cd 
     $ touch myfile
</pre>

<p>
or as:
</p>

<pre>
     $ cd; touch myfile
</pre>

<p>
and the same thing will end up happening.
</p>

<p>
Recall that <samp>cd</samp> by itself returns you to your home directory.
<samp>touch</samp> is normally used to change the modification time of the file
to the current time, but it has another interesting feature: if the file
doesn't exist, <samp>touch</samp> creates the file.  So we're using it to
create a file to practice with.  Use <samp>ls -l</samp> to confirm that the
file has been created, and notice the permissions mode:
</p>

<pre>
     $ ls -l 
     -rw-r--r-- 1 havoc havoc 0 Nov 18 22:04 myfile
</pre>

<p>
Obviously the time and user/group names will be different when you try it.  The
size of the file is 0, since <samp>touch</samp> creates an empty file.
<samp>-rw-r--r--</samp> is the default permissions mode on Debian (you can
change this - see FIXME: add ref to umask).
</p>
</li>
</ol>
<ol type="1" start="2" >
<li>
<p>
<samp>chmod u+x myfile</samp>
</p>

<p>
This command means to add (<samp>+</samp>) execute (<samp>x</samp>) permissions
for the user (<samp>u</samp>) who owns the file.  Use <samp>ls -l</samp> to see
the effects.
</p>
</li>
</ol>
<ol type="1" start="3" >
<li>
<p>
<samp>chmod go-r myfile</samp>
</p>

<p>
Here we've subtracted read permission from the group owning the file, and from
everyone else (others, <samp>o</samp>).  Again use <samp>ls -l</samp> to verify
the effects.
</p>
</li>
</ol>
<ol type="1" start="4" >
<li>
<p>
<samp>chmod ugo=rx myfile</samp>
</p>

<p>
Here we've set (<samp>=</samp>) user, group, and other permissions to read and
execute.  This sets permissions to <em>exactly</em> what you've specified, and
unsets any other permissions.  So all <samp>rx</samp> should be set, and all
<samp>w</samp> should be unset.  Now no one can write to the file.
</p>
</li>
</ol>
<ol type="1" start="5" >
<li>
<p>
<samp>chmod a-x myfile</samp>
</p>

<p>
<samp>a</samp> is a shortcut for <samp>ugo</samp>, or &quot;all&quot;.  So all
the <samp>x</samp> permissions should now be unset.
</p>
</li>
</ol>
<ol type="1" start="6" >
<li>
<p>
<samp>rm myfile</samp>
</p>

<p>
We're removing the file, but without write permissions.  <samp>rm</samp> will
ask if you're sure:
</p>

<pre>
     rm: remove `myfile', overriding mode 0444?
</pre>

<p>
You should respond by typing <samp>y</samp> and pressing enter.  This is a
feature of <samp>rm</samp>, not a fact of permissions - permission to delete a
file comes from the directory permissions, and you have write permission in the
directory.  However, <samp>rm</samp> tries to be helpful, figuring that if you
didn't want to change the file (and thus removed write permission), you don't
want to delete it either, so it asks you.
</p>
</li>
</ol>

<p>
What was that <samp>0444</samp> business in the question from <samp>rm</samp>?
Recall that the permissions mode is a twelve-digit binary number, like this:
<samp>000100100100</samp>.  <samp>0444</samp> is this binary number represented
as an octal (base 8) number, which is the conventional way to write a mode.  So
you can type <samp>chmod 444 myfile</samp> instead of <samp>chmod ugo=r
myfile</samp>.  See <a href="#s-files-advanced-permissions-absolute">Using
numeric arguments with <samp>chmod</samp>, Section 4.8.4.1</a>.
</p>

<hr>

<h2><a name="s-files-filesystems"></a>4.5 Filesystems</h2>

<p>
At this point it's probably a good idea to explain a little theory.  In
particular, the concept of a <em>filesystem</em>.  [<a href="footnotes.html#f2"
name="fr2">2</a>] This is confusing, because it has several meanings.
</p>
<ul>
<li>
<p>
<em>The</em> filesystem refers to the whole directory tree, starting with the
root directory <samp>/</samp>, as described above.
</p>
</li>
</ul>
<ul>
<li>
<p>
A &quot;filesystem&quot; in general means any organization of files and
directories on a particular physical device.  &quot;Organization&quot; means
the hierarchical directory structure, and any other information about files one
might want to keep track of: their size, who has permission to change them,
etc.  So you might have one filesystem on your hard disk, and another one on
each floppy disk.
</p>
</li>
</ul>
<ul>
<li>
<p>
&quot;Filesystem&quot; is also used to mean a <em>type</em> of filesystem.  For
example, MS-DOS and Windows 3.1 organize files in a particular way, with
particular rules: filenames can only have 8 characters, for example, and no
permissions information is stored.  Linux calls this the <samp>msdos</samp>
filesystem.  Linux also has its own filesystem, called the <samp>ext2</samp>
filesystem (version two of the &quot;extended&quot; filesystem).  You'll use
the <samp>ext2</samp> filesystem pretty much all the time, unless you're
accessing files from another operating system or have other special needs.
</p>
</li>
</ul>

<p>
Any physical device you wish to use for storing files must have at least one
filesystem on it.  This means a filesystem in the second sense - a hierarchy of
files and directories, along with information about them.  Of course, any
filesystem has a type, so the third sense will come into play as well.  If you
have more than one filesystem on a single device, each filesystem can have a
different type - for example, you might have both a DOS partition and a Linux
partition on your hard disk.
</p>

<p>
It's important to distinguish the filesystem from the low-level format of the
disk.  In the DOS and Macintosh worlds, the filesystem is called the high-level
format.  When you format a disk using one of those operating systems, generally
you both perform a low-level format and create a file system (high-level
format).  On GNU and Unix systems, one generally says simply &quot;format&quot;
to mean low-level format, and &quot;making a filesystem&quot; to mean
high-level format.
</p>

<p>
Formatting has to do with the particulars of the physical device, such as the
exact physical location of your data on a floppy disk (on the edge or in the
center of the disk for example).  The filesystem is the level of organization
you have to worry about - names of directories and files, their sizes, etc.
</p>

<hr>

<h2><a name="s-files-devices"></a>4.6 How to access particular devices (including hard disk partitions and floppy drives)</h2>

<p>
This section describes how to mount a floppy or Zip disk, the <samp>/dev</samp>
directory, and distributing the directory tree over multiple physical devices
or partitions.
</p>

<hr>

<h3><a name="s-files-devices-mounting"></a>4.6.1 Mounting a filesystem</h3>

<p>
As we said earlier, on a GNU/Linux system there's no necessary correspondence
between directories and physical devices, as there is in DOS for example where
each drive has its own directory tree beginning with a letter (such as
<samp>C:\</samp>).
</p>

<p>
Instead, each physical device such as a hard disk or floppy disk has one or
more filesystems on it.  In order to make a filesystem accessible, it's
assigned to a particular directory in another filesystem.  To avoid
circularity, the root filesystem (which contains the root directory
<samp>/</samp>) is not contained by any other filesystem - you have access to
it automatically when you boot Debian.
</p>

<p>
A directory in one filesystem which contains another filesystem is known as a
<em>mount point</em>.  A mount point is a directory in a first filesystem on
one device (such as your hard disk) but which contains a second filesystem,
perhaps on another device (such as a floppy disk).  To access a filesystem, you
must mount it at some mount point.
</p>

<p>
So, for example, you might mount a CD at the mount point <samp>/cdrom</samp>.
This means that if you look in the directory <samp>/cdrom</samp>, you'll see
the contents of the CD.  The <samp>/cdrom</samp> directory itself is actually
on your hard disk.  For all practical purposes the contents of the CD become a
part of the root filesystem, and when typing commands and using programs it
doesn't make any difference what the actual physical location of the files is.
You could have created a directory on your hard disk called
<samp>/cdrom</samp>, and put some files in it, and everything would behave in
exactly the same way.  Once you mount a filesystem, there's no need to pay any
attention to physical devices.
</p>

<p>
However, before mounting a filesystem, or to actually create a filesystem on a
disk that doesn't have one yet, it's necessary to refer to the devices
themselves.  All devices have names, and these are located in the
<samp>/dev</samp> directory.  If you type <samp>ls /dev</samp> now, you'll see
a pretty lengthy list of every possible device you could have on your Debian
system.
</p>

<p>
Possible devices include:
</p>
<ul>
<li>
<p>
<samp>/dev/hda</samp> is IDE drive A, usually called <samp>C:\</samp> on a DOS
or Windows system.  In general, this will be a hard drive.  IDE refers to the
type of drive - if you don't know what it means, you probably have this kind of
drive, because it's the most common.
</p>
</li>
</ul>
<ul>
<li>
<p>
<samp>/dev/hdb</samp> is IDE drive B, as you might guess.  This could be a
second hard drive, or perhaps a CD-ROM drive.  Drives A and B are the first and
second (master and slave) drives on the primary IDE controller.  Drives C and D
are the first and second drives on the secondary controller.
</p>
</li>
</ul>
<ul>
<li>
<p>
<samp>/dev/hda1</samp> is the first <em>partition</em> of IDE drive A.  Notice
that different drives are lettered, while specific partitions of those drives
are numbered as well.
</p>
</li>
</ul>
<ul>
<li>
<p>
<samp>/dev/sda</samp> is SCSI disk A.  SCSI is like IDE, only if you don't know
what it is you probably <em>don't</em> have one.  They're not very common in
home Intel PC's, though they're often used in servers and Macintoshes often
have SCSI disks.
</p>
</li>
</ul>
<ul>
<li>
<p>
<samp>/dev/fd0</samp> is the first floppy drive, generally <samp>A:\</samp>
under DOS.  Since floppy disks don't have partitions, they only have numbers,
rather than the letter-number scheme used for hard drives.  However, for floppy
drives the numbers refer to the drive, and for hard drives the numbers refer to
the partitions.
</p>
</li>
</ul>
<ul>
<li>
<p>
<samp>/dev/ttyS0</samp> is one of your serial ports.  <samp>/dev</samp>
contains the names of many devices, not just disk drives.
</p>
</li>
</ul>

<p>
To mount a filesystem, we want to tell Linux to associate whatever filesystem
it finds on a particular device with a particular mount point.  In the process,
we might have to tell Linux what kind of filesystem to look for.
</p>

<hr>

<h3><a name="s-files-devices-cdromexample"></a>4.6.2 Example: Mounting a CD-ROM</h3>

<p>
As a simple demonstration, we'll go through mounting a CD-ROM, such as the one
you may have used to install Debian.  You'll need to be root to do this, so be
careful; whenever you're root you have the power to mess up the whole system,
rather than just your own files.  Also, these commands assume there's a CD in
your drive; you should put one in the drive now.
</p>
<ol type="1" start="1" >
<li>
<p>
<samp>su</samp>
</p>

<p>
If you haven't already, you need to either log in as root or gain root
privileges with the <samp>su</samp> (super user) command.  If you use
<samp>su</samp>, enter the root password when prompted.
</p>
</li>
</ol>
<ol type="1" start="2" >
<li>
<p>
<samp>ls /cdrom</samp>
</p>

<p>
See what's in the <samp>/cdrom</samp> directory before you start.  If you don't
have a <samp>/cdrom</samp> directory, you may have to make one using
<samp>mkdir /cdrom</samp>.
</p>
</li>
</ol>
<ol type="1" start="3" >
<li>
<p>
<samp>mount</samp>
</p>

<p>
Typing simply <samp>mount</samp> with no arguments lists the currently mounted
filesystems.
</p>
</li>
</ol>
<ol type="1" start="4" >
<li>
<p>
<samp>mount -t iso9660 <var>CD device</var> /cdrom</samp>
</p>

<p>
For this command, you should substitute the name of your CD-ROM device for
<samp><var>CD device</var></samp> in the above command line.  If you aren't
sure, <samp>/dev/hdc</samp> is a good guess.  If that fails, try the different
IDE devices: <samp>/dev/hda</samp>, etc.  You should see a message like:
</p>

<pre>
     mount: block device /dev/hdc is write-protected, mounting read-only
</pre>

<p>
The <samp>-t</samp> option specifies the type of the filesystem, in this case
<samp>iso9660</samp>.  Most CDs are <samp>iso9660</samp>.  The next argument is
the name of the device to mount, and the final argument is the mount point.
There are many other arguments to <samp>mount</samp>; see the man page for
details.  (For example, you could avoid the above message by specifying
read-only on the command line.)
</p>

<p>
Once a CD is mounted, you may find that your drive tray will not open.  You
must unmount the CD before removing it.
</p>
</li>
</ol>
<ol type="1" start="5" >
<li>
<p>
<samp>ls /cdrom</samp>
</p>

<p>
Confirm that <samp>/cdrom</samp> now contains whatever is on the CD in your
drive.
</p>
</li>
</ol>
<ol type="1" start="6" >
<li>
<p>
<samp>mount</samp>
</p>

<p>
Look at the list of filesystems again, noticing that your CD drive is now
mounted.
</p>
</li>
</ol>
<ol type="1" start="7" >
<li>
<p>
<samp>umount /cdrom</samp>
</p>

<p>
This unmounts the CD.  It's now safe to remove the CD from the drive.  Notice
that the command is <samp>umount</samp> with no &quot;n&quot;, even though it's
used to u<em>n</em>mount the filesystem.
</p>
</li>
</ol>
<ol type="1" start="8" >
<li>
<p>
<samp>exit</samp>
</p>

<p>
Don't leave yourself logged on as root.  Log out immediately, just to be safe.
</p>
</li>
</ol>

<hr>

<h3><a name="s-files-devices-fstab"></a>4.6.3 <samp>/etc/fstab</samp>: Automating the mount process</h3>

<p>
The file <samp>/etc/fstab</samp> (it stands for &quot;file system table&quot;)
contains descriptions of filesystems that you mount often.  These filesystems
can then be mounted with a shorter command, such as <samp>mount /cdrom</samp>.
You can also configure filesystems to mount automatically when the system
boots.  You'll probably want to mount all of your hard disk filesystems when
you boot.
</p>

<p>
Look at this file now, by typing <samp>more /etc/fstab</samp>.  It will have
two or more entries that were configured automatically when you installed the
system.  It probably looks something like this:
</p>

<pre>
     # /etc/fstab: static file system information.
     #
     # &lt;file system&gt;     &lt;mount point&gt;   &lt;type&gt;  &lt;options&gt;   &lt;dump &gt;  &lt;pass&gt;
     /dev/hda1            /               ext2    defaults    0       1
     /dev/hda3            none            swap    sw          0       0
     proc                 /proc           proc    defaults    0       0
     
     /dev/hda5            /tmp            ext2    defaults    0       2
     /dev/hda6            /home           ext2    defaults    0       2
     /dev/hda7            /usr            ext2    defaults    0       2
     
     /dev/hdc             /cdrom          iso9660 ro          0       0
     /dev/fd0             /floppy         auto    noauto,sync 0       0
</pre>

<p>
The first column lists the device the filesystem resides on.  The second lists
the mount point, the third the filesystem type.  The line beginning
<samp>proc</samp> is a special filesystem explained in <a
href="#s-files-advanced-proc">The <samp>proc</samp> filesystem, Section
4.8.3</a>.  Notice that the swap partition (<samp>/dev/hda3</samp> in the
example) has no mount point, so the mount point column contains
<samp>none</samp>.
</p>

<p>
The last three columns may require some explanation.
</p>

<p>
The fifth column is used by the <samp>dump</samp> utility to decide when to
back up the filesystem.  FIXME: cross ref to <samp>dump</samp>
</p>

<p>
The sixth column is used by <samp>fsck</samp> to decide in what order to check
filesystems when you boot the system.  The root filesystem should have a
<samp>1</samp> in this field, filesystems which don't need to be checked (such
as the swap partition) should have a <samp>0</samp>, and all other filesystems
should have a <samp>2</samp>.  FIXME: cross ref to <samp>fsck</samp>, also, is
the swap partition really a filesystem?
</p>

<p>
Column four contains one or more options to use when mounting the filesystem.
Here's a brief summary (some of these probably won't make much sense yet -
they're here for future reference):
</p>
<dl>
<dt><samp>async</samp> and <samp>sync</samp></dt>
<dd>
<p>
Do I/O synchronously or asynchronously.  Synchronous I/O writes changes to
files immediately, while asynchronous I/O may keep data in buffers and write it
later, for efficiency reasons.  FIXME: cross ref to section on sync for full
explanation.  Also, should recommend when to choose one or the other.
</p>
</dd>
</dl>
<dl>
<dt><samp>ro</samp> and <samp>rw</samp></dt>
<dd>
<p>
Mount the filesystem read-only or read-write.  If you don't need to make any
changes to the filesystem, it's a good idea to mount it read-only so you don't
accidentally mess something up.  Also, read-only devices (such as CD-ROM drives
and floppy disks with write protection tabs) should be mounted read-only.
</p>
</dd>
</dl>
<dl>
<dt><samp>auto</samp> and <samp>noauto</samp></dt>
<dd>
<p>
When the system boots, or whenever you type <samp>mount -a</samp>,
<samp>mount</samp> tries to mount all the filesystems listed in
<samp>/etc/fstab</samp>.  If you don't want it to automatically mount a
filesystem, you should use the <samp>noauto</samp> option.  It's probably a
good idea to use <samp>noauto</samp> with removable media such as floppy disks,
because there may or may not be a disk in the drive.  You'll want to mount
these filesystems manually after you put in a disk.
</p>
</dd>
</dl>
<dl>
<dt><samp>dev</samp> and <samp>nodev</samp></dt>
<dd>
<p>
Use or ignore device files on this filesystem.  You might use
<samp>nodev</samp> if you mount the root directory of another system on your
system - you don't want your system to try to use the devices on the other
system.
</p>
</dd>
</dl>
<dl>
<dt><samp>user</samp> and <samp>nouser</samp></dt>
<dd>
<p>
Permit or forbid ordinary users to mount the filesystem.  <samp>nouser</samp>
means that only root can mount the filesystem.  This is the normal arrangement.
You might use the <samp>user</samp> option to access the floppy drive without
having to be root.
</p>
</dd>
</dl>
<dl>
<dt><samp>exec</samp> and <samp>noexec</samp></dt>
<dd>
<p>
Allow or do not allow the execution of files on this filesystem.  Probably you
won't need these options.
</p>
</dd>
</dl>
<dl>
<dt><samp>suid</samp> and <samp>nosuid</samp></dt>
<dd>
<p>
Allow or do not allow the suid bit to take effect.  Probably you won't need
these options.  See <a href="#s-files-advanced-permissions-suid">Making files
suid/sgid, Section 4.8.4.2</a>.
</p>
</dd>
</dl>
<dl>
<dt><samp>defaults</samp></dt>
<dd>
<p>
Equivalent to: <samp>rw</samp>, <samp>dev</samp>, <samp>suid</samp>,
<samp>exec</samp>, <samp>auto</samp>, <samp>nouser</samp>, <samp>async</samp>.
You can specify <samp>defaults</samp> followed by other options to override
specific aspects of <samp>defaults</samp>.
</p>
</dd>
</dl>

<hr>

<h3><a name="s-files-devices-removable"></a>4.6.4 Removable disks (floppies, Zip disks, etc.)</h3>

<p>
How to use them - setting things up so you can access them nicely from
userspace.
</p>

<p>
FIXME I'm actually not sure how to write this.  What's in fstab on a default
installation?  Should we do the manual su root thing, or one of those EZ floppy
mounting packages?  Perhaps do something with group permissions?  Or just the
<samp>user</samp> option in fstab?
</p>

<hr>

<h3><a name="s-files-devices-preparing"></a>4.6.5 Preparing disks for use: formatting and creating a filesystem</h3>

<hr>

<h2><a name="s-files-misc"></a>4.7 Miscellaneous topics</h2>

<hr>

<h3><a name="s-files-misc-viewing"></a>4.7.1 Viewing the contents of files</h3>

<p>
There are several ways to look at what's in a file; each one has different
uses.
</p>

<p>
The simplest way is to use <samp>cat</samp>.  <samp>cat</samp> is short for
&quot;concatenate&quot;, and it dumps the contents of files to the screen
(actually to the <em>standard output</em>, but that's in another chapter).  If
you pass it two or more files, it dumps them to the screen in order as if they
were one big file - i.e., it concatenates them.  However, if you pass it only
one file, with the syntax <samp>cat <var>myfile</var></samp>, it simply dumps
that file to the screen.  Try typing <samp>cat /etc/profile</samp>, to see the
contents of that file.
</p>

<p>
The problem with <samp>cat</samp> is that it's just an uncontrolled dump, which
is bad if the file is longer than one screen.  You can't see the beginning of
the file.  The solution is the <samp>more</samp> command, which displays a file
one page at a time.  <samp>less</samp> does the same thing, only it has more
features (&quot;less is more&quot;).  These are invoked in the same way as
<samp>cat</samp>: the command name followed by the filename.  You may have to
type <samp>q</samp> to exit from <samp>less</samp>, but <samp>more</samp> will
exit on its own when you reach the end of the file.
</p>

<p>
These utilities are limited to viewing text files; for viewing the raw form of
other kinds of files you might have to use a specialized utility such as
<samp>od</samp> (octal dump).  For viewing images, word processor documents,
and that kind of thing, you'll need to use an appropriate application.  There
are also many more specialized ways to look at text files: for example, you
might look at only the end of the file, or at lines containing a certain word.
These more specialized tools will be covered in a later chapter.  FIXME: add
cross reference
</p>

<hr>

<h3><a name="s-files-misc-dotfiles"></a>4.7.2 Hidden files beginning with <samp>.</samp></h3>

<p>
On GNU and Unix systems, any file beginning with a period (aka a dot) is
normally not visible.  You can see them by using the <samp>-a</samp> option to
<samp>ls</samp>.
</p>
<ol type="1" start="1" >
<li>
<p>
<samp>cd</samp>
</p>

<p>
<samp>cd</samp> to your home directory.
</p>
</li>
</ol>
<ol type="1" start="2" >
<li>
<p>
<samp>ls -a</samp>
</p>

<p>
List <em>all</em> files in the directory, even the dotfiles.
</p>
</li>
</ol>

<p>
You should see a number of files, all beginning with a <samp>.</samp>, that you
don't normally see when you type <samp>ls</samp>.  You'll also see simply
<samp>.</samp> and <samp>..</samp>, representing this directory and its parent.
If you type <samp>ls -A</samp> with capital A you won't see these two.
</p>

<p>
The reason for dotfiles is that many files have nothing to do with your day to
day work - rather, they're used for configuring your applications and storing
machine-generated data.  Thus, they're hidden out of the way so they don't
clutter up the directory.
</p>

<p>
Dotfiles are somewhat analagous to control panels on a Macintosh, or the
<samp>AUTOEXEC.BAT</samp> file under DOS.  You can ignore them for now - later
in the manual we'll explain how to use some of these files to customize your
personal Debian settings.
</p>

<p>
Many dotfiles have a system-wide analogue in the <samp>/etc</samp> directory.
For instance, you may have a <samp>.bash_profile</samp> in your directory.
This corresponds to <samp>/etc/profile</samp>.  Changes to
<samp>/etc/profile</samp> affect everyone, changes to
<samp>.bash_profile</samp> affect only you.
</p>

<hr>

<h3><a name="s-files-misc-find"></a>4.7.3 Finding a file on the system</h3>

<p>
There are two different facilities for finding files: <samp>find</samp> and
<samp>locate</samp>.  <samp>find</samp> searches the actual files in their
present state.  <samp>locate</samp> searches an index generated by the system
every morning at 6:42 a.m.  (this is a <samp>cron</samp> job, explained
elsewhere in this manual).  <samp>locate</samp> won't find any files which were
created after the index was generated.  However, since <samp>locate</samp>
searches an index, it's much faster - like using the index of a book rather
than looking through the whole thing.
</p>

<p>
To compare the two ways of finding files, pretend you can't remember where the
X configuration file <samp>XF86Config</samp> resides.
</p>
<ol type="1" start="1" >
<li>
<p>
<samp>locate XF86Config</samp>
</p>

<p>
This should be pretty fast.  You'll get a list of filenames which
<em>contain</em> <samp>XF86Config</samp>, something like this:
</p>

<pre>
     /etc/X11/XF86Config 
     /usr/X11R6/lib/X11/XF86Config
     /usr/X11R6/lib/X11/XF86Config.eg
     /usr/X11R6/man/man5/XF86Config.5x.gz
</pre>
</li>
</ol>
<ol type="1" start="2" >
<li>
<p>
<samp>find / -name XF86Config</samp>
</p>

<p>
You will hear a lot of disk activity, and this will take a lot longer.  If
hearing your disk grind for a long time pains you, you may not want to actually
type this command.  Results will look something like this:
</p>

<pre>
     /etc/X11/XF86Config 
     /usr/X11R6/lib/X11/XF86Config 
     find: /var/spool/cron/atjobs: Permission denied 
     find: /var/spool/cron/atspool: Permission denied
     find: /var/lib/xdm/authdir: Permission denied
</pre>

<p>
Notice that <samp>find</samp> only found files which were named
<em>exactly</em> <samp>XF86Config</samp>, rather than any files containing that
string of letters.  Also, <samp>find</samp> actually tried to look in every
directory on the system - including some where you didn't have read
permissions.  Thus the &quot;Permission denied&quot; messages.
</p>

<p>
The syntax is different as well.  You had to specify what directory to search
in - <samp>/</samp> - while locate automatically chose the root directory.  And
you had to specify a search by name, using the <samp>-name</samp> option.  You
could also have searched for files using many other criteria, such as
modification date or owner.
</p>
</li>
</ol>

<p>
In general <samp>find</samp> is a more powerful utility, and
<samp>locate</samp> is faster for everyday quick searches.  The full range of
possible searches would take a long time to explain; for more details type
<samp>info find</samp>, which will bring up the very thorough info pages on
<samp>find</samp> and <samp>locate</samp>.
</p>

<hr>

<h3><a name="s-files-misc-compression"></a>4.7.4 Compressing files with <samp>gzip</samp></h3>

<p>
Often it would be nice to make a file smaller: say to download it faster, or so
it takes up less space on your disk.  The program to do this is called
<samp>gzip</samp> (GNU Zip).
</p>
<ol type="1" start="1" >
<li>
<p>
<samp>cd; cp /etc/profile ./mysamplefile</samp>
</p>

<p>
Switch to your home directory, then copy an arbitrarily chosen file
(<samp>/etc/profile</samp>) to your current directory in the process renaming
it <samp>mysamplefile</samp>.  This gives us a file to play with using
<samp>gzip</samp>.
</p>
</li>
</ol>
<ol type="1" start="2" >
<li>
<p>
<samp>ls -l</samp>
</p>

<p>
List the contents of the current directory.  Note the size of
<samp>mysamplefile</samp>.
</p>
</li>
</ol>
<ol type="1" start="3" >
<li>
<p>
<samp>gzip mysamplefile</samp>
</p>

<p>
Compress <samp>mysamplefile</samp>.
</p>
</li>
</ol>
<ol type="1" start="4" >
<li>
<p>
<samp>ls -l</samp>
</p>

<p>
Observe the results: <samp>mysamplefile</samp> is now called
<samp>mysamplefile.gz</samp>.  It's also a good bit smaller.
</p>
</li>
</ol>
<ol type="1" start="5" >
<li>
<p>
<samp>gunzip mysamplefile.gz; ls -l</samp>
</p>

<p>
Uncompress.  Observe that <samp>mysamplefile</samp> has returned to its
original state.  Notice that to <em>uncompress</em> one uses
<samp>gunzip</samp>, not <samp>gzip</samp>.
</p>
</li>
</ol>
<ol type="1" start="6" >
<li>
<p>
<samp>rm mysamplefile</samp>
</p>

<p>
Remove the file, since it was just to practice with.
</p>
</li>
</ol>

<hr>

<h3><a name="s-files-misc-split"></a>4.7.5 Splitting files into smaller parts</h3>

<p>
Sometimes a file is too big to fit on a disk, or you don't want to send a huge
file over the net in a single chunk.  You can split the file using the
<samp>split</samp> utility, and reassemble it using the <samp>cat</samp>
(con<em>cat</em>enate) utility.
</p>
<ol type="1" start="1" >
<li>
<p>
<samp>cd; cp /bin/bash myfile; ls -l myfile</samp>
</p>

<p>
Copy the <samp>bash</samp> executable to a file in your home directory called
<samp>myfile</samp>.  Observe that <samp>myfile</samp> occupies a little over
300,000 bytes, or around 300 kilobytes.
</p>
</li>
</ol>
<ol type="1" start="2" >
<li>
<p>
<samp>split -b100k myfile myprefix</samp>
</p>

<p>
Splits the file into sections of 100 kilobytes, naming the sections
<samp>myprefixaa</samp>, <samp>myprefixab</samp>, etc.  Type <samp>ls -l</samp>
so see the results.
</p>

<p>
You can specify any number after the <samp>-b</samp>: choose one that makes
sense.  If you leave off the <samp>k</samp>, it will be understood as bytes
instead of kilobytes.  If you use <samp>m</samp> instead of <samp>k</samp>, it
will be understood as megabytes.
</p>
</li>
</ol>
<ol type="1" start="3" >
<li>
<p>
<samp>cat myprefix* &gt; mynewfile</samp>
</p>

<p>
Concatenate all the files and write them to <samp>mynewfile</samp>.  the
<samp>*</samp> and <samp>&gt;</samp> are tricks you'll learn in a later
chapter.
</p>
</li>
</ol>
<ol type="1" start="4" >
<li>
<p>
<samp>rm myfile mynewfile myprefix*</samp>
</p>

<p>
Remove everything.
</p>
</li>
</ol>

<hr>

<h3><a name="s-files-misc-diskspace"></a>4.7.6 Managing disk space</h3>

<p>
Probably you don't have all the disk space you might want, and your disks will
eventually fill up.  This section will describe how to find out how much space
there is, and gives some tips on how to open up more space.  e.g.  finding and
sorting files by size, <samp>df</samp>, <samp>du</samp>, strategic gzip,
removing unecessary packages.
</p>

<hr>

<h3><a name="s-files-misc-tar"></a>4.7.7 Backups and large-scale file copying</h3>

<p>
How to use tar to copy lots of files, or back up your files.  Tarballs.  I'm
thinking this should be a brief section aimed at single-user systems, with a
more thorough sysadmin discussion in a different manual.
</p>

<p>
Backup commands (contributed by Oliver Elphick, section to be cleaned up and
elaborated):
</p>

<p>
dump - dumps one filesystem at a time; its command options assume that you are
using half-inch tape (maximum 45Mb per reel) so it's a bit annoying when using
DAT (2Gb or more).  Probably the best for regular backups.  Can't be used for
NFS-mounted filesystems.
</p>

<p>
cpio - `find [directories] -print | cpio -ovH newc -B &gt;/dev/st0'
</p>

<p>
tar - `tar cvf /dev/st0 [directories]'
</p>

<p>
afio - like cpio; supports pre-compression of files before archiving.
</p>

<p>
tob - front-end for afio
</p>

<hr>

<h3><a name="s-files-misc-guessing"></a>4.7.8 Guessing a file's contents</h3>

<p>
Debian comes with a utility which can guess at the contents of a file for you.
It is not always correct.  However, it is reasonably accurate, and you can use
it to explore your system.
</p>
<ol type="1" start="1" >
<li>
<p>
<samp>file /bin/cp</samp>
</p>

<p>
You should see something like this:
</p>

<pre>
     /bin/cp: ELF 32-bit LSB executable, Intel 386, version 1, stripped
</pre>

<p>
Skipping the technical parts, this is an executable file for Intel machines.
</p>
</li>
</ol>
<ol type="1" start="2" >
<li>
<p>
<samp>file /etc/init.d/boot</samp>
</p>

<p>
Gives this response:
</p>

<pre>
     /etc/init.d/boot: Bourne shell script text
</pre>

<p>
Meaning that this is a text file, containing a Bourne shell script (see the
Shells chapter).
</p>
</li>
</ol>

<hr>

<h3><a name="s-files-misc-umask"></a>4.7.9 Defining default permissions with <samp>umask</samp></h3>

<hr>

<h2><a name="s-files-advanced"></a>4.8 Advanced Topics</h2>

<hr>

<h3><a name="s-files-advanced-hardlinks"></a>4.8.1 The real nature of files: hard links and inodes</h3>

<p>
Each file on your system is represented by an <em>inode</em> (eye-node): an
inode contains all the information about the file.  However, the inode is not
directly visible.  Instead, each inode is linked into the filesystem by one or
more <em>hard links</em>.  Hard links contain the name of the file, and the
inode number.  The inode contains the file itself, i.e., the location of the
information being stored on disk, its access permissions, the type of the file,
and so on.  The system can find any inode once it has the inode number.
</p>

<p>
A single file can have more than one hard link.  What this means is that
multiple filenames refer to the same file (that is, they are associated with
the same inode number).  However, you can't make hard links across filesystems:
all hard references to a particular file (inode) must be on the same
filesystem.  (I'm guessing this is because each filesystem has its own set of
inodes, and there will be duplicate inode numbers between filesystems.  FIXME:
find out why for real)
</p>

<p>
Since all hard links to a given inode are referring to <em>the same file</em>,
you can make changes to the file, referring to it by one name, and then see
those changes referring to it by a different name.  Try this:
</p>
<ol type="1" start="1" >
<li>
<p>
<samp>cd; echo &quot;hello&quot; &gt; firstlink</samp>
</p>

<p>
<samp>cd</samp> to your home directory and create a file called
<samp>firstlink</samp> containing the word &quot;hello&quot;.  What you've
actually done is redirect the output of <samp>echo</samp> (<samp>echo</samp>
just echoes back what you give to it), placing the output in
<samp>firstlink</samp>.  See the chapter on shells for a full explanation.
</p>
</li>
</ol>
<ol type="1" start="2" >
<li>
<p>
<samp>cat firstlink</samp>
</p>

<p>
Confirm the contents of <samp>firstlink</samp>.
</p>
</li>
</ol>
<ol type="1" start="3" >
<li>
<p>
<samp>ln firstlink secondlink</samp>
</p>

<p>
Create a hard link: <samp>secondlink</samp> now points to the same inode as
<samp>firstlink</samp>.
</p>
</li>
</ol>
<ol type="1" start="4" >
<li>
<p>
<samp>cat secondlink</samp>
</p>

<p>
Confirm that <samp>secondlink</samp> is the same as <samp>firstlink</samp>
</p>
</li>
</ol>
<ol type="1" start="5" >
<li>
<p>
<samp>ls -l</samp>
</p>

<p>
Notice that the number of hard links listed for <samp>firstlink</samp> and
<samp>secondlink</samp> is 2.
</p>
</li>
</ol>
<ol type="1" start="6" >
<li>
<p>
<samp>echo &quot;change&quot; &gt;&gt; secondlink</samp>
</p>

<p>
This is another shell redirection trick - don't worry about the details.  We've
appended the word &quot;change&quot; to <samp>secondlink</samp>.  Confirm this
with <samp>cat secondlink</samp>.
</p>
</li>
</ol>
<ol type="1" start="7" >
<li>
<p>
<samp>cat firstlink</samp>
</p>

<p>
<samp>firstlink</samp> also has the word &quot;change&quot; appended!  It's
because <samp>firstlink</samp> and <samp>secondlink</samp> refer to <em>the
same file</em>.  It doesn't matter what you call it when you change it.
</p>
</li>
</ol>
<ol type="1" start="8" >
<li>
<p>
<samp>chmod a+rwx firstlink</samp>
</p>

<p>
Change permissions on <samp>firstlink</samp>.  Do <samp>ls -l</samp> to confirm
that permissions on <samp>secondlink</samp> were also changed.  This means that
permissions information is stored in the inode, not in links.
</p>
</li>
</ol>
<ol type="1" start="9" >
<li>
<p>
<samp>rm firstlink</samp>
</p>

<p>
Delete this link.  This is a subtlety of <samp>rm</samp> - it really removes
links, not files.  Now type <samp>ls -l</samp> and notice that
<samp>secondlink</samp> is still there.  Also notice that the number of hard
links for <samp>secondlink</samp> has been reduced to one.
</p>
</li>
</ol>
<ol type="1" start="10" >
<li>
<p>
<samp>rm secondlink</samp>
</p>

<p>
Delete the other link.  When there are no more links to a file, Linux deletes
the file itself, that is, its inode.
</p>
</li>
</ol>

<p>
All files work like this - even special types of files such as devices (e.g.
<samp>/dev/hda</samp>).
</p>

<p>
A directory is simply a list of filenames and inode numbers, that is, a list of
hard links.  When you create a hard link, you're just adding a name-number pair
to a directory.  When you delete a file, you're just removing a hard link from
a directory.
</p>

<hr>

<h3><a name="s-files-advanced-types"></a>4.8.2 Types of files</h3>

<p>
One detail we've been concealing up to now is that Unix considers nearly
everything to be a file.  That includes directories and devices: they're just
special kinds of files.
</p>

<p>
As you may remember, the first letter of an <samp>ls -l</samp> display
represents the type of the file.  For an ordinary file, this will be simply
<samp>-</samp>.  Other possibilities are:
</p>
<ul>
<li>
<p>
<samp>d</samp> (directory)
</p>
</li>
</ul>
<ul>
<li>
<p>
<samp>l</samp> (symbolic link)
</p>
</li>
</ul>
<ul>
<li>
<p>
<samp>b</samp> (block device)
</p>
</li>
</ul>
<ul>
<li>
<p>
<samp>c</samp> (character device)
</p>
</li>
</ul>
<ul>
<li>
<p>
<samp>p</samp> (named pipe)
</p>
</li>
</ul>
<ul>
<li>
<p>
<samp>s</samp> (socket)
</p>
</li>
</ul>

<hr>

<h4><a name="s-files-advanced-types-symlinks"></a>4.8.2.1 Symbolic links</h4>

<p>
Symbolic links (also called symlinks or soft links) are the other kind of link
besides hard links.  A symlink is a file (with its own inode and hard link!)
that &quot;points to&quot; a hard link on any mounted filesystem.  When you try
to read the contents of a symlink, it gives the contents of the file it's
pointing to rather than the contents of the symlink itself.  Since directories,
devices, and other symlinks are types of files, you can point a symlink at any
of those things.
</p>

<p>
So a hard link is a filename and an inode number.  A file is really an inode: a
location on disk, file type, permissions mode, etc.  A symlink is an inode that
contains the name of a hard link.
</p>

<p>
All hard links to the same file have equal status.  That is, one is as good as
the other; if you perform any operation on one it's just the same as performing
that operation on any of the others.  This is because the hard links all refer
to the same inode.  Operations on symlinks, on the other hand, sometimes affect
the symlink's own inode (the one containing the name of a hard link) and
sometimes affect the hard link being pointed to.
</p>

<p>
There are a number of important differences between symlinks and hard links:
</p>
<ul>
<li>
<p>
Symlinks can cross filesystems.  (I'm guessing this is because they contain
complete filenames, starting with the root directory, and all complete
filenames are unique.  Since hard links contain inode numbers, they would be
ambiguous if the filesystem wasn't known.  FIXME: find out for real)
</p>
</li>
</ul>
<ul>
<li>
<p>
You can make symlinks to directories, but you can't make hard links to them.
Directories can have only one hard link: they can be listed in their parent
directory.  You can't create additional hard links to a directory.  Thus, the
output of <samp>ls -l</samp> lists the number of hard links <em>in</em> a
directory, and the number of hard links <em>to</em> a file.
</p>
</li>
</ul>
<ul>
<li>
<p>
You can only make a hard link to a file that exists, because there must be an
inode number to refer to.  However, you can make a symlink to any filename,
whether or not there actually is such a filename.
</p>
</li>
</ul>
<ul>
<li>
<p>
Removing a symlink removes only the link.  It has no effect on the linked-to
file.  Removing the only hard link to a file removes the file.
</p>
</li>
</ul>

<p>
Try this:
</p>
<ol type="1" start="1" >
<li>
<p>
<samp>cd; ln -s /tmp/me MyTmp</samp>
</p>

<p>
<samp>cd</samp> to your home directory.  <samp>ln</samp> with the
<samp>-s</samp> option makes a symbolic link; in this case, one called
<samp>MyTmp</samp> which points to the filename <samp>/tmp/me</samp>.
</p>
</li>
</ol>
<ol type="1" start="2" >
<li>
<p>
<samp>ls -l MyTmp</samp>
</p>

<p>
Output should look like this:
</p>

<pre>
     lrwxrwxrwx   1 havoc    havoc           7 Dec  6 12:50 MyTmp -&gt; /tmp/me
</pre>

<p>
The date and user/group names will be different for you, of course.  Notice
that the file type is <samp>l</samp>, indicating that this is a symbolic link.
Also notice the permissions - symbolic links always have these permissions.  If
you attempt to <samp>chmod</samp> a symlink, you'll actually change the
permissions on the file being pointed to.
</p>
</li>
</ol>
<ol type="1" start="3" >
<li>
<p>
<samp>chmod 700 MyTmp</samp>
</p>

<p>
You should get a &quot;No such file or directory&quot; error, because the file
<samp>/tmp/me</samp> doesn't exist.  Notice that you could create a symlink to
it anyway.
</p>
</li>
</ol>
<ol type="1" start="4" >
<li>
<p>
<samp>mkdir /tmp/me</samp>
</p>

<p>
Create the directory <samp>/tmp/me</samp>.
</p>
</li>
</ol>
<ol type="1" start="5" >
<li>
<p>
<samp>chmod 700 MyTmp</samp>
</p>

<p>
Should work now.
</p>
</li>
</ol>
<ol type="1" start="6" >
<li>
<p>
<samp>touch MyTmp/myfile</samp>
</p>

<p>
Create a file in <samp>MyTmp</samp>.
</p>
</li>
</ol>
<ol type="1" start="7" >
<li>
<p>
<samp>ls /tmp/me</samp>
</p>

<p>
The file was actually created in <samp>/tmp/me</samp>.
</p>
</li>
</ol>
<ol type="1" start="8" >
<li>
<p>
<samp>rm MyTmp</samp>
</p>

<p>
Remove the symbolic link.  Notice that this removes the link, not what it
points to.  Thus you use <samp>rm</samp> not <samp>rmdir</samp>.
</p>
</li>
</ol>
<ol type="1" start="9" >
<li>
<p>
<samp>rm /tmp/me/myfile; rmdir /tmp/me</samp>
</p>

<p>
Clean up after ourselves.
</p>
</li>
</ol>

<hr>

<h4><a name="s-files-misc-types-devices"></a>4.8.2.2 Device files</h4>

<p>
Device files refer to physical or virtual devices on your system, such as your
hard disk, video card, screen, or keyboard.  An example of a virtual device is
the console, represented by <samp>/dev/console</samp>.
</p>

<p>
There are two kinds of devices: <em>character devices</em> can be accessed one
character at a time, that is, the smallest unit of data which can be written to
or read from the device is a character (byte).
</p>

<p>
<em>Block devices</em> must be accessed in larger units called blocks, which
contain a number of characters.  Your hard disk is a block device.
</p>

<p>
You can read and write device files just as you can from other kinds of files,
though the file may well contain some strange incomprehensible-to-humans
gibberish.  Writing random data to these files is probably a Bad Idea.
Sometimes it's useful, though: for example, you can dump a postscript file into
the printer device <samp>/dev/lp0</samp>, or send modem commands to the device
file for the appropriate serial port.
</p>

<hr>

<h5><a name="s-files-advanced-types-devices-creating"></a>4.8.2.2.1 How to create device files.</h5>

<p>
<samp>MAKEDEV</samp>
</p>

<hr>

<h5><a name="s-files-advanced-types-devices-null"></a>4.8.2.2.2 <samp>/dev/null</samp></h5>

<p>
<samp>/dev/null</samp> is a special device file that discards anything you
write to it.  If you don't want something, throw it in <samp>/dev/null</samp>.
It's essentially a bottomless pit.  If you read <samp>/dev/null</samp>, you'll
get an end-of-file (EOF) character immediately.  <samp>/dev/zero</samp> is
similar, only if you read from it you get the <samp>\0</samp> character (not
the same as the number zero).
</p>

<hr>

<h4><a name="s-files-advanced-types-pipes"></a>4.8.2.3 Named pipes (FIFOs)</h4>

<p>
A named pipe is a file that acts like a pipe.  You put something into the file,
and it comes out the other end.  Thus it's called a FIFO, or
First-In-First-Out: the first thing you put in the pipe is the first thing to
come out the other end.
</p>

<p>
NOTE: The following explanation probably won't make much sense until you've
read about processes and using the shell.
</p>

<p>
If you write to a named pipe, the process which is writing to the pipe doesn't
terminate until the information being written is read from the pipe.  If you
read from a named pipe, the reading process waits until there's something to
read before terminating.  The size of the pipe is always zero - it doesn't
store data, it just links two processes like the shell <samp>|</samp>.
However, since this pipe has a name, the two processes don't have to be on the
same command line or even be run by the same user.
</p>

<p>
You can try it by doing the following:
</p>
<ol type="1" start="1" >
<li>
<p>
<samp>cd; mkfifo mypipe</samp>
</p>

<p>
Makes the pipe.
</p>
</li>
</ol>
<ol type="1" start="2" >
<li>
<p>
<samp>echo &quot;hello&quot; &gt; mypipe &amp;</samp>
</p>

<p>
Puts a process in the background which tries to write &quot;hello&quot; to the
pipe.  Notice that the process doesn't return from the background.  Try simply
<samp>echo &quot;hello&quot;</samp> without the redirection to see the
difference.
</p>
</li>
</ol>
<ol type="1" start="3" >
<li>
<p>
<samp>cat mypipe</samp>
</p>

<p>
At this point the <samp>echo</samp> process should return, and the
<samp>cat</samp> process will print <samp>hello</samp>.
</p>
</li>
</ol>
<ol type="1" start="4" >
<li>
<p>
<samp>rm mypipe</samp>
</p>

<p>
You can delete pipes just like any other file.
</p>
</li>
</ol>

<hr>

<h4><a name="s-files-advanced-types-sockets"></a>4.8.2.4 Sockets</h4>

<p>
Sockets are similar to pipes, only they work over the network.  This is how
your computer does networking, and forms the basis for the internet: you may
have heard of &quot;WinSock&quot;, which is sockets for Windows.
</p>

<p>
We won't go into these further, because you probably won't have occasion to use
them unless you're programming.  However, if you see a file marked with type
<samp>s</samp> on your computer, you know what it is.
</p>

<hr>

<h3><a name="s-files-advanced-proc"></a>4.8.3 The <samp>proc</samp> filesystem</h3>

<p>
The Linux kernel makes a special filesystem available, which is mounted under
<samp>/proc</samp> on Debian systems.  This is a &quot;pseudo-filesystem&quot;
- it doesn't really exist on any of your devices.
</p>

<p>
The <samp>proc</samp> filesystem contains information about the system and
running processes.  Some of the &quot;files&quot; in <samp>/proc</samp> are
reasonably understandable to humans (try typing <samp>cat /proc/meminfo</samp>)
and others are arcane collections of numbers.  Often, system utilities use
these to gather information and present it to you in a more understandable way.
</p>

<p>
People frequently panic when they notice one file in particular -
<samp>/proc/kcore</samp> - which is generally huge.  This is (more or less) a
copy of the contents of your computer's memory.  It's used to debug the kernel.
It doesn't actually exist anywhere, so don't worry about its size.
</p>

<p>
If you want to know about all the things in <samp>/proc</samp>, type <samp>man
5 proc</samp>.
</p>

<hr>

<h3><a name="s-files-advanced-permissions"></a>4.8.4 Advanced aspects of file permissions</h3>

<hr>

<h4><a name="s-files-advanced-permissions-absolute"></a>4.8.4.1 Using numeric arguments with <samp>chmod</samp></h4>

<p>
Earlier in this chapter, we briefly mentioned that you can set file permissions
using numbers.  The numeric notation is called an absolute mode, as opposed to
the symbolic notation (e.g.  <samp>u+rx</samp>) which is often called a
relative mode.  This is because the number specifies an exact mode to set, and
the symbol just specifies a change to make (e.g.  &quot;add user read and
execute permissions&quot;).
</p>

<p>
The numeric mode is a series of four octal digits or twelve binary digits.
Each octal (base eight) digit represents three binary digits: one octal digit
and three binary digits are two ways to represent the decimal digits 0 through
7.
</p>

<p>
Deriving a particular mode is pretty straightforward.  You simply add up the
modes you want to combine, or subtract modes you don't want.  For example, user
permissions, with only read permission turned on, would be <samp>100</samp> in
binary.  User permissions with write only would be <samp>010</samp> binary.
User permissions with read and write both turned on would be <samp>100 + 010 =
110</samp>.  Alternatively, you could put it in octal: <samp>4 + 2 = 6</samp>.
</p>

<p>
For the full mode, simply add up digits from this table:
</p>

<pre>
     0001        others, execute
     0002        others, write
     0004        others, read
     0010        group, execute
     0020        group, write
     0040        group, read
     0100        user, execute
     0200        user, write
     0400        user, read
     1000        sticky bit
     2000        set group id
     4000        set user id
</pre>

<p>
To use the table, first decide what permissions you want to set.  Then add up
the numbers for those permissions.  The total is your mode.  For example, to
get mode <samp>0755</samp>:
</p>

<pre>
       0001   o=x
       0004   o=r
       0010   g=x 
       0040   g=r
       0100   u=x
       0200   u=w
     + 0400   u=r
     -------
       0755  u=rwx go=rw
</pre>

<p>
You'd actually call this mode simply <samp>755</samp>, without the leading
<samp>0</samp>, because <samp>chmod</samp> automatically adds zeroes at the
beginning of the mode - so simply <samp>7</samp> becomes mode
<samp>0007</samp>.
</p>

<p>
To set a file to <samp>755</samp>, you'd type <samp>chmod 755 myfile</samp>.
</p>

<p>
<samp>755</samp> is a very common mode for directories, as it allows anyone to
use the directory but only the owner to create and delete files in the
directory.  <samp>644</samp> is the analogous mode for files, and it is also
very common.  It allows anyone to use the file but only the owner can change
it.  For executable files, <samp>755</samp> is a common mode; this is just
<samp>644</samp> plus execute permissions (<samp>644 + 111 = 755</samp>).
</p>

<hr>

<h4><a name="s-files-advanced-permissions-suid"></a>4.8.4.2 Making files suid/sgid</h4>

<hr>

<h4><a name="s-files-advanced-permissions-sticky"></a>4.8.4.3 Setting the sticky bit</h4>

<hr>

<h3><a name="s-files-advanced-undocumented"></a>4.8.5 Other concepts not yet covered, but should be</h3>

<p>
fsck, mke2fs, dd, fdisk, etc.
</p>

<p>
what package is a file in?
</p>

<p>
MSDOS vs.  Mac vs.  Unix text files
</p>

<p>
sync
</p>

<p>
chattr
</p>

<hr>

<p>
[ <a href="ch-manpages.html">previous</a> ]
[ <a href="index.html#contents">Contents</a> ]
[ <a href="ch1.html">1</a> ]
[ <a href="ch-logging-in.html">2</a> ]
[ <a href="ch-manpages.html">3</a> ]
[ 4 ]
[ <a href="ch-shells.html">5</a> ]
[ <a href="ch6.html">6</a> ]
[ <a href="ch7.html">7</a> ]
[ <a href="ch-editors.html">8</a> ]
[ <a href="ch9.html">9</a> ]
[ <a href="ch10.html">10</a> ]
[ <a href="ch11.html">11</a> ]
[ <a href="ch12.html">12</a> ]
[ <a href="ch13.html">13</a> ]
[ <a href="ch14.html">14</a> ]
[ <a href="ch15.html">15</a> ]
[ <a href="ch16.html">16</a> ]
[ <a href="ch-xwin.html">17</a> ]
[ <a href="ch18.html">18</a> ]
[ <a href="ch19.html">19</a> ]
[ <a href="ch20.html">20</a> ]
[ <a href="ch-shells.html">next</a> ]
</p>

<hr>

<p>
Debian User Reference Manual (Obsolete Documentation)
</p>

<address>
version 0.1, 29 Dezember 2009<br>
<br>
Ardo van Rangelrooij <code><a href="mailto:ardo@debian.org">ardo@debian.org</a></code><br>
Jason D. Waterman <code><a href="mailto:jwaterma@bbn.com">jwaterma@bbn.com</a></code><br>
Thalia L. Hooker <code><a href="mailto:th@visi.com">th@visi.com</a></code><br>
Havoc Pennington <code><a href="mailto:rhpennin@midway.uchicago.edu">rhpennin@midway.uchicago.edu</a></code><br>
Oliver Elphick - Maintainer <code><a href="mailto:Oliver.Elphick@lfix.co.uk">Oliver.Elphick@lfix.co.uk</a></code><br>
Bruce Evry <code><a href="mailto:bruce@fantek.org">bruce@fantek.org</a></code><br>
Karl-Heinz Zimmer <code><a href="mailto:khz@snafu.de">khz@snafu.de</a></code><br>
Andreas Franzen <code><a href="mailto:anfra@debian.org">anfra@debian.org</a></code><br>
<br>
</address>
<hr>

</body>

</html>

